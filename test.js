(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
"use strict";

/**
 * A numerical data type object.
 *
 * @class DataType
 * @constructor
 * @param {String} type - the abbreviated name of the data type. The following names are supported:
 *
 *     <table>
 *         <tr>
 *             <th>Abbreviated Name</th>
 *             <th>Interpretation</th>
 *         </tr>
 *         <tr>
 *             <td>"f32"</td>
 *             <td>Single-precision (32-bit) IEEE-754 floating-point type.</td>
 *         </tr>
 *         <tr>
 *             <td>"f64"</td>
 *             <td>Double-precision (64-bit) IEEE-754 floating-point type.</td>
 *         </tr>
 *     </table>
 *
 */
function DataType(type) {
	if (["f32", "f64"].indexOf(type) >= 0) {
		this.type = type;
		this.size = {"f32": 4, "f64": 8}[type];
		this.epsilon = {"f32": 1.1920928955078125e-7, "f64": 2.2204460492503131e-16}[type];
		this.arrayType = {"f32": Float32Array, "f64": Float64Array}[type];
	} else {
		throw new RangeError("Type " + type + " is not supported");
	}
}

/**
 * Compares two data type objects for equality.
 *
 * @method equals
 * @param {any} other - an object to compare to.
 */
DataType.prototype.equals = function(other) {
	return (other instanceof DataType) && (this.arrayType === other.arrayType);
};

module.exports = DataType;

},{}],2:[function(require,module,exports){
"use strict";

var util = require("./util");
var DataType = require("./DataType");

/**
 * An opaque N-dimensional array object.
 *
 * @class NDArray
 */

/**
 * Constructs an NDArray object without data.
 * Normally this constructor is called from array construction methods of computational contexts.
 * The calling function is responsible for initializing the data for the array.
 *
 * @constructor
 * @private
 */
function NDArray(shape, dataType, context) {
	if (typeof context === "undefined") {
		throw new Error("Context not defined");
	}
	if (!util.isPositiveIntArray(shape) && !util.isPositiveInt(shape)) {
		throw new TypeError(shape + " is not a valid array shape");
	}
	if (typeof dataType === "undefined") {
		dataType = new DataType("f64");
	} else if (!(dataType instanceof DataType)) {
		throw new TypeError(dataType + " is not an instance of DataType");
	}
	this.shape = shape;
	this.dataType = dataType;
	this._context = context;
	this.length = util.computeLength(this.shape);
	this._lockCount = 0;
	this._refCount = 1;
	this._isValid = true;
}

/**
 * Locks the array reference counter.
 * While the array is locked, functions and methods that operate on this array do not decrease its reference count.
 * The array can be locked multiple times, and would need just as many unlock calls to lift the lock.
 * If the array is not valid, this operation will fail with an error.
 *
 * @method lock
 * @chainable
 */
NDArray.prototype.lock = function() {
	if (!this.isValid()) {
		throw new Error("Attempted to lock an invalidated array");
	}
	this._lockCount++;
	return this;
};

/**
 * Unlocks the array reference counter.
 * Once the array is unlocked, functions and methods that operate on this array decrease its reference count and, if the reference count reaches zero, invalidate the array.
 * If the array was locked multiple times, it would need just as many unlock calls to lift the lock.
 * If the array is not locked, this operation will fail with an error.
 *
 * @method unlock
 * @chainable
 */
NDArray.prototype.unlock = function() {
	if (!this.isLocked()) {
		throw new Error("Attempted to lock a unlocked array");
	}
	this._lockCount--;
	return this;
};

/**
 * Checkes if the array is in the locked state.
 * If the array is not valid, this method return false.
 *
 * @method isLocked
 *
 * @return {Boolean} - true is the array is locked and false otherwise
 */
NDArray.prototype.isLocked = function() {
	return this._lockCount > 0;
};

/**
 * Increments the array reference count.
 * If the array is invalid or locked, this operation will fail with an error.
 *
 * @method retain
 * @chainable
 */
NDArray.prototype.retain = function() {
	if (!this.isValid()) {
		throw new Error("Attempted to release an invalidated array");
	}
	if (this.isLocked()) {
		throw new Error("Attempted to retain a locked array");
	}
	this._refCount++;
	return this;
};

/**
 * Decrements the array reference count. If the reference count turns zero, the array becomes invalid and its data buffer is deallocated.
 * If the array is invalid or locked, this operation will fail with an error.
 *
 * @method release
 * @chainable
 */
NDArray.prototype.release = function() {
	if (!this.isValid()) {
		throw new Error("Attempted to release an invalidated array");
	}
	if (this.isLocked()) {
		throw new Error("Attempted to release a locked array");
	}
	if (--this._refCount === 0) {
		this._context._invalidate(this);
	}
	return this;
};

/**
 * For a non-locked array, decrements the array reference count. If the reference count turns zero, the array becomes invalid and its data buffer is deallocated.
 * If the array is invalid, this operation will fail with an error.
 *
 * @method tryRelease
 * @chainable
 */
NDArray.prototype.tryRelease = function() {
	if (!this.isValid()) {
		throw new Error("Attempted to release an invalidated array");
	}
	if (!this.isLocked()) {
		if (--this._refCount === 0) {
			this._context._invalidate(this);
		}
	}
	return this;
};

/**
 * For a non-locked array, decrements the array reference count. If the reference count turns zero, the array becomes invalid and its data buffer is deallocated.
 * The array must be valid to perform this operation.
 *
 * @private
 * @method _tryRelease
 * @chainable
 */
NDArray.prototype._tryRelease = function() {
	if (!this.isLocked()) {
		if (--this._refCount === 0) {
			this._context._invalidate(this);
		}
	}
	return this;
};

/**
 * Invalidates the array and deallocates its data buffer, regardless of locks and reference count.
 * Calling this method on an invalidated array has no effect.
 *
 * @method invalidate
 * @chainable
 */
NDArray.prototype.invalidate = function() {
	if (this.isValid()) {
		this._context._invalidate(this);
		this._isValid = false;
		this._refCount = 0;
		this._lockCount = 0;
	}
	return this;
};

/**
 * Checkes if the array is in a valid state.
 * If the array is not in a valid state, its data buffer was deallocated, and any operations on the array will throw an error.
 *
 * @method isValid
 *
 * @return {Boolean} - true is the array is valid and false otherwise
 */
NDArray.prototype.isValid = function() {
	return this._isValid;
};

/**
 * Decrements the array reference count if the array is not locked.
 * This function does not invalidate the array when the reference count reach zero.
 * The caller is responsible for invalidating array if its reference count is zero after the operation.
 *
 * For a locked array the method has no effect and always returns true.
 *
 * @private
 * @method _decRef
 * @param {NDArray} array - the array to decrement the reference count for. Must be valid before the call.
 * @return {Boolean} - true if the reference count is non-zero after the operation and false otherwise.
 */
NDArray.prototype._decRef = function(array) {
	if (this._lockCount === 0) {
		--this._refCount;
	}
	return this._refCount !== 0;
};

/**
 * Increments the array reference count if the array is not locked.
 * For a locked array the method has no effect.
 *
 * @private
 * @method _incRef
 * @chainable
 * @param {NDArray} array - the array to increment the reference count for. Must be valid before the call, but may have zero reference count.
 */
NDArray.prototype._incRef = function(array) {
	if (this._lockCount === 0) {
		++this._refCount;
	}
	return this;
};

/**
 * Checks if the array is locked or has any references.
 *
 * @private
 * @method _hasRefs
 * @param {NDArray} array - the array to check. Must be valid before the call, but may have zero reference count.
 * @return {Boolean} - true if the array is locked or has references and false otherwise.
 */
NDArray.prototype._hasRefs = function(array) {
	return (this._lockCount !== 0) || (this._refCount !== 0);
};

/**
 * Invalidates the array if it valid, not locked, and has zero reference count.
 * Has no effect in all other cases.
 *
 * @private
 * @method _tryInvalidate
 * @param {NDArray} array - the array to try to invalidate. Can be invalid.
 * @return {Boolean} - true if the array was invalidated by this call and false otherwise.
 */
NDArray.prototype._tryInvalidate = function(array) {
	if (this.isValid() && !this._hasRefs()) {
		this._context._invalidate(this);
		this._isValid = false;
		return true;
	} else {
		return false;
	}
};

/**
 * Adds another array or a number to this array.
 *
 * @method add
 * @param {(NDArray|Number)} other - the array or scalar to be added.
 * @return {NDArray}
 */
NDArray.prototype.add = function(other) {
	return this._context.add(this, other);
};

/**
 * Subtracts another array or a number from this array.
 *
 * @method sub
 * @param {(NDArray|Number)} other - the array or scalar to be subtracted.
 * @return {NDArray}
 */
NDArray.prototype.sub = function(other) {
	return this._context.sub(this, other);
};

/**
 * Multiplies array elements by another array or by a number.
 *
 * @method mul
 * @param {(NDArray|Number)} other - the array or scalar to multiply elements by.
 * @return {NDArray}
 */
NDArray.prototype.mul = function(other) {
	return this._context.mul(this, other);
};

/**
 * Divides array elements by another array or by a number.
 *
 * @method div
 * @param {(NDArray|Number)} other - the array or scalar to divide elements by.
 * @return {NDArray}
 */
NDArray.prototype.div = function(other) {
	return this._context.div(this, other);
};

/**
 * Reduces array elements using minimum operation.
 * If the axis argument is provided, the method computes minimum of elements along the specified axis.
 * Otherwise, the method computes an all-array minimum of the elements and returns them as a 1-element array.
 *
 * @method min
 * @param {Number} [axis] - the axis along which the minimum is computed.
 * @return {NDArray}
 */
NDArray.prototype.min = function(axis) {
	return this._context.min(this, axis);
};

/**
 * Reduces array elements using maximum operation.
 * If the axis argument is provided, the method computes maximum of elements along the specified axis.
 * Otherwise, the method computes an all-array maximum of the elements and returns them as a 1-element array.
 *
 * @method min
 * @param {Number} [axis] - the axis along which the maximum is computed.
 * @return {NDArray}
 */
NDArray.prototype.max = function(axis) {
	return this._context.max(this, axis);
};

/**
 * Reduces array elements using sum operation.
 * If the axis argument is provided, the method computes sum of elements along the specified axis.
 * Otherwise, the method computes an all-array sum of the elements and returns them as a 1-element array.
 *
 * @method min
 * @param {Number} [axis] - the axis along which the sum is computed.
 * @return {NDArray}
 */
NDArray.prototype.sum = function(axis) {
	return this._context.sum(this, axis);
};

/**
 * Creates another array with the same data, but different dimensions.
 *
 * @method reshape
 * @param {(NDArray|Number)} other - dimensions of the new array.
 * @return {NDArray}
 */
NDArray.prototype.reshape = function(newShape) {
	return this._context.reshape(this, newShape);
};

/**
 * Duplicates array elements along the specified axis.
 *
 * @method repeat
 * @param {Number} repeats - the number of times to repeat each element.
 * @param {Number} axis - the axis along which the elements will be duplicated.
 * @return {NDArray}
 */
NDArray.prototype.repeat = function(repeats, axis) {
	return this._context.repeat(this, repeats, axis);
};

/**
 * Converts the data to a JavaScript Array.
 *
 * @method get
 * @async
 */
NDArray.prototype.get = function(callback) {
	this._context.get(this, callback);
};

module.exports = NDArray;

},{"./DataType":1,"./util":12}],3:[function(require,module,exports){
"use strict";

var NDArray = require("./NDArray");
var DataType = require("./DataType");
var allocator = require("./allocator");
var util = require("./util");
var requests = require("./requests.pb");
var Request = requests.Request;
var EmptyArrayRequest = requests.EmptyArrayRequest;
var DataArrayRequest = requests.DataArrayRequest;
var ConstArrayRequest = requests.ConstArrayRequest;
var LinspaceRequest = requests.LinspaceRequest;
var ReshapeRequest = requests.ReshapeRequest;
var RepeatRequest = requests.RepeatRequest;
var DeallocateRequest = requests.DeallocateRequest;
var FetchRequest = requests.FetchRequest;
var BinaryOperationRequest = requests.BinaryOperationRequest;
var BinaryConstOperationRequest = requests.BinaryConstOperationRequest;
var UnaryOperationRequest = requests.UnaryOperationRequest;
var ReductionRequest = requests.ReductionRequest;
var AxisReductionRequest = requests.AxisReductionRequest;
var DotOperationRequest = requests.DotOperationRequest;
var Response = require("./responses.pb").Response;

var dataTypeMap = {
	"f32": requests.DataType.FLOAT32,
	"f64": requests.DataType.FLOAT64
};

function PBContext(options, postMessage, callback) {
	var context = this;
	this._postMessage = postMessage;
	this._callbacks = {};
	this._callbacks[0] = function(limits) {
		callback(context, limits);
	};
}

PBContext.prototype._onMessage = function(message) {
	var response = Response.decode(message.data);
	var id = response.id;
	var callback = this._callbacks[id];
	delete this._callbacks[id];
	switch (response.type) {
		case Response.Type.INIT:
			var limits = {};
			var initResponse = response.initResponse;
			if (initResponse.concurrency !== null) {
				limits.concurrency = initResponse.concurrency;
			}
			callback(limits);
			break;
		case Response.Type.BARRIER:
			callback();
			break;
		case Response.Type.FETCH:
			callback(response.fetchResponse.dataBuffer.toArrayBuffer());
			break;
		case Response.Type.ERROR:
			break;
		case Response.Type.INFO:
			break;
	}
};

PBContext.prototype.empty = function(shape, dataType) {
	shape = util.checkShape(shape);
	if (typeof dataType === "undefined") {
		dataType = new DataType("f64");
	} else if (!(dataType instanceof DataType)) {
		throw new TypeError(dataType + " is not an instance of DataType");
	}
	var array = new NDArray(shape, dataType, this);
	array._id = allocator.newArrayId();

	var request = new Request();
	request.id = allocator.newMessageId();
	request.type = Request.Type.EMPTY_ARRAY;
	var emptyArrayRequest = new EmptyArrayRequest();
	emptyArrayRequest.idOut = array._id;
	emptyArrayRequest.shape = shape;
	emptyArrayRequest.dataType = dataTypeMap[dataType.type];
	request.emptyArrayRequest = emptyArrayRequest;
	this._postMessage(request.encodeAB());

	return array;
};

PBContext.prototype.zeros = function(shape, dataType) {
	shape = util.checkShape(shape);
	if (typeof dataType === "undefined") {
		dataType = new DataType("f64");
	} else if (!(dataType instanceof DataType)) {
		throw new TypeError(dataType + " is not an instance of DataType");
	}
	var array = new NDArray(shape, dataType, this);
	array._id = allocator.newArrayId();

	var request = new Request();
	request.id = allocator.newMessageId();
	request.type = Request.Type.CONST_ARRAY;
	var constArrayRequest = new ConstArrayRequest();
	constArrayRequest.idOut = array._id;
	constArrayRequest.shape = shape;
	constArrayRequest.dataType = dataTypeMap[dataType.type];
	constArrayRequest.fillValue = 0.0;
	request.constArrayRequest = constArrayRequest;
	this._postMessage(request.encodeAB());

	return array;
};

PBContext.prototype.ones = function(shape, dataType) {
	shape = util.checkShape(shape);
	if (typeof dataType === "undefined") {
		dataType = new DataType("f64");
	} else if (!(dataType instanceof DataType)) {
		throw new TypeError(dataType + " is not an instance of DataType");
	}
	var array = new NDArray(shape, dataType, this);
	array._id = allocator.newArrayId();

	var request = new Request();
	request.id = allocator.newMessageId();
	request.type = Request.Type.CONST_ARRAY;
	var constArrayRequest = new ConstArrayRequest();
	constArrayRequest.idOut = array._id;
	constArrayRequest.shape = shape;
	constArrayRequest.dataType = dataTypeMap[dataType.type];
	constArrayRequest.fillValue = 1.0;
	request.constArrayRequest = constArrayRequest;
	this._postMessage(request.encodeAB());

	return array;
};

PBContext.prototype.array = function(data, dataType) {
	var shape = [];
	util.discoverArrayShapeRecursive(data, shape, 0);
	if (typeof dataType === "undefined") {
		dataType = new DataType("f64");
	} else if (!(dataType instanceof DataType)) {
		throw new TypeError(dataType + " is not an instance of DataType");
	}
	var array = new NDArray(shape, dataType, this);
	array._id = allocator.newArrayId();
	var arrayBuffer = new dataType.arrayType(array.length);
	util.copyArrayDataRecursive(arrayBuffer, data, shape, 0, 0);

	var request = new Request();
	request.id = allocator.newMessageId();
	request.type = Request.Type.DATA_ARRAY;
	var dataArrayRequest = new DataArrayRequest();
	dataArrayRequest.idOut = array._id;
	dataArrayRequest.shape = shape;
	dataArrayRequest.dataType = dataTypeMap[dataType.type];
	dataArrayRequest.dataBuffer = arrayBuffer.buffer;
	request.dataArrayRequest = dataArrayRequest;
	this._postMessage(request.encodeAB());

	return array;
};

PBContext.prototype.linspace = function(start, stop, samples, includeStop) {
	if (!util.isReal(start)) {
		throw new TypeError(start + " is not a real number");
	}
	if (!util.isReal(stop)) {
		throw new TypeError(stop + " is not a real number");
	}
	if (typeof samples === "undefined") {
		/* Default value in NumPy */
		samples = 50;
	} else if (!util.isInt(samples)) {
		throw new TypeError(samples + " is not an integer");
	} else if (samples <= 0) {
		throw new RangeError("The number of samples must be positive");
	}
	if (typeof includeStop === "undefined") {
		includeStop = true;
	}
	if (includeStop && (samples === 1)) {
		throw new RangeError("The number of samples must be a least 2 (for start and end points)");
	}
	var dataType = new DataType("f64");
	var array = new NDArray([samples], dataType, this);
	array._id = allocator.newArrayId();

	var request = new Request();
	request.id = allocator.newMessageId();
	request.type = Request.Type.LINSPACE;
	var linspaceRequest = new LinspaceRequest();
	linspaceRequest.idOut = array._id;
	linspaceRequest.start = start;
	linspaceRequest.stop = stop;
	linspaceRequest.samples = samples;
	linspaceRequest.closed = includeStop;
	linspaceRequest.dataType = dataTypeMap[dataType.type];
	request.linspaceRequest = linspaceRequest;
	this._postMessage(request.encodeAB());

	return array;
};

PBContext.prototype.reshape = function(a, shape) {
	util.checkNDArray(a, "a");
	shape = util.checkShape(shape);
	if (util.computeLength(shape) !== a.length) {
		throw new RangeError("The shape is not compatible with the array");
	}
	var idA = a._id;
	var releaseA = !a._decRef();
	var out = new NDArray(shape, a.dataType, this);
	if (releaseA) {
		out._id = idA;
		a._id = 0;
		releaseA = false;
	} else {
		out._id = allocator.newArrayId();
	}

	var request = new Request();
	request.id = allocator.newMessageId();
	request.type = Request.Type.RESHAPE;
	var reshapeRequest = new ReshapeRequest();
	reshapeRequest.idA = idA;
	reshapeRequest.idOut = out._id;
	reshapeRequest.shapeOut = shape;
	request.reshapeRequest = reshapeRequest;
	this._postMessage(request.encodeAB());

	a._tryInvalidate();
	return out;
};

PBContext.prototype.repeat = function(a, repeats, axis, out) {
	util.checkNDArray(a, "a");
	repeats = util.checkRepeats(repeats);
	axis = util.checkAxis(axis, a.shape.length);
	var shapeA = a.shape;
	var shapeOut = shapeA.slice(0);
	shapeOut[axis] *= repeats;
	if (typeof out === "undefined") {
		out = new NDArray(shapeOut, a.dataType, this);
		out._id = allocator.newArrayId();
	} else {
		util.checkNDArray(out, "out");
		util.checkShapesCompatibility(out.shape, shapeOut);
		util.checkDataTypesCompatibility(a.dataType, out.dataType);
		out._incRef();
	}
	var idA = a._id;
	if (!a._decRef()) {
		idA = -idA;
		a._id = 0;
	}

	var request = new Request();
	request.id = allocator.newMessageId();
	request.type = Request.Type.REPEAT;
	var repeatRequest = new RepeatRequest();
	repeatRequest.idA = idA;
	repeatRequest.idOut = out._id;
	repeatRequest.axis = axis;
	repeatRequest.repeats = repeats;
	request.repeatRequest = repeatRequest;
	this._postMessage(request.encodeAB());

	a._tryInvalidate();
	return out;
};

PBContext.prototype._invalidate = function(array) {
	if (array._id !== 0) {
		var request = new Request();
		request.id = allocator.newMessageId();
		request.type = Request.Type.DEALLOCATE;
		var deallocateRequest = new DeallocateRequest();
		deallocateRequest.idA = array._id;
		request.deallocateRequest = deallocateRequest;
		this._postMessage(request.encodeAB());
	}
};

PBContext.prototype.fetch = function() {
	if (arguments.length === 0) {
		throw new Error("Callback argument missing");
	}
	var callback = arguments[arguments.length - 1];
	/* Validate arguments */
	if (arguments.length === 1) {
		throw new Error("At least one NDArray argument expected");
	}
	for (var i = 0; i < arguments.length - 1; ++i) {
		util.checkNDArray(arguments[i], "argument " + i);
	}
	var release = new Array(arguments.length - 1);
	for (var i = 0; i < arguments.length - 1; ++i) {
		release[i] = !arguments[i]._decRef();
	}
	var callbackWaitArguments = arguments.length - 1;
	var callbackArguments = new Array(callbackWaitArguments);
	for (var i = 0; i < callbackWaitArguments; i++) {
		var array = arguments[i];
		var messageId = allocator.newMessageId();
		this._callbacks[messageId] = (function(i, ArrayType) {
			return function(buffer) {
				callbackArguments[i] = new ArrayType(buffer);
				if (--callbackWaitArguments === 0) {
					callback.apply(null, callbackArguments);
				}
			};
		})(i, array.dataType.arrayType);
		var arrayId = array._id;
		if (release[i]) {
			array._id = 0;
			arrayId = -arrayId;
			array._tryInvalidate();
		}

		var request = new Request();
		request.id = messageId;
		request.type = Request.Type.FETCH;
		var fetchRequest = new FetchRequest();
		fetchRequest.idA = arrayId;
		request.fetchRequest = fetchRequest;
		this._postMessage(request.encodeAB());
	}
};

PBContext.prototype.get = function() {
	if (arguments.length === 0) {
		throw new Error("Callback argument missing");
	}
	var callback = arguments[arguments.length - 1];
	/* Validate arguments */
	if (arguments.length === 1) {
		throw new Error("At least one NDArray argument expected");
	}
	for (var i = 0; i < arguments.length - 1; ++i) {
		util.checkNDArray(arguments[i], "argument " + i);
	}
	var release = new Array(arguments.length - 1);
	for (var i = 0; i < arguments.length - 1; ++i) {
		release[i] = !arguments[i]._decRef();
	}
	var callbackWaitArguments = arguments.length - 1;
	var callbackArguments = new Array(callbackWaitArguments);
	for (var i = 0; i < callbackWaitArguments; i++) {
		var array = arguments[i];
		var messageId = allocator.newMessageId();
		if (array.shape.length === 0) {
			this._callbacks[messageId] = (function(i, ArrayType) {
				return function(buffer) {
					var typedArray = new ArrayType(buffer);
					callbackArguments[i] = typedArray[0];
					if (--callbackWaitArguments === 0) {
						callback.apply(null, callbackArguments);
					}
				};
			})(i, array.dataType.arrayType);
		} else {
			this._callbacks[messageId] = (function(i, ArrayType, shape) {
				return function(buffer) {
					var jsarray = new Array(shape[0]);
					util.createArrayRecursive(new ArrayType(buffer), jsarray, shape, 0, 0);
					callbackArguments[i] = jsarray;
					if (--callbackWaitArguments === 0) {
						callback.apply(null, callbackArguments);
					}
				};
			})(i, array.dataType.arrayType, array.shape);
		}
		var arrayId = array._id;
		if (release[i]) {
			array._id = 0;
			arrayId = -arrayId;
			array._tryInvalidate();
		}

		var request = new Request();
		request.id = messageId;
		request.type = Request.Type.FETCH;
		var fetchRequest = new FetchRequest();
		fetchRequest.idA = arrayId;
		request.fetchRequest = fetchRequest;
		this._postMessage(request.encodeAB());
	}
};

PBContext.prototype.info = function(callback) {
	throw new Error("Not implemented");
/*	var messageId = allocator.newMessageId();
	messageCallbacks[messageId] = callback;
	this._pnaclObject.postMessage({
		"id": messageId,
		"command": "info"
	});*/
};

PBContext.prototype.barrier = function(callback) {
	var messageId = allocator.newMessageId();
	this._callbacks[messageId] = callback;

	var request = new Request();
	request.id = messageId;
	request.type = Request.Type.BARRIER;
	this._postMessage(request.encodeAB());
};

var binaryArithOp = function(a, b, out, context, operation, constOperation, revConstOperation) {
	var shapeOut = null, dataTypeOut = null, releaseIdA = false, releaseIdB = false, idA = 0, idB = 0;
	if (a instanceof NDArray) {
		idA = a._id;
		shapeOut = a.shape;
		dataTypeOut = a.dataType;
		if (b instanceof NDArray) {
			idB = b._id;
			util.checkShapesCompatibility(a.shape, b.shape);
			util.checkDataTypesCompatibility(a.dataType, b.dataType);
		} else if (!util.isNumber(b)) {
			throw new TypeError("Unsupported type of b");
		}
	} else if (util.isNumber(a)) {
		idB = b._id;
		shapeOut = b.shape;
		dataTypeOut = b.dataType;
		util.checkNDArray(b, "b");
	} else {
		throw new TypeError("Unsupported type of a");
	}
	/* The IDs of a and b must be invalidated before we assign ID to out because a/b and out may be the same arrays */
	if (idA !== 0) {
		releaseIdA = !a._decRef();
		if (releaseIdA) {
			a._id = 0;
		}
	}
	if (idB !== 0) {
		releaseIdB = !b._decRef();
		if (releaseIdB) {
			b._id = 0;
		}
	}
	try {
		if (typeof out === "undefined") {
			out = new NDArray(shapeOut, dataTypeOut, context);
			if (releaseIdA) {
				out._id = idA;
				releaseIdA = false;
			} else if (releaseIdB) {
				out._id = idB;
				releaseIdB = false;
			} else {
				out._id = allocator.newArrayId();
			}
		} else {
			util.checkNDArray(out, "out");
			util.checkShapesCompatibility(shapeOut, out.shape);
			util.checkDataTypesCompatibility(dataTypeOut, out.dataType);
			out._incRef();
		}
		var request = new Request();
		request.id = allocator.newMessageId();
		if (idA !== 0) {
			if (idB !== 0) {
				request.type = Request.Type.BINARY_OPERATION;
				var binaryOperationRequest = new BinaryOperationRequest();
				binaryOperationRequest.type = operation;
				binaryOperationRequest.idA = (releaseIdA ? -idA : idA);
				binaryOperationRequest.idB = (releaseIdB ? -idB : idB);
				binaryOperationRequest.idOut = out._id;
				request.binaryOperationRequest = binaryOperationRequest;
				context._postMessage(request.encodeAB());
			} else {
				request.type = Request.Type.BINARY_CONST_OPERATION;
				var binaryConstOperationRequest = new BinaryConstOperationRequest();
				binaryConstOperationRequest.type = constOperation;
				binaryConstOperationRequest.idA = (releaseIdA ? -idA : idA);
				binaryConstOperationRequest.valueB = b;
				binaryConstOperationRequest.idOut = out._id;
				request.binaryConstOperationRequest = binaryConstOperationRequest;
				context._postMessage(request.encodeAB());
			}
		} else {
			request.type = Request.Type.BINARY_CONST_OPERATION;
			var binaryConstOperationRequest = new BinaryConstOperationRequest();
			binaryConstOperationRequest.type = revConstOperation;
			binaryConstOperationRequest.idA = (releaseIdB ? -idB : idB);
			binaryConstOperationRequest.valueB = a;
			binaryConstOperationRequest.idOut = out._id;
			request.binaryConstOperationRequest = binaryConstOperationRequest;
			context._postMessage(request.encodeAB());
		}
	} catch (e) {
		/* Restore the previous state */
		if (idA !== 0) {
			a._id = idA;
			a._incRef();
		}
		if (idB !== 0) {
			b._id = idB;
			b._incRef();
		}
		throw e;
	}
	/*
	 * If a or b are arrays, invalidate them as needed.
	 * If a/b and out are the same, their ref count is non-zero at this point, so they will stay valid.
	 */
	if (idA !== 0) {
		a._tryInvalidate();
	}
	if (idB !== 0) {
		b._tryInvalidate();
	}
	return out;
};

var unaryArithOp = function(a, out, context, operation) {
	util.checkNDArray(a, "a");
	var idA = a._id;
	var releaseIdA = !a._decRef();
	/* The ID of a must be invalidated before we assign ID to out because a and out may be the same arrays */
	if (releaseIdA) {
		a._id = 0;
	}
	try {
		if (typeof out === "undefined") {
			out = new NDArray(a.shape, a.dataType, context);
			if (releaseIdA) {
				out._id = idA;
				releaseIdA = false;
			} else {
				out._id = allocator.newArrayId();
			}
		} else {
			util.checkNDArray(out, "out");
			util.checkShapesCompatibility(a.shape, out.shape);
			util.checkDataTypesCompatibility(a.dataType, out.dataType);
			out._incRef();
		}
	} catch (e) {
		/* Restore the previous state */
		a._id = idA;
		a._incRef();
		throw e;
	}

	var request = new Request();
	request.id = allocator.newMessageId();
	request.type = Request.Type.UNARY_OPERATION;
	var unaryOperationRequest = new UnaryOperationRequest();
	unaryOperationRequest.type = operation;
	unaryOperationRequest.idA = (releaseIdA ? -idA : idA);
	unaryOperationRequest.idOut = out._id;
	request.unaryOperationRequest = unaryOperationRequest;
	context._postMessage(request.encodeAB());

	/* If a and out are the same, their ref count is non-zero at this point, so they will stay valid. */
	a._tryInvalidate();
	return out;
};

var reduceArithOp = function(a, out, context, operation) {
	util.checkNDArray(a, "a");
	var idA = a._id;
	var releaseIdA = !a._decRef();
	if (releaseIdA) {
		a._id = 0;
	}
	try {
		if (typeof out === "undefined") {
			out = new NDArray([], a.dataType, context);
			out._id = allocator.newArrayId();
		} else {
			util.checkNDArray(out, "out");
			util.checkShapesCompatibility(out.shape, []);
			util.checkDataTypesCompatibility(a.dataType, out.dataType);
			out._incRef();
		}
	} catch (e) {
		/* Restore the previous state */
		a._id = idA;
		a._incRef();
		throw e;
	}

	var request = new Request();
	request.id = allocator.newMessageId();
	request.type = Request.Type.REDUCTION_OPERATION;
	var reductionRequest = new ReductionRequest();
	reductionRequest.type = operation;
	reductionRequest.idA = (releaseIdA ? -idA : idA);
	reductionRequest.idOut = out._id;
	request.reductionRequest = reductionRequest;
	context._postMessage(request.encodeAB());

	a._tryInvalidate();
	return out;
};

var axisReduceArithOp = function(a, axis, out, context, operation) {
	util.checkNDArray(a, "a");
	var idA = a._id;
	var releaseIdA = !a._decRef();
	if (releaseIdA) {
		a._id = 0;
	}
	try {
		util.checkAxis(axis);
		if (typeof out === "undefined") {
			out = new NDArray(util.computeAxisReductionOutShape(a.shape, axis), a.dataType, context);
			out._id = allocator.newArrayId();
		} else {
			util.checkNDArray(out, "out");
			util.checkShapesCompatibility(out.shape, []);
			util.checkDataTypesCompatibility(a.dataType, out.dataType);
			out._incRef();
		}
	} catch (e) {
		/* Restore the previous state */
		a._id = idA;
		a._incRef();
		throw e;
	}

	var request = new Request();
	request.id = allocator.newMessageId();
	request.type = Request.Type.AXIS_REDUCTION_OPERATION;
	var axisReductionRequest = new AxisReductionRequest();
	axisReductionRequest.type = operation;
	axisReductionRequest.idA = (releaseIdA ? -idA : idA);
	axisReductionRequest.axis = axis;
	axisReductionRequest.idOut = out._id;
	request.axisReductionRequest = axisReductionRequest;
	context._postMessage(request.encodeAB());

	a._tryInvalidate();
	return out;
};

var dotArithOp = function(a, b, out, context) {
	util.checkNDArray(a, "a");
	util.checkNDArray(b, "b");
	util.checkDataTypesCompatibility(a.dataType, b.dataType);
	var idA = a._id;
	var releaseIdA = !a._decRef();
	if (releaseIdA) {
		a._id = 0;
	}
	var idB = b._id;
	var releaseIdB = !b._decRef();
	if (releaseIdB) {
		b._id = 0;
	}
	try {
		if (typeof out === "undefined") {
			var shapeA = a.shape;
			var shapeB = b.shape;
			var axisA = Math.max(shapeA.length - 1, 0);
			var axisB = Math.max(shapeB.length - 2, 0);
			if (shapeA[axisA] != shapeB[axisB]) {
				throw new TypeError("Mismatch in reduction dimensions");
			}
			var shapeOut = [];
			for (var i = 0; i < axisA; i++) {
				shapeOut.push(shapeA[i]);
			}
			if (shapeB.length > 1) {
				for (var i = 0; i < axisB; i++) {
					shapeOut.push(shapeB[i]);
				}
				shapeOut.push(shapeB[shapeB.length - 1]);
			}
			out = new NDArray(shapeOut, a.dataType, context);
			out._id = allocator.newArrayId();
		} else if (out instanceof NDArray) {
			util.checkNDArray(out, "out");
			util.checkDataTypesCompatibility(a.dataType, out.dataType);
			throw new Error("Not implemented");
		}
	} catch (e) {
		/* Restore the previous state */
		a._id = idA;
		a._incRef();
		b._id = idB;
		b._incRef();
		throw e;
	}

	var request = new Request();
	request.id = allocator.newMessageId();
	request.type = Request.Type.DOT_OPERATION;
	var dotOperationRequest = new DotOperationRequest();
	dotOperationRequest.idA = (releaseIdA ? -idA : idA);
	dotOperationRequest.idB = (releaseIdB ? -idB : idB);
	dotOperationRequest.idOut = out._id;
	request.dotOperationRequest = dotOperationRequest;
	context._postMessage(request.encodeAB());

	a._tryInvalidate();
	b._tryInvalidate();
	return out;
};

PBContext.prototype.add = function(a, b, out) {
	return binaryArithOp(a, b, out, this,
		BinaryOperationRequest.Type.ADD,
		BinaryConstOperationRequest.Type.ADDC,
		BinaryConstOperationRequest.Type.ADDC);
};

PBContext.prototype.sub = function(a, b, out) {
	return binaryArithOp(a, b, out, this,
		BinaryOperationRequest.Type.SUB,
		BinaryConstOperationRequest.Type.SUBC,
		BinaryConstOperationRequest.Type.SUBRC);
};

PBContext.prototype.mul = function(a, b, out) {
	return binaryArithOp(a, b, out, this,
		BinaryOperationRequest.Type.MUL,
		BinaryConstOperationRequest.Type.MULC,
		BinaryConstOperationRequest.Type.MULC);
};

PBContext.prototype.div = function(a, b, out) {
	return binaryArithOp(a, b, out, this,
		BinaryOperationRequest.Type.DIV,
		BinaryConstOperationRequest.Type.DIVC,
		BinaryConstOperationRequest.Type.DIVRC);
};

PBContext.prototype.neg = function(a, out) {
	return unaryArithOp(a, out, this,
		UnaryOperationRequest.Type.NEG);
};

PBContext.prototype.abs = function(a, out) {
	return unaryArithOp(a, out, this,
		UnaryOperationRequest.Type.ABS);
};

PBContext.prototype.exp = function(a, out) {
	return unaryArithOp(a, out, this,
		UnaryOperationRequest.Type.EXP);
};

PBContext.prototype.log = function(a, out) {
	return unaryArithOp(a, out, this,
		UnaryOperationRequest.Type.LOG);
};

PBContext.prototype.sqrt = function(a, out) {
	return unaryArithOp(a, out, this,
		UnaryOperationRequest.Type.SQRT);
};

PBContext.prototype.square = function(a, out) {
	return unaryArithOp(a, out, this,
		UnaryOperationRequest.Type.SQUARE);
};

PBContext.prototype.min = function(a, axis) {
	if (typeof axis === "undefined") {
		return reduceArithOp(a, undefined, this,
			ReductionRequest.Type.MIN);
	} else if (util.isInt(axis)) {
		return axisReduceArithOp(a, axis, undefined, this,
			AxisReductionRequest.Type.MIN);
	} else {
		throw new TypeError("Unsupported axis type");
	}
};

PBContext.prototype.max = function(a, axis) {
	if (typeof axis === "undefined") {
		return reduceArithOp(a, undefined, this,
			ReductionRequest.Type.MAX);
	} else if (util.isInt(axis)) {
		return axisReduceArithOp(a, axis, undefined, this,
			AxisReductionRequest.Type.MAX);
	} else {
		throw new TypeError("Unsupported axis type");
	}
};

PBContext.prototype.sum = function(a, axis) {
	if (typeof axis === "undefined") {
		return reduceArithOp(a, undefined, this,
			ReductionRequest.Type.SUM);
	} else if (util.isInt(axis)) {
		return axisReduceArithOp(a, axis, undefined, this,
			AxisReductionRequest.Type.SUM);
	} else {
		throw new TypeError("Unsupported axis type");
	}
};

PBContext.prototype.dot = function(a, b, out) {
	return dotArithOp(a, b, out, this);
};

module.exports = PBContext;

},{"./DataType":1,"./NDArray":2,"./allocator":5,"./requests.pb":10,"./responses.pb":11,"./util":12}],4:[function(require,module,exports){
"use strict";

var PBContext = require("./PBContext");

function PNaClContext(options, callback) {
	var self = this;
	this._pnaclObject = document.createElement("object");
	this._pnaclObject.width = 0;
	this._pnaclObject.height = 0;
	this._pnaclObject.data = PNaClContext.getManifestURL(options.baseUrl);
	this._pnaclObject.type = "application/x-pnacl";
	this._pnaclObject.addEventListener("message", function(e) {
		self._messagingContext._onMessage(e);
	}, true);
	this._messagingContext = new PBContext(options, function(message) {
		self._pnaclObject.postMessage(message);
	}, callback);
	document.body.appendChild(this._pnaclObject);
}

PNaClContext.isSupported = function() {
	try {
		return (typeof navigator.mimeTypes["application/x-pnacl"]) !== "undefined";
	} catch (e) {
	}
	return false;
};

PNaClContext.getManifestURL = function(baseUrl) {
	if (baseUrl) {
		return baseUrl + "furious.nmf";
	} else {
		return "furious.nmf";
	}
};

PNaClContext.prototype.empty = function(shape, dataType) {
	return this._messagingContext.empty(shape, dataType);
};

PNaClContext.prototype.zeros = function(shape, dataType) {
	return this._messagingContext.zeros(shape, dataType);
};

PNaClContext.prototype.ones = function(shape, dataType) {
	return this._messagingContext.ones(shape, dataType);
};

PNaClContext.prototype.array = function(data, dataType) {
	return this._messagingContext.array(data, dataType);
};

PNaClContext.prototype.linspace = function(start, stop, samples, closed) {
	return this._messagingContext.linspace(start, stop, samples, closed);
};

PNaClContext.prototype.reshape = function(a, shape) {
	return this._messagingContext.reshape(a, shape);
};

PNaClContext.prototype.repeat = function(a, repeats, axis, out) {
	return this._messagingContext.repeat(a, repeats, axis, out);
};

PNaClContext.prototype._invalidate = function(array) {
	return this._messagingContext._invalidate(array);
};

PNaClContext.prototype.fetch = function() {
	this._messagingContext.fetch.apply(this._messagingContext, arguments);
};

PNaClContext.prototype.get = function() {
	this._messagingContext.get.apply(this._messagingContext, arguments);
};

PNaClContext.prototype.info = function(callback) {
	this._messagingContext.info(callback);
};

PNaClContext.prototype.barrier = function(callback) {
	this._messagingContext.barrier(callback);
};

PNaClContext.prototype.add = function(a, b, out) {
	return this._messagingContext.add(a, b, out);
};

PNaClContext.prototype.sub = function(a, b, out) {
	return this._messagingContext.sub(a, b, out);
};

PNaClContext.prototype.mul = function(a, b, out) {
	return this._messagingContext.mul(a, b, out);
};

PNaClContext.prototype.div = function(a, b, out) {
	return this._messagingContext.div(a, b, out);
};

PNaClContext.prototype.neg = function(a, out) {
	return this._messagingContext.neg(a, out);
};

PNaClContext.prototype.abs = function(a, out) {
	return this._messagingContext.abs(a, out);
};

PNaClContext.prototype.exp = function(a, out) {
	return this._messagingContext.exp(a, out);
};

PNaClContext.prototype.log = function(a, out) {
	return this._messagingContext.log(a, out);
};

PNaClContext.prototype.sqrt = function(a, out) {
	return this._messagingContext.sqrt(a, out);
};

PNaClContext.prototype.square = function(a, out) {
	return this._messagingContext.square(a, out);
};

PNaClContext.prototype.min = function(a, axis) {
	return this._messagingContext.min(a, axis);
};

PNaClContext.prototype.max = function(a, axis) {
	return this._messagingContext.max(a, axis);
};

PNaClContext.prototype.sum = function(a, axis) {
	return this._messagingContext.sum(a, axis);
};

PNaClContext.prototype.dot = function(a, b, out) {
	return this._messagingContext.dot(a, b, out);
};

module.exports = PNaClContext;

},{"./PBContext":3}],5:[function(require,module,exports){
"use strict";

var messageId = 1;
var arrayId = 1;

exports.newMessageId = function() {
	var id = messageId;
	messageId = (messageId+1)|0;
	return id;
};

exports.newArrayId = function () {
	var id = arrayId;
	arrayId = (arrayId+1)|0;
	return id;
};

},{}],6:[function(require,module,exports){
"use strict";

/**
 * Provides information and support functions
 *
 * @class furious
 */

var DataType = require("./DataType");
var JSContext = require("./js/JSContext");
var WebWorkerContext = require("./js/WebWorkerContext");
var PNaClContext = require("./PNaClContext");
var WebCLContext = require("./webcl/WebCLContext");

var currentScriptUri = null;
try {
	currentScriptUri = document.currentScript.src;
} catch (e) {
	try {
		var scripts = document.getElementsByTagName("script");
		currentScriptUri = scripts[scripts.length - 1].src;
	} catch (e) {
	}
}
var currentScriptDir = null;
if (currentScriptUri !== null) {
	var separatorPos = currentScriptUri.lastIndexOf("/");
	var currentScriptDir = currentScriptUri.substr(0, separatorPos + 1);
}

/**
 * Initializes a computational context.
 *
 * @static
 * @method init
 * @async
 *
 * @param {String} [backend] - A string identifier for the backend to use. The following values are supported:
 *
 *     <table>
 *         <tr>
 *             <th>Backend Identifier</th>
 *             <th>Interpretation</th>
 *         </tr>
 *         <tr>
 *             <td>"javascript"</td>
 *             <td>JavaScript backend. Works in all browsers and Node.js, but can not deliver optimal performance.</td>
 *         </tr>
 *         <tr>
 *             <td>"pnacl"</td>
 *             <td>Portable Native Client (PNaCl) backend. Works in Chromium-based browsers. Can accelerate computations through the use of advanced CPU optimization technologies, such as multi-threading and SIMD instructions.</td>
 *         </tr>
 *         <tr>
 *             <td>"webcl"</td>
 *             <td>WebCL backend. Works in browsers and Node.js when a WebCL plugin is available. Can use full power of CPUs and GPUs to accelerate computations.</td>
 *         </tr>
 *     </table>
 *
 * @param {Object} options - Backend-specific options.
 * @param {Function} callback - A callback function that is called when the backend finish initialization.
 * @param {Context} callback.context - A ready to use computational context.
 */
var init = function(backend, options, callback) {
	if (typeof callback === "undefined") {
		if (typeof options === "undefined") {
			/* Called with one parameter: callback */
			callback = backend;
			options = undefined;
			backend = undefined;
		} else {
			/* Called with two parameters: backend and callback */
			callback = options;
			options = undefined;
		}
	}
	if (typeof backend === "undefined") {
		backend = getDefaultBackend();
	}
	if (typeof options === "undefined") {
		options = {};
	}
	if (backend === "javascript") {
		var async = options.async;
		if (typeof async === "undefined") {
			async = WebWorkerContext.isSupported();
		}
		if (async) {
			options.baseUrl = currentScriptDir;
			return new WebWorkerContext(options, callback);
		} else {
			return new JSContext(options, callback);
		}
	} else if (backend === "pnacl") {
		options.baseUrl = currentScriptDir;
		return new PNaClContext(options, callback);
	} else if (backend === "webcl") {
		return new WebCLContext(options, callback);
	} else {
		throw new Error("Unsupported backend: " + backend);
	}
};

/**
 * Detects the optimal backend supported by the browser or JavaScript engine.
 *
 * @static
 * @method getDefaultBackend
 *
 * @return {String} - Default backend identifier from the following table:
 *
 *     <table>
 *         <tr>
 *             <th>Backend Identifier</th>
 *             <th>Interpretation</th>
 *         </tr>
 *         <tr>
 *             <td>"javascript"</td>
 *             <td>JavaScript backend. Works in all browsers and Node.js, but can not deliver optimal performance.</td>
 *         </tr>
 *         <tr>
 *             <td>"asmjs"</td>
 *             <td>Asm.js backend. Works in Firefox 29 and later. Can accelerate computations with a limited use of native CPU instructions.</td>
 *         </tr>
 *         <tr>
 *             <td>"pnacl"</td>
 *             <td>Portable Native Client (PNaCl) backend. Works in Chromium-based browsers. Can accelerate computations through the use of advanced CPU optimization technologies, such as multi-threading and SIMD instructions.</td>
 *         </tr>
 *         <tr>
 *             <td>"webcl"</td>
 *             <td>WebCL backend. Works in browsers and Node.js when a WebCL plugin is available. Can use full power of CPUs and GPUs to accelerate computations.</td>
 *         </tr>
 *     </table>
 */
var getDefaultBackend = function() {
	if (WebCLContext.isUsable()) {
		return "webcl";
	} else if (PNaClContext.isSupported()) {
		return "pnacl";
	} else {
		return "javascript";
	}
};

/**
 * Detects which backends are supported by the system.
 *
 * @static
 * @method getSupportedBackends
 *
 * @return {String[]} - An array of supported backend identifiers in priority order (prioritized backends first). The following identifiers could be present:
 *
 *     <table>
 *         <tr>
 *             <th>Backend Identifier</th>
 *             <th>Interpretation</th>
 *         </tr>
 *         <tr>
 *             <td>"javascript"</td>
 *             <td>JavaScript backend. Works in all browsers and Node.js, but can not deliver optimal performance.</td>
 *         </tr>
 *         <tr>
 *             <td>"asmjs"</td>
 *             <td>Asm.js backend. Works in Firefox 29 and later. Can accelerate computations with a limited use of native CPU instructions.</td>
 *         </tr>
 *         <tr>
 *             <td>"pnacl"</td>
 *             <td>Portable Native Client (PNaCl) backend. Works in Chromium-based browsers. Can accelerate computations through the use of advanced CPU optimization technologies, such as multi-threading and SIMD instructions.</td>
 *         </tr>
 *         <tr>
 *             <td>"webcl"</td>
 *             <td>WebCL backend. Works in browsers and Node.js when a WebCL plugin is available. Can use full power of CPUs and GPUs to accelerate computations.</td>
 *         </tr>
 *     </table>
 */
var getSupportedBackends = function() {
	var backends = [];
	if (WebCLContext.isUsable()) {
		backends.push("webcl");
	}
	if (PNaClContext.isSupported()) {
		backends.push("pnacl");
	}
	if (hasFeature("asm.js")) {
		backends.push("asm.js");
	}
	backends.push("javascript");
	return backends;
};

/**
 * Queries possible backend options available on this platform.
 *
 * @param {String} backend - name of the backend to query options for.
 *
 * @static
 * @method getBackendOptions
 *
 * @return {Object} - An object that describes available options.
 * The names of object's properties correspond to backend option names.
 * Object's properties have array values with possible option values.
 * Below are the backend options for the built-in backends:
 *
 *     <table>
 *         <caption>Options of "javascript" and "asmjs" backends</caption>
 *         <tr>
 *             <th>Option name</th>
 *             <th>Option values</th>
 *             <th>Default value</th>
 *         </tr>
 *         <tr>
 *             <td>"async"</td>
 *             <td>[true, false]</td>
 *             <td>true</td>
 *         </tr>
 *     </table>
 *
 *     <table>
 *         <caption>Options of "pnacl" backend</caption>
 *         <tr>
 *             <th>Option name</th>
 *             <th>Option values</th>
 *             <th>Default value</th>
 *         </tr>
 *         <tr>
 *             <td>"manifest"</td>
 *             <td>undefined</td>
 *             <td>URL of "furious.nmf" file in the same directory as "furious.js" library</td>
 *         </tr>
 *     </table>
 *
 *     <table>
 *         <caption>Options of "webcl" backend</caption>
 *         <tr>
 *             <th>Option name</th>
 *             <th>Option values</th>
 *             <th>Default value</th>
 *         </tr>
 *         <tr>
 *             <td>"device"</td>
 *             <td>Depends on the platform</td>
 *             <td>Discrete GPU device, if available. Otherwise integrated GPU device, if available. Otherwise CPU device.</td>
 *         </tr>
 *     </table>
 */
var getBackendOptions = function(backend) {
	if (backend === "javascript") {
		if (WebWorkerContext.isSupported()) {
			return {
				"async": [true, false]
			};
		} else {
			return {};
		}
	} else if (backend === "pnacl") {
		return {};
	} else if (backend === "webcl") {
		return {
			"device": WebCLContext.getAvailableDevices()
		};
	} else {
		throw new Error("Unsupported backend: " + backend);
	}
};

/**
 * Queries default backend options on this platform.
 *
 * @param {String} backend - name of the backend to query options for.
 *
 * @static
 * @method getBackendOptions
 *
 * @return {Object} - An object that describes available options.
 * The names of object's properties correspond to backend option names.
 * The values of object's properties correspond to default option values.
 */
var getDefaultBackendOptions = function(backend) {
	if (backend === "javascript") {
		return {
			"async": true
		};
	} else if (backend === "pnacl") {
		if (PNaClContext.isSupported()) {
			return {
				"manifest": PNaClContext.getDefaultManifestURL()
			};
		} else {
			return {};
		}
	} else if (backend === "webcl") {
		return {
			"device": WebCLContext.getDefaultDevice()
		};
	} else {
		throw new Error("Unsupported backend: " + backend);
	}
};

/**
 * Detects whether the requested computing feature is available
 *
 * @static
 * @method hasFeature
 *
 * @param {String} name - an identifier of the optional feature to detect. The following identifiers are supported:
 *
 *     <table>
 *         <tr>
 *             <th>Feature Identifier</th>
 *             <th>Interpretation</th>
 *         </tr>
 *         <tr>
 *             <td>"webworkers"</td>
 *             <td>Detect if the JavaScript engine can spawn dedicated Web Workers.</td>
 *         </tr>
 *         <tr>
 *             <td>"asm.js"</td>
 *             <td>Detect if the JavaScript engine recognizes Asm.js directive.</td>
 *         </tr>
 *         <tr>
 *             <td>"simd.js"</td>
 *             <td>Detect if the JavaScript engine provide SIMD.float32x4, SIMD.int32x4, Float32x4Array, and Int32x4Array of SIMD.js</td>
 *         </tr>
 *         <tr>
 *             <td>"webgl"</td>
 *             <td>Detect if the environment supports WebGL (either experimental or stable implementation)</td>
 *         </tr>
 *         <tr>
 *             <td>"webcl"</td>
 *             <td>Detect if the environment supports WebCL</td>
 *         </tr>
 *         <tr>
 *             <td>"pnacl"</td>
 *             <td>Detect if Portable Native Client (PNaCl) is supported and enabled</td>
 *         </tr>
 *         <tr>
 *             <td>"nacl"</td>
 *             <td>Detect if Native Client (NaCl) is supported and enabled</td>
 *         </tr>
 *     </table>
 *
 * @return {Boolean} - true if the feature is supported, false otherwise
 */
var hasFeature = function(name) {
	switch (name) {
		case "asm.js":
			try {
				var userAgent = window.navigator.userAgent;
				var userAgentComponents = userAgent.split(/\s+/);
				var firefoxRegexp = /[Ff]irefox\/(\d+)/g;
				for (var i = 0; i < userAgentComponents.length; ++i) {
					var component = userAgentComponents[i];
					var match = firefoxRegexp.exec(component);
					if (match !== null) {
						var firefoxVersion = parseInt(match[1]);
						return firefoxVersion >= 29;
					}
				}
				return false;
			} catch (e) {
			}
			return false;
		case "simd.js":
			return (typeof SIMD !== "undefined") &&
				(typeof Float32x4Array !== "undefined") &&
				(typeof Int32x4Array !== "undefined");
		case "webworkers":
			return (typeof Worker !== "undefined");
		case "webgl":
			try {
				var canvas = document.createElement("canvas");
				try {
					if (canvas.getContext("webgl") !== null) {
						return true;
					}
				} catch (e) {
				}
				try {
					if (canvas.getContext("experimental-webgl") !== null) {
						return true;
					}
				} catch (e) {
				}
			} catch (e) {
			}
			return false;
		case "webcl":
			return WebCLContext.isSupported();
		case "pnacl":
			return PNaClContext.isSupported();
		case "nacl":
			try {
				return (typeof navigator.mimeTypes["application/x-nacl"]) !== "undefined";
			} catch (e) {
			}
			return false;
		default:
			throw new Error("Unknown feature: " + name);
	}
};

exports.init = init;
exports.hasFeature = hasFeature;
exports.getDefaultBackend = getDefaultBackend;
exports.getSupportedBackends = getSupportedBackends;
exports.getBackendOptions = getBackendOptions;
exports.getDefaultBackendOptions = getDefaultBackendOptions;
exports.DataType = DataType;

},{"./DataType":1,"./PNaClContext":4,"./js/JSContext":7,"./js/WebWorkerContext":8,"./webcl/WebCLContext":13}],7:[function(require,module,exports){
"use strict";

var NDArray = require("./../NDArray");
var DataType = require("./../DataType");
var util = require("./../util");
var jsmath = require("./jsmath");

/**
 * Provides methods for creation, manipulation, and destruction of N-dimensional arrays.
 * Arithmetic operations are possible only on arrays that belong to the same context.
 *
 * @class Context
 * @constructor
 */
function JSContext(options, callback) {
	callback(this);
}

/**
 * Constructs an uninialized N-dimensional array.
 *
 * @method empty
 * @param {Number} shape - the dimensions of the array
 * @param {DataType} dataType - the type of elements in the array.
 */
JSContext.prototype.empty = function(shape, dataType) {
	/* The is no way to create uninitialized typed array in JavaScript */
	return this.zeros(shape, dataType);
};

/**
 * Constructs an N-dimensional array with elements initialized to zero.
 *
 * @method zeros
 * @param {Number} shape - the dimensions of the array
 * @param {DataType} dataType - the type of elements in the array.
 */
JSContext.prototype.zeros = function(shape, dataType) {
	shape = util.checkShape(shape);
	if (typeof dataType === "undefined") {
		dataType = new DataType("f64");
	} else {
		dataType = util.checkDataType(dataType);
	}
	var array = new NDArray(shape, dataType, this);
	array._data = new dataType.arrayType(array.length);
	return array;
};

/**
 * Constructs an N-dimensional array with elements initialized to one.
 *
 * @method ones
 * @param {Number} shape - the dimensions of the array
 * @param {DataType} dataType - the type of elements in the array.
 */
JSContext.prototype.ones = function(shape, dataType) {
	/* The is no way to create uninitialized typed array in JavaScript */
	var array = this.zeros(shape, dataType);
	jsmath.fill(array._data, 1.0);
	return array;
};

/**
 * Constructs an N-dimensional array object with the provided data.
 *
 * @method array
 * @param {Number[]} data - the array data
 * @param {DataType} dataType - the type of elements in the array.
 */
JSContext.prototype.array = function(data, dataType) {
	if (typeof dataType === "undefined") {
		dataType = new DataType("f64");
	} else {
		dataType = util.checkDataType(dataType);
	}
	var shape = [];
	util.discoverArrayShapeRecursive(data, shape, 0);
	var array = this.empty(shape, dataType);
	util.copyArrayDataRecursive(array._data, data, shape, 0, 0);
	return array;
};

/**
 * De-allocates data associated with the array.
 *
 * @method _invalidate
 * @private
 *
 * @param {NDArray} array - the n-dimensional array object with data to be de-allocated.
 */
JSContext.prototype._invalidate = function(array) {
	util.checkNDArray(array, "array");
	array._data = null;
};

/**
 * Fetches NDArray data and asynchronously returns it as JavaScript typed arrays.
 *
 * @method fetch
 * @async
 *
 * @param {NDArray} arrays* - NDArrays to fetch.
 * @param {Function} callback - A callback to be called with the data when it is available.
 * @param {ArrayBufferView} callback.arrays* - typed arrays with the data. The element type of the typed array matches the data type of the NDArray. For zero-dimensional arrays the output is returned as a typed array with a single element. Multi-dimensional arrays are returned in row-major storage format.
 */
JSContext.prototype.fetch = function() {
	if (arguments.length === 0) {
		throw new Error("Callback argument missing");
	}
	var callback = arguments[arguments.length - 1];
	/* Validate arguments */
	if (arguments.length === 1) {
		throw new Error("At least one NDArray argument expected");
	}
	for (var i = 0; i < arguments.length - 1; ++i) {
		util.checkNDArray(arguments[i], "argument " + i);
	}
	for (var i = 0; i < arguments.length - 1; ++i) {
		arguments[i]._decRef();
	}
	var callbackArguments = new Array(arguments.length - 1);
	for (var i = 0; i < callbackArguments.length; ++i) {
		var array = arguments[i];
		callbackArguments[i] = new array.dataType.arrayType(array._data);
	}
	for (var i = 0; i < arguments.length - 1; ++i) {
		arguments[i]._tryInvalidate();
	}
	callback.apply(null, callbackArguments);
};

/**
 * Fetches NDArray data and asynchronously returns it as JavaScript arrays or numbers.
 *
 * @method get
 * @async
 *
 * @param {NDArray} arrays* - NDArrays to fetch.
 * @param {Function} callback - A callback to be called with the data when it is available.
 * @param {Number|Number[]} callback.arrays* - JavaScript numbers or multidimensional arrays with the data. The number and order of arguments matches the NDArrays passed to the method call.
 */
JSContext.prototype.get = function() {
	if (arguments.length === 0) {
		throw new Error("Callback argument missing");
	}
	var callback = arguments[arguments.length - 1];
	/* Validate arguments */
	if (arguments.length === 1) {
		throw new Error("At least one NDArray argument expected");
	}
	for (var i = 0; i < arguments.length - 1; ++i) {
		util.checkNDArray(arguments[i], "argument " + i);
	}
	for (var i = 0; i < arguments.length - 1; ++i) {
		arguments[i]._decRef();
	}
	var callbackArguments = new Array(arguments.length - 1);
	for (var i = 0; i < callbackArguments.length; ++i) {
		var array = arguments[i];
		if (array.shape.length === 0) {
			callbackArguments[i] = array._data[0];
		} else {
			var jsarray = new Array(array.shape[0]);
			util.createArrayRecursive(array._data, jsarray, array.shape, 0, 0);
			callbackArguments[i] = jsarray;
		}
	}
	for (var i = 0; i < arguments.length - 1; ++i) {
		arguments[i]._tryInvalidate();
	}
	callback.apply(null, callbackArguments);
};

/**
 * Waits until previous commands finished execution and calls the callback.
 *
 * @method barrier
 * @async
 *
 * @param {Function} callback - A callback to be called after the previous commands retire.
 */
JSContext.prototype.barrier = function(callback) {
	callback();
};

/**
 * Creates another array with the same data, but different dimensions.
 *
 * @method reshape
 * @param {(NDArray|Number)} shape - dimensions of the new array.
 */
JSContext.prototype.reshape = function(array, shape) {
	shape = util.checkShape(shape);
	if (util.computeLength(shape) !== array.length) {
		throw new RangeError("The shape is not compatible with the array");
	}
	var out = new NDArray(shape, array.dataType, this);
	if (array._decRef()) {
		out._data = new out.dataType.arrayType(out.length);
		out._data.set(array._data);
	} else {
		out._data = array._data;
		array._tryInvalidate();
	}
	return out;
};

/**
 * Duplicates array elements along the specified axis.
 *
 * @method repeat
 * @param {NDArray} a - the input array.
 * @param {Number} repeats - the number of times to repeat each element.
 * @param {Number} axis - the axis along which the elements will be duplicated.
 * @param {NDArray} [out] - an output array to store the result.
 * @return {NDArray} - an N-dimensional array with repeated elements of array **a**.
 */
JSContext.prototype.repeat = function(a, repeats, axis, out) {
	util.checkNDArray(a, "a");
	repeats = util.checkRepeats(repeats);
	axis = util.checkAxis(axis, a.shape.length);
	var shapeA = a.shape;
	var shapeOut = shapeA.slice(0);
	shapeOut[axis] *= repeats;
	a._decRef();
	try {
		if (typeof out === "undefined") {
			out = this.empty(shapeOut, a.dataType);
		} else {
			util.checkNDArray(out, "out");
			util.checkShapesCompatibility(out.shape, shapeOut);
			util.checkDataTypesCompatibility(a.dataType, out.dataType);
			out._incRef();
		}
		var outerStride = util.computeOuterStride(shapeA, axis);
		var innerStride = util.computeInnerStride(shapeA, axis);
		jsmath.repeat(a._data, out._data, outerStride, innerStride, shapeA[axis], repeats);
	} catch (e) {
		a._incRef();
		throw e;
	}
	a._tryInvalidate();
	return out;
};

var binaryArithOp = function(a, b, out, context, operation, operationConst, operationRevConst) {
	var shapeOut = null, dataTypeOut = null;
	if (a instanceof NDArray) {
		shapeOut = a.shape;
		dataTypeOut = a.dataType;
		if (b instanceof NDArray) {
			util.checkShapesCompatibility(a.shape, b.shape);
			util.checkDataTypesCompatibility(a.dataType, b.dataType);
		} else if (!util.isNumber(b)) {
			throw new TypeError("Unsupported type of b");
		}
	} else if (util.isNumber(a)) {
		shapeOut = b.shape;
		dataTypeOut = b.dataType;
		util.checkNDArray(b, "b");
	} else {
		throw new TypeError("Unsupported type of a");
	}
	if (a instanceof NDArray) {
		a._decRef();
	}
	if (b instanceof NDArray) {
		b._decRef();
	}
	try {
		if (typeof out === "undefined") {
			out = new NDArray(shapeOut, dataTypeOut, context);
			if ((a instanceof NDArray) && !a._hasRefs()) {
				out._data = a._data;
			} else if ((b instanceof NDArray) && !b._hasRefs()) {
				out._data = b._data;
			} else {
				out._data = new dataTypeOut.arrayType(out.length);
			}
		} else {
			util.checkNDArray(out, "out");
			util.checkShapesCompatibility(shapeOut, out.shape);
			util.checkDataTypesCompatibility(dataTypeOut, out.dataType);
			out._incRef();
		}
		if (a instanceof NDArray) {
			if (b instanceof NDArray) {
				operation(a._data, b._data, out._data);
			} else {
				operationConst(a._data, +b, out._data);
			}
		} else {
			operationRevConst(b._data, +a, out._data);
		}
	} catch (e) {
		/* Restore the previous state */
		if (a instanceof NDArray) {
			a._incRef();
		}
		if (b instanceof NDArray) {
			b._incRef();
		}
		throw e;
	}
	if (a instanceof NDArray) {
		a._tryInvalidate();
	}
	if (b instanceof NDArray) {
		b._tryInvalidate();
	}
	return out;
};

var unaryArithOp = function(a, out, context, operation) {
	util.checkNDArray(a, "a");
	a._decRef();
	try {
		if (typeof out === "undefined") {
			out = new NDArray(a.shape, a.dataType, context);
			if ((a instanceof NDArray) && !a._hasRefs()) {
				out._data = a._data;
			} else {
				out._data = new a.dataType.arrayType(out.length);
			}
		} else {
			util.checkNDArray(out, "out");
			util.checkShapesCompatibility(a.shape, out.shape);
			util.checkDataTypesCompatibility(a.dataType, out.dataType);
			out._incRef();
		}
		operation(a._data, out._data);
	} catch (e) {
		/* Restore the previous state */
		a._incRef();
		throw e;
	}
	a._tryInvalidate();
	return out;
};

var axisReduceOp = function(a, axis, out, context, operation, axisOperation) {
	util.checkNDArray(a, "a");
	if (typeof axis === "undefined") {
		if (typeof out === "undefined") {
			out = context.empty([], a.dataType);
		} else {
			util.checkNDArray(out, "out");
			util.checkShapesCompatibility([], out.shape);
			util.checkDataTypesCompatibility(a.dataType, out.dataType);
			out._incRef();
		}
		operation(a._data, out._data);
		a._tryRelease();
		return out;
	} else {
		axis = util.checkAxis(axis, a.shape.length);
		var shapeOut = util.computeAxisReductionOutShape(a.shape, axis);
		if (typeof out === "undefined") {
			out = context.empty(shapeOut, a.dataType);
		} else {
			util.checkNDArray(out, "out");
			util.checkShapesCompatibility([], out.shape);
			util.checkDataTypesCompatibility(a.dataType, out.dataType);
			out._incRef();
		}
		axisOperation(a._data, out._data,
			util.computeOuterStride(a.shape, axis),
			util.computeInnerStride(a.shape, axis),
			a.shape[axis]);
		a._tryRelease();
		return out;
	}
};

/**
 * Adds one number or array with another number or array.
 * Addition is performed element-by-element.
 *
 * @method add
 * @param {(NDArray|Number)} a - one number or array to add. If **b** is a *Number*, **a** must be an *NDArray*.
 * @param {(NDArray|Number)} b - another number or array to add. If **a** is a *Number*, **b** must be an *NDArray*.
 * @param {NDArray} [out] - the array where the result is to be stored. If provided, must match the shape and data type of input arrays.
 * @return {NDArray} - the result of element-wise addition of **a** and **b**.
 */
JSContext.prototype.add = function(a, b, out) {
	return binaryArithOp(a, b, out, this, jsmath.add, jsmath.addConst, jsmath.addConst);
};

/**
 * Subtracts one number or array from another number or array.
 * Subtraction is performed element-by-element.
 *
 * @method sub
 * @param {(NDArray|Number)} a - the number or array to subtract from. If **b** is a *Number*, **a** must be an *NDArray*.
 * @param {(NDArray|Number)} b - the number or array to subtract. If **a** is a *Number*, **b** must be an *NDArray*.
 * @param {NDArray} [out] - the array where the result is to be stored. If provided, must match the shape and data type of input arrays.
 * @return {NDArray} - the result of element-wise subtraction of **b** from **a**.
 */
JSContext.prototype.sub = function(a, b, out) {
	return binaryArithOp(a, b, out, this, jsmath.sub, jsmath.subConst, jsmath.subRevConst);
};

/**
 * Multiplies one number or array by another number or array.
 * Multiplication is performed element-by-element.
 *
 * @method mul
 * @param {(NDArray|Number)} a - one number or array to multiply. If **b** is a *Number*, **a** must be an *NDArray*.
 * @param {(NDArray|Number)} b - another number or array to multiply. If **a** is a *Number*, **b** must be an *NDArray*.
 * @param {NDArray} [out] - the array where the result is to be stored. If provided, must match the shape and data type of input arrays.
 * @return {NDArray} - the result of element-wise multiplication of **a** and **b**.
 */
JSContext.prototype.mul = function(a, b, out) {
	return binaryArithOp(a, b, out, this, jsmath.mul, jsmath.mulConst, jsmath.mulConst);
};

/**
 * Divides one number or array by another number or array.
 * Division is performed element-by-element.
 *
 * @method div
 * @param {(NDArray|Number)} a - the number or array to divide. If **b** is a *Number*, **a** must be an *NDArray*.
 * @param {(NDArray|Number)} b - the number or array to divide by. If **a** is a *Number*, **b** must be an *NDArray*.
 * @param {NDArray} [out] - the array where the result is to be stored. If provided, must match the shape and data type of input arrays.
 * @return {NDArray} - the result of element-wise division of **a** by **b**.
 */
JSContext.prototype.div = function(a, b, out) {
	return binaryArithOp(a, b, out, this, jsmath.div, jsmath.divConst, jsmath.divRevConst);
};

JSContext.prototype.min = function(a, axis, out) {
	return axisReduceOp(a, axis, out, this, jsmath.min, jsmath.axisMin);
};

JSContext.prototype.max = function(a, axis, out) {
	return axisReduceOp(a, axis, out, this, jsmath.max, jsmath.axisMax);
};

JSContext.prototype.sum = function(a, axis, out) {
	return axisReduceOp(a, axis, out, this, jsmath.sum, jsmath.axisSum);
};

/**
 * Negates array elements.
 *
 * @method neg
 * @param {NDArray} a - the array of elements to be negated.
 * @param {NDArray} [out] - the array for negated elements. If supplied, must match the dimensions and data type of the **a** array.
 */
JSContext.prototype.neg = function(a, out) {
	return unaryArithOp(a, out, this, jsmath.neg);
};

/**
 * Computes absolute value of array elements.
 *
 * @method abs
 * @param {NDArray} a - the array of input elements.
 * @param {NDArray} [out] - the array for computed absolute values. If supplied, must match the dimensions and data type of the **a** array.
 */
JSContext.prototype.abs = function(a, out) {
	return unaryArithOp(a, out, this, jsmath.abs);
};

/**
 * Exponentiates array elements.
 *
 * @method exp
 * @param {NDArray} a - the array of elements to be exponentiated.
 * @param {NDArray} [out] - the array for exponentiated elements. If supplied, must match the dimensions and data type of the **a** array.
 */
JSContext.prototype.exp = function(a, out) {
	return unaryArithOp(a, out, this, jsmath.exp);
};

/**
 * Computes logarithm of array elements.
 *
 * @method log
 * @param {NDArray} a - the array of input elements.
 * @param {NDArray} [out] - the array for computed logarithm values. If supplied, must match the dimensions and data type of the **a** array.
 */
JSContext.prototype.log = function(a, out) {
	return unaryArithOp(a, out, this, jsmath.log);
};

/**
 * Computes square root of array elements.
 *
 * @method sqrt
 * @param {NDArray} a - the array of input elements.
 * @param {NDArray} [out] - the array for computed square root values. If supplied, must match the dimensions and data type of the **a** array.
 */
JSContext.prototype.sqrt = function(a, out) {
	return unaryArithOp(a, out, this, jsmath.sqrt);
};

/**
 * Squares array elements.
 *
 * @method square
 * @param {NDArray} a - the array of elements to be squared.
 * @param {NDArray} [out] - the array for squared elements. If supplied, must match the dimensions and data type of the **a** array.
 */
JSContext.prototype.square = function(a, out) {
	return unaryArithOp(a, out, this, jsmath.square);
};

/**
 * Computes the dot product of two N-dimensional arrays.
 *
 * @method dot
 * @param {NDArray} a - the first input array.
 * @param {NDArray} b - the second input array.
 * @param {NDArray} [out] - the output array. If supplied, must match the data type of **a** and **b** arrays and have the expected shape. Can not be the same array as **a** or **b**.
 * @return {NDArray} - the array with the dot product of **a** and **b**.
 */
JSContext.prototype.dot = function(a, b, out) {
	util.checkNDArray(a, "a");
	util.checkNDArray(b, "b");
	util.checkDataTypesCompatibility(a.dataType, b.dataType);

	/* The axis of b used in reduction: axis 0 for 1D array, second-to-last axis for ND array */
	var aAxis = Math.max(a.shape.length - 1, 0);
	var bAxis = Math.max(b.shape.length - 2, 0);
	var reductionDim = a.shape[aAxis];
	if (reductionDim !== b.shape[bAxis]) {
		throw new RangeError("Arrays have incompatible reduction dimensions");
	}
	var shapeOut = [], strideA = 1, outerStrideB = 1, innerStrideB = 1;
	for (var i = 0; i < aAxis; i++) {
		shapeOut.push(a.shape[i]);
		strideA *= a.shape[i];
	}
	for (var i = 0; i < b.shape.length; i++) {
		var dim = b.shape[i];
		if (i < bAxis) {
			outerStrideB *= dim;
			shapeOut.push(dim);
		} else if (i > bAxis) {
			innerStrideB *= dim;
			shapeOut.push(dim);
		}
	}
	if (typeof out === "undefined") {
		out = this.empty(shapeOut, a.dataType);
	} else if (out instanceof NDArray) {
		util.checkNDArray(out, "out");
		util.checkShapesCompatibility(out.shape, shapeOut);
		util.checkDataTypesCompatibility(out.dataType, a.dataType);
		util.checkDifferentNDArrays(a, out, "a", "out");
		util.checkDifferentNDArrays(b, out, "b", "out");
		out._incRef();
	}
	jsmath.dot(a._data, b._data, out._data, strideA, outerStrideB, innerStrideB, reductionDim);
	a._tryRelease();
	b._tryRelease();
	return out;
};

/**
 * Creates an arithmetic sequence.
 *
 * @method linspace
 * @param {Number} start - the starting endpoint of the sequence. Must be a finite number.
 * @param {Number} stop - the final endpoint of the sequence. Must be a finite number.
 * @param {Number} [samples=50] - the number of samples in the sequency. Must be a positive integer.
 * @param {Boolean} [closed=true] - an indicator of whether the final endpoint (`stop` argument) should be included in the sequence.
 */
JSContext.prototype.linspace = function(start, stop, samples, closed) {
	if (!util.isReal(start)) {
		throw new TypeError(start + " is not a real number");
	}
	if (!util.isReal(stop)) {
		throw new TypeError(stop + " is not a real number");
	}
	if (typeof samples === "undefined") {
		/* Default value in NumPy */
		samples = 50;
	} else if (!util.isInt(samples)) {
		throw new TypeError(samples + " is not an integer");
	} else if (samples <= 0) {
		throw new RangeError("The number of samples must be positive");
	}
	if (typeof closed === "undefined") {
		closed = true;
	}
	if (closed && (samples === 1)) {
		throw new RangeError("The number of samples must be a least 2 (for start and end points)");
	}
	var array = this.empty(samples, new DataType("f64"));
	var data = array._data;
	var range = stop - start;
	var n = (closed) ? samples - 1 : samples;
	var step = range / n;
	for (var i = 0; i < samples; i++) {
		data[i] = start + step * i;
	}
	return array;
};

module.exports = JSContext;

},{"./../DataType":1,"./../NDArray":2,"./../util":12,"./jsmath":9}],8:[function(require,module,exports){
"use strict";

var PBContext = require("./../PBContext.js");

function WebWorkerContext(options, callback) {
	var self = this;
	this._worker = new Worker(WebWorkerContext.getWorkerURL(options.baseUrl));
	this._worker.addEventListener("message", function(e) {
		self._messagingContext._onMessage(e);
	}, true);
	this._messagingContext = new PBContext(options, function(message) {
		self._worker.postMessage(message, [message]);
	}, callback);
}

WebWorkerContext.isSupported = function() {
	return typeof Worker !== "undefined";
};

WebWorkerContext.getWorkerURL = function(baseUrl) {
	if (baseUrl) {
		return baseUrl + "furious-worker.min.js";
	} else {
		return "furious-worker.min.js";
	}
};

WebWorkerContext.prototype.empty = function(shape, dataType) {
	return this._messagingContext.empty(shape, dataType);
};

WebWorkerContext.prototype.zeros = function(shape, dataType) {
	return this._messagingContext.zeros(shape, dataType);
};

WebWorkerContext.prototype.ones = function(shape, dataType) {
	return this._messagingContext.ones(shape, dataType);
};

WebWorkerContext.prototype.array = function(data, dataType) {
	return this._messagingContext.array(data, dataType);
};

WebWorkerContext.prototype.linspace = function(start, stop, samples, closed) {
	return this._messagingContext.linspace(start, stop, samples, closed);
};

WebWorkerContext.prototype.reshape = function(a, shape) {
	return this._messagingContext.reshape(a, shape);
};

WebWorkerContext.prototype.repeat = function(a, repeats, axis, out) {
	return this._messagingContext.repeat(a, repeats, axis, out);
};

WebWorkerContext.prototype._invalidate = function(array) {
	return this._messagingContext._invalidate(array);
};

WebWorkerContext.prototype.fetch = function() {
	this._messagingContext.fetch.apply(this._messagingContext, arguments);
};

WebWorkerContext.prototype.get = function() {
	this._messagingContext.get.apply(this._messagingContext, arguments);
};

WebWorkerContext.prototype.info = function(callback) {
	this._messagingContext.info(callback);
};

WebWorkerContext.prototype.barrier = function(callback) {
	this._messagingContext.barrier(callback);
};

WebWorkerContext.prototype.add = function(a, b, out) {
	return this._messagingContext.add(a, b, out);
};

WebWorkerContext.prototype.sub = function(a, b, out) {
	return this._messagingContext.sub(a, b, out);
};

WebWorkerContext.prototype.mul = function(a, b, out) {
	return this._messagingContext.mul(a, b, out);
};

WebWorkerContext.prototype.div = function(a, b, out) {
	return this._messagingContext.div(a, b, out);
};

WebWorkerContext.prototype.neg = function(a, out) {
	return this._messagingContext.neg(a, out);
};

WebWorkerContext.prototype.abs = function(a, out) {
	return this._messagingContext.abs(a, out);
};

WebWorkerContext.prototype.exp = function(a, out) {
	return this._messagingContext.exp(a, out);
};

WebWorkerContext.prototype.log = function(a, out) {
	return this._messagingContext.log(a, out);
};

WebWorkerContext.prototype.sqrt = function(a, out) {
	return this._messagingContext.sqrt(a, out);
};

WebWorkerContext.prototype.square = function(a, out) {
	return this._messagingContext.square(a, out);
};

WebWorkerContext.prototype.min = function(a, axis) {
	return this._messagingContext.min(a, axis);
};

WebWorkerContext.prototype.max = function(a, axis) {
	return this._messagingContext.max(a, axis);
};

WebWorkerContext.prototype.sum = function(a, axis) {
	return this._messagingContext.sum(a, axis);
};

WebWorkerContext.prototype.dot = function(a, b, out) {
	return this._messagingContext.dot(a, b, out);
};

module.exports = WebWorkerContext;

},{"./../PBContext.js":3}],9:[function(require,module,exports){
"use strict";

/**
 * JavaScript implementation of computational methods
 *
 * @private
 * @class JSMath
 */

/**
 * Sets all array elements to the specified value.
 *
 * @param {ArrayBufferView} data - the array data buffer.
 * @param {Number} value - the constant to fill the buffer with.
 *
 * @private
 * @static
 * @method fill
 */
exports.fill = function(data, value) {
	var n = data.length;
	for (var i = 0; i < n; ++i) {
		data[i] = value;
	}
};

/**
 * Adds two arrays.
 *
 * @param {ArrayBufferView} dataA - the input augend array.
 * @param {ArrayBufferView} dataB - the input addend array.
 * @param {ArrayBufferView} dataOut - the output sum array.
 *
 * @private
 * @static
 * @method add
 */
exports.add = function(dataA, dataB, dataOut) {
	var n = dataOut.length;
	for (var i = 0; i < n; ++i) {
		dataOut[i] = dataA[i] + dataB[i];
	}
};

/**
 * Adds a constant to an array.
 *
 * @param {ArrayBufferView} dataA - the input augend array.
 * @param {Number} valueB - the addend constant.
 * @param {ArrayBufferView} dataOut - the output sum array.
 *
 * @private
 * @static
 * @method addConst
 */
exports.addConst = function(dataA, valueB, dataOut) {
	var n = dataOut.length;
	for (var i = 0; i < n; ++i) {
		dataOut[i] = dataA[i] + valueB;
	}
};

/**
 * Subtracts two arrays.
 *
 * @param {ArrayBufferView} dataA - the input minuend array.
 * @param {ArrayBufferView} dataB - the input subtrahend array.
 * @param {ArrayBufferView} dataOut - the output difference array.
 *
 * @private
 * @static
 * @method sub
 */
exports.sub = function(dataA, dataB, dataOut) {
	var n = dataOut.length;
	for (var i = 0; i < n; ++i) {
		dataOut[i] = dataA[i] - dataB[i];
	}
};

/**
 * Subtracts a constant from an array.
 *
 * @param {ArrayBufferView} dataA - the input minuend array.
 * @param {Number} valueB - the subtrahend constant.
 * @param {ArrayBufferView} dataOut - the output difference array.
 *
 * @private
 * @static
 * @method subConst
 */
exports.subConst = function(dataA, valueB, dataOut) {
	var n = dataOut.length;
	for (var i = 0; i < n; ++i) {
		dataOut[i] = dataA[i] - valueB;
	}
};

/**
 * Subtracts an array from a constant.
 *
 * @param {ArrayBufferView} dataA - the input subtrahend array.
 * @param {Number} valueB - the minuend constant.
 * @param {ArrayBufferView} dataOut - the output difference array.
 *
 * @private
 * @static
 * @method subRevConst
 */
exports.subRevConst = function(dataA, valueB, dataOut) {
	var n = dataOut.length;
	for (var i = 0; i < n; ++i) {
		dataOut[i] = valueB - dataA[i];
	}
};

/**
 * Multiplies two arrays.
 *
 * @param {ArrayBufferView} dataA - the input multiplicand array.
 * @param {ArrayBufferView} dataB - the input multiplier array.
 * @param {ArrayBufferView} dataOut - the output product array.
 *
 * @private
 * @static
 * @method mul
 */
exports.mul = function(dataA, dataB, dataOut) {
	var n = dataOut.length;
	for (var i = 0; i < n; ++i) {
		dataOut[i] = dataA[i] * dataB[i];
	}
};

/**
 * Multiplies an array by a constant.
 *
 * @param {ArrayBufferView} dataA - the input multiplicand array.
 * @param {Number} valueB - the multiplier constant.
 * @param {ArrayBufferView} dataOut - the output product array.
 *
 * @private
 * @static
 * @method mulConst
 */
exports.mulConst = function(dataA, valueB, dataOut) {
	var n = dataOut.length;
	for (var i = 0; i < n; ++i) {
		dataOut[i] = dataA[i] * valueB;
	}
};

/**
 * Divides two arrays.
 *
 * @param {ArrayBufferView} dataA - the input dividend array.
 * @param {ArrayBufferView} dataB - the input divisor array.
 * @param {ArrayBufferView} dataOut - the output quotient array.
 *
 * @private
 * @static
 * @method div
 */
exports.div = function(dataA, dataB, dataOut) {
	var n = dataOut.length;
	for (var i = 0; i < n; ++i) {
		dataOut[i] = dataA[i] / dataB[i];
	}
};

/**
 * Divides an array by a constant.
 *
 * @param {ArrayBufferView} dataA - the input dividend array.
 * @param {Number} valueB - the divisor constant.
 * @param {ArrayBufferView} dataOut - the output quotient array.
 *
 * @private
 * @static
 * @method divConst
 */
exports.divConst = function(dataA, valueB, dataOut) {
	var n = dataOut.length;
	for (var i = 0; i < n; ++i) {
		dataOut[i] = dataA[i] / valueB;
	}
};

/**
 * Divides a constant by an array.
 *
 * @param {ArrayBufferView} dataA - the input divisor array.
 * @param {Number} valueB - the dividend constant.
 * @param {ArrayBufferView} dataOut - the output quotient array.
 *
 * @private
 * @static
 * @method divRevConst
 */
exports.divRevConst = function(dataA, valueB, dataOut) {
	var n = dataOut.length;
	for (var i = 0; i < n; ++i) {
		dataOut[i] = valueB / dataA[i];
	}
};

/**
 * Negates an array.
 *
 * @param {ArrayBufferView} dataA - the input array.
 * @param {ArrayBufferView} dataOut - the output array.
 *
 * @private
 * @static
 * @method neg
 */
exports.neg = function(dataA, dataOut) {
	var n = dataOut.length;
	for (var i = 0; i < n; ++i) {
		dataOut[i] = -dataA[i];
	}
};

/**
 * Computes absolute value of array elements.
 *
 * @param {ArrayBufferView} dataA - the input array.
 * @param {ArrayBufferView} dataOut - the output array.
 *
 * @private
 * @static
 * @method abs
 */
exports.abs = function(dataA, dataOut) {
	var n = dataOut.length;
	for (var i = 0; i < n; ++i) {
		dataOut[i] = Math.abs(dataA[i]);
	}
};

/**
 * Exponentiates array elements.
 *
 * @param {ArrayBufferView} dataA - the input array.
 * @param {ArrayBufferView} dataOut - the output array.
 *
 * @private
 * @static
 * @method exp
 */
exports.exp = function(dataA, dataOut) {
	var n = dataOut.length;
	for (var i = 0; i < n; ++i) {
		dataOut[i] = Math.exp(dataA[i]);
	}
};

/**
 * Computes logarithm of array elements.
 *
 * @param {ArrayBufferView} dataA - the input array.
 * @param {ArrayBufferView} dataOut - the output array.
 *
 * @private
 * @static
 * @method log
 */
exports.log = function(dataA, dataOut) {
	var n = dataOut.length;
	for (var i = 0; i < n; ++i) {
		dataOut[i] = Math.log(dataA[i]);
	}
};

/**
 * Computes square root of array elements.
 *
 * @param {ArrayBufferView} dataA - the input array.
 * @param {ArrayBufferView} dataOut - the output array.
 *
 * @private
 * @static
 * @method sqrt
 */
exports.sqrt = function(dataA, dataOut) {
	var n = dataOut.length;
	for (var i = 0; i < n; ++i) {
		dataOut[i] = Math.sqrt(dataA[i]);
	}
};

/**
 * Squares array elements.
 *
 * @param {ArrayBufferView} dataA - the input array.
 * @param {ArrayBufferView} dataOut - the output array.
 *
 * @private
 * @static
 * @method square
 */
exports.square = function(dataA, dataOut) {
	var n = dataOut.length;
	for (var i = 0; i < n; ++i) {
		var a = dataA[i];
		dataOut[i] = a * a;
	}
};

/**
 * Computes the minimum value of elements in an array.
 *
 * @param {ArrayBufferView} dataA - the input array to compute minimum on.
 * @param {ArrayBufferView} dataOut - the output array to store the minimum at.
 *
 * @private
 * @static
 * @method min
 */
exports.min = function(dataA, dataOut) {
	/* Computation of all-array min */
	var lengthA = dataA.length;
	var result = dataA[0];
	for (var i = 1; i < lengthA; ++i) {
		result = Math.min(result, dataA[i]);
	}
	dataOut[0] = result;
};

/**
 * Computes the maximum value of elements in an array.
 *
 * @param {ArrayBufferView} dataA - the input array to compute maximum on.
 * @param {ArrayBufferView} dataOut - the output array to store the maximum at.
 *
 * @private
 * @static
 * @method max
 */
exports.max = function(dataA, dataOut) {
	/* Computation of all-array min */
	var lengthA = dataA.length;
	var result = dataA[0];
	for (var i = 1; i < lengthA; ++i) {
		result = Math.max(result, dataA[i]);
	}
	dataOut[0] = result;
};

/**
 * Computes the sum of elements in an array.
 *
 * @param {ArrayBufferView} dataA - the input array with elements to sum up.
 * @param {ArrayBufferView} dataOut - the output array to store the sum at.
 *
 * @private
 * @static
 * @method min
 */
exports.sum = function(dataA, dataOut) {
	var lengthA = dataA.length;
	var result = 0.0;
	for (var i = 0; i < lengthA; ++i) {
		result += dataA[i];
	}
	dataOut[0] = result;
};

/**
 * Computes the minimum value of elements along an axis.
 *
 * @param {ArrayBufferView} dataA - the input array to compute minima on.
 * @param {ArrayBufferView} dataOut - the output array to store the minima at.
 * @param {Number} outerStride - the product of input array dimensions preceeding the reduction dimension.
 * @param {Number} innerStride - the product of input array dimensions following the reduction dimension.
 * @param {Number} reductionDim - the length of input array along the reduction dimension.
 *
 * @private
 * @static
 * @method axisMin
 */
exports.axisMin = function(dataA, dataOut, outerStride, innerStride, reductionDim) {
	for (var i = 0; i < outerStride; ++i) {
		for (var k = 0; k < innerStride; ++k) {
			var offset = i * reductionDim * innerStride + k;
			var currentMin = dataA[offset];
			for (var j = 1; j < reductionDim; ++j) {
				offset += innerStride;
				currentMin = Math.min(currentMin, dataA[offset]);
			}
			dataOut[i * innerStride + k] = currentMin;
		}
	}
};

/**
 * Computes the maximum value of elements along an axis.
 *
 * @param {ArrayBufferView} dataA - the input array to compute maxima on.
 * @param {ArrayBufferView} dataOut - the output array to store the maxima at.
 * @param {Number} outerStride - the product of input array dimensions preceeding the reduction dimension.
 * @param {Number} innerStride - the product of input array dimensions following the reduction dimension.
 * @param {Number} reductionDim - the length of input array along the reduction dimension.
 *
 * @private
 * @static
 * @method axisMax
 */
exports.axisMax = function(dataA, dataOut, outerStride, innerStride, reductionDim) {
	for (var i = 0; i < outerStride; ++i) {
		for (var k = 0; k < innerStride; ++k) {
			var offset = i * reductionDim * innerStride + k;
			var currentMax = dataA[offset];
			for (var j = 1; j < reductionDim; ++j) {
				offset += innerStride;
				currentMax = Math.max(currentMax, dataA[offset]);
			}
			dataOut[i * innerStride + k] = currentMax;
		}
	}
};

/**
 * Computes the sum of elements along an axis.
 *
 * @param {ArrayBufferView} dataA - the input array to sum up.
 * @param {ArrayBufferView} dataOut - the output array to store the sums at.
 * @param {Number} outerStride - the product of input array dimensions preceeding the reduction dimension.
 * @param {Number} innerStride - the product of input array dimensions following the reduction dimension.
 * @param {Number} reductionDim - the length of input array along the reduction dimension.
 *
 * @private
 * @static
 * @method axisSum
 */
exports.axisSum = function(dataA, dataOut, outerStride, innerStride, reductionDim) {
	for (var i = 0; i < outerStride; ++i) {
		for (var k = 0; k < innerStride; ++k) {
			var offset = i * reductionDim * innerStride + k;
			var currentSum = dataA[offset];
			for (var j = 1; j < reductionDim; ++j) {
				offset += innerStride;
				currentSum += dataA[offset];
			}
			dataOut[i * innerStride + k] = currentSum;
		}
	}
};

/**
 * Computes the dot product of two N-dimensional arrays.
 *
 * @param {ArrayBufferView} dataA - an input multiplicand array.
 * @param {ArrayBufferView} dataB - an input multiplier array.
 * @param {ArrayBufferView} dataOut - the output product array.
 * @param {Number} strideA - the product of the the multiplicand dimensions preceeding the reduction dimension.
 * @param {Number} outerStrideB - the product of the multiplier dimensions preceeding the reduction dimension.
 * @param {Number} innerStrideB - the product of the multiplier dimensions following the reduction dimension.
 * @param {Number} reductionDim - the length of inputs arrays along the reduction dimension.
 *
 * @private
 * @static
 * @method dot
 */
exports.dot = function(dataA, dataB, dataOut, strideA, outerStrideB, innerStrideB, reductionDim) {
	for (var i = 0; i < strideA; ++i) {
		for (var j = 0; j < reductionDim; ++j) {
			for (var k = 0; k < outerStrideB; ++k) {
				for (var l = 0; l < innerStrideB; ++l) {
					dataOut[(i*outerStrideB + k) * innerStrideB + l] += dataA[i*reductionDim+j] * dataB[(k*reductionDim+j)*innerStrideB+l];
				}
			}
		}
	}
};

/**
 * Replicates array elements along an axis.
 *
 * @param {ArrayBufferView} dataA - the input array.
 * @param {ArrayBufferView} dataOut - the output array for repeated elements.
 * @param {Number} outerStride - the product of input array dimensions preceeding the expansion dimension.
 * @param {Number} innerStride - the product of input array dimensions following the expansion dimension.
 * @param {Number} expansionDim - the length of input array along the expansion dimension.
 * @param {Number} repeats - the number of times each element will be replicated.
 *
 * @private
 * @static
 * @method repeat
 */
exports.repeat = function(dataA, dataOut, outerStride, innerStride, expansionDim, repeats) {
	if (innerStride < repeats) {
		for (var i = 0; i < outerStride; ++i) {
			for (var j = 0; j < expansionDim; ++j) {
				for (var k = 0; k < innerStride; ++k) {
					var valueA = dataA[(i * expansionDim + j) * innerStride + k];
					for (var c = 0; c < repeats; ++c) {
						dataOut[((i * expansionDim + j) * repeats + c) * innerStride + k] = valueA;
					}
				}
			}
		}
	} else {
		for (var i = 0; i < outerStride; ++i) {
			for (var j = 0; j < expansionDim; ++j) {
				var rowA = dataA.subarray((i * expansionDim + j) * innerStride, (i * expansionDim + j + 1) * innerStride);
				for (var c = 0; c < repeats; ++c) {
					dataOut.set(rowA, ((i * expansionDim + j) * repeats + c) * innerStride);
				}
			}
		}
	}
};

},{}],10:[function(require,module,exports){

var protobufjs = require("protobufjs");
protobufjs.convertFieldsToCamelCase = true;
var requestsProto = "package furious;\n\noption optimize_for = LITE_RUNTIME;\n\nenum DataType {\n\tFLOAT64 = 0;\n\tFLOAT32 = 1;\n}\n\nmessage Request {\n\tenum Type {\n\t\tEMPTY_ARRAY              =  0;\n\t\tDATA_ARRAY               =  1;\n\t\tCONST_ARRAY              =  2;\n\t\tLINSPACE                 =  3;\n\t\tRESHAPE                  =  4;\n\t\tREPEAT                   =  5;\n\t\tDEALLOCATE               =  6;\n\t\tFETCH                    =  7;\n\t\tBARRIER                  =  8;\n\t\tINFO                     =  9;\n\t\tBINARY_OPERATION         = 10;\n\t\tBINARY_CONST_OPERATION   = 11;\n\t\tUNARY_OPERATION          = 12;\n\t\tREDUCTION_OPERATION      = 13;\n\t\tAXIS_REDUCTION_OPERATION = 14;\n\t\tDOT_OPERATION            = 15;\n\t}\n\trequired fixed32                     id                             =  1;\n\trequired Type                        type                           =  2;\n\n\toptional EmptyArrayRequest           empty_array_request            =  3;\n\toptional DataArrayRequest            data_array_request             =  4;\n\toptional ConstArrayRequest           const_array_request            =  5;\n\toptional LinspaceRequest             linspace_request               =  6;\n\toptional ReshapeRequest              reshape_request                =  7;\n\toptional RepeatRequest               repeat_request                 =  8;\n\toptional DeallocateRequest           deallocate_request             =  9;\n\toptional FetchRequest                fetch_request                  = 10;\n\toptional BinaryOperationRequest      binary_operation_request       = 11;\n\toptional BinaryConstOperationRequest binary_const_operation_request = 12;\n\toptional UnaryOperationRequest       unary_operation_request        = 13;\n\toptional ReductionRequest            reduction_request              = 14;\n\toptional AxisReductionRequest        axis_reduction_request         = 15;\n\toptional DotOperationRequest         dot_operation_request          = 16;\n}\n\nmessage EmptyArrayRequest {\n\trequired fixed32  id_out      = 1;\n\trepeated uint32   shape       = 2 [packed=true];\n\trequired DataType data_type   = 3;\n}\n\nmessage DataArrayRequest {\n\trequired fixed32  id_out      = 1;\n\trepeated uint32   shape       = 2 [packed=true];\n\trequired DataType data_type   = 3;\n\trequired bytes    data_buffer = 4;\n}\n\nmessage ConstArrayRequest {\n\trequired fixed32  id_out      = 1;\n\trepeated uint32   shape       = 2 [packed=true];\n\trequired DataType data_type   = 3;\n\trequired double   fill_value  = 4;\n}\n\nmessage LinspaceRequest {\n\trequired sfixed32  id_out     = 1;\n\trequired double    start      = 2;\n\trequired double    stop       = 3;\n\trequired uint32    samples    = 4;\n\trequired bool      closed     = 5;\n\trequired DataType  data_type  = 6;\n}\n\nmessage ReshapeRequest {\n\trequired sfixed32  id_a      = 1;\n\trequired fixed32   id_out    = 2;\n\trepeated uint32    shape_out = 3 [packed=true];\n}\n\nmessage RepeatRequest {\n\trequired sfixed32 id_a    = 1;\n\trequired fixed32  id_out  = 2;\n\trequired uint32   axis    = 3;\n\trequired uint32   repeats = 4;\n}\n\nmessage DeallocateRequest {\n\trequired fixed32 id_a = 1;\n}\n\nmessage FetchRequest {\n\trequired sfixed32 id_a = 1;\n}\n\nmessage BinaryOperationRequest {\n\tenum Type {\n\t\tADD = 0;\n\t\tSUB = 1;\n\t\tMUL = 2;\n\t\tDIV = 3;\n\t}\n\trequired Type     type   = 1;\n\trequired sfixed32 id_a   = 2;\n\trequired sfixed32 id_b   = 3;\n\trequired fixed32  id_out = 4;\n}\n\nmessage BinaryConstOperationRequest {\n\tenum Type {\n\t\tADDC  = 0;\n\t\tSUBC  = 1;\n\t\tSUBRC = 2;\n\t\tMULC  = 3;\n\t\tDIVC  = 4;\n\t\tDIVRC = 5;\n\t}\n\trequired Type     type    = 1;\n\trequired sfixed32 id_a    = 2;\n\trequired double   value_b = 3;\n\trequired fixed32  id_out  = 4;\n}\n\nmessage UnaryOperationRequest {\n\tenum Type {\n\t\tNEG    = 0;\n\t\tABS    = 1;\n\t\tEXP    = 2;\n\t\tLOG    = 3;\n\t\tSQRT   = 4;\n\t\tSQUARE = 5;\n\t}\n\trequired Type     type   = 1;\n\trequired sfixed32 id_a   = 2;\n\trequired fixed32  id_out = 3;\n}\n\nmessage ReductionRequest {\n\tenum Type {\n\t\tSUM = 0;\n\t\tMIN = 1;\n\t\tMAX = 2;\n\t}\n\trequired Type     type   = 1;\n\trequired sfixed32 id_a   = 2;\n\trequired fixed32  id_out = 3;\n}\n\nmessage AxisReductionRequest {\n\tenum Type {\n\t\tSUM = 0;\n\t\tMIN = 1;\n\t\tMAX = 2;\n\t}\n\trequired Type     type   = 1;\n\trequired sfixed32 id_a   = 2;\n\trequired uint32   axis   = 3;\n\trequired fixed32  id_out = 4;\n}\n\nmessage DotOperationRequest {\n\trequired sfixed32 id_a   = 1;\n\trequired sfixed32 id_b   = 2;\n\trequired fixed32  id_out = 3;\n}\n";
module.exports = protobufjs.loadProto(requestsProto).build("furious");

},{"protobufjs":53}],11:[function(require,module,exports){

var protobufjs = require("protobufjs");
protobufjs.convertFieldsToCamelCase = true;
var responsesProto = "package furious;\n\noption optimize_for = LITE_RUNTIME;\n\nmessage Response {\n\tenum Type {\n\t\tFETCH   = 0;\n\t\tERROR   = 1;\n\t\tINIT    = 2;\n\t\tBARRIER = 3;\n\t\tINFO    = 4;\n\t}\n\trequired fixed32         id               = 1;\n\trequired Type            type             = 2;\n\n\toptional FetchResponse   fetch_response   = 3;\n\toptional ErrorResponse   error_response   = 4;\n\toptional InitResponse    init_response    = 5;\n\toptional InfoResponse    info_response    = 7;\n}\n\nmessage FetchResponse {\n\trequired bytes data_buffer = 1;\n}\n\nmessage ErrorResponse {\n\tenum Type {\n\t\tRUNTIME  = 0;\n\t\tARGUMENT = 1;\n\t\tPARSE    = 2;\n\t}\n\trequired Type   type        = 1;\n\toptional string description = 2;\n}\n\nmessage InitResponse {\n\toptional uint32 concurrency = 1;\n}\n\nmessage InfoResponse {\n}\n";
module.exports = protobufjs.loadProto(responsesProto).build("furious");

},{"protobufjs":53}],12:[function(require,module,exports){
"use strict";

/**
 * Provides helper functions
 *
 * @private
 * @class util
 */

var isNumber = function(n) {
	return n === +n;
};
exports.isNumber = isNumber;

var isReal = function(n) {
	return (n === +n) && (isFinite(n));
};
exports.isReal = isReal;

var isInt = function(n) {
	return n === (n|0);
};
exports.isInt = isInt;

exports.isPositiveInt = function(n) {
	return (n === +n) && (n === (n|0)) && (n > 0);
};

exports.isNonNegativeInt = function(n) {
	return (n === +n) && (n === (n|0)) && (n >= 0);
};

var isArray = function(list) {
	return list instanceof Array;
};
exports.isArray = isArray;

exports.isIntArray = function(list) {
	if (exports.isArray(list)) {
		for (var i = 0; i < list.length; i++) {
			if (!exports.isInt(list[i])) {
				return false;
			}
		}
		return true;
	} else {
		return false;
	}
};

exports.isPositiveIntArray = function(list) {
	if (exports.isArray(list)) {
		for (var i = 0; i < list.length; i++) {
			if (!exports.isPositiveInt(list[i])) {
				return false;
			}
		}
		return true;
	} else {
		return false;
	}
};

exports.asIntArray = function (list) {
	if (exports.isInt(list)) {
		return [list];
	} else if (exports.isIntArray(list)) {
		return list;
	} else {
		throw new TypeError(list + " can not be converted to integer array");
	}
};

/**
 * Compares for equality two arrays of primitive types.
 *
 * @param {Number[]} arrayA - the first array to compare.
 * @param {Number[]} arrayB - the second array to compare.
 *
 * @example
 *     if (!util.arrayEquals(a.shape, b.shape)) {
 *	       throw new Error("a and b have incompatible shapes");
 *     }
 *
 * @private
 * @static
 * @method arrayEquals
 */
exports.arrayEquals = function(arrayA, arrayB) {
	if (arrayA === arrayB) {
		return true;
	}
	if (arrayA.length !== arrayB.length) {
		return false;
	}
	var n = arrayA.length;
	for (var i = 0; i < n; ++i) {
		if (arrayA[i] !== arrayB[i]) {
			return false;
		}
	}
	return true;
};

exports.roundUp = function (number, multiple) {
	return Math.ceil(number / multiple) * multiple;
};

/**
 * Validate the shape argument.
 * Throws an error if the argument represents a valid shape.
 * Returns the shape as an integer array.
 *
 * @param {(Number|Number[])} shape - the shape argument to validate.
 *
 * @example
 *     shape = util.checkShape(shape);
 *
 * @private
 * @static
 * @method checkShape
 */
var checkShape = function(shape) {
	if (isNumber(shape)) {
		return checkShape([shape]);
	} else if (isArray(shape)) {
		var n = shape.length;
		var outShape = new Array(n);
		for (var i = 0; i < n; i++) {
			if (!isNumber(shape[i])) {
				throw new Error("Shape has non-numeric dimensions");
			}
			if (!isInt(shape[i])) {
				throw new Error("Shape must have integer dimensions");
			}
			if (shape[i] < 1) {
				throw new Error("Degenerate shape");
			}
			outShape[i] = shape[i]|0;
		}
		return outShape;
	} else {
		throw new Error("Shape must be an integer or integer array");
	}
};
exports.checkShape = checkShape;

/**
 * Checks that the two shapes are similar.
 * Throws an error if the two shapes are different.
 * If the data types are compatible, the function does nothing.
 *
 * @param {Number[]} shapeA - one valid shape to compare.
 * @param {Number[]} shapeB - another valid shape to compare.
 *
 * @example
 *     util.checkShapesCompatibility(a.shape, b.shape);
 *
 * @private
 * @static
 * @method checkShapesCompatibility
 */
exports.checkShapesCompatibility = function(shapeA, shapeB) {
	if (shapeA.length != shapeB.length) {
		throw new Error("The shapes have different dimensions");
	}
	var n = shapeA.length;
	for (var i = 0; i < n; i++) {
		if (shapeA[i] != shapeB[i]) {
			throw new Error("The shapes are different");
		}
	}
};

/**
 * Computes array length from its shape.
 *
 * @param {Number[]} shape - an array shape.  The shape must be valid w.r.t. **checkShape** function.
 *
 * @example
 *     var length = util.computeLength(shape);
 *
 * @private
 * @static
 * @method computeLength
 */
exports.computeLength = function(shape) {
	var length = 1;
	for (var i = 0; i < shape.length; ++i) {
		length *= shape[i];
	}
	return length;
};

/**
 * Checks the the argument represents a data type.
 * Throws an error if the argument is not of DataType type.
 * If the argument is a DataType object, the function does nothing.
 *
 * @param {DataType} dataType - the expectedly data type object to validate.
 * @return {DataType} - a data type object equivalent to the argument.
 *
 * @example
 *     dataType = util.checkDataType(dataType);
 *
 * @private
 * @static
 * @method checkDataType
 */
exports.checkDataType = function(dataType) {
	var DataType = require("./DataType");
	if (!(dataType instanceof DataType)) {
		throw new TypeError("dataType is not an instance of DataType");
	}
	return dataType;
};

/**
 * Checks that the two data types are compatible.
 * Throws an error if the data types do not match.
 * If the data types are compatible, the function does nothing.
 *
 * @param {DataType} dataTypeA - the first data type.
 * @param {DataType} dataTypeB - the second data type.
 *
 * @example
 *     util.checkDataTypesCompatibility(a.dataType, b.dataType);
 *
 * @private
 * @static
 * @method checkDataTypesCompatibility
 */
exports.checkDataTypesCompatibility = function(dataTypeA, dataTypeB) {
	if (!dataTypeA.equals(dataTypeB)) {
		throw new Error("The data types are not compatible");
	}
};

/**
 * Validates an NDArray parameter.
 * Throws an error if the expected NDArray argument has other type or if it has been invalidated.
 * If the argument is a valid NDArray, the function does nothing.
 *
 * @param {NDArray} array - the expectedly NDArray argument to be validated.
 * @param {String} vaname - the name of the NDArray argument to be used in error messages.
 *
 * @example
 *     util.checkNDArray(out, "out");
 *
 * @private
 * @static
 * @method checkNDArray
 */
exports.checkNDArray = function(array, varname) {
	var NDArray = require("./NDArray");
	if (!(array instanceof NDArray)) {
		throw new TypeError(varname + " is not an NDArray");
	}
	if (!array.isValid()) {
		throw new Error(varname + " is an invalidated array");
	}
};

/**
 * Checks that the two arrays are different.
 * Throws an error if they refer to the same object.
 * If the arrays are different, the function does nothing.
 *
 * @param {NDArray} a - the first array to check. Must be an NDArray object.
 * @param {NDArray} b - the second array to check. Must be an NDArray object.
 * @param {String} varnameA - name of the first array variable. This name may be used in an error message.
 * @param {String} varnameB - name of the second array variable. This name may be used in an error message.
 *
 * @example
 *     util.checkDifferentNDArrays(a, out, "a", "out");
 *
 * @private
 * @static
 * @method checkDifferentNDArrays
 */
exports.checkDifferentNDArrays = function(a, b, varnameA, varnameB) {
	if (a === b) {
		throw new Error("The arrays " + varnameA + " and " + varnameB + " must be different");
	}
};

/**
 * Validates **repeats** parameter for repeatition/tiling of array along an axis.
 * Throws an error if **repeats** is not an integer or if **repeats** is smaller than 2.
 * If **repeats** is valid, the function does nothing.
 *
 * @param {Number} repeats - the repeats argument to be verified.
 * @return {Number} - **repeats** casted to integer.
 *
 * @example
 *     repeats = util.checkRepeats(repeats);
 *
 * @private
 * @static
 * @method checkRepeats
 */
exports.checkRepeats = function(repeats) {
	if (!isInt(repeats)) {
		throw new TypeError("Repeats is not an integer");
	}
	if (repeats <= 1) {
		throw new RangeError("Repeats should be greater than 1");
	}
	return repeats|0;
};

/**
 * Validates axis parameter for reductions along an axis.
 * Throws an error if axis is not an integer, if axis is negative, or axis exceeds the number of dimensions.
 * If axis is valid, the function does nothing.
 *
 * @param {Number} axis - the axis argument to be verified.
 * @param {Number} numDimensions - the number of dimensions in the array being reduced.
 * @return {Number} - axis casted to integer.
 *
 * @example
 *     axis = util.checkAxis(axis, ndarray.shape.length);
 *
 * @private
 * @static
 * @method
 */
exports.checkAxis = function(axis, numDimensions) {
	if (!isInt(axis)) {
		throw new TypeError("Axis is not an integer");
	}
	if (axis < 0) {
		throw new RangeError("Axis is negative");
	}
	/* E.g. 3-dimensional array has axes 0, 1, 2 (but not 3!) */
	if (axis >= numDimensions) {
		throw new RangeError("Axis out of range");
	}
	return axis|0;
};

/**
 * Validates the shape of output array for reductions along an axis.
 * Throws an error if the shape of the output array does match the shape of input array after reduction along the axis.
 *
 * @param {Number[]} inShape - the shape of the input array.
 * @param {Number[]} outShape - the shape of the output array to be validated.
 * @param {Number} axis - the axis for reduction of input array. Must be valid w.r.t. inShape.
 *
 * @example
 *     util.checkAxisReductionOutShape(inArray.shape, outArray.shape, axis);
 *
 * @private
 * @static
 * @method
 */
exports.checkAxisReductionOutShape = function(inShape, outShape, axis) {
	if (inShape.length !== outShape.length + 1) {
		throw new Error("Output array has invalid number of dimensions for this operation");
	}
	for (var i = 0; i < axis; ++i) {
		if (inShape[i] !== outShape[i]) {
			throw new Error("Output array has invalid shape for this operation");
		}
	}
	for (var i = axis + 1; i < inShape.length; ++i) {
		if (inShape[i] !== outShape[i-1]) {
			throw new Error("Output array has invalid shape for this operation");
		}
	}
};

/**
 * Computes the shape of an array after reduction along an axis.
 *
 * @param {Number[]} inShape - the shape of the input array.
 * @param {Number} axis - the axis for reduction of input array. Must be valid w.r.t. inShape.
 * @return {Number[]} - the shape of the output array.
 *
 * @example
 *     var outShape = util.getAxisReductionOutShape(inArray.shape, axis);
 *     var outArray = new NDArray(outShape, inArray.dataType, context);
 *
 * @private
 * @static
 * @method
 */
exports.computeAxisReductionOutShape = function(inShape, axis) {
	var outShape = [];
	for (var i = 0; i < inShape.length; ++i) {
		if (i !== axis) {
			outShape.push(inShape[i]);
		}
	}
	return outShape;
};

/**
 * Computes the product of array dimensions before the axis.
 *
 * @param {Number[]} shape - the shape of the array.
 * @param {Number} axis - the axis used in an operation. Must be valid w.r.t. shape.
 * @return {Number} - the product of array dimensions before axis.
 *
 * @example
 *     // 5-dimensional array
 *     var ndarray = context.empty([2, 3, 4, 5, 6]);
 *     // Returns 6 = 2*3
 *     var outerStride = computeOuterStride(ndarray, 2);
 *
 * @private
 * @static
 * @method
 */
exports.computeOuterStride = function(shape, axis) {
	var outerStride = 1;
	for (var i = 0; i < axis; ++i) {
		outerStride *= shape[i];
	}
	return outerStride;
};

/**
 * Computes the product of array dimensions after the axis.
 *
 * @param {Number[]} shape - the shape of the array.
 * @param {Number} axis - the axis used in an operation. Must be valid w.r.t. shape.
 * @return {Number} - the product of array dimensions after axis.
 *
 * @example
 *     // 5-dimensional array
 *     var ndarray = context.empty([2, 3, 4, 5, 6]);
 *     // Returns 6 = 2*3
 *     var innerStride = computeInnerStride(ndarray, 2);
 *
 * @private
 * @static
 * @method
 */
exports.computeInnerStride = function(shape, axis) {
	var innerStride = 1;
	for (var i = axis + 1; i < shape.length; ++i) {
		innerStride *= shape[i];
	}
	return innerStride;
};

var discoverArrayShapeRecursive = function(data, shape, level) {
	if (isArray(data)) {
		if (shape.length <= level) {
			/* Discovered a new level of sub-arrays. Record its dimension. */
			shape.push(data.length);
		} else {
			/* Only check dimension */
			if (shape[level] != data.length) {
				throw new RangeError("Sub-array " + data + " does not match the expected dimension of " + shape[level]);
			}
		}
		for (var i = 0; i < data.length; i++) {
			discoverArrayShapeRecursive(data[i], shape, level + 1);
		}
	} else {
		if (level != shape.length) {
			throw new RangeError("Sub-array [" + data + "] does not match the expected dimension of " + shape[level]);
		}
		if (!isNumber(data)) {
			throw new TypeError("Non-numeric element: " + data);
		}
	}
};
exports.discoverArrayShapeRecursive = discoverArrayShapeRecursive;

var copyArrayDataRecursive = function(dataBuffer, dataArray, shape, level, offset) {
	var n = shape[level];
	if (level === shape.length - 1) {
		dataBuffer.set(dataArray, offset * n);
	} else {
		for (var i = 0; i < n; i++) {
			copyArrayDataRecursive(dataBuffer, dataArray[i], shape, level + 1, offset * n  + i);
		}
	}
};
exports.copyArrayDataRecursive = copyArrayDataRecursive;

var createArrayRecursive = function(dataBuffer, dataArray, shape, level, offset) {
	var n = shape[level];
	if (level === shape.length - 1) {
		for (var i = 0; i < n; i++) {
			dataArray[i] = dataBuffer[offset * n + i];
		}
	} else {
		for (var i = 0; i < n; i++) {
			dataArray[i] = new Array(shape[level + 1]);
			createArrayRecursive(dataBuffer, dataArray[i], shape, level + 1, offset * n  + i);
		}
	}
};
exports.createArrayRecursive = createArrayRecursive;

},{"./DataType":1,"./NDArray":2}],13:[function(require,module,exports){
"use strict";

var NDArray = require("../NDArray");
var DataType = require("../DataType");
var util = require("../util");


/* Buggy in Chromium-WebCL */
var useBufferCreationWithInit = false;

var isNodeWebCL = false;
var cl = void 0;
var availableDevices = null;
var availableDevicesDescriptions = null;
var defaultDeviceIndex = -1;

/**
 * If the global cl variable is undefined, this method would initialize it with a WebCL instance.
 * Works for both browser and Node.js
 *
 * @private
 * @static
 * @method initWebCL
 * @return {WebCL} - an instance of WebCL object from WebCL specification. If WebCL is not supported, return null.
 */
var initWebCL = function() {
	if (typeof cl === "undefined") {
		if (typeof window === "object") {
			cl = (typeof window.webcl !== "undefined") ? window.webcl : null;
		} else {
			try {
				cl = require("node-webcl");
				isNodeWebCL = true;
			} catch (e) {
				cl = null;
			}
		}
	}
	return cl;
};

/**
 * Creates an empty WebCLEvent.
 * Works for both browser and Node.js
 *
 * @private
 * @static
 * @method createEvent
 * @return {WebCLEvent} - an empty instance of WebCLEvent.
 */
var createEvent = function() {
	if (isNodeWebCL) {
		return new cl.WebCLEvent();
	} else {
		return new WebCLEvent();
	}
};

/**
 * Tries to release a WebCL resource and ignores any errors in the process.
 *
 * @private
 * @method tryRlease
 * @param {Object} webclObject - a WebCL object.
 * @return {Boolean} - true if the object was successfully released and false otherwise.
 */
var tryRelease = function(webclResource) {
	if (webclResource !== null) {
		try {
			webclResource.release();
			return true;
		} catch (e) {
			/* Silently ignore */
		}
	}
	return false;
};

/**
 * Checks if a WebCL device supports KHR_fp64 extension.
 *
 * @private
 * @method isFP64Capable
 * @param {WebCLDevice} device - the device to check for KHR_fp64 support.
 * @return {Boolean} - true if the device supports KHR_fp64 and false otherwise.
 */
var isFP64Capable = function(device) {
	var extensions = device.getSupportedExtensions();
	if (extensions.indexOf("KHR_fp64") === -1) {
		return false;
	}
	/*
	 * Due to a bug WebKit-WebCL may report KHR_fp64 even if it is not supported by the underlying OpenCL device.
	 * See bug https://github.com/SRA-SiliconValley/webkit-webcl/issues/536
	 */
	var testSource = "kernel void foo(global double* bar) { }";
	var context = null, program = null;
	try {
		context = cl.createContext(device);
		program = context.createProgram(testSource);
		program.build();
		return true;
	} catch (e) {
		return false;
	} finally {
		tryRelease(program);
		tryRelease(context);
	}
};

/**
 * Initialises and returns a list of WebCL devices suitable for computation.
 *
 * @private
 * @static
 * @method getAvailableDevices
 * @return {WebCLDevice[]} - a list of GPU and CPU WebCL devices that support KHR_FP64 (may be empty).
 */
var getAvailableDevices = function() {
	if (availableDevices === null) {
		availableDevices = [];
		var webcl = initWebCL();
		if (webcl !== null) {
			var platforms = cl.getPlatforms();
			for (var i = 0; i < platforms.length; ++i) {
				var platform = platforms[i];
				var devices = platform.getDevices(cl.DEVICE_TYPE_ALL);
				for (var j = 0; j < devices.length; ++j) {
					var device = devices[j];
					if (isFP64Capable(device)) {
						availableDevices.push(device);
					}
				}
			}
		}
		generateAvailableDevicesDescriptions();
	}
	return availableDevices;
};

var generateAvailableDevicesDescriptions = function() {
	availableDevicesDescriptions = [];
	/* If devices names are available, use them */
	var haveNames = true;
	for (var i = 0; i < availableDevices.length; ++i) {
		var device = availableDevices[i];
		var name = device.getInfo(cl.DEVICE_NAME);
		if ((name === null) || (name === "")) {
			haveNames = false;
			break;
		}
		availableDevicesDescriptions[i] = name;
	}
	if (!haveNames) {
		/* At least some names are not available: try to assign names based on classification (e.g. "CPU", "dGPU", "iGPU") */
		var cpuCount = 0, igpuCount = 0, dgpuCount = 0;
		for (var i = 0; i < availableDevices.length; ++i) {
			var device = availableDevices[i];
			var classification = classifyDevice(device);
			if (classification === "cpu") {
				++cpuCount;
				availableDevicesDescriptions[i] = "CPU";
			} else if (classification === "igpu") {
				++igpuCount;
				availableDevicesDescriptions[i] = "iGPU";
			} else if (classification === "dgpu") {
				++dgpuCount;
				availableDevicesDescriptions[i] = "dGPU";
			} else {
				throw new Error("Impossible device classification: " + classification);
			}
		}
		if ((cpuCount > 1) || (igpuCount > 1) || (dgpuCount > 1)) {
			/* We have multiple devices of the same type. Need to use more complicated naming scheme */
			var cpuIndex = 0, igpuIndex = 0, dgpuIndex = 0;
			for (var i = 0; i < availableDevices.length; ++i) {
				var device = availableDevices[i];
				var classification = classifyDevice(device);
				if (classification === "cpu") {
					if (cpuCount > 1) {
						++cpuIndex;
						availableDevicesDescriptions[i] = "CPU #" + cpuIndex;
					}
				} else if (classification === "igpu") {
					if (igpuCount > 1) {
						++igpuIndex;
						availableDevicesDescriptions[i] = "iGPU #" + igpuIndex;
					}
				} else if (classification === "dgpu") {
					if (dgpuCount > 1) {
						++dgpuCount;
						availableDevicesDescriptions[i] = "dGPU #" + dgpuIndex;
					}
				} else {
					throw new Error("Impossible device classification: " + classification);
				}
			}
		}
	}
};

/**
 * Classifies WebCL device to one of four categories:
 * - "cpu" for CPU devices.
 * - "igpu" for GPUs integrated with CPU package or chipset.
 * - "dgpu" for discrete GPUs.
 * - "unknown" for other types of devices (e.g. FPGAs)
 *
 * @private
 * @method classifyDevice
 * @param {WebCLDevice} device - the WebCL device to classify.
 * @return {String} - one of the strings described above.
 */
var classifyDevice = function(device) {
	try {
		var deviceType = device.getInfo(cl.DEVICE_TYPE);
		if (deviceType === cl.DEVICE_TYPE_CPU) {
			return "cpu";
		} else if (deviceType === cl.DEVICE_TYPE_GPU) {
			var isHostUnifiedMemory = device.getInfo(cl.DEVICE_HOST_UNIFIED_MEMORY);
			return (isHostUnifiedMemory ? "igpu" : "dgpu");
		}
	} catch (e) {
	}
	return "unknown";
};

/**
 * Selects the optimal WebCL device among the available devices.
 * The priority of devices: "dgpu" > "igpu" > "cpu"
 *
 * @private
 * @method getDefaultDeviceIndex
 * @return {WebCLDevice} - the selected device from the list.
 */
var getDefaultDeviceIndex = function() {
	if (defaultDeviceIndex === -1) {
		var availableDevices = getAvailableDevices();
		if (availableDevices.length === 0) {
			defaultDeviceIndex = -2;
			return defaultDeviceIndex;
		}
		var deviceClassifications = [];
		/* Search for "dgpu" */
		for (var i = 0; i < availableDevices.length; ++i) {
			var device = availableDevices[i];
			var deviceClass = classifyDevice(device);
			if (deviceClass === "dgpu") {
				defaultDeviceIndex = i;
				return i;
			}
			deviceClassifications.push(deviceClass);
		}
		/* Search for "igpu" */
		for (var i = 0; i < availableDevices.length; ++i) {
			if (deviceClassifications[i] === "igpu") {
				defaultDeviceIndex = i;
				return i;
			}
		}
		/* Search for "cpu" */
		for (var i = 0; i < availableDevices.length; ++i) {
			if (deviceClassifications[i] === "cpu") {
				defaultDeviceIndex = i;
				return i;
			}
		}
	}
	return defaultDeviceIndex;
};

var createKernels = function(program) {
	var kernels = {
		set: {
			f32: program.createKernel("set_f32"),
			f64: program.createKernel("set_f64")
		},
		linspace: {
			f32: program.createKernel("linspace_f32"),
			f64: program.createKernel("linspace_f64")
		},
		repeat: {
			f32: program.createKernel("repeat_f32"),
			f64: program.createKernel("repeat_f64")
		},
		add: {
			f32: program.createKernel("add_f32"),
			f64: program.createKernel("add_f64")
		},
		sub: {
			f32: program.createKernel("sub_f32"),
			f64: program.createKernel("sub_f64")
		},
		mul: {
			f32: program.createKernel("mul_f32"),
			f64: program.createKernel("mul_f64")
		},
		div: {
			f32: program.createKernel("div_f32"),
			f64: program.createKernel("div_f64")
		},
		addc: {
			f32: program.createKernel("addc_f32"),
			f64: program.createKernel("addc_f64")
		},
		subc: {
			f32: program.createKernel("subc_f32"),
			f64: program.createKernel("subc_f64")
		},
		subrc: {
			f32: program.createKernel("subrc_f32"),
			f64: program.createKernel("subrc_f64")
		},
		mulc: {
			f32: program.createKernel("mulc_f32"),
			f64: program.createKernel("mulc_f64")
		},
		divc: {
			f32: program.createKernel("divc_f32"),
			f64: program.createKernel("divc_f64")
		},
		divrc: {
			f32: program.createKernel("divrc_f32"),
			f64: program.createKernel("divrc_f64")
		},
		neg: {
			f32: program.createKernel("neg_f32"),
			f64: program.createKernel("neg_f64")
		},
		abs: {
			f32: program.createKernel("abs_f32"),
			f64: program.createKernel("abs_f64")
		},
		exp: {
			f32: program.createKernel("exp_f32"),
			f64: program.createKernel("exp_f64")
		},
		log: {
			f32: program.createKernel("log_f32"),
			f64: program.createKernel("log_f64")
		},
		sqrt: {
			f32: program.createKernel("sqrt_f32"),
			f64: program.createKernel("sqrt_f64")
		},
		square: {
			f32: program.createKernel("square_f32"),
			f64: program.createKernel("square_f64")
		},
		sum: {
			f32: program.createKernel("sum_f32_gpu"),
			f64: program.createKernel("sum_f64_gpu")
		},
		min: {
			f32: program.createKernel("min_f32_gpu"),
			f64: program.createKernel("min_f64_gpu")
		},
		max: {
			f32: program.createKernel("max_f32_gpu"),
			f64: program.createKernel("max_f64_gpu")
		},
		asum: {
			f32: program.createKernel("asum_f32"),
			f64: program.createKernel("asum_f64")
		},
		amin: {
			f32: program.createKernel("amin_f32"),
			f64: program.createKernel("amin_f64")
		},
		amax: {
			f32: program.createKernel("amax_f32"),
			f64: program.createKernel("amax_f64")
		},
		dot: {
			f32: program.createKernel("dot_f32"),
			f64: program.createKernel("dot_f64")
		}
	};
	return kernels;
};

function WebCLContext(options, callback) {
	initWebCL();
	var binaryKernelsSource = "kernel void add_f32(\n\tuint length,\n\tglobal float* a,\n\tglobal float* b,\n\tglobal float* out)\n{\n\tconst uint id = get_global_id(0);\n\tif (id < length) {\n\t\tout[id] = a[id] + b[id];\n\t}\n}\nkernel void add_f64(\n\tuint length,\n\tglobal double* a,\n\tglobal double* b,\n\tglobal double* out)\n{\n\tconst uint id = get_global_id(0);\n\tif (id < length) {\n\t\tout[id] = a[id] + b[id];\n\t}\n}\nkernel void sub_f32(\n\tuint length,\n\tglobal float* a,\n\tglobal float* b,\n\tglobal float* out)\n{\n\tconst uint id = get_global_id(0);\n\tif (id < length) {\n\t\tout[id] = a[id] - b[id];\n\t}\n}\nkernel void sub_f64(\n\tuint length,\n\tglobal double* a,\n\tglobal double* b,\n\tglobal double* out)\n{\n\tconst uint id = get_global_id(0);\n\tif (id < length) {\n\t\tout[id] = a[id] - b[id];\n\t}\n}\nkernel void mul_f32(\n\tuint length,\n\tglobal float* a,\n\tglobal float* b,\n\tglobal float* out)\n{\n\tconst uint id = get_global_id(0);\n\tif (id < length) {\n\t\tout[id] = a[id] * b[id];\n\t}\n}\nkernel void mul_f64(\n\tuint length,\n\tglobal double* a,\n\tglobal double* b,\n\tglobal double* out)\n{\n\tconst uint id = get_global_id(0);\n\tif (id < length) {\n\t\tout[id] = a[id] * b[id];\n\t}\n}\nkernel void div_f32(\n\tuint length,\n\tglobal float* a,\n\tglobal float* b,\n\tglobal float* out)\n{\n\tconst uint id = get_global_id(0);\n\tif (id < length) {\n\t\tout[id] = a[id] / b[id];\n\t}\n}\nkernel void div_f64(\n\tuint length,\n\tglobal double* a,\n\tglobal double* b,\n\tglobal double* out)\n{\n\tconst uint id = get_global_id(0);\n\tif (id < length) {\n\t\tout[id] = a[id] / b[id];\n\t}\n}\nkernel void addc_f32(\n\tuint length,\n\tglobal float* a,\n\tfloat b,\n\tglobal float* out)\n{\n\tconst uint id = get_global_id(0);\n\tif (id < length) {\n\t\tout[id] = a[id] + b;\n\t}\n}\nkernel void addc_f64(\n\tuint length,\n\tglobal double* a,\n\tdouble b,\n\tglobal double* out)\n{\n\tconst uint id = get_global_id(0);\n\tif (id < length) {\n\t\tout[id] = a[id] + b;\n\t}\n}\nkernel void subc_f32(\n\tuint length,\n\tglobal float* a,\n\tfloat b,\n\tglobal float* out)\n{\n\tconst uint id = get_global_id(0);\n\tif (id < length) {\n\t\tout[id] = a[id] - b;\n\t}\n}\nkernel void subc_f64(\n\tuint length,\n\tglobal double* a,\n\tdouble b,\n\tglobal double* out)\n{\n\tconst uint id = get_global_id(0);\n\tif (id < length) {\n\t\tout[id] = a[id] - b;\n\t}\n}\nkernel void subrc_f32(\n\tuint length,\n\tglobal float* a,\n\tfloat b,\n\tglobal float* out)\n{\n\tconst uint id = get_global_id(0);\n\tif (id < length) {\n\t\tout[id] = b / a[id];\n\t}\n}\nkernel void subrc_f64(\n\tuint length,\n\tglobal double* a,\n\tdouble b,\n\tglobal double* out)\n{\n\tconst uint id = get_global_id(0);\n\tif (id < length) {\n\t\tout[id] = b / a[id];\n\t}\n}\nkernel void mulc_f32(\n\tuint length,\n\tglobal float* a,\n\tfloat b,\n\tglobal float* out)\n{\n\tconst uint id = get_global_id(0);\n\tif (id < length) {\n\t\tout[id] = a[id] * b;\n\t}\n}\nkernel void mulc_f64(\n\tuint length,\n\tglobal double* a,\n\tdouble b,\n\tglobal double* out)\n{\n\tconst uint id = get_global_id(0);\n\tif (id < length) {\n\t\tout[id] = a[id] * b;\n\t}\n}\nkernel void divc_f32(\n\tuint length,\n\tglobal float* a,\n\tfloat b,\n\tglobal float* out)\n{\n\tconst uint id = get_global_id(0);\n\tif (id < length) {\n\t\tout[id] = a[id] / b;\n\t}\n}\nkernel void divc_f64(\n\tuint length,\n\tglobal double* a,\n\tdouble b,\n\tglobal double* out)\n{\n\tconst uint id = get_global_id(0);\n\tif (id < length) {\n\t\tout[id] = a[id] / b;\n\t}\n}\nkernel void divrc_f32(\n\tuint length,\n\tglobal float* a,\n\tfloat b,\n\tglobal float* out)\n{\n\tconst uint id = get_global_id(0);\n\tif (id < length) {\n\t\tout[id] = b / a[id];\n\t}\n}\nkernel void divrc_f64(\n\tuint length,\n\tglobal double* a,\n\tdouble b,\n\tglobal double* out)\n{\n\tconst uint id = get_global_id(0);\n\tif (id < length) {\n\t\tout[id] = b / a[id];\n\t}\n}\n";
	var unaryKernelsSource = "kernel void neg_f32(\n\tuint length,\n\tglobal float* a,\n\tglobal float* out)\n{\n\tconst uint id = get_global_id(0);\n\tif (id < length) {\n\t\tout[id] = -a[id];\n\t}\n}\nkernel void neg_f64(\n\tuint length,\n\tglobal double* a,\n\tglobal double* out)\n{\n\tconst uint id = get_global_id(0);\n\tif (id < length) {\n\t\tout[id] = -a[id];\n\t}\n}\nkernel void abs_f32(\n\tuint length,\n\tglobal float* a,\n\tglobal float* out)\n{\n\tconst uint id = get_global_id(0);\n\tif (id < length) {\n\t\tout[id] = fabs(a[id]);\n\t}\n}\nkernel void abs_f64(\n\tuint length,\n\tglobal double* a,\n\tglobal double* out)\n{\n\tconst uint id = get_global_id(0);\n\tif (id < length) {\n\t\tout[id] = fabs(a[id]);\n\t}\n}\nkernel void exp_f32(\n\tuint length,\n\tglobal float* a,\n\tglobal float* out)\n{\n\tconst uint id = get_global_id(0);\n\tif (id < length) {\n\t\tout[id] = exp(a[id]);\n\t}\n}\nkernel void exp_f64(\n\tuint length,\n\tglobal double* a,\n\tglobal double* out)\n{\n\tconst uint id = get_global_id(0);\n\tif (id < length) {\n\t\tout[id] = exp(a[id]);\n\t}\n}\nkernel void log_f32(\n\tuint length,\n\tglobal float* a,\n\tglobal float* out)\n{\n\tconst uint id = get_global_id(0);\n\tif (id < length) {\n\t\tout[id] = log(a[id]);\n\t}\n}\nkernel void log_f64(\n\tuint length,\n\tglobal double* a,\n\tglobal double* out)\n{\n\tconst uint id = get_global_id(0);\n\tif (id < length) {\n\t\tout[id] = log(a[id]);\n\t}\n}\nkernel void sqrt_f32(\n\tuint length,\n\tglobal float* a,\n\tglobal float* out)\n{\n\tconst uint id = get_global_id(0);\n\tif (id < length) {\n\t\tout[id] = sqrt(a[id]);\n\t}\n}\nkernel void sqrt_f64(\n\tuint length,\n\tglobal double* a,\n\tglobal double* out)\n{\n\tconst uint id = get_global_id(0);\n\tif (id < length) {\n\t\tout[id] = sqrt(a[id]);\n\t}\n}\nkernel void square_f32(\n\tuint length,\n\tglobal float* a,\n\tglobal float* out)\n{\n\tconst uint id = get_global_id(0);\n\tif (id < length) {\n\t\tconst float aVal = a[id]; \n\t\tout[id] = aVal * aVal;\n\t}\n}\nkernel void square_f64(\n\tuint length,\n\tglobal double* a,\n\tglobal double* out)\n{\n\tconst uint id = get_global_id(0);\n\tif (id < length) {\n\t\tconst double aVal = a[id];\n\t\tout[id] = aVal * aVal;\n\t}\n}\n";
	var reductionKernelsSource = "kernel void sum_f32_gpu(\n\tuint length,\n\tglobal float* a,\n\tlocal float* scratch,\n\tglobal float* out)\n{\n\tconst uint globalSize = get_global_size(0);\n\tuint globalIndex = get_global_id(0);\n\tfloat accumulator = 0.0f;\n\twhile (globalIndex < length) {\n\t\taccumulator += a[globalIndex];\n\t\tglobalIndex += globalSize;\n\t}\n\n\tuint localIndex = get_local_id(0);\n\tscratch[localIndex] = accumulator;\n\tbarrier(CLK_LOCAL_MEM_FENCE);\n\tfor (uint offset = get_local_size(0) / 2; offset != 0; offset >>= 1) {\n\t\tif (localIndex < offset) {\n\t\t\tscratch[localIndex] += scratch[localIndex + offset];\n\t\t}\n\t\tbarrier(CLK_LOCAL_MEM_FENCE);\n\t}\n\tif (localIndex == 0) {\n\t\tout[get_group_id(0)] = scratch[0];\n\t}\n}\n\nkernel void sum_f64_gpu(\n\tuint length,\n\tglobal double* a,\n\tlocal double* scratch,\n\tglobal double* out)\n{\n\tconst uint globalSize = get_global_size(0);\n\tuint globalIndex = get_global_id(0);\n\tdouble accumulator = 0.0;\n\twhile (globalIndex < length) {\n\t\taccumulator += a[globalIndex];\n\t\tglobalIndex += globalSize;\n\t}\n\n\tuint localIndex = get_local_id(0);\n\tscratch[localIndex] = accumulator;\n\tbarrier(CLK_LOCAL_MEM_FENCE);\n\tfor (uint offset = get_local_size(0) / 2; offset != 0; offset >>= 1) {\n\t\tif (localIndex < offset) {\n\t\t\tscratch[localIndex] += scratch[localIndex + offset];\n\t\t}\n\t\tbarrier(CLK_LOCAL_MEM_FENCE);\n\t}\n\tif (localIndex == 0) {\n\t\tout[get_group_id(0)] = scratch[0];\n\t}\n}\n\nkernel void min_f32_gpu(\n\tuint length,\n\tglobal float* a,\n\tlocal float* scratch,\n\tglobal float* out)\n{\n\tconst uint globalSize = get_global_size(0);\n\tuint globalIndex = get_global_id(0);\n\tfloat accumulator = INFINITY;\n\twhile (globalIndex < length) {\n\t\taccumulator = min(accumulator, a[globalIndex]);\n\t\tglobalIndex += globalSize;\n\t}\n\n\tuint localIndex = get_local_id(0);\n\tscratch[localIndex] = accumulator;\n\tbarrier(CLK_LOCAL_MEM_FENCE);\n\tfor (uint offset = get_local_size(0) / 2; offset != 0; offset >>= 1) {\n\t\tif (localIndex < offset) {\n\t\t\tscratch[localIndex] = min(scratch[localIndex], scratch[localIndex + offset]);\n\t\t}\n\t\tbarrier(CLK_LOCAL_MEM_FENCE);\n\t}\n\tif (localIndex == 0) {\n\t\tout[get_group_id(0)] = scratch[0];\n\t}\n}\n\nkernel void min_f64_gpu(\n\tuint length,\n\tglobal double* a,\n\tlocal double* scratch,\n\tglobal double* out)\n{\n\tconst uint globalSize = get_global_size(0);\n\tuint globalIndex = get_global_id(0);\n\tdouble accumulator = INFINITY;\n\twhile (globalIndex < length) {\n\t\taccumulator = min(accumulator, a[globalIndex]);\n\t\tglobalIndex += globalSize;\n\t}\n\n\tuint localIndex = get_local_id(0);\n\tscratch[localIndex] = accumulator;\n\tbarrier(CLK_LOCAL_MEM_FENCE);\n\tfor (uint offset = get_local_size(0) / 2; offset != 0; offset >>= 1) {\n\t\tif (localIndex < offset) {\n\t\t\tscratch[localIndex] = min(scratch[localIndex], scratch[localIndex + offset]);\n\t\t}\n\t\tbarrier(CLK_LOCAL_MEM_FENCE);\n\t}\n\tif (localIndex == 0) {\n\t\tout[get_group_id(0)] = scratch[0];\n\t}\n}\n\nkernel void max_f32_gpu(\n\tuint length,\n\tglobal float* a,\n\tlocal float* scratch,\n\tglobal float* out)\n{\n\tconst uint globalSize = get_global_size(0);\n\tuint globalIndex = get_global_id(0);\n\tfloat accumulator = -INFINITY;\n\twhile (globalIndex < length) {\n\t\taccumulator = max(accumulator, a[globalIndex]);\n\t\tglobalIndex += globalSize;\n\t}\n\n\tuint localIndex = get_local_id(0);\n\tscratch[localIndex] = accumulator;\n\tbarrier(CLK_LOCAL_MEM_FENCE);\n\tfor (uint offset = get_local_size(0) / 2; offset != 0; offset >>= 1) {\n\t\tif (localIndex < offset) {\n\t\t\tscratch[localIndex] = max(scratch[localIndex], scratch[localIndex + offset]);\n\t\t}\n\t\tbarrier(CLK_LOCAL_MEM_FENCE);\n\t}\n\tif (localIndex == 0) {\n\t\tout[get_group_id(0)] = scratch[0];\n\t}\n}\n\nkernel void max_f64_gpu(\n\tuint length,\n\tglobal double* a,\n\tlocal double* scratch,\n\tglobal double* out)\n{\n\tconst uint globalSize = get_global_size(0);\n\tuint globalIndex = get_global_id(0);\n\tdouble accumulator = -INFINITY;\n\twhile (globalIndex < length) {\n\t\taccumulator = max(accumulator, a[globalIndex]);\n\t\tglobalIndex += globalSize;\n\t}\n\n\tuint localIndex = get_local_id(0);\n\tscratch[localIndex] = accumulator;\n\tbarrier(CLK_LOCAL_MEM_FENCE);\n\tfor (uint offset = get_local_size(0) / 2; offset != 0; offset >>= 1) {\n\t\tif (localIndex < offset) {\n\t\t\tscratch[localIndex] = max(scratch[localIndex], scratch[localIndex + offset]);\n\t\t}\n\t\tbarrier(CLK_LOCAL_MEM_FENCE);\n\t}\n\tif (localIndex == 0) {\n\t\tout[get_group_id(0)] = scratch[0];\n\t}\n}\n";
	var axisReductionKernelsSource = "kernel void asum_f32(\n\tuint reductionDim,\n\tglobal float* a,\n\tglobal float* out)\n{\n\tconst uint innerStride = get_global_size(1);\n\tconst uint i = get_global_id(0);\n\tconst uint k = get_global_id(1);\n\ta += i * reductionDim * innerStride + k;\n\tfloat accumulator = *a;\n\twhile (--reductionDim) {\n\t\ta += innerStride;\n\t\taccumulator += *a;\n\t}\n\tout[i * innerStride + k] = accumulator;\n}\n\nkernel void asum_f64(\n\tuint reductionDim,\n\tglobal double* a,\n\tglobal double* out)\n{\n\tconst uint innerStride = get_global_size(1);\n\tconst uint i = get_global_id(0);\n\tconst uint k = get_global_id(1);\n\ta += i * reductionDim * innerStride + k;\n\tdouble accumulator = *a;\n\twhile (--reductionDim) {\n\t\ta += innerStride;\n\t\taccumulator += *a;\n\t}\n\tout[i * innerStride + k] = accumulator;\n}\n\nkernel void amin_f32(\n\tuint reductionDim,\n\tglobal float* a,\n\tglobal float* out)\n{\n\tconst uint innerStride = get_global_size(1);\n\tconst uint i = get_global_id(0);\n\tconst uint k = get_global_id(1);\n\ta += i * reductionDim * innerStride + k;\n\tfloat accumulator = *a;\n\twhile (--reductionDim) {\n\t\ta += innerStride;\n\t\taccumulator = min(accumulator, *a);\n\t}\n\tout[i * innerStride + k] = accumulator;\n}\n\nkernel void amin_f64(\n\tuint reductionDim,\n\tglobal double* a,\n\tglobal double* out)\n{\n\tconst uint innerStride = get_global_size(1);\n\tconst uint i = get_global_id(0);\n\tconst uint k = get_global_id(1);\n\ta += i * reductionDim * innerStride + k;\n\tdouble accumulator = *a;\n\twhile (--reductionDim) {\n\t\ta += innerStride;\n\t\taccumulator = min(accumulator, *a);\n\t}\n\tout[i * innerStride + k] = accumulator;\n}\n\nkernel void amax_f32(\n\tuint reductionDim,\n\tglobal float* a,\n\tglobal float* out)\n{\n\tconst uint innerStride = get_global_size(1);\n\tconst uint i = get_global_id(0);\n\tconst uint k = get_global_id(1);\n\ta += i * reductionDim * innerStride + k;\n\tfloat accumulator = *a;\n\twhile (--reductionDim) {\n\t\ta += innerStride;\n\t\taccumulator = max(accumulator, *a);\n\t}\n\tout[i * innerStride + k] = accumulator;\n}\n\nkernel void amax_f64(\n\tuint reductionDim,\n\tglobal double* a,\n\tglobal double* out)\n{\n\tconst uint innerStride = get_global_size(1);\n\tconst uint i = get_global_id(0);\n\tconst uint k = get_global_id(1);\n\ta += i * reductionDim * innerStride + k;\n\tdouble accumulator = *a;\n\twhile (--reductionDim) {\n\t\ta += innerStride;\n\t\taccumulator = max(accumulator, *a);\n\t}\n\tout[i * innerStride + k] = accumulator;\n}\n";
	var productKernelsSource = "kernel void dot_f32(\n\tuint reductionDim,\n\tglobal float* a,\n\tglobal float* b,\n\tglobal float* out)\n{\n\tconst uint i = get_global_id(0);\n\tconst uint k = get_global_id(1);\n\tconst uint l = get_global_id(2);\n\tconst uint outerStrideB = get_global_size(1);\n\tconst uint innerStrideB = get_global_size(2);\n\n\tfloat accumulator = 0.0f;\n\tfor (uint j = 0; j < reductionDim; ++j) {\n\t\taccumulator += a[i*reductionDim+j] * b[(k*reductionDim+j)*innerStrideB+l];\n\t}\n\tout[(i*outerStrideB + k) * innerStrideB + l] = accumulator;\n}\n\nkernel void dot_f64(\n\tuint reductionDim,\n\tglobal double* a,\n\tglobal double* b,\n\tglobal double* out)\n{\n\tconst uint i = get_global_id(0);\n\tconst uint k = get_global_id(1);\n\tconst uint l = get_global_id(2);\n\tconst uint outerStrideB = get_global_size(1);\n\tconst uint innerStrideB = get_global_size(2);\n\n\tdouble accumulator = 0.0;\n\tfor (uint j = 0; j < reductionDim; ++j) {\n\t\taccumulator += a[i*reductionDim+j] * b[(k*reductionDim+j)*innerStrideB+l];\n\t}\n\tout[(i*outerStrideB + k) * innerStrideB + l] = accumulator;\n}\n";
	var utilKernelsSource = "kernel void set_f32(\n\tuint length,\n\tglobal float* out,\n\tfloat value)\n{\n\tconst uint id = get_global_id(0);\n\tif (id < length) {\n\t\tout[id] = value;\n\t}\n}\nkernel void set_f64(\n\tuint length,\n\tglobal double* out,\n\tdouble value)\n{\n\tconst uint id = get_global_id(0);\n\tif (id < length) {\n\t\tout[id] = value;\n\t}\n}\n\nkernel void linspace_f32(\n\tuint length,\n\tglobal float* out,\n\tfloat start,\n\tfloat step)\n{\n\tconst uint id = get_global_id(0);\n\tif (id < length) {\n\t\tout[id] = start + step * ((float) id);\n\t}\n}\nkernel void linspace_f64(\n\tuint length,\n\tglobal double* out,\n\tdouble start,\n\tdouble step)\n{\n\tconst uint id = get_global_id(0);\n\tif (id < length) {\n\t\tout[id] = start + step * ((double) id);\n\t}\n}\n\nkernel void repeat_f32(\n\tuint expansionDim,\n\tuint innerStride,\n\tuint repeats,\n\tglobal float *restrict a,\n\tglobal float *restrict out)\n{\n\tconst uint i = get_global_id(0);\n\tconst uint j = get_global_id(1);\n\tconst uint k = get_global_id(2);\n\tconst float value = a[(i * expansionDim + j) * innerStride + k];\n\tuint offsetOut = (i * expansionDim + j) * repeats * innerStride + k;\n\tfor (uint c = 0; c < repeats; ++c) {\n\t\tout[offsetOut] = value;\n\t\toffsetOut += innerStride;\n\t}\n}\nkernel void repeat_f64(\n\tuint expansionDim,\n\tuint innerStride,\n\tuint repeats,\n\tglobal double *restrict a,\n\tglobal double *restrict out)\n{\n\tconst uint i = get_global_id(0);\n\tconst uint j = get_global_id(1);\n\tconst uint k = get_global_id(2);\n\tconst double value = a[(i * expansionDim + j) * innerStride + k];\n\tuint offsetOut = (i * expansionDim + j) * repeats * innerStride + k;\n\tfor (uint c = 0; c < repeats; ++c) {\n\t\tout[offsetOut] = value;\n\t\toffsetOut += innerStride;\n\t}\n}\n";
	var source = binaryKernelsSource + unaryKernelsSource + 
		reductionKernelsSource + axisReductionKernelsSource + 
		productKernelsSource + utilKernelsSource;

	var asyncCallbacks = options.asyncCallbacks;
	if (typeof asyncCallbacks === "undefined") {
		/* Currently only Node-WebCL supports asynchronous callbacks */
		this.asyncCallbacks = isNodeWebCL;
	} else {
		this.asyncCallbacks = !!asyncCallbacks;
	}
	var deviceName = options.device;
	if (deviceName) {
		var deviceIndex = availableDevicesDescriptions.indexOf(deviceName);
		if (deviceIndex === -1) {
			throw new Error("Invalid WebCL device name: " + deviceName);
		}
		this.device = availableDevices[deviceIndex];
	} else {
		var deviceIndex = getDefaultDeviceIndex();
		if (deviceIndex < 0) {
			throw new Error("No suitable WebCL device found");
		}
		this.device = availableDevices[deviceIndex];
	}
	this.device.enableExtension("KHR_fp64");
	this.deviceInfo = {
		deviceClass: classifyDevice(this.device),
		localMemorySize: this.device.getInfo(cl.DEVICE_LOCAL_MEM_SIZE),
		maxComputeUnits: this.device.getInfo(cl.DEVICE_MAX_COMPUTE_UNITS),
		maxWorkGroupSize: this.device.getInfo(cl.DEVICE_MAX_WORK_GROUP_SIZE),
		maxWorkItemSizes: this.device.getInfo(cl.DEVICE_MAX_WORK_ITEM_SIZES)
	};
	this.context = cl.createContext(this.device);
	this.queue = this.context.createCommandQueue(this.device);
	this.program = this.context.createProgram(source);
	try {
		/* Chromium-WebCL requires a list of devices */
		this.program.build([this.device]);
	} catch (e) {
		if (e.name === "INVALID_DEVICE") {
			/* Nokia-WebCL only works with no arguments to WebCLProgram.build */
			this.program.build();
		} else {
			throw e;
		}
	}
	this.kernels = createKernels(this.program);
	/* Context is ready for computations */
	callback(this);
}

/**
 * Returns the names of devices that can be used for computation.
 * Any of these names can be passed as a "device" option when creating a WebCL context.
 *
 * @static
 * @method getAvailableDevices
 * @return {String[]} - a possibly empty list of available device names.
 */
WebCLContext.getAvailableDevices = function() {
	if (WebCLContext.isUsable()) {
		return availableDevicesDescriptions;
	} else {
		return [];
	}
};

/**
 * Returns the name of the default device used for computation.
 *
 * @static
 * @method getDefaultDevice
 * @return {String} - the name of the default WebCL device or null if no suitable device available.
 */
WebCLContext.getDefaultDevice = function() {
	var deviceIndex = getDefaultDeviceIndex();
	if (deviceIndex < 0) {
		return null;
	} else {
		return availableDevicesDescriptions[deviceIndex];
	}
};

/**
 * Checks if WebCL is supported by the environment.
 *
 * @static
 * @method isSupported
 * @return {Boolean} - true if WebCL is supported on this system and false otherwise.
 */
WebCLContext.isSupported = function() {
	return initWebCL() !== null;
};

/**
 * Checks if WebCL can be used for computation.
 * WebCL is usable for computations if it is supported by JS engine (or Node.js) and there is at least one CPU or GPU device with KHR_fp64 extension.
 *
 * @static
 * @method isUsable
 * @return {Boolean} - true if WebCL is usable on this system and false otherwise.
 */
WebCLContext.isUsable = function() {
	var webcl = initWebCL();
	if (webcl === null) {
		return false;
	}
	var availableDevices = getAvailableDevices();
	return availableDevices.length !== 0;
};

WebCLContext.prototype.empty = function(shape, dataType) {
	shape = util.checkShape(shape);
	if (typeof dataType === "undefined") {
		dataType = new DataType("f64");
	} else if (!(dataType instanceof DataType)) {
		throw new TypeError(dataType + " is not an instance of DataType");
	}
	var array = new NDArray(shape, dataType, this);
	array._buffer = this.context.createBuffer(cl.MEM_READ_WRITE, array.length * dataType.size);
	return array;
};

WebCLContext.prototype.zeros = function(shape, dataType) {
	shape = util.checkShape(shape);
	if (typeof dataType === "undefined") {
		dataType = new DataType("f64");
	} else if (!(dataType instanceof DataType)) {
		throw new TypeError(dataType + " is not an instance of DataType");
	}
	var array = new NDArray(shape, dataType, this);
	array._buffer = this.context.createBuffer(cl.MEM_READ_WRITE, array.length * dataType.size);
	var kernel = this.kernels.set[dataType.type];
	kernel.setArg(0, new Uint32Array([array.length]));
	kernel.setArg(1, array._buffer);
	kernel.setArg(2, new dataType.arrayType([0.0]));
	this.queue.enqueueNDRangeKernel(kernel, 1, null, [array.length]);
	return array;
};

WebCLContext.prototype.ones = function(shape, dataType) {
	shape = util.checkShape(shape);
	if (typeof dataType === "undefined") {
		dataType = new DataType("f64");
	} else if (!(dataType instanceof DataType)) {
		throw new TypeError(dataType + " is not an instance of DataType");
	}
	var array = new NDArray(shape, dataType, this);
	array._buffer = this.context.createBuffer(cl.MEM_READ_WRITE, array.length * dataType.size);
	var kernel = this.kernels.set[dataType.type];
	kernel.setArg(0, new Uint32Array([array.length]));
	kernel.setArg(1, array._buffer);
	kernel.setArg(2, new dataType.arrayType([1.0]));
	this.queue.enqueueNDRangeKernel(kernel, 1, null, [array.length]);
	return array;
};

WebCLContext.prototype.array = function(data, dataType) {
	if (typeof dataType === "undefined") {
		dataType = new DataType("f64");
	} else {
		dataType = util.checkDataType(dataType);
	}
	var shape = [];
	util.discoverArrayShapeRecursive(data, shape, 0);
	var array = new NDArray(shape, dataType, this);
	var buffer = new dataType.arrayType(array.length);
	util.copyArrayDataRecursive(buffer, data, shape, 0, 0);
	if (useBufferCreationWithInit) {
		array._buffer = this.context.createBuffer(cl.MEM_READ_WRITE, buffer.byteLength, buffer);
	} else {
		array._buffer = this.context.createBuffer(cl.MEM_READ_WRITE, buffer.byteLength);
		this.queue.enqueueWriteBuffer(array._buffer, false, 0, buffer.byteLength, buffer);
	}
	return array;
};

WebCLContext.prototype.linspace = function(start, stop, samples, closed) {
	if (!util.isReal(start)) {
		throw new TypeError(start + " is not a real number");
	}
	if (!util.isReal(stop)) {
		throw new TypeError(stop + " is not a real number");
	}
	if (typeof samples === "undefined") {
		/* Default value in NumPy */
		samples = 50;
	} else if (!util.isInt(samples)) {
		throw new TypeError(samples + " is not an integer");
	} else if (samples <= 0) {
		throw new RangeError("The number of samples must be positive");
	}
	if (typeof closed === "undefined") {
		closed = true;
	}
	if (closed && (samples === 1)) {
		throw new RangeError("The number of samples must be a least 2 (for start and end points)");
	}

	var dataType = new DataType("f64");
	var array = new NDArray([samples], dataType, this);
	array._buffer = this.context.createBuffer(cl.MEM_READ_WRITE, samples * dataType.size);

	var range = stop - start;
	var n = (closed) ? samples - 1 : samples;
	var step = range / n;

	var kernel = this.kernels.linspace[dataType.type];
	kernel.setArg(0, new Uint32Array([array.length]));
	kernel.setArg(1, array._buffer);
	kernel.setArg(2, new dataType.arrayType([start]));
	kernel.setArg(3, new dataType.arrayType([step]));
	this.queue.enqueueNDRangeKernel(kernel, 1, null, [array.length]);

	return array;
};

WebCLContext.prototype._invalidate = function(array) {
	if (array._buffer !== null) {
		/* Work-around for Chromium-WebCL that currently lacks WebCLMemObject.release method */
		if (typeof array._buffer.release !== "undefined") {
			array._buffer.release();
		}
		array._buffer = null;
	}
};

WebCLContext.prototype.fetch = function() {
	if (arguments.length === 0) {
		throw new Error("Callback argument missing");
	}
	var callback = arguments[arguments.length - 1];
	/* Validate arguments */
	if (arguments.length === 1) {
		throw new Error("At least one NDArray argument expected");
	}
	for (var i = 0; i < arguments.length - 1; i++) {
		if (!(arguments[i] instanceof NDArray)) {
			throw new TypeError("Argument " + i + " is not an NDArray");
		}
	}
	var callbackWaitArguments = arguments.length - 1;
	var callbackArguments = new Array(callbackWaitArguments);
	if (this.asyncCallbacks) {
		var asyncEvents = [];
		for (var i = 0; i < callbackWaitArguments; i++) {
			var array = arguments[i];
			(function(queue, i, shape, ArrayType) {
				var buffer = new ArrayType(array.length);
				var readFinishEvent = createEvent();
				asyncEvents.push(readFinishEvent);
				queue.enqueueReadBuffer(array._buffer, false, 0, buffer.byteLength, buffer, null, readFinishEvent);
				readFinishEvent.setCallback(cl.COMPLETE, function() {
					readFinishEvent.release();
					callbackArguments[i] = buffer;
					if (--callbackWaitArguments === 0) {
						callback.apply(null, callbackArguments);
						/* OpenCL standard: commands enqueued in a callback won't start until clFlush */
						queue.flush();
					}
				});
			})(this.queue, i, array.shape, array.dataType.arrayType);
			/* This line mostly serializes execution. Unfortunately, without it nothing works */
			cl.waitForEvents(asyncEvents);
		}
	} else {
		for (var i = 0; i < callbackWaitArguments; i++) {
			var array = arguments[i];
			var buffer = new array.dataType.arrayType(array.length);
			this.queue.enqueueReadBuffer(array._buffer, true, 0, buffer.byteLength, buffer);
			callbackArguments[i] = buffer;
		}
		callback.apply(null, callbackArguments);
	}
};

WebCLContext.prototype.get = function() {
	if (arguments.length === 0) {
		throw new Error("Callback argument missing");
	}
	var callback = arguments[arguments.length - 1];
	/* Validate arguments */
	if (arguments.length === 1) {
		throw new Error("At least one NDArray argument expected");
	}
	for (var i = 0; i < arguments.length - 1; i++) {
		if (!(arguments[i] instanceof NDArray)) {
			throw new TypeError("Argument " + i + " is not an NDArray");
		}
	}
	var callbackWaitArguments = arguments.length - 1;
	var callbackArguments = new Array(callbackWaitArguments);
	if (this.asyncCallbacks) {
		var asyncEvents = [];
		for (var i = 0; i < callbackWaitArguments; i++) {
			var array = arguments[i];
			(function(queue, i, shape, ArrayType) {
				var buffer = new ArrayType(array.length);
				var readFinishEvent = createEvent();
				asyncEvents.push(readFinishEvent);
				queue.enqueueReadBuffer(array._buffer, false, 0, buffer.byteLength, buffer, null, readFinishEvent);
				if (shape.length === 0) {
					readFinishEvent.setCallback(cl.COMPLETE, function() {
						readFinishEvent.release();
						callbackArguments[i] = buffer[0];
						if (--callbackWaitArguments === 0) {
							callback.apply(null, callbackArguments);
							/* OpenCL standard: commands enqueued in a callback won't start until clFlush */
							queue.flush();
						}
					});
				} else {
					readFinishEvent.setCallback(cl.COMPLETE, function() {
						readFinishEvent.release();
						var jsarray = new Array(shape[0]);
						util.createArrayRecursive(new ArrayType(buffer), jsarray, shape, 0, 0);
						callbackArguments[i] = jsarray;
						if (--callbackWaitArguments === 0) {
							callback.apply(null, callbackArguments);
							/* OpenCL standard: commands enqueued in a callback won't start until clFlush */
							queue.flush();
						}
					});
				}
			})(this.queue, i, array.shape, array.dataType.arrayType);
			/* This line mostly serializes execution. Unfortunately, without it nothing works */
			cl.waitForEvents(asyncEvents);
		}
	} else {
		for (var i = 0; i < callbackWaitArguments; i++) {
			var array = arguments[i];
			var buffer = new array.dataType.arrayType(array.length);
			this.queue.enqueueReadBuffer(array._buffer, true, 0, buffer.byteLength, buffer);
			if (array.shape.length === 0) {
				callbackArguments[i] = buffer[0];
			} else {
				var jsarray = new Array(array.shape[0]);
				util.createArrayRecursive(new array.dataType.arrayType(buffer), jsarray, array.shape, 0, 0);
				callbackArguments[i] = jsarray;
			}
		}
		callback.apply(null, callbackArguments);
	}
};

WebCLContext.prototype.barrier = function(callback) {
	var barrierEvent = createEvent();
	this.queue.enqueueMarker(barrierEvent);
	if (this.asyncCallbacks) {
		var queue = this.queue;
		barrierEvent.setCallback(cl.COMPLETE, function() {
			barrierEvent.release();
			callback();
			/* OpenCL standard: commands enqueued in a callback won't start until clFlush */
			queue.flush();
		});
		cl.waitForEvents([barrierEvent]);
	} else {
		cl.waitForEvents([barrierEvent]);
		callback();
	}
};

WebCLContext.prototype.reshape = function(a, shape) {
	shape = util.checkShape(shape);
	if (util.computeLength(shape) !== a.length) {
		throw new RangeError("The shape is not compatible with the array");
	}
	var out = new NDArray(shape, a.dataType, this);
	if (a._decRef()) {
		out._buffer = this.context.createBuffer(webcl.MEM_READ_WRITE, out.length * out.dataType.size);
		this.queue.enqueueCopyBuffer(a._buffer, out._buffer, 0, 0, out.length * out.dataType.size);
	} else {
		out._buffer = a._buffer;
		a._buffer = null;
	}
	return out;
};

WebCLContext.prototype.repeat = function(a, repeats, axis, out) {
	util.checkNDArray(a, "a");
	repeats = util.checkRepeats(repeats);
	axis = util.checkAxis(axis, a.shape.length);
	var shapeA = a.shape;
	var shapeOut = shapeA.slice(0);
	shapeOut[axis] *= repeats;
	a._decRef();
	try {
		if (typeof out === "undefined") {
			out = new NDArray(shapeOut, a.dataType, this);
			out._buffer = this.context.createBuffer(cl.MEM_READ_WRITE, out.length * out.dataType.size);
		} else {
			util.checkNDArray(out, "out");
			util.checkShapesCompatibility(out.shape, shapeOut);
			util.checkDataTypesCompatibility(a.dataType, out.dataType);
			out._incRef();
		}
		var outerStride = util.computeOuterStride(shapeA, axis);
		var expansionDim = shapeA[axis];
		var innerStride = util.computeInnerStride(shapeA, axis);
		var kernel = this.kernels.repeat[a.dataType.type];
		kernel.setArg(0, new Uint32Array([expansionDim]));
		kernel.setArg(1, new Uint32Array([innerStride]));
		kernel.setArg(2, new Uint32Array([repeats]));
		kernel.setArg(3, a._buffer);
		kernel.setArg(4, out._buffer);
		this.queue.enqueueNDRangeKernel(kernel, 3, null, [outerStride, expansionDim, innerStride]);
	} catch (e) {
		a._incRef();
		throw e;
	}
	a._tryInvalidate();
	return out;
};

var binaryArithOp = function(a, b, out, furiousContext, binaryOpKernels, binaryConstOpKernels, binaryRevConstKernels) {
	var shapeOut = null, dataTypeOut = null;
	var bufferA = null, bufferB = null;
	if (a instanceof NDArray) {
		bufferA = a._buffer;
		shapeOut = a.shape;
		dataTypeOut = a.dataType;
		if (b instanceof NDArray) {
			bufferB = b._buffer;
			util.checkShapesCompatibility(a.shape, b.shape);
			util.checkDataTypesCompatibility(a.dataType, b.dataType);
		} else if (!util.isNumber(b)) {
			throw new TypeError("Unsupported type of b");
		}
	} else if (util.isNumber(a)) {
		util.checkNDArray(b, "b");
		bufferB = b._buffer;
		shapeOut = b.shape;
		dataTypeOut = b.dataType;
	} else {
		throw new TypeError("Unsupported type of a");
	}
	if (a instanceof NDArray) {
		a._decRef();
	}
	if (b instanceof NDArray) {
		b._decRef();
	}
	try {
		if (typeof out === "undefined") {
			out = new NDArray(shapeOut, dataTypeOut, furiousContext);
			if ((a instanceof NDArray) && !a._hasRefs()) {
				out._buffer = a._buffer;
				a._buffer = null;
			} else if ((b instanceof NDArray) && !b._hasRefs()) {
				out._buffer = b._buffer;
				b._buffer = null;
			} else {
				out._buffer = furiousContext.context.createBuffer(cl.MEM_READ_WRITE, out.length * out.dataType.size);
			}
		} else {
			util.checkNDArray(out, "out");
			util.checkShapesCompatibility(shapeOut, out.shape);
			util.checkDataTypesCompatibility(dataTypeOut, out.dataType);
			out._incRef();
		}
		if (a instanceof NDArray) {
			if (b instanceof NDArray) {
				var kernel = binaryOpKernels[dataTypeOut.type];
				kernel.setArg(0, new Uint32Array([out.length]));
				kernel.setArg(1, bufferA);
				kernel.setArg(2, bufferB);
				kernel.setArg(3, out._buffer);
				furiousContext.queue.enqueueNDRangeKernel(kernel, 1, null, [out.length]);
			} else {
				var kernel = binaryConstOpKernels[dataTypeOut.type];
				kernel.setArg(0, new Uint32Array([out.length]));
				kernel.setArg(1, bufferA);
				kernel.setArg(2, new dataTypeOut.arrayType([b]));
				kernel.setArg(3, out._buffer);
				furiousContext.queue.enqueueNDRangeKernel(kernel, 1, null, [out.length]);
			}
		} else {
			var kernel = binaryRevConstKernels[dataTypeOut.type];
			kernel.setArg(0, new Uint32Array([out.length]));
			kernel.setArg(1, bufferB);
			kernel.setArg(2, new dataTypeOut.arrayType([a]));
			kernel.setArg(3, out._buffer);
			furiousContext.queue.enqueueNDRangeKernel(kernel, 1, null, [out.length]);
		}
	} catch (e) {
		/* Restore the previous state */
		if (a instanceof NDArray) {
			a._incRef();
		}
		if (b instanceof NDArray) {
			b._incRef();
		}
		throw e;
	}
	if (a instanceof NDArray) {
		a._tryInvalidate();
	}
	if (b instanceof NDArray) {
		b._tryInvalidate();
	}
	return out;
};

var unaryArithOp = function(a, out, furiousContext, unaryOpKernels) {
	util.checkNDArray(a, "a");
	a._decRef();
	var bufferA = a._buffer;
	try {
		if (typeof out === "undefined") {
			out = new NDArray(a.shape, a.dataType, furiousContext);
			if ((a instanceof NDArray) && !a._hasRefs()) {
				out._buffer = a._buffer;
				a._buffer = null;
			} else {
				out._buffer = furiousContext.context.createBuffer(cl.MEM_READ_WRITE, out.length * out.dataType.size);
			}
		} else {
			util.checkNDArray(out, "out");
			util.checkShapesCompatibility(a.shape, out.shape);
			util.checkDataTypesCompatibility(a.dataType, out.dataType);
			out._incRef();
		}
		var kernel = unaryOpKernels[a.dataType.type];
		kernel.setArg(0, new Uint32Array([out.length]));
		kernel.setArg(1, bufferA);
		kernel.setArg(2, out._buffer);
		furiousContext.queue.enqueueNDRangeKernel(kernel, 1, null, [out.length]);
	} catch (e) {
		/* Restore the previous state */
		a._incRef();
		throw e;
	}
	a._tryInvalidate();
	return out;
};

var axisReduceOp = function(a, axis, out, furiousContext, reduceKernels, axisReduceKernels) {
	util.checkNDArray(a, "a");
	if (typeof axis === "undefined") {
		if (typeof out === "undefined") {
			out = new NDArray([], a.dataType, furiousContext);
			out._buffer = furiousContext.context.createBuffer(cl.MEM_READ_WRITE, a.dataType.size);
		} else {
			util.checkNDArray(out, "out");
			util.checkShapesCompatibility([], out.shape);
			util.checkDataTypesCompatibility(a.dataType, out.dataType);
			out._incRef();
		}
		var lengthA = a.length;
		var maxWorkItemsPerCU = Math.min(
			Math.min(furiousContext.deviceInfo.maxWorkGroupSize,
				furiousContext.deviceInfo.maxWorkItemSizes[0]), 
			furiousContext.deviceInfo.localMemorySize / a.dataType.size);
		/* The minimal ammount of parallelism that justifies switching to two-pass reduction */
		var parallelisationThreshold = 16;
		var kernel = reduceKernels[a.dataType.type];
		if (lengthA < maxWorkItemsPerCU * parallelisationThreshold) {
			/* One reduction is enough */
			kernel.setArg(0, new Uint32Array([lengthA]));
			kernel.setArg(1, a._buffer);
			kernel.setArg(2, new Uint32Array([maxWorkItemsPerCU * a.dataType.size]));
			kernel.setArg(3, out._buffer);
			/* Important: use only one work group */
			furiousContext.queue.enqueueNDRangeKernel(kernel, 1, null, [maxWorkItemsPerCU], [maxWorkItemsPerCU]);
		} else {
			/* Two-step reduction */
			var maxComputeUnits = furiousContext.deviceInfo.maxComputeUnits;
			var workGroupSizeMultiple = kernel.getWorkGroupInfo(furiousContext.device, cl.KERNEL_PREFERRED_WORK_GROUP_SIZE_MULTIPLE);
			var tempBuffer = furiousContext.context.createBuffer(cl.MEM_READ_WRITE, maxComputeUnits * a.dataType.size);

			kernel.setArg(0, new Uint32Array([lengthA]));
			kernel.setArg(1, a._buffer);
			kernel.setArg(2, new Uint32Array([maxWorkItemsPerCU * a.dataType.size]));
			kernel.setArg(3, tempBuffer);
			furiousContext.queue.enqueueNDRangeKernel(kernel, 1, null,
				[maxWorkItemsPerCU * maxComputeUnits],
				[maxWorkItemsPerCU]);

			var workGroupSize = Math.min(maxWorkItemsPerCU,
				util.roundUp(maxComputeUnits, workGroupSizeMultiple));
			kernel.setArg(0, new Uint32Array([maxComputeUnits]));
			kernel.setArg(1, tempBuffer);
			kernel.setArg(2, new Uint32Array([workGroupSize * a.dataType.size]));
			kernel.setArg(3, out._buffer);
			/* Important: use only one work group */
			furiousContext.queue.enqueueNDRangeKernel(kernel, 1, null,
				[workGroupSize],
				[workGroupSize]);

			tempBuffer.release();
		}
		a._tryRelease();
		return out;
	} else {
		axis = util.checkAxis(axis, a.shape.length);
		var shapeOut = util.computeAxisReductionOutShape(a.shape, axis);
		if (typeof out === "undefined") {
			out = new NDArray(shapeOut, a.dataType, furiousContext);
			out._buffer = furiousContext.context.createBuffer(cl.MEM_READ_WRITE, a.dataType.size * out.length);
		} else {
			util.checkNDArray(out, "out");
			util.checkShapesCompatibility([], out.shape);
			util.checkDataTypesCompatibility(a.dataType, out.dataType);
			out._incRef();
		}
		var outerStride = util.computeOuterStride(a.shape, axis);
		var reductionDim = a.shape[axis];
		var innerStride = util.computeInnerStride(a.shape, axis);
		var kernel = axisReduceKernels[a.dataType.type];
		kernel.setArg(0, new Uint32Array([reductionDim]));
		kernel.setArg(1, a._buffer);
		kernel.setArg(2, out._buffer);
		furiousContext.queue.enqueueNDRangeKernel(kernel, 2, null,
			[outerStride, innerStride]);
		a._tryRelease();
		return out;
	}
};


WebCLContext.prototype.add = function(a, b, out) {
	return binaryArithOp(a, b, out, this, this.kernels.add, this.kernels.addc, this.kernels.addc);
};

WebCLContext.prototype.sub = function(a, b, out) {
	return binaryArithOp(a, b, out, this, this.kernels.sub, this.kernels.subc, this.kernels.subrc);
};

WebCLContext.prototype.mul = function(a, b, out) {
	return binaryArithOp(a, b, out, this, this.kernels.mul, this.kernels.mulc, this.kernels.mulc);
};

WebCLContext.prototype.div = function(a, b, out) {
	return binaryArithOp(a, b, out, this, this.kernels.div, this.kernels.divc, this.kernels.divrc);
};

WebCLContext.prototype.neg = function(a, out) {
	return unaryArithOp(a, out, this, this.kernels.neg);
};

WebCLContext.prototype.abs = function(a, out) {
	return unaryArithOp(a, out, this, this.kernels.abs);
};

WebCLContext.prototype.exp = function(a, out) {
	return unaryArithOp(a, out, this, this.kernels.exp);
};

WebCLContext.prototype.log = function(a, out) {
	return unaryArithOp(a, out, this, this.kernels.log);
};

WebCLContext.prototype.sqrt = function(a, out) {
	return unaryArithOp(a, out, this, this.kernels.sqrt);
};

WebCLContext.prototype.square = function(a, out) {
	return unaryArithOp(a, out, this, this.kernels.square);
};

WebCLContext.prototype.min = function(a, axis, out) {
	return axisReduceOp(a, axis, out, this, this.kernels.min, this.kernels.amin);
};

WebCLContext.prototype.max = function(a, axis, out) {
	return axisReduceOp(a, axis, out, this, this.kernels.max, this.kernels.amax);
};

WebCLContext.prototype.sum = function(a, axis, out) {
	return axisReduceOp(a, axis, out, this, this.kernels.sum, this.kernels.asum);
};

WebCLContext.prototype.dot = function(a, b, out) {
	util.checkNDArray(a, "a");
	util.checkNDArray(b, "b");
	util.checkDataTypesCompatibility(a.dataType, b.dataType);

	/* The axis of b used in reduction: axis 0 for 1D array, second-to-last axis for ND array */
	var aAxis = Math.max(a.shape.length - 1, 0);
	var bAxis = Math.max(b.shape.length - 2, 0);
	var reductionDim = a.shape[aAxis];
	if (reductionDim !== b.shape[bAxis]) {
		throw new RangeError("Arrays have incompatible reduction dimensions");
	}
	var shapeOut = [], strideA = 1, outerStrideB = 1, innerStrideB = 1;
	for (var i = 0; i < aAxis; i++) {
		shapeOut.push(a.shape[i]);
		strideA *= a.shape[i];
	}
	for (var i = 0; i < b.shape.length; i++) {
		var dim = b.shape[i];
		if (i < bAxis) {
			outerStrideB *= dim;
			shapeOut.push(dim);
		} else if (i > bAxis) {
			innerStrideB *= dim;
			shapeOut.push(dim);
		}
	}
	if (typeof out === "undefined") {
		out = this.empty(shapeOut, a.dataType);
	} else if (out instanceof NDArray) {
		util.checkNDArray(out, "out");
		util.checkShapesCompatibility(out.shape, shapeOut);
		util.checkDataTypesCompatibility(out.dataType, a.dataType);
		util.checkDifferentNDArrays(a, out, "a", "out");
		util.checkDifferentNDArrays(b, out, "b", "out");
		out._incRef();
	}
	var kernel = this.kernels.dot[out.dataType.type];
	kernel.setArg(0, new Uint32Array([reductionDim]));
	kernel.setArg(1, a._buffer);
	kernel.setArg(2, b._buffer);
	kernel.setArg(3, out._buffer);
	this.queue.enqueueNDRangeKernel(kernel, 3, null,
		[strideA, outerStrideB, innerStrideB]);
	a._tryRelease();
	b._tryRelease();
	return out;
};

module.exports = WebCLContext;

},{"../DataType":1,"../NDArray":2,"../util":12}],14:[function(require,module,exports){
module.exports = require('./lib/chai');

},{"./lib/chai":15}],15:[function(require,module,exports){
/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

var used = []
  , exports = module.exports = {};

/*!
 * Chai version
 */

exports.version = '1.9.1';

/*!
 * Assertion Error
 */

exports.AssertionError = require('assertion-error');

/*!
 * Utils for plugins (not exported)
 */

var util = require('./chai/utils');

/**
 * # .use(function)
 *
 * Provides a way to extend the internals of Chai
 *
 * @param {Function}
 * @returns {this} for chaining
 * @api public
 */

exports.use = function (fn) {
  if (!~used.indexOf(fn)) {
    fn(this, util);
    used.push(fn);
  }

  return this;
};

/*!
 * Configuration
 */

var config = require('./chai/config');
exports.config = config;

/*!
 * Primary `Assertion` prototype
 */

var assertion = require('./chai/assertion');
exports.use(assertion);

/*!
 * Core Assertions
 */

var core = require('./chai/core/assertions');
exports.use(core);

/*!
 * Expect interface
 */

var expect = require('./chai/interface/expect');
exports.use(expect);

/*!
 * Should interface
 */

var should = require('./chai/interface/should');
exports.use(should);

/*!
 * Assert interface
 */

var assert = require('./chai/interface/assert');
exports.use(assert);

},{"./chai/assertion":16,"./chai/config":17,"./chai/core/assertions":18,"./chai/interface/assert":19,"./chai/interface/expect":20,"./chai/interface/should":21,"./chai/utils":32,"assertion-error":41}],16:[function(require,module,exports){
/*!
 * chai
 * http://chaijs.com
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

var config = require('./config');

module.exports = function (_chai, util) {
  /*!
   * Module dependencies.
   */

  var AssertionError = _chai.AssertionError
    , flag = util.flag;

  /*!
   * Module export.
   */

  _chai.Assertion = Assertion;

  /*!
   * Assertion Constructor
   *
   * Creates object for chaining.
   *
   * @api private
   */

  function Assertion (obj, msg, stack) {
    flag(this, 'ssfi', stack || arguments.callee);
    flag(this, 'object', obj);
    flag(this, 'message', msg);
  }

  Object.defineProperty(Assertion, 'includeStack', {
    get: function() {
      console.warn('Assertion.includeStack is deprecated, use chai.config.includeStack instead.');
      return config.includeStack;
    },
    set: function(value) {
      console.warn('Assertion.includeStack is deprecated, use chai.config.includeStack instead.');
      config.includeStack = value;
    }
  });

  Object.defineProperty(Assertion, 'showDiff', {
    get: function() {
      console.warn('Assertion.showDiff is deprecated, use chai.config.showDiff instead.');
      return config.showDiff;
    },
    set: function(value) {
      console.warn('Assertion.showDiff is deprecated, use chai.config.showDiff instead.');
      config.showDiff = value;
    }
  });

  Assertion.addProperty = function (name, fn) {
    util.addProperty(this.prototype, name, fn);
  };

  Assertion.addMethod = function (name, fn) {
    util.addMethod(this.prototype, name, fn);
  };

  Assertion.addChainableMethod = function (name, fn, chainingBehavior) {
    util.addChainableMethod(this.prototype, name, fn, chainingBehavior);
  };

  Assertion.overwriteProperty = function (name, fn) {
    util.overwriteProperty(this.prototype, name, fn);
  };

  Assertion.overwriteMethod = function (name, fn) {
    util.overwriteMethod(this.prototype, name, fn);
  };

  Assertion.overwriteChainableMethod = function (name, fn, chainingBehavior) {
    util.overwriteChainableMethod(this.prototype, name, fn, chainingBehavior);
  };

  /*!
   * ### .assert(expression, message, negateMessage, expected, actual)
   *
   * Executes an expression and check expectations. Throws AssertionError for reporting if test doesn't pass.
   *
   * @name assert
   * @param {Philosophical} expression to be tested
   * @param {String} message to display if fails
   * @param {String} negatedMessage to display if negated expression fails
   * @param {Mixed} expected value (remember to check for negation)
   * @param {Mixed} actual (optional) will default to `this.obj`
   * @api private
   */

  Assertion.prototype.assert = function (expr, msg, negateMsg, expected, _actual, showDiff) {
    var ok = util.test(this, arguments);
    if (true !== showDiff) showDiff = false;
    if (true !== config.showDiff) showDiff = false;

    if (!ok) {
      var msg = util.getMessage(this, arguments)
        , actual = util.getActual(this, arguments);
      throw new AssertionError(msg, {
          actual: actual
        , expected: expected
        , showDiff: showDiff
      }, (config.includeStack) ? this.assert : flag(this, 'ssfi'));
    }
  };

  /*!
   * ### ._obj
   *
   * Quick reference to stored `actual` value for plugin developers.
   *
   * @api private
   */

  Object.defineProperty(Assertion.prototype, '_obj',
    { get: function () {
        return flag(this, 'object');
      }
    , set: function (val) {
        flag(this, 'object', val);
      }
  });
};

},{"./config":17}],17:[function(require,module,exports){
module.exports = {

  /**
   * ### config.includeStack
   *
   * User configurable property, influences whether stack trace
   * is included in Assertion error message. Default of false
   * suppresses stack trace in the error message.
   *
   *     chai.config.includeStack = true;  // enable stack on error
   *
   * @param {Boolean}
   * @api public
   */

   includeStack: false,

  /**
   * ### config.showDiff
   *
   * User configurable property, influences whether or not
   * the `showDiff` flag should be included in the thrown
   * AssertionErrors. `false` will always be `false`; `true`
   * will be true when the assertion has requested a diff
   * be shown.
   *
   * @param {Boolean}
   * @api public
   */

  showDiff: true,

  /**
   * ### config.truncateThreshold
   *
   * User configurable property, sets length threshold for actual and
   * expected values in assertion errors. If this threshold is exceeded,
   * the value is truncated.
   *
   * Set it to zero if you want to disable truncating altogether.
   *
   *     chai.config.truncateThreshold = 0;  // disable truncating
   *
   * @param {Number}
   * @api public
   */

  truncateThreshold: 40

};

},{}],18:[function(require,module,exports){
/*!
 * chai
 * http://chaijs.com
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

module.exports = function (chai, _) {
  var Assertion = chai.Assertion
    , toString = Object.prototype.toString
    , flag = _.flag;

  /**
   * ### Language Chains
   *
   * The following are provided as chainable getters to
   * improve the readability of your assertions. They
   * do not provide testing capabilities unless they
   * have been overwritten by a plugin.
   *
   * **Chains**
   *
   * - to
   * - be
   * - been
   * - is
   * - that
   * - and
   * - has
   * - have
   * - with
   * - at
   * - of
   * - same
   *
   * @name language chains
   * @api public
   */

  [ 'to', 'be', 'been'
  , 'is', 'and', 'has', 'have'
  , 'with', 'that', 'at'
  , 'of', 'same' ].forEach(function (chain) {
    Assertion.addProperty(chain, function () {
      return this;
    });
  });

  /**
   * ### .not
   *
   * Negates any of assertions following in the chain.
   *
   *     expect(foo).to.not.equal('bar');
   *     expect(goodFn).to.not.throw(Error);
   *     expect({ foo: 'baz' }).to.have.property('foo')
   *       .and.not.equal('bar');
   *
   * @name not
   * @api public
   */

  Assertion.addProperty('not', function () {
    flag(this, 'negate', true);
  });

  /**
   * ### .deep
   *
   * Sets the `deep` flag, later used by the `equal` and
   * `property` assertions.
   *
   *     expect(foo).to.deep.equal({ bar: 'baz' });
   *     expect({ foo: { bar: { baz: 'quux' } } })
   *       .to.have.deep.property('foo.bar.baz', 'quux');
   *
   * @name deep
   * @api public
   */

  Assertion.addProperty('deep', function () {
    flag(this, 'deep', true);
  });

  /**
   * ### .a(type)
   *
   * The `a` and `an` assertions are aliases that can be
   * used either as language chains or to assert a value's
   * type.
   *
   *     // typeof
   *     expect('test').to.be.a('string');
   *     expect({ foo: 'bar' }).to.be.an('object');
   *     expect(null).to.be.a('null');
   *     expect(undefined).to.be.an('undefined');
   *
   *     // language chain
   *     expect(foo).to.be.an.instanceof(Foo);
   *
   * @name a
   * @alias an
   * @param {String} type
   * @param {String} message _optional_
   * @api public
   */

  function an (type, msg) {
    if (msg) flag(this, 'message', msg);
    type = type.toLowerCase();
    var obj = flag(this, 'object')
      , article = ~[ 'a', 'e', 'i', 'o', 'u' ].indexOf(type.charAt(0)) ? 'an ' : 'a ';

    this.assert(
        type === _.type(obj)
      , 'expected #{this} to be ' + article + type
      , 'expected #{this} not to be ' + article + type
    );
  }

  Assertion.addChainableMethod('an', an);
  Assertion.addChainableMethod('a', an);

  /**
   * ### .include(value)
   *
   * The `include` and `contain` assertions can be used as either property
   * based language chains or as methods to assert the inclusion of an object
   * in an array or a substring in a string. When used as language chains,
   * they toggle the `contain` flag for the `keys` assertion.
   *
   *     expect([1,2,3]).to.include(2);
   *     expect('foobar').to.contain('foo');
   *     expect({ foo: 'bar', hello: 'universe' }).to.include.keys('foo');
   *
   * @name include
   * @alias contain
   * @param {Object|String|Number} obj
   * @param {String} message _optional_
   * @api public
   */

  function includeChainingBehavior () {
    flag(this, 'contains', true);
  }

  function include (val, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    var expected = false;
    if (_.type(obj) === 'array' && _.type(val) === 'object') {
      for (var i in obj) {
        if (_.eql(obj[i], val)) {
          expected = true;
          break;
        }
      }
    } else if (_.type(val) === 'object') {
      if (!flag(this, 'negate')) {
        for (var k in val) new Assertion(obj).property(k, val[k]);
        return;
      }
      var subset = {}
      for (var k in val) subset[k] = obj[k]
      expected = _.eql(subset, val);
    } else {
      expected = obj && ~obj.indexOf(val)
    }
    this.assert(
        expected
      , 'expected #{this} to include ' + _.inspect(val)
      , 'expected #{this} to not include ' + _.inspect(val));
  }

  Assertion.addChainableMethod('include', include, includeChainingBehavior);
  Assertion.addChainableMethod('contain', include, includeChainingBehavior);

  /**
   * ### .ok
   *
   * Asserts that the target is truthy.
   *
   *     expect('everthing').to.be.ok;
   *     expect(1).to.be.ok;
   *     expect(false).to.not.be.ok;
   *     expect(undefined).to.not.be.ok;
   *     expect(null).to.not.be.ok;
   *
   * @name ok
   * @api public
   */

  Assertion.addProperty('ok', function () {
    this.assert(
        flag(this, 'object')
      , 'expected #{this} to be truthy'
      , 'expected #{this} to be falsy');
  });

  /**
   * ### .true
   *
   * Asserts that the target is `true`.
   *
   *     expect(true).to.be.true;
   *     expect(1).to.not.be.true;
   *
   * @name true
   * @api public
   */

  Assertion.addProperty('true', function () {
    this.assert(
        true === flag(this, 'object')
      , 'expected #{this} to be true'
      , 'expected #{this} to be false'
      , this.negate ? false : true
    );
  });

  /**
   * ### .false
   *
   * Asserts that the target is `false`.
   *
   *     expect(false).to.be.false;
   *     expect(0).to.not.be.false;
   *
   * @name false
   * @api public
   */

  Assertion.addProperty('false', function () {
    this.assert(
        false === flag(this, 'object')
      , 'expected #{this} to be false'
      , 'expected #{this} to be true'
      , this.negate ? true : false
    );
  });

  /**
   * ### .null
   *
   * Asserts that the target is `null`.
   *
   *     expect(null).to.be.null;
   *     expect(undefined).not.to.be.null;
   *
   * @name null
   * @api public
   */

  Assertion.addProperty('null', function () {
    this.assert(
        null === flag(this, 'object')
      , 'expected #{this} to be null'
      , 'expected #{this} not to be null'
    );
  });

  /**
   * ### .undefined
   *
   * Asserts that the target is `undefined`.
   *
   *     expect(undefined).to.be.undefined;
   *     expect(null).to.not.be.undefined;
   *
   * @name undefined
   * @api public
   */

  Assertion.addProperty('undefined', function () {
    this.assert(
        undefined === flag(this, 'object')
      , 'expected #{this} to be undefined'
      , 'expected #{this} not to be undefined'
    );
  });

  /**
   * ### .exist
   *
   * Asserts that the target is neither `null` nor `undefined`.
   *
   *     var foo = 'hi'
   *       , bar = null
   *       , baz;
   *
   *     expect(foo).to.exist;
   *     expect(bar).to.not.exist;
   *     expect(baz).to.not.exist;
   *
   * @name exist
   * @api public
   */

  Assertion.addProperty('exist', function () {
    this.assert(
        null != flag(this, 'object')
      , 'expected #{this} to exist'
      , 'expected #{this} to not exist'
    );
  });


  /**
   * ### .empty
   *
   * Asserts that the target's length is `0`. For arrays, it checks
   * the `length` property. For objects, it gets the count of
   * enumerable keys.
   *
   *     expect([]).to.be.empty;
   *     expect('').to.be.empty;
   *     expect({}).to.be.empty;
   *
   * @name empty
   * @api public
   */

  Assertion.addProperty('empty', function () {
    var obj = flag(this, 'object')
      , expected = obj;

    if (Array.isArray(obj) || 'string' === typeof object) {
      expected = obj.length;
    } else if (typeof obj === 'object') {
      expected = Object.keys(obj).length;
    }

    this.assert(
        !expected
      , 'expected #{this} to be empty'
      , 'expected #{this} not to be empty'
    );
  });

  /**
   * ### .arguments
   *
   * Asserts that the target is an arguments object.
   *
   *     function test () {
   *       expect(arguments).to.be.arguments;
   *     }
   *
   * @name arguments
   * @alias Arguments
   * @api public
   */

  function checkArguments () {
    var obj = flag(this, 'object')
      , type = Object.prototype.toString.call(obj);
    this.assert(
        '[object Arguments]' === type
      , 'expected #{this} to be arguments but got ' + type
      , 'expected #{this} to not be arguments'
    );
  }

  Assertion.addProperty('arguments', checkArguments);
  Assertion.addProperty('Arguments', checkArguments);

  /**
   * ### .equal(value)
   *
   * Asserts that the target is strictly equal (`===`) to `value`.
   * Alternately, if the `deep` flag is set, asserts that
   * the target is deeply equal to `value`.
   *
   *     expect('hello').to.equal('hello');
   *     expect(42).to.equal(42);
   *     expect(1).to.not.equal(true);
   *     expect({ foo: 'bar' }).to.not.equal({ foo: 'bar' });
   *     expect({ foo: 'bar' }).to.deep.equal({ foo: 'bar' });
   *
   * @name equal
   * @alias equals
   * @alias eq
   * @alias deep.equal
   * @param {Mixed} value
   * @param {String} message _optional_
   * @api public
   */

  function assertEqual (val, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    if (flag(this, 'deep')) {
      return this.eql(val);
    } else {
      this.assert(
          val === obj
        , 'expected #{this} to equal #{exp}'
        , 'expected #{this} to not equal #{exp}'
        , val
        , this._obj
        , true
      );
    }
  }

  Assertion.addMethod('equal', assertEqual);
  Assertion.addMethod('equals', assertEqual);
  Assertion.addMethod('eq', assertEqual);

  /**
   * ### .eql(value)
   *
   * Asserts that the target is deeply equal to `value`.
   *
   *     expect({ foo: 'bar' }).to.eql({ foo: 'bar' });
   *     expect([ 1, 2, 3 ]).to.eql([ 1, 2, 3 ]);
   *
   * @name eql
   * @alias eqls
   * @param {Mixed} value
   * @param {String} message _optional_
   * @api public
   */

  function assertEql(obj, msg) {
    if (msg) flag(this, 'message', msg);
    this.assert(
        _.eql(obj, flag(this, 'object'))
      , 'expected #{this} to deeply equal #{exp}'
      , 'expected #{this} to not deeply equal #{exp}'
      , obj
      , this._obj
      , true
    );
  }

  Assertion.addMethod('eql', assertEql);
  Assertion.addMethod('eqls', assertEql);

  /**
   * ### .above(value)
   *
   * Asserts that the target is greater than `value`.
   *
   *     expect(10).to.be.above(5);
   *
   * Can also be used in conjunction with `length` to
   * assert a minimum length. The benefit being a
   * more informative error message than if the length
   * was supplied directly.
   *
   *     expect('foo').to.have.length.above(2);
   *     expect([ 1, 2, 3 ]).to.have.length.above(2);
   *
   * @name above
   * @alias gt
   * @alias greaterThan
   * @param {Number} value
   * @param {String} message _optional_
   * @api public
   */

  function assertAbove (n, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    if (flag(this, 'doLength')) {
      new Assertion(obj, msg).to.have.property('length');
      var len = obj.length;
      this.assert(
          len > n
        , 'expected #{this} to have a length above #{exp} but got #{act}'
        , 'expected #{this} to not have a length above #{exp}'
        , n
        , len
      );
    } else {
      this.assert(
          obj > n
        , 'expected #{this} to be above ' + n
        , 'expected #{this} to be at most ' + n
      );
    }
  }

  Assertion.addMethod('above', assertAbove);
  Assertion.addMethod('gt', assertAbove);
  Assertion.addMethod('greaterThan', assertAbove);

  /**
   * ### .least(value)
   *
   * Asserts that the target is greater than or equal to `value`.
   *
   *     expect(10).to.be.at.least(10);
   *
   * Can also be used in conjunction with `length` to
   * assert a minimum length. The benefit being a
   * more informative error message than if the length
   * was supplied directly.
   *
   *     expect('foo').to.have.length.of.at.least(2);
   *     expect([ 1, 2, 3 ]).to.have.length.of.at.least(3);
   *
   * @name least
   * @alias gte
   * @param {Number} value
   * @param {String} message _optional_
   * @api public
   */

  function assertLeast (n, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    if (flag(this, 'doLength')) {
      new Assertion(obj, msg).to.have.property('length');
      var len = obj.length;
      this.assert(
          len >= n
        , 'expected #{this} to have a length at least #{exp} but got #{act}'
        , 'expected #{this} to have a length below #{exp}'
        , n
        , len
      );
    } else {
      this.assert(
          obj >= n
        , 'expected #{this} to be at least ' + n
        , 'expected #{this} to be below ' + n
      );
    }
  }

  Assertion.addMethod('least', assertLeast);
  Assertion.addMethod('gte', assertLeast);

  /**
   * ### .below(value)
   *
   * Asserts that the target is less than `value`.
   *
   *     expect(5).to.be.below(10);
   *
   * Can also be used in conjunction with `length` to
   * assert a maximum length. The benefit being a
   * more informative error message than if the length
   * was supplied directly.
   *
   *     expect('foo').to.have.length.below(4);
   *     expect([ 1, 2, 3 ]).to.have.length.below(4);
   *
   * @name below
   * @alias lt
   * @alias lessThan
   * @param {Number} value
   * @param {String} message _optional_
   * @api public
   */

  function assertBelow (n, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    if (flag(this, 'doLength')) {
      new Assertion(obj, msg).to.have.property('length');
      var len = obj.length;
      this.assert(
          len < n
        , 'expected #{this} to have a length below #{exp} but got #{act}'
        , 'expected #{this} to not have a length below #{exp}'
        , n
        , len
      );
    } else {
      this.assert(
          obj < n
        , 'expected #{this} to be below ' + n
        , 'expected #{this} to be at least ' + n
      );
    }
  }

  Assertion.addMethod('below', assertBelow);
  Assertion.addMethod('lt', assertBelow);
  Assertion.addMethod('lessThan', assertBelow);

  /**
   * ### .most(value)
   *
   * Asserts that the target is less than or equal to `value`.
   *
   *     expect(5).to.be.at.most(5);
   *
   * Can also be used in conjunction with `length` to
   * assert a maximum length. The benefit being a
   * more informative error message than if the length
   * was supplied directly.
   *
   *     expect('foo').to.have.length.of.at.most(4);
   *     expect([ 1, 2, 3 ]).to.have.length.of.at.most(3);
   *
   * @name most
   * @alias lte
   * @param {Number} value
   * @param {String} message _optional_
   * @api public
   */

  function assertMost (n, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    if (flag(this, 'doLength')) {
      new Assertion(obj, msg).to.have.property('length');
      var len = obj.length;
      this.assert(
          len <= n
        , 'expected #{this} to have a length at most #{exp} but got #{act}'
        , 'expected #{this} to have a length above #{exp}'
        , n
        , len
      );
    } else {
      this.assert(
          obj <= n
        , 'expected #{this} to be at most ' + n
        , 'expected #{this} to be above ' + n
      );
    }
  }

  Assertion.addMethod('most', assertMost);
  Assertion.addMethod('lte', assertMost);

  /**
   * ### .within(start, finish)
   *
   * Asserts that the target is within a range.
   *
   *     expect(7).to.be.within(5,10);
   *
   * Can also be used in conjunction with `length` to
   * assert a length range. The benefit being a
   * more informative error message than if the length
   * was supplied directly.
   *
   *     expect('foo').to.have.length.within(2,4);
   *     expect([ 1, 2, 3 ]).to.have.length.within(2,4);
   *
   * @name within
   * @param {Number} start lowerbound inclusive
   * @param {Number} finish upperbound inclusive
   * @param {String} message _optional_
   * @api public
   */

  Assertion.addMethod('within', function (start, finish, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object')
      , range = start + '..' + finish;
    if (flag(this, 'doLength')) {
      new Assertion(obj, msg).to.have.property('length');
      var len = obj.length;
      this.assert(
          len >= start && len <= finish
        , 'expected #{this} to have a length within ' + range
        , 'expected #{this} to not have a length within ' + range
      );
    } else {
      this.assert(
          obj >= start && obj <= finish
        , 'expected #{this} to be within ' + range
        , 'expected #{this} to not be within ' + range
      );
    }
  });

  /**
   * ### .instanceof(constructor)
   *
   * Asserts that the target is an instance of `constructor`.
   *
   *     var Tea = function (name) { this.name = name; }
   *       , Chai = new Tea('chai');
   *
   *     expect(Chai).to.be.an.instanceof(Tea);
   *     expect([ 1, 2, 3 ]).to.be.instanceof(Array);
   *
   * @name instanceof
   * @param {Constructor} constructor
   * @param {String} message _optional_
   * @alias instanceOf
   * @api public
   */

  function assertInstanceOf (constructor, msg) {
    if (msg) flag(this, 'message', msg);
    var name = _.getName(constructor);
    this.assert(
        flag(this, 'object') instanceof constructor
      , 'expected #{this} to be an instance of ' + name
      , 'expected #{this} to not be an instance of ' + name
    );
  };

  Assertion.addMethod('instanceof', assertInstanceOf);
  Assertion.addMethod('instanceOf', assertInstanceOf);

  /**
   * ### .property(name, [value])
   *
   * Asserts that the target has a property `name`, optionally asserting that
   * the value of that property is strictly equal to  `value`.
   * If the `deep` flag is set, you can use dot- and bracket-notation for deep
   * references into objects and arrays.
   *
   *     // simple referencing
   *     var obj = { foo: 'bar' };
   *     expect(obj).to.have.property('foo');
   *     expect(obj).to.have.property('foo', 'bar');
   *
   *     // deep referencing
   *     var deepObj = {
   *         green: { tea: 'matcha' }
   *       , teas: [ 'chai', 'matcha', { tea: 'konacha' } ]
   *     };

   *     expect(deepObj).to.have.deep.property('green.tea', 'matcha');
   *     expect(deepObj).to.have.deep.property('teas[1]', 'matcha');
   *     expect(deepObj).to.have.deep.property('teas[2].tea', 'konacha');
   *
   * You can also use an array as the starting point of a `deep.property`
   * assertion, or traverse nested arrays.
   *
   *     var arr = [
   *         [ 'chai', 'matcha', 'konacha' ]
   *       , [ { tea: 'chai' }
   *         , { tea: 'matcha' }
   *         , { tea: 'konacha' } ]
   *     ];
   *
   *     expect(arr).to.have.deep.property('[0][1]', 'matcha');
   *     expect(arr).to.have.deep.property('[1][2].tea', 'konacha');
   *
   * Furthermore, `property` changes the subject of the assertion
   * to be the value of that property from the original object. This
   * permits for further chainable assertions on that property.
   *
   *     expect(obj).to.have.property('foo')
   *       .that.is.a('string');
   *     expect(deepObj).to.have.property('green')
   *       .that.is.an('object')
   *       .that.deep.equals({ tea: 'matcha' });
   *     expect(deepObj).to.have.property('teas')
   *       .that.is.an('array')
   *       .with.deep.property('[2]')
   *         .that.deep.equals({ tea: 'konacha' });
   *
   * @name property
   * @alias deep.property
   * @param {String} name
   * @param {Mixed} value (optional)
   * @param {String} message _optional_
   * @returns value of property for chaining
   * @api public
   */

  Assertion.addMethod('property', function (name, val, msg) {
    if (msg) flag(this, 'message', msg);

    var descriptor = flag(this, 'deep') ? 'deep property ' : 'property '
      , negate = flag(this, 'negate')
      , obj = flag(this, 'object')
      , value = flag(this, 'deep')
        ? _.getPathValue(name, obj)
        : obj[name];

    if (negate && undefined !== val) {
      if (undefined === value) {
        msg = (msg != null) ? msg + ': ' : '';
        throw new Error(msg + _.inspect(obj) + ' has no ' + descriptor + _.inspect(name));
      }
    } else {
      this.assert(
          undefined !== value
        , 'expected #{this} to have a ' + descriptor + _.inspect(name)
        , 'expected #{this} to not have ' + descriptor + _.inspect(name));
    }

    if (undefined !== val) {
      this.assert(
          val === value
        , 'expected #{this} to have a ' + descriptor + _.inspect(name) + ' of #{exp}, but got #{act}'
        , 'expected #{this} to not have a ' + descriptor + _.inspect(name) + ' of #{act}'
        , val
        , value
      );
    }

    flag(this, 'object', value);
  });


  /**
   * ### .ownProperty(name)
   *
   * Asserts that the target has an own property `name`.
   *
   *     expect('test').to.have.ownProperty('length');
   *
   * @name ownProperty
   * @alias haveOwnProperty
   * @param {String} name
   * @param {String} message _optional_
   * @api public
   */

  function assertOwnProperty (name, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    this.assert(
        obj.hasOwnProperty(name)
      , 'expected #{this} to have own property ' + _.inspect(name)
      , 'expected #{this} to not have own property ' + _.inspect(name)
    );
  }

  Assertion.addMethod('ownProperty', assertOwnProperty);
  Assertion.addMethod('haveOwnProperty', assertOwnProperty);

  /**
   * ### .length(value)
   *
   * Asserts that the target's `length` property has
   * the expected value.
   *
   *     expect([ 1, 2, 3]).to.have.length(3);
   *     expect('foobar').to.have.length(6);
   *
   * Can also be used as a chain precursor to a value
   * comparison for the length property.
   *
   *     expect('foo').to.have.length.above(2);
   *     expect([ 1, 2, 3 ]).to.have.length.above(2);
   *     expect('foo').to.have.length.below(4);
   *     expect([ 1, 2, 3 ]).to.have.length.below(4);
   *     expect('foo').to.have.length.within(2,4);
   *     expect([ 1, 2, 3 ]).to.have.length.within(2,4);
   *
   * @name length
   * @alias lengthOf
   * @param {Number} length
   * @param {String} message _optional_
   * @api public
   */

  function assertLengthChain () {
    flag(this, 'doLength', true);
  }

  function assertLength (n, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    new Assertion(obj, msg).to.have.property('length');
    var len = obj.length;

    this.assert(
        len == n
      , 'expected #{this} to have a length of #{exp} but got #{act}'
      , 'expected #{this} to not have a length of #{act}'
      , n
      , len
    );
  }

  Assertion.addChainableMethod('length', assertLength, assertLengthChain);
  Assertion.addMethod('lengthOf', assertLength, assertLengthChain);

  /**
   * ### .match(regexp)
   *
   * Asserts that the target matches a regular expression.
   *
   *     expect('foobar').to.match(/^foo/);
   *
   * @name match
   * @param {RegExp} RegularExpression
   * @param {String} message _optional_
   * @api public
   */

  Assertion.addMethod('match', function (re, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    this.assert(
        re.exec(obj)
      , 'expected #{this} to match ' + re
      , 'expected #{this} not to match ' + re
    );
  });

  /**
   * ### .string(string)
   *
   * Asserts that the string target contains another string.
   *
   *     expect('foobar').to.have.string('bar');
   *
   * @name string
   * @param {String} string
   * @param {String} message _optional_
   * @api public
   */

  Assertion.addMethod('string', function (str, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    new Assertion(obj, msg).is.a('string');

    this.assert(
        ~obj.indexOf(str)
      , 'expected #{this} to contain ' + _.inspect(str)
      , 'expected #{this} to not contain ' + _.inspect(str)
    );
  });


  /**
   * ### .keys(key1, [key2], [...])
   *
   * Asserts that the target has exactly the given keys, or
   * asserts the inclusion of some keys when using the
   * `include` or `contain` modifiers.
   *
   *     expect({ foo: 1, bar: 2 }).to.have.keys(['foo', 'bar']);
   *     expect({ foo: 1, bar: 2, baz: 3 }).to.contain.keys('foo', 'bar');
   *
   * @name keys
   * @alias key
   * @param {String...|Array} keys
   * @api public
   */

  function assertKeys (keys) {
    var obj = flag(this, 'object')
      , str
      , ok = true;

    keys = keys instanceof Array
      ? keys
      : Array.prototype.slice.call(arguments);

    if (!keys.length) throw new Error('keys required');

    var actual = Object.keys(obj)
      , len = keys.length;

    // Inclusion
    ok = keys.every(function(key){
      return ~actual.indexOf(key);
    });

    // Strict
    if (!flag(this, 'negate') && !flag(this, 'contains')) {
      ok = ok && keys.length == actual.length;
    }

    // Key string
    if (len > 1) {
      keys = keys.map(function(key){
        return _.inspect(key);
      });
      var last = keys.pop();
      str = keys.join(', ') + ', and ' + last;
    } else {
      str = _.inspect(keys[0]);
    }

    // Form
    str = (len > 1 ? 'keys ' : 'key ') + str;

    // Have / include
    str = (flag(this, 'contains') ? 'contain ' : 'have ') + str;

    // Assertion
    this.assert(
        ok
      , 'expected #{this} to ' + str
      , 'expected #{this} to not ' + str
    );
  }

  Assertion.addMethod('keys', assertKeys);
  Assertion.addMethod('key', assertKeys);

  /**
   * ### .throw(constructor)
   *
   * Asserts that the function target will throw a specific error, or specific type of error
   * (as determined using `instanceof`), optionally with a RegExp or string inclusion test
   * for the error's message.
   *
   *     var err = new ReferenceError('This is a bad function.');
   *     var fn = function () { throw err; }
   *     expect(fn).to.throw(ReferenceError);
   *     expect(fn).to.throw(Error);
   *     expect(fn).to.throw(/bad function/);
   *     expect(fn).to.not.throw('good function');
   *     expect(fn).to.throw(ReferenceError, /bad function/);
   *     expect(fn).to.throw(err);
   *     expect(fn).to.not.throw(new RangeError('Out of range.'));
   *
   * Please note that when a throw expectation is negated, it will check each
   * parameter independently, starting with error constructor type. The appropriate way
   * to check for the existence of a type of error but for a message that does not match
   * is to use `and`.
   *
   *     expect(fn).to.throw(ReferenceError)
   *        .and.not.throw(/good function/);
   *
   * @name throw
   * @alias throws
   * @alias Throw
   * @param {ErrorConstructor} constructor
   * @param {String|RegExp} expected error message
   * @param {String} message _optional_
   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
   * @returns error for chaining (null if no error)
   * @api public
   */

  function assertThrows (constructor, errMsg, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    new Assertion(obj, msg).is.a('function');

    var thrown = false
      , desiredError = null
      , name = null
      , thrownError = null;

    if (arguments.length === 0) {
      errMsg = null;
      constructor = null;
    } else if (constructor && (constructor instanceof RegExp || 'string' === typeof constructor)) {
      errMsg = constructor;
      constructor = null;
    } else if (constructor && constructor instanceof Error) {
      desiredError = constructor;
      constructor = null;
      errMsg = null;
    } else if (typeof constructor === 'function') {
      name = constructor.prototype.name || constructor.name;
      if (name === 'Error' && constructor !== Error) {
        name = (new constructor()).name;
      }
    } else {
      constructor = null;
    }

    try {
      obj();
    } catch (err) {
      // first, check desired error
      if (desiredError) {
        this.assert(
            err === desiredError
          , 'expected #{this} to throw #{exp} but #{act} was thrown'
          , 'expected #{this} to not throw #{exp}'
          , (desiredError instanceof Error ? desiredError.toString() : desiredError)
          , (err instanceof Error ? err.toString() : err)
        );

        flag(this, 'object', err);
        return this;
      }

      // next, check constructor
      if (constructor) {
        this.assert(
            err instanceof constructor
          , 'expected #{this} to throw #{exp} but #{act} was thrown'
          , 'expected #{this} to not throw #{exp} but #{act} was thrown'
          , name
          , (err instanceof Error ? err.toString() : err)
        );

        if (!errMsg) {
          flag(this, 'object', err);
          return this;
        }
      }

      // next, check message
      var message = 'object' === _.type(err) && "message" in err
        ? err.message
        : '' + err;

      if ((message != null) && errMsg && errMsg instanceof RegExp) {
        this.assert(
            errMsg.exec(message)
          , 'expected #{this} to throw error matching #{exp} but got #{act}'
          , 'expected #{this} to throw error not matching #{exp}'
          , errMsg
          , message
        );

        flag(this, 'object', err);
        return this;
      } else if ((message != null) && errMsg && 'string' === typeof errMsg) {
        this.assert(
            ~message.indexOf(errMsg)
          , 'expected #{this} to throw error including #{exp} but got #{act}'
          , 'expected #{this} to throw error not including #{act}'
          , errMsg
          , message
        );

        flag(this, 'object', err);
        return this;
      } else {
        thrown = true;
        thrownError = err;
      }
    }

    var actuallyGot = ''
      , expectedThrown = name !== null
        ? name
        : desiredError
          ? '#{exp}' //_.inspect(desiredError)
          : 'an error';

    if (thrown) {
      actuallyGot = ' but #{act} was thrown'
    }

    this.assert(
        thrown === true
      , 'expected #{this} to throw ' + expectedThrown + actuallyGot
      , 'expected #{this} to not throw ' + expectedThrown + actuallyGot
      , (desiredError instanceof Error ? desiredError.toString() : desiredError)
      , (thrownError instanceof Error ? thrownError.toString() : thrownError)
    );

    flag(this, 'object', thrownError);
  };

  Assertion.addMethod('throw', assertThrows);
  Assertion.addMethod('throws', assertThrows);
  Assertion.addMethod('Throw', assertThrows);

  /**
   * ### .respondTo(method)
   *
   * Asserts that the object or class target will respond to a method.
   *
   *     Klass.prototype.bar = function(){};
   *     expect(Klass).to.respondTo('bar');
   *     expect(obj).to.respondTo('bar');
   *
   * To check if a constructor will respond to a static function,
   * set the `itself` flag.
   *
   *     Klass.baz = function(){};
   *     expect(Klass).itself.to.respondTo('baz');
   *
   * @name respondTo
   * @param {String} method
   * @param {String} message _optional_
   * @api public
   */

  Assertion.addMethod('respondTo', function (method, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object')
      , itself = flag(this, 'itself')
      , context = ('function' === _.type(obj) && !itself)
        ? obj.prototype[method]
        : obj[method];

    this.assert(
        'function' === typeof context
      , 'expected #{this} to respond to ' + _.inspect(method)
      , 'expected #{this} to not respond to ' + _.inspect(method)
    );
  });

  /**
   * ### .itself
   *
   * Sets the `itself` flag, later used by the `respondTo` assertion.
   *
   *     function Foo() {}
   *     Foo.bar = function() {}
   *     Foo.prototype.baz = function() {}
   *
   *     expect(Foo).itself.to.respondTo('bar');
   *     expect(Foo).itself.not.to.respondTo('baz');
   *
   * @name itself
   * @api public
   */

  Assertion.addProperty('itself', function () {
    flag(this, 'itself', true);
  });

  /**
   * ### .satisfy(method)
   *
   * Asserts that the target passes a given truth test.
   *
   *     expect(1).to.satisfy(function(num) { return num > 0; });
   *
   * @name satisfy
   * @param {Function} matcher
   * @param {String} message _optional_
   * @api public
   */

  Assertion.addMethod('satisfy', function (matcher, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    this.assert(
        matcher(obj)
      , 'expected #{this} to satisfy ' + _.objDisplay(matcher)
      , 'expected #{this} to not satisfy' + _.objDisplay(matcher)
      , this.negate ? false : true
      , matcher(obj)
    );
  });

  /**
   * ### .closeTo(expected, delta)
   *
   * Asserts that the target is equal `expected`, to within a +/- `delta` range.
   *
   *     expect(1.5).to.be.closeTo(1, 0.5);
   *
   * @name closeTo
   * @param {Number} expected
   * @param {Number} delta
   * @param {String} message _optional_
   * @api public
   */

  Assertion.addMethod('closeTo', function (expected, delta, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    this.assert(
        Math.abs(obj - expected) <= delta
      , 'expected #{this} to be close to ' + expected + ' +/- ' + delta
      , 'expected #{this} not to be close to ' + expected + ' +/- ' + delta
    );
  });

  function isSubsetOf(subset, superset, cmp) {
    return subset.every(function(elem) {
      if (!cmp) return superset.indexOf(elem) !== -1;

      return superset.some(function(elem2) {
        return cmp(elem, elem2);
      });
    })
  }

  /**
   * ### .members(set)
   *
   * Asserts that the target is a superset of `set`,
   * or that the target and `set` have the same strictly-equal (===) members.
   * Alternately, if the `deep` flag is set, set members are compared for deep
   * equality.
   *
   *     expect([1, 2, 3]).to.include.members([3, 2]);
   *     expect([1, 2, 3]).to.not.include.members([3, 2, 8]);
   *
   *     expect([4, 2]).to.have.members([2, 4]);
   *     expect([5, 2]).to.not.have.members([5, 2, 1]);
   *
   *     expect([{ id: 1 }]).to.deep.include.members([{ id: 1 }]);
   *
   * @name members
   * @param {Array} set
   * @param {String} message _optional_
   * @api public
   */

  Assertion.addMethod('members', function (subset, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');

    new Assertion(obj).to.be.an('array');
    new Assertion(subset).to.be.an('array');

    var cmp = flag(this, 'deep') ? _.eql : undefined;

    if (flag(this, 'contains')) {
      return this.assert(
          isSubsetOf(subset, obj, cmp)
        , 'expected #{this} to be a superset of #{act}'
        , 'expected #{this} to not be a superset of #{act}'
        , obj
        , subset
      );
    }

    this.assert(
        isSubsetOf(obj, subset, cmp) && isSubsetOf(subset, obj, cmp)
        , 'expected #{this} to have the same members as #{act}'
        , 'expected #{this} to not have the same members as #{act}'
        , obj
        , subset
    );
  });
};

},{}],19:[function(require,module,exports){
/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */


module.exports = function (chai, util) {

  /*!
   * Chai dependencies.
   */

  var Assertion = chai.Assertion
    , flag = util.flag;

  /*!
   * Module export.
   */

  /**
   * ### assert(expression, message)
   *
   * Write your own test expressions.
   *
   *     assert('foo' !== 'bar', 'foo is not bar');
   *     assert(Array.isArray([]), 'empty arrays are arrays');
   *
   * @param {Mixed} expression to test for truthiness
   * @param {String} message to display on error
   * @name assert
   * @api public
   */

  var assert = chai.assert = function (express, errmsg) {
    var test = new Assertion(null, null, chai.assert);
    test.assert(
        express
      , errmsg
      , '[ negation message unavailable ]'
    );
  };

  /**
   * ### .fail(actual, expected, [message], [operator])
   *
   * Throw a failure. Node.js `assert` module-compatible.
   *
   * @name fail
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @param {String} operator
   * @api public
   */

  assert.fail = function (actual, expected, message, operator) {
    message = message || 'assert.fail()';
    throw new chai.AssertionError(message, {
        actual: actual
      , expected: expected
      , operator: operator
    }, assert.fail);
  };

  /**
   * ### .ok(object, [message])
   *
   * Asserts that `object` is truthy.
   *
   *     assert.ok('everything', 'everything is ok');
   *     assert.ok(false, 'this will fail');
   *
   * @name ok
   * @param {Mixed} object to test
   * @param {String} message
   * @api public
   */

  assert.ok = function (val, msg) {
    new Assertion(val, msg).is.ok;
  };

  /**
   * ### .notOk(object, [message])
   *
   * Asserts that `object` is falsy.
   *
   *     assert.notOk('everything', 'this will fail');
   *     assert.notOk(false, 'this will pass');
   *
   * @name notOk
   * @param {Mixed} object to test
   * @param {String} message
   * @api public
   */

  assert.notOk = function (val, msg) {
    new Assertion(val, msg).is.not.ok;
  };

  /**
   * ### .equal(actual, expected, [message])
   *
   * Asserts non-strict equality (`==`) of `actual` and `expected`.
   *
   *     assert.equal(3, '3', '== coerces values to strings');
   *
   * @name equal
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @api public
   */

  assert.equal = function (act, exp, msg) {
    var test = new Assertion(act, msg, assert.equal);

    test.assert(
        exp == flag(test, 'object')
      , 'expected #{this} to equal #{exp}'
      , 'expected #{this} to not equal #{act}'
      , exp
      , act
    );
  };

  /**
   * ### .notEqual(actual, expected, [message])
   *
   * Asserts non-strict inequality (`!=`) of `actual` and `expected`.
   *
   *     assert.notEqual(3, 4, 'these numbers are not equal');
   *
   * @name notEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @api public
   */

  assert.notEqual = function (act, exp, msg) {
    var test = new Assertion(act, msg, assert.notEqual);

    test.assert(
        exp != flag(test, 'object')
      , 'expected #{this} to not equal #{exp}'
      , 'expected #{this} to equal #{act}'
      , exp
      , act
    );
  };

  /**
   * ### .strictEqual(actual, expected, [message])
   *
   * Asserts strict equality (`===`) of `actual` and `expected`.
   *
   *     assert.strictEqual(true, true, 'these booleans are strictly equal');
   *
   * @name strictEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @api public
   */

  assert.strictEqual = function (act, exp, msg) {
    new Assertion(act, msg).to.equal(exp);
  };

  /**
   * ### .notStrictEqual(actual, expected, [message])
   *
   * Asserts strict inequality (`!==`) of `actual` and `expected`.
   *
   *     assert.notStrictEqual(3, '3', 'no coercion for strict equality');
   *
   * @name notStrictEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @api public
   */

  assert.notStrictEqual = function (act, exp, msg) {
    new Assertion(act, msg).to.not.equal(exp);
  };

  /**
   * ### .deepEqual(actual, expected, [message])
   *
   * Asserts that `actual` is deeply equal to `expected`.
   *
   *     assert.deepEqual({ tea: 'green' }, { tea: 'green' });
   *
   * @name deepEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @api public
   */

  assert.deepEqual = function (act, exp, msg) {
    new Assertion(act, msg).to.eql(exp);
  };

  /**
   * ### .notDeepEqual(actual, expected, [message])
   *
   * Assert that `actual` is not deeply equal to `expected`.
   *
   *     assert.notDeepEqual({ tea: 'green' }, { tea: 'jasmine' });
   *
   * @name notDeepEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @api public
   */

  assert.notDeepEqual = function (act, exp, msg) {
    new Assertion(act, msg).to.not.eql(exp);
  };

  /**
   * ### .isTrue(value, [message])
   *
   * Asserts that `value` is true.
   *
   *     var teaServed = true;
   *     assert.isTrue(teaServed, 'the tea has been served');
   *
   * @name isTrue
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isTrue = function (val, msg) {
    new Assertion(val, msg).is['true'];
  };

  /**
   * ### .isFalse(value, [message])
   *
   * Asserts that `value` is false.
   *
   *     var teaServed = false;
   *     assert.isFalse(teaServed, 'no tea yet? hmm...');
   *
   * @name isFalse
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isFalse = function (val, msg) {
    new Assertion(val, msg).is['false'];
  };

  /**
   * ### .isNull(value, [message])
   *
   * Asserts that `value` is null.
   *
   *     assert.isNull(err, 'there was no error');
   *
   * @name isNull
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isNull = function (val, msg) {
    new Assertion(val, msg).to.equal(null);
  };

  /**
   * ### .isNotNull(value, [message])
   *
   * Asserts that `value` is not null.
   *
   *     var tea = 'tasty chai';
   *     assert.isNotNull(tea, 'great, time for tea!');
   *
   * @name isNotNull
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isNotNull = function (val, msg) {
    new Assertion(val, msg).to.not.equal(null);
  };

  /**
   * ### .isUndefined(value, [message])
   *
   * Asserts that `value` is `undefined`.
   *
   *     var tea;
   *     assert.isUndefined(tea, 'no tea defined');
   *
   * @name isUndefined
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isUndefined = function (val, msg) {
    new Assertion(val, msg).to.equal(undefined);
  };

  /**
   * ### .isDefined(value, [message])
   *
   * Asserts that `value` is not `undefined`.
   *
   *     var tea = 'cup of chai';
   *     assert.isDefined(tea, 'tea has been defined');
   *
   * @name isDefined
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isDefined = function (val, msg) {
    new Assertion(val, msg).to.not.equal(undefined);
  };

  /**
   * ### .isFunction(value, [message])
   *
   * Asserts that `value` is a function.
   *
   *     function serveTea() { return 'cup of tea'; };
   *     assert.isFunction(serveTea, 'great, we can have tea now');
   *
   * @name isFunction
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isFunction = function (val, msg) {
    new Assertion(val, msg).to.be.a('function');
  };

  /**
   * ### .isNotFunction(value, [message])
   *
   * Asserts that `value` is _not_ a function.
   *
   *     var serveTea = [ 'heat', 'pour', 'sip' ];
   *     assert.isNotFunction(serveTea, 'great, we have listed the steps');
   *
   * @name isNotFunction
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isNotFunction = function (val, msg) {
    new Assertion(val, msg).to.not.be.a('function');
  };

  /**
   * ### .isObject(value, [message])
   *
   * Asserts that `value` is an object (as revealed by
   * `Object.prototype.toString`).
   *
   *     var selection = { name: 'Chai', serve: 'with spices' };
   *     assert.isObject(selection, 'tea selection is an object');
   *
   * @name isObject
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isObject = function (val, msg) {
    new Assertion(val, msg).to.be.a('object');
  };

  /**
   * ### .isNotObject(value, [message])
   *
   * Asserts that `value` is _not_ an object.
   *
   *     var selection = 'chai'
   *     assert.isNotObject(selection, 'tea selection is not an object');
   *     assert.isNotObject(null, 'null is not an object');
   *
   * @name isNotObject
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isNotObject = function (val, msg) {
    new Assertion(val, msg).to.not.be.a('object');
  };

  /**
   * ### .isArray(value, [message])
   *
   * Asserts that `value` is an array.
   *
   *     var menu = [ 'green', 'chai', 'oolong' ];
   *     assert.isArray(menu, 'what kind of tea do we want?');
   *
   * @name isArray
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isArray = function (val, msg) {
    new Assertion(val, msg).to.be.an('array');
  };

  /**
   * ### .isNotArray(value, [message])
   *
   * Asserts that `value` is _not_ an array.
   *
   *     var menu = 'green|chai|oolong';
   *     assert.isNotArray(menu, 'what kind of tea do we want?');
   *
   * @name isNotArray
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isNotArray = function (val, msg) {
    new Assertion(val, msg).to.not.be.an('array');
  };

  /**
   * ### .isString(value, [message])
   *
   * Asserts that `value` is a string.
   *
   *     var teaOrder = 'chai';
   *     assert.isString(teaOrder, 'order placed');
   *
   * @name isString
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isString = function (val, msg) {
    new Assertion(val, msg).to.be.a('string');
  };

  /**
   * ### .isNotString(value, [message])
   *
   * Asserts that `value` is _not_ a string.
   *
   *     var teaOrder = 4;
   *     assert.isNotString(teaOrder, 'order placed');
   *
   * @name isNotString
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isNotString = function (val, msg) {
    new Assertion(val, msg).to.not.be.a('string');
  };

  /**
   * ### .isNumber(value, [message])
   *
   * Asserts that `value` is a number.
   *
   *     var cups = 2;
   *     assert.isNumber(cups, 'how many cups');
   *
   * @name isNumber
   * @param {Number} value
   * @param {String} message
   * @api public
   */

  assert.isNumber = function (val, msg) {
    new Assertion(val, msg).to.be.a('number');
  };

  /**
   * ### .isNotNumber(value, [message])
   *
   * Asserts that `value` is _not_ a number.
   *
   *     var cups = '2 cups please';
   *     assert.isNotNumber(cups, 'how many cups');
   *
   * @name isNotNumber
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isNotNumber = function (val, msg) {
    new Assertion(val, msg).to.not.be.a('number');
  };

  /**
   * ### .isBoolean(value, [message])
   *
   * Asserts that `value` is a boolean.
   *
   *     var teaReady = true
   *       , teaServed = false;
   *
   *     assert.isBoolean(teaReady, 'is the tea ready');
   *     assert.isBoolean(teaServed, 'has tea been served');
   *
   * @name isBoolean
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isBoolean = function (val, msg) {
    new Assertion(val, msg).to.be.a('boolean');
  };

  /**
   * ### .isNotBoolean(value, [message])
   *
   * Asserts that `value` is _not_ a boolean.
   *
   *     var teaReady = 'yep'
   *       , teaServed = 'nope';
   *
   *     assert.isNotBoolean(teaReady, 'is the tea ready');
   *     assert.isNotBoolean(teaServed, 'has tea been served');
   *
   * @name isNotBoolean
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isNotBoolean = function (val, msg) {
    new Assertion(val, msg).to.not.be.a('boolean');
  };

  /**
   * ### .typeOf(value, name, [message])
   *
   * Asserts that `value`'s type is `name`, as determined by
   * `Object.prototype.toString`.
   *
   *     assert.typeOf({ tea: 'chai' }, 'object', 'we have an object');
   *     assert.typeOf(['chai', 'jasmine'], 'array', 'we have an array');
   *     assert.typeOf('tea', 'string', 'we have a string');
   *     assert.typeOf(/tea/, 'regexp', 'we have a regular expression');
   *     assert.typeOf(null, 'null', 'we have a null');
   *     assert.typeOf(undefined, 'undefined', 'we have an undefined');
   *
   * @name typeOf
   * @param {Mixed} value
   * @param {String} name
   * @param {String} message
   * @api public
   */

  assert.typeOf = function (val, type, msg) {
    new Assertion(val, msg).to.be.a(type);
  };

  /**
   * ### .notTypeOf(value, name, [message])
   *
   * Asserts that `value`'s type is _not_ `name`, as determined by
   * `Object.prototype.toString`.
   *
   *     assert.notTypeOf('tea', 'number', 'strings are not numbers');
   *
   * @name notTypeOf
   * @param {Mixed} value
   * @param {String} typeof name
   * @param {String} message
   * @api public
   */

  assert.notTypeOf = function (val, type, msg) {
    new Assertion(val, msg).to.not.be.a(type);
  };

  /**
   * ### .instanceOf(object, constructor, [message])
   *
   * Asserts that `value` is an instance of `constructor`.
   *
   *     var Tea = function (name) { this.name = name; }
   *       , chai = new Tea('chai');
   *
   *     assert.instanceOf(chai, Tea, 'chai is an instance of tea');
   *
   * @name instanceOf
   * @param {Object} object
   * @param {Constructor} constructor
   * @param {String} message
   * @api public
   */

  assert.instanceOf = function (val, type, msg) {
    new Assertion(val, msg).to.be.instanceOf(type);
  };

  /**
   * ### .notInstanceOf(object, constructor, [message])
   *
   * Asserts `value` is not an instance of `constructor`.
   *
   *     var Tea = function (name) { this.name = name; }
   *       , chai = new String('chai');
   *
   *     assert.notInstanceOf(chai, Tea, 'chai is not an instance of tea');
   *
   * @name notInstanceOf
   * @param {Object} object
   * @param {Constructor} constructor
   * @param {String} message
   * @api public
   */

  assert.notInstanceOf = function (val, type, msg) {
    new Assertion(val, msg).to.not.be.instanceOf(type);
  };

  /**
   * ### .include(haystack, needle, [message])
   *
   * Asserts that `haystack` includes `needle`. Works
   * for strings and arrays.
   *
   *     assert.include('foobar', 'bar', 'foobar contains string "bar"');
   *     assert.include([ 1, 2, 3 ], 3, 'array contains value');
   *
   * @name include
   * @param {Array|String} haystack
   * @param {Mixed} needle
   * @param {String} message
   * @api public
   */

  assert.include = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.include).include(inc);
  };

  /**
   * ### .notInclude(haystack, needle, [message])
   *
   * Asserts that `haystack` does not include `needle`. Works
   * for strings and arrays.
   *i
   *     assert.notInclude('foobar', 'baz', 'string not include substring');
   *     assert.notInclude([ 1, 2, 3 ], 4, 'array not include contain value');
   *
   * @name notInclude
   * @param {Array|String} haystack
   * @param {Mixed} needle
   * @param {String} message
   * @api public
   */

  assert.notInclude = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.notInclude).not.include(inc);
  };

  /**
   * ### .match(value, regexp, [message])
   *
   * Asserts that `value` matches the regular expression `regexp`.
   *
   *     assert.match('foobar', /^foo/, 'regexp matches');
   *
   * @name match
   * @param {Mixed} value
   * @param {RegExp} regexp
   * @param {String} message
   * @api public
   */

  assert.match = function (exp, re, msg) {
    new Assertion(exp, msg).to.match(re);
  };

  /**
   * ### .notMatch(value, regexp, [message])
   *
   * Asserts that `value` does not match the regular expression `regexp`.
   *
   *     assert.notMatch('foobar', /^foo/, 'regexp does not match');
   *
   * @name notMatch
   * @param {Mixed} value
   * @param {RegExp} regexp
   * @param {String} message
   * @api public
   */

  assert.notMatch = function (exp, re, msg) {
    new Assertion(exp, msg).to.not.match(re);
  };

  /**
   * ### .property(object, property, [message])
   *
   * Asserts that `object` has a property named by `property`.
   *
   *     assert.property({ tea: { green: 'matcha' }}, 'tea');
   *
   * @name property
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @api public
   */

  assert.property = function (obj, prop, msg) {
    new Assertion(obj, msg).to.have.property(prop);
  };

  /**
   * ### .notProperty(object, property, [message])
   *
   * Asserts that `object` does _not_ have a property named by `property`.
   *
   *     assert.notProperty({ tea: { green: 'matcha' }}, 'coffee');
   *
   * @name notProperty
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @api public
   */

  assert.notProperty = function (obj, prop, msg) {
    new Assertion(obj, msg).to.not.have.property(prop);
  };

  /**
   * ### .deepProperty(object, property, [message])
   *
   * Asserts that `object` has a property named by `property`, which can be a
   * string using dot- and bracket-notation for deep reference.
   *
   *     assert.deepProperty({ tea: { green: 'matcha' }}, 'tea.green');
   *
   * @name deepProperty
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @api public
   */

  assert.deepProperty = function (obj, prop, msg) {
    new Assertion(obj, msg).to.have.deep.property(prop);
  };

  /**
   * ### .notDeepProperty(object, property, [message])
   *
   * Asserts that `object` does _not_ have a property named by `property`, which
   * can be a string using dot- and bracket-notation for deep reference.
   *
   *     assert.notDeepProperty({ tea: { green: 'matcha' }}, 'tea.oolong');
   *
   * @name notDeepProperty
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @api public
   */

  assert.notDeepProperty = function (obj, prop, msg) {
    new Assertion(obj, msg).to.not.have.deep.property(prop);
  };

  /**
   * ### .propertyVal(object, property, value, [message])
   *
   * Asserts that `object` has a property named by `property` with value given
   * by `value`.
   *
   *     assert.propertyVal({ tea: 'is good' }, 'tea', 'is good');
   *
   * @name propertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.propertyVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg).to.have.property(prop, val);
  };

  /**
   * ### .propertyNotVal(object, property, value, [message])
   *
   * Asserts that `object` has a property named by `property`, but with a value
   * different from that given by `value`.
   *
   *     assert.propertyNotVal({ tea: 'is good' }, 'tea', 'is bad');
   *
   * @name propertyNotVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.propertyNotVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg).to.not.have.property(prop, val);
  };

  /**
   * ### .deepPropertyVal(object, property, value, [message])
   *
   * Asserts that `object` has a property named by `property` with value given
   * by `value`. `property` can use dot- and bracket-notation for deep
   * reference.
   *
   *     assert.deepPropertyVal({ tea: { green: 'matcha' }}, 'tea.green', 'matcha');
   *
   * @name deepPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.deepPropertyVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg).to.have.deep.property(prop, val);
  };

  /**
   * ### .deepPropertyNotVal(object, property, value, [message])
   *
   * Asserts that `object` has a property named by `property`, but with a value
   * different from that given by `value`. `property` can use dot- and
   * bracket-notation for deep reference.
   *
   *     assert.deepPropertyNotVal({ tea: { green: 'matcha' }}, 'tea.green', 'konacha');
   *
   * @name deepPropertyNotVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.deepPropertyNotVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg).to.not.have.deep.property(prop, val);
  };

  /**
   * ### .lengthOf(object, length, [message])
   *
   * Asserts that `object` has a `length` property with the expected value.
   *
   *     assert.lengthOf([1,2,3], 3, 'array has length of 3');
   *     assert.lengthOf('foobar', 5, 'string has length of 6');
   *
   * @name lengthOf
   * @param {Mixed} object
   * @param {Number} length
   * @param {String} message
   * @api public
   */

  assert.lengthOf = function (exp, len, msg) {
    new Assertion(exp, msg).to.have.length(len);
  };

  /**
   * ### .throws(function, [constructor/string/regexp], [string/regexp], [message])
   *
   * Asserts that `function` will throw an error that is an instance of
   * `constructor`, or alternately that it will throw an error with message
   * matching `regexp`.
   *
   *     assert.throw(fn, 'function throws a reference error');
   *     assert.throw(fn, /function throws a reference error/);
   *     assert.throw(fn, ReferenceError);
   *     assert.throw(fn, ReferenceError, 'function throws a reference error');
   *     assert.throw(fn, ReferenceError, /function throws a reference error/);
   *
   * @name throws
   * @alias throw
   * @alias Throw
   * @param {Function} function
   * @param {ErrorConstructor} constructor
   * @param {RegExp} regexp
   * @param {String} message
   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
   * @api public
   */

  assert.Throw = function (fn, errt, errs, msg) {
    if ('string' === typeof errt || errt instanceof RegExp) {
      errs = errt;
      errt = null;
    }

    var assertErr = new Assertion(fn, msg).to.Throw(errt, errs);
    return flag(assertErr, 'object');
  };

  /**
   * ### .doesNotThrow(function, [constructor/regexp], [message])
   *
   * Asserts that `function` will _not_ throw an error that is an instance of
   * `constructor`, or alternately that it will not throw an error with message
   * matching `regexp`.
   *
   *     assert.doesNotThrow(fn, Error, 'function does not throw');
   *
   * @name doesNotThrow
   * @param {Function} function
   * @param {ErrorConstructor} constructor
   * @param {RegExp} regexp
   * @param {String} message
   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
   * @api public
   */

  assert.doesNotThrow = function (fn, type, msg) {
    if ('string' === typeof type) {
      msg = type;
      type = null;
    }

    new Assertion(fn, msg).to.not.Throw(type);
  };

  /**
   * ### .operator(val1, operator, val2, [message])
   *
   * Compares two values using `operator`.
   *
   *     assert.operator(1, '<', 2, 'everything is ok');
   *     assert.operator(1, '>', 2, 'this will fail');
   *
   * @name operator
   * @param {Mixed} val1
   * @param {String} operator
   * @param {Mixed} val2
   * @param {String} message
   * @api public
   */

  assert.operator = function (val, operator, val2, msg) {
    if (!~['==', '===', '>', '>=', '<', '<=', '!=', '!=='].indexOf(operator)) {
      throw new Error('Invalid operator "' + operator + '"');
    }
    var test = new Assertion(eval(val + operator + val2), msg);
    test.assert(
        true === flag(test, 'object')
      , 'expected ' + util.inspect(val) + ' to be ' + operator + ' ' + util.inspect(val2)
      , 'expected ' + util.inspect(val) + ' to not be ' + operator + ' ' + util.inspect(val2) );
  };

  /**
   * ### .closeTo(actual, expected, delta, [message])
   *
   * Asserts that the target is equal `expected`, to within a +/- `delta` range.
   *
   *     assert.closeTo(1.5, 1, 0.5, 'numbers are close');
   *
   * @name closeTo
   * @param {Number} actual
   * @param {Number} expected
   * @param {Number} delta
   * @param {String} message
   * @api public
   */

  assert.closeTo = function (act, exp, delta, msg) {
    new Assertion(act, msg).to.be.closeTo(exp, delta);
  };

  /**
   * ### .sameMembers(set1, set2, [message])
   *
   * Asserts that `set1` and `set2` have the same members.
   * Order is not taken into account.
   *
   *     assert.sameMembers([ 1, 2, 3 ], [ 2, 1, 3 ], 'same members');
   *
   * @name sameMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @api public
   */

  assert.sameMembers = function (set1, set2, msg) {
    new Assertion(set1, msg).to.have.same.members(set2);
  }

  /**
   * ### .includeMembers(superset, subset, [message])
   *
   * Asserts that `subset` is included in `superset`.
   * Order is not taken into account.
   *
   *     assert.includeMembers([ 1, 2, 3 ], [ 2, 1 ], 'include members');
   *
   * @name includeMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @api public
   */

  assert.includeMembers = function (superset, subset, msg) {
    new Assertion(superset, msg).to.include.members(subset);
  }

  /*!
   * Undocumented / untested
   */

  assert.ifError = function (val, msg) {
    new Assertion(val, msg).to.not.be.ok;
  };

  /*!
   * Aliases.
   */

  (function alias(name, as){
    assert[as] = assert[name];
    return alias;
  })
  ('Throw', 'throw')
  ('Throw', 'throws');
};

},{}],20:[function(require,module,exports){
/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

module.exports = function (chai, util) {
  chai.expect = function (val, message) {
    return new chai.Assertion(val, message);
  };
};


},{}],21:[function(require,module,exports){
/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

module.exports = function (chai, util) {
  var Assertion = chai.Assertion;

  function loadShould () {
    // explicitly define this method as function as to have it's name to include as `ssfi`
    function shouldGetter() {
      if (this instanceof String || this instanceof Number) {
        return new Assertion(this.constructor(this), null, shouldGetter);
      } else if (this instanceof Boolean) {
        return new Assertion(this == true, null, shouldGetter);
      }
      return new Assertion(this, null, shouldGetter);
    }
    function shouldSetter(value) {
      // See https://github.com/chaijs/chai/issues/86: this makes
      // `whatever.should = someValue` actually set `someValue`, which is
      // especially useful for `global.should = require('chai').should()`.
      //
      // Note that we have to use [[DefineProperty]] instead of [[Put]]
      // since otherwise we would trigger this very setter!
      Object.defineProperty(this, 'should', {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    }
    // modify Object.prototype to have `should`
    Object.defineProperty(Object.prototype, 'should', {
      set: shouldSetter
      , get: shouldGetter
      , configurable: true
    });

    var should = {};

    should.equal = function (val1, val2, msg) {
      new Assertion(val1, msg).to.equal(val2);
    };

    should.Throw = function (fn, errt, errs, msg) {
      new Assertion(fn, msg).to.Throw(errt, errs);
    };

    should.exist = function (val, msg) {
      new Assertion(val, msg).to.exist;
    }

    // negation
    should.not = {}

    should.not.equal = function (val1, val2, msg) {
      new Assertion(val1, msg).to.not.equal(val2);
    };

    should.not.Throw = function (fn, errt, errs, msg) {
      new Assertion(fn, msg).to.not.Throw(errt, errs);
    };

    should.not.exist = function (val, msg) {
      new Assertion(val, msg).to.not.exist;
    }

    should['throw'] = should['Throw'];
    should.not['throw'] = should.not['Throw'];

    return should;
  };

  chai.should = loadShould;
  chai.Should = loadShould;
};

},{}],22:[function(require,module,exports){
/*!
 * Chai - addChainingMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependencies
 */

var transferFlags = require('./transferFlags');
var flag = require('./flag');
var config = require('../config');

/*!
 * Module variables
 */

// Check whether `__proto__` is supported
var hasProtoSupport = '__proto__' in Object;

// Without `__proto__` support, this module will need to add properties to a function.
// However, some Function.prototype methods cannot be overwritten,
// and there seems no easy cross-platform way to detect them (@see chaijs/chai/issues/69).
var excludeNames = /^(?:length|name|arguments|caller)$/;

// Cache `Function` properties
var call  = Function.prototype.call,
    apply = Function.prototype.apply;

/**
 * ### addChainableMethod (ctx, name, method, chainingBehavior)
 *
 * Adds a method to an object, such that the method can also be chained.
 *
 *     utils.addChainableMethod(chai.Assertion.prototype, 'foo', function (str) {
 *       var obj = utils.flag(this, 'object');
 *       new chai.Assertion(obj).to.be.equal(str);
 *     });
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.addChainableMethod('foo', fn, chainingBehavior);
 *
 * The result can then be used as both a method assertion, executing both `method` and
 * `chainingBehavior`, or as a language chain, which only executes `chainingBehavior`.
 *
 *     expect(fooStr).to.be.foo('bar');
 *     expect(fooStr).to.be.foo.equal('foo');
 *
 * @param {Object} ctx object to which the method is added
 * @param {String} name of method to add
 * @param {Function} method function to be used for `name`, when called
 * @param {Function} chainingBehavior function to be called every time the property is accessed
 * @name addChainableMethod
 * @api public
 */

module.exports = function (ctx, name, method, chainingBehavior) {
  if (typeof chainingBehavior !== 'function') {
    chainingBehavior = function () { };
  }

  var chainableBehavior = {
      method: method
    , chainingBehavior: chainingBehavior
  };

  // save the methods so we can overwrite them later, if we need to.
  if (!ctx.__methods) {
    ctx.__methods = {};
  }
  ctx.__methods[name] = chainableBehavior;

  Object.defineProperty(ctx, name,
    { get: function () {
        chainableBehavior.chainingBehavior.call(this);

        var assert = function assert() {
          var old_ssfi = flag(this, 'ssfi');
          if (old_ssfi && config.includeStack === false)
            flag(this, 'ssfi', assert);
          var result = chainableBehavior.method.apply(this, arguments);
          return result === undefined ? this : result;
        };

        // Use `__proto__` if available
        if (hasProtoSupport) {
          // Inherit all properties from the object by replacing the `Function` prototype
          var prototype = assert.__proto__ = Object.create(this);
          // Restore the `call` and `apply` methods from `Function`
          prototype.call = call;
          prototype.apply = apply;
        }
        // Otherwise, redefine all properties (slow!)
        else {
          var asserterNames = Object.getOwnPropertyNames(ctx);
          asserterNames.forEach(function (asserterName) {
            if (!excludeNames.test(asserterName)) {
              var pd = Object.getOwnPropertyDescriptor(ctx, asserterName);
              Object.defineProperty(assert, asserterName, pd);
            }
          });
        }

        transferFlags(this, assert);
        return assert;
      }
    , configurable: true
  });
};

},{"../config":17,"./flag":25,"./transferFlags":39}],23:[function(require,module,exports){
/*!
 * Chai - addMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

var config = require('../config');

/**
 * ### .addMethod (ctx, name, method)
 *
 * Adds a method to the prototype of an object.
 *
 *     utils.addMethod(chai.Assertion.prototype, 'foo', function (str) {
 *       var obj = utils.flag(this, 'object');
 *       new chai.Assertion(obj).to.be.equal(str);
 *     });
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.addMethod('foo', fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(fooStr).to.be.foo('bar');
 *
 * @param {Object} ctx object to which the method is added
 * @param {String} name of method to add
 * @param {Function} method function to be used for name
 * @name addMethod
 * @api public
 */
var flag = require('./flag');

module.exports = function (ctx, name, method) {
  ctx[name] = function () {
    var old_ssfi = flag(this, 'ssfi');
    if (old_ssfi && config.includeStack === false)
      flag(this, 'ssfi', ctx[name]);
    var result = method.apply(this, arguments);
    return result === undefined ? this : result;
  };
};

},{"../config":17,"./flag":25}],24:[function(require,module,exports){
/*!
 * Chai - addProperty utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### addProperty (ctx, name, getter)
 *
 * Adds a property to the prototype of an object.
 *
 *     utils.addProperty(chai.Assertion.prototype, 'foo', function () {
 *       var obj = utils.flag(this, 'object');
 *       new chai.Assertion(obj).to.be.instanceof(Foo);
 *     });
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.addProperty('foo', fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(myFoo).to.be.foo;
 *
 * @param {Object} ctx object to which the property is added
 * @param {String} name of property to add
 * @param {Function} getter function to be used for name
 * @name addProperty
 * @api public
 */

module.exports = function (ctx, name, getter) {
  Object.defineProperty(ctx, name,
    { get: function () {
        var result = getter.call(this);
        return result === undefined ? this : result;
      }
    , configurable: true
  });
};

},{}],25:[function(require,module,exports){
/*!
 * Chai - flag utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### flag(object ,key, [value])
 *
 * Get or set a flag value on an object. If a
 * value is provided it will be set, else it will
 * return the currently set value or `undefined` if
 * the value is not set.
 *
 *     utils.flag(this, 'foo', 'bar'); // setter
 *     utils.flag(this, 'foo'); // getter, returns `bar`
 *
 * @param {Object} object (constructed Assertion
 * @param {String} key
 * @param {Mixed} value (optional)
 * @name flag
 * @api private
 */

module.exports = function (obj, key, value) {
  var flags = obj.__flags || (obj.__flags = Object.create(null));
  if (arguments.length === 3) {
    flags[key] = value;
  } else {
    return flags[key];
  }
};

},{}],26:[function(require,module,exports){
/*!
 * Chai - getActual utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * # getActual(object, [actual])
 *
 * Returns the `actual` value for an Assertion
 *
 * @param {Object} object (constructed Assertion)
 * @param {Arguments} chai.Assertion.prototype.assert arguments
 */

module.exports = function (obj, args) {
  return args.length > 4 ? args[4] : obj._obj;
};

},{}],27:[function(require,module,exports){
/*!
 * Chai - getEnumerableProperties utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .getEnumerableProperties(object)
 *
 * This allows the retrieval of enumerable property names of an object,
 * inherited or not.
 *
 * @param {Object} object
 * @returns {Array}
 * @name getEnumerableProperties
 * @api public
 */

module.exports = function getEnumerableProperties(object) {
  var result = [];
  for (var name in object) {
    result.push(name);
  }
  return result;
};

},{}],28:[function(require,module,exports){
/*!
 * Chai - message composition utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependancies
 */

var flag = require('./flag')
  , getActual = require('./getActual')
  , inspect = require('./inspect')
  , objDisplay = require('./objDisplay');

/**
 * ### .getMessage(object, message, negateMessage)
 *
 * Construct the error message based on flags
 * and template tags. Template tags will return
 * a stringified inspection of the object referenced.
 *
 * Message template tags:
 * - `#{this}` current asserted object
 * - `#{act}` actual value
 * - `#{exp}` expected value
 *
 * @param {Object} object (constructed Assertion)
 * @param {Arguments} chai.Assertion.prototype.assert arguments
 * @name getMessage
 * @api public
 */

module.exports = function (obj, args) {
  var negate = flag(obj, 'negate')
    , val = flag(obj, 'object')
    , expected = args[3]
    , actual = getActual(obj, args)
    , msg = negate ? args[2] : args[1]
    , flagMsg = flag(obj, 'message');

  msg = msg || '';
  msg = msg
    .replace(/#{this}/g, objDisplay(val))
    .replace(/#{act}/g, objDisplay(actual))
    .replace(/#{exp}/g, objDisplay(expected));

  return flagMsg ? flagMsg + ': ' + msg : msg;
};

},{"./flag":25,"./getActual":26,"./inspect":33,"./objDisplay":34}],29:[function(require,module,exports){
/*!
 * Chai - getName utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * # getName(func)
 *
 * Gets the name of a function, in a cross-browser way.
 *
 * @param {Function} a function (usually a constructor)
 */

module.exports = function (func) {
  if (func.name) return func.name;

  var match = /^\s?function ([^(]*)\(/.exec(func);
  return match && match[1] ? match[1] : "";
};

},{}],30:[function(require,module,exports){
/*!
 * Chai - getPathValue utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * @see https://github.com/logicalparadox/filtr
 * MIT Licensed
 */

/**
 * ### .getPathValue(path, object)
 *
 * This allows the retrieval of values in an
 * object given a string path.
 *
 *     var obj = {
 *         prop1: {
 *             arr: ['a', 'b', 'c']
 *           , str: 'Hello'
 *         }
 *       , prop2: {
 *             arr: [ { nested: 'Universe' } ]
 *           , str: 'Hello again!'
 *         }
 *     }
 *
 * The following would be the results.
 *
 *     getPathValue('prop1.str', obj); // Hello
 *     getPathValue('prop1.att[2]', obj); // b
 *     getPathValue('prop2.arr[0].nested', obj); // Universe
 *
 * @param {String} path
 * @param {Object} object
 * @returns {Object} value or `undefined`
 * @name getPathValue
 * @api public
 */

var getPathValue = module.exports = function (path, obj) {
  var parsed = parsePath(path);
  return _getPathValue(parsed, obj);
};

/*!
 * ## parsePath(path)
 *
 * Helper function used to parse string object
 * paths. Use in conjunction with `_getPathValue`.
 *
 *      var parsed = parsePath('myobject.property.subprop');
 *
 * ### Paths:
 *
 * * Can be as near infinitely deep and nested
 * * Arrays are also valid using the formal `myobject.document[3].property`.
 *
 * @param {String} path
 * @returns {Object} parsed
 * @api private
 */

function parsePath (path) {
  var str = path.replace(/\[/g, '.[')
    , parts = str.match(/(\\\.|[^.]+?)+/g);
  return parts.map(function (value) {
    var re = /\[(\d+)\]$/
      , mArr = re.exec(value)
    if (mArr) return { i: parseFloat(mArr[1]) };
    else return { p: value };
  });
};

/*!
 * ## _getPathValue(parsed, obj)
 *
 * Helper companion function for `.parsePath` that returns
 * the value located at the parsed address.
 *
 *      var value = getPathValue(parsed, obj);
 *
 * @param {Object} parsed definition from `parsePath`.
 * @param {Object} object to search against
 * @returns {Object|Undefined} value
 * @api private
 */

function _getPathValue (parsed, obj) {
  var tmp = obj
    , res;
  for (var i = 0, l = parsed.length; i < l; i++) {
    var part = parsed[i];
    if (tmp) {
      if ('undefined' !== typeof part.p)
        tmp = tmp[part.p];
      else if ('undefined' !== typeof part.i)
        tmp = tmp[part.i];
      if (i == (l - 1)) res = tmp;
    } else {
      res = undefined;
    }
  }
  return res;
};

},{}],31:[function(require,module,exports){
/*!
 * Chai - getProperties utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .getProperties(object)
 *
 * This allows the retrieval of property names of an object, enumerable or not,
 * inherited or not.
 *
 * @param {Object} object
 * @returns {Array}
 * @name getProperties
 * @api public
 */

module.exports = function getProperties(object) {
  var result = Object.getOwnPropertyNames(subject);

  function addProperty(property) {
    if (result.indexOf(property) === -1) {
      result.push(property);
    }
  }

  var proto = Object.getPrototypeOf(subject);
  while (proto !== null) {
    Object.getOwnPropertyNames(proto).forEach(addProperty);
    proto = Object.getPrototypeOf(proto);
  }

  return result;
};

},{}],32:[function(require,module,exports){
/*!
 * chai
 * Copyright(c) 2011 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Main exports
 */

var exports = module.exports = {};

/*!
 * test utility
 */

exports.test = require('./test');

/*!
 * type utility
 */

exports.type = require('./type');

/*!
 * message utility
 */

exports.getMessage = require('./getMessage');

/*!
 * actual utility
 */

exports.getActual = require('./getActual');

/*!
 * Inspect util
 */

exports.inspect = require('./inspect');

/*!
 * Object Display util
 */

exports.objDisplay = require('./objDisplay');

/*!
 * Flag utility
 */

exports.flag = require('./flag');

/*!
 * Flag transferring utility
 */

exports.transferFlags = require('./transferFlags');

/*!
 * Deep equal utility
 */

exports.eql = require('deep-eql');

/*!
 * Deep path value
 */

exports.getPathValue = require('./getPathValue');

/*!
 * Function name
 */

exports.getName = require('./getName');

/*!
 * add Property
 */

exports.addProperty = require('./addProperty');

/*!
 * add Method
 */

exports.addMethod = require('./addMethod');

/*!
 * overwrite Property
 */

exports.overwriteProperty = require('./overwriteProperty');

/*!
 * overwrite Method
 */

exports.overwriteMethod = require('./overwriteMethod');

/*!
 * Add a chainable method
 */

exports.addChainableMethod = require('./addChainableMethod');

/*!
 * Overwrite chainable method
 */

exports.overwriteChainableMethod = require('./overwriteChainableMethod');


},{"./addChainableMethod":22,"./addMethod":23,"./addProperty":24,"./flag":25,"./getActual":26,"./getMessage":28,"./getName":29,"./getPathValue":30,"./inspect":33,"./objDisplay":34,"./overwriteChainableMethod":35,"./overwriteMethod":36,"./overwriteProperty":37,"./test":38,"./transferFlags":39,"./type":40,"deep-eql":42}],33:[function(require,module,exports){
// This is (almost) directly from Node.js utils
// https://github.com/joyent/node/blob/f8c335d0caf47f16d31413f89aa28eda3878e3aa/lib/util.js

var getName = require('./getName');
var getProperties = require('./getProperties');
var getEnumerableProperties = require('./getEnumerableProperties');

module.exports = inspect;

/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Boolean} showHidden Flag that shows hidden (not enumerable)
 *    properties of objects.
 * @param {Number} depth Depth in which to descend in object. Default is 2.
 * @param {Boolean} colors Flag to turn on ANSI escape codes to color the
 *    output. Default is false (no coloring).
 */
function inspect(obj, showHidden, depth, colors) {
  var ctx = {
    showHidden: showHidden,
    seen: [],
    stylize: function (str) { return str; }
  };
  return formatValue(ctx, obj, (typeof depth === 'undefined' ? 2 : depth));
}

// https://gist.github.com/1044128/
var getOuterHTML = function(element) {
  if ('outerHTML' in element) return element.outerHTML;
  var ns = "http://www.w3.org/1999/xhtml";
  var container = document.createElementNS(ns, '_');
  var elemProto = (window.HTMLElement || window.Element).prototype;
  var xmlSerializer = new XMLSerializer();
  var html;
  if (document.xmlVersion) {
    return xmlSerializer.serializeToString(element);
  } else {
    container.appendChild(element.cloneNode(false));
    html = container.innerHTML.replace('><', '>' + element.innerHTML + '<');
    container.innerHTML = '';
    return html;
  }
};

// Returns true if object is a DOM element.
var isDOMElement = function (object) {
  if (typeof HTMLElement === 'object') {
    return object instanceof HTMLElement;
  } else {
    return object &&
      typeof object === 'object' &&
      object.nodeType === 1 &&
      typeof object.nodeName === 'string';
  }
};

function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (value && typeof value.inspect === 'function' &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes);
    if (typeof ret !== 'string') {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // If it's DOM elem, get outer HTML.
  if (isDOMElement(value)) {
    return getOuterHTML(value);
  }

  // Look up the keys of the object.
  var visibleKeys = getEnumerableProperties(value);
  var keys = ctx.showHidden ? getProperties(value) : visibleKeys;

  // Some type of object without properties can be shortcutted.
  // In IE, errors have a single `stack` property, or if they are vanilla `Error`,
  // a `stack` plus `description` property; ignore those for consistency.
  if (keys.length === 0 || (isError(value) && (
      (keys.length === 1 && keys[0] === 'stack') ||
      (keys.length === 2 && keys[0] === 'description' && keys[1] === 'stack')
     ))) {
    if (typeof value === 'function') {
      var name = getName(value);
      var nameSuffix = name ? ': ' + name : '';
      return ctx.stylize('[Function' + nameSuffix + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toUTCString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (typeof value === 'function') {
    var name = getName(value);
    var nameSuffix = name ? ': ' + name : '';
    base = ' [Function' + nameSuffix + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    return formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  switch (typeof value) {
    case 'undefined':
      return ctx.stylize('undefined', 'undefined');

    case 'string':
      var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                               .replace(/'/g, "\\'")
                                               .replace(/\\"/g, '"') + '\'';
      return ctx.stylize(simple, 'string');

    case 'number':
      return ctx.stylize('' + value, 'number');

    case 'boolean':
      return ctx.stylize('' + value, 'boolean');
  }
  // For some reason typeof null is "object", so special case here.
  if (value === null) {
    return ctx.stylize('null', 'null');
  }
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (Object.prototype.hasOwnProperty.call(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str;
  if (value.__lookupGetter__) {
    if (value.__lookupGetter__(key)) {
      if (value.__lookupSetter__(key)) {
        str = ctx.stylize('[Getter/Setter]', 'special');
      } else {
        str = ctx.stylize('[Getter]', 'special');
      }
    } else {
      if (value.__lookupSetter__(key)) {
        str = ctx.stylize('[Setter]', 'special');
      }
    }
  }
  if (visibleKeys.indexOf(key) < 0) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(value[key]) < 0) {
      if (recurseTimes === null) {
        str = formatValue(ctx, value[key], null);
      } else {
        str = formatValue(ctx, value[key], recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (typeof name === 'undefined') {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}

function isArray(ar) {
  return Array.isArray(ar) ||
         (typeof ar === 'object' && objectToString(ar) === '[object Array]');
}

function isRegExp(re) {
  return typeof re === 'object' && objectToString(re) === '[object RegExp]';
}

function isDate(d) {
  return typeof d === 'object' && objectToString(d) === '[object Date]';
}

function isError(e) {
  return typeof e === 'object' && objectToString(e) === '[object Error]';
}

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

},{"./getEnumerableProperties":27,"./getName":29,"./getProperties":31}],34:[function(require,module,exports){
/*!
 * Chai - flag utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependancies
 */

var inspect = require('./inspect');
var config = require('../config');

/**
 * ### .objDisplay (object)
 *
 * Determines if an object or an array matches
 * criteria to be inspected in-line for error
 * messages or should be truncated.
 *
 * @param {Mixed} javascript object to inspect
 * @name objDisplay
 * @api public
 */

module.exports = function (obj) {
  var str = inspect(obj)
    , type = Object.prototype.toString.call(obj);

  if (config.truncateThreshold && str.length >= config.truncateThreshold) {
    if (type === '[object Function]') {
      return !obj.name || obj.name === ''
        ? '[Function]'
        : '[Function: ' + obj.name + ']';
    } else if (type === '[object Array]') {
      return '[ Array(' + obj.length + ') ]';
    } else if (type === '[object Object]') {
      var keys = Object.keys(obj)
        , kstr = keys.length > 2
          ? keys.splice(0, 2).join(', ') + ', ...'
          : keys.join(', ');
      return '{ Object (' + kstr + ') }';
    } else {
      return str;
    }
  } else {
    return str;
  }
};

},{"../config":17,"./inspect":33}],35:[function(require,module,exports){
/*!
 * Chai - overwriteChainableMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### overwriteChainableMethod (ctx, name, fn)
 *
 * Overwites an already existing chainable method
 * and provides access to the previous function or
 * property.  Must return functions to be used for
 * name.
 *
 *     utils.overwriteChainableMethod(chai.Assertion.prototype, 'length',
 *       function (_super) {
 *       }
 *     , function (_super) {
 *       }
 *     );
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.overwriteChainableMethod('foo', fn, fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(myFoo).to.have.length(3);
 *     expect(myFoo).to.have.length.above(3);
 *
 * @param {Object} ctx object whose method / property is to be overwritten
 * @param {String} name of method / property to overwrite
 * @param {Function} method function that returns a function to be used for name
 * @param {Function} chainingBehavior function that returns a function to be used for property
 * @name overwriteChainableMethod
 * @api public
 */

module.exports = function (ctx, name, method, chainingBehavior) {
  var chainableBehavior = ctx.__methods[name];

  var _chainingBehavior = chainableBehavior.chainingBehavior;
  chainableBehavior.chainingBehavior = function () {
    var result = chainingBehavior(_chainingBehavior).call(this);
    return result === undefined ? this : result;
  };

  var _method = chainableBehavior.method;
  chainableBehavior.method = function () {
    var result = method(_method).apply(this, arguments);
    return result === undefined ? this : result;
  };
};

},{}],36:[function(require,module,exports){
/*!
 * Chai - overwriteMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### overwriteMethod (ctx, name, fn)
 *
 * Overwites an already existing method and provides
 * access to previous function. Must return function
 * to be used for name.
 *
 *     utils.overwriteMethod(chai.Assertion.prototype, 'equal', function (_super) {
 *       return function (str) {
 *         var obj = utils.flag(this, 'object');
 *         if (obj instanceof Foo) {
 *           new chai.Assertion(obj.value).to.equal(str);
 *         } else {
 *           _super.apply(this, arguments);
 *         }
 *       }
 *     });
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.overwriteMethod('foo', fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(myFoo).to.equal('bar');
 *
 * @param {Object} ctx object whose method is to be overwritten
 * @param {String} name of method to overwrite
 * @param {Function} method function that returns a function to be used for name
 * @name overwriteMethod
 * @api public
 */

module.exports = function (ctx, name, method) {
  var _method = ctx[name]
    , _super = function () { return this; };

  if (_method && 'function' === typeof _method)
    _super = _method;

  ctx[name] = function () {
    var result = method(_super).apply(this, arguments);
    return result === undefined ? this : result;
  }
};

},{}],37:[function(require,module,exports){
/*!
 * Chai - overwriteProperty utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### overwriteProperty (ctx, name, fn)
 *
 * Overwites an already existing property getter and provides
 * access to previous value. Must return function to use as getter.
 *
 *     utils.overwriteProperty(chai.Assertion.prototype, 'ok', function (_super) {
 *       return function () {
 *         var obj = utils.flag(this, 'object');
 *         if (obj instanceof Foo) {
 *           new chai.Assertion(obj.name).to.equal('bar');
 *         } else {
 *           _super.call(this);
 *         }
 *       }
 *     });
 *
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.overwriteProperty('foo', fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(myFoo).to.be.ok;
 *
 * @param {Object} ctx object whose property is to be overwritten
 * @param {String} name of property to overwrite
 * @param {Function} getter function that returns a getter function to be used for name
 * @name overwriteProperty
 * @api public
 */

module.exports = function (ctx, name, getter) {
  var _get = Object.getOwnPropertyDescriptor(ctx, name)
    , _super = function () {};

  if (_get && 'function' === typeof _get.get)
    _super = _get.get

  Object.defineProperty(ctx, name,
    { get: function () {
        var result = getter(_super).call(this);
        return result === undefined ? this : result;
      }
    , configurable: true
  });
};

},{}],38:[function(require,module,exports){
/*!
 * Chai - test utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependancies
 */

var flag = require('./flag');

/**
 * # test(object, expression)
 *
 * Test and object for expression.
 *
 * @param {Object} object (constructed Assertion)
 * @param {Arguments} chai.Assertion.prototype.assert arguments
 */

module.exports = function (obj, args) {
  var negate = flag(obj, 'negate')
    , expr = args[0];
  return negate ? !expr : expr;
};

},{"./flag":25}],39:[function(require,module,exports){
/*!
 * Chai - transferFlags utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### transferFlags(assertion, object, includeAll = true)
 *
 * Transfer all the flags for `assertion` to `object`. If
 * `includeAll` is set to `false`, then the base Chai
 * assertion flags (namely `object`, `ssfi`, and `message`)
 * will not be transferred.
 *
 *
 *     var newAssertion = new Assertion();
 *     utils.transferFlags(assertion, newAssertion);
 *
 *     var anotherAsseriton = new Assertion(myObj);
 *     utils.transferFlags(assertion, anotherAssertion, false);
 *
 * @param {Assertion} assertion the assertion to transfer the flags from
 * @param {Object} object the object to transfer the flags too; usually a new assertion
 * @param {Boolean} includeAll
 * @name getAllFlags
 * @api private
 */

module.exports = function (assertion, object, includeAll) {
  var flags = assertion.__flags || (assertion.__flags = Object.create(null));

  if (!object.__flags) {
    object.__flags = Object.create(null);
  }

  includeAll = arguments.length === 3 ? includeAll : true;

  for (var flag in flags) {
    if (includeAll ||
        (flag !== 'object' && flag !== 'ssfi' && flag != 'message')) {
      object.__flags[flag] = flags[flag];
    }
  }
};

},{}],40:[function(require,module,exports){
/*!
 * Chai - type utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Detectable javascript natives
 */

var natives = {
    '[object Arguments]': 'arguments'
  , '[object Array]': 'array'
  , '[object Date]': 'date'
  , '[object Function]': 'function'
  , '[object Number]': 'number'
  , '[object RegExp]': 'regexp'
  , '[object String]': 'string'
};

/**
 * ### type(object)
 *
 * Better implementation of `typeof` detection that can
 * be used cross-browser. Handles the inconsistencies of
 * Array, `null`, and `undefined` detection.
 *
 *     utils.type({}) // 'object'
 *     utils.type(null) // `null'
 *     utils.type(undefined) // `undefined`
 *     utils.type([]) // `array`
 *
 * @param {Mixed} object to detect type of
 * @name type
 * @api private
 */

module.exports = function (obj) {
  var str = Object.prototype.toString.call(obj);
  if (natives[str]) return natives[str];
  if (obj === null) return 'null';
  if (obj === undefined) return 'undefined';
  if (obj === Object(obj)) return 'object';
  return typeof obj;
};

},{}],41:[function(require,module,exports){
/*!
 * assertion-error
 * Copyright(c) 2013 Jake Luer <jake@qualiancy.com>
 * MIT Licensed
 */

/*!
 * Return a function that will copy properties from
 * one object to another excluding any originally
 * listed. Returned function will create a new `{}`.
 *
 * @param {String} excluded properties ...
 * @return {Function}
 */

function exclude () {
  var excludes = [].slice.call(arguments);

  function excludeProps (res, obj) {
    Object.keys(obj).forEach(function (key) {
      if (!~excludes.indexOf(key)) res[key] = obj[key];
    });
  }

  return function extendExclude () {
    var args = [].slice.call(arguments)
      , i = 0
      , res = {};

    for (; i < args.length; i++) {
      excludeProps(res, args[i]);
    }

    return res;
  };
};

/*!
 * Primary Exports
 */

module.exports = AssertionError;

/**
 * ### AssertionError
 *
 * An extension of the JavaScript `Error` constructor for
 * assertion and validation scenarios.
 *
 * @param {String} message
 * @param {Object} properties to include (optional)
 * @param {callee} start stack function (optional)
 */

function AssertionError (message, _props, ssf) {
  var extend = exclude('name', 'message', 'stack', 'constructor', 'toJSON')
    , props = extend(_props || {});

  // default values
  this.message = message || 'Unspecified AssertionError';
  this.showDiff = false;

  // copy from properties
  for (var key in props) {
    this[key] = props[key];
  }

  // capture stack trace
  ssf = ssf || arguments.callee;
  if (ssf && Error.captureStackTrace) {
    Error.captureStackTrace(this, ssf);
  }
}

/*!
 * Inherit from Error.prototype
 */

AssertionError.prototype = Object.create(Error.prototype);

/*!
 * Statically set name
 */

AssertionError.prototype.name = 'AssertionError';

/*!
 * Ensure correct constructor
 */

AssertionError.prototype.constructor = AssertionError;

/**
 * Allow errors to be converted to JSON for static transfer.
 *
 * @param {Boolean} include stack (default: `true`)
 * @return {Object} object that can be `JSON.stringify`
 */

AssertionError.prototype.toJSON = function (stack) {
  var extend = exclude('constructor', 'toJSON', 'stack')
    , props = extend({ name: this.name }, this);

  // include stack if exists and not turned off
  if (false !== stack && this.stack) {
    props.stack = this.stack;
  }

  return props;
};

},{}],42:[function(require,module,exports){
module.exports = require('./lib/eql');

},{"./lib/eql":43}],43:[function(require,module,exports){
/*!
 * deep-eql
 * Copyright(c) 2013 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependencies
 */

var type = require('type-detect');

/*!
 * Buffer.isBuffer browser shim
 */

var Buffer;
try { Buffer = require('buffer').Buffer; }
catch(ex) {
  Buffer = {};
  Buffer.isBuffer = function() { return false; }
}

/*!
 * Primary Export
 */

module.exports = deepEqual;

/**
 * Assert super-strict (egal) equality between
 * two objects of any type.
 *
 * @param {Mixed} a
 * @param {Mixed} b
 * @param {Array} memoised (optional)
 * @return {Boolean} equal match
 */

function deepEqual(a, b, m) {
  if (sameValue(a, b)) {
    return true;
  } else if ('date' === type(a)) {
    return dateEqual(a, b);
  } else if ('regexp' === type(a)) {
    return regexpEqual(a, b);
  } else if (Buffer.isBuffer(a)) {
    return bufferEqual(a, b);
  } else if ('arguments' === type(a)) {
    return argumentsEqual(a, b, m);
  } else if (!typeEqual(a, b)) {
    return false;
  } else if (('object' !== type(a) && 'object' !== type(b))
  && ('array' !== type(a) && 'array' !== type(b))) {
    return sameValue(a, b);
  } else {
    return objectEqual(a, b, m);
  }
}

/*!
 * Strict (egal) equality test. Ensures that NaN always
 * equals NaN and `-0` does not equal `+0`.
 *
 * @param {Mixed} a
 * @param {Mixed} b
 * @return {Boolean} equal match
 */

function sameValue(a, b) {
  if (a === b) return a !== 0 || 1 / a === 1 / b;
  return a !== a && b !== b;
}

/*!
 * Compare the types of two given objects and
 * return if they are equal. Note that an Array
 * has a type of `array` (not `object`) and arguments
 * have a type of `arguments` (not `array`/`object`).
 *
 * @param {Mixed} a
 * @param {Mixed} b
 * @return {Boolean} result
 */

function typeEqual(a, b) {
  return type(a) === type(b);
}

/*!
 * Compare two Date objects by asserting that
 * the time values are equal using `saveValue`.
 *
 * @param {Date} a
 * @param {Date} b
 * @return {Boolean} result
 */

function dateEqual(a, b) {
  if ('date' !== type(b)) return false;
  return sameValue(a.getTime(), b.getTime());
}

/*!
 * Compare two regular expressions by converting them
 * to string and checking for `sameValue`.
 *
 * @param {RegExp} a
 * @param {RegExp} b
 * @return {Boolean} result
 */

function regexpEqual(a, b) {
  if ('regexp' !== type(b)) return false;
  return sameValue(a.toString(), b.toString());
}

/*!
 * Assert deep equality of two `arguments` objects.
 * Unfortunately, these must be sliced to arrays
 * prior to test to ensure no bad behavior.
 *
 * @param {Arguments} a
 * @param {Arguments} b
 * @param {Array} memoize (optional)
 * @return {Boolean} result
 */

function argumentsEqual(a, b, m) {
  if ('arguments' !== type(b)) return false;
  a = [].slice.call(a);
  b = [].slice.call(b);
  return deepEqual(a, b, m);
}

/*!
 * Get enumerable properties of a given object.
 *
 * @param {Object} a
 * @return {Array} property names
 */

function enumerable(a) {
  var res = [];
  for (var key in a) res.push(key);
  return res;
}

/*!
 * Simple equality for flat iterable objects
 * such as Arrays or Node.js buffers.
 *
 * @param {Iterable} a
 * @param {Iterable} b
 * @return {Boolean} result
 */

function iterableEqual(a, b) {
  if (a.length !==  b.length) return false;

  var i = 0;
  var match = true;

  for (; i < a.length; i++) {
    if (a[i] !== b[i]) {
      match = false;
      break;
    }
  }

  return match;
}

/*!
 * Extension to `iterableEqual` specifically
 * for Node.js Buffers.
 *
 * @param {Buffer} a
 * @param {Mixed} b
 * @return {Boolean} result
 */

function bufferEqual(a, b) {
  if (!Buffer.isBuffer(b)) return false;
  return iterableEqual(a, b);
}

/*!
 * Block for `objectEqual` ensuring non-existing
 * values don't get in.
 *
 * @param {Mixed} object
 * @return {Boolean} result
 */

function isValue(a) {
  return a !== null && a !== undefined;
}

/*!
 * Recursively check the equality of two objects.
 * Once basic sameness has been established it will
 * defer to `deepEqual` for each enumerable key
 * in the object.
 *
 * @param {Mixed} a
 * @param {Mixed} b
 * @return {Boolean} result
 */

function objectEqual(a, b, m) {
  if (!isValue(a) || !isValue(b)) {
    return false;
  }

  if (a.prototype !== b.prototype) {
    return false;
  }

  var i;
  if (m) {
    for (i = 0; i < m.length; i++) {
      if ((m[i][0] === a && m[i][1] === b)
      ||  (m[i][0] === b && m[i][1] === a)) {
        return true;
      }
    }
  } else {
    m = [];
  }

  try {
    var ka = enumerable(a);
    var kb = enumerable(b);
  } catch (ex) {
    return false;
  }

  ka.sort();
  kb.sort();

  if (!iterableEqual(ka, kb)) {
    return false;
  }

  m.push([ a, b ]);

  var key;
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!deepEqual(a[key], b[key], m)) {
      return false;
    }
  }

  return true;
}

},{"buffer":47,"type-detect":44}],44:[function(require,module,exports){
module.exports = require('./lib/type');

},{"./lib/type":45}],45:[function(require,module,exports){
/*!
 * type-detect
 * Copyright(c) 2013 jake luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Primary Exports
 */

var exports = module.exports = getType;

/*!
 * Detectable javascript natives
 */

var natives = {
    '[object Array]': 'array'
  , '[object RegExp]': 'regexp'
  , '[object Function]': 'function'
  , '[object Arguments]': 'arguments'
  , '[object Date]': 'date'
};

/**
 * ### typeOf (obj)
 *
 * Use several different techniques to determine
 * the type of object being tested.
 *
 *
 * @param {Mixed} object
 * @return {String} object type
 * @api public
 */

function getType (obj) {
  var str = Object.prototype.toString.call(obj);
  if (natives[str]) return natives[str];
  if (obj === null) return 'null';
  if (obj === undefined) return 'undefined';
  if (obj === Object(obj)) return 'object';
  return typeof obj;
}

exports.Library = Library;

/**
 * ### Library
 *
 * Create a repository for custom type detection.
 *
 * ```js
 * var lib = new type.Library;
 * ```
 *
 */

function Library () {
  this.tests = {};
}

/**
 * #### .of (obj)
 *
 * Expose replacement `typeof` detection to the library.
 *
 * ```js
 * if ('string' === lib.of('hello world')) {
 *   // ...
 * }
 * ```
 *
 * @param {Mixed} object to test
 * @return {String} type
 */

Library.prototype.of = getType;

/**
 * #### .define (type, test)
 *
 * Add a test to for the `.test()` assertion.
 *
 * Can be defined as a regular expression:
 *
 * ```js
 * lib.define('int', /^[0-9]+$/);
 * ```
 *
 * ... or as a function:
 *
 * ```js
 * lib.define('bln', function (obj) {
 *   if ('boolean' === lib.of(obj)) return true;
 *   var blns = [ 'yes', 'no', 'true', 'false', 1, 0 ];
 *   if ('string' === lib.of(obj)) obj = obj.toLowerCase();
 *   return !! ~blns.indexOf(obj);
 * });
 * ```
 *
 * @param {String} type
 * @param {RegExp|Function} test
 * @api public
 */

Library.prototype.define = function (type, test) {
  if (arguments.length === 1) return this.tests[type];
  this.tests[type] = test;
  return this;
};

/**
 * #### .test (obj, test)
 *
 * Assert that an object is of type. Will first
 * check natives, and if that does not pass it will
 * use the user defined custom tests.
 *
 * ```js
 * assert(lib.test('1', 'int'));
 * assert(lib.test('yes', 'bln'));
 * ```
 *
 * @param {Mixed} object
 * @param {String} type
 * @return {Boolean} result
 * @api public
 */

Library.prototype.test = function (obj, type) {
  if (type === getType(obj)) return true;
  var test = this.tests[type];

  if (test && 'regexp' === getType(test)) {
    return test.test(obj);
  } else if (test && 'function' === getType(test)) {
    return test(obj);
  } else {
    throw new ReferenceError('Type test "' + type + '" not defined or invalid.');
  }
};

},{}],46:[function(require,module,exports){

},{}],47:[function(require,module,exports){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = Buffer
exports.INSPECT_MAX_BYTES = 50
Buffer.poolSize = 8192

/**
 * If `TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Note:
 *
 * - Implementation must support adding new properties to `Uint8Array` instances.
 *   Firefox 4-29 lacked support, fixed in Firefox 30+.
 *   See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *  - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *  - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *    incorrect length in some situations.
 *
 * We detect these buggy browsers and set `TYPED_ARRAY_SUPPORT` to `false` so they will
 * get the Object implementation, which is slower but will work correctly.
 */
var TYPED_ARRAY_SUPPORT = (function () {
  try {
    var buf = new ArrayBuffer(0)
    var arr = new Uint8Array(buf)
    arr.foo = function () { return 42 }
    return 42 === arr.foo() && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        new Uint8Array(1).subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
})()

/**
 * Class: Buffer
 * =============
 *
 * The Buffer constructor returns instances of `Uint8Array` that are augmented
 * with function properties for all the node `Buffer` API functions. We use
 * `Uint8Array` so that square bracket notation works as expected -- it returns
 * a single octet.
 *
 * By augmenting the instances, we can avoid modifying the `Uint8Array`
 * prototype.
 */
function Buffer (subject, encoding, noZero) {
  if (!(this instanceof Buffer))
    return new Buffer(subject, encoding, noZero)

  var type = typeof subject

  // Find the length
  var length
  if (type === 'number')
    length = subject > 0 ? subject >>> 0 : 0
  else if (type === 'string') {
    if (encoding === 'base64')
      subject = base64clean(subject)
    length = Buffer.byteLength(subject, encoding)
  } else if (type === 'object' && subject !== null) { // assume object is array-like
    if (subject.type === 'Buffer' && isArray(subject.data))
      subject = subject.data
    length = +subject.length > 0 ? Math.floor(+subject.length) : 0
  } else
    throw new Error('First argument needs to be a number, array or string.')

  var buf
  if (TYPED_ARRAY_SUPPORT) {
    // Preferred: Return an augmented `Uint8Array` instance for best performance
    buf = Buffer._augment(new Uint8Array(length))
  } else {
    // Fallback: Return THIS instance of Buffer (created by `new`)
    buf = this
    buf.length = length
    buf._isBuffer = true
  }

  var i
  if (TYPED_ARRAY_SUPPORT && typeof subject.byteLength === 'number') {
    // Speed optimization -- use set if we're copying from a typed array
    buf._set(subject)
  } else if (isArrayish(subject)) {
    // Treat array-ish objects as a byte array
    if (Buffer.isBuffer(subject)) {
      for (i = 0; i < length; i++)
        buf[i] = subject.readUInt8(i)
    } else {
      for (i = 0; i < length; i++)
        buf[i] = ((subject[i] % 256) + 256) % 256
    }
  } else if (type === 'string') {
    buf.write(subject, 0, encoding)
  } else if (type === 'number' && !TYPED_ARRAY_SUPPORT && !noZero) {
    for (i = 0; i < length; i++) {
      buf[i] = 0
    }
  }

  return buf
}

// STATIC METHODS
// ==============

Buffer.isEncoding = function (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'raw':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.isBuffer = function (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.byteLength = function (str, encoding) {
  var ret
  str = str.toString()
  switch (encoding || 'utf8') {
    case 'hex':
      ret = str.length / 2
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8ToBytes(str).length
      break
    case 'ascii':
    case 'binary':
    case 'raw':
      ret = str.length
      break
    case 'base64':
      ret = base64ToBytes(str).length
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = str.length * 2
      break
    default:
      throw new Error('Unknown encoding')
  }
  return ret
}

Buffer.concat = function (list, totalLength) {
  assert(isArray(list), 'Usage: Buffer.concat(list[, length])')

  if (list.length === 0) {
    return new Buffer(0)
  } else if (list.length === 1) {
    return list[0]
  }

  var i
  if (totalLength === undefined) {
    totalLength = 0
    for (i = 0; i < list.length; i++) {
      totalLength += list[i].length
    }
  }

  var buf = new Buffer(totalLength)
  var pos = 0
  for (i = 0; i < list.length; i++) {
    var item = list[i]
    item.copy(buf, pos)
    pos += item.length
  }
  return buf
}

Buffer.compare = function (a, b) {
  assert(Buffer.isBuffer(a) && Buffer.isBuffer(b), 'Arguments must be Buffers')
  var x = a.length
  var y = b.length
  for (var i = 0, len = Math.min(x, y); i < len && a[i] === b[i]; i++) {}
  if (i !== len) {
    x = a[i]
    y = b[i]
  }
  if (x < y) {
    return -1
  }
  if (y < x) {
    return 1
  }
  return 0
}

// BUFFER INSTANCE METHODS
// =======================

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  assert(strLen % 2 === 0, 'Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; i++) {
    var byte = parseInt(string.substr(i * 2, 2), 16)
    assert(!isNaN(byte), 'Invalid hex string')
    buf[offset + i] = byte
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  var charsWritten = blitBuffer(utf8ToBytes(string), buf, offset, length)
  return charsWritten
}

function asciiWrite (buf, string, offset, length) {
  var charsWritten = blitBuffer(asciiToBytes(string), buf, offset, length)
  return charsWritten
}

function binaryWrite (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  var charsWritten = blitBuffer(base64ToBytes(string), buf, offset, length)
  return charsWritten
}

function utf16leWrite (buf, string, offset, length) {
  var charsWritten = blitBuffer(utf16leToBytes(string), buf, offset, length)
  return charsWritten
}

Buffer.prototype.write = function (string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length
      length = undefined
    }
  } else {  // legacy
    var swap = encoding
    encoding = offset
    offset = length
    length = swap
  }

  offset = Number(offset) || 0
  var remaining = this.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase()

  var ret
  switch (encoding) {
    case 'hex':
      ret = hexWrite(this, string, offset, length)
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8Write(this, string, offset, length)
      break
    case 'ascii':
      ret = asciiWrite(this, string, offset, length)
      break
    case 'binary':
      ret = binaryWrite(this, string, offset, length)
      break
    case 'base64':
      ret = base64Write(this, string, offset, length)
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = utf16leWrite(this, string, offset, length)
      break
    default:
      throw new Error('Unknown encoding')
  }
  return ret
}

Buffer.prototype.toString = function (encoding, start, end) {
  var self = this

  encoding = String(encoding || 'utf8').toLowerCase()
  start = Number(start) || 0
  end = (end === undefined) ? self.length : Number(end)

  // Fastpath empty strings
  if (end === start)
    return ''

  var ret
  switch (encoding) {
    case 'hex':
      ret = hexSlice(self, start, end)
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8Slice(self, start, end)
      break
    case 'ascii':
      ret = asciiSlice(self, start, end)
      break
    case 'binary':
      ret = binarySlice(self, start, end)
      break
    case 'base64':
      ret = base64Slice(self, start, end)
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = utf16leSlice(self, start, end)
      break
    default:
      throw new Error('Unknown encoding')
  }
  return ret
}

Buffer.prototype.toJSON = function () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

Buffer.prototype.equals = function (b) {
  assert(Buffer.isBuffer(b), 'Argument must be a Buffer')
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.compare = function (b) {
  assert(Buffer.isBuffer(b), 'Argument must be a Buffer')
  return Buffer.compare(this, b)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function (target, target_start, start, end) {
  var source = this

  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (!target_start) target_start = 0

  // Copy 0 bytes; we're done
  if (end === start) return
  if (target.length === 0 || source.length === 0) return

  // Fatal error conditions
  assert(end >= start, 'sourceEnd < sourceStart')
  assert(target_start >= 0 && target_start < target.length,
      'targetStart out of bounds')
  assert(start >= 0 && start < source.length, 'sourceStart out of bounds')
  assert(end >= 0 && end <= source.length, 'sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length)
    end = this.length
  if (target.length - target_start < end - start)
    end = target.length - target_start + start

  var len = end - start

  if (len < 100 || !TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < len; i++) {
      target[i + target_start] = this[i + start]
    }
  } else {
    target._set(this.subarray(start, start + len), target_start)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  var res = ''
  var tmp = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    if (buf[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i])
      tmp = ''
    } else {
      tmp += '%' + buf[i].toString(16)
    }
  }

  return res + decodeUtf8Char(tmp)
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function binarySlice (buf, start, end) {
  return asciiSlice(buf, start, end)
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; i++) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len;
    if (start < 0)
      start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0)
      end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start)
    end = start

  if (TYPED_ARRAY_SUPPORT) {
    return Buffer._augment(this.subarray(start, end))
  } else {
    var sliceLen = end - start
    var newBuf = new Buffer(sliceLen, undefined, true)
    for (var i = 0; i < sliceLen; i++) {
      newBuf[i] = this[i + start]
    }
    return newBuf
  }
}

// `get` will be removed in Node 0.13+
Buffer.prototype.get = function (offset) {
  console.log('.get() is deprecated. Access using array indexes instead.')
  return this.readUInt8(offset)
}

// `set` will be removed in Node 0.13+
Buffer.prototype.set = function (v, offset) {
  console.log('.set() is deprecated. Access using array indexes instead.')
  return this.writeUInt8(v, offset)
}

Buffer.prototype.readUInt8 = function (offset, noAssert) {
  if (!noAssert) {
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < this.length, 'Trying to read beyond buffer length')
  }

  if (offset >= this.length)
    return

  return this[offset]
}

function readUInt16 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val
  if (littleEndian) {
    val = buf[offset]
    if (offset + 1 < len)
      val |= buf[offset + 1] << 8
  } else {
    val = buf[offset] << 8
    if (offset + 1 < len)
      val |= buf[offset + 1]
  }
  return val
}

Buffer.prototype.readUInt16LE = function (offset, noAssert) {
  return readUInt16(this, offset, true, noAssert)
}

Buffer.prototype.readUInt16BE = function (offset, noAssert) {
  return readUInt16(this, offset, false, noAssert)
}

function readUInt32 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val
  if (littleEndian) {
    if (offset + 2 < len)
      val = buf[offset + 2] << 16
    if (offset + 1 < len)
      val |= buf[offset + 1] << 8
    val |= buf[offset]
    if (offset + 3 < len)
      val = val + (buf[offset + 3] << 24 >>> 0)
  } else {
    if (offset + 1 < len)
      val = buf[offset + 1] << 16
    if (offset + 2 < len)
      val |= buf[offset + 2] << 8
    if (offset + 3 < len)
      val |= buf[offset + 3]
    val = val + (buf[offset] << 24 >>> 0)
  }
  return val
}

Buffer.prototype.readUInt32LE = function (offset, noAssert) {
  return readUInt32(this, offset, true, noAssert)
}

Buffer.prototype.readUInt32BE = function (offset, noAssert) {
  return readUInt32(this, offset, false, noAssert)
}

Buffer.prototype.readInt8 = function (offset, noAssert) {
  if (!noAssert) {
    assert(offset !== undefined && offset !== null,
        'missing offset')
    assert(offset < this.length, 'Trying to read beyond buffer length')
  }

  if (offset >= this.length)
    return

  var neg = this[offset] & 0x80
  if (neg)
    return (0xff - this[offset] + 1) * -1
  else
    return this[offset]
}

function readInt16 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val = readUInt16(buf, offset, littleEndian, true)
  var neg = val & 0x8000
  if (neg)
    return (0xffff - val + 1) * -1
  else
    return val
}

Buffer.prototype.readInt16LE = function (offset, noAssert) {
  return readInt16(this, offset, true, noAssert)
}

Buffer.prototype.readInt16BE = function (offset, noAssert) {
  return readInt16(this, offset, false, noAssert)
}

function readInt32 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val = readUInt32(buf, offset, littleEndian, true)
  var neg = val & 0x80000000
  if (neg)
    return (0xffffffff - val + 1) * -1
  else
    return val
}

Buffer.prototype.readInt32LE = function (offset, noAssert) {
  return readInt32(this, offset, true, noAssert)
}

Buffer.prototype.readInt32BE = function (offset, noAssert) {
  return readInt32(this, offset, false, noAssert)
}

function readFloat (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  return ieee754.read(buf, offset, littleEndian, 23, 4)
}

Buffer.prototype.readFloatLE = function (offset, noAssert) {
  return readFloat(this, offset, true, noAssert)
}

Buffer.prototype.readFloatBE = function (offset, noAssert) {
  return readFloat(this, offset, false, noAssert)
}

function readDouble (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset + 7 < buf.length, 'Trying to read beyond buffer length')
  }

  return ieee754.read(buf, offset, littleEndian, 52, 8)
}

Buffer.prototype.readDoubleLE = function (offset, noAssert) {
  return readDouble(this, offset, true, noAssert)
}

Buffer.prototype.readDoubleBE = function (offset, noAssert) {
  return readDouble(this, offset, false, noAssert)
}

Buffer.prototype.writeUInt8 = function (value, offset, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < this.length, 'trying to write beyond buffer length')
    verifuint(value, 0xff)
  }

  if (offset >= this.length) return

  this[offset] = value
  return offset + 1
}

function writeUInt16 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'trying to write beyond buffer length')
    verifuint(value, 0xffff)
  }

  var len = buf.length
  if (offset >= len)
    return

  for (var i = 0, j = Math.min(len - offset, 2); i < j; i++) {
    buf[offset + i] =
        (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
            (littleEndian ? i : 1 - i) * 8
  }
  return offset + 2
}

Buffer.prototype.writeUInt16LE = function (value, offset, noAssert) {
  return writeUInt16(this, value, offset, true, noAssert)
}

Buffer.prototype.writeUInt16BE = function (value, offset, noAssert) {
  return writeUInt16(this, value, offset, false, noAssert)
}

function writeUInt32 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'trying to write beyond buffer length')
    verifuint(value, 0xffffffff)
  }

  var len = buf.length
  if (offset >= len)
    return

  for (var i = 0, j = Math.min(len - offset, 4); i < j; i++) {
    buf[offset + i] =
        (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
  return offset + 4
}

Buffer.prototype.writeUInt32LE = function (value, offset, noAssert) {
  return writeUInt32(this, value, offset, true, noAssert)
}

Buffer.prototype.writeUInt32BE = function (value, offset, noAssert) {
  return writeUInt32(this, value, offset, false, noAssert)
}

Buffer.prototype.writeInt8 = function (value, offset, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < this.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7f, -0x80)
  }

  if (offset >= this.length)
    return

  if (value >= 0)
    this.writeUInt8(value, offset, noAssert)
  else
    this.writeUInt8(0xff + value + 1, offset, noAssert)
  return offset + 1
}

function writeInt16 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7fff, -0x8000)
  }

  var len = buf.length
  if (offset >= len)
    return

  if (value >= 0)
    writeUInt16(buf, value, offset, littleEndian, noAssert)
  else
    writeUInt16(buf, 0xffff + value + 1, offset, littleEndian, noAssert)
  return offset + 2
}

Buffer.prototype.writeInt16LE = function (value, offset, noAssert) {
  return writeInt16(this, value, offset, true, noAssert)
}

Buffer.prototype.writeInt16BE = function (value, offset, noAssert) {
  return writeInt16(this, value, offset, false, noAssert)
}

function writeInt32 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7fffffff, -0x80000000)
  }

  var len = buf.length
  if (offset >= len)
    return

  if (value >= 0)
    writeUInt32(buf, value, offset, littleEndian, noAssert)
  else
    writeUInt32(buf, 0xffffffff + value + 1, offset, littleEndian, noAssert)
  return offset + 4
}

Buffer.prototype.writeInt32LE = function (value, offset, noAssert) {
  return writeInt32(this, value, offset, true, noAssert)
}

Buffer.prototype.writeInt32BE = function (value, offset, noAssert) {
  return writeInt32(this, value, offset, false, noAssert)
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to write beyond buffer length')
    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }

  var len = buf.length
  if (offset >= len)
    return

  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 7 < buf.length,
        'Trying to write beyond buffer length')
    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }

  var len = buf.length
  if (offset >= len)
    return

  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function (value, start, end) {
  if (!value) value = 0
  if (!start) start = 0
  if (!end) end = this.length

  assert(end >= start, 'end < start')

  // Fill 0 bytes; we're done
  if (end === start) return
  if (this.length === 0) return

  assert(start >= 0 && start < this.length, 'start out of bounds')
  assert(end >= 0 && end <= this.length, 'end out of bounds')

  var i
  if (typeof value === 'number') {
    for (i = start; i < end; i++) {
      this[i] = value
    }
  } else {
    var bytes = utf8ToBytes(value.toString())
    var len = bytes.length
    for (i = start; i < end; i++) {
      this[i] = bytes[i % len]
    }
  }

  return this
}

Buffer.prototype.inspect = function () {
  var out = []
  var len = this.length
  for (var i = 0; i < len; i++) {
    out[i] = toHex(this[i])
    if (i === exports.INSPECT_MAX_BYTES) {
      out[i + 1] = '...'
      break
    }
  }
  return '<Buffer ' + out.join(' ') + '>'
}

/**
 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
 */
Buffer.prototype.toArrayBuffer = function () {
  if (typeof Uint8Array !== 'undefined') {
    if (TYPED_ARRAY_SUPPORT) {
      return (new Buffer(this)).buffer
    } else {
      var buf = new Uint8Array(this.length)
      for (var i = 0, len = buf.length; i < len; i += 1) {
        buf[i] = this[i]
      }
      return buf.buffer
    }
  } else {
    throw new Error('Buffer.toArrayBuffer not supported in this browser')
  }
}

// HELPER FUNCTIONS
// ================

var BP = Buffer.prototype

/**
 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
 */
Buffer._augment = function (arr) {
  arr._isBuffer = true

  // save reference to original Uint8Array get/set methods before overwriting
  arr._get = arr.get
  arr._set = arr.set

  // deprecated, will be removed in node 0.13+
  arr.get = BP.get
  arr.set = BP.set

  arr.write = BP.write
  arr.toString = BP.toString
  arr.toLocaleString = BP.toString
  arr.toJSON = BP.toJSON
  arr.equals = BP.equals
  arr.compare = BP.compare
  arr.copy = BP.copy
  arr.slice = BP.slice
  arr.readUInt8 = BP.readUInt8
  arr.readUInt16LE = BP.readUInt16LE
  arr.readUInt16BE = BP.readUInt16BE
  arr.readUInt32LE = BP.readUInt32LE
  arr.readUInt32BE = BP.readUInt32BE
  arr.readInt8 = BP.readInt8
  arr.readInt16LE = BP.readInt16LE
  arr.readInt16BE = BP.readInt16BE
  arr.readInt32LE = BP.readInt32LE
  arr.readInt32BE = BP.readInt32BE
  arr.readFloatLE = BP.readFloatLE
  arr.readFloatBE = BP.readFloatBE
  arr.readDoubleLE = BP.readDoubleLE
  arr.readDoubleBE = BP.readDoubleBE
  arr.writeUInt8 = BP.writeUInt8
  arr.writeUInt16LE = BP.writeUInt16LE
  arr.writeUInt16BE = BP.writeUInt16BE
  arr.writeUInt32LE = BP.writeUInt32LE
  arr.writeUInt32BE = BP.writeUInt32BE
  arr.writeInt8 = BP.writeInt8
  arr.writeInt16LE = BP.writeInt16LE
  arr.writeInt16BE = BP.writeInt16BE
  arr.writeInt32LE = BP.writeInt32LE
  arr.writeInt32BE = BP.writeInt32BE
  arr.writeFloatLE = BP.writeFloatLE
  arr.writeFloatBE = BP.writeFloatBE
  arr.writeDoubleLE = BP.writeDoubleLE
  arr.writeDoubleBE = BP.writeDoubleBE
  arr.fill = BP.fill
  arr.inspect = BP.inspect
  arr.toArrayBuffer = BP.toArrayBuffer

  return arr
}

var INVALID_BASE64_RE = /[^+\/0-9A-z]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function isArray (subject) {
  return (Array.isArray || function (subject) {
    return Object.prototype.toString.call(subject) === '[object Array]'
  })(subject)
}

function isArrayish (subject) {
  return isArray(subject) || Buffer.isBuffer(subject) ||
      subject && typeof subject === 'object' &&
      typeof subject.length === 'number'
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    var b = str.charCodeAt(i)
    if (b <= 0x7F) {
      byteArray.push(b)
    } else {
      var start = i
      if (b >= 0xD800 && b <= 0xDFFF) i++
      var h = encodeURIComponent(str.slice(start, i+1)).substr(1).split('%')
      for (var j = 0; j < h.length; j++) {
        byteArray.push(parseInt(h[j], 16))
      }
    }
  }
  return byteArray
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(str)
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; i++) {
    if ((i + offset >= dst.length) || (i >= src.length))
      break
    dst[i + offset] = src[i]
  }
  return i
}

function decodeUtf8Char (str) {
  try {
    return decodeURIComponent(str)
  } catch (err) {
    return String.fromCharCode(0xFFFD) // UTF 8 invalid char
  }
}

/*
 * We have to make sure that the value is a valid integer. This means that it
 * is non-negative. It has no fractional component and that it does not
 * exceed the maximum allowed value.
 */
function verifuint (value, max) {
  assert(typeof value === 'number', 'cannot write a non-number as a number')
  assert(value >= 0, 'specified a negative value for writing an unsigned value')
  assert(value <= max, 'value is larger than maximum value for type')
  assert(Math.floor(value) === value, 'value has a fractional component')
}

function verifsint (value, max, min) {
  assert(typeof value === 'number', 'cannot write a non-number as a number')
  assert(value <= max, 'value larger than maximum allowed value')
  assert(value >= min, 'value smaller than minimum allowed value')
  assert(Math.floor(value) === value, 'value has a fractional component')
}

function verifIEEE754 (value, max, min) {
  assert(typeof value === 'number', 'cannot write a non-number as a number')
  assert(value <= max, 'value larger than maximum allowed value')
  assert(value >= min, 'value smaller than minimum allowed value')
}

function assert (test, message) {
  if (!test) throw new Error(message || 'Failed assertion')
}

},{"base64-js":48,"ieee754":49}],48:[function(require,module,exports){
var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

;(function (exports) {
	'use strict';

  var Arr = (typeof Uint8Array !== 'undefined')
    ? Uint8Array
    : Array

	var PLUS   = '+'.charCodeAt(0)
	var SLASH  = '/'.charCodeAt(0)
	var NUMBER = '0'.charCodeAt(0)
	var LOWER  = 'a'.charCodeAt(0)
	var UPPER  = 'A'.charCodeAt(0)

	function decode (elt) {
		var code = elt.charCodeAt(0)
		if (code === PLUS)
			return 62 // '+'
		if (code === SLASH)
			return 63 // '/'
		if (code < NUMBER)
			return -1 //no match
		if (code < NUMBER + 10)
			return code - NUMBER + 26 + 26
		if (code < UPPER + 26)
			return code - UPPER
		if (code < LOWER + 26)
			return code - LOWER + 26
	}

	function b64ToByteArray (b64) {
		var i, j, l, tmp, placeHolders, arr

		if (b64.length % 4 > 0) {
			throw new Error('Invalid string. Length must be a multiple of 4')
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		var len = b64.length
		placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

		// base64 is 4/3 + up to two characters of the original data
		arr = new Arr(b64.length * 3 / 4 - placeHolders)

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length

		var L = 0

		function push (v) {
			arr[L++] = v
		}

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
			push((tmp & 0xFF0000) >> 16)
			push((tmp & 0xFF00) >> 8)
			push(tmp & 0xFF)
		}

		if (placeHolders === 2) {
			tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
			push(tmp & 0xFF)
		} else if (placeHolders === 1) {
			tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
			push((tmp >> 8) & 0xFF)
			push(tmp & 0xFF)
		}

		return arr
	}

	function uint8ToBase64 (uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length

		function encode (num) {
			return lookup.charAt(num)
		}

		function tripletToBase64 (num) {
			return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
		}

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
			output += tripletToBase64(temp)
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1]
				output += encode(temp >> 2)
				output += encode((temp << 4) & 0x3F)
				output += '=='
				break
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
				output += encode(temp >> 10)
				output += encode((temp >> 4) & 0x3F)
				output += encode((temp << 2) & 0x3F)
				output += '='
				break
		}

		return output
	}

	exports.toByteArray = b64ToByteArray
	exports.fromByteArray = uint8ToBase64
}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))

},{}],49:[function(require,module,exports){
exports.read = function(buffer, offset, isLE, mLen, nBytes) {
  var e, m,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      nBits = -7,
      i = isLE ? (nBytes - 1) : 0,
      d = isLE ? -1 : 1,
      s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity);
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
      i = isLE ? 0 : (nBytes - 1),
      d = isLE ? 1 : -1,
      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);

  buffer[offset + i - d] |= s * 128;
};

},{}],50:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this,require("JkpR2F"))
},{"JkpR2F":51}],51:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            var source = ev.source;
            if ((source === window || source === null) && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}],52:[function(require,module,exports){
/*
 Copyright 2013 Daniel Wirtz <dcode@dcode.io>

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 */

/**
 * @license ProtoBuf.js (c) 2013 Daniel Wirtz <dcode@dcode.io>
 * Released under the Apache License, Version 2.0
 * see: https://github.com/dcodeIO/ProtoBuf.js for details
 */
(function(global) {
    "use strict";

    function init(ByteBuffer) {

        /**
         * The ProtoBuf namespace.
         * @exports ProtoBuf
         * @namespace
         * @expose
         */
        var ProtoBuf = {};

        /**
         * ProtoBuf.js version.
         * @type {string}
         * @const
         * @expose
         */
        ProtoBuf.VERSION = "3.2.2";

        /**
         * Wire types.
         * @type {Object.<string,number>}
         * @const
         * @expose
         */
        ProtoBuf.WIRE_TYPES = {};

        /**
         * Varint wire type.
         * @type {number}
         * @expose
         */
        ProtoBuf.WIRE_TYPES.VARINT = 0;

        /**
         * Fixed 64 bits wire type.
         * @type {number}
         * @const
         * @expose
         */
        ProtoBuf.WIRE_TYPES.BITS64 = 1;

        /**
         * Length delimited wire type.
         * @type {number}
         * @const
         * @expose
         */
        ProtoBuf.WIRE_TYPES.LDELIM = 2;

        /**
         * Start group wire type.
         * @type {number}
         * @const
         * @expose
         */
        ProtoBuf.WIRE_TYPES.STARTGROUP = 3;

        /**
         * End group wire type.
         * @type {number}
         * @const
         * @expose
         */
        ProtoBuf.WIRE_TYPES.ENDGROUP = 4;

        /**
         * Fixed 32 bits wire type.
         * @type {number}
         * @const
         * @expose
         */
        ProtoBuf.WIRE_TYPES.BITS32 = 5;

        /**
         * Packable wire types.
         * @type {!Array.<number>}
         * @const
         * @expose
         */
        ProtoBuf.PACKABLE_WIRE_TYPES = [
            ProtoBuf.WIRE_TYPES.VARINT,
            ProtoBuf.WIRE_TYPES.BITS64,
            ProtoBuf.WIRE_TYPES.BITS32
        ];

        /**
         * Types.
         * @dict
         * @type {Object.<string,{name: string, wireType: number}>}
         * @const
         * @expose
         */
        ProtoBuf.TYPES = {
            // According to the protobuf spec.
            "int32": {
                name: "int32",
                wireType: ProtoBuf.WIRE_TYPES.VARINT
            },
            "uint32": {
                name: "uint32",
                wireType: ProtoBuf.WIRE_TYPES.VARINT
            },
            "sint32": {
                name: "sint32",
                wireType: ProtoBuf.WIRE_TYPES.VARINT
            },
            "int64": {
                name: "int64",
                wireType: ProtoBuf.WIRE_TYPES.VARINT
            },
            "uint64": {
                name: "uint64",
                wireType: ProtoBuf.WIRE_TYPES.VARINT
            },
            "sint64": {
                name: "sint64",
                wireType: ProtoBuf.WIRE_TYPES.VARINT
            },
            "bool": {
                name: "bool",
                wireType: ProtoBuf.WIRE_TYPES.VARINT
            },
            "double": {
                name: "double",
                wireType: ProtoBuf.WIRE_TYPES.BITS64
            },
            "string": {
                name: "string",
                wireType: ProtoBuf.WIRE_TYPES.LDELIM
            },
            "bytes": {
                name: "bytes",
                wireType: ProtoBuf.WIRE_TYPES.LDELIM
            },
            "fixed32": {
                name: "fixed32",
                wireType: ProtoBuf.WIRE_TYPES.BITS32
            },
            "sfixed32": {
                name: "sfixed32",
                wireType: ProtoBuf.WIRE_TYPES.BITS32
            },
            "fixed64": {
                name: "fixed64",
                wireType: ProtoBuf.WIRE_TYPES.BITS64
            },
            "sfixed64": {
                name: "sfixed64",
                wireType: ProtoBuf.WIRE_TYPES.BITS64
            },
            "float": {
                name: "float",
                wireType: ProtoBuf.WIRE_TYPES.BITS32
            },
            "enum": {
                name: "enum",
                wireType: ProtoBuf.WIRE_TYPES.VARINT
            },
            "message": {
                name: "message",
                wireType: ProtoBuf.WIRE_TYPES.LDELIM
            },
            "group": {
                name: "group",
                wireType: ProtoBuf.WIRE_TYPES.STARTGROUP
            }
        };

        /**
         * Minimum field id.
         * @type {number}
         * @const
         * @expose
         */
        ProtoBuf.ID_MIN = 1;

        /**
         * Maximum field id.
         * @type {number}
         * @const
         * @expose
         */
        ProtoBuf.ID_MAX = 0x1FFFFFFF;

        /**
         * @type {!function(new: ByteBuffer, ...[*])}
         * @expose
         */
        ProtoBuf.ByteBuffer = ByteBuffer;

        /**
         * @type {?function(new: Long, ...[*])}
         * @expose
         */
        ProtoBuf.Long = ByteBuffer.Long || null;

        /**
         * If set to `true`, field names will be converted from underscore notation to camel case. Defaults to `false`.
         *  Must be set prior to parsing.
         * @type {boolean}
         * @expose
         */
        ProtoBuf.convertFieldsToCamelCase = false;

        /**
         * @alias ProtoBuf.Util
         * @expose
         */
        ProtoBuf.Util = (function() {
            "use strict";

            // Object.create polyfill
            // ref: https://developer.mozilla.org/de/docs/JavaScript/Reference/Global_Objects/Object/create
            if (!Object.create)
                /** @expose */
                Object.create = function (o) {
                    if (arguments.length > 1)
                        throw Error('Object.create polyfill only accepts the first parameter.');
                    function F() {}
                    F.prototype = o;
                    return new F();
                };

            /**
             * ProtoBuf utilities.
             * @exports ProtoBuf.Util
             * @namespace
             */
            var Util = {};

            /**
             * Flag if running in node (fs is available) or not.
             * @type {boolean}
             * @const
             * @expose
             */
            Util.IS_NODE = false;
            try {
                // There is no reliable way to detect node.js as an environment, so our
                // best bet is to feature-detect what we actually need.
                Util.IS_NODE =
                    typeof require === 'function' &&
                    typeof require("fs").readFileSync === 'function' &&
                    typeof require("path").resolve === 'function';
            } catch (e) {}

            /**
             * Constructs a XMLHttpRequest object.
             * @return {XMLHttpRequest}
             * @throws {Error} If XMLHttpRequest is not supported
             * @expose
             */
            Util.XHR = function() {
                // No dependencies please, ref: http://www.quirksmode.org/js/xmlhttp.html
                var XMLHttpFactories = [
                    function () {return new XMLHttpRequest()},
                    function () {return new ActiveXObject("Msxml2.XMLHTTP")},
                    function () {return new ActiveXObject("Msxml3.XMLHTTP")},
                    function () {return new ActiveXObject("Microsoft.XMLHTTP")}
                ];
                /** @type {?XMLHttpRequest} */
                var xhr = null;
                for (var i=0;i<XMLHttpFactories.length;i++) {
                    try { xhr = XMLHttpFactories[i](); }
                    catch (e) { continue; }
                    break;
                }
                if (!xhr)
                    throw Error("XMLHttpRequest is not supported");
                return xhr;
            };

            /**
             * Fetches a resource.
             * @param {string} path Resource path
             * @param {function(?string)=} callback Callback receiving the resource's contents. If omitted the resource will
             *   be fetched synchronously. If the request failed, contents will be null.
             * @return {?string|undefined} Resource contents if callback is omitted (null if the request failed), else undefined.
             * @expose
             */
            Util.fetch = function(path, callback) {
                if (callback && typeof callback != 'function')
                    callback = null;
                if (Util.IS_NODE) {
                    if (callback) {
                        require("fs").readFile(path, function(err, data) {
                            if (err)
                                callback(null);
                            else
                                callback(""+data);
                        });
                    } else
                        try {
                            return require("fs").readFileSync(path);
                        } catch (e) {
                            return null;
                        }
                } else {
                    var xhr = Util.XHR();
                    xhr.open('GET', path, callback ? true : false);
                    // xhr.setRequestHeader('User-Agent', 'XMLHTTP/1.0');
                    xhr.setRequestHeader('Accept', 'text/plain');
                    if (typeof xhr.overrideMimeType === 'function') xhr.overrideMimeType('text/plain');
                    if (callback) {
                        xhr.onreadystatechange = function() {
                            if (xhr.readyState != 4) return;
                            if (/* remote */ xhr.status == 200 || /* local */ (xhr.status == 0 && typeof xhr.responseText === 'string'))
                                callback(xhr.responseText);
                            else
                                callback(null);
                        };
                        if (xhr.readyState == 4)
                            return;
                        xhr.send(null);
                    } else {
                        xhr.send(null);
                        if (/* remote */ xhr.status == 200 || /* local */ (xhr.status == 0 && typeof xhr.responseText === 'string'))
                            return xhr.responseText;
                        return null;
                    }
                }
            };

            /**
             * Tests if an object is an array.
             * @function
             * @param {*} obj Object to test
             * @returns {boolean} true if it is an array, else false
             * @expose
             */
            Util.isArray = Array.isArray || function(obj) {
                return Object.prototype.toString.call(obj) === "[object Array]";
            };

            return Util;
        })();

        /**
         * Language expressions.
         * @exports ProtoBuf.Lang
         * @type {Object.<string,string|RegExp>}
         * @namespace
         * @expose
         */
        ProtoBuf.Lang = {
            OPEN: "{",
            CLOSE: "}",
            OPTOPEN: "[",
            OPTCLOSE: "]",
            OPTEND: ",",
            EQUAL: "=",
            END: ";",
            STRINGOPEN: '"',
            STRINGCLOSE: '"',
            STRINGOPEN_SQ: "'",
            STRINGCLOSE_SQ: "'",
            COPTOPEN: '(',
            COPTCLOSE: ')',
            DELIM: /[\s\{\}=;\[\],'"\(\)]/g,
            // KEYWORD: /^(?:package|option|import|message|enum|extend|service|syntax|extensions|group)$/,
            RULE: /^(?:required|optional|repeated)$/,
            TYPE: /^(?:double|float|int32|uint32|sint32|int64|uint64|sint64|fixed32|sfixed32|fixed64|sfixed64|bool|string|bytes)$/,
            NAME: /^[a-zA-Z_][a-zA-Z_0-9]*$/,
            TYPEDEF: /^[a-zA-Z][a-zA-Z_0-9]*$/,
            TYPEREF: /^(?:\.?[a-zA-Z_][a-zA-Z_0-9]*)+$/,
            FQTYPEREF: /^(?:\.[a-zA-Z][a-zA-Z_0-9]*)+$/,
            NUMBER: /^-?(?:[1-9][0-9]*|0|0x[0-9a-fA-F]+|0[0-7]+|([0-9]*\.[0-9]+([Ee][+-]?[0-9]+)?))$/,
            NUMBER_DEC: /^(?:[1-9][0-9]*|0)$/,
            NUMBER_HEX: /^0x[0-9a-fA-F]+$/,
            NUMBER_OCT: /^0[0-7]+$/,
            NUMBER_FLT: /^[0-9]*\.[0-9]+([Ee][+-]?[0-9]+)?$/,
            ID: /^(?:[1-9][0-9]*|0|0x[0-9a-fA-F]+|0[0-7]+)$/,
            NEGID: /^\-?(?:[1-9][0-9]*|0|0x[0-9a-fA-F]+|0[0-7]+)$/,
            WHITESPACE: /\s/,
            STRING: /['"]([^'"\\]*(\\.[^"\\]*)*)['"]/g,
            BOOL: /^(?:true|false)$/i
        };

        /**
         * @alias ProtoBuf.DotProto
         * @expose
         */
        ProtoBuf.DotProto = (function(ProtoBuf, Lang) {
            "use strict";

            /**
             * Utilities to parse .proto files.
             * @exports ProtoBuf.DotProto
             * @namespace
             */
            var DotProto = {};

            /**
             * Constructs a new Tokenizer.
             * @exports ProtoBuf.DotProto.Tokenizer
             * @class proto tokenizer
             * @param {string} proto Proto to tokenize
             * @constructor
             */
            var Tokenizer = function(proto) {

                /**
                 * Source to parse.
                 * @type {string}
                 * @expose
                 */
                this.source = ""+proto; // In case it's a buffer

                /**
                 * Current index.
                 * @type {number}
                 * @expose
                 */
                this.index = 0;

                /**
                 * Current line.
                 * @type {number}
                 * @expose
                 */
                this.line = 1;

                /**
                 * Stacked values.
                 * @type {Array}
                 * @expose
                 */
                this.stack = [];

                /**
                 * Whether currently reading a string or not.
                 * @type {boolean}
                 * @expose
                 */
                this.readingString = false;

                /**
                 * Whatever character ends the string. Either a single or double quote character.
                 * @type {string}
                 * @expose
                 */
                this.stringEndsWith = Lang.STRINGCLOSE;
            };

            /**
             * Reads a string beginning at the current index.
             * @return {string} The string
             * @throws {Error} If it's not a valid string
             * @private
             */
            Tokenizer.prototype._readString = function() {
                Lang.STRING.lastIndex = this.index-1; // Include the open quote
                var match;
                if ((match = Lang.STRING.exec(this.source)) !== null) {
                    var s = match[1];
                    this.index = Lang.STRING.lastIndex;
                    this.stack.push(this.stringEndsWith);
                    return s;
                }
                throw Error("Illegal string value at line "+this.line+", index "+this.index);
            };

            /**
             * Gets the next token and advances by one.
             * @return {?string} Token or `null` on EOF
             * @throws {Error} If it's not a valid proto file
             * @expose
             */
            Tokenizer.prototype.next = function() {
                if (this.stack.length > 0)
                    return this.stack.shift();
                if (this.index >= this.source.length)
                    return null; // No more tokens
                if (this.readingString) {
                    this.readingString = false;
                    return this._readString();
                }
                var repeat, last;
                do {
                    repeat = false;
                    // Strip white spaces
                    while (Lang.WHITESPACE.test(last = this.source.charAt(this.index))) {
                        this.index++;
                        if (last === "\n")
                            this.line++;
                        if (this.index === this.source.length)
                            return null;
                    }
                    // Strip comments
                    if (this.source.charAt(this.index) === '/') {
                        if (this.source.charAt(++this.index) === '/') { // Single line
                            while (this.source.charAt(this.index) !== "\n") {
                                this.index++;
                                if (this.index == this.source.length)
                                    return null;
                            }
                            this.index++;
                            this.line++;
                            repeat = true;
                        } else if (this.source.charAt(this.index) === '*') { /* Block */
                            last = '';
                            while (last+(last=this.source.charAt(this.index)) !== '*/') {
                                this.index++;
                                if (last === "\n")
                                    this.line++;
                                if (this.index === this.source.length)
                                    return null;
                            }
                            this.index++;
                            repeat = true;
                        } else
                            throw Error("Invalid comment at line "+this.line+": /"+this.source.charAt(this.index)+" ('/' or '*' expected)");
                    }
                } while (repeat);
                if (this.index === this.source.length) return null;

                // Read the next token
                var end = this.index;
                Lang.DELIM.lastIndex = 0;
                var delim = Lang.DELIM.test(this.source.charAt(end));
                if (!delim) {
                    ++end;
                    while(end < this.source.length && !Lang.DELIM.test(this.source.charAt(end)))
                        end++;
                } else
                    ++end;
                var token = this.source.substring(this.index, this.index = end);
                if (token === Lang.STRINGOPEN)
                    this.readingString = true,
                    this.stringEndsWith = Lang.STRINGCLOSE;
                else if (token === Lang.STRINGOPEN_SQ)
                    this.readingString = true,
                    this.stringEndsWith = Lang.STRINGCLOSE_SQ;
                return token;
            };

            /**
             * Peeks for the next token.
             * @return {?string} Token or `null` on EOF
             * @throws {Error} If it's not a valid proto file
             * @expose
             */
            Tokenizer.prototype.peek = function() {
                if (this.stack.length === 0) {
                    var token = this.next();
                    if (token === null)
                        return null;
                    this.stack.push(token);
                }
                return this.stack[0];
            };

            /**
             * Returns a string representation of this object.
             * @return {string} String representation as of "Tokenizer(index/length)"
             * @expose
             */
            Tokenizer.prototype.toString = function() {
                return "Tokenizer("+this.index+"/"+this.source.length+" at line "+this.line+")";
            };

            /**
             * @alias ProtoBuf.DotProto.Tokenizer
             * @expose
             */
            DotProto.Tokenizer = Tokenizer;

            /**
             * Constructs a new Parser.
             * @exports ProtoBuf.DotProto.Parser
             * @class proto parser
             * @param {string} proto Protocol source
             * @constructor
             */
            var Parser = function(proto) {

                /**
                 * Tokenizer.
                 * @type {ProtoBuf.DotProto.Tokenizer}
                 * @expose
                 */
                this.tn = new Tokenizer(proto);
            };

            /**
             * Runs the parser.
             * @return {{package: string|null, messages: Array.<object>, enums: Array.<object>, imports: Array.<string>, options: object<string,*>}}
             * @throws {Error} If the source cannot be parsed
             * @expose
             */
            Parser.prototype.parse = function() {
                var topLevel = {
                    "name": "[ROOT]", // temporary
                    "package": null,
                    "messages": [],
                    "enums": [],
                    "imports": [],
                    "options": {},
                    "services": []
                };
                var token, header = true;
                while(token = this.tn.next()) {
                    switch (token) {
                        case 'package':
                            if (!header || topLevel["package"] !== null)
                                throw Error("Illegal package at line "+this.tn.line);
                            topLevel["package"] = this._parsePackage(token);
                            break;
                        case 'import':
                            if (!header)
                                throw Error("Illegal import at line "+this.tn.line);
                            topLevel.imports.push(this._parseImport(token));
                            break;
                        case 'message':
                            this._parseMessage(topLevel, null, token);
                            header = false;
                            break;
                        case 'enum':
                            this._parseEnum(topLevel, token);
                            header = false;
                            break;
                        case 'option':
                            if (!header)
                                throw Error("Illegal option at line "+this.tn.line);
                            this._parseOption(topLevel, token);
                            break;
                        case 'service':
                            this._parseService(topLevel, token);
                            break;
                        case 'extend':
                            this._parseExtend(topLevel, token);
                            break;
                        case 'syntax':
                            this._parseIgnoredStatement(topLevel, token);
                            break;
                        default:
                            throw Error("Illegal token at line "+this.tn.line+": "+token);
                    }
                }
                delete topLevel["name"];
                return topLevel;
            };

            /**
             * Parses a number value.
             * @param {string} val Number value to parse
             * @return {number} Number
             * @throws {Error} If the number value is invalid
             * @private
             */
            Parser.prototype._parseNumber = function(val) {
                var sign = 1;
                if (val.charAt(0) == '-')
                    sign = -1,
                    val = val.substring(1);
                if (Lang.NUMBER_DEC.test(val))
                    return sign*parseInt(val, 10);
                else if (Lang.NUMBER_HEX.test(val))
                    return sign*parseInt(val.substring(2), 16);
                else if (Lang.NUMBER_OCT.test(val))
                    return sign*parseInt(val.substring(1), 8);
                else if (Lang.NUMBER_FLT.test(val))
                    return sign*parseFloat(val);
                throw Error("Illegal number at line "+this.tn.line+": "+(sign < 0 ? '-' : '')+val);
            };

            /**
             * Parses an ID value.
             * @param {string} val ID value to parse
             * @param {boolean=} neg Whether the ID may be negative, defaults to `false`
             * @returns {number} ID
             * @throws {Error} If the ID value is invalid
             * @private
             */
            Parser.prototype._parseId = function(val, neg) {
                var id = -1;
                var sign = 1;
                if (val.charAt(0) == '-')
                    sign = -1,
                    val = val.substring(1);
                if (Lang.NUMBER_DEC.test(val))
                    id = parseInt(val);
                else if (Lang.NUMBER_HEX.test(val))
                    id = parseInt(val.substring(2), 16);
                else if (Lang.NUMBER_OCT.test(val))
                    id = parseInt(val.substring(1), 8);
                else
                    throw Error("Illegal ID at line "+this.tn.line+": "+(sign < 0 ? '-' : '')+val);
                id = (sign*id)|0; // Force to 32bit
                if (!neg && id < 0)
                    throw Error("Illegal ID at line "+this.tn.line+": "+(sign < 0 ? '-' : '')+val);
                return id;
            };

            /**
             * Parses the package definition.
             * @param {string} token Initial token
             * @return {string} Package name
             * @throws {Error} If the package definition cannot be parsed
             * @private
             */
            Parser.prototype._parsePackage = function(token) {
                token = this.tn.next();
                if (!Lang.TYPEREF.test(token))
                    throw Error("Illegal package at line "+this.tn.line+": "+token);
                var pkg = token;
                token = this.tn.next();
                if (token != Lang.END)
                    throw Error("Illegal end of package at line "+this.tn.line+": "+token+" ('"+Lang.END+"' expected)");
                return pkg;
            };

            /**
             * Parses an import definition.
             * @param {string} token Initial token
             * @return {string} Import file name
             * @throws {Error} If the import definition cannot be parsed
             * @private
             */
            Parser.prototype._parseImport = function(token) {
                token = this.tn.next();
                if (token === "public")
                    token = this.tn.next();
                if (token !== Lang.STRINGOPEN && token !== Lang.STRINGOPEN_SQ)
                    throw Error("Illegal import at line "+this.tn.line+": "+token+" ('"+Lang.STRINGOPEN+"' or '"+Lang.STRINGOPEN_SQ+"' expected)");
                var imported = this.tn.next();
                token = this.tn.next();
                if (token !== this.tn.stringEndsWith)
                    throw Error("Illegal import at line "+this.tn.line+": "+token+" ('"+this.tn.stringEndsWith+"' expected)");
                token = this.tn.next();
                if (token !== Lang.END)
                    throw Error("Illegal import at line "+this.tn.line+": "+token+" ('"+Lang.END+"' expected)");
                return imported;
            };

            /**
             * Parses a namespace option.
             * @param {Object} parent Parent definition
             * @param {string} token Initial token
             * @throws {Error} If the option cannot be parsed
             * @private
             */
            Parser.prototype._parseOption = function(parent, token) {
                token = this.tn.next();
                var custom = false;
                if (token == Lang.COPTOPEN)
                    custom = true,
                    token = this.tn.next();
                if (!Lang.TYPEREF.test(token))
                    // we can allow options of the form google.protobuf.* since they will just get ignored anyways
                    if (!/google\.protobuf\./.test(token))
                        throw Error("Illegal option in message "+parent.name+" at line "+this.tn.line+": "+token);
                var name = token;
                token = this.tn.next();
                if (custom) { // (my_method_option).foo, (my_method_option), some_method_option, (foo.my_option).bar
                    if (token !== Lang.COPTCLOSE)
                        throw Error("Illegal option in message "+parent.name+", option "+name+" at line "+this.tn.line+": "+token+" ('"+Lang.COPTCLOSE+"' expected)");
                    name = '('+name+')';
                    token = this.tn.next();
                    if (Lang.FQTYPEREF.test(token))
                        name += token,
                        token = this.tn.next();
                }
                if (token !== Lang.EQUAL)
                    throw Error("Illegal option operator in message "+parent.name+", option "+name+" at line "+this.tn.line+": "+token+" ('"+Lang.EQUAL+"' expected)");
                var value;
                token = this.tn.next();
                if (token === Lang.STRINGOPEN || token === Lang.STRINGOPEN_SQ) {
                    value = this.tn.next();
                    token = this.tn.next();
                    if (token !== this.tn.stringEndsWith)
                        throw Error("Illegal end of option value in message "+parent.name+", option "+name+" at line "+this.tn.line+": "+token+" ('"+this.tn.stringEndsWith+"' expected)");
                } else {
                    if (Lang.NUMBER.test(token))
                        value = this._parseNumber(token, true);
                    else if (Lang.BOOL.test(token))
                        value = token === 'true';
                    else if (Lang.TYPEREF.test(token))
                        value = token;
                    else
                        throw Error("Illegal option value in message "+parent.name+", option "+name+" at line "+this.tn.line+": "+token);
                }
                token = this.tn.next();
                if (token !== Lang.END)
                    throw Error("Illegal end of option in message "+parent.name+", option "+name+" at line "+this.tn.line+": "+token+" ('"+Lang.END+"' expected)");
                parent["options"][name] = value;
            };

            /**
             * Parses an ignored statement of the form ['keyword', ..., ';'].
             * @param {Object} parent Parent definition
             * @param {string} keyword Initial token
             * @throws {Error} If the directive cannot be parsed
             * @private
             */
            Parser.prototype._parseIgnoredStatement = function(parent, keyword) {
                var token;
                do {
                    token = this.tn.next();
                    if (token === null)
                        throw Error("Unexpected EOF in "+parent.name+", "+keyword+" (ignored) at line "+this.tn.line);
                    if (token === Lang.END)
                        break;
                } while (true);
            };

            /**
             * Parses a service definition.
             * @param {Object} parent Parent definition
             * @param {string} token Initial token
             * @throws {Error} If the service cannot be parsed
             * @private
             */
            Parser.prototype._parseService = function(parent, token) {
                token = this.tn.next();
                if (!Lang.NAME.test(token))
                    throw Error("Illegal service name at line "+this.tn.line+": "+token);
                var name = token;
                var svc = {
                    "name": name,
                    "rpc": {},
                    "options": {}
                };
                token = this.tn.next();
                if (token !== Lang.OPEN)
                    throw Error("Illegal OPEN after service "+name+" at line "+this.tn.line+": "+token+" ('"+Lang.OPEN+"' expected)");
                do {
                    token = this.tn.next();
                    if (token === "option")
                        this._parseOption(svc, token);
                    else if (token === 'rpc')
                        this._parseServiceRPC(svc, token);
                    else if (token !== Lang.CLOSE)
                        throw Error("Illegal type for service "+name+" at line "+this.tn.line+": "+token);
                } while (token !== Lang.CLOSE);
                parent["services"].push(svc);
            };

            /**
             * Parses a RPC service definition of the form ['rpc', name, (request), 'returns', (response)].
             * @param {Object} svc Parent definition
             * @param {string} token Initial token
             * @private
             */
            Parser.prototype._parseServiceRPC = function(svc, token) {
                var type = token;
                token = this.tn.next();
                if (!Lang.NAME.test(token))
                    throw Error("Illegal RPC method name in service "+svc["name"]+" at line "+this.tn.line+": "+token);
                var name = token;
                var method = {
                    "request": null,
                    "response": null,
                    "options": {}
                };
                token = this.tn.next();
                if (token !== Lang.COPTOPEN)
                    throw Error("Illegal start of request type in RPC service "+svc["name"]+"#"+name+" at line "+this.tn.line+": "+token+" ('"+Lang.COPTOPEN+"' expected)");
                token = this.tn.next();
                if (!Lang.TYPEREF.test(token))
                    throw Error("Illegal request type in RPC service "+svc["name"]+"#"+name+" at line "+this.tn.line+": "+token);
                method["request"] = token;
                token = this.tn.next();
                if (token != Lang.COPTCLOSE)
                    throw Error("Illegal end of request type in RPC service "+svc["name"]+"#"+name+" at line "+this.tn.line+": "+token+" ('"+Lang.COPTCLOSE+"' expected)");
                token = this.tn.next();
                if (token.toLowerCase() !== "returns")
                    throw Error("Illegal request/response delimiter in RPC service "+svc["name"]+"#"+name+" at line "+this.tn.line+": "+token+" ('returns' expected)");
                token = this.tn.next();
                if (token != Lang.COPTOPEN)
                    throw Error("Illegal start of response type in RPC service "+svc["name"]+"#"+name+" at line "+this.tn.line+": "+token+" ('"+Lang.COPTOPEN+"' expected)");
                token = this.tn.next();
                method["response"] = token;
                token = this.tn.next();
                if (token !== Lang.COPTCLOSE)
                    throw Error("Illegal end of response type in RPC service "+svc["name"]+"#"+name+" at line "+this.tn.line+": "+token+" ('"+Lang.COPTCLOSE+"' expected)");
                token = this.tn.next();
                if (token === Lang.OPEN) {
                    do {
                        token = this.tn.next();
                        if (token === 'option')
                            this._parseOption(method, token); // <- will fail for the custom-options example
                        else if (token !== Lang.CLOSE)
                            throw Error("Illegal start of option in RPC service "+svc["name"]+"#"+name+" at line "+this.tn.line+": "+token+" ('option' expected)");
                    } while (token !== Lang.CLOSE);
                    if (this.tn.peek() === Lang.END)
                        this.tn.next();
                } else if (token !== Lang.END)
                    throw Error("Illegal method delimiter in RPC service "+svc["name"]+"#"+name+" at line "+this.tn.line+": "+token+" ('"+Lang.END+"' or '"+Lang.OPEN+"' expected)");
                if (typeof svc[type] === 'undefined')
                    svc[type] = {};
                svc[type][name] = method;
            };

            /**
             * Parses a message definition.
             * @param {Object} parent Parent definition
             * @param {Object} fld Field definition if this is a group, otherwise `null`
             * @param {string} token First token
             * @return {Object}
             * @throws {Error} If the message cannot be parsed
             * @private
             */
            Parser.prototype._parseMessage = function(parent, fld, token) {
                /** @dict */
                var msg = {}; // Note: At some point we might want to exclude the parser, so we need a dict.
                var isGroup = token === "group";
                token = this.tn.next();
                if (!Lang.NAME.test(token))
                    throw Error("Illegal "+(isGroup ? "group" : "message")+" name"+(parent ? " in message "+parent["name"] : "")+" at line "+this.tn.line+": "+token);
                msg["name"] = token;
                if (isGroup) {
                    token = this.tn.next();
                    if (token !== Lang.EQUAL)
                        throw Error("Illegal id assignment after group "+msg.name+" at line "+this.tn.line+": "+token+" ('"+Lang.EQUAL+"' expected)");
                    token = this.tn.next();
                    try {
                        fld["id"] = this._parseId(token);
                    } catch (e) {
                        throw Error("Illegal field id value for group "+msg.name+"#"+fld.name+" at line "+this.tn.line+": "+token);
                    }
                    msg["isGroup"] = true;
                }
                msg["fields"] = []; // Note: Using arrays to support also browser that cannot preserve order of object keys.
                msg["enums"] = [];
                msg["messages"] = [];
                msg["options"] = {};
                token = this.tn.next();
                if (token === Lang.OPTOPEN && fld)
                    this._parseFieldOptions(msg, fld, token),
                    token = this.tn.next();
                if (token !== Lang.OPEN)
                    throw Error("Illegal OPEN after "+(isGroup ? "group" : "message")+" "+msg.name+" at line "+this.tn.line+": "+token+" ('"+Lang.OPEN+"' expected)");
                // msg["extensions"] = undefined
                do {
                    token = this.tn.next();
                    if (token === Lang.CLOSE) {
                        token = this.tn.peek();
                        if (token === Lang.END)
                            this.tn.next();
                        break;
                    } else if (Lang.RULE.test(token))
                        this._parseMessageField(msg, token);
                    else if (token === "enum")
                        this._parseEnum(msg, token);
                    else if (token === "message")
                        this._parseMessage(msg, null, token);
                    else if (token === "option")
                        this._parseOption(msg, token);
                    else if (token === "extensions")
                        msg["extensions"] = this._parseExtensions(msg, token);
                    else if (token === "extend")
                        this._parseExtend(msg, token);
                    else
                        throw Error("Illegal token in message "+msg.name+" at line "+this.tn.line+": "+token+" (type or '"+Lang.CLOSE+"' expected)");
                } while (true);
                parent["messages"].push(msg);
                return msg;
            };

            /**
             * Parses a message field.
             * @param {Object} msg Message definition
             * @param {string} token Initial token
             * @throws {Error} If the message field cannot be parsed
             * @private
             */
            Parser.prototype._parseMessageField = function(msg, token) {
                /** @dict */
                var fld = {}, grp = null;
                fld["rule"] = token;
                /** @dict */
                fld["options"] = {};
                token = this.tn.next();
                if (token === "group") {
                    // "A [legacy] group simply combines a nested message type and a field into a single declaration. In your
                    // code, you can treat this message just as if it had a Result type field called result (the latter name is
                    // converted to lower-case so that it does not conflict with the former)."
                    grp = this._parseMessage(msg, fld, token);
                    if (!/^[A-Z]/.test(grp["name"]))
                        throw Error('Group names must start with a capital letter');
                    fld["type"] = grp["name"];
                    fld["name"] = grp["name"].toLowerCase();
                    token = this.tn.peek();
                    if (token === Lang.END)
                        this.tn.next();
                } else {
                    if (!Lang.TYPE.test(token) && !Lang.TYPEREF.test(token))
                        throw Error("Illegal field type in message "+msg.name+" at line "+this.tn.line+": "+token);
                    fld["type"] = token;
                    token = this.tn.next();
                    if (!Lang.NAME.test(token))
                        throw Error("Illegal field name in message "+msg.name+" at line "+this.tn.line+": "+token);
                    fld["name"] = token;
                    token = this.tn.next();
                    if (token !== Lang.EQUAL)
                        throw Error("Illegal field id assignment in message "+msg.name+"#"+fld.name+" at line "+this.tn.line+": "+token+" ('"+Lang.EQUAL+"' expected)");
                    token = this.tn.next();
                    try {
                        fld["id"] = this._parseId(token);
                    } catch (e) {
                        throw Error("Illegal field id value in message "+msg.name+"#"+fld.name+" at line "+this.tn.line+": "+token);
                    }
                    token = this.tn.next();
                    if (token === Lang.OPTOPEN)
                        this._parseFieldOptions(msg, fld, token),
                        token = this.tn.next();
                    if (token !== Lang.END)
                        throw Error("Illegal field delimiter in message "+msg.name+"#"+fld.name+" at line "+this.tn.line+": "+token+" ('"+Lang.END+"' expected)");
                }
                msg["fields"].push(fld);
            };

            /**
             * Parses a set of field option definitions.
             * @param {Object} msg Message definition
             * @param {Object} fld Field definition
             * @param {string} token Initial token
             * @throws {Error} If the message field options cannot be parsed
             * @private
             */
            Parser.prototype._parseFieldOptions = function(msg, fld, token) {
                var first = true;
                do {
                    token = this.tn.next();
                    if (token === Lang.OPTCLOSE)
                        break;
                    else if (token === Lang.OPTEND) {
                        if (first)
                            throw Error("Illegal start of message field options in message "+msg.name+"#"+fld.name+" at line "+this.tn.line+": "+token);
                        token = this.tn.next();
                    }
                    this._parseFieldOption(msg, fld, token);
                    first = false;
                } while (true);
            };

            /**
             * Parses a single field option.
             * @param {Object} msg Message definition
             * @param {Object} fld Field definition
             * @param {string} token Initial token
             * @throws {Error} If the mesage field option cannot be parsed
             * @private
             */
            Parser.prototype._parseFieldOption = function(msg, fld, token) {
                var custom = false;
                if (token === Lang.COPTOPEN)
                    token = this.tn.next(),
                    custom = true;
                if (!Lang.TYPEREF.test(token))
                    throw Error("Illegal field option in message "+msg.name+"#"+fld.name+" at line "+this.tn.line+": "+token);
                var name = token;
                token = this.tn.next();
                if (custom) {
                    if (token !== Lang.COPTCLOSE)
                        throw Error("Illegal custom field option name delimiter in message "+msg.name+"#"+fld.name+" at line "+this.tn.line+": "+token+" (')' expected)");
                    name = '('+name+')';
                    token = this.tn.next();
                    if (Lang.FQTYPEREF.test(token))
                        name += token,
                        token = this.tn.next();
                }
                if (token !== Lang.EQUAL)
                    throw Error("Illegal field option operation in message "+msg.name+"#"+fld.name+" at line "+this.tn.line+": "+token+" ('=' expected)");
                var value;
                token = this.tn.next();
                if (token === Lang.STRINGOPEN || token === Lang.STRINGOPEN_SQ) {
                    value = this.tn.next();
                    token = this.tn.next();
                    if (token != this.tn.stringEndsWith)
                        throw Error("Illegal end of field value in message "+msg.name+"#"+fld.name+", option "+name+" at line "+this.tn.line+": "+token+" ('"+this.tn.stringEndsWith+"' expected)");
                } else if (Lang.NUMBER.test(token, true))
                    value = this._parseNumber(token, true);
                else if (Lang.BOOL.test(token))
                    value = token.toLowerCase() === 'true';
                else if (Lang.TYPEREF.test(token))
                    value = token; // TODO: Resolve?
                else
                    throw Error("Illegal field option value in message "+msg.name+"#"+fld.name+", option "+name+" at line "+this.tn.line+": "+token);
                fld["options"][name] = value;
            };

            /**
             * Parses an enum.
             * @param {Object} msg Message definition
             * @param {string} token Initial token
             * @throws {Error} If the enum cannot be parsed
             * @private
             */
            Parser.prototype._parseEnum = function(msg, token) {
                /** @dict */
                var enm = {};
                token = this.tn.next();
                if (!Lang.NAME.test(token))
                    throw Error("Illegal enum name in message "+msg.name+" at line "+this.tn.line+": "+token);
                enm["name"] = token;
                token = this.tn.next();
                if (token !== Lang.OPEN)
                    throw Error("Illegal OPEN after enum "+enm.name+" at line "+this.tn.line+": "+token);
                enm["values"] = [];
                enm["options"] = {};
                do {
                    token = this.tn.next();
                    if (token === Lang.CLOSE) {
                        token = this.tn.peek();
                        if (token === Lang.END)
                            this.tn.next();
                        break;
                    }
                    if (token == 'option')
                        this._parseOption(enm, token);
                    else {
                        if (!Lang.NAME.test(token))
                            throw Error("Illegal enum value name in enum "+enm.name+" at line "+this.tn.line+": "+token);
                        this._parseEnumValue(enm, token);
                    }
                } while (true);
                msg["enums"].push(enm);
            };

            /**
             * Parses an enum value.
             * @param {Object} enm Enum definition
             * @param {string} token Initial token
             * @throws {Error} If the enum value cannot be parsed
             * @private
             */
            Parser.prototype._parseEnumValue = function(enm, token) {
                /** @dict */
                var val = {};
                val["name"] = token;
                token = this.tn.next();
                if (token !== Lang.EQUAL)
                    throw Error("Illegal enum value operator in enum "+enm.name+" at line "+this.tn.line+": "+token+" ('"+Lang.EQUAL+"' expected)");
                token = this.tn.next();
                try {
                    val["id"] = this._parseId(token, true);
                } catch (e) {
                    throw Error("Illegal enum value id in enum "+enm.name+" at line "+this.tn.line+": "+token);
                }
                enm["values"].push(val);
                token = this.tn.next();
                if (token === Lang.OPTOPEN) {
                    var opt = { 'options' : {} }; // TODO: Actually expose them somehow.
                    this._parseFieldOptions(enm, opt, token);
                    token = this.tn.next();
                }
                if (token !== Lang.END)
                    throw Error("Illegal enum value delimiter in enum "+enm.name+" at line "+this.tn.line+": "+token+" ('"+Lang.END+"' expected)");
            };

            /**
             * Parses an extensions statement.
             * @param {Object} msg Message object
             * @param {string} token Initial token
             * @throws {Error} If the extensions statement cannot be parsed
             * @private
             */
            Parser.prototype._parseExtensions = function(msg, token) {
                /** @type {Array.<number>} */
                var range = [];
                token = this.tn.next();
                if (token === "min") // FIXME: Does the official implementation support this?
                    range.push(ProtoBuf.ID_MIN);
                else if (token === "max")
                    range.push(ProtoBuf.ID_MAX);
                else
                    range.push(this._parseNumber(token));
                token = this.tn.next();
                if (token !== 'to')
                    throw Error("Illegal extensions delimiter in message "+msg.name+" at line "+this.tn.line+" ('to' expected)");
                token = this.tn.next();
                if (token === "min")
                    range.push(ProtoBuf.ID_MIN);
                else if (token === "max")
                    range.push(ProtoBuf.ID_MAX);
                else
                    range.push(this._parseNumber(token));
                token = this.tn.next();
                if (token !== Lang.END)
                    throw Error("Illegal extension delimiter in message "+msg.name+" at line "+this.tn.line+": "+token+" ('"+Lang.END+"' expected)");
                return range;
            };

            /**
             * Parses an extend block.
             * @param {Object} parent Parent object
             * @param {string} token Initial token
             * @throws {Error} If the extend block cannot be parsed
             * @private
             */
            Parser.prototype._parseExtend = function(parent, token) {
                token = this.tn.next();
                if (!Lang.TYPEREF.test(token))
                    throw Error("Illegal extended message name at line "+this.tn.line+": "+token);
                /** @dict */
                var ext = {};
                ext["ref"] = token;
                ext["fields"] = [];
                token = this.tn.next();
                if (token !== Lang.OPEN)
                    throw Error("Illegal OPEN in extend "+ext.name+" at line "+this.tn.line+": "+token+" ('"+Lang.OPEN+"' expected)");
                do {
                    token = this.tn.next();
                    if (token === Lang.CLOSE) {
                        token = this.tn.peek();
                        if (token == Lang.END)
                            this.tn.next();
                        break;
                    } else if (Lang.RULE.test(token))
                        this._parseMessageField(ext, token);
                    else
                        throw Error("Illegal token in extend "+ext.name+" at line "+this.tn.line+": "+token+" (rule or '"+Lang.CLOSE+"' expected)");
                } while (true);
                parent["messages"].push(ext);
                return ext;
            };

            /**
             * Returns a string representation of this object.
             * @returns {string} String representation as of "Parser"
             */
            Parser.prototype.toString = function() {
                return "Parser";
            };

            /**
             * @alias ProtoBuf.DotProto.Parser
             * @expose
             */
            DotProto.Parser = Parser;

            return DotProto;

        })(ProtoBuf, ProtoBuf.Lang);

        /**
         * @alias ProtoBuf.Reflect
         * @expose
         */
        ProtoBuf.Reflect = (function(ProtoBuf) {
            "use strict";

            /**
             * Reflection types.
             * @exports ProtoBuf.Reflect
             * @namespace
             */
            var Reflect = {};

            /**
             * Constructs a Reflect base class.
             * @exports ProtoBuf.Reflect.T
             * @constructor
             * @abstract
             * @param {ProtoBuf.Reflect.T} parent Parent object
             * @param {string} name Object name
             */
            var T = function(parent, name) {

                /**
                 * Parent object.
                 * @type {ProtoBuf.Reflect.T|null}
                 * @expose
                 */
                this.parent = parent;

                /**
                 * Object name in namespace.
                 * @type {string}
                 * @expose
                 */
                this.name = name;

                /**
                 * Fully qualified class name
                 * @type {string}
                 * @expose
                 */
                this.className;
            };

            /**
             * Returns the fully qualified name of this object.
             * @returns {string} Fully qualified name as of ".PATH.TO.THIS"
             * @expose
             */
            T.prototype.fqn = function() {
                var name = this.name,
                    ptr = this;
                do {
                    ptr = ptr.parent;
                    if (ptr == null)
                        break;
                    name = ptr.name+"."+name;
                } while (true);
                return name;
            };

            /**
             * Returns a string representation of this Reflect object (its fully qualified name).
             * @param {boolean=} includeClass Set to true to include the class name. Defaults to false.
             * @return String representation
             * @expose
             */
            T.prototype.toString = function(includeClass) {
                return (includeClass ? this.className + " " : "") + this.fqn();
            };

            /**
             * Builds this type.
             * @throws {Error} If this type cannot be built directly
             * @expose
             */
            T.prototype.build = function() {
                throw Error(this.toString(true)+" cannot be built directly");
            };

            /**
             * @alias ProtoBuf.Reflect.T
             * @expose
             */
            Reflect.T = T;

            /**
             * Constructs a new Namespace.
             * @exports ProtoBuf.Reflect.Namespace
             * @param {ProtoBuf.Reflect.Namespace|null} parent Namespace parent
             * @param {string} name Namespace name
             * @param {Object.<string,*>} options Namespace options
             * @constructor
             * @extends ProtoBuf.Reflect.T
             */
            var Namespace = function(parent, name, options) {
                T.call(this, parent, name);

                /**
                 * @override
                 */
                this.className = "Namespace";

                /**
                 * Children inside the namespace.
                 * @type {Array.<ProtoBuf.Reflect.T>}
                 */
                this.children = [];

                /**
                 * Options.
                 * @type {Object.<string, *>}
                 */
                this.options = options || {};
            };

            // Extends T
            Namespace.prototype = Object.create(T.prototype);

            /**
             * Returns an array of the namespace's children.
             * @param {ProtoBuf.Reflect.T=} type Filter type (returns instances of this type only). Defaults to null (all children).
             * @return {Array.<ProtoBuf.Reflect.T>}
             * @expose
             */
            Namespace.prototype.getChildren = function(type) {
                type = type || null;
                if (type == null)
                    return this.children.slice();
                var children = [];
                for (var i=0, k=this.children.length; i<k; ++i)
                    if (this.children[i] instanceof type)
                        // We also need to distinguish between Field and ExtensionField which is an instance of Field
                        if (type !== Message.Field || !(this.children[i] instanceof Message.ExtensionField))
                            children.push(this.children[i]);
                return children;
            };

            /**
             * Adds a child to the namespace.
             * @param {ProtoBuf.Reflect.T} child Child
             * @throws {Error} If the child cannot be added (duplicate)
             * @expose
             */
            Namespace.prototype.addChild = function(child) {
                var other;
                if (other = this.getChild(child.name)) {
                    // Try to revert camelcase transformation on collision
                    if (other instanceof Message.Field && other.name !== other.originalName && !this.hasChild(other.originalName))
                        other.name = other.originalName; // Revert previous first (effectively keeps both originals)
                    else if (child instanceof Message.Field && child.name !== child.originalName && !this.hasChild(child.originalName))
                        child.name = child.originalName;
                    else
                        throw Error("Duplicate name in namespace "+this.toString(true)+": "+child.name);
                }
                this.children.push(child);
            };

            /**
             * Tests if this namespace has a child with the specified name.
             * @param {string|number} nameOrId Child name or id
             * @returns {boolean} true if there is one, else false
             * @expose
             */
            Namespace.prototype.hasChild = function(nameOrId) {
                return this._indexOf(nameOrId) > -1;
            };

            /**
             * Gets a child by its name.
             * @param {string|number} nameOrId Child name or id
             * @return {?ProtoBuf.Reflect.T} The child or null if not found
             * @expose
             */
            Namespace.prototype.getChild = function(nameOrId) {
                var index = this._indexOf(nameOrId);
                return index > -1 ? this.children[index] : null;
            };

            /**
             * Returns child index by its name or id.
             * @param {string|number} nameOrId Child name or id
             * @return {Number} The child index
             * @private
             */
            Namespace.prototype._indexOf = function(nameOrId) {
                var key = typeof nameOrId === 'number' ? 'id' : 'name';
                for (var i=0; i<this.children.length; i++)
                    if (typeof this.children[i][key] !== 'undefined' && this.children[i][key] == nameOrId)
                        return i;
                return -1;
            };

            /**
             * Resolves a reflect object inside of this namespace.
             * @param {string} qn Qualified name to resolve
             * @param {boolean=} excludeFields Excludes fields, defaults to `false`
             * @return {ProtoBuf.Reflect.Namespace|null} The resolved type or null if not found
             * @expose
             */
            Namespace.prototype.resolve = function(qn, excludeFields) {
                var part = qn.split(".");
                var ptr = this, i=0;
                if (part[i] == "") { // Fully qualified name, e.g. ".My.Message'
                    while (ptr.parent != null)
                        ptr = ptr.parent;
                    i++;
                }
                var child;
                do {
                    do {
                        child = ptr.getChild(part[i]);
                        if (!child || !(child instanceof Reflect.T) || (excludeFields && child instanceof Reflect.Message.Field)) {
                            ptr = null;
                            break;
                        }
                        ptr = child; i++;
                    } while (i < part.length);
                    if (ptr != null)
                        break; // Found
                    // Else search the parent
                    if (this.parent !== null) {
                        return this.parent.resolve(qn, excludeFields);
                    }
                } while (ptr != null);
                return ptr;
            };

            /**
             * Builds the namespace and returns the runtime counterpart.
             * @return {Object.<string,Function|Object>} Runtime namespace
             * @expose
             */
            Namespace.prototype.build = function() {
                /** @dict */
                var ns = {};
                var children = this.getChildren(), child;
                for (var i=0, k=children.length; i<k; ++i) {
                    child = children[i];
                    if (child instanceof Namespace)
                        ns[child.name] = child.build();
                }
                if (Object.defineProperty)
                    Object.defineProperty(ns, "$options", { "value": this.buildOpt() });
                return ns;
            };

            /**
             * Builds the namespace's '$options' property.
             * @return {Object.<string,*>}
             */
            Namespace.prototype.buildOpt = function() {
                var opt = {};
                var keys = Object.keys(this.options);
                for (var i=0; i<keys.length; i++) {
                    var key = keys[i],
                        val = this.options[keys[i]];
                    // TODO: Options are not resolved, yet.
                    // if (val instanceof Namespace) {
                    //     opt[key] = val.build();
                    // } else {
                    opt[key] = val;
                    // }
                }
                return opt;
            };

            /**
             * Gets the value assigned to the option with the specified name.
             * @param {string=} name Returns the option value if specified, otherwise all options are returned.
             * @return {*|Object.<string,*>}null} Option value or NULL if there is no such option
             */
            Namespace.prototype.getOption = function(name) {
                if (typeof name === 'undefined')
                    return this.options;
                return typeof this.options[name] !== 'undefined' ? this.options[name] : null;
            };

            /**
             * @alias ProtoBuf.Reflect.Namespace
             * @expose
             */
            Reflect.Namespace = Namespace;

            /**
             * Constructs a new Message.
             * @exports ProtoBuf.Reflect.Message
             * @param {ProtoBuf.Reflect.Namespace} parent Parent message or namespace
             * @param {string} name Message name
             * @param {Object.<string,*>} options Message options
             * @param {boolean=} isGroup `true` if this is a legacy group
             * @constructor
             * @extends ProtoBuf.Reflect.Namespace
             */
            var Message = function(parent, name, options, isGroup) {
                Namespace.call(this, parent, name, options);

                /**
                 * @override
                 */
                this.className = "Message";

                /**
                 * Extensions range.
                 * @type {!Array.<number>}
                 * @expose
                 */
                this.extensions = [ProtoBuf.ID_MIN, ProtoBuf.ID_MAX];

                /**
                 * Runtime message class.
                 * @type {?function(new:ProtoBuf.Builder.Message)}
                 * @expose
                 */
                this.clazz = null;

                /**
                 * Whether this is a legacy group or not.
                 * @type {boolean}
                 * @expose
                 */
                this.isGroup = !!isGroup;
            };

            // Extends Namespace
            Message.prototype = Object.create(Namespace.prototype);

            /**
             * Builds the message and returns the runtime counterpart, which is a fully functional class.
             * @see ProtoBuf.Builder.Message
             * @param {boolean=} rebuild Whether to rebuild or not, defaults to false
             * @return {ProtoBuf.Reflect.Message} Message class
             * @throws {Error} If the message cannot be built
             * @expose
             */
            Message.prototype.build = function(rebuild) {
                if (this.clazz && !rebuild) return this.clazz;

                // We need to create a prototyped Message class in an isolated scope
                var clazz = (function(ProtoBuf, T) {

                    var fields = T.getChildren(ProtoBuf.Reflect.Message.Field);

                    /**
                     * Constructs a new runtime Message.
                     * @name ProtoBuf.Builder.Message
                     * @class Barebone of all runtime messages.
                     * @param {Object.<string,*>|...[string]} values Preset values
                     * @constructor
                     * @throws {Error} If the message cannot be created
                     */
                    var Message = function(values) {
                        ProtoBuf.Builder.Message.call(this);
                        var i, field;

                        // Create fields on the object itself to allow setting and getting through Message#fieldname
                        for (i=0; i<fields.length; i++) {
                            field = fields[i];
                            this[field.name] = (field.repeated) ? [] : null;
                        }
                        // Set the default values
                        for (i=0; i<fields.length; i++) {
                            field = fields[i];
                            if (typeof field.options['default'] != 'undefined') {
                                try {
                                    this.$set(field.name, field.options['default']); // Should not throw
                                } catch (e) {
                                    throw Error("[INTERNAL] "+e);
                                }
                            }
                        }
                        // Set field values from a values object
                        if (arguments.length == 1 && typeof values == 'object' &&
                            /* not another Message */ typeof values.encode != 'function' &&
                            /* not a repeated field */ !ProtoBuf.Util.isArray(values) &&
                            /* not a ByteBuffer */ !(values instanceof ByteBuffer) &&
                            /* not an ArrayBuffer */ !(values instanceof ArrayBuffer) &&
                            /* not a Long */ !(ProtoBuf.Long && values instanceof ProtoBuf.Long)) {
                            var keys = Object.keys(values);
                            for (i=0; i<keys.length; i++)
                                this.$set(keys[i], values[keys[i]]); // May throw
                            // Else set field values from arguments, in correct order
                        } else
                            for (i=0; i<arguments.length; i++)
                                if (i<fields.length)
                                    this.$set(fields[i].name, arguments[i]); // May throw
                    };

                    // Extends ProtoBuf.Builder.Message
                    Message.prototype = Object.create(ProtoBuf.Builder.Message.prototype);

                    /**
                     * Adds a value to a repeated field.
                     * @name ProtoBuf.Builder.Message#add
                     * @function
                     * @param {string} key Field name
                     * @param {*} value Value to add
                     * @param {boolean=} noAssert Whether to assert the value or not (asserts by default)
                     * @throws {Error} If the value cannot be added
                     * @expose
                     */
                    Message.prototype.add = function(key, value, noAssert) {
                        var field = T.getChild(key);
                        if (!field)
                            throw Error(this+"#"+key+" is undefined");
                        if (!(field instanceof ProtoBuf.Reflect.Message.Field))
                            throw Error(this+"#"+key+" is not a field: "+field.toString(true)); // May throw if it's an enum or embedded message
                        if (!field.repeated)
                            throw Error(this+"#"+key+" is not a repeated field");
                        if (this[field.name] === null)
                            this[field.name] = [];
                        this[field.name].push(noAssert ? value : field.verifyValue(value, true));
                    };

                    /**
                     * Adds a value to a repeated field. This is an alias for {@link ProtoBuf.Builder.Message#add}.
                     * @name ProtoBuf.Builder.Message#$add
                     * @function
                     * @param {string} key Field name
                     * @param {*} value Value to add
                     * @param {boolean=} noAssert Whether to assert the value or not (asserts by default)
                     * @throws {Error} If the value cannot be added
                     * @expose
                     */
                    Message.prototype.$add = Message.prototype.add;

                    /**
                     * Sets a field's value.
                     * @name ProtoBuf.Builder.Message#set
                     * @function
                     * @param {string} key Key
                     * @param {*} value Value to set
                     * @param {boolean=} noAssert Whether to assert the value or not (asserts by default)
                     * @throws {Error} If the value cannot be set
                     * @expose
                     */
                    Message.prototype.set = function(key, value, noAssert) {
                        var field = T.getChild(key);
                        if (!field)
                            throw Error(this+"#"+key+" is not a field: undefined");
                        if (!(field instanceof ProtoBuf.Reflect.Message.Field))
                            throw Error(this+"#"+key+" is not a field: "+field.toString(true));
                        this[field.name] = noAssert ? value : field.verifyValue(value); // May throw
                    };

                    /**
                     * Sets a field's value. This is an alias for [@link ProtoBuf.Builder.Message#set}.
                     * @name ProtoBuf.Builder.Message#$set
                     * @function
                     * @param {string} key Key
                     * @param {*} value Value to set
                     * @param {boolean=} noAssert Whether to assert the value or not (asserts by default)
                     * @throws {Error} If the value cannot be set
                     * @expose
                     */
                    Message.prototype.$set = Message.prototype.set;

                    /**
                     * Gets a field's value.
                     * @name ProtoBuf.Builder.Message#get
                     * @function
                     * @param {string} key Key
                     * @return {*} Value
                     * @throws {Error} If there is no such field
                     * @expose
                     */
                    Message.prototype.get = function(key) {
                        var field = T.getChild(key);
                        if (!field || !(field instanceof ProtoBuf.Reflect.Message.Field))
                            throw Error(this+"#"+key+" is not a field: undefined");
                        if (!(field instanceof ProtoBuf.Reflect.Message.Field))
                            throw Error(this+"#"+key+" is not a field: "+field.toString(true));
                        return this[field.name];
                    };

                    /**
                     * Gets a field's value. This is an alias for {@link ProtoBuf.Builder.Message#$get}.
                     * @name ProtoBuf.Builder.Message#$get
                     * @function
                     * @param {string} key Key
                     * @return {*} Value
                     * @throws {Error} If there is no such field
                     * @expose
                     */
                    Message.prototype.$get = Message.prototype.get;

                    // Getters and setters

                    for (var i=0; i<fields.length; i++) {
                        var field = fields[i];

                        (function(field) {
                            // set/get[SomeValue]
                            var Name = field.originalName.replace(/(_[a-zA-Z])/g, function(match) {
                                return match.toUpperCase().replace('_','');
                            });
                            Name = Name.substring(0,1).toUpperCase()+Name.substring(1);

                            // set/get_[some_value]
                            var name = field.originalName.replace(/([A-Z])/g, function(match) {
                                return "_"+match;
                            });

                            /**
                             * Sets a value. This method is present for each field, but only if there is no name conflict with
                             * another field.
                             * @name ProtoBuf.Builder.Message#set[SomeField]
                             * @function
                             * @param {*} value Value to set
                             * @abstract
                             * @throws {Error} If the value cannot be set
                             */
                            if (!T.hasChild("set"+Name))
                                Message.prototype["set"+Name] = function(value) {
                                    this.$set(field.name, value);
                                };

                            /**
                             * Sets a value. This method is present for each field, but only if there is no name conflict with
                             * another field.
                             * @name ProtoBuf.Builder.Message#set_[some_field]
                             * @function
                             * @param {*} value Value to set
                             * @abstract
                             * @throws {Error} If the value cannot be set
                             */
                            if (!T.hasChild("set_"+name))
                                Message.prototype["set_"+name] = function(value) {
                                    this.$set(field.name, value);
                                };

                            /**
                             * Gets a value. This method is present for each field, but only if there is no name conflict with
                             * another field.
                             * @name ProtoBuf.Builder.Message#get[SomeField]
                             * @function
                             * @abstract
                             * @return {*} The value
                             */
                            if (!T.hasChild("get"+Name))
                                Message.prototype["get"+Name] = function() {
                                    return this.$get(field.name); // Does not throw, field exists
                                }

                            /**
                             * Gets a value. This method is present for each field, but only if there is no name conflict with
                             * another field.
                             * @name ProtoBuf.Builder.Message#get_[some_field]
                             * @function
                             * @return {*} The value
                             * @abstract
                             */
                            if (!T.hasChild("get_"+name))
                                Message.prototype["get_"+name] = function() {
                                    return this.$get(field.name); // Does not throw, field exists
                                };

                        })(field);
                    }

                    // En-/decoding

                    /**
                     * Encodes the message.
                     * @name ProtoBuf.Builder.Message#$encode
                     * @function
                     * @param {(!ByteBuffer|boolean)=} buffer ByteBuffer to encode to. Will create a new one and flip it if omitted.
                     * @return {!ByteBuffer} Encoded message as a ByteBuffer
                     * @throws {Error} If the message cannot be encoded or if required fields are missing. The later still
                     *  returns the encoded ByteBuffer in the `encoded` property on the error.
                     * @expose
                     * @see ProtoBuf.Builder.Message#encode64
                     * @see ProtoBuf.Builder.Message#encodeHex
                     * @see ProtoBuf.Builder.Message#encodeAB
                     */
                    Message.prototype.encode = function(buffer) {
                        var isNew = false;
                        if (!buffer)
                            buffer = new ByteBuffer(), isNew = true;
                        var le = buffer.littleEndian;
                        try {
                            T.encode(this, buffer.LE());
                            return (isNew ? buffer.flip() : buffer).LE(le);
                        } catch (e) {
                            buffer.LE(le);
                            throw(e);
                        }
                    };

                    /**
                     * Calculates the byte length of the message.
                     * @name ProtoBuf.Builder.Message#calculate
                     * @function
                     * @returns {number} Byte length
                     * @throws {Error} If the message cannot be calculated or if required fields are missing.
                     * @expose
                     */
                    Message.prototype.calculate = function() {
                        return T.calculate(this);
                    };

                    /**
                     * Encodes the varint32 length-delimited message.
                     * @name ProtoBuf.Builder.Message#encodeDelimited
                     * @function
                     * @param {(!ByteBuffer|boolean)=} buffer ByteBuffer to encode to. Will create a new one and flip it if omitted.
                     * @return {!ByteBuffer} Encoded message as a ByteBuffer
                     * @throws {Error} If the message cannot be encoded or if required fields are missing. The later still
                     *  returns the encoded ByteBuffer in the `encoded` property on the error.
                     * @expose
                     */
                    Message.prototype.encodeDelimited = function(buffer) {
                        var isNew = false;
                        if (!buffer)
                            buffer = new ByteBuffer(), isNew = true;
                        var enc = new ByteBuffer().LE();
                        T.encode(this, enc).flip();
                        buffer.writeVarint32(enc.remaining());
                        buffer.append(enc);
                        return isNew ? buffer.flip() : buffer;
                    };

                    /**
                     * Directly encodes the message to an ArrayBuffer.
                     * @name ProtoBuf.Builder.Message#encodeAB
                     * @function
                     * @return {ArrayBuffer} Encoded message as ArrayBuffer
                     * @throws {Error} If the message cannot be encoded or if required fields are missing. The later still
                     *  returns the encoded ArrayBuffer in the `encoded` property on the error.
                     * @expose
                     */
                    Message.prototype.encodeAB = function() {
                        try {
                            return this.encode().toArrayBuffer();
                        } catch (e) {
                            if (e["encoded"]) e["encoded"] = e["encoded"].toArrayBuffer();
                            throw(e);
                        }
                    };

                    /**
                     * Returns the message as an ArrayBuffer. This is an alias for {@link ProtoBuf.Builder.Message#encodeAB}.
                     * @name ProtoBuf.Builder.Message#toArrayBuffer
                     * @function
                     * @return {ArrayBuffer} Encoded message as ArrayBuffer
                     * @throws {Error} If the message cannot be encoded or if required fields are missing. The later still
                     *  returns the encoded ArrayBuffer in the `encoded` property on the error.
                     * @expose
                     */
                    Message.prototype.toArrayBuffer = Message.prototype.encodeAB;

                    /**
                     * Directly encodes the message to a node Buffer.
                     * @name ProtoBuf.Builder.Message#encodeNB
                     * @function
                     * @return {!Buffer}
                     * @throws {Error} If the message cannot be encoded, not running under node.js or if required fields are
                     *  missing. The later still returns the encoded node Buffer in the `encoded` property on the error.
                     * @expose
                     */
                    Message.prototype.encodeNB = function() {
                        try {
                            return this.encode().toBuffer();
                        } catch (e) {
                            if (e["encoded"]) e["encoded"] = e["encoded"].toBuffer();
                            throw(e);
                        }
                    };

                    /**
                     * Returns the message as a node Buffer. This is an alias for {@link ProtoBuf.Builder.Message#encodeNB}.
                     * @name ProtoBuf.Builder.Message#toBuffer
                     * @function
                     * @return {!Buffer}
                     * @throws {Error} If the message cannot be encoded or if required fields are missing. The later still
                     *  returns the encoded node Buffer in the `encoded` property on the error.
                     * @expose
                     */
                    Message.prototype.toBuffer = Message.prototype.encodeNB;

                    /**
                     * Directly encodes the message to a base64 encoded string.
                     * @name ProtoBuf.Builder.Message#encode64
                     * @function
                     * @return {string} Base64 encoded string
                     * @throws {Error} If the underlying buffer cannot be encoded or if required fields are missing. The later
                     *  still returns the encoded base64 string in the `encoded` property on the error.
                     * @expose
                     */
                    Message.prototype.encode64 = function() {
                        try {
                            return this.encode().toBase64();
                        } catch (e) {
                            if (e["encoded"]) e["encoded"] = e["encoded"].toBase64();
                            throw(e);
                        }
                    };

                    /**
                     * Returns the message as a base64 encoded string. This is an alias for {@link ProtoBuf.Builder.Message#encode64}.
                     * @name ProtoBuf.Builder.Message#toBase64
                     * @function
                     * @return {string} Base64 encoded string
                     * @throws {Error} If the message cannot be encoded or if required fields are missing. The later still
                     *  returns the encoded base64 string in the `encoded` property on the error.
                     * @expose
                     */
                    Message.prototype.toBase64 = Message.prototype.encode64;

                    /**
                     * Directly encodes the message to a hex encoded string.
                     * @name ProtoBuf.Builder.Message#encodeHex
                     * @function
                     * @return {string} Hex encoded string
                     * @throws {Error} If the underlying buffer cannot be encoded or if required fields are missing. The later
                     *  still returns the encoded hex string in the `encoded` property on the error.
                     * @expose
                     */
                    Message.prototype.encodeHex = function() {
                        try {
                            return this.encode().toHex();
                        } catch (e) {
                            if (e["encoded"]) e["encoded"] = e["encoded"].toHex();
                            throw(e);
                        }
                    };

                    /**
                     * Returns the message as a hex encoded string. This is an alias for {@link ProtoBuf.Builder.Message#encodeHex}.
                     * @name ProtoBuf.Builder.Message#toHex
                     * @function
                     * @return {string} Hex encoded string
                     * @throws {Error} If the message cannot be encoded or if required fields are missing. The later still
                     *  returns the encoded hex string in the `encoded` property on the error.
                     * @expose
                     */
                    Message.prototype.toHex = Message.prototype.encodeHex;

                    /**
                     * Clones a message object to a raw object.
                     * @param {*} obj Object to clone
                     * @param {boolean} includeBuffers Whether to include native buffer data or not
                     * @returns {*} Cloned object
                     * @inner
                     */
                    function cloneRaw(obj, includeBuffers) {
                        var clone = {};
                        for (var i in obj)
                            if (obj.hasOwnProperty(i)) {
                                if (obj[i] === null || typeof obj[i] !== 'object')
                                    clone[i] = obj[i];
                                else if (obj[i] instanceof ByteBuffer) {
                                    if (includeBuffers)
                                        clone[i] = obj.toBuffer();
                                } else // is a non-null object
                                    clone[i] = cloneRaw(obj[i], includeBuffers);
                            }
                        return clone;
                    }

                    /**
                     * Returns the message's raw payload.
                     * @param {boolean=} includeBuffers Whether to include native buffer data or not, defaults to `false`
                     * @returns {Object.<string,*>} Raw payload
                     * @expose
                     */
                    Message.prototype.toRaw = function(includeBuffers) {
                        return cloneRaw(this, !!includeBuffers);
                    };

                    /**
                     * Decodes a message from the specified buffer or string.
                     * @name ProtoBuf.Builder.Message.decode
                     * @function
                     * @param {!ByteBuffer|!ArrayBuffer|!Buffer|string} buffer Buffer to decode from
                     * @param {string=} enc Encoding if buffer is a string: hex, utf8 (not recommended), defaults to base64
                     * @return {!ProtoBuf.Builder.Message} Decoded message
                     * @throws {Error} If the message cannot be decoded or if required fields are missing. The later still
                     *  returns the decoded message with missing fields in the `decoded` property on the error.
                     * @expose
                     * @see ProtoBuf.Builder.Message.decode64
                     * @see ProtoBuf.Builder.Message.decodeHex
                     */
                    Message.decode = function(buffer, enc) {
                        if (typeof buffer === 'string')
                            buffer = ByteBuffer.wrap(buffer, enc ? enc : "base64");
                        buffer = buffer instanceof ByteBuffer ? buffer : ByteBuffer.wrap(buffer); // May throw
                        var le = buffer.littleEndian;
                        try {
                            var msg = T.decode(buffer.LE());
                            buffer.LE(le);
                            return msg;
                        } catch (e) {
                            buffer.LE(le);
                            throw(e);
                        }
                    };

                    /**
                     * Decodes a varint32 length-delimited message from the specified buffer or string.
                     * @name ProtoBuf.Builder.Message.decodeDelimited
                     * @function
                     * @param {!ByteBuffer|!ArrayBuffer|!Buffer|string} buffer Buffer to decode from
                     * @param {string=} enc Encoding if buffer is a string: hex, utf8 (not recommended), defaults to base64
                     * @return {ProtoBuf.Builder.Message} Decoded message or `null` if not enough bytes are available yet
                     * @throws {Error} If the message cannot be decoded or if required fields are missing. The later still
                     *  returns the decoded message with missing fields in the `decoded` property on the error.
                     * @expose
                     */
                    Message.decodeDelimited = function(buffer, enc) {
                        if (typeof buffer === 'string')
                            buffer = ByteBuffer.wrap(buffer, enc ? enc : "base64");
                        buffer = buffer instanceof ByteBuffer ? buffer : ByteBuffer.wrap(buffer); // May throw
                        if (buffer.remaining() < 1)
                            return null;
                        var off = buffer.offset,
                            len = buffer.readVarint32();
                        if (buffer.remaining() < len) {
                            buffer.offset = off;
                            return null;
                        }
                        try {
                            var msg = T.decode(buffer.slice(buffer.offset, buffer.offset + len).LE());
                            buffer.offset += len;
                            return msg;
                        } catch (err) {
                            buffer.offset += len;
                            throw err;
                        }
                    };

                    /**
                     * Decodes the message from the specified base64 encoded string.
                     * @name ProtoBuf.Builder.Message.decode64
                     * @function
                     * @param {string} str String to decode from
                     * @return {!ProtoBuf.Builder.Message} Decoded message
                     * @throws {Error} If the message cannot be decoded or if required fields are missing. The later still
                     *  returns the decoded message with missing fields in the `decoded` property on the error.
                     * @expose
                     */
                    Message.decode64 = function(str) {
                        return Message.decode(str, "base64");
                    };

                    /**
                     * Decodes the message from the specified hex encoded string.
                     * @name ProtoBuf.Builder.Message.decodeHex
                     * @function
                     * @param {string} str String to decode from
                     * @return {!ProtoBuf.Builder.Message} Decoded message
                     * @throws {Error} If the message cannot be decoded or if required fields are missing. The later still
                     *  returns the decoded message with missing fields in the `decoded` property on the error.
                     * @expose
                     */
                    Message.decodeHex = function(str) {
                        return Message.decode(str, "hex");
                    };

                    // Utility

                    /**
                     * Returns a string representation of this Message.
                     * @name ProtoBuf.Builder.Message#toString
                     * @function
                     * @return {string} String representation as of ".Fully.Qualified.MessageName"
                     * @expose
                     */
                    Message.prototype.toString = function() {
                        return T.toString();
                    };

                    // Static

                    /**
                     * Options.
                     * @name ProtoBuf.Builder.Message.$options
                     * @type {Object.<string,*>}
                     * @expose
                     */
                    var $options; // for cc

                    if (Object.defineProperty)
                        Object.defineProperty(Message, '$options', { "value": T.buildOpt() });

                    return Message;

                })(ProtoBuf, this);

                // Static enums and prototyped sub-messages
                var children = this.getChildren();
                for (var i=0; i<children.length; i++) {
                    if (children[i] instanceof Enum)
                        clazz[children[i]['name']] = children[i].build();
                    else if (children[i] instanceof Message)
                        clazz[children[i]['name']] = children[i].build();
                    else if (children[i] instanceof Message.Field) {
                        // Ignore
                    } else
                        throw Error("Illegal reflect child of "+this.toString(true)+": "+children[i].toString(true));
                }
                return this.clazz = clazz;
            };

            /**
             * Encodes a runtime message's contents to the specified buffer.
             * @param {!ProtoBuf.Builder.Message} message Runtime message to encode
             * @param {ByteBuffer} buffer ByteBuffer to write to
             * @return {ByteBuffer} The ByteBuffer for chaining
             * @throws {Error} If required fields are missing or the message cannot be encoded for another reason
             * @expose
             */
            Message.prototype.encode = function(message, buffer) {
                var fields = this.getChildren(Message.Field),
                    fieldMissing = null;
                for (var i=0, val; i<fields.length; i++) {
                    val = message.$get(fields[i].name);
                    if (fields[i].required && val === null) {
                        if (fieldMissing === null)
                            fieldMissing = fields[i];
                    } else
                        fields[i].encode(val, buffer);
                }
                if (fieldMissing !== null) {
                    var err = Error("Missing at least one required field for "+this.toString(true)+": "+fieldMissing);
                    err["encoded"] = buffer; // Still expose what we got
                    throw(err);
                }
                return buffer;
            };

            /**
             * Calculates a runtime message's byte length.
             * @param {!ProtoBuf.Builder.Message} message Runtime message to encode
             * @returns {number} Byte length
             * @throws {Error} If required fields are missing or the message cannot be calculated for another reason
             * @expose
             */
            Message.prototype.calculate = function(message) {
                var fields = this.getChildren(Message.Field),
                    n = 0;
                for (var i=0, val; i<fields.length; i++) {
                    val = message.$get(fields[i].name);
                    if (fields[i].required && val === null)
                       throw Error("Missing at least one required field for "+this.toString(true)+": "+fields[i]);
                    else
                        n += fields[i].calculate(val);
                }
                return n;
            };

            /**
             * Skips all data until the end of the specified group has been reached.
             * @param {number} expectedId Expected GROUPEND id
             * @param {!ByteBuffer} buf ByteBuffer
             * @returns {boolean} `true` if a value as been skipped, `false` if the end has been reached
             * @throws {Error} If it wasn't possible to find the end of the group (buffer overrun or end tag mismatch)
             * @inner
             */
            function skipTillGroupEnd(expectedId, buf) {
                var tag = buf.readVarint32(), // Throws on OOB
                    wireType = tag & 0x07,
                    id = tag >> 3;
                switch (wireType) {
                    case ProtoBuf.WIRE_TYPES.VARINT:
                        do tag = buf.readUint8();
                        while ((tag & 0x80) === 0x80);
                        break;
                    case ProtoBuf.WIRE_TYPES.BITS64:
                        buf.offset += 8;
                        break;
                    case ProtoBuf.WIRE_TYPES.LDELIM:
                        tag = buf.readVarint32(); // reads the varint
                        buf.offset += tag;        // skips n bytes
                        break;
                    case ProtoBuf.WIRE_TYPES.STARTGROUP:
                        skipTillGroupEnd(id, buf);
                        break;
                    case ProtoBuf.WIRE_TYPES.ENDGROUP:
                        if (id === expectedId)
                            return false;
                        else
                            throw Error("Illegal GROUPEND after unknown group: "+id+" ("+expectedId+" expected)");
                    case ProtoBuf.WIRE_TYPES.BITS32:
                        buf.offset += 4;
                        break;
                    default:
                        throw Error("Illegal wire type in unknown group "+expectedId+": "+wireType);
                }
                return true;
            }

            /**
             * Decodes an encoded message and returns the decoded message.
             * @param {ByteBuffer} buffer ByteBuffer to decode from
             * @param {number=} length Message length. Defaults to decode all the available data.
             * @param {number=} expectedGroupEndId Expected GROUPEND id if this is a legacy group
             * @return {ProtoBuf.Builder.Message} Decoded message
             * @throws {Error} If the message cannot be decoded
             * @expose
             */
            Message.prototype.decode = function(buffer, length, expectedGroupEndId) {
                length = typeof length === 'number' ? length : -1;
                var start = buffer.offset;
                var msg = new (this.clazz)();
                var tag, wireType, id;
                while (buffer.offset < start+length || (length == -1 && buffer.remaining() > 0)) {
                    tag = buffer.readVarint32();
                    wireType = tag & 0x07;
                    id = tag >> 3;
                    if (wireType === ProtoBuf.WIRE_TYPES.ENDGROUP) {
                        if (id !== expectedGroupEndId)
                            throw Error("Illegal group end indicator for "+this.toString(true)+": "+id+" ("+(expectedGroupEndId ? expectedGroupEndId+" expected" : "not a group")+")");
                        break;
                    }
                    var field = this.getChild(id); // Message.Field only
                    if (!field) {
                        // "messages created by your new code can be parsed by your old code: old binaries simply ignore the new field when parsing."
                        switch (wireType) {
                            case ProtoBuf.WIRE_TYPES.VARINT:
                                buffer.readVarint32();
                                break;
                            case ProtoBuf.WIRE_TYPES.BITS32:
                                buffer.offset += 4;
                                break;
                            case ProtoBuf.WIRE_TYPES.BITS64:
                                buffer.offset += 8;
                                break;
                            case ProtoBuf.WIRE_TYPES.LDELIM:
                                var len = buffer.readVarint32();
                                buffer.offset += len;
                                break;
                            case ProtoBuf.WIRE_TYPES.STARTGROUP:
                                while (skipTillGroupEnd(id, buffer)) {}
                                break;
                            default:
                                throw Error("Illegal wire type for unknown field "+id+" in "+this.toString(true)+"#decode: "+wireType);
                        }
                        continue;
                    }
                    if (field.repeated && !field.options["packed"])
                        msg.$add(field.name, field.decode(wireType, buffer), true);
                    else
                        msg.$set(field.name, field.decode(wireType, buffer), true);
                }

                // Check if all required fields are present
                var fields = this.getChildren(ProtoBuf.Reflect.Field);
                for (var i=0; i<fields.length; i++)
                    if (fields[i].required && msg[fields[i].name] === null) {
                        var err = Error("Missing at least one required field for "+this.toString(true)+": "+fields[i].name);
                        err["decoded"] = msg; // Still expose what we got
                        throw(err);
                    }
                return msg;
            };

            /**
             * @alias ProtoBuf.Reflect.Message
             * @expose
             */
            Reflect.Message = Message;

            /**
             * Constructs a new Message Field.
             * @exports ProtoBuf.Reflect.Message.Field
             * @param {ProtoBuf.Reflect.Message} message Message reference
             * @param {string} rule Rule, one of requried, optional, repeated
             * @param {string} type Data type, e.g. int32
             * @param {string} name Field name
             * @param {number} id Unique field id
             * @param {Object.<string.*>=} options Options
             * @constructor
             * @extends ProtoBuf.Reflect.T
             */
            var Field = function(message, rule, type, name, id, options) {
                T.call(this, message, name);

                /**
                 * @override
                 */
                this.className = "Message.Field";

                /**
                 * Message field required flag.
                 * @type {boolean}
                 * @expose
                 */
                this.required = rule == "required";

                /**
                 * Message field repeated flag.
                 * @type {boolean}
                 * @expose
                 */
                this.repeated = rule == "repeated";

                /**
                 * Message field type. Type reference string if unresolved, protobuf type if resolved.
                 * @type {string|{name: string, wireType: number}}
                 * @expose
                 */
                this.type = type;

                /**
                 * Resolved type reference inside the global namespace.
                 * @type {ProtoBuf.Reflect.T|null}
                 * @expose
                 */
                this.resolvedType = null;

                /**
                 * Unique message field id.
                 * @type {number}
                 * @expose
                 */
                this.id = id;

                /**
                 * Message field options.
                 * @type {!Object.<string,*>}
                 * @dict
                 * @expose
                 */
                this.options = options || {};

                /**
                 * Original field name.
                 * @type {string}
                 * @expose
                 */
                this.originalName = this.name; // Used to revert camelcase transformation on naming collisions

                // Convert field names to camel case notation if the override is set
                if (ProtoBuf.convertFieldsToCamelCase) {
                    this.name = this.name.replace(/_([a-zA-Z])/g, function($0, $1) {
                        return $1.toUpperCase();
                    });
                }
            };

            // Extends T
            Field.prototype = Object.create(T.prototype);

            /**
             * Makes a Long from a value.
             * @param {{low: number, high: number, unsigned: boolean}|string|number} value Value
             * @param {boolean=} unsigned Whether unsigned or not, defaults to reuse it from Long-like objects or to signed for
             *  strings and numbers
             * @returns {!Long}
             * @throws {Error} If the value cannot be converted to a Long
             * @inner
             */
            function mkLong(value, unsigned) {
                if (value && typeof value.low === 'number' && typeof value.high === 'number' && typeof value.unsigned === 'boolean'
                    && value.low === value.low && value.high === value.high)
                    return new ProtoBuf.Long(value.low, value.high, typeof unsigned === 'undefined' ? value.unsigned : unsigned);
                if (typeof value === 'string')
                    return ProtoBuf.Long.fromString(value, unsigned || false, 10);
                if (typeof value === 'number')
                    return ProtoBuf.Long.fromNumber(value, unsigned || false);
                throw Error("not convertible to Long");
            }

            /**
             * Checks if the given value can be set for this field.
             * @param {*} value Value to check
             * @param {boolean=} skipRepeated Whether to skip the repeated value check or not. Defaults to false.
             * @return {*} Verified, maybe adjusted, value
             * @throws {Error} If the value cannot be set for this field
             * @expose
             */
            Field.prototype.verifyValue = function(value, skipRepeated) {
                skipRepeated = skipRepeated || false;
                var fail = function(val, msg) {
                    throw Error("Illegal value for "+this.toString(true)+" of type "+this.type.name+": "+val+" ("+msg+")");
                }.bind(this);
                if (value === null) { // NULL values for optional fields
                    if (this.required)
                        fail(typeof value, "required");
                    return null;
                }
                var i;
                if (this.repeated && !skipRepeated) { // Repeated values as arrays
                    if (!ProtoBuf.Util.isArray(value))
                        value = [value];
                    var res = [];
                    for (i=0; i<value.length; i++)
                        res.push(this.verifyValue(value[i], true));
                    return res;
                }
                // All non-repeated fields expect no array
                if (!this.repeated && ProtoBuf.Util.isArray(value))
                    fail(typeof value, "no array expected");

                switch (this.type) {
                    // Signed 32bit
                    case ProtoBuf.TYPES["int32"]:
                    case ProtoBuf.TYPES["sint32"]:
                    case ProtoBuf.TYPES["sfixed32"]:
                        // Account for !NaN: value === value
                        if (typeof value !== 'number' || (value === value && value % 1 !== 0))
                            fail(typeof value, "not an integer");
                        return value > 4294967295 ? value | 0 : value;

                    // Unsigned 32bit
                    case ProtoBuf.TYPES["uint32"]:
                    case ProtoBuf.TYPES["fixed32"]:
                        if (typeof value !== 'number' || (value === value && value % 1 !== 0))
                            fail(typeof value, "not an integer");
                        return value < 0 ? value >>> 0 : value;

                    // Signed 64bit
                    case ProtoBuf.TYPES["int64"]:
                    case ProtoBuf.TYPES["sint64"]:
                    case ProtoBuf.TYPES["sfixed64"]: {
                        if (ProtoBuf.Long)
                            try {
                                return mkLong(value, false);
                            } catch (e) {
                                fail(typeof value, e.message);
                            }
                        else
                            fail(typeof value, "requires Long.js");
                    }

                    // Unsigned 64bit
                    case ProtoBuf.TYPES["uint64"]:
                    case ProtoBuf.TYPES["fixed64"]: {
                        if (ProtoBuf.Long)
                            try {
                                return mkLong(value, true);
                            } catch (e) {
                                fail(typeof value, e.message);
                            }
                        else
                            fail(typeof value, "requires Long.js");
                    }

                    // Bool
                    case ProtoBuf.TYPES["bool"]:
                        if (typeof value !== 'boolean')
                            fail(typeof value, "not a boolean");
                        return value;

                    // Float
                    case ProtoBuf.TYPES["float"]:
                    case ProtoBuf.TYPES["double"]:
                        if (typeof value !== 'number')
                            fail(typeof value, "not a number");
                        return value;

                    // Length-delimited string
                    case ProtoBuf.TYPES["string"]:
                        if (typeof value !== 'string' && !(value && value instanceof String))
                            fail(typeof value, "not a string");
                        return ""+value; // Convert String object to string

                    // Length-delimited bytes
                    case ProtoBuf.TYPES["bytes"]:
                        return value && value instanceof ByteBuffer
                            ? value
                            : ByteBuffer.wrap(value);

                    // Constant enum value
                    case ProtoBuf.TYPES["enum"]: {
                        var values = this.resolvedType.getChildren(Enum.Value);
                        for (i=0; i<values.length; i++) {
                            if (values[i].name == value) {
                                return values[i].id;
                            } else if (values[i].id == value) {
                                return values[i].id;
                            }
                        }
                        fail(value, "not a valid enum value");
                    }
                    // Embedded message
                    case ProtoBuf.TYPES["group"]:
                    case ProtoBuf.TYPES["message"]: {
                        if (!value || typeof value !== 'object')
                            fail(typeof value, "object expected");
                        if (value instanceof this.resolvedType.clazz)
                            return value;
                        // Else let's try to construct one from a key-value object
                        return new (this.resolvedType.clazz)(value); // May throw for a hundred of reasons
                    }
                }

                // We should never end here
                throw Error("[INTERNAL] Illegal value for "+this.toString(true)+": "+value+" (undefined type "+this.type+")");
            };

            /**
             * Encodes the specified field value to the specified buffer.
             * @param {*} value Field value
             * @param {ByteBuffer} buffer ByteBuffer to encode to
             * @return {ByteBuffer} The ByteBuffer for chaining
             * @throws {Error} If the field cannot be encoded
             * @expose
             */
            Field.prototype.encode = function(value, buffer) {
                value = this.verifyValue(value); // May throw
                if (this.type === null || typeof this.type !== 'object')
                    throw Error("[INTERNAL] Unresolved type in "+this.toString(true)+": "+this.type);
                if (value === null || (this.repeated && value.length == 0))
                    return buffer; // Optional omitted
                try {
                    if (this.repeated) {
                        var i;
                        // "Only repeated fields of primitive numeric types (types which use the varint, 32-bit, or 64-bit wire
                        // types) can be declared 'packed'."
                        if (this.options["packed"] && ProtoBuf.PACKABLE_WIRE_TYPES.indexOf(this.type.wireType) >= 0) {
                            // "All of the elements of the field are packed into a single key-value pair with wire type 2
                            // (length-delimited). Each element is encoded the same way it would be normally, except without a
                            // tag preceding it."
                            buffer.writeVarint32((this.id << 3) | ProtoBuf.WIRE_TYPES.LDELIM);
                            buffer.ensureCapacity(buffer.offset += 1); // We do not know the length yet, so let's assume a varint of length 1
                            var start = buffer.offset; // Remember where the contents begin
                            for (i=0; i<value.length; i++)
                                this.encodeValue(value[i], buffer);
                            var len = buffer.offset-start;
                            var varintLen = ByteBuffer.calculateVarint32(len);
                            if (varintLen > 1) { // We need to move the contents
                                var contents = buffer.slice(start, buffer.offset);
                                start += varintLen-1;
                                buffer.offset = start;
                                buffer.append(contents);
                            }
                            buffer.writeVarint32(len, start-varintLen);
                        } else {
                            // "If your message definition has repeated elements (without the [packed=true] option), the encoded
                            // message has zero or more key-value pairs with the same tag number"
                            for (i=0; i<value.length; i++)
                                buffer.writeVarint32((this.id << 3) | this.type.wireType),
                                this.encodeValue(value[i], buffer);
                        }
                    } else
                        buffer.writeVarint32((this.id << 3) | this.type.wireType),
                        this.encodeValue(value, buffer);
                } catch (e) {
                    throw Error("Illegal value for "+this.toString(true)+": "+value+" ("+e+")");
                }
                return buffer;
            };

            /**
             * Encodes a value to the specified buffer. Does not encode the key.
             * @param {*} value Field value
             * @param {ByteBuffer} buffer ByteBuffer to encode to
             * @return {ByteBuffer} The ByteBuffer for chaining
             * @throws {Error} If the value cannot be encoded
             * @expose
             */
            Field.prototype.encodeValue = function(value, buffer) {
                if (value === null) return buffer; // Nothing to encode
                // Tag has already been written

                switch (this.type) {
                    // 32bit signed varint
                    case ProtoBuf.TYPES["int32"]:
                        // "If you use int32 or int64 as the type for a negative number, the resulting varint is always ten bytes
                        // long  it is, effectively, treated like a very large unsigned integer." (see #122)
                        if (value < 0)
                            buffer.writeVarint64(value);
                        else
                            buffer.writeVarint32(value);
                        break;

                    // 32bit unsigned varint
                    case ProtoBuf.TYPES["uint32"]:
                        buffer.writeVarint32(value);
                        break;

                    // 32bit varint zig-zag
                    case ProtoBuf.TYPES["sint32"]:
                        buffer.writeVarint32ZigZag(value);
                        break;

                    // Fixed unsigned 32bit
                    case ProtoBuf.TYPES["fixed32"]:
                        buffer.writeUint32(value);
                        break;

                    // Fixed signed 32bit
                    case ProtoBuf.TYPES["sfixed32"]:
                        buffer.writeInt32(value);
                        break;

                    // 64bit varint as-is
                    case ProtoBuf.TYPES["int64"]:
                    case ProtoBuf.TYPES["uint64"]:
                        buffer.writeVarint64(value); // throws
                        break;

                    // 64bit varint zig-zag
                    case ProtoBuf.TYPES["sint64"]:
                        buffer.writeVarint64ZigZag(value); // throws
                        break;

                    // Fixed unsigned 64bit
                    case ProtoBuf.TYPES["fixed64"]:
                        buffer.writeUint64(value); // throws
                        break;

                    // Fixed signed 64bit
                    case ProtoBuf.TYPES["sfixed64"]:
                        buffer.writeInt64(value); // throws
                        break;

                    // Bool
                    case ProtoBuf.TYPES["bool"]:
                        if (typeof value === 'string')
                            buffer.writeVarint32(value.toLowerCase() === 'false' ? 0 : !!value);
                        else
                            buffer.writeVarint32(value ? 1 : 0);
                        break;

                    // Constant enum value
                    case ProtoBuf.TYPES["enum"]:
                        buffer.writeVarint32(value);
                        break;

                    // 32bit float
                    case ProtoBuf.TYPES["float"]:
                        buffer.writeFloat32(value);
                        break;

                    // 64bit float
                    case ProtoBuf.TYPES["double"]:
                        buffer.writeFloat64(value);
                        break;

                    // Length-delimited string
                    case ProtoBuf.TYPES["string"]:
                        buffer.writeVString(value);
                        break;

                    // Length-delimited bytes
                    case ProtoBuf.TYPES["bytes"]:
                        if (value.remaining() < 0)
                            throw Error("Illegal value for "+this.toString(true)+": "+value.remaining()+" bytes remaining");
                        var prevOffset = value.offset;
                        buffer.writeVarint32(value.remaining());
                        buffer.append(value);
                        value.offset = prevOffset;
                        break;

                    // Embedded message
                    case ProtoBuf.TYPES["message"]:
                        var bb = new ByteBuffer().LE();
                        this.resolvedType.encode(value, bb);
                        buffer.writeVarint32(bb.offset);
                        buffer.append(bb.flip());
                        break;

                    // Legacy group
                    case ProtoBuf.TYPES["group"]:
                        this.resolvedType.encode(value, buffer);
                        buffer.writeVarint32((this.id << 3) | ProtoBuf.WIRE_TYPES.ENDGROUP);
                        break;

                    default:
                        // We should never end here
                        throw Error("[INTERNAL] Illegal value to encode in "+this.toString(true)+": "+value+" (unknown type)");
                }
                return buffer;
            };

            /**
             * Calculates the length of this field's value on the network level.
             * @param {*} value Field value
             * @returns {number} Byte length
             * @expose
             */
            Field.prototype.calculate = function(value) {
                value = this.verifyValue(value); // May throw
                if (this.type === null || typeof this.type !== 'object')
                    throw Error("[INTERNAL] Unresolved type in "+this.toString(true)+": "+this.type);
                if (value === null || (this.repeated && value.length == 0))
                    return 0; // Optional omitted
                var n = 0;
                try {
                    if (this.repeated) {
                        var i, ni;
                        if (this.options["packed"] && ProtoBuf.PACKABLE_WIRE_TYPES.indexOf(this.type.wireType) >= 0) {
                            n += ByteBuffer.calculateVarint32((this.id << 3) | ProtoBuf.WIRE_TYPES.LDELIM);
                            ni = 0;
                            for (i=0; i<value.length; i++)
                                ni += this.calculateValue(value[i]);
                            n += ByteBuffer.calculateVarint32(ni);
                            n += ni;
                        } else {
                            for (i=0; i<value.length; i++)
                                n += ByteBuffer.calculateVarint32((this.id << 3) | this.type.wireType),
                                n += this.calculateValue(value[i]);
                        }
                    } else {
                        n += ByteBuffer.calculateVarint32((this.id << 3) | this.type.wireType);
                        n += this.calculateValue(value);
                    }
                } catch (e) {
                    throw Error("Illegal value for "+this.toString(true)+": "+value+" ("+e+")");
                }
                return n;
            };

            /**
             * Calculates the byte length of a value.
             * @param {*} value Field value
             * @returns {number} Byte length
             * @throws {Error} If the value cannot be calculated
             * @expose
             */
            Field.prototype.calculateValue = function(value) {
                if (value === null) return 0; // Nothing to encode
                // Tag has already been written
                var n;
                switch (this.type) {
                    case ProtoBuf.TYPES["int32"]:
                        return value < 0 ? ByteBuffer.calculateVarint64(value) : ByteBuffer.calculateVarint32(value);
                    case ProtoBuf.TYPES["uint32"]:
                        return ByteBuffer.calculateVarint32(value);
                    case ProtoBuf.TYPES["sint32"]:
                        return ByteBuffer.calculateVarint32(ByteBuffer.zigZagEncode32(value));
                    case ProtoBuf.TYPES["fixed32"]:
                    case ProtoBuf.TYPES["sfixed32"]:
                    case ProtoBuf.TYPES["float"]:
                        return 4;
                    case ProtoBuf.TYPES["int64"]:
                    case ProtoBuf.TYPES["uint64"]:
                        return ByteBuffer.calculateVarint64(value);
                    case ProtoBuf.TYPES["sint64"]:
                        return ByteBuffer.calculateVarint64(ByteBuffer.zigZagEncode64(value));
                    case ProtoBuf.TYPES["fixed64"]:
                    case ProtoBuf.TYPES["sfixed64"]:
                        return 8;
                    case ProtoBuf.TYPES["bool"]:
                        return 1;
                    case ProtoBuf.TYPES["enum"]:
                        return ByteBuffer.calculateVarint32(value);
                    case ProtoBuf.TYPES["double"]:
                        return 8;
                    case ProtoBuf.TYPES["string"]:
                        n = ByteBuffer.calculateUTF8Bytes(value);
                        return ByteBuffer.calculateVarint32(n) + n;
                    case ProtoBuf.TYPES["bytes"]:
                        if (value.remaining() < 0)
                            throw Error("Illegal value for "+this.toString(true)+": "+value.remaining()+" bytes remaining");
                        return ByteBuffer.calculateVarint32(value.remaining()) + value.remaining();
                    case ProtoBuf.TYPES["message"]:
                        n = this.resolvedType.calculate(value);
                        return ByteBuffer.calculateVarint32(n) + n;
                    case ProtoBuf.TYPES["group"]:
                        n = this.resolvedType.calculate(value);
                        return n + ByteBuffer.calculateVarint32((this.id << 3) | ProtoBuf.WIRE_TYPES.ENDGROUP);
                }
                // We should never end here
                throw Error("[INTERNAL] Illegal value to encode in "+this.toString(true)+": "+value+" (unknown type)");
            };

            /**
             * Decode the field value from the specified buffer.
             * @param {number} wireType Leading wire type
             * @param {ByteBuffer} buffer ByteBuffer to decode from
             * @param {boolean=} skipRepeated Whether to skip the repeated check or not. Defaults to false.
             * @return {*} Decoded value
             * @throws {Error} If the field cannot be decoded
             * @expose
             */
            Field.prototype.decode = function(wireType, buffer, skipRepeated) {
                var value, nBytes;
                if (wireType != this.type.wireType && (skipRepeated || (wireType != ProtoBuf.WIRE_TYPES.LDELIM || !this.repeated)))
                    throw Error("Illegal wire type for field "+this.toString(true)+": "+wireType+" ("+this.type.wireType+" expected)");
                if (wireType == ProtoBuf.WIRE_TYPES.LDELIM && this.repeated && this.options["packed"] && ProtoBuf.PACKABLE_WIRE_TYPES.indexOf(this.type.wireType) >= 0) {
                    if (!skipRepeated) {
                        nBytes = buffer.readVarint32();
                        nBytes = buffer.offset + nBytes; // Limit
                        var values = [];
                        while (buffer.offset < nBytes)
                            values.push(this.decode(this.type.wireType, buffer, true));
                        return values;
                    }
                    // Read the next value otherwise...
                }
                switch (this.type) {
                    // 32bit signed varint
                    case ProtoBuf.TYPES["int32"]:
                        return buffer.readVarint32() | 0;

                    // 32bit unsigned varint
                    case ProtoBuf.TYPES["uint32"]:
                        return buffer.readVarint32() >>> 0;

                    // 32bit signed varint zig-zag
                    case ProtoBuf.TYPES["sint32"]:
                        return buffer.readVarint32ZigZag() | 0;

                    // Fixed 32bit unsigned
                    case ProtoBuf.TYPES["fixed32"]:
                        return buffer.readUint32() >>> 0;

                    case ProtoBuf.TYPES["sfixed32"]:
                        return buffer.readInt32() | 0;

                    // 64bit signed varint
                    case ProtoBuf.TYPES["int64"]:
                        return buffer.readVarint64();

                    // 64bit unsigned varint
                    case ProtoBuf.TYPES["uint64"]:
                        return buffer.readVarint64().toUnsigned();

                    // 64bit signed varint zig-zag
                    case ProtoBuf.TYPES["sint64"]:
                        return buffer.readVarint64ZigZag();

                    // Fixed 64bit unsigned
                    case ProtoBuf.TYPES["fixed64"]:
                        return buffer.readUint64();

                    // Fixed 64bit signed
                    case ProtoBuf.TYPES["sfixed64"]:
                        return buffer.readInt64();

                    // Bool varint
                    case ProtoBuf.TYPES["bool"]:
                        return !!buffer.readVarint32();

                    // Constant enum value (varint)
                    case ProtoBuf.TYPES["enum"]:
                        // The following Builder.Message#set will already throw
                        return buffer.readVarint32();

                    // 32bit float
                    case ProtoBuf.TYPES["float"]:
                        return buffer.readFloat();

                    // 64bit float
                    case ProtoBuf.TYPES["double"]:
                        return buffer.readDouble();

                    // Length-delimited string
                    case ProtoBuf.TYPES["string"]:
                        return buffer.readVString();

                    // Length-delimited bytes
                    case ProtoBuf.TYPES["bytes"]: {
                        nBytes = buffer.readVarint32();
                        if (buffer.remaining() < nBytes)
                            throw Error("Illegal number of bytes for "+this.toString(true)+": "+nBytes+" required but got only "+buffer.remaining());
                        value = buffer.clone(); // Offset already set
                        value.limit = value.offset+nBytes;
                        buffer.offset += nBytes;
                        return value;
                    }

                    // Length-delimited embedded message
                    case ProtoBuf.TYPES["message"]: {
                        nBytes = buffer.readVarint32();
                        return this.resolvedType.decode(buffer, nBytes);
                    }

                    // Legacy group
                    case ProtoBuf.TYPES["group"]:
                        return this.resolvedType.decode(buffer, -1, this.id);
                }

                // We should never end here
                throw Error("[INTERNAL] Illegal wire type for "+this.toString(true)+": "+wireType);
            }

            /**
             * @alias ProtoBuf.Reflect.Message.Field
             * @expose
             */
            Reflect.Message.Field = Field;

            /**
             * Constructs a new Message ExtensionField.
             * @exports ProtoBuf.Reflect.Message.ExtensionField
             * @param {ProtoBuf.Reflect.Message} message Message reference
             * @param {string} rule Rule, one of requried, optional, repeated
             * @param {string} type Data type, e.g. int32
             * @param {string} name Field name
             * @param {number} id Unique field id
             * @param {Object.<string.*>=} options Options
             * @constructor
             * @extends ProtoBuf.Reflect.Message.Field
             */
            var ExtensionField = function(message, rule, type, name, id, options) {
                Field.call(this, message, rule, type, name, id, options);
            };

            // Extends Field
            ExtensionField.prototype = Object.create(Field.prototype);

            /**
             * @alias ProtoBuf.Reflect.Message.ExtensionField
             * @expose
             */
            Reflect.Message.ExtensionField = ExtensionField;

            /**
             * Constructs a new Enum.
             * @exports ProtoBuf.Reflect.Enum
             * @param {!ProtoBuf.Reflect.T} parent Parent Reflect object
             * @param {string} name Enum name
             * @param {Object.<string.*>=} options Enum options
             * @constructor
             * @extends ProtoBuf.Reflect.Namespace
             */
            var Enum = function(parent, name, options) {
                Namespace.call(this, parent, name, options);

                /**
                 * @override
                 */
                this.className = "Enum";

                /**
                 * Runtime enum object.
                 * @type {Object.<string,number>|null}
                 * @expose
                 */
                this.object = null;
            };

            // Extends Namespace
            Enum.prototype = Object.create(Namespace.prototype);

            /**
             * Builds this enum and returns the runtime counterpart.
             * @return {Object<string,*>}
             * @expose
             */
            Enum.prototype.build = function() {
                var enm = {};
                var values = this.getChildren(Enum.Value);
                for (var i=0; i<values.length; i++)
                    enm[values[i]['name']] = values[i]['id'];
                if (Object.defineProperty)
                    Object.defineProperty(enm, '$options', { "value": this.buildOpt() });
                return this.object = enm;
            };

            /**
             * @alias ProtoBuf.Reflect.Enum
             * @expose
             */
            Reflect.Enum = Enum;

            /**
             * Constructs a new Enum Value.
             * @exports ProtoBuf.Reflect.Enum.Value
             * @param {!ProtoBuf.Reflect.Enum} enm Enum reference
             * @param {string} name Field name
             * @param {number} id Unique field id
             * @constructor
             * @extends ProtoBuf.Reflect.T
             */
            var Value = function(enm, name, id) {
                T.call(this, enm, name);

                /**
                 * @override
                 */
                this.className = "Enum.Value";

                /**
                 * Unique enum value id.
                 * @type {number}
                 * @expose
                 */
                this.id = id;
            };

            // Extends T
            Value.prototype = Object.create(T.prototype);

            /**
             * @alias ProtoBuf.Reflect.Enum.Value
             * @expose
             */
            Reflect.Enum.Value = Value;

            /**
             * Constructs a new Service.
             * @exports ProtoBuf.Reflect.Service
             * @param {!ProtoBuf.Reflect.Namespace} root Root
             * @param {string} name Service name
             * @param {Object.<string,*>=} options Options
             * @constructor
             * @extends ProtoBuf.Reflect.Namespace
             */
            var Service = function(root, name, options) {
                Namespace.call(this, root, name, options);

                /**
                 * @override
                 */
                this.className = "Service";

                /**
                 * Built runtime service class.
                 * @type {?function(new:ProtoBuf.Builder.Service)}
                 */
                this.clazz = null;
            };

            // Extends Namespace
            Service.prototype = Object.create(Namespace.prototype);

            /**
             * Builds the service and returns the runtime counterpart, which is a fully functional class.
             * @see ProtoBuf.Builder.Service
             * @param {boolean=} rebuild Whether to rebuild or not
             * @return {Function} Service class
             * @throws {Error} If the message cannot be built
             * @expose
             */
            Service.prototype.build = function(rebuild) {
                if (this.clazz && !rebuild) return this.clazz;
                return this.clazz = (function(ProtoBuf, T) {

                    /**
                     * Constructs a new runtime Service.
                     * @name ProtoBuf.Builder.Service
                     * @param {function(string, ProtoBuf.Builder.Message, function(Error, ProtoBuf.Builder.Message=))=} rpcImpl RPC implementation receiving the method name and the message
                     * @class Barebone of all runtime services.
                     * @constructor
                     * @throws {Error} If the service cannot be created
                     */
                    var Service = function(rpcImpl) {
                        ProtoBuf.Builder.Service.call(this);

                        /**
                         * Service implementation.
                         * @name ProtoBuf.Builder.Service#rpcImpl
                         * @type {!function(string, ProtoBuf.Builder.Message, function(Error, ProtoBuf.Builder.Message=))}
                         * @expose
                         */
                        this.rpcImpl = rpcImpl || function(name, msg, callback) {
                            // This is what a user has to implement: A function receiving the method name, the actual message to
                            // send (type checked) and the callback that's either provided with the error as its first
                            // argument or null and the actual response message.
                            setTimeout(callback.bind(this, Error("Not implemented, see: https://github.com/dcodeIO/ProtoBuf.js/wiki/Services")), 0); // Must be async!
                        };
                    };

                    // Extends ProtoBuf.Builder.Service
                    Service.prototype = Object.create(ProtoBuf.Builder.Service.prototype);

                    if (Object.defineProperty)
                        Object.defineProperty(Service, "$options", { "value": T.buildOpt() }),
                        Object.defineProperty(Service.prototype, "$options", { "value": Service["$options"] });

                    /**
                     * Asynchronously performs an RPC call using the given RPC implementation.
                     * @name ProtoBuf.Builder.Service.[Method]
                     * @function
                     * @param {!function(string, ProtoBuf.Builder.Message, function(Error, ProtoBuf.Builder.Message=))} rpcImpl RPC implementation
                     * @param {ProtoBuf.Builder.Message} req Request
                     * @param {function(Error, (ProtoBuf.Builder.Message|ByteBuffer|Buffer|string)=)} callback Callback receiving
                     *  the error if any and the response either as a pre-parsed message or as its raw bytes
                     * @abstract
                     */

                    /**
                     * Asynchronously performs an RPC call using the instance's RPC implementation.
                     * @name ProtoBuf.Builder.Service#[Method]
                     * @function
                     * @param {ProtoBuf.Builder.Message} req Request
                     * @param {function(Error, (ProtoBuf.Builder.Message|ByteBuffer|Buffer|string)=)} callback Callback receiving
                     *  the error if any and the response either as a pre-parsed message or as its raw bytes
                     * @abstract
                     */

                    var rpc = T.getChildren(ProtoBuf.Reflect.Service.RPCMethod);
                    for (var i=0; i<rpc.length; i++) {
                        (function(method) {

                            // service#Method(message, callback)
                            Service.prototype[method.name] = function(req, callback) {
                                try {
                                    if (!req || !(req instanceof method.resolvedRequestType.clazz)) {
                                        setTimeout(callback.bind(this, Error("Illegal request type provided to service method "+T.name+"#"+method.name)), 0);
                                        return;
                                    }
                                    this.rpcImpl(method.fqn(), req, function(err, res) { // Assumes that this is properly async
                                        if (err) {
                                            callback(err);
                                            return;
                                        }
                                        try { res = method.resolvedResponseType.clazz.decode(res); } catch (notABuffer) {}
                                        if (!res || !(res instanceof method.resolvedResponseType.clazz)) {
                                            callback(Error("Illegal response type received in service method "+ T.name+"#"+method.name));
                                            return;
                                        }
                                        callback(null, res);
                                    });
                                } catch (err) {
                                    setTimeout(callback.bind(this, err), 0);
                                }
                            };

                            // Service.Method(rpcImpl, message, callback)
                            Service[method.name] = function(rpcImpl, req, callback) {
                                new Service(rpcImpl)[method.name](req, callback);
                            };

                            if (Object.defineProperty)
                                Object.defineProperty(Service[method.name], "$options", { "value": method.buildOpt() }),
                                Object.defineProperty(Service.prototype[method.name], "$options", { "value": Service[method.name]["$options"] });
                        })(rpc[i]);
                    }

                    return Service;

                })(ProtoBuf, this);
            };

            /**
             * @alias ProtoBuf.Reflect.Service
             * @expose
             */
            Reflect.Service = Service;

            /**
             * Abstract service method.
             * @exports ProtoBuf.Reflect.Service.Method
             * @param {!ProtoBuf.Reflect.Service} svc Service
             * @param {string} name Method name
             * @param {Object.<string,*>=} options Options
             * @constructor
             * @extends ProtoBuf.Reflect.T
             */
            var Method = function(svc, name, options) {
                T.call(this, svc, name);

                /**
                 * @override
                 */
                this.className = "Service.Method";

                /**
                 * Options.
                 * @type {Object.<string, *>}
                 * @expose
                 */
                this.options = options || {};
            };

            // Extends T
            Method.prototype = Object.create(T.prototype);

            /**
             * Builds the method's '$options' property.
             * @name ProtoBuf.Reflect.Service.Method#buildOpt
             * @function
             * @return {Object.<string,*>}
             */
            Method.prototype.buildOpt = Namespace.prototype.buildOpt;

            /**
             * @alias ProtoBuf.Reflect.Service.Method
             * @expose
             */
            Reflect.Service.Method = Method;

            /**
             * RPC service method.
             * @exports ProtoBuf.Reflect.Service.RPCMethod
             * @param {!ProtoBuf.Reflect.Service} svc Service
             * @param {string} name Method name
             * @param {string} request Request message name
             * @param {string} response Response message name
             * @param {Object.<string,*>=} options Options
             * @constructor
             * @extends ProtoBuf.Reflect.Service.Method
             */
            var RPCMethod = function(svc, name, request, response, options) {
                Method.call(this, svc, name, options);

                /**
                 * @override
                 */
                this.className = "Service.RPCMethod";

                /**
                 * Request message name.
                 * @type {string}
                 * @expose
                 */
                this.requestName = request;

                /**
                 * Response message name.
                 * @type {string}
                 * @expose
                 */
                this.responseName = response;

                /**
                 * Resolved request message type.
                 * @type {ProtoBuf.Reflect.Message}
                 * @expose
                 */
                this.resolvedRequestType = null;

                /**
                 * Resolved response message type.
                 * @type {ProtoBuf.Reflect.Message}
                 * @expose
                 */
                this.resolvedResponseType = null;
            };

            // Extends Method
            RPCMethod.prototype = Object.create(Method.prototype);

            /**
             * @alias ProtoBuf.Reflect.Service.RPCMethod
             * @expose
             */
            Reflect.Service.RPCMethod = RPCMethod;

            return Reflect;
        })(ProtoBuf);

        /**
         * @alias ProtoBuf.Builder
         * @expose
         */
        ProtoBuf.Builder = (function(ProtoBuf, Lang, Reflect) {
            "use strict";

            /**
             * Constructs a new Builder.
             * @exports ProtoBuf.Builder
             * @class Provides the functionality to build protocol messages.
             * @constructor
             */
            var Builder = function() {

                /**
                 * Namespace.
                 * @type {ProtoBuf.Reflect.Namespace}
                 * @expose
                 */
                this.ns = new Reflect.Namespace(null, ""); // Global namespace

                /**
                 * Namespace pointer.
                 * @type {ProtoBuf.Reflect.T}
                 * @expose
                 */
                this.ptr = this.ns;

                /**
                 * Resolved flag.
                 * @type {boolean}
                 * @expose
                 */
                this.resolved = false;

                /**
                 * The current building result.
                 * @type {Object.<string,ProtoBuf.Builder.Message|Object>|null}
                 * @expose
                 */
                this.result = null;

                /**
                 * Imported files.
                 * @type {Array.<string>}
                 * @expose
                 */
                this.files = {};

                /**
                 * Import root override.
                 * @type {?string}
                 * @expose
                 */
                this.importRoot = null;
            };

            /**
             * Resets the pointer to the root namespace.
             * @expose
             */
            Builder.prototype.reset = function() {
                this.ptr = this.ns;
            };

            /**
             * Defines a package on top of the current pointer position and places the pointer on it.
             * @param {string} pkg
             * @param {Object.<string,*>=} options
             * @return {ProtoBuf.Builder} this
             * @throws {Error} If the package name is invalid
             * @expose
             */
            Builder.prototype.define = function(pkg, options) {
                if (typeof pkg !== 'string' || !Lang.TYPEREF.test(pkg))
                    throw Error("Illegal package: "+pkg);
                var part = pkg.split("."), i;
                for (i=0; i<part.length; i++) // To be absolutely sure
                    if (!Lang.NAME.test(part[i]))
                        throw Error("Illegal package: "+part[i]);
                for (i=0; i<part.length; i++) {
                    if (!this.ptr.hasChild(part[i])) // Keep existing namespace
                        this.ptr.addChild(new Reflect.Namespace(this.ptr, part[i], options));
                    this.ptr = this.ptr.getChild(part[i]);
                }
                return this;
            };

            /**
             * Tests if a definition is a valid message definition.
             * @param {Object.<string,*>} def Definition
             * @return {boolean} true if valid, else false
             * @expose
             */
            Builder.isValidMessage = function(def) {
                // Messages require a string name
                if (typeof def["name"] !== 'string' || !Lang.NAME.test(def["name"]))
                    return false;
                // Messages must not contain values (that'd be an enum) or methods (that'd be a service)
                if (typeof def["values"] !== 'undefined' || typeof def["rpc"] !== 'undefined')
                    return false;
                // Fields, enums and messages are arrays if provided
                var i;
                if (typeof def["fields"] !== 'undefined') {
                    if (!ProtoBuf.Util.isArray(def["fields"]))
                        return false;
                    var ids = [], id; // IDs must be unique
                    for (i=0; i<def["fields"].length; i++) {
                        if (!Builder.isValidMessageField(def["fields"][i]))
                            return false;
                        id = parseInt(def["fields"][i]["id"], 10);
                        if (ids.indexOf(id) >= 0)
                            return false;
                        ids.push(id);
                    }
                    ids = null;
                }
                if (typeof def["enums"] !== 'undefined') {
                    if (!ProtoBuf.Util.isArray(def["enums"]))
                        return false;
                    for (i=0; i<def["enums"].length; i++)
                        if (!Builder.isValidEnum(def["enums"][i]))
                            return false;
                }
                if (typeof def["messages"] !== 'undefined') {
                    if (!ProtoBuf.Util.isArray(def["messages"]))
                        return false;
                    for (i=0; i<def["messages"].length; i++)
                        if (!Builder.isValidMessage(def["messages"][i]) && !Builder.isValidExtend(def["messages"][i]))
                            return false;
                }
                if (typeof def["extensions"] !== 'undefined')
                    if (!ProtoBuf.Util.isArray(def["extensions"]) || def["extensions"].length !== 2 || typeof def["extensions"][0] !== 'number' || typeof def["extensions"][1] !== 'number')
                        return false;
                return true;
            };

            /**
             * Tests if a definition is a valid message field definition.
             * @param {Object} def Definition
             * @return {boolean} true if valid, else false
             * @expose
             */
            Builder.isValidMessageField = function(def) {
                // Message fields require a string rule, name and type and an id
                if (typeof def["rule"] !== 'string' || typeof def["name"] !== 'string' || typeof def["type"] !== 'string' || typeof def["id"] === 'undefined')
                    return false;
                if (!Lang.RULE.test(def["rule"]) || !Lang.NAME.test(def["name"]) || !Lang.TYPEREF.test(def["type"]) || !Lang.ID.test(""+def["id"]))
                    return false;
                if (typeof def["options"] !== 'undefined') {
                    // Options are objects
                    if (typeof def["options"] !== 'object')
                        return false;
                    // Options are <string,string|number|boolean>
                    var keys = Object.keys(def["options"]);
                    for (var i=0, key; i<keys.length; i++)
                        if (typeof (key = keys[i]) !== 'string' || (typeof def["options"][key] !== 'string' && typeof def["options"][key] !== 'number' && typeof def["options"][key] !== 'boolean'))
                            return false;
                }
                return true;
            };

            /**
             * Tests if a definition is a valid enum definition.
             * @param {Object} def Definition
             * @return {boolean} true if valid, else false
             * @expose
             */
            Builder.isValidEnum = function(def) {
                // Enums require a string name
                if (typeof def["name"] !== 'string' || !Lang.NAME.test(def["name"]))
                    return false;
                // Enums require at least one value
                if (typeof def["values"] === 'undefined' || !ProtoBuf.Util.isArray(def["values"]) || def["values"].length == 0)
                    return false;
                for (var i=0; i<def["values"].length; i++) {
                    // Values are objects
                    if (typeof def["values"][i] != "object")
                        return false;
                    // Values require a string name and an id
                    if (typeof def["values"][i]["name"] !== 'string' || typeof def["values"][i]["id"] === 'undefined')
                        return false;
                    if (!Lang.NAME.test(def["values"][i]["name"]) || !Lang.NEGID.test(""+def["values"][i]["id"]))
                        return false;
                }
                // It's not important if there are other fields because ["values"] is already unique
                return true;
            };

            /**
             * Creates ths specified protocol types at the current pointer position.
             * @param {Array.<Object.<string,*>>} defs Messages, enums or services to create
             * @return {ProtoBuf.Builder} this
             * @throws {Error} If a message definition is invalid
             * @expose
             */
            Builder.prototype.create = function(defs) {
                if (!defs)
                    return this; // Nothing to create
                if (!ProtoBuf.Util.isArray(defs))
                    defs = [defs];
                if (defs.length == 0)
                    return this;

                // It's quite hard to keep track of scopes and memory here, so let's do this iteratively.
                var stack = [], def, obj, subObj, i, j;
                stack.push(defs); // One level [a, b, c]
                while (stack.length > 0) {
                    defs = stack.pop();
                    if (ProtoBuf.Util.isArray(defs)) { // Stack always contains entire namespaces
                        while (defs.length > 0) {
                            def = defs.shift(); // Namespace always contains an array of messages, enums and services
                            if (Builder.isValidMessage(def)) {
                                obj = new Reflect.Message(this.ptr, def["name"], def["options"], def["isGroup"]);
                                // Create fields
                                if (def["fields"] && def["fields"].length > 0) {
                                    for (i=0; i<def["fields"].length; i++) { // i=Fields
                                        if (obj.hasChild(def['fields'][i]['id']))
                                            throw Error("Duplicate field id in message "+obj.name+": "+def['fields'][i]['id']);
                                        if (def["fields"][i]["options"]) {
                                            subObj = Object.keys(def["fields"][i]["options"]);
                                            for (j=0; j<subObj.length; j++) { // j=Option names
                                                if (typeof subObj[j] !== 'string')
                                                    throw Error("Illegal field option name in message "+obj.name+"#"+def["fields"][i]["name"]+": "+subObj[j]);
                                                if (typeof def["fields"][i]["options"][subObj[j]] !== 'string' && typeof def["fields"][i]["options"][subObj[j]] !== 'number' && typeof def["fields"][i]["options"][subObj[j]] !== 'boolean')
                                                    throw Error("Illegal field option value in message "+obj.name+"#"+def["fields"][i]["name"]+"#"+subObj[j]+": "+def["fields"][i]["options"][subObj[j]]);
                                            }
                                            subObj = null;
                                        }
                                        obj.addChild(new Reflect.Message.Field(obj, def["fields"][i]["rule"], def["fields"][i]["type"], def["fields"][i]["name"], def["fields"][i]["id"], def["fields"][i]["options"]));
                                    }
                                }
                                // Push enums and messages to stack
                                subObj = [];
                                if (typeof def["enums"] !== 'undefined' && def['enums'].length > 0)
                                    for (i=0; i<def["enums"].length; i++)
                                        subObj.push(def["enums"][i]);
                                if (def["messages"] && def["messages"].length > 0)
                                    for (i=0; i<def["messages"].length; i++)
                                        subObj.push(def["messages"][i]);
                                // Set extension range
                                if (def["extensions"]) {
                                    obj.extensions = def["extensions"];
                                    if (obj.extensions[0] < ProtoBuf.ID_MIN)
                                        obj.extensions[0] = ProtoBuf.ID_MIN;
                                    if (obj.extensions[1] > ProtoBuf.ID_MAX)
                                        obj.extensions[1] = ProtoBuf.ID_MAX;
                                }
                                this.ptr.addChild(obj); // Add to current namespace
                                if (subObj.length > 0) {
                                    stack.push(defs); // Push the current level back
                                    defs = subObj; // Continue processing sub level
                                    subObj = null;
                                    this.ptr = obj; // And move the pointer to this namespace
                                    obj = null;
                                    continue;
                                }
                                subObj = null;
                                obj = null;
                            } else if (Builder.isValidEnum(def)) {
                                obj = new Reflect.Enum(this.ptr, def["name"], def["options"]);
                                for (i=0; i<def["values"].length; i++)
                                    obj.addChild(new Reflect.Enum.Value(obj, def["values"][i]["name"], def["values"][i]["id"]));
                                this.ptr.addChild(obj);
                                obj = null;
                            } else if (Builder.isValidService(def)) {
                                obj = new Reflect.Service(this.ptr, def["name"], def["options"]);
                                for (i in def["rpc"])
                                    if (def["rpc"].hasOwnProperty(i))
                                        obj.addChild(new Reflect.Service.RPCMethod(obj, i, def["rpc"][i]["request"], def["rpc"][i]["response"], def["rpc"][i]["options"]));
                                this.ptr.addChild(obj);
                                obj = null;
                            } else if (Builder.isValidExtend(def)) {
                                obj = this.ptr.resolve(def["ref"]);
                                if (obj) {
                                    for (i=0; i<def["fields"].length; i++) { // i=Fields
                                        if (obj.hasChild(def['fields'][i]['id']))
                                            throw Error("Duplicate extended field id in message "+obj.name+": "+def['fields'][i]['id']);
                                        if (def['fields'][i]['id'] < obj.extensions[0] || def['fields'][i]['id'] > obj.extensions[1])
                                            throw Error("Illegal extended field id in message "+obj.name+": "+def['fields'][i]['id']+" ("+obj.extensions.join(' to ')+" expected)");
                                        // TODO: See #161
                                        /* subObj = new (this.ptr instanceof Reflect.Message ? Reflect.Message.ExtensionField : Reflect.Message.Field)(obj, def["fields"][i]["rule"], def["fields"][i]["type"], def["fields"][i]["name"], def["fields"][i]["id"], def["fields"][i]["options"]);
                                        if (this.ptr instanceof Reflect.Message)
                                            this.ptr.addChild(subObj);
                                        else
                                            obj.addChild(subObj); */
                                        obj.addChild(new Reflect.Message.Field(obj, def["fields"][i]["rule"], def["fields"][i]["type"], def["fields"][i]["name"], def["fields"][i]["id"], def["fields"][i]["options"]));
                                    }
                                } else if (!/\.?google\.protobuf\./.test(def["ref"])) // Silently skip internal extensions
                                    throw Error("Extended message "+def["ref"]+" is not defined");
                            } else
                                throw Error("Not a valid definition: "+JSON.stringify(def));
                            def = null;
                        }
                        // Break goes here
                    } else
                        throw Error("Not a valid namespace: "+JSON.stringify(defs));
                    defs = null;
                    this.ptr = this.ptr.parent; // This namespace is s done
                }
                this.resolved = false; // Require re-resolve
                this.result = null; // Require re-build
                return this;
            };

            /**
             * Imports another definition into this builder.
             * @param {Object.<string,*>} json Parsed import
             * @param {(string|{root: string, file: string})=} filename Imported file name
             * @return {ProtoBuf.Builder} this
             * @throws {Error} If the definition or file cannot be imported
             * @expose
             */
            Builder.prototype["import"] = function(json, filename) {
                if (typeof filename === 'string') {
                    if (ProtoBuf.Util.IS_NODE)
                        filename = require("path")['resolve'](filename);
                    if (this.files[filename] === true) {
                        this.reset();
                        return this; // Skip duplicate imports
                    }
                    this.files[filename] = true;
                }
                if (!!json['imports'] && json['imports'].length > 0) {
                    var importRoot, delim = '/', resetRoot = false;
                    if (typeof filename === 'object') { // If an import root is specified, override
                        this.importRoot = filename["root"]; resetRoot = true; // ... and reset afterwards
                        importRoot = this.importRoot;
                        filename = filename["file"];
                        if (importRoot.indexOf("\\") >= 0 || filename.indexOf("\\") >= 0) delim = '\\';
                    } else if (typeof filename === 'string') {
                        if (this.importRoot) // If import root is overridden, use it
                            importRoot = this.importRoot;
                        else { // Otherwise compute from filename
                            if (filename.indexOf("/") >= 0) { // Unix
                                importRoot = filename.replace(/\/[^\/]*$/, "");
                                if (/* /file.proto */ importRoot === "")
                                    importRoot = "/";
                            } else if (filename.indexOf("\\") >= 0) { // Windows
                                importRoot = filename.replace(/\\[^\\]*$/, "");
                                delim = '\\';
                            } else
                                importRoot = ".";
                        }
                    } else
                        importRoot = null;

                    for (var i=0; i<json['imports'].length; i++) {
                        if (typeof json['imports'][i] === 'string') { // Import file
                            if (!importRoot)
                                throw Error("Cannot determine import root: File name is unknown");
                            var importFilename = json['imports'][i];
                            if (/^google\/protobuf\//.test(importFilename))
                                continue; // Not needed and therefore not used
                            importFilename = importRoot+delim+importFilename;
                            if (this.files[importFilename] === true)
                                continue; // Already imported
                            if (/\.proto$/i.test(importFilename) && !ProtoBuf.DotProto)     // If this is a NOPARSE build
                                importFilename = importFilename.replace(/\.proto$/, ".json"); // always load the JSON file
                            var contents = ProtoBuf.Util.fetch(importFilename);
                            if (contents === null)
                                throw Error("Failed to import '"+importFilename+"' in '"+filename+"': File not found");
                            if (/\.json$/i.test(importFilename)) // Always possible
                                this["import"](JSON.parse(contents+""), importFilename); // May throw
                            else
                                this["import"]((new ProtoBuf.DotProto.Parser(contents+"")).parse(), importFilename); // May throw
                        } else // Import structure
                            if (!filename)
                                this["import"](json['imports'][i]);
                            else if (/\.(\w+)$/.test(filename)) // With extension: Append _importN to the name portion to make it unique
                                this["import"](json['imports'][i], filename.replace(/^(.+)\.(\w+)$/, function($0, $1, $2) { return $1+"_import"+i+"."+$2; }));
                            else // Without extension: Append _importN to make it unique
                                this["import"](json['imports'][i], filename+"_import"+i);
                    }
                    if (resetRoot) // Reset import root override when all imports are done
                        this.importRoot = null;
                }
                if (json['messages']) {
                    if (json['package'])
                        this.define(json['package'], json["options"]);
                    this.create(json['messages']);
                    this.reset();
                }
                if (json['enums']) {
                    if (json['package'])
                        this.define(json['package'], json["options"]);
                    this.create(json['enums']);
                    this.reset();
                }
                if (json['services']) {
                    if (json['package'])
                        this.define(json['package'], json["options"]);
                    this.create(json['services']);
                    this.reset();
                }
                if (json['extends']) {
                    if (json['package'])
                        this.define(json['package'], json["options"]);
                    this.create(json['extends']);
                    this.reset();
                }
                return this;
            };

            /**
             * Tests if a definition is a valid service definition.
             * @param {Object} def Definition
             * @return {boolean} true if valid, else false
             * @expose
             */
            Builder.isValidService = function(def) {
                // Services require a string name and an rpc object
                return !(typeof def["name"] !== 'string' || !Lang.NAME.test(def["name"]) || typeof def["rpc"] !== 'object');
            };

            /**
             * Tests if a definition is a valid extension.
             * @param {Object} def Definition
             * @returns {boolean} true if valid, else false
             * @expose
            */
            Builder.isValidExtend = function(def) {
                if (typeof def["ref"] !== 'string' || !Lang.TYPEREF.test(def["ref"]))
                    return false;
                var i;
                if (typeof def["fields"] !== 'undefined') {
                    if (!ProtoBuf.Util.isArray(def["fields"]))
                        return false;
                    var ids = [], id; // IDs must be unique (does not yet test for the extended message's ids)
                    for (i=0; i<def["fields"].length; i++) {
                        if (!Builder.isValidMessageField(def["fields"][i]))
                            return false;
                        id = parseInt(def["id"], 10);
                        if (ids.indexOf(id) >= 0)
                            return false;
                        ids.push(id);
                    }
                    ids = null;
                }
                return true;
            };

            /**
             * Resolves all namespace objects.
             * @throws {Error} If a type cannot be resolved
             * @expose
             */
            Builder.prototype.resolveAll = function() {
                // Resolve all reflected objects
                var res;
                if (this.ptr == null || typeof this.ptr.type === 'object')
                    return; // Done (already resolved)
                if (this.ptr instanceof Reflect.Namespace) {
                    // Build all children
                    var children = this.ptr.getChildren();
                    for (var i=0; i<children.length; i++)
                        this.ptr = children[i], this.resolveAll();
                } else if (this.ptr instanceof Reflect.Message.Field) {
                    if (!Lang.TYPE.test(this.ptr.type)) { // Resolve type...
                        if (!Lang.TYPEREF.test(this.ptr.type))
                            throw Error("Illegal type reference in "+this.ptr.toString(true)+": "+this.ptr.type);
                        res = this.ptr.parent.resolve(this.ptr.type, true);
                        if (!res)
                            throw Error("Unresolvable type reference in "+this.ptr.toString(true)+": "+this.ptr.type);
                        this.ptr.resolvedType = res;
                        if (res instanceof Reflect.Enum)
                            this.ptr.type = ProtoBuf.TYPES["enum"];
                        else if (res instanceof Reflect.Message)
                            this.ptr.type = res.isGroup ? ProtoBuf.TYPES["group"] : ProtoBuf.TYPES["message"];
                        else
                            throw Error("Illegal type reference in "+this.ptr.toString(true)+": "+this.ptr.type);
                    } else
                        this.ptr.type = ProtoBuf.TYPES[this.ptr.type];
                } else if (this.ptr instanceof ProtoBuf.Reflect.Enum.Value) {
                    // No need to build enum values (built in enum)
                } else if (this.ptr instanceof ProtoBuf.Reflect.Service.Method) {
                    if (this.ptr instanceof ProtoBuf.Reflect.Service.RPCMethod) {
                        res = this.ptr.parent.resolve(this.ptr.requestName);
                        if (!res || !(res instanceof ProtoBuf.Reflect.Message))
                            throw Error("Illegal type reference in "+this.ptr.toString(true)+": "+this.ptr.requestName);
                        this.ptr.resolvedRequestType = res;
                        res = this.ptr.parent.resolve(this.ptr.responseName);
                        if (!res || !(res instanceof ProtoBuf.Reflect.Message))
                            throw Error("Illegal type reference in "+this.ptr.toString(true)+": "+this.ptr.responseName);
                        this.ptr.resolvedResponseType = res;
                    } else {
                        // Should not happen as nothing else is implemented
                        throw Error("Illegal service type in "+this.ptr.toString(true));
                    }
                } else
                    throw Error("Illegal object in namespace: "+typeof(this.ptr)+":"+this.ptr);
                this.reset();
            };

            /**
             * Builds the protocol. This will first try to resolve all definitions and, if this has been successful,
             * return the built package.
             * @param {string=} path Specifies what to return. If omitted, the entire namespace will be returned.
             * @return {ProtoBuf.Builder.Message|Object.<string,*>}
             * @throws {Error} If a type could not be resolved
             * @expose
             */
            Builder.prototype.build = function(path) {
                this.reset();
                if (!this.resolved)
                    this.resolveAll(),
                    this.resolved = true,
                    this.result = null; // Require re-build
                if (this.result == null) // (Re-)Build
                    this.result = this.ns.build();
                if (!path)
                    return this.result;
                else {
                    var part = path.split(".");
                    var ptr = this.result; // Build namespace pointer (no hasChild etc.)
                    for (var i=0; i<part.length; i++)
                        if (ptr[part[i]])
                            ptr = ptr[part[i]];
                        else {
                            ptr = null;
                            break;
                        }
                    return ptr;
                }
            };

            /**
             * Similar to {@link ProtoBuf.Builder#build}, but looks up the internal reflection descriptor.
             * @param {string=} path Specifies what to return. If omitted, the entire namespace wiil be returned.
             * @return {ProtoBuf.Reflect.T} Reflection descriptor or `null` if not found
             */
            Builder.prototype.lookup = function(path) {
                return path ? this.ns.resolve(path) : this.ns;
            };

            /**
             * Returns a string representation of this object.
             * @return {string} String representation as of "Builder"
             * @expose
             */
            Builder.prototype.toString = function() {
                return "Builder";
            };

            // Pseudo types documented in Reflect.js.
            // Exist for the sole purpose of being able to "... instanceof ProtoBuf.Builder.Message" etc.
            Builder.Message = function() {};
            Builder.Service = function() {};

            return Builder;

        })(ProtoBuf, ProtoBuf.Lang, ProtoBuf.Reflect);


        /**
         * Loads a .proto string and returns the Builder.
         * @param {string} proto .proto file contents
         * @param {(ProtoBuf.Builder|string|{root: string, file: string})=} builder Builder to append to. Will create a new one if omitted.
         * @param {(string|{root: string, file: string})=} filename The corresponding file name if known. Must be specified for imports.
         * @return {ProtoBuf.Builder} Builder to create new messages
         * @throws {Error} If the definition cannot be parsed or built
         * @expose
         */
        ProtoBuf.loadProto = function(proto, builder, filename) {
            if (typeof builder === 'string' || (builder && typeof builder["file"] === 'string' && typeof builder["root"] === 'string')) {
                filename = builder;
                builder = null;
            }
            return ProtoBuf.loadJson((new ProtoBuf.DotProto.Parser(proto)).parse(), builder, filename);
        };

        /**
         * Loads a .proto string and returns the Builder. This is an alias of {@link ProtoBuf.loadProto}.
         * @function
         * @param {string} proto .proto file contents
         * @param {(ProtoBuf.Builder|string)=} builder Builder to append to. Will create a new one if omitted.
         * @param {(string|{root: string, file: string})=} filename The corresponding file name if known. Must be specified for imports.
         * @return {ProtoBuf.Builder} Builder to create new messages
         * @throws {Error} If the definition cannot be parsed or built
         * @expose
         */
        ProtoBuf.protoFromString = ProtoBuf.loadProto; // Legacy

        /**
         * Loads a .proto file and returns the Builder.
         * @param {string|{root: string, file: string}} filename Path to proto file or an object specifying 'file' with
         *  an overridden 'root' path for all imported files.
         * @param {function(?Error, !ProtoBuf.Builder=)=} callback Callback that will receive `null` as the first and
         *  the Builder as its second argument on success, otherwise the error as its first argument. If omitted, the
         *  file will be read synchronously and this function will return the Builder.
         * @param {ProtoBuf.Builder=} builder Builder to append to. Will create a new one if omitted.
         * @return {?ProtoBuf.Builder|undefined} The Builder if synchronous (no callback specified, will be NULL if the
         *   request has failed), else undefined
         * @expose
         */
        ProtoBuf.loadProtoFile = function(filename, callback, builder) {
            if (callback && typeof callback === 'object')
                builder = callback,
                callback = null;
            else if (!callback || typeof callback !== 'function')
                callback = null;
            if (callback)
                return ProtoBuf.Util.fetch(typeof filename === 'string' ? filename : filename["root"]+"/"+filename["file"], function(contents) {
                    if (contents === null) {
                        callback(Error("Failed to fetch file"));
                        return;
                    }
                    try {
                        callback(null, ProtoBuf.loadProto(contents, builder, filename));
                    } catch (e) {
                        callback(e);
                    }
                });
            var contents = ProtoBuf.Util.fetch(typeof filename === 'object' ? filename["root"]+"/"+filename["file"] : filename);
            return contents === null ? null : ProtoBuf.loadProto(contents, builder, filename);
        };

        /**
         * Loads a .proto file and returns the Builder. This is an alias of {@link ProtoBuf.loadProtoFile}.
         * @function
         * @param {string|{root: string, file: string}} filename Path to proto file or an object specifying 'file' with
         *  an overridden 'root' path for all imported files.
         * @param {function(?Error, !ProtoBuf.Builder=)=} callback Callback that will receive `null` as the first and
         *  the Builder as its second argument on success, otherwise the error as its first argument. If omitted, the
         *  file will be read synchronously and this function will return the Builder.
         * @param {ProtoBuf.Builder=} builder Builder to append to. Will create a new one if omitted.
         * @return {!ProtoBuf.Builder|undefined} The Builder if synchronous (no callback specified, will be NULL if the
         *   request has failed), else undefined
         * @expose
         */
        ProtoBuf.protoFromFile = ProtoBuf.loadProtoFile; // Legacy


        /**
         * Constructs a new Builder with the specified package defined.
         * @param {string=} pkg Package name as fully qualified name, e.g. "My.Game". If no package is specified, the
         * builder will only contain a global namespace.
         * @param {Object.<string,*>=} options Top level options
         * @return {ProtoBuf.Builder} New Builder
         * @expose
         */
        ProtoBuf.newBuilder = function(pkg, options) {
            var builder = new ProtoBuf.Builder();
            if (typeof pkg !== 'undefined' && pkg !== null)
                builder.define(pkg, options);
            return builder;
        };

        /**
         * Loads a .json definition and returns the Builder.
         * @param {!*|string} json JSON definition
         * @param {(ProtoBuf.Builder|string|{root: string, file: string})=} builder Builder to append to. Will create a new one if omitted.
         * @param {(string|{root: string, file: string})=} filename The corresponding file name if known. Must be specified for imports.
         * @return {ProtoBuf.Builder} Builder to create new messages
         * @throws {Error} If the definition cannot be parsed or built
         * @expose
         */
        ProtoBuf.loadJson = function(json, builder, filename) {
            if (typeof builder === 'string' || (builder && typeof builder["file"] === 'string' && typeof builder["root"] === 'string'))
                filename = builder,
                builder = null;
            if (!builder || typeof builder !== 'object')
                builder = ProtoBuf.newBuilder();
            if (typeof json === 'string')
                json = JSON.parse(json);
            builder["import"](json, filename);
            builder.resolveAll();
            builder.build();
            return builder;
        };

        /**
         * Loads a .json file and returns the Builder.
         * @param {string|!{root: string, file: string}} filename Path to json file or an object specifying 'file' with
         *  an overridden 'root' path for all imported files.
         * @param {function(?Error, !ProtoBuf.Builder=)=} callback Callback that will receive `null` as the first and
         *  the Builder as its second argument on success, otherwise the error as its first argument. If omitted, the
         *  file will be read synchronously and this function will return the Builder.
         * @param {ProtoBuf.Builder=} builder Builder to append to. Will create a new one if omitted.
         * @return {?ProtoBuf.Builder|undefined} The Builder if synchronous (no callback specified, will be NULL if the
         *   request has failed), else undefined
         * @expose
         */
        ProtoBuf.loadJsonFile = function(filename, callback, builder) {
            if (callback && typeof callback === 'object')
                builder = callback,
                callback = null;
            else if (!callback || typeof callback !== 'function')
                callback = null;
            if (callback)
                return ProtoBuf.Util.fetch(typeof filename === 'string' ? filename : filename["root"]+"/"+filename["file"], function(contents) {
                    if (contents === null) {
                        callback(Error("Failed to fetch file"));
                        return;
                    }
                    try {
                        callback(null, ProtoBuf.loadJson(JSON.parse(contents), builder, filename));
                    } catch (e) {
                        callback(e);
                    }
                });
            var contents = ProtoBuf.Util.fetch(typeof filename === 'object' ? filename["root"]+"/"+filename["file"] : filename);
            return contents === null ? null : ProtoBuf.loadJson(JSON.parse(contents), builder, filename);
        };

        return ProtoBuf;
    }

    /* CommonJS */ if (typeof module !== 'undefined' && module["exports"])
        module["exports"] = init(require("bytebuffer"));
    /* AMD */ else if (typeof define === 'function' && define["amd"])
        define(["ByteBuffer"], init);
    /* Global */ else
        (global["dcodeIO"] = global["dcodeIO"] || {})["ProtoBuf"] = init(global["dcodeIO"]["ByteBuffer"]);

})(this);

},{"bytebuffer":54,"fs":46,"path":50}],53:[function(require,module,exports){
/*
 Copyright 2013 Daniel Wirtz <dcode@dcode.io>

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 */
var ProtoBuf = require("./dist/ProtoBuf.js");

module.exports = ProtoBuf;

},{"./dist/ProtoBuf.js":52}],54:[function(require,module,exports){
/*
 ByteBuffer.js (c) 2013-2014 Daniel Wirtz <dcode@dcode.io>
 This version of ByteBuffer.js uses an ArrayBuffer (AB) as its backing buffer and is compatible with modern browsers.
 Released under the Apache License, Version 2.0
 see: https://github.com/dcodeIO/ByteBuffer.js for details
*/
(function(r){function s(l){function d(a,b,c){"undefined"===typeof a&&(a=d.DEFAULT_CAPACITY);"undefined"===typeof b&&(b=d.DEFAULT_ENDIAN);"undefined"===typeof c&&(c=d.DEFAULT_NOASSERT);if(!c){a|=0;if(0>a)throw new RangeError("Illegal capacity: 0 <= "+a);if("boolean"!==typeof b)throw new TypeError("Illegal littleEndian: Not a boolean");if("boolean"!==typeof c)throw new TypeError("Illegal noAssert: Not a boolean");}this.buffer=0===a?r:new ArrayBuffer(a);this.view=0===a?null:new DataView(this.buffer);
this.offset=0;this.markedOffset=-1;this.limit=a;this.littleEndian="undefined"!==typeof b?!!b:!1;this.noAssert=!!c}d.VERSION="3.1.0";d.LITTLE_ENDIAN=!0;d.BIG_ENDIAN=!1;d.DEFAULT_CAPACITY=16;d.DEFAULT_ENDIAN=d.BIG_ENDIAN;d.DEFAULT_NOASSERT=!1;d.Long=l||null;var r=new ArrayBuffer(0);d.allocate=function(a,b,c){return new d(a,b,c)};d.concat=function(a,b,c,e){if("boolean"===typeof b||"string"!==typeof b)e=c,c=b,b=void 0;for(var h=0,f=0,g=a.length,n;f<g;++f)d.isByteBuffer(a[f])||(a[f]=d.wrap(a[f],b)),n=
a[f].limit-a[f].offset,0<n&&(h+=n);if(0===h)return new d(0,c,e);b=new d(h,c,e);e=new Uint8Array(b.buffer);for(f=0;f<g;)c=a[f++],n=c.limit-c.offset,0>=n||(e.set((new Uint8Array(c.buffer)).subarray(c.offset,c.limit),b.offset),b.offset+=n);b.limit=b.offset;b.offset=0;return b};d.isByteBuffer=function(a){return a&&a instanceof d};d.type=function(){return ArrayBuffer};d.wrap=function(a,b,c,e){"string"!==typeof b&&(e=c,c=b,b=void 0);if("string"===typeof a)switch("undefined"===typeof b&&(b="utf8"),b){case "base64":return d.fromBase64(a,
c);case "hex":return d.fromHex(a,c);case "binary":return d.fromBinary(a,c);case "utf8":return d.fromUTF8(a,c);case "debug":return d.fromDebug(a,c);default:throw new TypeError("Unsupported encoding: "+b);}if(null===a||"object"!==typeof a)throw new TypeError("Illegal buffer: null or non-object");if(d.isByteBuffer(a))return b=d.prototype.clone.call(a),b.markedOffset=-1,b;if(a instanceof Uint8Array)b=new d(0,c,e),0<a.length&&(b.buffer=a.buffer,b.offset=a.byteOffset,b.limit=a.byteOffset+a.length,b.view=
0<a.length?new DataView(a.buffer):null);else if(a instanceof ArrayBuffer)b=new d(0,c,e),0<a.byteLength&&(b.buffer=a,b.offset=0,b.limit=a.byteLength,b.view=0<a.byteLength?new DataView(a):null);else if("[object Array]"===Object.prototype.toString.call(a))for(b=new d(a.length,c,e),b.limit=a.length,i=0;i<a.length;++i)b.view.setUint8(i,a[i]);else throw new TypeError("Illegal buffer");return b};d.prototype.writeInt8=function(a,b){var c="undefined"===typeof b;c&&(b=this.offset);if(!this.noAssert){if("number"!==
typeof a||0!==a%1)throw new TypeError("Illegal value: "+a+" (not an integer)");a|=0;if("number"!==typeof b||0!==b%1)throw new TypeError("Illegal offset: "+b+" (not an integer)");b>>>=0;if(0>b||b+0>this.buffer.byteLength)throw new RangeError("Illegal offset: 0 <= "+b+" (+0) <= "+this.buffer.byteLength);}b+=1;var e=this.buffer.byteLength;b>e&&this.resize((e*=2)>b?e:b);this.view.setInt8(b-1,a);c&&(this.offset+=1);return this};d.prototype.writeByte=d.prototype.writeInt8;d.prototype.readInt8=function(a){var b=
"undefined"===typeof a;b&&(a=this.offset);if(!this.noAssert){if("number"!==typeof a||0!==a%1)throw new TypeError("Illegal offset: "+a+" (not an integer)");a>>>=0;if(0>a||a+1>this.buffer.byteLength)throw new RangeError("Illegal offset: 0 <= "+a+" (+1) <= "+this.buffer.byteLength);}a=this.view.getInt8(a);b&&(this.offset+=1);return a};d.prototype.readByte=d.prototype.readInt8;d.prototype.writeUint8=function(a,b){var c="undefined"===typeof b;c&&(b=this.offset);if(!this.noAssert){if("number"!==typeof a||
0!==a%1)throw new TypeError("Illegal value: "+a+" (not an integer)");a>>>=0;if("number"!==typeof b||0!==b%1)throw new TypeError("Illegal offset: "+b+" (not an integer)");b>>>=0;if(0>b||b+0>this.buffer.byteLength)throw new RangeError("Illegal offset: 0 <= "+b+" (+0) <= "+this.buffer.byteLength);}b+=1;var e=this.buffer.byteLength;b>e&&this.resize((e*=2)>b?e:b);this.view.setUint8(b-1,a);c&&(this.offset+=1);return this};d.prototype.readUint8=function(a){var b="undefined"===typeof a;b&&(a=this.offset);
if(!this.noAssert){if("number"!==typeof a||0!==a%1)throw new TypeError("Illegal offset: "+a+" (not an integer)");a>>>=0;if(0>a||a+1>this.buffer.byteLength)throw new RangeError("Illegal offset: 0 <= "+a+" (+1) <= "+this.buffer.byteLength);}a=this.view.getUint8(a);b&&(this.offset+=1);return a};d.prototype.writeInt16=function(a,b){var c="undefined"===typeof b;c&&(b=this.offset);if(!this.noAssert){if("number"!==typeof a||0!==a%1)throw new TypeError("Illegal value: "+a+" (not an integer)");a|=0;if("number"!==
typeof b||0!==b%1)throw new TypeError("Illegal offset: "+b+" (not an integer)");b>>>=0;if(0>b||b+0>this.buffer.byteLength)throw new RangeError("Illegal offset: 0 <= "+b+" (+0) <= "+this.buffer.byteLength);}b+=2;var e=this.buffer.byteLength;b>e&&this.resize((e*=2)>b?e:b);this.view.setInt16(b-2,a,this.littleEndian);c&&(this.offset+=2);return this};d.prototype.writeShort=d.prototype.writeInt16;d.prototype.readInt16=function(a){var b="undefined"===typeof a;b&&(a=this.offset);if(!this.noAssert){if("number"!==
typeof a||0!==a%1)throw new TypeError("Illegal offset: "+a+" (not an integer)");a>>>=0;if(0>a||a+2>this.buffer.byteLength)throw new RangeError("Illegal offset: 0 <= "+a+" (+2) <= "+this.buffer.byteLength);}a=this.view.getInt16(a,this.littleEndian);b&&(this.offset+=2);return a};d.prototype.readShort=d.prototype.readInt16;d.prototype.writeUint16=function(a,b){var c="undefined"===typeof b;c&&(b=this.offset);if(!this.noAssert){if("number"!==typeof a||0!==a%1)throw new TypeError("Illegal value: "+a+" (not an integer)");
a>>>=0;if("number"!==typeof b||0!==b%1)throw new TypeError("Illegal offset: "+b+" (not an integer)");b>>>=0;if(0>b||b+0>this.buffer.byteLength)throw new RangeError("Illegal offset: 0 <= "+b+" (+0) <= "+this.buffer.byteLength);}b+=2;var e=this.buffer.byteLength;b>e&&this.resize((e*=2)>b?e:b);this.view.setUint16(b-2,a,this.littleEndian);c&&(this.offset+=2);return this};d.prototype.readUint16=function(a){var b="undefined"===typeof a;b&&(a=this.offset);if(!this.noAssert){if("number"!==typeof a||0!==a%
1)throw new TypeError("Illegal offset: "+a+" (not an integer)");a>>>=0;if(0>a||a+2>this.buffer.byteLength)throw new RangeError("Illegal offset: 0 <= "+a+" (+2) <= "+this.buffer.byteLength);}a=this.view.getUint16(a,this.littleEndian);b&&(this.offset+=2);return a};d.prototype.writeInt32=function(a,b){var c="undefined"===typeof b;c&&(b=this.offset);if(!this.noAssert){if("number"!==typeof a||0!==a%1)throw new TypeError("Illegal value: "+a+" (not an integer)");a|=0;if("number"!==typeof b||0!==b%1)throw new TypeError("Illegal offset: "+
b+" (not an integer)");b>>>=0;if(0>b||b+0>this.buffer.byteLength)throw new RangeError("Illegal offset: 0 <= "+b+" (+0) <= "+this.buffer.byteLength);}b+=4;var e=this.buffer.byteLength;b>e&&this.resize((e*=2)>b?e:b);this.view.setInt32(b-4,a,this.littleEndian);c&&(this.offset+=4);return this};d.prototype.writeInt=d.prototype.writeInt32;d.prototype.readInt32=function(a){var b="undefined"===typeof a;b&&(a=this.offset);if(!this.noAssert){if("number"!==typeof a||0!==a%1)throw new TypeError("Illegal offset: "+
a+" (not an integer)");a>>>=0;if(0>a||a+4>this.buffer.byteLength)throw new RangeError("Illegal offset: 0 <= "+a+" (+4) <= "+this.buffer.byteLength);}a=this.view.getInt32(a,this.littleEndian);b&&(this.offset+=4);return a};d.prototype.readInt=d.prototype.readInt32;d.prototype.writeUint32=function(a,b){var c="undefined"===typeof b;c&&(b=this.offset);if(!this.noAssert){if("number"!==typeof a||0!==a%1)throw new TypeError("Illegal value: "+a+" (not an integer)");a>>>=0;if("number"!==typeof b||0!==b%1)throw new TypeError("Illegal offset: "+
b+" (not an integer)");b>>>=0;if(0>b||b+0>this.buffer.byteLength)throw new RangeError("Illegal offset: 0 <= "+b+" (+0) <= "+this.buffer.byteLength);}b+=4;var e=this.buffer.byteLength;b>e&&this.resize((e*=2)>b?e:b);this.view.setUint32(b-4,a,this.littleEndian);c&&(this.offset+=4);return this};d.prototype.readUint32=function(a){var b="undefined"===typeof a;b&&(a=this.offset);if(!this.noAssert){if("number"!==typeof a||0!==a%1)throw new TypeError("Illegal offset: "+a+" (not an integer)");a>>>=0;if(0>a||
a+4>this.buffer.byteLength)throw new RangeError("Illegal offset: 0 <= "+a+" (+4) <= "+this.buffer.byteLength);}a=this.view.getUint32(a,this.littleEndian);b&&(this.offset+=4);return a};l&&(d.prototype.writeInt64=function(a,b){var c="undefined"===typeof b;c&&(b=this.offset);if(!this.noAssert){if("number"===typeof a)a=l.fromNumber(a);else if(!(a&&a instanceof l))throw new TypeError("Illegal value: "+a+" (not an integer or Long)");if("number"!==typeof b||0!==b%1)throw new TypeError("Illegal offset: "+
b+" (not an integer)");b>>>=0;if(0>b||b+0>this.buffer.byteLength)throw new RangeError("Illegal offset: 0 <= "+b+" (+0) <= "+this.buffer.byteLength);}"number"===typeof a&&(a=l.fromNumber(a));b+=8;var e=this.buffer.byteLength;b>e&&this.resize((e*=2)>b?e:b);b-=8;this.littleEndian?(this.view.setInt32(b,a.low,!0),this.view.setInt32(b+4,a.high,!0)):(this.view.setInt32(b,a.high,!1),this.view.setInt32(b+4,a.low,!1));c&&(this.offset+=8);return this},d.prototype.writeLong=d.prototype.writeInt64,d.prototype.readInt64=
function(a){var b="undefined"===typeof a;b&&(a=this.offset);if(!this.noAssert){if("number"!==typeof a||0!==a%1)throw new TypeError("Illegal offset: "+a+" (not an integer)");a>>>=0;if(0>a||a+8>this.buffer.byteLength)throw new RangeError("Illegal offset: 0 <= "+a+" (+8) <= "+this.buffer.byteLength);}a=this.littleEndian?new l(this.view.getInt32(a,!0),this.view.getInt32(a+4,!0),!1):new l(this.view.getInt32(a+4,!1),this.view.getInt32(a,!1),!1);b&&(this.offset+=8);return a},d.prototype.readLong=d.prototype.readInt64,
d.prototype.writeUint64=function(a,b){var c="undefined"===typeof b;c&&(b=this.offset);if(!this.noAssert){if("number"===typeof a)a=l.fromNumber(a);else if(!(a&&a instanceof l))throw new TypeError("Illegal value: "+a+" (not an integer or Long)");if("number"!==typeof b||0!==b%1)throw new TypeError("Illegal offset: "+b+" (not an integer)");b>>>=0;if(0>b||b+0>this.buffer.byteLength)throw new RangeError("Illegal offset: 0 <= "+b+" (+0) <= "+this.buffer.byteLength);}"number"===typeof a&&(a=l.fromNumber(a));
b+=8;var e=this.buffer.byteLength;b>e&&this.resize((e*=2)>b?e:b);b-=8;this.littleEndian?(this.view.setInt32(b,a.low,!0),this.view.setInt32(b+4,a.high,!0)):(this.view.setInt32(b,a.high,!1),this.view.setInt32(b+4,a.low,!1));c&&(this.offset+=8);return this},d.prototype.readUint64=function(a){var b="undefined"===typeof a;b&&(a=this.offset);if(!this.noAssert){if("number"!==typeof a||0!==a%1)throw new TypeError("Illegal offset: "+a+" (not an integer)");a>>>=0;if(0>a||a+8>this.buffer.byteLength)throw new RangeError("Illegal offset: 0 <= "+
a+" (+8) <= "+this.buffer.byteLength);}a=this.littleEndian?new l(this.view.getInt32(a,!0),this.view.getInt32(a+4,!0),!0):new l(this.view.getInt32(a+4,!1),this.view.getInt32(a,!1),!0);b&&(this.offset+=8);return a});d.prototype.writeFloat32=function(a,b){var c="undefined"===typeof b;c&&(b=this.offset);if(!this.noAssert){if("number"!==typeof a)throw new TypeError("Illegal value: "+a+" (not a number)");if("number"!==typeof b||0!==b%1)throw new TypeError("Illegal offset: "+b+" (not an integer)");b>>>=
0;if(0>b||b+0>this.buffer.byteLength)throw new RangeError("Illegal offset: 0 <= "+b+" (+0) <= "+this.buffer.byteLength);}b+=4;var e=this.buffer.byteLength;b>e&&this.resize((e*=2)>b?e:b);this.view.setFloat32(b-4,a,this.littleEndian);c&&(this.offset+=4);return this};d.prototype.writeFloat=d.prototype.writeFloat32;d.prototype.readFloat32=function(a){var b="undefined"===typeof a;b&&(a=this.offset);if(!this.noAssert){if("number"!==typeof a||0!==a%1)throw new TypeError("Illegal offset: "+a+" (not an integer)");
a>>>=0;if(0>a||a+4>this.buffer.byteLength)throw new RangeError("Illegal offset: 0 <= "+a+" (+4) <= "+this.buffer.byteLength);}a=this.view.getFloat32(a,this.littleEndian);b&&(this.offset+=4);return a};d.prototype.readFloat=d.prototype.readFloat32;d.prototype.writeFloat64=function(a,b){var c="undefined"===typeof b;c&&(b=this.offset);if(!this.noAssert){if("number"!==typeof a)throw new TypeError("Illegal value: "+a+" (not a number)");if("number"!==typeof b||0!==b%1)throw new TypeError("Illegal offset: "+
b+" (not an integer)");b>>>=0;if(0>b||b+0>this.buffer.byteLength)throw new RangeError("Illegal offset: 0 <= "+b+" (+0) <= "+this.buffer.byteLength);}b+=8;var e=this.buffer.byteLength;b>e&&this.resize((e*=2)>b?e:b);this.view.setFloat64(b-8,a,this.littleEndian);c&&(this.offset+=8);return this};d.prototype.writeDouble=d.prototype.writeFloat64;d.prototype.readFloat64=function(a){var b="undefined"===typeof a;b&&(a=this.offset);if(!this.noAssert){if("number"!==typeof a||0!==a%1)throw new TypeError("Illegal offset: "+
a+" (not an integer)");a>>>=0;if(0>a||a+8>this.buffer.byteLength)throw new RangeError("Illegal offset: 0 <= "+a+" (+8) <= "+this.buffer.byteLength);}a=this.view.getFloat64(a,this.littleEndian);b&&(this.offset+=8);return a};d.prototype.readDouble=d.prototype.readFloat64;d.MAX_VARINT32_BYTES=5;d.calculateVarint32=function(a){a>>>=0;return 128>a?1:16384>a?2:2097152>a?3:268435456>a?4:5};d.zigZagEncode32=function(a){return((a|=0)<<1^a>>31)>>>0};d.zigZagDecode32=function(a){return a>>>1^-(a&1)|0};d.prototype.writeVarint32=
function(a,b){var c="undefined"===typeof b;c&&(b=this.offset);if(!this.noAssert){if("number"!==typeof a||0!==a%1)throw new TypeError("Illegal value: "+a+" (not an integer)");a|=0;if("number"!==typeof b||0!==b%1)throw new TypeError("Illegal offset: "+b+" (not an integer)");b>>>=0;if(0>b||b+0>this.buffer.byteLength)throw new RangeError("Illegal offset: 0 <= "+b+" (+0) <= "+this.buffer.byteLength);}var e=d.calculateVarint32(a);b+=e;var h=this.buffer.byteLength;b>h&&this.resize((h*=2)>b?h:b);b-=e;this.view.setUint8(b,
e=a|128);a>>>=0;128<=a?(e=a>>7|128,this.view.setUint8(b+1,e),16384<=a?(e=a>>14|128,this.view.setUint8(b+2,e),2097152<=a?(e=a>>21|128,this.view.setUint8(b+3,e),268435456<=a?(this.view.setUint8(b+4,a>>28&15),e=5):(this.view.setUint8(b+3,e&127),e=4)):(this.view.setUint8(b+2,e&127),e=3)):(this.view.setUint8(b+1,e&127),e=2)):(this.view.setUint8(b,e&127),e=1);return c?(this.offset+=e,this):e};d.prototype.writeVarint32ZigZag=function(a,b){return this.writeVarint32(d.zigZagEncode32(a),b)};d.prototype.readVarint32=
function(a){var b="undefined"===typeof a;b&&(a=this.offset);if(!this.noAssert){if("number"!==typeof a||0!==a%1)throw new TypeError("Illegal offset: "+a+" (not an integer)");a>>>=0;if(0>a||a+1>this.buffer.byteLength)throw new RangeError("Illegal offset: 0 <= "+a+" (+1) <= "+this.buffer.byteLength);}var c=0,e=0,d;do d=this.view.getUint8(a+c),5>c&&(e|=(d&127)<<7*c>>>0),++c;while(128===(d&128));e|=0;return b?(this.offset+=c,e):{value:e,length:c}};d.prototype.readVarint32ZigZag=function(a){a=this.readVarint32(a);
"object"===typeof a?a.value=d.zigZagDecode32(a.value):a=d.zigZagDecode32(a);return a};l&&(d.MAX_VARINT64_BYTES=10,d.calculateVarint64=function(a){"number"===typeof a&&(a=l.fromNumber(a));var b=a.toInt()>>>0,c=a.shiftRightUnsigned(28).toInt()>>>0;a=a.shiftRightUnsigned(56).toInt()>>>0;return 0==a?0==c?16384>b?128>b?1:2:2097152>b?3:4:16384>c?128>c?5:6:2097152>c?7:8:128>a?9:10},d.zigZagEncode64=function(a){"number"===typeof a?a=l.fromNumber(a,!1):!1!==a.unsigned&&(a=a.toSigned());return a.shiftLeft(1).xor(a.shiftRight(63)).toUnsigned()},
d.zigZagDecode64=function(a){"number"===typeof a?a=l.fromNumber(a,!1):!1!==a.unsigned&&(a=a.toSigned());return a.shiftRightUnsigned(1).xor(a.and(l.ONE).toSigned().negate()).toSigned()},d.prototype.writeVarint64=function(a,b){var c="undefined"===typeof b;c&&(b=this.offset);if(!this.noAssert){if("number"===typeof a)a=l.fromNumber(a);else if(!(a&&a instanceof l))throw new TypeError("Illegal value: "+a+" (not an integer or Long)");if("number"!==typeof b||0!==b%1)throw new TypeError("Illegal offset: "+
b+" (not an integer)");b>>>=0;if(0>b||b+0>this.buffer.byteLength)throw new RangeError("Illegal offset: 0 <= "+b+" (+0) <= "+this.buffer.byteLength);}"number"===typeof a?a=l.fromNumber(a,!1):!1!==a.unsigned&&(a=a.toSigned());var e=d.calculateVarint64(a),h=a.toInt()>>>0,f=a.shiftRightUnsigned(28).toInt()>>>0,g=a.shiftRightUnsigned(56).toInt()>>>0;b+=e;var n=this.buffer.byteLength;b>n&&this.resize((n*=2)>b?n:b);b-=e;switch(e){case 10:this.view.setUint8(b+9,g>>>7&1);case 9:this.view.setUint8(b+8,9!==
e?g|128:g&127);case 8:this.view.setUint8(b+7,8!==e?f>>>21|128:f>>>21&127);case 7:this.view.setUint8(b+6,7!==e?f>>>14|128:f>>>14&127);case 6:this.view.setUint8(b+5,6!==e?f>>>7|128:f>>>7&127);case 5:this.view.setUint8(b+4,5!==e?f|128:f&127);case 4:this.view.setUint8(b+3,4!==e?h>>>21|128:h>>>21&127);case 3:this.view.setUint8(b+2,3!==e?h>>>14|128:h>>>14&127);case 2:this.view.setUint8(b+1,2!==e?h>>>7|128:h>>>7&127);case 1:this.view.setUint8(b,1!==e?h|128:h&127)}return c?(this.offset+=e,this):e},d.prototype.writeVarint64ZigZag=
function(a,b){return this.writeVarint64(d.zigZagEncode64(a),b)},d.prototype.readVarint64=function(a){var b="undefined"===typeof a;b&&(a=this.offset);if(!this.noAssert){if("number"!==typeof a||0!==a%1)throw new TypeError("Illegal offset: "+a+" (not an integer)");a>>>=0;if(0>a||a+1>this.buffer.byteLength)throw new RangeError("Illegal offset: 0 <= "+a+" (+1) <= "+this.buffer.byteLength);}var c=a,e=0,d=0,f=0,g=0,g=this.view.getUint8(a++),e=g&127;if(g&128&&(g=this.view.getUint8(a++),e|=(g&127)<<7,g&128&&
(g=this.view.getUint8(a++),e|=(g&127)<<14,g&128&&(g=this.view.getUint8(a++),e|=(g&127)<<21,g&128&&(g=this.view.getUint8(a++),d=g&127,g&128&&(g=this.view.getUint8(a++),d|=(g&127)<<7,g&128&&(g=this.view.getUint8(a++),d|=(g&127)<<14,g&128&&(g=this.view.getUint8(a++),d|=(g&127)<<21,g&128&&(g=this.view.getUint8(a++),f=g&127,g&128&&(g=this.view.getUint8(a++),f|=(g&127)<<7,g&128))))))))))throw Error("Data must be corrupt: Buffer overrun");e=l.from28Bits(e,d,f,!1);return b?(this.offset=a,e):{value:e,length:a-
c}},d.prototype.readVarint64ZigZag=function(a){(a=this.readVarint64(a))&&a.value instanceof l?a.value=d.zigZagDecode64(a.value):a=d.zigZagDecode64(a);return a});d.prototype.writeCString=function(a,b){var c="undefined"===typeof b;c&&(b=this.offset);var e,d=a.length;if(!this.noAssert){if("string"!==typeof a)throw new TypeError("Illegal str: Not a string");for(e=0;e<d;++e)if(0===a.charCodeAt(e))throw new RangeError("Illegal str: Contains NULL-characters");if("number"!==typeof b||0!==b%1)throw new TypeError("Illegal offset: "+
b+" (not an integer)");b>>>=0;if(0>b||b+0>this.buffer.byteLength)throw new RangeError("Illegal offset: 0 <= "+b+" (+0) <= "+this.buffer.byteLength);}e=b;d=k.b(k.a(a))[1];b+=d+1;var f=this.buffer.byteLength;b>f&&this.resize((f*=2)>b?f:b);b-=d+1;k.e(k.a(a),function(a){this.view.setUint8(b++,a)}.bind(this));this.view.setUint8(b++,0);return c?(this.offset=b-e,this):d};d.prototype.readCString=function(a){var b="undefined"===typeof a;b&&(a=this.offset);if(!this.noAssert){if("number"!==typeof a||0!==a%1)throw new TypeError("Illegal offset: "+
a+" (not an integer)");a>>>=0;if(0>a||a+1>this.buffer.byteLength)throw new RangeError("Illegal offset: 0 <= "+a+" (+1) <= "+this.buffer.byteLength);}var c=a,e,d=-1;k.d(function(){if(0===d)return null;if(a>=this.limit)throw RangeError("Illegal range: Truncated data, "+a+" < "+this.limit);return 0===(d=this.view.getUint8(a++))?null:d}.bind(this),e=k.c(),!0);return b?(this.offset=a,e()):{string:e(),length:a-c}};d.prototype.writeIString=function(a,b){var c="undefined"===typeof b;c&&(b=this.offset);if(!this.noAssert){if("string"!==
typeof a)throw new TypeError("Illegal str: Not a string");if("number"!==typeof b||0!==b%1)throw new TypeError("Illegal offset: "+b+" (not an integer)");b>>>=0;if(0>b||b+0>this.buffer.byteLength)throw new RangeError("Illegal offset: 0 <= "+b+" (+0) <= "+this.buffer.byteLength);}var e=b,d;d=k.b(k.a(a),this.noAssert)[1];b+=4+d;var f=this.buffer.byteLength;b>f&&this.resize((f*=2)>b?f:b);b-=4+d;this.view.setUint32(b,d,this.littleEndian);b+=4;k.e(k.a(a),function(a){this.view.setUint8(b++,a)}.bind(this));
if(b!==e+4+d)throw new RangeError("Illegal range: Truncated data, "+b+" == "+(b+4+d));return c?(this.offset=b,this):b-e};d.prototype.readIString=function(a){var b="undefined"===typeof a;b&&(a=this.offset);if(!this.noAssert){if("number"!==typeof a||0!==a%1)throw new TypeError("Illegal offset: "+a+" (not an integer)");a>>>=0;if(0>a||a+4>this.buffer.byteLength)throw new RangeError("Illegal offset: 0 <= "+a+" (+4) <= "+this.buffer.byteLength);}var c=0,e=a,c=this.view.getUint32(a,this.littleEndian);a+=
4;var d=a+c;k.d(function(){return a<d?this.view.getUint8(a++):null}.bind(this),c=k.c(),this.noAssert);c=c();return b?(this.offset=a,c):{string:c,length:a-e}};d.METRICS_CHARS="c";d.METRICS_BYTES="b";d.prototype.writeUTF8String=function(a,b){var c="undefined"===typeof b;c&&(b=this.offset);if(!this.noAssert){if("number"!==typeof b||0!==b%1)throw new TypeError("Illegal offset: "+b+" (not an integer)");b>>>=0;if(0>b||b+0>this.buffer.byteLength)throw new RangeError("Illegal offset: 0 <= "+b+" (+0) <= "+
this.buffer.byteLength);}var e,d=b;e=k.b(k.a(a))[1];b+=e;var f=this.buffer.byteLength;b>f&&this.resize((f*=2)>b?f:b);b-=e;k.e(k.a(a),function(a){this.view.setUint8(b++,a)}.bind(this));return c?(this.offset=b,this):b-d};d.prototype.writeString=d.prototype.writeUTF8String;d.calculateUTF8Chars=function(a){return k.b(k.a(a))[0]};d.calculateUTF8Bytes=function(a){return k.b(k.a(a))[1]};d.prototype.readUTF8String=function(a,b,c){"number"===typeof b&&(c=b,b=void 0);var e="undefined"===typeof c;e&&(c=this.offset);
"undefined"===typeof b&&(b=d.METRICS_CHARS);if(!this.noAssert){if("number"!==typeof a||0!==a%1)throw new TypeError("Illegal length: "+a+" (not an integer)");a|=0;if("number"!==typeof c||0!==c%1)throw new TypeError("Illegal offset: "+c+" (not an integer)");c>>>=0;if(0>c||c+0>this.buffer.byteLength)throw new RangeError("Illegal offset: 0 <= "+c+" (+0) <= "+this.buffer.byteLength);}var h=0,f=c,g;if(b===d.METRICS_CHARS){g=k.c();k.i(function(){return h<a&&c<this.limit?this.view.getUint8(c++):null}.bind(this),
function(a){++h;k.g(a,g)}.bind(this));if(h!==a)throw new RangeError("Illegal range: Truncated data, "+h+" == "+a);return e?(this.offset=c,g()):{string:g(),length:c-f}}if(b===d.METRICS_BYTES){if(!this.noAssert){if("number"!==typeof c||0!==c%1)throw new TypeError("Illegal offset: "+c+" (not an integer)");c>>>=0;if(0>c||c+a>this.buffer.byteLength)throw new RangeError("Illegal offset: 0 <= "+c+" (+"+a+") <= "+this.buffer.byteLength);}var n=c+a;k.d(function(){return c<n?this.view.getUint8(c++):null}.bind(this),
g=k.c(),this.noAssert);if(c!==n)throw new RangeError("Illegal range: Truncated data, "+c+" == "+n);return e?(this.offset=c,g()):{string:g(),length:c-f}}throw new TypeError("Unsupported metrics: "+b);};d.prototype.readString=d.prototype.readUTF8String;d.prototype.writeVString=function(a,b){var c="undefined"===typeof b;c&&(b=this.offset);if(!this.noAssert){if("string"!==typeof a)throw new TypeError("Illegal str: Not a string");if("number"!==typeof b||0!==b%1)throw new TypeError("Illegal offset: "+b+
" (not an integer)");b>>>=0;if(0>b||b+0>this.buffer.byteLength)throw new RangeError("Illegal offset: 0 <= "+b+" (+0) <= "+this.buffer.byteLength);}var e=b,h,f;h=k.b(k.a(a),this.noAssert)[1];f=d.calculateVarint32(h);b+=f+h;var g=this.buffer.byteLength;b>g&&this.resize((g*=2)>b?g:b);b-=f+h;b+=this.writeVarint32(h,b);k.e(k.a(a),function(a){this.view.setUint8(b++,a)}.bind(this));if(b!==e+h+f)throw new RangeError("Illegal range: Truncated data, "+b+" == "+(b+h+f));return c?(this.offset=b,this):b-e};d.prototype.readVString=
function(a){var b="undefined"===typeof a;b&&(a=this.offset);if(!this.noAssert){if("number"!==typeof a||0!==a%1)throw new TypeError("Illegal offset: "+a+" (not an integer)");a>>>=0;if(0>a||a+1>this.buffer.byteLength)throw new RangeError("Illegal offset: 0 <= "+a+" (+1) <= "+this.buffer.byteLength);}var c=this.readVarint32(a),e=a;a+=c.length;var c=c.value,d=a+c,c=k.c();k.d(function(){return a<d?this.view.getUint8(a++):null}.bind(this),c,this.noAssert);c=c();return b?(this.offset=a,c):{string:c,length:a-
e}};d.prototype.append=function(a,b,c){if("number"===typeof b||"string"!==typeof b)c=b,b=void 0;var e="undefined"===typeof c;e&&(c=this.offset);if(!this.noAssert){if("number"!==typeof c||0!==c%1)throw new TypeError("Illegal offset: "+c+" (not an integer)");c>>>=0;if(0>c||c+0>this.buffer.byteLength)throw new RangeError("Illegal offset: 0 <= "+c+" (+0) <= "+this.buffer.byteLength);}a instanceof d||(a=d.wrap(a,b));b=a.limit-a.offset;if(0>=b)return this;c+=b;var h=this.buffer.byteLength;c>h&&this.resize((h*=
2)>c?h:c);(new Uint8Array(this.buffer,c-b)).set((new Uint8Array(a.buffer)).subarray(a.offset,a.limit));a.offset+=b;e&&(this.offset+=b);return this};d.prototype.appendTo=function(a,b){a.append(this,b);return this};d.prototype.assert=function(a){this.noAssert=!a;return this};d.prototype.capacity=function(){return this.buffer.byteLength};d.prototype.clear=function(){this.offset=0;this.limit=this.buffer.byteLength;this.markedOffset=-1;return this};d.prototype.clone=function(a){var b=new d(0,this.littleEndian,
this.noAssert);a?(a=new ArrayBuffer(this.buffer.byteLength),(new Uint8Array(a)).set(this.buffer),b.buffer=a,b.view=new DataView(a)):(b.buffer=this.buffer,b.view=this.view);b.offset=this.offset;b.markedOffset=this.markedOffset;b.limit=this.limit;return b};d.prototype.compact=function(a,b){"undefined"===typeof a&&(a=this.offset);"undefined"===typeof b&&(b=this.limit);if(!this.noAssert){if("number"!==typeof a||0!==a%1)throw new TypeError("Illegal begin: Not an integer");a>>>=0;if("number"!==typeof b||
0!==b%1)throw new TypeError("Illegal end: Not an integer");b>>>=0;if(0>a||a>b||b>this.buffer.byteLength)throw new RangeError("Illegal range: 0 <= "+a+" <= "+b+" <= "+this.buffer.byteLength);}if(0===a&&b===this.buffer.byteLength)return this;var c=b-a;if(0===c)return this.buffer=r,this.view=null,0<=this.markedOffset&&(this.markedOffset-=a),this.limit=this.offset=0,this;var e=new ArrayBuffer(c);(new Uint8Array(e)).set((new Uint8Array(this.buffer)).subarray(a,b));this.buffer=e;this.view=new DataView(e);
0<=this.markedOffset&&(this.markedOffset-=a);this.offset=0;this.limit=c;return this};d.prototype.copy=function(a,b){"undefined"===typeof a&&(a=this.offset);"undefined"===typeof b&&(b=this.limit);if(!this.noAssert){if("number"!==typeof a||0!==a%1)throw new TypeError("Illegal begin: Not an integer");a>>>=0;if("number"!==typeof b||0!==b%1)throw new TypeError("Illegal end: Not an integer");b>>>=0;if(0>a||a>b||b>this.buffer.byteLength)throw new RangeError("Illegal range: 0 <= "+a+" <= "+b+" <= "+this.buffer.byteLength);
}if(a===b)return new d(0,this.littleEndian,this.noAssert);var c=b-a,e=new d(c,this.littleEndian,this.noAssert);e.offset=0;e.limit=c;0<=e.markedOffset&&(e.markedOffset-=a);this.copyTo(e,0,a,b);return e};d.prototype.copyTo=function(a,b,c,e){var h,f;if(!this.noAssert&&!d.isByteBuffer(a))throw new TypeError("Illegal target: Not a ByteBuffer");b=(f="undefined"===typeof b)?a.offset:b|0;c=(h="undefined"===typeof c)?this.offset:c|0;e="undefined"===typeof e?this.limit:e|0;if(0>b||b>a.buffer.byteLength)throw new RangeError("Illegal target range: 0 <= "+
b+" <= "+a.buffer.byteLength);if(0>c||e>this.buffer.byteLength)throw new RangeError("Illegal source range: 0 <= "+c+" <= "+this.buffer.byteLength);var g=e-c;if(0===g)return a;a.ensureCapacity(b+g);(new Uint8Array(a.buffer)).set((new Uint8Array(this.buffer)).subarray(c,e),b);h&&(this.offset+=g);f&&(a.offset+=g);return this};d.prototype.ensureCapacity=function(a){var b=this.buffer.byteLength;return b<a?this.resize((b*=2)>a?b:a):this};d.prototype.fill=function(a,b,c){var e="undefined"===typeof b;e&&
(b=this.offset);"string"===typeof a&&0<a.length&&(a=a.charCodeAt(0));"undefined"===typeof b&&(b=this.offset);"undefined"===typeof c&&(c=this.limit);if(!this.noAssert){if("number"!==typeof a||0!==a%1)throw new TypeError("Illegal value: "+a+" (not an integer)");a|=0;if("number"!==typeof b||0!==b%1)throw new TypeError("Illegal begin: Not an integer");b>>>=0;if("number"!==typeof c||0!==c%1)throw new TypeError("Illegal end: Not an integer");c>>>=0;if(0>b||b>c||c>this.buffer.byteLength)throw new RangeError("Illegal range: 0 <= "+
b+" <= "+c+" <= "+this.buffer.byteLength);}if(b>=c)return this;for(;b<c;)this.view.setUint8(b++,a);e&&(this.offset=b);return this};d.prototype.flip=function(){this.limit=this.offset;this.offset=0;return this};d.prototype.mark=function(a){a="undefined"===typeof a?this.offset:a;if(!this.noAssert){if("number"!==typeof a||0!==a%1)throw new TypeError("Illegal offset: "+a+" (not an integer)");a>>>=0;if(0>a||a+0>this.buffer.byteLength)throw new RangeError("Illegal offset: 0 <= "+a+" (+0) <= "+this.buffer.byteLength);
}this.markedOffset=a;return this};d.prototype.order=function(a){if(!this.noAssert&&"boolean"!==typeof a)throw new TypeError("Illegal littleEndian: Not a boolean");this.littleEndian=!!a;return this};d.prototype.LE=function(a){this.littleEndian="undefined"!==typeof a?!!a:!0;return this};d.prototype.BE=function(a){this.littleEndian="undefined"!==typeof a?!a:!1;return this};d.prototype.prepend=function(a,b,c){if("number"===typeof b||"string"!==typeof b)c=b,b=void 0;var e="undefined"===typeof c;e&&(c=
this.offset);if(!this.noAssert){if("number"!==typeof c||0!==c%1)throw new TypeError("Illegal offset: "+c+" (not an integer)");c>>>=0;if(0>c||c+0>this.buffer.byteLength)throw new RangeError("Illegal offset: 0 <= "+c+" (+0) <= "+this.buffer.byteLength);}a instanceof d||(a=d.wrap(a,b));b=a.limit-a.offset;if(0>=b)return this;var h=b-c,f;if(0<h){var g=new ArrayBuffer(this.buffer.byteLength+h);f=new Uint8Array(g);f.set((new Uint8Array(this.buffer)).subarray(c,this.buffer.byteLength),b);this.buffer=g;this.view=
new DataView(g);this.offset+=h;0<=this.markedOffset&&(this.markedOffset+=h);this.limit+=h;c+=h}else f=new Uint8Array(this.buffer);f.set((new Uint8Array(a.buffer)).subarray(a.offset,a.limit),c-b);a.offset=a.limit;e&&(this.offset-=b);return this};d.prototype.prependTo=function(a,b){a.prepend(this,b);return this};d.prototype.printDebug=function(a){"function"!==typeof a&&(a=console.log.bind(console));a(this.toString()+"\n-------------------------------------------------------------------\n"+this.toDebug(!0))};
d.prototype.remaining=function(){return this.limit-this.offset};d.prototype.reset=function(){0<=this.markedOffset?(this.offset=this.markedOffset,this.markedOffset=-1):this.offset=0;return this};d.prototype.resize=function(a){if(!this.noAssert){if("number"!==typeof a||0!==a%1)throw new TypeError("Illegal capacity: "+a+" (not an integer)");a|=0;if(0>a)throw new RangeError("Illegal capacity: 0 <= "+a);}this.buffer.byteLength<a&&(a=new ArrayBuffer(a),(new Uint8Array(a)).set(new Uint8Array(this.buffer)),
this.buffer=a,this.view=new DataView(a));return this};d.prototype.reverse=function(a,b){"undefined"===typeof a&&(a=this.offset);"undefined"===typeof b&&(b=this.limit);if(!this.noAssert){if("number"!==typeof a||0!==a%1)throw new TypeError("Illegal begin: Not an integer");a>>>=0;if("number"!==typeof b||0!==b%1)throw new TypeError("Illegal end: Not an integer");b>>>=0;if(0>a||a>b||b>this.buffer.byteLength)throw new RangeError("Illegal range: 0 <= "+a+" <= "+b+" <= "+this.buffer.byteLength);}if(a===b)return this;
Array.prototype.reverse.call((new Uint8Array(this.buffer)).subarray(a,b));this.view=new DataView(this.buffer);return this};d.prototype.skip=function(a){if(!this.noAssert){if("number"!==typeof a||0!==a%1)throw new TypeError("Illegal length: "+a+" (not an integer)");a|=0}var b=this.offset+a;if(!this.noAssert&&(0>b||b>this.buffer.byteLength))throw new RangeError("Illegal length: 0 <= "+this.offset+" + "+a+" <= "+this.buffer.byteLength);this.offset=b;return this};d.prototype.slice=function(a,b){"undefined"===
typeof a&&(a=this.offset);"undefined"===typeof b&&(b=this.limit);if(!this.noAssert){if("number"!==typeof a||0!==a%1)throw new TypeError("Illegal begin: Not an integer");a>>>=0;if("number"!==typeof b||0!==b%1)throw new TypeError("Illegal end: Not an integer");b>>>=0;if(0>a||a>b||b>this.buffer.byteLength)throw new RangeError("Illegal range: 0 <= "+a+" <= "+b+" <= "+this.buffer.byteLength);}var c=this.clone();c.offset=a;c.limit=b;return c};d.prototype.toBuffer=function(a){var b=this.offset,c=this.limit;
if(b>c)var e=b,b=c,c=e;if(!this.noAssert){if("number"!==typeof b||0!==b%1)throw new TypeError("Illegal offset: Not an integer");b>>>=0;if("number"!==typeof c||0!==c%1)throw new TypeError("Illegal limit: Not an integer");c>>>=0;if(0>b||b>c||c>this.buffer.byteLength)throw new RangeError("Illegal range: 0 <= "+b+" <= "+c+" <= "+this.buffer.byteLength);}if(!a&&0===b&&c===this.buffer.byteLength)return this.buffer;if(b===c)return r;a=new ArrayBuffer(c-b);(new Uint8Array(a)).set((new Uint8Array(this.buffer)).subarray(b,
c),0);return a};d.prototype.toArrayBuffer=d.prototype.toBuffer;d.prototype.toString=function(a){if("undefined"===typeof a)return"ByteBufferAB(offset="+this.offset+",markedOffset="+this.markedOffset+",limit="+this.limit+",capacity="+this.capacity()+")";switch(a){case "utf8":return this.toUTF8();case "base64":return this.toBase64();case "hex":return this.toHex();case "binary":return this.toBinary();case "debug":return this.toDebug();case "columns":return this.o();default:throw Error("Unsupported encoding: "+
a);}};var m="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",m=m+"";d.prototype.toBase64=function(a,b){"undefined"===typeof a&&(a=this.offset);"undefined"===typeof b&&(b=this.limit);if(!this.noAssert){if("number"!==typeof a||0!==a%1)throw new TypeError("Illegal begin: Not an integer");a>>>=0;if("number"!==typeof b||0!==b%1)throw new TypeError("Illegal end: Not an integer");b>>>=0;if(0>a||a>b||b>this.buffer.byteLength)throw new RangeError("Illegal range: 0 <= "+a+" <= "+b+" <= "+
this.buffer.byteLength);}if(a===b)return"";for(var c,e,d,f,g,k,l="";a<b;)c=this.view.getUint8(a++),e=(f=a<b)?this.view.getUint8(a++):0,d=(g=a<b)?this.view.getUint8(a++):0,k=c>>2,c=(c&3)<<4|e>>4,e=(e&15)<<2|d>>6,d&=63,g||(d=64,f||(e=64)),l+=m.charAt(k)+m.charAt(c)+m.charAt(e)+m.charAt(d);return l};d.fromBase64=function(a,b,c){if(!c){if("string"!==typeof a)throw new TypeError("Illegal str: Not a string");if(0!==a.length%4)throw new TypeError("Illegal str: Length not a multiple of 4");}var e=a.length,
h=0,f;for(f=a.length-1;0<=f;--f)if("="===a.charAt(f))h++;else break;if(2<h)throw new TypeError("Illegal str: Suffix is too large");if(0===e)return new d(0,b,c);var g,k,l,p=new d(e/4*3-h,b,c);for(b=f=0;f<e;){h=m.indexOf(a.charAt(f++));g=f<e?m.indexOf(a.charAt(f++)):0;k=f<e?m.indexOf(a.charAt(f++)):0;l=f<e?m.indexOf(a.charAt(f++)):0;if(!c&&(0>h||0>g||0>k||0>l))throw new TypeError("Illegal str: Contains non-base64 characters");p.view.setUint8(b++,h<<2|g>>4);64!==k&&(p.view.setUint8(b++,g<<4&240|k>>2,
b),64!==l&&p.view.setUint8(b++,k<<6&192|l))}p.limit=b;return p};d.btoa=function(a){return d.fromBinary(a).toBase64()};d.atob=function(a){return d.fromBase64(a).toBinary()};d.prototype.toBinary=function(a,b){a="undefined"===typeof a?this.offset:a;b="undefined"===typeof b?this.limit:b;if(!this.noAssert){if("number"!==typeof a||0!==a%1)throw new TypeError("Illegal begin: Not an integer");a>>>=0;if("number"!==typeof b||0!==b%1)throw new TypeError("Illegal end: Not an integer");b>>>=0;if(0>a||a>b||b>this.buffer.byteLength)throw new RangeError("Illegal range: 0 <= "+
a+" <= "+b+" <= "+this.buffer.byteLength);}if(a===b)return"";for(var c=[];a<b;)c.push(this.view.getUint8(a++));return String.fromCharCode.apply(String,c)};d.fromBinary=function(a,b,c){if(!c&&"string"!==typeof a)throw new TypeError("Illegal str: Not a string");for(var e=0,h=a.length,f=new d(h,b,c);e<h;){b=a.charCodeAt(e);if(!c&&255<b)throw new TypeError("Illegal charCode at "+e+": 0 <= "+b+" <= 255");f.view.setUint8(e++,b)}f.limit=h;return f};d.prototype.toDebug=function(a){for(var b=-1,c=this.buffer.byteLength,
e,d="",f="",g="";b<c;){-1!==b&&(e=this.view.getUint8(b),d=16>e?d+("0"+e.toString(16).toUpperCase()):d+e.toString(16).toUpperCase(),a&&(f+=32<e&&127>e?String.fromCharCode(e):"."));++b;if(a&&0<b&&0===b%16&&b!==c){for(;51>d.length;)d+=" ";g+=d+f+"\n";d=f=""}d=b===this.offset&&b===this.limit?d+(b===this.markedOffset?"!":"|"):b===this.offset?d+(b===this.markedOffset?"[":"<"):b===this.limit?d+(b===this.markedOffset?"]":">"):d+(b===this.markedOffset?"'":a||0!==b&&b!==c?" ":"")}if(a&&" "!==d){for(;51>d.length;)d+=
" ";g+=d+f+"\n"}return a?g:d};d.fromDebug=function(a,b,c){var e=a.length;b=new d((e+1)/3|0,b,c);for(var h=0,f=0,g,k=!1,l=!1,p=!1,m=!1,q=!1;h<e;){switch(g=a.charAt(h++)){case "!":if(!c){if(l||p||m){q=!0;break}l=p=m=!0}b.offset=b.markedOffset=b.limit=f;k=!1;break;case "|":if(!c){if(l||m){q=!0;break}l=m=!0}b.offset=b.limit=f;k=!1;break;case "[":if(!c){if(l||p){q=!0;break}l=p=!0}b.offset=b.markedOffset=f;k=!1;break;case "<":if(!c){if(l){q=!0;break}l=!0}b.offset=f;k=!1;break;case "]":if(!c){if(m||p){q=
!0;break}m=p=!0}b.limit=b.markedOffset=f;k=!1;break;case ">":if(!c){if(m){q=!0;break}m=!0}b.limit=f;k=!1;break;case "'":if(!c){if(p){q=!0;break}p=!0}b.markedOffset=f;k=!1;break;case " ":k=!1;break;default:if(!c&&k){q=!0;break}g=parseInt(g+a.charAt(h++),16);if(!c&&(isNaN(g)||0>g||255<g))throw new TypeError("Illegal str: Not a debug encoded string");b.view.setUint8(f++,g);k=!0}if(q)throw new TypeError("Illegal str: Invalid symbol at "+h);}if(!c){if(!l||!m)throw new TypeError("Illegal str: Missing offset or limit");
if(f<b.buffer.byteLength)throw new TypeError("Illegal str: Not a debug encoded string (is it hex?) "+f+" < "+e);}return b};d.prototype.toHex=function(a,b){a="undefined"===typeof a?this.offset:a;b="undefined"===typeof b?this.limit:b;if(!this.noAssert){if("number"!==typeof a||0!==a%1)throw new TypeError("Illegal begin: Not an integer");a>>>=0;if("number"!==typeof b||0!==b%1)throw new TypeError("Illegal end: Not an integer");b>>>=0;if(0>a||a>b||b>this.buffer.byteLength)throw new RangeError("Illegal range: 0 <= "+
a+" <= "+b+" <= "+this.buffer.byteLength);}for(var c=Array(b-a),e;a<b;)e=this.view.getUint8(a++),16>e?c.push("0",e.toString(16)):c.push(e.toString(16));return c.join("")};d.fromHex=function(a,b,c){if(!c){if("string"!==typeof a)throw new TypeError("Illegal str: Not a string");if(0!==a.length%2)throw new TypeError("Illegal str: Length not a multiple of 2");}var e=a.length;b=new d(e/2|0,b);for(var h,f=0,g=0;f<e;f+=2){h=parseInt(a.substring(f,f+2),16);if(!c&&(!isFinite(h)||0>h||255<h))throw new TypeError("Illegal str: Contains non-hex characters");
b.view.setUint8(g++,h)}b.limit=g;return b};var k=function(){var a={j:function(a,c){var e=null;"number"===typeof a&&(e=a,a=function(){return null});for(;null!==e||null!==(e=a());)128>e?c(e&127):(2048>e?c(e>>6&31|192):(65536>e?c(e>>12&15|224):(c(e>>18&7|240),c(e>>12&63|128)),c(e>>6&63|128)),c(e&63|128)),e=null},i:function(a,c){function e(a){a=a.slice(0,a.indexOf(null));var b=Error(a.toString());b.name="TruncatedError";b.bytes=a;throw b;}for(var d,f,g,k;null!==(d=a());)if(0===(d&128))c(d);else if(192===
(d&224))null===(f=a())&&e([d,f]),c((d&31)<<6|f&63);else if(224===(d&240))null!==(f=a())&&null!==(g=a())||e([d,f,g]),c((d&15)<<12|(f&63)<<6|g&63);else if(240===(d&248))null!==(f=a())&&null!==(g=a())&&null!==(k=a())||e([d,f,g,k]),c((d&7)<<18|(f&63)<<12|(g&63)<<6|k&63);else throw RangeError("Illegal starting byte: "+d);},f:function(a,c){for(var e,d=null;null!==(e=null!==d?d:a());)55296<=e&&57343>=e&&null!==(d=a())&&56320<=d&&57343>=d?(c(1024*(e-55296)+d-56320+65536),d=null):c(e);null!==d&&c(d)},g:function(a,
c){var e=null;"number"===typeof a&&(e=a,a=function(){return null});for(;null!==e||null!==(e=a());)65535>=e?c(e):(e-=65536,c((e>>10)+55296),c(e%1024+56320)),e=null},e:function(b,c){a.f(b,function(b){a.j(b,c)})},d:function(b,c){a.i(b,function(b){a.g(b,c)})},k:function(a){if("number"!==typeof a||a!==a)throw TypeError("Illegal byte: "+typeof a);if(-128>a||255<a)throw RangeError("Illegal byte: "+a);return a},l:function(a){if("number"!==typeof a||a!==a)throw TypeError("Illegal char code: "+typeof a);if(0>
a||65535<a)throw RangeError("Illegal char code: "+a);return a},m:function(a){if("number"!==typeof a||a!==a)throw TypeError("Illegal code point: "+typeof a);if(0>a||1114111<a)throw RangeError("Illegal code point: "+a);return a},h:function(a){return 128>a?1:2048>a?2:65536>a?3:4},n:function(b){for(var c,d=0;null!==(c=b());)d+=a.h(c);return d},b:function(b){var c=0,d=0;a.f(b,function(b){++c;d+=a.h(b)});return[c,d]}};return a}(),s=String.fromCharCode;k.a=function(a){var b=0;return function(){return b<
a.length?a.charCodeAt(b++):null}};k.c=function(){var a=[],b=[];return function(){if(0===arguments.length)return b.join("")+s.apply(String,a);1024<a.length+arguments.length&&(b.push(s.apply(String,a)),a.length=0);Array.prototype.push.apply(a,arguments)}};d.prototype.toUTF8=function(a,b){"undefined"===typeof a&&(a=this.offset);"undefined"===typeof b&&(b=this.limit);if(!this.noAssert){if("number"!==typeof a||0!==a%1)throw new TypeError("Illegal begin: Not an integer");a>>>=0;if("number"!==typeof b||
0!==b%1)throw new TypeError("Illegal end: Not an integer");b>>>=0;if(0>a||a>b||b>this.buffer.byteLength)throw new RangeError("Illegal range: 0 <= "+a+" <= "+b+" <= "+this.buffer.byteLength);}var c=this,d;try{k.d(function(){return a<b?c.view.getUint8(a++):null},d=k.c())}catch(h){if(a!==b)throw new RangeError("Illegal range: Truncated data, "+a+" != "+b);}return d()};d.fromUTF8=function(a,b,c){if(!c&&"string"!==typeof a)throw new TypeError("Illegal str: Not a string");var e=new d(k.b(k.a(a),!0)[1],
b,c),h=0;k.e(k.a(a),function(a){e.view.setUint8(h++,a)});e.limit=h;return e};return d}"undefined"!=typeof module&&module.exports?module.exports=s(require("long")):"undefined"!==typeof define&&define.amd?define("ByteBuffer",["Math/Long"],function(l){return s(l)}):(r.dcodeIO||(r.dcodeIO={}),r.dcodeIO.ByteBuffer=s(r.dcodeIO.Long))})(this);

},{"long":56}],55:[function(require,module,exports){
/*
 Copyright 2013 Daniel Wirtz <dcode@dcode.io>
 Copyright 2009 The Closure Library Authors. All Rights Reserved.

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS-IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 */
/**
 * @license Long.js (c) 2013 Daniel Wirtz <dcode@dcode.io>
 * Released under the Apache License, Version 2.0
 * Derived from goog.math.Long from the Closure Library
 * see: https://github.com/dcodeIO/Long.js for details
 */
(function(global) {
    "use strict";

    /**
     * Constructs a 64-bit two's-complement integer, given its low and high 32-bit
     * values as *signed* integers.  See the from* functions below for more
     * convenient ways of constructing Longs.
     *
     * The internal representation of a long is the two given signed, 32-bit values.
     * We use 32-bit pieces because these are the size of integers on which
     * Javascript performs bit-operations.  For operations like addition and
     * multiplication, we split each number into 16-bit pieces, which can easily be
     * multiplied within Javascript's floating-point representation without overflow
     * or change in sign.
     *
     * In the algorithms below, we frequently reduce the negative case to the
     * positive case by negating the input(s) and then post-processing the result.
     * Note that we must ALWAYS check specially whether those values are MIN_VALUE
     * (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as
     * a positive number, it overflows back into a negative).  Not handling this
     * case would often result in infinite recursion.
     * 
     * @exports Long
     * @class A Long class for representing a 64-bit two's-complement integer value.
     * @param {number|!{low: number, high: number, unsigned: boolean}} low The low (signed) 32 bits of the long.
     *  Optionally accepts a Long-like object as the first parameter.
     * @param {number=} high The high (signed) 32 bits of the long.
     * @param {boolean=} unsigned Whether unsigned or not. Defaults to `false` (signed).
     * @constructor
     */
    var Long = function(low, high, unsigned) {
        if (low && typeof low === 'object') {
            high = low.high;
            unsigned = low.unsigned;
            low = low.low;
        }
        
        /**
         * The low 32 bits as a signed value.
         * @type {number}
         * @expose
         */
        this.low = low | 0;

        /**
         * The high 32 bits as a signed value.
         * @type {number}
         * @expose
         */
        this.high = high | 0;

        /**
         * Whether unsigned or not.
         * @type {boolean}
         * @expose
         */
        this.unsigned = !!unsigned;
    };

    // NOTE: Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from* methods on which they depend.

    // NOTE: The following cache variables are used internally only and are therefore not exposed as properties of the
    // Long class.
    
    /**
     * A cache of the Long representations of small integer values.
     * @type {!Object}
     */
    var INT_CACHE = {};

    /**
     * A cache of the Long representations of small unsigned integer values.
     * @type {!Object}
     */
    var UINT_CACHE = {};

    /**
     * Returns a Long representing the given (32-bit) integer value.
     * @param {number} value The 32-bit integer in question.
     * @param {boolean=} unsigned Whether unsigned or not. Defaults to false (signed).
     * @return {!Long} The corresponding Long value.
     * @expose
     */
    Long.fromInt = function(value, unsigned) {
        var obj, cachedObj;
        if (!unsigned) {
            value = value | 0;
            if (-128 <= value && value < 128) {
                cachedObj = INT_CACHE[value];
                if (cachedObj) return cachedObj;
            }
            obj = new Long(value, value < 0 ? -1 : 0, false);
            if (-128 <= value && value < 128) {
                INT_CACHE[value] = obj;
            }
            return obj;
        } else {
            value = value >>> 0;
            if (0 <= value && value < 256) {
                cachedObj = UINT_CACHE[value];
                if (cachedObj) return cachedObj;
            }
            obj = new Long(value, (value | 0) < 0 ? -1 : 0, true);
            if (0 <= value && value < 256) {
                UINT_CACHE[value] = obj;
            }
            return obj;
        }
    };

    /**
     * Returns a Long representing the given value, provided that it is a finite
     * number.  Otherwise, zero is returned.
     * @param {number} value The number in question.
     * @param {boolean=} unsigned Whether unsigned or not. Defaults to false (signed).
     * @return {!Long} The corresponding Long value.
     * @expose
     */
    Long.fromNumber = function(value, unsigned) {
        unsigned = !!unsigned;
        if (isNaN(value) || !isFinite(value)) {
            return Long.ZERO;
        } else if (!unsigned && value <= -TWO_PWR_63_DBL) {
            return Long.MIN_SIGNED_VALUE;
        } else if (unsigned && value <= 0) {
            return Long.MIN_UNSIGNED_VALUE;
        } else if (!unsigned && value + 1 >= TWO_PWR_63_DBL) {
            return Long.MAX_SIGNED_VALUE;
        } else if (unsigned && value >= TWO_PWR_64_DBL) {
            return Long.MAX_UNSIGNED_VALUE;
        } else if (value < 0) {
            return Long.fromNumber(-value, false).negate();
        } else {
            return new Long((value % TWO_PWR_32_DBL) | 0, (value / TWO_PWR_32_DBL) | 0, unsigned);
        }
    };

    /**
     * Returns a Long representing the 64bit integer that comes by concatenating the given low and high bits. Each is
     *  assumed to use 32 bits.
     * @param {number} lowBits The low 32 bits.
     * @param {number} highBits The high 32 bits.
     * @param {boolean=} unsigned Whether unsigned or not. Defaults to false (signed).
     * @return {!Long} The corresponding Long value.
     * @expose
     */
    Long.fromBits = function(lowBits, highBits, unsigned) {
        return new Long(lowBits, highBits, unsigned);
    };

    /**
     * Returns a Long representing the 64bit integer that comes by concatenating the given low, middle and high bits.
     *  Each is assumed to use 28 bits.
     * @param {number} part0 The low 28 bits
     * @param {number} part1 The middle 28 bits
     * @param {number} part2 The high 28 (8) bits
     * @param {boolean=} unsigned Whether unsigned or not. Defaults to false (signed).
     * @return {!Long}
     * @expose
     */
    Long.from28Bits = function(part0, part1, part2, unsigned) {
        // 00000000000000000000000000001111 11111111111111111111111122222222 2222222222222
        // LLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH
        return Long.fromBits(part0 | (part1 << 28), (part1 >>> 4) | (part2) << 24, unsigned);
    };

    /**
     * Returns a Long representation of the given string, written using the given
     * radix.
     * @param {string} str The textual representation of the Long.
     * @param {(boolean|number)=} unsigned Whether unsigned or not. Defaults to false (signed).
     * @param {number=} radix The radix in which the text is written.
     * @return {!Long} The corresponding Long value.
     * @expose
     */
    Long.fromString = function(str, unsigned, radix) {
        if (str.length == 0) {
            throw(new Error('number format error: empty string'));
        }
        if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity") {
            return Long.ZERO;
        }
        if (typeof unsigned === 'number') { // For goog.math.Long compatibility
            radix = unsigned;
            unsigned = false;
        }
        radix = radix || 10;
        if (radix < 2 || 36 < radix) {
            throw(new Error('radix out of range: ' + radix));
        }

        if (str.charAt(0) == '-') {
            return Long.fromString(str.substring(1), unsigned, radix).negate();
        } else if (str.indexOf('-') >= 0) {
            throw(new Error('number format error: interior "-" character: ' + str));
        }

        // Do several (8) digits each time through the loop, so as to
        // minimize the calls to the very expensive emulated div.
        var radixToPower = Long.fromNumber(Math.pow(radix, 8));

        var result = Long.ZERO;
        for (var i = 0; i < str.length; i += 8) {
            var size = Math.min(8, str.length - i);
            var value = parseInt(str.substring(i, i + size), radix);
            if (size < 8) {
                var power = Long.fromNumber(Math.pow(radix, size));
                result = result.multiply(power).add(Long.fromNumber(value));
            } else {
                result = result.multiply(radixToPower);
                result = result.add(Long.fromNumber(value));
            }
        }
        result.unsigned = unsigned;
        return result;
    };

    // NOTE: the compiler should inline these constant values below and then remove these variables, so there should be
    // no runtime penalty for these.
    
    // NOTE: The following constant values are used internally only and are therefore not exposed as properties of the
    // Long class.

    /**
     * @type {number}
     */
    var TWO_PWR_16_DBL = 1 << 16;

    /**
     * @type {number}
     */
    var TWO_PWR_24_DBL = 1 << 24;

    /**
     * @type {number}
     */
    var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;

    /**
     * @type {number}
     */
    var TWO_PWR_31_DBL = TWO_PWR_32_DBL / 2;

    /**
     * @type {number}
     */
    var TWO_PWR_48_DBL = TWO_PWR_32_DBL * TWO_PWR_16_DBL;

    /**
     * @type {number}
     */
    var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;

    /**
     * @type {number}
     */
    var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;

    /**
     * @type {!Long}
     */
    var TWO_PWR_24 = Long.fromInt(1 << 24);

    /**
     * @type {!Long}
     * @expose
     */
    Long.ZERO = Long.fromInt(0);

    /**
     * @type {!Long}
     * @expose
     */
    Long.UZERO = Long.fromInt(0, true);

    /**
     * @type {!Long}
     * @expose
     */
    Long.ONE = Long.fromInt(1);

    /**
     * @type {!Long}
     * @expose
     */
    Long.UONE = Long.fromInt(1, true);

    /**
     * @type {!Long}
     * @expose
     */
    Long.NEG_ONE = Long.fromInt(-1);

    /**
     * @type {!Long}
     * @expose
     */
    Long.MAX_SIGNED_VALUE = Long.fromBits(0xFFFFFFFF | 0, 0x7FFFFFFF | 0, false);

    /**
     * @type {!Long}
     * @expose
     */
    Long.MAX_UNSIGNED_VALUE = Long.fromBits(0xFFFFFFFF | 0, 0xFFFFFFFF | 0, true);

    /**
     * Alias of {@link Long.MAX_SIGNED_VALUE} for goog.math.Long compatibility.
     * @type {!Long}
     * @expose
     */
    Long.MAX_VALUE = Long.MAX_SIGNED_VALUE;

    /**
     * @type {!Long}
     * @expose
     */
    Long.MIN_SIGNED_VALUE = Long.fromBits(0, 0x80000000 | 0, false);

    /**
     * @type {!Long}
     * @expose
     */
    Long.MIN_UNSIGNED_VALUE = Long.fromBits(0, 0, true);

    /**
     * Alias of {@link Long.MIN_SIGNED_VALUE}  for goog.math.Long compatibility.
     * @type {!Long}
     * @expose
     */
    Long.MIN_VALUE = Long.MIN_SIGNED_VALUE;

    /**
     * @return {number} The value, assuming it is a 32-bit integer.
     * @expose
     */
    Long.prototype.toInt = function() {
        return this.unsigned ? this.low >>> 0 : this.low;
    };

    /**
     * @return {number} The closest floating-point representation to this value.
     * @expose
     */
    Long.prototype.toNumber = function() {
        if (this.unsigned) {
            return ((this.high >>> 0) * TWO_PWR_32_DBL) + (this.low >>> 0);
        }
        return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
    };

    /**
     * @param {number=} radix The radix in which the text should be written.
     * @return {string} The textual representation of this value.
     * @override
     * @expose
     */
    Long.prototype.toString = function(radix) {
        radix = radix || 10;
        if (radix < 2 || 36 < radix) {
            throw(new Error('radix out of range: ' + radix));
        }
        if (this.isZero()) {
            return '0';
        }
        var rem;
        if (this.isNegative()) { // Unsigned Longs are never negative
            if (this.equals(Long.MIN_SIGNED_VALUE)) {
                // We need to change the Long value before it can be negated, so we remove
                // the bottom-most digit in this base and then recurse to do the rest.
                var radixLong = Long.fromNumber(radix);
                var div = this.div(radixLong);
                rem = div.multiply(radixLong).subtract(this);
                return div.toString(radix) + rem.toInt().toString(radix);
            } else {
                return '-' + this.negate().toString(radix);
            }
        }

        // Do several (6) digits each time through the loop, so as to
        // minimize the calls to the very expensive emulated div.
        var radixToPower = Long.fromNumber(Math.pow(radix, 6));
        rem = this;
        var result = '';
        while (true) {
            var remDiv = rem.div(radixToPower);
            var intval = rem.subtract(remDiv.multiply(radixToPower)).toInt();
            var digits = intval.toString(radix);
            rem = remDiv;
            if (rem.isZero()) {
                return digits + result;
            } else {
                while (digits.length < 6) {
                    digits = '0' + digits;
                }
                result = '' + digits + result;
            }
        }
    };

    /**
     * @return {number} The high 32 bits as a signed value.
     * @expose
     */
    Long.prototype.getHighBits = function() {
        return this.high;
    };

    /**
     * @return {number} The high 32 bits as an unsigned value.
     * @expose
     */
    Long.prototype.getHighBitsUnsigned = function() {
        return this.high >>> 0;
    };

    /**
     * @return {number} The low 32 bits as a signed value.
     * @expose
     */
    Long.prototype.getLowBits = function() {
        return this.low;
    };

    /**
     * @return {number} The low 32 bits as an unsigned value.
     * @expose
     */
    Long.prototype.getLowBitsUnsigned = function() {
        return this.low >>> 0;
    };

    /**
     * @return {number} Returns the number of bits needed to represent the absolute
     *     value of this Long.
     * @expose
     */
    Long.prototype.getNumBitsAbs = function() {
        if (this.isNegative()) { // Unsigned Longs are never negative
            if (this.equals(Long.MIN_SIGNED_VALUE)) {
                return 64;
            } else {
                return this.negate().getNumBitsAbs();
            }
        } else {
            var val = this.high != 0 ? this.high : this.low;
            for (var bit = 31; bit > 0; bit--) {
                if ((val & (1 << bit)) != 0) {
                    break;
                }
            }
            return this.high != 0 ? bit + 33 : bit + 1;
        }
    };

    /**
     * @return {boolean} Whether this value is zero.
     * @expose
     */
    Long.prototype.isZero = function() {
        return this.high == 0 && this.low == 0;
    };

    /**
     * @return {boolean} Whether this value is negative.
     * @expose
     */
    Long.prototype.isNegative = function() {
        return !this.unsigned && this.high < 0;
    };

    /**
     * @return {boolean} Whether this value is odd.
     * @expose
     */
    Long.prototype.isOdd = function() {
        return (this.low & 1) == 1;
    };

    /**
     * @return {boolean} Whether this value is even.
     */
    Long.prototype.isEven = function() {
        return (this.low & 1) == 0;
    };

    /**
     * @param {Long} other Long to compare against.
     * @return {boolean} Whether this Long equals the other.
     * @expose
     */
    Long.prototype.equals = function(other) {
        if (this.unsigned != other.unsigned && (this.high >>> 31) != (other.high >>> 31)) return false;
        return (this.high == other.high) && (this.low == other.low);
    };

    /**
     * @param {Long} other Long to compare against.
     * @return {boolean} Whether this Long does not equal the other.
     * @expose
     */
    Long.prototype.notEquals = function(other) {
        return !this.equals(other);
    };

    /**
     * @param {Long} other Long to compare against.
     * @return {boolean} Whether this Long is less than the other.
     * @expose
     */
    Long.prototype.lessThan = function(other) {
        return this.compare(other) < 0;
    };

    /**
     * @param {Long} other Long to compare against.
     * @return {boolean} Whether this Long is less than or equal to the other.
     * @expose
     */
    Long.prototype.lessThanOrEqual = function(other) {
        return this.compare(other) <= 0;
    };

    /**
     * @param {Long} other Long to compare against.
     * @return {boolean} Whether this Long is greater than the other.
     * @expose
     */
    Long.prototype.greaterThan = function(other) {
        return this.compare(other) > 0;
    };

    /**
     * @param {Long} other Long to compare against.
     * @return {boolean} Whether this Long is greater than or equal to the other.
     * @expose
     */
    Long.prototype.greaterThanOrEqual = function(other) {
        return this.compare(other) >= 0;
    };

    /**
     * Compares this Long with the given one.
     * @param {Long} other Long to compare against.
     * @return {number} 0 if they are the same, 1 if the this is greater, and -1
     *     if the given one is greater.
     * @expose
     */
    Long.prototype.compare = function(other) {
        if (this.equals(other)) {
            return 0;
        }
        var thisNeg = this.isNegative();
        var otherNeg = other.isNegative();
        if (thisNeg && !otherNeg) return -1;
        if (!thisNeg && otherNeg) return 1;
        if (!this.unsigned) {
            // At this point the signs are the same
            return this.subtract(other).isNegative() ? -1 : 1;
        } else {
            // Both are positive if at least one is unsigned
            return (other.high >>> 0) > (this.high >>> 0) || (other.high == this.high && (other.low >>> 0) > (this.low >>> 0)) ? -1 : 1;
        }
    };

    /**
     * @return {!Long} The negation of this value.
     * @expose
     */
    Long.prototype.negate = function() {
        if (!this.unsigned && this.equals(Long.MIN_SIGNED_VALUE)) {
            return Long.MIN_SIGNED_VALUE;
        }
        return this.not().add(Long.ONE);
    };

    /**
     * Returns the sum of this and the given Long.
     * @param {Long} other Long to add to this one.
     * @return {!Long} The sum of this and the given Long.
     * @expose
     */
    Long.prototype.add = function(other) {
        // Divide each number into 4 chunks of 16 bits, and then sum the chunks.
        
        var a48 = this.high >>> 16;
        var a32 = this.high & 0xFFFF;
        var a16 = this.low >>> 16;
        var a00 = this.low & 0xFFFF;

        var b48 = other.high >>> 16;
        var b32 = other.high & 0xFFFF;
        var b16 = other.low >>> 16;
        var b00 = other.low & 0xFFFF;

        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
        c00 += a00 + b00;
        c16 += c00 >>> 16;
        c00 &= 0xFFFF;
        c16 += a16 + b16;
        c32 += c16 >>> 16;
        c16 &= 0xFFFF;
        c32 += a32 + b32;
        c48 += c32 >>> 16;
        c32 &= 0xFFFF;
        c48 += a48 + b48;
        c48 &= 0xFFFF;
        return Long.fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
    };

    /**
     * Returns the difference of this and the given Long.
     * @param {Long} other Long to subtract from this.
     * @return {!Long} The difference of this and the given Long.
     * @expose
     */
    Long.prototype.subtract = function(other) {
        return this.add(other.negate());
    };

    /**
     * Returns the product of this and the given long.
     * @param {Long} other Long to multiply with this.
     * @return {!Long} The product of this and the other.
     * @expose
     */
    Long.prototype.multiply = function(other) {
        if (this.isZero()) {
            return Long.ZERO;
        } else if (other.isZero()) {
            return Long.ZERO;
        }

        if (this.equals(Long.MIN_VALUE)) {
            return other.isOdd() ? Long.MIN_VALUE : Long.ZERO;
        } else if (other.equals(Long.MIN_VALUE)) {
            return this.isOdd() ? Long.MIN_VALUE : Long.ZERO;
        }

        if (this.isNegative()) {
            if (other.isNegative()) {
                return this.negate().multiply(other.negate());
            } else {
                return this.negate().multiply(other).negate();
            }
        } else if (other.isNegative()) {
            return this.multiply(other.negate()).negate();
        }
        // If both longs are small, use float multiplication
        if (this.lessThan(TWO_PWR_24) &&
            other.lessThan(TWO_PWR_24)) {
            return Long.fromNumber(this.toNumber() * other.toNumber(), this.unsigned);
        }

        // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.
        // We can skip products that would overflow.
        
        var a48 = this.high >>> 16;
        var a32 = this.high & 0xFFFF;
        var a16 = this.low >>> 16;
        var a00 = this.low & 0xFFFF;

        var b48 = other.high >>> 16;
        var b32 = other.high & 0xFFFF;
        var b16 = other.low >>> 16;
        var b00 = other.low & 0xFFFF;

        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
        c00 += a00 * b00;
        c16 += c00 >>> 16;
        c00 &= 0xFFFF;
        c16 += a16 * b00;
        c32 += c16 >>> 16;
        c16 &= 0xFFFF;
        c16 += a00 * b16;
        c32 += c16 >>> 16;
        c16 &= 0xFFFF;
        c32 += a32 * b00;
        c48 += c32 >>> 16;
        c32 &= 0xFFFF;
        c32 += a16 * b16;
        c48 += c32 >>> 16;
        c32 &= 0xFFFF;
        c32 += a00 * b32;
        c48 += c32 >>> 16;
        c32 &= 0xFFFF;
        c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
        c48 &= 0xFFFF;
        return Long.fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
    };

    /**
     * Returns this Long divided by the given one.
     * @param {Long} other Long by which to divide.
     * @return {!Long} This Long divided by the given one.
     * @expose
     */
    Long.prototype.div = function(other) {
        if (other.isZero()) {
            throw(new Error('division by zero'));
        } else if (this.isZero()) {
            return this.unsigned ? Long.UZERO : Long.ZERO;
        }
        var approx, rem, res;
        if (this.equals(Long.MIN_SIGNED_VALUE)) {
            if (other.equals(Long.ONE) || other.equals(Long.NEG_ONE)) {
                return Long.MIN_SIGNED_VALUE;  // recall that -MIN_VALUE == MIN_VALUE
            } else if (other.equals(Long.MIN_SIGNED_VALUE)) {
                return Long.ONE;
            } else {
                // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.
                var halfThis = this.shiftRight(1);
                approx = halfThis.div(other).shiftLeft(1);
                if (approx.equals(Long.ZERO)) {
                    return other.isNegative() ? Long.ONE : Long.NEG_ONE;
                } else {
                    rem = this.subtract(other.multiply(approx));
                    res = approx.add(rem.div(other));
                    return res;
                }
            }
        } else if (other.equals(Long.MIN_SIGNED_VALUE)) {
            return this.unsigned ? Long.UZERO : Long.ZERO;
        }
        if (this.isNegative()) {
            if (other.isNegative()) {
                return this.negate().div(other.negate());
            } else {
                return this.negate().div(other).negate();
            }
        } else if (other.isNegative()) {
            return this.div(other.negate()).negate();
        }
        
        // Repeat the following until the remainder is less than other:  find a
        // floating-point that approximates remainder / other *from below*, add this
        // into the result, and subtract it from the remainder.  It is critical that
        // the approximate value is less than or equal to the real value so that the
        // remainder never becomes negative.
        res = Long.ZERO;
        rem = this;
        while (rem.greaterThanOrEqual(other)) {
            // Approximate the result of division. This may be a little greater or
            // smaller than the actual value.
            approx = Math.max(1, Math.floor(rem.toNumber() / other.toNumber()));

            // We will tweak the approximate result by changing it in the 48-th digit or
            // the smallest non-fractional digit, whichever is larger.
            var log2 = Math.ceil(Math.log(approx) / Math.LN2);
            var delta = (log2 <= 48) ? 1 : Math.pow(2, log2 - 48);

            // Decrease the approximation until it is smaller than the remainder.  Note
            // that if it is too large, the product overflows and is negative.
            var approxRes = Long.fromNumber(approx, this.unsigned);
            var approxRem = approxRes.multiply(other);
            while (approxRem.isNegative() || approxRem.greaterThan(rem)) {
                approx -= delta;
                approxRes = Long.fromNumber(approx, this.unsigned);
                approxRem = approxRes.multiply(other);
            }

            // We know the answer can't be zero... and actually, zero would cause
            // infinite recursion since we would make no progress.
            if (approxRes.isZero()) {
                approxRes = Long.ONE;
            }

            res = res.add(approxRes);
            rem = rem.subtract(approxRem);
        }
        return res;
    };

    /**
     * Returns this Long modulo the given one.
     * @param {Long} other Long by which to mod.
     * @return {!Long} This Long modulo the given one.
     * @expose
     */
    Long.prototype.modulo = function(other) {
        return this.subtract(this.div(other).multiply(other));
    };

    /**
     * @return {!Long} The bitwise-NOT of this value.
     * @expose
     */
    Long.prototype.not = function() {
        return Long.fromBits(~this.low, ~this.high, this.unsigned);
    };

    /**
     * Returns the bitwise-AND of this Long and the given one.
     * @param {Long} other The Long with which to AND.
     * @return {!Long} The bitwise-AND of this and the other.
     * @expose
     */
    Long.prototype.and = function(other) {
        return Long.fromBits(this.low & other.low, this.high & other.high, this.unsigned);
    };

    /**
     * Returns the bitwise-OR of this Long and the given one.
     * @param {Long} other The Long with which to OR.
     * @return {!Long} The bitwise-OR of this and the other.
     * @expose
     */
    Long.prototype.or = function(other) {
        return Long.fromBits(this.low | other.low, this.high | other.high, this.unsigned);
    };

    /**
     * Returns the bitwise-XOR of this Long and the given one.
     * @param {Long} other The Long with which to XOR.
     * @return {!Long} The bitwise-XOR of this and the other.
     * @expose
     */
    Long.prototype.xor = function(other) {
        return Long.fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
    };

    /**
     * Returns this Long with bits shifted to the left by the given amount.
     * @param {number} numBits The number of bits by which to shift.
     * @return {!Long} This shifted to the left by the given amount.
     * @expose
     */
    Long.prototype.shiftLeft = function(numBits) {
        numBits &= 63;
        if (numBits == 0) {
            return this;
        } else {
            var low = this.low;
            if (numBits < 32) {
                var high = this.high;
                return Long.fromBits(low << numBits, (high << numBits) | (low >>> (32 - numBits)), this.unsigned);
            } else {
                return Long.fromBits(0, low << (numBits - 32), this.unsigned);
            }
        }
    };

    /**
     * Returns this Long with bits shifted to the right by the given amount.
     * @param {number} numBits The number of bits by which to shift.
     * @return {!Long} This shifted to the right by the given amount.
     * @expose
     */
    Long.prototype.shiftRight = function(numBits) {
        numBits &= 63;
        if (numBits == 0) {
            return this;
        } else {
            var high = this.high;
            if (numBits < 32) {
                var low = this.low;
                return Long.fromBits((low >>> numBits) | (high << (32 - numBits)), high >> numBits, this.unsigned);
            } else {
                return Long.fromBits(high >> (numBits - 32), high >= 0 ? 0 : -1, this.unsigned);
            }
        }
    };

    /**
     * Returns this Long with bits shifted to the right by the given amount, with
     * the new top bits matching the current sign bit.
     * @param {number} numBits The number of bits by which to shift.
     * @return {!Long} This shifted to the right by the given amount, with
     *     zeros placed into the new leading bits.
     * @expose
     */
    Long.prototype.shiftRightUnsigned = function(numBits) {
        numBits &= 63;
        if (numBits == 0) {
            return this;
        } else {
            var high = this.high;
            if (numBits < 32) {
                var low = this.low;
                return Long.fromBits((low >>> numBits) | (high << (32 - numBits)), high >>> numBits, this.unsigned);
            } else if (numBits == 32) {
                return Long.fromBits(high, 0, this.unsigned);
            } else {
                return Long.fromBits(high >>> (numBits - 32), 0, this.unsigned);
            }
        }
    };

    /**
     * @return {!Long} Signed long
     * @expose
     */
    Long.prototype.toSigned = function() {
        var l = this.clone();
        l.unsigned = false;
        return l;
    };

    /**
     * @return {!Long} Unsigned long
     * @expose
     */
    Long.prototype.toUnsigned = function() {
        var l = this.clone();
        l.unsigned = true;
        return l;
    };
    
    /**
     * @return {Long} Cloned instance with the same low/high bits and unsigned flag.
     * @expose
     */
    Long.prototype.clone = function() {
        return new Long(this.low, this.high, this.unsigned);
    };

    // Enable module loading if available
    if (typeof module != 'undefined' && module["exports"]) { // CommonJS
        module["exports"] = Long;
    } else if (typeof define != 'undefined' && define["amd"]) { // AMD
        define("Math/Long", [], function() { return Long; });
    } else { // Shim
        if (!global["dcodeIO"]) {
            global["dcodeIO"] = {};
        }
        global["dcodeIO"]["Long"] = Long;
    }

})(this);

},{}],56:[function(require,module,exports){
/*
 Copyright 2013 Daniel Wirtz <dcode@dcode.io>
 Copyright 2009 The Closure Library Authors. All Rights Reserved.

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS-IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 */

module.exports = require("./dist/Long.js");

},{"./dist/Long.js":55}],57:[function(require,module,exports){
var furious = require("../lib/furious.js");
var expect = require("chai").expect;

var context = null;
before(function(done) {
	furious.init(function(ctx) {
		context = ctx;
		done();
	});
});

describe("Context", function(){
	describe("barrier", function() {
		it("Calls the callback", function(done) {
			context.barrier(function () {
				done();
			});
		});
		it("Executes after preceeding commands have finished", function(done) {
			var x = context.zeros([3, 3]);
			var getHasFinished = false;
			x.get(function(data) {
				getHasFinished = true;
			});
			context.barrier(function (){
				expect(getHasFinished).to.be.true;
				done();
			});
		});
		it("Executes before subsequent commands have started", function(done) {
			var x = context.zeros([3, 3]);
			var barrierHasFinished = false;
			context.barrier(function (){
				barrierHasFinished = true;
			});
			x.get(function(x) {
				expect(barrierHasFinished).to.be.true;
				done();
			});
		});
	});
	describe("empty", function(){
		it("Creates array with specified shape", function() {
			var x = context.empty(42);
			var y = context.empty([42]);
			var z = context.empty([4, 2]);
			expect(x.shape).to.deep.equal([42]);
			expect(y.shape).to.deep.equal([42]);
			expect(z.shape).to.deep.equal([4, 2]);
			x.invalidate();
			y.invalidate();
			z.invalidate();
		});
		it("Creates array with specified data type (f64 by default)", function() {
			var x = context.empty([4, 2]);
			var y = context.empty([4, 2], new furious.DataType("f64"));
			var z = context.empty([4, 2], new furious.DataType("f32"));
			expect(x.dataType.equals(new furious.DataType("f64"))).to.be.true;
			expect(y.dataType.equals(new furious.DataType("f64"))).to.be.true;
			expect(z.dataType.equals(new furious.DataType("f32"))).to.be.true;
			x.invalidate();
			y.invalidate();
			z.invalidate();
		});
	});
	describe("zeros", function(){
		it("Creates array with specified shape", function() {
			var x = context.zeros(42);
			var y = context.zeros([42]);
			var z = context.zeros([4, 2]);
			expect(x.shape).to.deep.equal([42]);
			expect(y.shape).to.deep.equal([42]);
			expect(z.shape).to.deep.equal([4, 2]);
			x.invalidate();
			y.invalidate();
			z.invalidate();
		});
		it("Creates array with specified data type (f64 by default)", function() {
			var x = context.zeros([4, 2]);
			var y = context.zeros([4, 2], new furious.DataType("f64"));
			var z = context.zeros([4, 2], new furious.DataType("f32"));
			expect(x.dataType.equals(new furious.DataType("f64"))).to.be.true;
			expect(y.dataType.equals(new furious.DataType("f64"))).to.be.true;
			expect(z.dataType.equals(new furious.DataType("f32"))).to.be.true;
			x.invalidate();
			y.invalidate();
			z.invalidate();
		});
		it("Creates array with all elements initialized to zero", function(done) {
			var x = context.zeros([3, 2], new furious.DataType("f64"));
			var y = context.zeros([2, 3], new furious.DataType("f32"));
			context.get(x, y, function(x, y) {
				expect(x).to.deep.equal([[0.0, 0.0],
				                         [0.0, 0.0],
				                         [0.0, 0.0]]);
				expect(y).to.deep.equal([[0.0, 0.0, 0.0],
				                         [0.0, 0.0, 0.0]]);
				done();
			});
		});
	});
	describe("ones", function(){
		it("Creates array with specified shape", function() {
			var x = context.ones(42);
			var y = context.ones([42]);
			var z = context.ones([4, 2]);
			expect(x.shape).to.deep.equal([42]);
			expect(y.shape).to.deep.equal([42]);
			expect(z.shape).to.deep.equal([4, 2]);
			x.invalidate();
			y.invalidate();
			z.invalidate();
		});
		it("Creates array with specified data type (f64 by default)", function() {
			var x = context.ones([4, 2]);
			var y = context.ones([4, 2], new furious.DataType("f64"));
			var z = context.ones([4, 2], new furious.DataType("f32"));
			expect(x.dataType.equals(new furious.DataType("f64"))).to.be.true;
			expect(y.dataType.equals(new furious.DataType("f64"))).to.be.true;
			expect(z.dataType.equals(new furious.DataType("f32"))).to.be.true;
			x.invalidate();
			y.invalidate();
			z.invalidate();
		});
		it("Creates array with all elements initialized to one", function(done) {
			var x = context.ones([3, 2], new furious.DataType("f64"));
			var y = context.ones([2, 3], new furious.DataType("f32"));
			context.get(x, y, function(x, y) {
				expect(x).to.deep.equal([[1.0, 1.0],
				                         [1.0, 1.0],
				                         [1.0, 1.0]]);
				expect(y).to.deep.equal([[1.0, 1.0, 1.0],
				                         [1.0, 1.0, 1.0]]);
				done();
			});
		});
	});
	describe("array", function(){
		it("Creates array of the same length as the provided array", function(){
			var x = context.array([0, 1]);
			var y = context.array([[0, 1],
			                       [2, 3],
			                       [3, 4]]);
			expect(x.length).to.equal(2);
			expect(y.length).to.equal(6);
			x.invalidate();
			y.invalidate();
		});
		it("Creates array of the same shape as the provided array", function(){
			var x = context.array([0, 1]);
			var y = context.array([[0, 1],
			                       [2, 3],
			                       [3, 4]]);
			var z = context.array([[[1, 2, 3], [ 4,  5,  6]],
			                       [[7, 8, 9], [10, 11, 12]]]);
			expect(x.shape).to.deep.equal([2]);
			expect(y.shape).to.deep.equal([3, 2]);
			expect(z.shape).to.deep.equal([2, 2, 3]);
			x.invalidate();
			y.invalidate();
			z.invalidate();
		});
		it("Creates array with the same data as the provided array", function(done){
			var array = [[[1, 2, 3], [ 4,  5,  6]],
			             [[7, 8, 9], [10, 11, 12]]];
			var x = context.array(array, new furious.DataType("f64"));
			var y = context.array(array, new furious.DataType("f32"));
			context.get(x, y, function(x, y) {
				expect(x).to.deep.equal(array);
				expect(y).to.deep.equal(array);
				done();
			});
		});
	});
	describe("linspace", function(){
		it("Has length of 50 with default arguments", function(){
			expect((context.linspace(0, 1)).length).to.equal(50);
		});
		it("Has the specified number of samples", function(){
			expect((context.linspace(0, 1, 243)).length).to.equal(243);
		});
		it("Has expected values", function(done){
			var start = 50;
			var stop = 99;
			var x = context.linspace(start, stop);
			x.get(function(result) {
				for (var i = 0; i < result.length; i++) {
					expect(result[i]).to.equal(start+i);
				}
				done();
			});
		});
		describe("with includeStop === false", function(){
			it("Has the specified number of samples", function(){
				expect((context.linspace(0, 1, 243, false)).length).to.equal(243);
			});
			it("Does not contain the right endpoint", function(done){
				var x = context.linspace(-1, 1, 1000, false);
				x.get(function(result) {
					expect(result[result.length - 1]).to.not.equal(1);
					done();
				});
			});
		});
	});
	describe("neg", function() {
		var xRef = [ 1, -7.5,  0, -15];
		var yRef = [-1,  7.5, -0,  15];
		var dataTypes = ["f32", "f64"];

		describe("With no output array supplied", function() {
			it("Creates an output array with the same shape as input array", function() {
				var x = context.ones([2, 3, 4]);
				var y = context.neg(x);
				expect(y.shape).to.deep.equal([2, 3, 4]);
				y.invalidate();
			});

			for (var i = 0; i < dataTypes.length; i++) {
				(function(dataType) {
					it("Creates an output array with the same data type as input array (" + dataType + " data type)", function() {
						var x = context.array(xRef, new furious.DataType(dataType));
						var y = context.neg(x);
						expect(y.dataType.equals(new furious.DataType(dataType))).to.be.true;
						y.invalidate();
					});
				})(dataTypes[i]);
			}

			for (var i = 0; i < dataTypes.length; i++) {
				(function(dataType) {
					it("Creates an output array with negated elements (" + dataType + " data type)", function(done) {
						var x = context.array(xRef, new furious.DataType(dataType));
						var y = context.neg(x);
						y.get(function(y) {
							expect(y).to.deep.equal(yRef);
							done();
						});
					});
				})(dataTypes[i]);
			}
		});
		describe("With an output array", function() {
			for (var i = 0; i < dataTypes.length; i++) {
				(function(dataType) {
					it("Populates the output array with negated elements (" + dataType + " data type)", function(done) {
						var x = context.array(xRef, new furious.DataType(dataType));
						var y = context.ones(x.shape, x.dataType);
						context.neg(x, y);
						y.get(function(y) {
							expect(y).to.deep.equal(yRef);
							done();
						});
					});
				})(dataTypes[i]);
			}
		});
	});
	describe("abs", function() {
		var xRef = [1, -7.5, 0, -15];
		var yRef = [1,  7.5, 0,  15];
		var dataTypes = ["f32", "f64"];

		describe("With no output array supplied", function() {
			it("Creates an output array with the same shape as input array", function() {
				var x = context.ones([2, 3, 4]);
				var y = context.abs(x);
				expect(y.shape).to.deep.equal([2, 3, 4]);
				y.invalidate();
			});

			for (var i = 0; i < dataTypes.length; i++) {
				(function(dataType) {
					it("Creates an output array with the same data type as input array (" + dataType + " data type)", function() {
						var x = context.array(xRef, new furious.DataType(dataType));
						var y = context.abs(x);
						expect(y.dataType.equals(new furious.DataType(dataType))).to.be.true;
						y.invalidate();
					});
				})(dataTypes[i]);
			}

			for (var i = 0; i < dataTypes.length; i++) {
				(function(dataType) {
					it("Creates an output array with absolute values of elements (" + dataType + " data type)", function(done) {
						var x = context.array(xRef, new furious.DataType(dataType));
						var y = context.abs(x);
						y.get(function(y) {
							expect(y).to.deep.equal(yRef);
							done();
						});
					});
				})(dataTypes[i]);
			}
		});
		describe("With an output array", function() {
			for (var i = 0; i < dataTypes.length; i++) {
				(function(dataType) {
					it("Populates the output array with absolute values of elements (" + dataType + " data type)", function(done) {
						var x = context.array(xRef, new furious.DataType(dataType));
						var y = context.ones(x.shape, x.dataType);
						context.abs(x, y);
						y.get(function(y) {
							expect(y).to.deep.equal(yRef);
							done();
						});
					});
				})(dataTypes[i]);
			}
		});
	});
	describe("exp", function() {
		var xRef = [1, -1, 0];
		var dataTypes = ["f32", "f64"];

		describe("With no output array supplied", function() {
			it("Creates an output array with the same shape as input array", function() {
				var x = context.ones([2, 3, 4]);
				var y = context.exp(x);
				expect(y.shape).to.deep.equal([2, 3, 4]);
				y.invalidate();
			});

			for (var i = 0; i < dataTypes.length; i++) {
				(function(dataType) {
					it("Creates an output array with the same data type as input array (" + dataType + " data type)", function() {
						var x = context.array(xRef, new furious.DataType(dataType));
						var y = context.exp(x);
						expect(y.dataType.equals(new furious.DataType(dataType))).to.be.true;
						y.invalidate();
					});
				})(dataTypes[i]);
			}

			for (var i = 0; i < dataTypes.length; i++) {
				(function(dataType) {
					it("Creates an output array with absolute values of elements (" + dataType + " data type)", function(done) {
						var x = context.array(xRef, new furious.DataType(dataType));
						var y = context.exp(x);
						y.get(function(y) {
							for (var k = 0; k < y.length; k++) {
								expect(y[k]).to.be.closeTo(Math.exp(xRef[k]), Math.exp(xRef[k]) * 3 * x.dataType.epsilon);
							}
							done();
						});
					});
				})(dataTypes[i]);
			}
		});
		describe("With an output array", function() {
			for (var i = 0; i < dataTypes.length; i++) {
				(function(dataType) {
					it("Populates the output array with absolute values of elements (" + dataType + " data type)", function(done) {
						var x = context.array(xRef, new furious.DataType(dataType));
						var y = context.ones(x.shape, x.dataType);
						context.exp(x, y);
						y.get(function(y) {
							for (var k = 0; k < y.length; k++) {
								expect(y[k]).to.be.closeTo(Math.exp(xRef[k]), Math.exp(xRef[k]) * 3 * x.dataType.epsilon);
							}
							done();
						});
					});
				})(dataTypes[i]);
			}
		});
	});
	describe("log", function() {
		var xRef = [1, 3, 10];
		var dataTypes = ["f32", "f64"];

		describe("With no output array supplied", function() {
			it("Creates an output array with the same shape as input array", function() {
				var x = context.ones([2, 3, 4]);
				var y = context.log(x);
				expect(y.shape).to.deep.equal([2, 3, 4]);
				y.invalidate();
			});

			for (var i = 0; i < dataTypes.length; i++) {
				(function(dataType) {
					it("Creates an output array with the same data type as input array (" + dataType + " data type)", function() {
						var x = context.array(xRef, new furious.DataType(dataType));
						var y = context.log(x);
						expect(y.dataType.equals(new furious.DataType(dataType))).to.be.true;
						y.invalidate();
					});
				})(dataTypes[i]);
			}

			for (var i = 0; i < dataTypes.length; i++) {
				(function(dataType) {
					it("Creates an output array with absolute values of elements (" + dataType + " data type)", function(done) {
						var x = context.array(xRef, new furious.DataType(dataType));
						var y = context.log(x);
						y.get(function(y) {
							for (var k = 0; k < y.length; k++) {
								expect(y[k]).to.be.closeTo(Math.log(xRef[k]), Math.log(xRef[k]) * 3 * x.dataType.epsilon);
							}
							done();
						});
					});
				})(dataTypes[i]);
			}
		});
		describe("With an output array", function() {
			for (var i = 0; i < dataTypes.length; i++) {
				(function(dataType) {
					it("Populates the output array with absolute values of elements (" + dataType + " data type)", function(done) {
						var x = context.array(xRef, new furious.DataType(dataType));
						var y = context.ones(x.shape, x.dataType);
						context.log(x, y);
						y.get(function(y) {
							for (var k = 0; k < y.length; k++) {
								expect(y[k]).to.be.closeTo(Math.log(xRef[k]), Math.log(xRef[k]) * 3 * x.dataType.epsilon);
							}
							done();
						});
					});
				})(dataTypes[i]);
			}
		});
	});
	describe("sqrt", function() {
		var xRef = [0, 0.25, 1, 9, 10];
		var dataTypes = ["f32", "f64"];

		describe("With no output array supplied", function() {
			it("Creates an output array with the same shape as input array", function() {
				var x = context.ones([2, 3, 4]);
				var y = context.sqrt(x);
				expect(y.shape).to.deep.equal([2, 3, 4]);
				y.invalidate();
			});

			for (var i = 0; i < dataTypes.length; i++) {
				(function(dataType) {
					it("Creates an output array with the same data type as input array (" + dataType + " data type)", function() {
						var x = context.array(xRef, new furious.DataType(dataType));
						var y = context.sqrt(x);
						expect(y.dataType.equals(new furious.DataType(dataType))).to.be.true;
						y.invalidate();
					});
				})(dataTypes[i]);
			}

			for (var i = 0; i < dataTypes.length; i++) {
				(function(dataType) {
					it("Creates an output array with absolute values of elements (" + dataType + " data type)", function(done) {
						var x = context.array(xRef, new furious.DataType(dataType));
						var y = context.sqrt(x);
						y.get(function(y) {
							for (var k = 0; k < y.length; k++) {
								expect(y[k]).to.be.closeTo(Math.sqrt(xRef[k]), Math.sqrt(xRef[k]) * 3 * x.dataType.epsilon);
							}
							done();
						});
					});
				})(dataTypes[i]);
			}
		});
		describe("With an output array", function() {
			for (var i = 0; i < dataTypes.length; i++) {
				(function(dataType) {
					it("Populates the output array with absolute values of elements (" + dataType + " data type)", function(done) {
						var x = context.array(xRef, new furious.DataType(dataType));
						var y = context.ones(x.shape, x.dataType);
						context.sqrt(x, y);
						y.get(function(y) {
							for (var k = 0; k < y.length; k++) {
								expect(y[k]).to.be.closeTo(Math.sqrt(xRef[k]), Math.sqrt(xRef[k]) * 3 * x.dataType.epsilon);
							}
							done();
						});
					});
				})(dataTypes[i]);
			}
		});
	});
	describe("square", function() {
		var xRef = [-2, 0, 0.5, 1, 3];
		var dataTypes = ["f32", "f64"];

		describe("With no output array supplied", function() {
			it("Creates an output array with the same shape as input array", function() {
				var x = context.ones([2, 3, 4]);
				var y = context.square(x);
				expect(y.shape).to.deep.equal([2, 3, 4]);
				y.invalidate();
			});

			for (var i = 0; i < dataTypes.length; i++) {
				(function(dataType) {
					it("Creates an output array with the same data type as input array (" + dataType + " data type)", function() {
						var x = context.array(xRef, new furious.DataType(dataType));
						var y = context.square(x);
						expect(y.dataType.equals(new furious.DataType(dataType))).to.be.true;
						y.invalidate();
					});
				})(dataTypes[i]);
			}

			for (var i = 0; i < dataTypes.length; i++) {
				(function(dataType) {
					it("Creates an output array with absolute values of elements (" + dataType + " data type)", function(done) {
						var x = context.array(xRef, new furious.DataType(dataType));
						var y = context.square(x);
						y.get(function(y) {
							for (var k = 0; k < y.length; k++) {
								expect(y[k]).to.be.closeTo(xRef[k] * xRef[k], xRef[k] * xRef[k] * x.dataType.epsilon);
							}
							done();
						});
					});
				})(dataTypes[i]);
			}
		});
		describe("With an output array", function() {
			for (var i = 0; i < dataTypes.length; i++) {
				(function(dataType) {
					it("Populates the output array with absolute values of elements (" + dataType + " data type)", function(done) {
						var x = context.array(xRef, new furious.DataType(dataType));
						var y = context.ones(x.shape, x.dataType);
						context.square(x, y);
						y.get(function(y) {
							for (var k = 0; k < y.length; k++) {
								expect(y[k]).to.be.closeTo(xRef[k] * xRef[k], xRef[k] * xRef[k] * x.dataType.epsilon);
							}
							done();
						});
					});
				})(dataTypes[i]);
			}
		});
	});
});

},{"../lib/furious.js":6,"chai":14}],58:[function(require,module,exports){
var furious = require("../lib/furious.js");
var expect = require("chai").expect;

describe("DataType", function(){
	describe("f32", function(){
		it("should have size 4", function(){
			var dtype = new furious.DataType("f32");
			expect(dtype.size).to.equal(4);
		});

		it("should have type \"f32\"", function(){
			var dtype = new furious.DataType("f32");
			expect(dtype.type).to.equal("f32");
		});
	});
	describe("f64", function(){
		it("should have size 8", function(){
			var dtype = new furious.DataType("f64");
			expect(dtype.size).to.equal(8);
		});

		it("should have type \"f64\"", function(){
			var dtype = new furious.DataType("f64");
			expect(dtype.type).to.equal("f64");
		});
	});
});

},{"../lib/furious.js":6,"chai":14}],59:[function(require,module,exports){
var furious = require("../lib/furious.js");
var expect = require("chai").expect;

var context = null;
before(function(done) {
	furious.init(function(ctx) {
		context = ctx;
		done();
	});
});

describe("NDArray", function() {
	describe("length", function() {
		it("Equals to the number passed in constructor", function() {
			var x = context.empty(42);
			expect(x.length).to.equal(42);
			x.invalidate();
		});
		it("Equals to the number passed in constructor as an array", function() {
			var x = context.empty([42]);
			expect(x.length).to.equal(42);
			x.invalidate();
		});
		it("Equals to the product of dimensions", function() {
			var x = context.empty([2, 5, 3]);
			expect(x.length).to.equal(30);
			x.invalidate();
		});
	});
	describe("reshape", function() {
		it("Preserves length", function() {
			var x = context.empty([7,5,3]);
			var y = x.reshape([21,5]);
			expect(y.length).to.equal(x.length);
			y.invalidate();
		});
		it("Changes shape", function() {
			var x = context.empty([7,5,3]);
			var y = x.reshape([21,5]);
			expect(y.shape).to.deep.equal([21,5]);
			y.invalidate();
		});
		it("Rearranges data", function(done) {
			var x = context.linspace(1, 8, 8).reshape([2, 2, 2]);
			x.get(function(result) {
				expect(result).to.deep.equal([[[ 1,  2], [ 3,  4]],
											  [[ 5,  6], [ 7,  8]]]);
				done();
			});
		});
	});
	describe("repeat", function() {
		it("Repeats array elements along axis 0", function(done) {
			var x = context.array([[8, 1, 6],
			                       [3, 5, 7],
			                       [4, 9, 2]]);
			x.repeat(2, 0).get(function(y) {
				expect(y).to.deep.equal([[8, 1, 6],
				                         [8, 1, 6],
				                         [3, 5, 7],
				                         [3, 5, 7],
				                         [4, 9, 2],
				                         [4, 9, 2]]);
				done();
			});
		});
		it("Repeats array elements along axis 1", function(done) {
			var x = context.array([[8, 1, 6],
			                       [3, 5, 7],
			                       [4, 9, 2]]);
			x.repeat(2, 1).get(function(y) {
				expect(y).to.deep.equal([[8, 8, 1, 1, 6, 6],
				                         [3, 3, 5, 5, 7, 7],
				                         [4, 4, 9, 9, 2, 2]]);
				done();
			});
		});
	});
	describe("get", function(){
		it("Works with 1-dimensional array", function(done) {
			var x = context.array([42, 10]);
			x.get(function(y) {
				expect(y).to.deep.equal([42, 10]);
				done();
			});
		});
		it("Works with 2-dimensional array", function(done) {
			var array = [[16,  2,  3, 13,  5],
						 [11, 10,  8,  9,  7],
						 [ 6, 12,  4, 14, 15]];
			var x = context.array(array);
			x.get(function(y) {
				expect(y).to.deep.equal(array);
				done();
			});
		});
	});
	describe("add", function() {
		describe("Add array", function() {
			it("Correct result for 1-dimensional arrays", function(done) {
				var x = context.array([1, 4, 9]);
				var y = context.array([8, -1, 10]);
				var z = x.add(y);
				z.get(function(z) {
					expect(z).to.deep.equal([9, 3, 19]);
					done();
				});
			});
			it("Correct result for 2-dimensional arrays", function(done) {
				var x = context.array([[1, 4], [9, -17]]);
				var y = context.array([[8, -1], [10, -21]]);
				var z = x.add(y);
				z.get(function(result) {
					expect(result).to.deep.equal([[9, 3], [19, -38]]);
					done();
				});
			});
		});
		describe("Add scalar", function(){
			it("Correct result for 1-dimensional arrays", function(done) {
				var x = context.array([1, 4, 9]);
				var z = x.add(-7);
				z.get(function(z) {
					expect(z).to.deep.equal([-6, -3, 2]);
					done();
				});
			});
			it("Correct result for 2-dimensional arrays", function(done) {
				var x = context.array([[1, 4], [9, -17]]);
				var z = x.add(42);
				z.get(function(z) {
					expect(z).to.deep.equal([[43, 46], [51, 25]]);
					done();
				});
			});
		});
	});
	describe("sub", function() {
		describe("Subtract array", function() {
			it("Correct result for 1-dimensional arrays", function(done) {
				var x = context.array([1, 4, 9]);
				var y = context.array([8, -1, 10]);
				var z = x.sub(y);
				z.get(function(result) {
					expect(result).to.deep.equal([-7, 5, -1]);
					done();
				});
			});
			it("Correct result for 2-dimensional arrays", function(done) {
				var x = context.array([[1, 4], [9, -17]]);
				var y = context.array([[8, -1], [10, -21]]);
				var z = x.sub(y);
				z.get(function(result) {
					expect(result).to.deep.equal([[-7, 5], [-1, 4]]);
					done();
				});
			});
		});
		describe("Subtract scalar", function() {
			it("Correct result for 1-dimensional arrays", function(done) {
				var x = context.array([1, 4, 9]);
				var y = x.sub(-7);
				y.get(function(y) {
					expect(y).to.deep.equal([8, 11, 16]);
					done();
				});
			});
			it("Correct result for 2-dimensional arrays", function(done) {
				var x = context.array([[1, 4], [9, -17]]);
				var y = x.sub(42);
				y.get(function(y) {
					expect(y).to.deep.equal([[-41, -38], [-33, -59]]);
					done();
				});
			});
		});
	});
	describe("mul", function() {
		describe("Multiply by array", function() {
			it("Correct result for 1-dimensional arrays", function(done) {
				var x = context.array([1, 4, 9]);
				var y = context.array([8, -1, 10]);
				var z = x.mul(y);
				z.get(function(z) {
					expect(z).to.deep.equal([8, -4, 90]);
					done();
				});
			});
			it("Correct result for 2-dimensional arrays", function(done) {
				var x = context.array([[1, 4], [9, -17]]);
				var y = context.array([[8, -1], [10, -21]]);
				var z = x.mul(y);
				z.get(function(z) {
					expect(z).to.deep.equal([[8, -4], [90, 357]]);
					done();
				});
			});
		});
		describe("Multiply by scalar", function() {
			it("Correct result for 1-dimensional arrays", function(done) {
				var x = context.array([1, 4, 9]);
				var y = x.mul(-10);
				y.get(function(y) {
					expect(y).to.deep.equal([-10, -40, -90]);
					done();
				});
			});
			it("Correct result for 2-dimensional arrays", function(done) {
				var x = context.array([[1, 4], [9, -17]]);
				var y = x.mul(10);
				y.get(function(y) {
					expect(y).to.deep.equal([[10, 40], [90, -170]]);
					done();
				});
			});
		});
	});
	describe("div", function(){
		describe("Divide by array", function(){
			it("Correct result for 1-dimensional arrays", function(done) {
				var x = context.array([1, 4, 9]);
				var y = context.array([2, -4, 8]);
				var z = x.div(y);
				z.get(function(z) {
					expect(z).to.deep.equal([0.5, -1, 1.125]);
					done();
				});
			});
			it("Correct result for 2-dimensional arrays", function(done) {
				var x = context.array([[1, 4], [9, -17]]);
				var y = context.array([[-2, 4], [-8, 16]]);
				var z = x.div(y);
				z.get(function(z) {
					expect(z).to.deep.equal([[-0.5, 1], [-1.125, -1.0625]]);
					done();
				});
			});
		});
		describe("Divide by scalar", function() {
			it("Correct result for 1-dimensional arrays", function() {
				var x = context.array([1, 4, 9]);
				var y = x.div(-2);
				y.get(function(y) {
					expect(y).to.deep.equal([-0.5, -2, -4.5]);
				});
			});
			it("Correct result for 2-dimensional arrays", function() {
				var x = context.array([[1, 4], [9, -17]]);
				var y = x.div(-4);
				y.get(function(y) {
					expect(y).to.deep.equal([[-0.25, -1], [-2.25, 4.25]]);
				});
			});
		});
	});
	describe("min", function(){
		describe("All elements", function(){
			it("Returns zero-dimensional array of length one", function() {
				var x = context.zeros([20, 30]);
				var y = x.min();
				expect(y.shape).to.deep.equal([]);
				expect(y.length).to.equal(1);
				y.invalidate();
			});
			it("Computes the minimum of all elements in an array", function(done) {
				var x = context.linspace(-50, 100, 100000).reshape([200, 500]);
				x.min().get(function(y) {
					expect(y).to.equal(-50);
					done();
				});
			});
		});
		describe("Along an axis", function() {
			it("Correct shape for 3-dimensional arrays", function() {
				var x = context.linspace(1, 24, 24).reshape([2, 3, 4]).lock();
				expect(x.min(0).shape).to.deep.equal([3, 4]);
				expect(x.min(1).shape).to.deep.equal([2, 4]);
				expect(x.min(2).shape).to.deep.equal([2, 3]);
				x.invalidate();
			});
			it("Correct result for 3-dimensional arrays, axis 0", function(done) {
				var x = context.linspace(1, 24, 24).reshape([2, 3, 4]);
				x.min(0).get(function(y) {
					expect(y).to.deep.equal([[ 1,  2,  3,  4],
					                         [ 5,  6,  7,  8],
					                         [ 9, 10, 11, 12]]);
					done();
				});
			});
			it("Correct result for 3-dimensional arrays, axis 1", function(done) {
				var x = context.linspace(1, 24, 24).reshape([2, 3, 4]);
				x.min(1).get(function(y) {
					expect(y).to.deep.equal([[  1,  2,  3,  4],
					                         [ 13, 14, 15, 16]]);
					done();
				});
			});
			it("Correct result for 3-dimensional arrays, axis 2", function(done) {
				var x = context.linspace(1, 24, 24).reshape([2, 3, 4]);
				x.min(2).get(function(y) {
					expect(y).to.deep.equal([[  1,  5,  9],
					                         [ 13, 17, 21]]);
					done();
				});
			});
		});
	});
	describe("max", function() {
		describe("All elements", function() {
			it("Returns zero-dimensional array of length one", function() {
				var x = context.zeros([20, 30]);
				var y = x.max();
				expect(y.shape).to.deep.equal([]);
				expect(y.length).to.equal(1);
				y.invalidate();
			});
			it("Computes the maximum of all elements in an array", function(done) {
				var x = context.linspace(-50, 100, 100000).reshape([200, 500]);
				x.max().get(function(y) {
					expect(y).to.equal(100);
					done();
				});
			});
		});
		describe("Along an axis", function() {
			it("Correct shape for 3-dimensional arrays", function() {
				var x = context.linspace(1, 24, 24).reshape([2, 3, 4]).lock();
				expect(x.max(0).shape).to.deep.equal([3, 4]);
				expect(x.max(1).shape).to.deep.equal([2, 4]);
				expect(x.max(2).shape).to.deep.equal([2, 3]);
				x.invalidate();
			});
			it("Correct result for 3-dimensional arrays, axis 0", function(done) {
				var x = context.linspace(1, 24, 24).reshape([2, 3, 4]);
				x.max(0).get(function(y) {
					expect(y).to.deep.equal([[ 13, 14, 15, 16],
					                         [ 17, 18, 19, 20],
					                         [ 21, 22, 23, 24]]);
					done();
				});
			});
			it("Correct result for 3-dimensional arrays, axis 1", function(done) {
				var x = context.linspace(1, 24, 24).reshape([2, 3, 4]);
				x.max(1).get(function(y) {
					expect(y).to.deep.equal([[  9, 10, 11, 12],
					                         [ 21, 22, 23, 24]]);
					done();
				});
			});
			it("Correct result for 3-dimensional arrays, axis 2", function(done) {
				var x = context.linspace(1, 24, 24).reshape([2, 3, 4]);
				x.max(2).get(function(y) {
					expect(y).to.deep.equal([[  4,  8, 12],
					                         [ 16, 20, 24]]);
					done();
				});
			});
		});
	});
	describe("sum", function() {
		describe("All elements", function() {
			it("Returns zero-dimensional array of length one", function() {
				var x = context.zeros([20, 30]);
				var y = x.sum();
				expect(y.shape).to.deep.equal([]);
				expect(y.length).to.equal(1);
				y.invalidate();
			});
			it("Computes the sum of all elements in an array", function(done) {
				var x = context.linspace(1, 100000, 100000).reshape([200, 500]);
				x.sum().get(function(y) {
					expect(y).to.equal(5000050000);
					done();
				});
			});
		});
		describe("Along an axis", function() {
			it("Correct shape for 3-dimensional arrays", function() {
				var x = context.linspace(1, 24, 24).reshape([2, 3, 4]).lock();
				expect(x.sum(0).shape).to.deep.equal([3, 4]);
				expect(x.sum(1).shape).to.deep.equal([2, 4]);
				expect(x.sum(2).shape).to.deep.equal([2, 3]);
				x.invalidate();
			});
			it("Correct result for 3-dimensional arrays, axis 0", function(done) {
				var x = context.linspace(1, 24, 24).reshape([2, 3, 4]);
				x.sum(0).get(function(y) {
					expect(y).to.deep.equal([[ 14, 16, 18, 20],
					                         [ 22, 24, 26, 28],
					                         [ 30, 32, 34, 36]]);
					done();
				});
			});
			it("Correct result for 3-dimensional arrays, axis 1", function(done) {
				var x = context.linspace(1, 24, 24).reshape([2, 3, 4]);
				x.sum(1).get(function(y) {
					expect(y).to.deep.equal([[ 15,  18,  21,  24],
					                         [ 51,  54,  57,  60]]);
					done();
				});
			});
			it("Correct result for 3-dimensional arrays, axis 2", function(done) {
				var x = context.linspace(1, 24, 24).reshape([2, 3, 4]);
				x.sum(2).get(function(y) {
					expect(y).to.deep.equal([[ 10,  26,  42],
					                         [ 58,  74,  90]]);
					done();
				});
			});
		});
	});
	describe("dot", function() {
		it("Correct shape for 2-dimensional arrays", function() {
			var x = context.empty([2, 5]);
			var y = context.empty([5, 11]);
			var z = context.dot(x, y);
			expect(z.shape).to.deep.equal([2, 11]);
			z.invalidate();
		});
		it("Correct shape for 3-dimensional arrays", function() {
			var x = context.empty([2, 3, 4]);
			var y = context.empty([7, 4, 8]);
			var z = context.dot(x, y);
			expect(z.shape).to.deep.equal([2, 3, 7, 8]);
			z.invalidate();
		});
		it("Correct shape for 4-dimensional arrays", function() {
			var x = context.empty([2, 3, 4, 5]);
			var y = context.empty([6, 7, 5, 8]);
			var z = context.dot(x, y);
			expect(z.shape).to.deep.equal([2, 3, 4, 6, 7, 8]);
			z.invalidate();
		});
		it("Correct value for 1-dimensional arrays", function(done) {
			var x = context.array([2, 5]);
			var y = context.array([5, 11]);
			context.dot(x, y).get(function(z) {
				expect(z).to.deep.equal(65);
				done();
			});
		});
		it("Correct value for 2-dimensional arrays", function(done) {
			var x = context.array([[64,  2,  3],
			                       [61, 60,  6]]);
			var y = context.array([[92, 99,  1,  8, 15],
			                       [67, 74, 51, 58, 40],
			                       [98, 80,  7, 14, 16]]);
			var z = context.dot(x, y);
			z.get(function(result) {
				expect(result).to.deep.equal([[  6316,  6724,  187,  670, 1088],
				                              [ 10220, 10959, 3163, 4052, 3411]]);
				done();
			});
		});
	});
});

},{"../lib/furious.js":6,"chai":14}]},{},[57,58,59])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYXJhdC9Qcm9qZWN0cy9mdXJpb3VzLmpzL25vZGVfbW9kdWxlcy9ncnVudC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCIvVXNlcnMvbWFyYXQvUHJvamVjdHMvZnVyaW91cy5qcy9saWIvRGF0YVR5cGUuanMiLCIvVXNlcnMvbWFyYXQvUHJvamVjdHMvZnVyaW91cy5qcy9saWIvTkRBcnJheS5qcyIsIi9Vc2Vycy9tYXJhdC9Qcm9qZWN0cy9mdXJpb3VzLmpzL2xpYi9QQkNvbnRleHQuanMiLCIvVXNlcnMvbWFyYXQvUHJvamVjdHMvZnVyaW91cy5qcy9saWIvUE5hQ2xDb250ZXh0LmpzIiwiL1VzZXJzL21hcmF0L1Byb2plY3RzL2Z1cmlvdXMuanMvbGliL2FsbG9jYXRvci5qcyIsIi9Vc2Vycy9tYXJhdC9Qcm9qZWN0cy9mdXJpb3VzLmpzL2xpYi9mdXJpb3VzLmpzIiwiL1VzZXJzL21hcmF0L1Byb2plY3RzL2Z1cmlvdXMuanMvbGliL2pzL0pTQ29udGV4dC5qcyIsIi9Vc2Vycy9tYXJhdC9Qcm9qZWN0cy9mdXJpb3VzLmpzL2xpYi9qcy9XZWJXb3JrZXJDb250ZXh0LmpzIiwiL1VzZXJzL21hcmF0L1Byb2plY3RzL2Z1cmlvdXMuanMvbGliL2pzL2pzbWF0aC5qcyIsIi9Vc2Vycy9tYXJhdC9Qcm9qZWN0cy9mdXJpb3VzLmpzL2xpYi9yZXF1ZXN0cy5wYi5qcyIsIi9Vc2Vycy9tYXJhdC9Qcm9qZWN0cy9mdXJpb3VzLmpzL2xpYi9yZXNwb25zZXMucGIuanMiLCIvVXNlcnMvbWFyYXQvUHJvamVjdHMvZnVyaW91cy5qcy9saWIvdXRpbC5qcyIsIi9Vc2Vycy9tYXJhdC9Qcm9qZWN0cy9mdXJpb3VzLmpzL2xpYi93ZWJjbC9XZWJDTENvbnRleHQuanMiLCIvVXNlcnMvbWFyYXQvUHJvamVjdHMvZnVyaW91cy5qcy9ub2RlX21vZHVsZXMvY2hhaS9pbmRleC5qcyIsIi9Vc2Vycy9tYXJhdC9Qcm9qZWN0cy9mdXJpb3VzLmpzL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpLmpzIiwiL1VzZXJzL21hcmF0L1Byb2plY3RzL2Z1cmlvdXMuanMvbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvYXNzZXJ0aW9uLmpzIiwiL1VzZXJzL21hcmF0L1Byb2plY3RzL2Z1cmlvdXMuanMvbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvY29uZmlnLmpzIiwiL1VzZXJzL21hcmF0L1Byb2plY3RzL2Z1cmlvdXMuanMvbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvY29yZS9hc3NlcnRpb25zLmpzIiwiL1VzZXJzL21hcmF0L1Byb2plY3RzL2Z1cmlvdXMuanMvbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvaW50ZXJmYWNlL2Fzc2VydC5qcyIsIi9Vc2Vycy9tYXJhdC9Qcm9qZWN0cy9mdXJpb3VzLmpzL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL2ludGVyZmFjZS9leHBlY3QuanMiLCIvVXNlcnMvbWFyYXQvUHJvamVjdHMvZnVyaW91cy5qcy9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS9pbnRlcmZhY2Uvc2hvdWxkLmpzIiwiL1VzZXJzL21hcmF0L1Byb2plY3RzL2Z1cmlvdXMuanMvbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvYWRkQ2hhaW5hYmxlTWV0aG9kLmpzIiwiL1VzZXJzL21hcmF0L1Byb2plY3RzL2Z1cmlvdXMuanMvbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvYWRkTWV0aG9kLmpzIiwiL1VzZXJzL21hcmF0L1Byb2plY3RzL2Z1cmlvdXMuanMvbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvYWRkUHJvcGVydHkuanMiLCIvVXNlcnMvbWFyYXQvUHJvamVjdHMvZnVyaW91cy5qcy9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS91dGlscy9mbGFnLmpzIiwiL1VzZXJzL21hcmF0L1Byb2plY3RzL2Z1cmlvdXMuanMvbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvZ2V0QWN0dWFsLmpzIiwiL1VzZXJzL21hcmF0L1Byb2plY3RzL2Z1cmlvdXMuanMvbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvZ2V0RW51bWVyYWJsZVByb3BlcnRpZXMuanMiLCIvVXNlcnMvbWFyYXQvUHJvamVjdHMvZnVyaW91cy5qcy9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS91dGlscy9nZXRNZXNzYWdlLmpzIiwiL1VzZXJzL21hcmF0L1Byb2plY3RzL2Z1cmlvdXMuanMvbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvZ2V0TmFtZS5qcyIsIi9Vc2Vycy9tYXJhdC9Qcm9qZWN0cy9mdXJpb3VzLmpzL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL3V0aWxzL2dldFBhdGhWYWx1ZS5qcyIsIi9Vc2Vycy9tYXJhdC9Qcm9qZWN0cy9mdXJpb3VzLmpzL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL3V0aWxzL2dldFByb3BlcnRpZXMuanMiLCIvVXNlcnMvbWFyYXQvUHJvamVjdHMvZnVyaW91cy5qcy9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS91dGlscy9pbmRleC5qcyIsIi9Vc2Vycy9tYXJhdC9Qcm9qZWN0cy9mdXJpb3VzLmpzL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL3V0aWxzL2luc3BlY3QuanMiLCIvVXNlcnMvbWFyYXQvUHJvamVjdHMvZnVyaW91cy5qcy9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS91dGlscy9vYmpEaXNwbGF5LmpzIiwiL1VzZXJzL21hcmF0L1Byb2plY3RzL2Z1cmlvdXMuanMvbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvb3ZlcndyaXRlQ2hhaW5hYmxlTWV0aG9kLmpzIiwiL1VzZXJzL21hcmF0L1Byb2plY3RzL2Z1cmlvdXMuanMvbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvb3ZlcndyaXRlTWV0aG9kLmpzIiwiL1VzZXJzL21hcmF0L1Byb2plY3RzL2Z1cmlvdXMuanMvbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvb3ZlcndyaXRlUHJvcGVydHkuanMiLCIvVXNlcnMvbWFyYXQvUHJvamVjdHMvZnVyaW91cy5qcy9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS91dGlscy90ZXN0LmpzIiwiL1VzZXJzL21hcmF0L1Byb2plY3RzL2Z1cmlvdXMuanMvbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvdHJhbnNmZXJGbGFncy5qcyIsIi9Vc2Vycy9tYXJhdC9Qcm9qZWN0cy9mdXJpb3VzLmpzL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL3V0aWxzL3R5cGUuanMiLCIvVXNlcnMvbWFyYXQvUHJvamVjdHMvZnVyaW91cy5qcy9ub2RlX21vZHVsZXMvY2hhaS9ub2RlX21vZHVsZXMvYXNzZXJ0aW9uLWVycm9yL2luZGV4LmpzIiwiL1VzZXJzL21hcmF0L1Byb2plY3RzL2Z1cmlvdXMuanMvbm9kZV9tb2R1bGVzL2NoYWkvbm9kZV9tb2R1bGVzL2RlZXAtZXFsL2luZGV4LmpzIiwiL1VzZXJzL21hcmF0L1Byb2plY3RzL2Z1cmlvdXMuanMvbm9kZV9tb2R1bGVzL2NoYWkvbm9kZV9tb2R1bGVzL2RlZXAtZXFsL2xpYi9lcWwuanMiLCIvVXNlcnMvbWFyYXQvUHJvamVjdHMvZnVyaW91cy5qcy9ub2RlX21vZHVsZXMvY2hhaS9ub2RlX21vZHVsZXMvZGVlcC1lcWwvbm9kZV9tb2R1bGVzL3R5cGUtZGV0ZWN0L2luZGV4LmpzIiwiL1VzZXJzL21hcmF0L1Byb2plY3RzL2Z1cmlvdXMuanMvbm9kZV9tb2R1bGVzL2NoYWkvbm9kZV9tb2R1bGVzL2RlZXAtZXFsL25vZGVfbW9kdWxlcy90eXBlLWRldGVjdC9saWIvdHlwZS5qcyIsIi9Vc2Vycy9tYXJhdC9Qcm9qZWN0cy9mdXJpb3VzLmpzL25vZGVfbW9kdWxlcy9ncnVudC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L2xpYi9fZW1wdHkuanMiLCIvVXNlcnMvbWFyYXQvUHJvamVjdHMvZnVyaW91cy5qcy9ub2RlX21vZHVsZXMvZ3J1bnQtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnVmZmVyL2luZGV4LmpzIiwiL1VzZXJzL21hcmF0L1Byb2plY3RzL2Z1cmlvdXMuanMvbm9kZV9tb2R1bGVzL2dydW50LWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2J1ZmZlci9ub2RlX21vZHVsZXMvYmFzZTY0LWpzL2xpYi9iNjQuanMiLCIvVXNlcnMvbWFyYXQvUHJvamVjdHMvZnVyaW91cy5qcy9ub2RlX21vZHVsZXMvZ3J1bnQtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnVmZmVyL25vZGVfbW9kdWxlcy9pZWVlNzU0L2luZGV4LmpzIiwiL1VzZXJzL21hcmF0L1Byb2plY3RzL2Z1cmlvdXMuanMvbm9kZV9tb2R1bGVzL2dydW50LWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3BhdGgtYnJvd3NlcmlmeS9pbmRleC5qcyIsIi9Vc2Vycy9tYXJhdC9Qcm9qZWN0cy9mdXJpb3VzLmpzL25vZGVfbW9kdWxlcy9ncnVudC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCIvVXNlcnMvbWFyYXQvUHJvamVjdHMvZnVyaW91cy5qcy9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9kaXN0L1Byb3RvQnVmLmpzIiwiL1VzZXJzL21hcmF0L1Byb2plY3RzL2Z1cmlvdXMuanMvbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvaW5kZXguanMiLCIvVXNlcnMvbWFyYXQvUHJvamVjdHMvZnVyaW91cy5qcy9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9ub2RlX21vZHVsZXMvYnl0ZWJ1ZmZlci9kaXN0L0J5dGVCdWZmZXJBQi5taW4uanMiLCIvVXNlcnMvbWFyYXQvUHJvamVjdHMvZnVyaW91cy5qcy9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9ub2RlX21vZHVsZXMvYnl0ZWJ1ZmZlci9ub2RlX21vZHVsZXMvbG9uZy9kaXN0L0xvbmcuanMiLCIvVXNlcnMvbWFyYXQvUHJvamVjdHMvZnVyaW91cy5qcy9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9ub2RlX21vZHVsZXMvYnl0ZWJ1ZmZlci9ub2RlX21vZHVsZXMvbG9uZy9pbmRleC5qcyIsIi9Vc2Vycy9tYXJhdC9Qcm9qZWN0cy9mdXJpb3VzLmpzL3Rlc3QvQ29udGV4dC50ZXN0LmpzIiwiL1VzZXJzL21hcmF0L1Byb2plY3RzL2Z1cmlvdXMuanMvdGVzdC9EYXRhVHlwZS50ZXN0LmpzIiwiL1VzZXJzL21hcmF0L1Byb2plY3RzL2Z1cmlvdXMuanMvdGVzdC9OREFycmF5LnRlc3QuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3J5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3haQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbGZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3psQ0E7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNseUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hpQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9HQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaFVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3REQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5R0E7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDalFBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5SUE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6NkhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdDdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3Rocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIil9dmFyIGY9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGYuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sZixmLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIlwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIEEgbnVtZXJpY2FsIGRhdGEgdHlwZSBvYmplY3QuXG4gKlxuICogQGNsYXNzIERhdGFUeXBlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIC0gdGhlIGFiYnJldmlhdGVkIG5hbWUgb2YgdGhlIGRhdGEgdHlwZS4gVGhlIGZvbGxvd2luZyBuYW1lcyBhcmUgc3VwcG9ydGVkOlxuICpcbiAqICAgICA8dGFibGU+XG4gKiAgICAgICAgIDx0cj5cbiAqICAgICAgICAgICAgIDx0aD5BYmJyZXZpYXRlZCBOYW1lPC90aD5cbiAqICAgICAgICAgICAgIDx0aD5JbnRlcnByZXRhdGlvbjwvdGg+XG4gKiAgICAgICAgIDwvdHI+XG4gKiAgICAgICAgIDx0cj5cbiAqICAgICAgICAgICAgIDx0ZD5cImYzMlwiPC90ZD5cbiAqICAgICAgICAgICAgIDx0ZD5TaW5nbGUtcHJlY2lzaW9uICgzMi1iaXQpIElFRUUtNzU0IGZsb2F0aW5nLXBvaW50IHR5cGUuPC90ZD5cbiAqICAgICAgICAgPC90cj5cbiAqICAgICAgICAgPHRyPlxuICogICAgICAgICAgICAgPHRkPlwiZjY0XCI8L3RkPlxuICogICAgICAgICAgICAgPHRkPkRvdWJsZS1wcmVjaXNpb24gKDY0LWJpdCkgSUVFRS03NTQgZmxvYXRpbmctcG9pbnQgdHlwZS48L3RkPlxuICogICAgICAgICA8L3RyPlxuICogICAgIDwvdGFibGU+XG4gKlxuICovXG5mdW5jdGlvbiBEYXRhVHlwZSh0eXBlKSB7XG5cdGlmIChbXCJmMzJcIiwgXCJmNjRcIl0uaW5kZXhPZih0eXBlKSA+PSAwKSB7XG5cdFx0dGhpcy50eXBlID0gdHlwZTtcblx0XHR0aGlzLnNpemUgPSB7XCJmMzJcIjogNCwgXCJmNjRcIjogOH1bdHlwZV07XG5cdFx0dGhpcy5lcHNpbG9uID0ge1wiZjMyXCI6IDEuMTkyMDkyODk1NTA3ODEyNWUtNywgXCJmNjRcIjogMi4yMjA0NDYwNDkyNTAzMTMxZS0xNn1bdHlwZV07XG5cdFx0dGhpcy5hcnJheVR5cGUgPSB7XCJmMzJcIjogRmxvYXQzMkFycmF5LCBcImY2NFwiOiBGbG9hdDY0QXJyYXl9W3R5cGVdO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBSYW5nZUVycm9yKFwiVHlwZSBcIiArIHR5cGUgKyBcIiBpcyBub3Qgc3VwcG9ydGVkXCIpO1xuXHR9XG59XG5cbi8qKlxuICogQ29tcGFyZXMgdHdvIGRhdGEgdHlwZSBvYmplY3RzIGZvciBlcXVhbGl0eS5cbiAqXG4gKiBAbWV0aG9kIGVxdWFsc1xuICogQHBhcmFtIHthbnl9IG90aGVyIC0gYW4gb2JqZWN0IHRvIGNvbXBhcmUgdG8uXG4gKi9cbkRhdGFUeXBlLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbihvdGhlcikge1xuXHRyZXR1cm4gKG90aGVyIGluc3RhbmNlb2YgRGF0YVR5cGUpICYmICh0aGlzLmFycmF5VHlwZSA9PT0gb3RoZXIuYXJyYXlUeXBlKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRGF0YVR5cGU7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xudmFyIERhdGFUeXBlID0gcmVxdWlyZShcIi4vRGF0YVR5cGVcIik7XG5cbi8qKlxuICogQW4gb3BhcXVlIE4tZGltZW5zaW9uYWwgYXJyYXkgb2JqZWN0LlxuICpcbiAqIEBjbGFzcyBOREFycmF5XG4gKi9cblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGFuIE5EQXJyYXkgb2JqZWN0IHdpdGhvdXQgZGF0YS5cbiAqIE5vcm1hbGx5IHRoaXMgY29uc3RydWN0b3IgaXMgY2FsbGVkIGZyb20gYXJyYXkgY29uc3RydWN0aW9uIG1ldGhvZHMgb2YgY29tcHV0YXRpb25hbCBjb250ZXh0cy5cbiAqIFRoZSBjYWxsaW5nIGZ1bmN0aW9uIGlzIHJlc3BvbnNpYmxlIGZvciBpbml0aWFsaXppbmcgdGhlIGRhdGEgZm9yIHRoZSBhcnJheS5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIE5EQXJyYXkoc2hhcGUsIGRhdGFUeXBlLCBjb250ZXh0KSB7XG5cdGlmICh0eXBlb2YgY29udGV4dCA9PT0gXCJ1bmRlZmluZWRcIikge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIkNvbnRleHQgbm90IGRlZmluZWRcIik7XG5cdH1cblx0aWYgKCF1dGlsLmlzUG9zaXRpdmVJbnRBcnJheShzaGFwZSkgJiYgIXV0aWwuaXNQb3NpdGl2ZUludChzaGFwZSkpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKHNoYXBlICsgXCIgaXMgbm90IGEgdmFsaWQgYXJyYXkgc2hhcGVcIik7XG5cdH1cblx0aWYgKHR5cGVvZiBkYXRhVHlwZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuXHRcdGRhdGFUeXBlID0gbmV3IERhdGFUeXBlKFwiZjY0XCIpO1xuXHR9IGVsc2UgaWYgKCEoZGF0YVR5cGUgaW5zdGFuY2VvZiBEYXRhVHlwZSkpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKGRhdGFUeXBlICsgXCIgaXMgbm90IGFuIGluc3RhbmNlIG9mIERhdGFUeXBlXCIpO1xuXHR9XG5cdHRoaXMuc2hhcGUgPSBzaGFwZTtcblx0dGhpcy5kYXRhVHlwZSA9IGRhdGFUeXBlO1xuXHR0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcblx0dGhpcy5sZW5ndGggPSB1dGlsLmNvbXB1dGVMZW5ndGgodGhpcy5zaGFwZSk7XG5cdHRoaXMuX2xvY2tDb3VudCA9IDA7XG5cdHRoaXMuX3JlZkNvdW50ID0gMTtcblx0dGhpcy5faXNWYWxpZCA9IHRydWU7XG59XG5cbi8qKlxuICogTG9ja3MgdGhlIGFycmF5IHJlZmVyZW5jZSBjb3VudGVyLlxuICogV2hpbGUgdGhlIGFycmF5IGlzIGxvY2tlZCwgZnVuY3Rpb25zIGFuZCBtZXRob2RzIHRoYXQgb3BlcmF0ZSBvbiB0aGlzIGFycmF5IGRvIG5vdCBkZWNyZWFzZSBpdHMgcmVmZXJlbmNlIGNvdW50LlxuICogVGhlIGFycmF5IGNhbiBiZSBsb2NrZWQgbXVsdGlwbGUgdGltZXMsIGFuZCB3b3VsZCBuZWVkIGp1c3QgYXMgbWFueSB1bmxvY2sgY2FsbHMgdG8gbGlmdCB0aGUgbG9jay5cbiAqIElmIHRoZSBhcnJheSBpcyBub3QgdmFsaWQsIHRoaXMgb3BlcmF0aW9uIHdpbGwgZmFpbCB3aXRoIGFuIGVycm9yLlxuICpcbiAqIEBtZXRob2QgbG9ja1xuICogQGNoYWluYWJsZVxuICovXG5OREFycmF5LnByb3RvdHlwZS5sb2NrID0gZnVuY3Rpb24oKSB7XG5cdGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJBdHRlbXB0ZWQgdG8gbG9jayBhbiBpbnZhbGlkYXRlZCBhcnJheVwiKTtcblx0fVxuXHR0aGlzLl9sb2NrQ291bnQrKztcblx0cmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFVubG9ja3MgdGhlIGFycmF5IHJlZmVyZW5jZSBjb3VudGVyLlxuICogT25jZSB0aGUgYXJyYXkgaXMgdW5sb2NrZWQsIGZ1bmN0aW9ucyBhbmQgbWV0aG9kcyB0aGF0IG9wZXJhdGUgb24gdGhpcyBhcnJheSBkZWNyZWFzZSBpdHMgcmVmZXJlbmNlIGNvdW50IGFuZCwgaWYgdGhlIHJlZmVyZW5jZSBjb3VudCByZWFjaGVzIHplcm8sIGludmFsaWRhdGUgdGhlIGFycmF5LlxuICogSWYgdGhlIGFycmF5IHdhcyBsb2NrZWQgbXVsdGlwbGUgdGltZXMsIGl0IHdvdWxkIG5lZWQganVzdCBhcyBtYW55IHVubG9jayBjYWxscyB0byBsaWZ0IHRoZSBsb2NrLlxuICogSWYgdGhlIGFycmF5IGlzIG5vdCBsb2NrZWQsIHRoaXMgb3BlcmF0aW9uIHdpbGwgZmFpbCB3aXRoIGFuIGVycm9yLlxuICpcbiAqIEBtZXRob2QgdW5sb2NrXG4gKiBAY2hhaW5hYmxlXG4gKi9cbk5EQXJyYXkucHJvdG90eXBlLnVubG9jayA9IGZ1bmN0aW9uKCkge1xuXHRpZiAoIXRoaXMuaXNMb2NrZWQoKSkge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIkF0dGVtcHRlZCB0byBsb2NrIGEgdW5sb2NrZWQgYXJyYXlcIik7XG5cdH1cblx0dGhpcy5fbG9ja0NvdW50LS07XG5cdHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDaGVja2VzIGlmIHRoZSBhcnJheSBpcyBpbiB0aGUgbG9ja2VkIHN0YXRlLlxuICogSWYgdGhlIGFycmF5IGlzIG5vdCB2YWxpZCwgdGhpcyBtZXRob2QgcmV0dXJuIGZhbHNlLlxuICpcbiAqIEBtZXRob2QgaXNMb2NrZWRcbiAqXG4gKiBAcmV0dXJuIHtCb29sZWFufSAtIHRydWUgaXMgdGhlIGFycmF5IGlzIGxvY2tlZCBhbmQgZmFsc2Ugb3RoZXJ3aXNlXG4gKi9cbk5EQXJyYXkucHJvdG90eXBlLmlzTG9ja2VkID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLl9sb2NrQ291bnQgPiAwO1xufTtcblxuLyoqXG4gKiBJbmNyZW1lbnRzIHRoZSBhcnJheSByZWZlcmVuY2UgY291bnQuXG4gKiBJZiB0aGUgYXJyYXkgaXMgaW52YWxpZCBvciBsb2NrZWQsIHRoaXMgb3BlcmF0aW9uIHdpbGwgZmFpbCB3aXRoIGFuIGVycm9yLlxuICpcbiAqIEBtZXRob2QgcmV0YWluXG4gKiBAY2hhaW5hYmxlXG4gKi9cbk5EQXJyYXkucHJvdG90eXBlLnJldGFpbiA9IGZ1bmN0aW9uKCkge1xuXHRpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiQXR0ZW1wdGVkIHRvIHJlbGVhc2UgYW4gaW52YWxpZGF0ZWQgYXJyYXlcIik7XG5cdH1cblx0aWYgKHRoaXMuaXNMb2NrZWQoKSkge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIkF0dGVtcHRlZCB0byByZXRhaW4gYSBsb2NrZWQgYXJyYXlcIik7XG5cdH1cblx0dGhpcy5fcmVmQ291bnQrKztcblx0cmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIERlY3JlbWVudHMgdGhlIGFycmF5IHJlZmVyZW5jZSBjb3VudC4gSWYgdGhlIHJlZmVyZW5jZSBjb3VudCB0dXJucyB6ZXJvLCB0aGUgYXJyYXkgYmVjb21lcyBpbnZhbGlkIGFuZCBpdHMgZGF0YSBidWZmZXIgaXMgZGVhbGxvY2F0ZWQuXG4gKiBJZiB0aGUgYXJyYXkgaXMgaW52YWxpZCBvciBsb2NrZWQsIHRoaXMgb3BlcmF0aW9uIHdpbGwgZmFpbCB3aXRoIGFuIGVycm9yLlxuICpcbiAqIEBtZXRob2QgcmVsZWFzZVxuICogQGNoYWluYWJsZVxuICovXG5OREFycmF5LnByb3RvdHlwZS5yZWxlYXNlID0gZnVuY3Rpb24oKSB7XG5cdGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJBdHRlbXB0ZWQgdG8gcmVsZWFzZSBhbiBpbnZhbGlkYXRlZCBhcnJheVwiKTtcblx0fVxuXHRpZiAodGhpcy5pc0xvY2tlZCgpKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiQXR0ZW1wdGVkIHRvIHJlbGVhc2UgYSBsb2NrZWQgYXJyYXlcIik7XG5cdH1cblx0aWYgKC0tdGhpcy5fcmVmQ291bnQgPT09IDApIHtcblx0XHR0aGlzLl9jb250ZXh0Ll9pbnZhbGlkYXRlKHRoaXMpO1xuXHR9XG5cdHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBGb3IgYSBub24tbG9ja2VkIGFycmF5LCBkZWNyZW1lbnRzIHRoZSBhcnJheSByZWZlcmVuY2UgY291bnQuIElmIHRoZSByZWZlcmVuY2UgY291bnQgdHVybnMgemVybywgdGhlIGFycmF5IGJlY29tZXMgaW52YWxpZCBhbmQgaXRzIGRhdGEgYnVmZmVyIGlzIGRlYWxsb2NhdGVkLlxuICogSWYgdGhlIGFycmF5IGlzIGludmFsaWQsIHRoaXMgb3BlcmF0aW9uIHdpbGwgZmFpbCB3aXRoIGFuIGVycm9yLlxuICpcbiAqIEBtZXRob2QgdHJ5UmVsZWFzZVxuICogQGNoYWluYWJsZVxuICovXG5OREFycmF5LnByb3RvdHlwZS50cnlSZWxlYXNlID0gZnVuY3Rpb24oKSB7XG5cdGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJBdHRlbXB0ZWQgdG8gcmVsZWFzZSBhbiBpbnZhbGlkYXRlZCBhcnJheVwiKTtcblx0fVxuXHRpZiAoIXRoaXMuaXNMb2NrZWQoKSkge1xuXHRcdGlmICgtLXRoaXMuX3JlZkNvdW50ID09PSAwKSB7XG5cdFx0XHR0aGlzLl9jb250ZXh0Ll9pbnZhbGlkYXRlKHRoaXMpO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRm9yIGEgbm9uLWxvY2tlZCBhcnJheSwgZGVjcmVtZW50cyB0aGUgYXJyYXkgcmVmZXJlbmNlIGNvdW50LiBJZiB0aGUgcmVmZXJlbmNlIGNvdW50IHR1cm5zIHplcm8sIHRoZSBhcnJheSBiZWNvbWVzIGludmFsaWQgYW5kIGl0cyBkYXRhIGJ1ZmZlciBpcyBkZWFsbG9jYXRlZC5cbiAqIFRoZSBhcnJheSBtdXN0IGJlIHZhbGlkIHRvIHBlcmZvcm0gdGhpcyBvcGVyYXRpb24uXG4gKlxuICogQHByaXZhdGVcbiAqIEBtZXRob2QgX3RyeVJlbGVhc2VcbiAqIEBjaGFpbmFibGVcbiAqL1xuTkRBcnJheS5wcm90b3R5cGUuX3RyeVJlbGVhc2UgPSBmdW5jdGlvbigpIHtcblx0aWYgKCF0aGlzLmlzTG9ja2VkKCkpIHtcblx0XHRpZiAoLS10aGlzLl9yZWZDb3VudCA9PT0gMCkge1xuXHRcdFx0dGhpcy5fY29udGV4dC5faW52YWxpZGF0ZSh0aGlzKTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEludmFsaWRhdGVzIHRoZSBhcnJheSBhbmQgZGVhbGxvY2F0ZXMgaXRzIGRhdGEgYnVmZmVyLCByZWdhcmRsZXNzIG9mIGxvY2tzIGFuZCByZWZlcmVuY2UgY291bnQuXG4gKiBDYWxsaW5nIHRoaXMgbWV0aG9kIG9uIGFuIGludmFsaWRhdGVkIGFycmF5IGhhcyBubyBlZmZlY3QuXG4gKlxuICogQG1ldGhvZCBpbnZhbGlkYXRlXG4gKiBAY2hhaW5hYmxlXG4gKi9cbk5EQXJyYXkucHJvdG90eXBlLmludmFsaWRhdGUgPSBmdW5jdGlvbigpIHtcblx0aWYgKHRoaXMuaXNWYWxpZCgpKSB7XG5cdFx0dGhpcy5fY29udGV4dC5faW52YWxpZGF0ZSh0aGlzKTtcblx0XHR0aGlzLl9pc1ZhbGlkID0gZmFsc2U7XG5cdFx0dGhpcy5fcmVmQ291bnQgPSAwO1xuXHRcdHRoaXMuX2xvY2tDb3VudCA9IDA7XG5cdH1cblx0cmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENoZWNrZXMgaWYgdGhlIGFycmF5IGlzIGluIGEgdmFsaWQgc3RhdGUuXG4gKiBJZiB0aGUgYXJyYXkgaXMgbm90IGluIGEgdmFsaWQgc3RhdGUsIGl0cyBkYXRhIGJ1ZmZlciB3YXMgZGVhbGxvY2F0ZWQsIGFuZCBhbnkgb3BlcmF0aW9ucyBvbiB0aGUgYXJyYXkgd2lsbCB0aHJvdyBhbiBlcnJvci5cbiAqXG4gKiBAbWV0aG9kIGlzVmFsaWRcbiAqXG4gKiBAcmV0dXJuIHtCb29sZWFufSAtIHRydWUgaXMgdGhlIGFycmF5IGlzIHZhbGlkIGFuZCBmYWxzZSBvdGhlcndpc2VcbiAqL1xuTkRBcnJheS5wcm90b3R5cGUuaXNWYWxpZCA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcy5faXNWYWxpZDtcbn07XG5cbi8qKlxuICogRGVjcmVtZW50cyB0aGUgYXJyYXkgcmVmZXJlbmNlIGNvdW50IGlmIHRoZSBhcnJheSBpcyBub3QgbG9ja2VkLlxuICogVGhpcyBmdW5jdGlvbiBkb2VzIG5vdCBpbnZhbGlkYXRlIHRoZSBhcnJheSB3aGVuIHRoZSByZWZlcmVuY2UgY291bnQgcmVhY2ggemVyby5cbiAqIFRoZSBjYWxsZXIgaXMgcmVzcG9uc2libGUgZm9yIGludmFsaWRhdGluZyBhcnJheSBpZiBpdHMgcmVmZXJlbmNlIGNvdW50IGlzIHplcm8gYWZ0ZXIgdGhlIG9wZXJhdGlvbi5cbiAqXG4gKiBGb3IgYSBsb2NrZWQgYXJyYXkgdGhlIG1ldGhvZCBoYXMgbm8gZWZmZWN0IGFuZCBhbHdheXMgcmV0dXJucyB0cnVlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbWV0aG9kIF9kZWNSZWZcbiAqIEBwYXJhbSB7TkRBcnJheX0gYXJyYXkgLSB0aGUgYXJyYXkgdG8gZGVjcmVtZW50IHRoZSByZWZlcmVuY2UgY291bnQgZm9yLiBNdXN0IGJlIHZhbGlkIGJlZm9yZSB0aGUgY2FsbC5cbiAqIEByZXR1cm4ge0Jvb2xlYW59IC0gdHJ1ZSBpZiB0aGUgcmVmZXJlbmNlIGNvdW50IGlzIG5vbi16ZXJvIGFmdGVyIHRoZSBvcGVyYXRpb24gYW5kIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuTkRBcnJheS5wcm90b3R5cGUuX2RlY1JlZiA9IGZ1bmN0aW9uKGFycmF5KSB7XG5cdGlmICh0aGlzLl9sb2NrQ291bnQgPT09IDApIHtcblx0XHQtLXRoaXMuX3JlZkNvdW50O1xuXHR9XG5cdHJldHVybiB0aGlzLl9yZWZDb3VudCAhPT0gMDtcbn07XG5cbi8qKlxuICogSW5jcmVtZW50cyB0aGUgYXJyYXkgcmVmZXJlbmNlIGNvdW50IGlmIHRoZSBhcnJheSBpcyBub3QgbG9ja2VkLlxuICogRm9yIGEgbG9ja2VkIGFycmF5IHRoZSBtZXRob2QgaGFzIG5vIGVmZmVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG1ldGhvZCBfaW5jUmVmXG4gKiBAY2hhaW5hYmxlXG4gKiBAcGFyYW0ge05EQXJyYXl9IGFycmF5IC0gdGhlIGFycmF5IHRvIGluY3JlbWVudCB0aGUgcmVmZXJlbmNlIGNvdW50IGZvci4gTXVzdCBiZSB2YWxpZCBiZWZvcmUgdGhlIGNhbGwsIGJ1dCBtYXkgaGF2ZSB6ZXJvIHJlZmVyZW5jZSBjb3VudC5cbiAqL1xuTkRBcnJheS5wcm90b3R5cGUuX2luY1JlZiA9IGZ1bmN0aW9uKGFycmF5KSB7XG5cdGlmICh0aGlzLl9sb2NrQ291bnQgPT09IDApIHtcblx0XHQrK3RoaXMuX3JlZkNvdW50O1xuXHR9XG5cdHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGFycmF5IGlzIGxvY2tlZCBvciBoYXMgYW55IHJlZmVyZW5jZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBtZXRob2QgX2hhc1JlZnNcbiAqIEBwYXJhbSB7TkRBcnJheX0gYXJyYXkgLSB0aGUgYXJyYXkgdG8gY2hlY2suIE11c3QgYmUgdmFsaWQgYmVmb3JlIHRoZSBjYWxsLCBidXQgbWF5IGhhdmUgemVybyByZWZlcmVuY2UgY291bnQuXG4gKiBAcmV0dXJuIHtCb29sZWFufSAtIHRydWUgaWYgdGhlIGFycmF5IGlzIGxvY2tlZCBvciBoYXMgcmVmZXJlbmNlcyBhbmQgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5OREFycmF5LnByb3RvdHlwZS5faGFzUmVmcyA9IGZ1bmN0aW9uKGFycmF5KSB7XG5cdHJldHVybiAodGhpcy5fbG9ja0NvdW50ICE9PSAwKSB8fCAodGhpcy5fcmVmQ291bnQgIT09IDApO1xufTtcblxuLyoqXG4gKiBJbnZhbGlkYXRlcyB0aGUgYXJyYXkgaWYgaXQgdmFsaWQsIG5vdCBsb2NrZWQsIGFuZCBoYXMgemVybyByZWZlcmVuY2UgY291bnQuXG4gKiBIYXMgbm8gZWZmZWN0IGluIGFsbCBvdGhlciBjYXNlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG1ldGhvZCBfdHJ5SW52YWxpZGF0ZVxuICogQHBhcmFtIHtOREFycmF5fSBhcnJheSAtIHRoZSBhcnJheSB0byB0cnkgdG8gaW52YWxpZGF0ZS4gQ2FuIGJlIGludmFsaWQuXG4gKiBAcmV0dXJuIHtCb29sZWFufSAtIHRydWUgaWYgdGhlIGFycmF5IHdhcyBpbnZhbGlkYXRlZCBieSB0aGlzIGNhbGwgYW5kIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuTkRBcnJheS5wcm90b3R5cGUuX3RyeUludmFsaWRhdGUgPSBmdW5jdGlvbihhcnJheSkge1xuXHRpZiAodGhpcy5pc1ZhbGlkKCkgJiYgIXRoaXMuX2hhc1JlZnMoKSkge1xuXHRcdHRoaXMuX2NvbnRleHQuX2ludmFsaWRhdGUodGhpcyk7XG5cdFx0dGhpcy5faXNWYWxpZCA9IGZhbHNlO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9IGVsc2Uge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufTtcblxuLyoqXG4gKiBBZGRzIGFub3RoZXIgYXJyYXkgb3IgYSBudW1iZXIgdG8gdGhpcyBhcnJheS5cbiAqXG4gKiBAbWV0aG9kIGFkZFxuICogQHBhcmFtIHsoTkRBcnJheXxOdW1iZXIpfSBvdGhlciAtIHRoZSBhcnJheSBvciBzY2FsYXIgdG8gYmUgYWRkZWQuXG4gKiBAcmV0dXJuIHtOREFycmF5fVxuICovXG5OREFycmF5LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihvdGhlcikge1xuXHRyZXR1cm4gdGhpcy5fY29udGV4dC5hZGQodGhpcywgb3RoZXIpO1xufTtcblxuLyoqXG4gKiBTdWJ0cmFjdHMgYW5vdGhlciBhcnJheSBvciBhIG51bWJlciBmcm9tIHRoaXMgYXJyYXkuXG4gKlxuICogQG1ldGhvZCBzdWJcbiAqIEBwYXJhbSB7KE5EQXJyYXl8TnVtYmVyKX0gb3RoZXIgLSB0aGUgYXJyYXkgb3Igc2NhbGFyIHRvIGJlIHN1YnRyYWN0ZWQuXG4gKiBAcmV0dXJuIHtOREFycmF5fVxuICovXG5OREFycmF5LnByb3RvdHlwZS5zdWIgPSBmdW5jdGlvbihvdGhlcikge1xuXHRyZXR1cm4gdGhpcy5fY29udGV4dC5zdWIodGhpcywgb3RoZXIpO1xufTtcblxuLyoqXG4gKiBNdWx0aXBsaWVzIGFycmF5IGVsZW1lbnRzIGJ5IGFub3RoZXIgYXJyYXkgb3IgYnkgYSBudW1iZXIuXG4gKlxuICogQG1ldGhvZCBtdWxcbiAqIEBwYXJhbSB7KE5EQXJyYXl8TnVtYmVyKX0gb3RoZXIgLSB0aGUgYXJyYXkgb3Igc2NhbGFyIHRvIG11bHRpcGx5IGVsZW1lbnRzIGJ5LlxuICogQHJldHVybiB7TkRBcnJheX1cbiAqL1xuTkRBcnJheS5wcm90b3R5cGUubXVsID0gZnVuY3Rpb24ob3RoZXIpIHtcblx0cmV0dXJuIHRoaXMuX2NvbnRleHQubXVsKHRoaXMsIG90aGVyKTtcbn07XG5cbi8qKlxuICogRGl2aWRlcyBhcnJheSBlbGVtZW50cyBieSBhbm90aGVyIGFycmF5IG9yIGJ5IGEgbnVtYmVyLlxuICpcbiAqIEBtZXRob2QgZGl2XG4gKiBAcGFyYW0geyhOREFycmF5fE51bWJlcil9IG90aGVyIC0gdGhlIGFycmF5IG9yIHNjYWxhciB0byBkaXZpZGUgZWxlbWVudHMgYnkuXG4gKiBAcmV0dXJuIHtOREFycmF5fVxuICovXG5OREFycmF5LnByb3RvdHlwZS5kaXYgPSBmdW5jdGlvbihvdGhlcikge1xuXHRyZXR1cm4gdGhpcy5fY29udGV4dC5kaXYodGhpcywgb3RoZXIpO1xufTtcblxuLyoqXG4gKiBSZWR1Y2VzIGFycmF5IGVsZW1lbnRzIHVzaW5nIG1pbmltdW0gb3BlcmF0aW9uLlxuICogSWYgdGhlIGF4aXMgYXJndW1lbnQgaXMgcHJvdmlkZWQsIHRoZSBtZXRob2QgY29tcHV0ZXMgbWluaW11bSBvZiBlbGVtZW50cyBhbG9uZyB0aGUgc3BlY2lmaWVkIGF4aXMuXG4gKiBPdGhlcndpc2UsIHRoZSBtZXRob2QgY29tcHV0ZXMgYW4gYWxsLWFycmF5IG1pbmltdW0gb2YgdGhlIGVsZW1lbnRzIGFuZCByZXR1cm5zIHRoZW0gYXMgYSAxLWVsZW1lbnQgYXJyYXkuXG4gKlxuICogQG1ldGhvZCBtaW5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbYXhpc10gLSB0aGUgYXhpcyBhbG9uZyB3aGljaCB0aGUgbWluaW11bSBpcyBjb21wdXRlZC5cbiAqIEByZXR1cm4ge05EQXJyYXl9XG4gKi9cbk5EQXJyYXkucHJvdG90eXBlLm1pbiA9IGZ1bmN0aW9uKGF4aXMpIHtcblx0cmV0dXJuIHRoaXMuX2NvbnRleHQubWluKHRoaXMsIGF4aXMpO1xufTtcblxuLyoqXG4gKiBSZWR1Y2VzIGFycmF5IGVsZW1lbnRzIHVzaW5nIG1heGltdW0gb3BlcmF0aW9uLlxuICogSWYgdGhlIGF4aXMgYXJndW1lbnQgaXMgcHJvdmlkZWQsIHRoZSBtZXRob2QgY29tcHV0ZXMgbWF4aW11bSBvZiBlbGVtZW50cyBhbG9uZyB0aGUgc3BlY2lmaWVkIGF4aXMuXG4gKiBPdGhlcndpc2UsIHRoZSBtZXRob2QgY29tcHV0ZXMgYW4gYWxsLWFycmF5IG1heGltdW0gb2YgdGhlIGVsZW1lbnRzIGFuZCByZXR1cm5zIHRoZW0gYXMgYSAxLWVsZW1lbnQgYXJyYXkuXG4gKlxuICogQG1ldGhvZCBtaW5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbYXhpc10gLSB0aGUgYXhpcyBhbG9uZyB3aGljaCB0aGUgbWF4aW11bSBpcyBjb21wdXRlZC5cbiAqIEByZXR1cm4ge05EQXJyYXl9XG4gKi9cbk5EQXJyYXkucHJvdG90eXBlLm1heCA9IGZ1bmN0aW9uKGF4aXMpIHtcblx0cmV0dXJuIHRoaXMuX2NvbnRleHQubWF4KHRoaXMsIGF4aXMpO1xufTtcblxuLyoqXG4gKiBSZWR1Y2VzIGFycmF5IGVsZW1lbnRzIHVzaW5nIHN1bSBvcGVyYXRpb24uXG4gKiBJZiB0aGUgYXhpcyBhcmd1bWVudCBpcyBwcm92aWRlZCwgdGhlIG1ldGhvZCBjb21wdXRlcyBzdW0gb2YgZWxlbWVudHMgYWxvbmcgdGhlIHNwZWNpZmllZCBheGlzLlxuICogT3RoZXJ3aXNlLCB0aGUgbWV0aG9kIGNvbXB1dGVzIGFuIGFsbC1hcnJheSBzdW0gb2YgdGhlIGVsZW1lbnRzIGFuZCByZXR1cm5zIHRoZW0gYXMgYSAxLWVsZW1lbnQgYXJyYXkuXG4gKlxuICogQG1ldGhvZCBtaW5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbYXhpc10gLSB0aGUgYXhpcyBhbG9uZyB3aGljaCB0aGUgc3VtIGlzIGNvbXB1dGVkLlxuICogQHJldHVybiB7TkRBcnJheX1cbiAqL1xuTkRBcnJheS5wcm90b3R5cGUuc3VtID0gZnVuY3Rpb24oYXhpcykge1xuXHRyZXR1cm4gdGhpcy5fY29udGV4dC5zdW0odGhpcywgYXhpcyk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYW5vdGhlciBhcnJheSB3aXRoIHRoZSBzYW1lIGRhdGEsIGJ1dCBkaWZmZXJlbnQgZGltZW5zaW9ucy5cbiAqXG4gKiBAbWV0aG9kIHJlc2hhcGVcbiAqIEBwYXJhbSB7KE5EQXJyYXl8TnVtYmVyKX0gb3RoZXIgLSBkaW1lbnNpb25zIG9mIHRoZSBuZXcgYXJyYXkuXG4gKiBAcmV0dXJuIHtOREFycmF5fVxuICovXG5OREFycmF5LnByb3RvdHlwZS5yZXNoYXBlID0gZnVuY3Rpb24obmV3U2hhcGUpIHtcblx0cmV0dXJuIHRoaXMuX2NvbnRleHQucmVzaGFwZSh0aGlzLCBuZXdTaGFwZSk7XG59O1xuXG4vKipcbiAqIER1cGxpY2F0ZXMgYXJyYXkgZWxlbWVudHMgYWxvbmcgdGhlIHNwZWNpZmllZCBheGlzLlxuICpcbiAqIEBtZXRob2QgcmVwZWF0XG4gKiBAcGFyYW0ge051bWJlcn0gcmVwZWF0cyAtIHRoZSBudW1iZXIgb2YgdGltZXMgdG8gcmVwZWF0IGVhY2ggZWxlbWVudC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBheGlzIC0gdGhlIGF4aXMgYWxvbmcgd2hpY2ggdGhlIGVsZW1lbnRzIHdpbGwgYmUgZHVwbGljYXRlZC5cbiAqIEByZXR1cm4ge05EQXJyYXl9XG4gKi9cbk5EQXJyYXkucHJvdG90eXBlLnJlcGVhdCA9IGZ1bmN0aW9uKHJlcGVhdHMsIGF4aXMpIHtcblx0cmV0dXJuIHRoaXMuX2NvbnRleHQucmVwZWF0KHRoaXMsIHJlcGVhdHMsIGF4aXMpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGUgZGF0YSB0byBhIEphdmFTY3JpcHQgQXJyYXkuXG4gKlxuICogQG1ldGhvZCBnZXRcbiAqIEBhc3luY1xuICovXG5OREFycmF5LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuXHR0aGlzLl9jb250ZXh0LmdldCh0aGlzLCBjYWxsYmFjayk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE5EQXJyYXk7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIE5EQXJyYXkgPSByZXF1aXJlKFwiLi9OREFycmF5XCIpO1xudmFyIERhdGFUeXBlID0gcmVxdWlyZShcIi4vRGF0YVR5cGVcIik7XG52YXIgYWxsb2NhdG9yID0gcmVxdWlyZShcIi4vYWxsb2NhdG9yXCIpO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xudmFyIHJlcXVlc3RzID0gcmVxdWlyZShcIi4vcmVxdWVzdHMucGJcIik7XG52YXIgUmVxdWVzdCA9IHJlcXVlc3RzLlJlcXVlc3Q7XG52YXIgRW1wdHlBcnJheVJlcXVlc3QgPSByZXF1ZXN0cy5FbXB0eUFycmF5UmVxdWVzdDtcbnZhciBEYXRhQXJyYXlSZXF1ZXN0ID0gcmVxdWVzdHMuRGF0YUFycmF5UmVxdWVzdDtcbnZhciBDb25zdEFycmF5UmVxdWVzdCA9IHJlcXVlc3RzLkNvbnN0QXJyYXlSZXF1ZXN0O1xudmFyIExpbnNwYWNlUmVxdWVzdCA9IHJlcXVlc3RzLkxpbnNwYWNlUmVxdWVzdDtcbnZhciBSZXNoYXBlUmVxdWVzdCA9IHJlcXVlc3RzLlJlc2hhcGVSZXF1ZXN0O1xudmFyIFJlcGVhdFJlcXVlc3QgPSByZXF1ZXN0cy5SZXBlYXRSZXF1ZXN0O1xudmFyIERlYWxsb2NhdGVSZXF1ZXN0ID0gcmVxdWVzdHMuRGVhbGxvY2F0ZVJlcXVlc3Q7XG52YXIgRmV0Y2hSZXF1ZXN0ID0gcmVxdWVzdHMuRmV0Y2hSZXF1ZXN0O1xudmFyIEJpbmFyeU9wZXJhdGlvblJlcXVlc3QgPSByZXF1ZXN0cy5CaW5hcnlPcGVyYXRpb25SZXF1ZXN0O1xudmFyIEJpbmFyeUNvbnN0T3BlcmF0aW9uUmVxdWVzdCA9IHJlcXVlc3RzLkJpbmFyeUNvbnN0T3BlcmF0aW9uUmVxdWVzdDtcbnZhciBVbmFyeU9wZXJhdGlvblJlcXVlc3QgPSByZXF1ZXN0cy5VbmFyeU9wZXJhdGlvblJlcXVlc3Q7XG52YXIgUmVkdWN0aW9uUmVxdWVzdCA9IHJlcXVlc3RzLlJlZHVjdGlvblJlcXVlc3Q7XG52YXIgQXhpc1JlZHVjdGlvblJlcXVlc3QgPSByZXF1ZXN0cy5BeGlzUmVkdWN0aW9uUmVxdWVzdDtcbnZhciBEb3RPcGVyYXRpb25SZXF1ZXN0ID0gcmVxdWVzdHMuRG90T3BlcmF0aW9uUmVxdWVzdDtcbnZhciBSZXNwb25zZSA9IHJlcXVpcmUoXCIuL3Jlc3BvbnNlcy5wYlwiKS5SZXNwb25zZTtcblxudmFyIGRhdGFUeXBlTWFwID0ge1xuXHRcImYzMlwiOiByZXF1ZXN0cy5EYXRhVHlwZS5GTE9BVDMyLFxuXHRcImY2NFwiOiByZXF1ZXN0cy5EYXRhVHlwZS5GTE9BVDY0XG59O1xuXG5mdW5jdGlvbiBQQkNvbnRleHQob3B0aW9ucywgcG9zdE1lc3NhZ2UsIGNhbGxiYWNrKSB7XG5cdHZhciBjb250ZXh0ID0gdGhpcztcblx0dGhpcy5fcG9zdE1lc3NhZ2UgPSBwb3N0TWVzc2FnZTtcblx0dGhpcy5fY2FsbGJhY2tzID0ge307XG5cdHRoaXMuX2NhbGxiYWNrc1swXSA9IGZ1bmN0aW9uKGxpbWl0cykge1xuXHRcdGNhbGxiYWNrKGNvbnRleHQsIGxpbWl0cyk7XG5cdH07XG59XG5cblBCQ29udGV4dC5wcm90b3R5cGUuX29uTWVzc2FnZSA9IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcblx0dmFyIHJlc3BvbnNlID0gUmVzcG9uc2UuZGVjb2RlKG1lc3NhZ2UuZGF0YSk7XG5cdHZhciBpZCA9IHJlc3BvbnNlLmlkO1xuXHR2YXIgY2FsbGJhY2sgPSB0aGlzLl9jYWxsYmFja3NbaWRdO1xuXHRkZWxldGUgdGhpcy5fY2FsbGJhY2tzW2lkXTtcblx0c3dpdGNoIChyZXNwb25zZS50eXBlKSB7XG5cdFx0Y2FzZSBSZXNwb25zZS5UeXBlLklOSVQ6XG5cdFx0XHR2YXIgbGltaXRzID0ge307XG5cdFx0XHR2YXIgaW5pdFJlc3BvbnNlID0gcmVzcG9uc2UuaW5pdFJlc3BvbnNlO1xuXHRcdFx0aWYgKGluaXRSZXNwb25zZS5jb25jdXJyZW5jeSAhPT0gbnVsbCkge1xuXHRcdFx0XHRsaW1pdHMuY29uY3VycmVuY3kgPSBpbml0UmVzcG9uc2UuY29uY3VycmVuY3k7XG5cdFx0XHR9XG5cdFx0XHRjYWxsYmFjayhsaW1pdHMpO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSBSZXNwb25zZS5UeXBlLkJBUlJJRVI6XG5cdFx0XHRjYWxsYmFjaygpO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSBSZXNwb25zZS5UeXBlLkZFVENIOlxuXHRcdFx0Y2FsbGJhY2socmVzcG9uc2UuZmV0Y2hSZXNwb25zZS5kYXRhQnVmZmVyLnRvQXJyYXlCdWZmZXIoKSk7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlIFJlc3BvbnNlLlR5cGUuRVJST1I6XG5cdFx0XHRicmVhaztcblx0XHRjYXNlIFJlc3BvbnNlLlR5cGUuSU5GTzpcblx0XHRcdGJyZWFrO1xuXHR9XG59O1xuXG5QQkNvbnRleHQucHJvdG90eXBlLmVtcHR5ID0gZnVuY3Rpb24oc2hhcGUsIGRhdGFUeXBlKSB7XG5cdHNoYXBlID0gdXRpbC5jaGVja1NoYXBlKHNoYXBlKTtcblx0aWYgKHR5cGVvZiBkYXRhVHlwZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuXHRcdGRhdGFUeXBlID0gbmV3IERhdGFUeXBlKFwiZjY0XCIpO1xuXHR9IGVsc2UgaWYgKCEoZGF0YVR5cGUgaW5zdGFuY2VvZiBEYXRhVHlwZSkpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKGRhdGFUeXBlICsgXCIgaXMgbm90IGFuIGluc3RhbmNlIG9mIERhdGFUeXBlXCIpO1xuXHR9XG5cdHZhciBhcnJheSA9IG5ldyBOREFycmF5KHNoYXBlLCBkYXRhVHlwZSwgdGhpcyk7XG5cdGFycmF5Ll9pZCA9IGFsbG9jYXRvci5uZXdBcnJheUlkKCk7XG5cblx0dmFyIHJlcXVlc3QgPSBuZXcgUmVxdWVzdCgpO1xuXHRyZXF1ZXN0LmlkID0gYWxsb2NhdG9yLm5ld01lc3NhZ2VJZCgpO1xuXHRyZXF1ZXN0LnR5cGUgPSBSZXF1ZXN0LlR5cGUuRU1QVFlfQVJSQVk7XG5cdHZhciBlbXB0eUFycmF5UmVxdWVzdCA9IG5ldyBFbXB0eUFycmF5UmVxdWVzdCgpO1xuXHRlbXB0eUFycmF5UmVxdWVzdC5pZE91dCA9IGFycmF5Ll9pZDtcblx0ZW1wdHlBcnJheVJlcXVlc3Quc2hhcGUgPSBzaGFwZTtcblx0ZW1wdHlBcnJheVJlcXVlc3QuZGF0YVR5cGUgPSBkYXRhVHlwZU1hcFtkYXRhVHlwZS50eXBlXTtcblx0cmVxdWVzdC5lbXB0eUFycmF5UmVxdWVzdCA9IGVtcHR5QXJyYXlSZXF1ZXN0O1xuXHR0aGlzLl9wb3N0TWVzc2FnZShyZXF1ZXN0LmVuY29kZUFCKCkpO1xuXG5cdHJldHVybiBhcnJheTtcbn07XG5cblBCQ29udGV4dC5wcm90b3R5cGUuemVyb3MgPSBmdW5jdGlvbihzaGFwZSwgZGF0YVR5cGUpIHtcblx0c2hhcGUgPSB1dGlsLmNoZWNrU2hhcGUoc2hhcGUpO1xuXHRpZiAodHlwZW9mIGRhdGFUeXBlID09PSBcInVuZGVmaW5lZFwiKSB7XG5cdFx0ZGF0YVR5cGUgPSBuZXcgRGF0YVR5cGUoXCJmNjRcIik7XG5cdH0gZWxzZSBpZiAoIShkYXRhVHlwZSBpbnN0YW5jZW9mIERhdGFUeXBlKSkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoZGF0YVR5cGUgKyBcIiBpcyBub3QgYW4gaW5zdGFuY2Ugb2YgRGF0YVR5cGVcIik7XG5cdH1cblx0dmFyIGFycmF5ID0gbmV3IE5EQXJyYXkoc2hhcGUsIGRhdGFUeXBlLCB0aGlzKTtcblx0YXJyYXkuX2lkID0gYWxsb2NhdG9yLm5ld0FycmF5SWQoKTtcblxuXHR2YXIgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KCk7XG5cdHJlcXVlc3QuaWQgPSBhbGxvY2F0b3IubmV3TWVzc2FnZUlkKCk7XG5cdHJlcXVlc3QudHlwZSA9IFJlcXVlc3QuVHlwZS5DT05TVF9BUlJBWTtcblx0dmFyIGNvbnN0QXJyYXlSZXF1ZXN0ID0gbmV3IENvbnN0QXJyYXlSZXF1ZXN0KCk7XG5cdGNvbnN0QXJyYXlSZXF1ZXN0LmlkT3V0ID0gYXJyYXkuX2lkO1xuXHRjb25zdEFycmF5UmVxdWVzdC5zaGFwZSA9IHNoYXBlO1xuXHRjb25zdEFycmF5UmVxdWVzdC5kYXRhVHlwZSA9IGRhdGFUeXBlTWFwW2RhdGFUeXBlLnR5cGVdO1xuXHRjb25zdEFycmF5UmVxdWVzdC5maWxsVmFsdWUgPSAwLjA7XG5cdHJlcXVlc3QuY29uc3RBcnJheVJlcXVlc3QgPSBjb25zdEFycmF5UmVxdWVzdDtcblx0dGhpcy5fcG9zdE1lc3NhZ2UocmVxdWVzdC5lbmNvZGVBQigpKTtcblxuXHRyZXR1cm4gYXJyYXk7XG59O1xuXG5QQkNvbnRleHQucHJvdG90eXBlLm9uZXMgPSBmdW5jdGlvbihzaGFwZSwgZGF0YVR5cGUpIHtcblx0c2hhcGUgPSB1dGlsLmNoZWNrU2hhcGUoc2hhcGUpO1xuXHRpZiAodHlwZW9mIGRhdGFUeXBlID09PSBcInVuZGVmaW5lZFwiKSB7XG5cdFx0ZGF0YVR5cGUgPSBuZXcgRGF0YVR5cGUoXCJmNjRcIik7XG5cdH0gZWxzZSBpZiAoIShkYXRhVHlwZSBpbnN0YW5jZW9mIERhdGFUeXBlKSkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoZGF0YVR5cGUgKyBcIiBpcyBub3QgYW4gaW5zdGFuY2Ugb2YgRGF0YVR5cGVcIik7XG5cdH1cblx0dmFyIGFycmF5ID0gbmV3IE5EQXJyYXkoc2hhcGUsIGRhdGFUeXBlLCB0aGlzKTtcblx0YXJyYXkuX2lkID0gYWxsb2NhdG9yLm5ld0FycmF5SWQoKTtcblxuXHR2YXIgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KCk7XG5cdHJlcXVlc3QuaWQgPSBhbGxvY2F0b3IubmV3TWVzc2FnZUlkKCk7XG5cdHJlcXVlc3QudHlwZSA9IFJlcXVlc3QuVHlwZS5DT05TVF9BUlJBWTtcblx0dmFyIGNvbnN0QXJyYXlSZXF1ZXN0ID0gbmV3IENvbnN0QXJyYXlSZXF1ZXN0KCk7XG5cdGNvbnN0QXJyYXlSZXF1ZXN0LmlkT3V0ID0gYXJyYXkuX2lkO1xuXHRjb25zdEFycmF5UmVxdWVzdC5zaGFwZSA9IHNoYXBlO1xuXHRjb25zdEFycmF5UmVxdWVzdC5kYXRhVHlwZSA9IGRhdGFUeXBlTWFwW2RhdGFUeXBlLnR5cGVdO1xuXHRjb25zdEFycmF5UmVxdWVzdC5maWxsVmFsdWUgPSAxLjA7XG5cdHJlcXVlc3QuY29uc3RBcnJheVJlcXVlc3QgPSBjb25zdEFycmF5UmVxdWVzdDtcblx0dGhpcy5fcG9zdE1lc3NhZ2UocmVxdWVzdC5lbmNvZGVBQigpKTtcblxuXHRyZXR1cm4gYXJyYXk7XG59O1xuXG5QQkNvbnRleHQucHJvdG90eXBlLmFycmF5ID0gZnVuY3Rpb24oZGF0YSwgZGF0YVR5cGUpIHtcblx0dmFyIHNoYXBlID0gW107XG5cdHV0aWwuZGlzY292ZXJBcnJheVNoYXBlUmVjdXJzaXZlKGRhdGEsIHNoYXBlLCAwKTtcblx0aWYgKHR5cGVvZiBkYXRhVHlwZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuXHRcdGRhdGFUeXBlID0gbmV3IERhdGFUeXBlKFwiZjY0XCIpO1xuXHR9IGVsc2UgaWYgKCEoZGF0YVR5cGUgaW5zdGFuY2VvZiBEYXRhVHlwZSkpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKGRhdGFUeXBlICsgXCIgaXMgbm90IGFuIGluc3RhbmNlIG9mIERhdGFUeXBlXCIpO1xuXHR9XG5cdHZhciBhcnJheSA9IG5ldyBOREFycmF5KHNoYXBlLCBkYXRhVHlwZSwgdGhpcyk7XG5cdGFycmF5Ll9pZCA9IGFsbG9jYXRvci5uZXdBcnJheUlkKCk7XG5cdHZhciBhcnJheUJ1ZmZlciA9IG5ldyBkYXRhVHlwZS5hcnJheVR5cGUoYXJyYXkubGVuZ3RoKTtcblx0dXRpbC5jb3B5QXJyYXlEYXRhUmVjdXJzaXZlKGFycmF5QnVmZmVyLCBkYXRhLCBzaGFwZSwgMCwgMCk7XG5cblx0dmFyIHJlcXVlc3QgPSBuZXcgUmVxdWVzdCgpO1xuXHRyZXF1ZXN0LmlkID0gYWxsb2NhdG9yLm5ld01lc3NhZ2VJZCgpO1xuXHRyZXF1ZXN0LnR5cGUgPSBSZXF1ZXN0LlR5cGUuREFUQV9BUlJBWTtcblx0dmFyIGRhdGFBcnJheVJlcXVlc3QgPSBuZXcgRGF0YUFycmF5UmVxdWVzdCgpO1xuXHRkYXRhQXJyYXlSZXF1ZXN0LmlkT3V0ID0gYXJyYXkuX2lkO1xuXHRkYXRhQXJyYXlSZXF1ZXN0LnNoYXBlID0gc2hhcGU7XG5cdGRhdGFBcnJheVJlcXVlc3QuZGF0YVR5cGUgPSBkYXRhVHlwZU1hcFtkYXRhVHlwZS50eXBlXTtcblx0ZGF0YUFycmF5UmVxdWVzdC5kYXRhQnVmZmVyID0gYXJyYXlCdWZmZXIuYnVmZmVyO1xuXHRyZXF1ZXN0LmRhdGFBcnJheVJlcXVlc3QgPSBkYXRhQXJyYXlSZXF1ZXN0O1xuXHR0aGlzLl9wb3N0TWVzc2FnZShyZXF1ZXN0LmVuY29kZUFCKCkpO1xuXG5cdHJldHVybiBhcnJheTtcbn07XG5cblBCQ29udGV4dC5wcm90b3R5cGUubGluc3BhY2UgPSBmdW5jdGlvbihzdGFydCwgc3RvcCwgc2FtcGxlcywgaW5jbHVkZVN0b3ApIHtcblx0aWYgKCF1dGlsLmlzUmVhbChzdGFydCkpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKHN0YXJ0ICsgXCIgaXMgbm90IGEgcmVhbCBudW1iZXJcIik7XG5cdH1cblx0aWYgKCF1dGlsLmlzUmVhbChzdG9wKSkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3Ioc3RvcCArIFwiIGlzIG5vdCBhIHJlYWwgbnVtYmVyXCIpO1xuXHR9XG5cdGlmICh0eXBlb2Ygc2FtcGxlcyA9PT0gXCJ1bmRlZmluZWRcIikge1xuXHRcdC8qIERlZmF1bHQgdmFsdWUgaW4gTnVtUHkgKi9cblx0XHRzYW1wbGVzID0gNTA7XG5cdH0gZWxzZSBpZiAoIXV0aWwuaXNJbnQoc2FtcGxlcykpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKHNhbXBsZXMgKyBcIiBpcyBub3QgYW4gaW50ZWdlclwiKTtcblx0fSBlbHNlIGlmIChzYW1wbGVzIDw9IDApIHtcblx0XHR0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlRoZSBudW1iZXIgb2Ygc2FtcGxlcyBtdXN0IGJlIHBvc2l0aXZlXCIpO1xuXHR9XG5cdGlmICh0eXBlb2YgaW5jbHVkZVN0b3AgPT09IFwidW5kZWZpbmVkXCIpIHtcblx0XHRpbmNsdWRlU3RvcCA9IHRydWU7XG5cdH1cblx0aWYgKGluY2x1ZGVTdG9wICYmIChzYW1wbGVzID09PSAxKSkge1xuXHRcdHRocm93IG5ldyBSYW5nZUVycm9yKFwiVGhlIG51bWJlciBvZiBzYW1wbGVzIG11c3QgYmUgYSBsZWFzdCAyIChmb3Igc3RhcnQgYW5kIGVuZCBwb2ludHMpXCIpO1xuXHR9XG5cdHZhciBkYXRhVHlwZSA9IG5ldyBEYXRhVHlwZShcImY2NFwiKTtcblx0dmFyIGFycmF5ID0gbmV3IE5EQXJyYXkoW3NhbXBsZXNdLCBkYXRhVHlwZSwgdGhpcyk7XG5cdGFycmF5Ll9pZCA9IGFsbG9jYXRvci5uZXdBcnJheUlkKCk7XG5cblx0dmFyIHJlcXVlc3QgPSBuZXcgUmVxdWVzdCgpO1xuXHRyZXF1ZXN0LmlkID0gYWxsb2NhdG9yLm5ld01lc3NhZ2VJZCgpO1xuXHRyZXF1ZXN0LnR5cGUgPSBSZXF1ZXN0LlR5cGUuTElOU1BBQ0U7XG5cdHZhciBsaW5zcGFjZVJlcXVlc3QgPSBuZXcgTGluc3BhY2VSZXF1ZXN0KCk7XG5cdGxpbnNwYWNlUmVxdWVzdC5pZE91dCA9IGFycmF5Ll9pZDtcblx0bGluc3BhY2VSZXF1ZXN0LnN0YXJ0ID0gc3RhcnQ7XG5cdGxpbnNwYWNlUmVxdWVzdC5zdG9wID0gc3RvcDtcblx0bGluc3BhY2VSZXF1ZXN0LnNhbXBsZXMgPSBzYW1wbGVzO1xuXHRsaW5zcGFjZVJlcXVlc3QuY2xvc2VkID0gaW5jbHVkZVN0b3A7XG5cdGxpbnNwYWNlUmVxdWVzdC5kYXRhVHlwZSA9IGRhdGFUeXBlTWFwW2RhdGFUeXBlLnR5cGVdO1xuXHRyZXF1ZXN0LmxpbnNwYWNlUmVxdWVzdCA9IGxpbnNwYWNlUmVxdWVzdDtcblx0dGhpcy5fcG9zdE1lc3NhZ2UocmVxdWVzdC5lbmNvZGVBQigpKTtcblxuXHRyZXR1cm4gYXJyYXk7XG59O1xuXG5QQkNvbnRleHQucHJvdG90eXBlLnJlc2hhcGUgPSBmdW5jdGlvbihhLCBzaGFwZSkge1xuXHR1dGlsLmNoZWNrTkRBcnJheShhLCBcImFcIik7XG5cdHNoYXBlID0gdXRpbC5jaGVja1NoYXBlKHNoYXBlKTtcblx0aWYgKHV0aWwuY29tcHV0ZUxlbmd0aChzaGFwZSkgIT09IGEubGVuZ3RoKSB7XG5cdFx0dGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUaGUgc2hhcGUgaXMgbm90IGNvbXBhdGlibGUgd2l0aCB0aGUgYXJyYXlcIik7XG5cdH1cblx0dmFyIGlkQSA9IGEuX2lkO1xuXHR2YXIgcmVsZWFzZUEgPSAhYS5fZGVjUmVmKCk7XG5cdHZhciBvdXQgPSBuZXcgTkRBcnJheShzaGFwZSwgYS5kYXRhVHlwZSwgdGhpcyk7XG5cdGlmIChyZWxlYXNlQSkge1xuXHRcdG91dC5faWQgPSBpZEE7XG5cdFx0YS5faWQgPSAwO1xuXHRcdHJlbGVhc2VBID0gZmFsc2U7XG5cdH0gZWxzZSB7XG5cdFx0b3V0Ll9pZCA9IGFsbG9jYXRvci5uZXdBcnJheUlkKCk7XG5cdH1cblxuXHR2YXIgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KCk7XG5cdHJlcXVlc3QuaWQgPSBhbGxvY2F0b3IubmV3TWVzc2FnZUlkKCk7XG5cdHJlcXVlc3QudHlwZSA9IFJlcXVlc3QuVHlwZS5SRVNIQVBFO1xuXHR2YXIgcmVzaGFwZVJlcXVlc3QgPSBuZXcgUmVzaGFwZVJlcXVlc3QoKTtcblx0cmVzaGFwZVJlcXVlc3QuaWRBID0gaWRBO1xuXHRyZXNoYXBlUmVxdWVzdC5pZE91dCA9IG91dC5faWQ7XG5cdHJlc2hhcGVSZXF1ZXN0LnNoYXBlT3V0ID0gc2hhcGU7XG5cdHJlcXVlc3QucmVzaGFwZVJlcXVlc3QgPSByZXNoYXBlUmVxdWVzdDtcblx0dGhpcy5fcG9zdE1lc3NhZ2UocmVxdWVzdC5lbmNvZGVBQigpKTtcblxuXHRhLl90cnlJbnZhbGlkYXRlKCk7XG5cdHJldHVybiBvdXQ7XG59O1xuXG5QQkNvbnRleHQucHJvdG90eXBlLnJlcGVhdCA9IGZ1bmN0aW9uKGEsIHJlcGVhdHMsIGF4aXMsIG91dCkge1xuXHR1dGlsLmNoZWNrTkRBcnJheShhLCBcImFcIik7XG5cdHJlcGVhdHMgPSB1dGlsLmNoZWNrUmVwZWF0cyhyZXBlYXRzKTtcblx0YXhpcyA9IHV0aWwuY2hlY2tBeGlzKGF4aXMsIGEuc2hhcGUubGVuZ3RoKTtcblx0dmFyIHNoYXBlQSA9IGEuc2hhcGU7XG5cdHZhciBzaGFwZU91dCA9IHNoYXBlQS5zbGljZSgwKTtcblx0c2hhcGVPdXRbYXhpc10gKj0gcmVwZWF0cztcblx0aWYgKHR5cGVvZiBvdXQgPT09IFwidW5kZWZpbmVkXCIpIHtcblx0XHRvdXQgPSBuZXcgTkRBcnJheShzaGFwZU91dCwgYS5kYXRhVHlwZSwgdGhpcyk7XG5cdFx0b3V0Ll9pZCA9IGFsbG9jYXRvci5uZXdBcnJheUlkKCk7XG5cdH0gZWxzZSB7XG5cdFx0dXRpbC5jaGVja05EQXJyYXkob3V0LCBcIm91dFwiKTtcblx0XHR1dGlsLmNoZWNrU2hhcGVzQ29tcGF0aWJpbGl0eShvdXQuc2hhcGUsIHNoYXBlT3V0KTtcblx0XHR1dGlsLmNoZWNrRGF0YVR5cGVzQ29tcGF0aWJpbGl0eShhLmRhdGFUeXBlLCBvdXQuZGF0YVR5cGUpO1xuXHRcdG91dC5faW5jUmVmKCk7XG5cdH1cblx0dmFyIGlkQSA9IGEuX2lkO1xuXHRpZiAoIWEuX2RlY1JlZigpKSB7XG5cdFx0aWRBID0gLWlkQTtcblx0XHRhLl9pZCA9IDA7XG5cdH1cblxuXHR2YXIgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KCk7XG5cdHJlcXVlc3QuaWQgPSBhbGxvY2F0b3IubmV3TWVzc2FnZUlkKCk7XG5cdHJlcXVlc3QudHlwZSA9IFJlcXVlc3QuVHlwZS5SRVBFQVQ7XG5cdHZhciByZXBlYXRSZXF1ZXN0ID0gbmV3IFJlcGVhdFJlcXVlc3QoKTtcblx0cmVwZWF0UmVxdWVzdC5pZEEgPSBpZEE7XG5cdHJlcGVhdFJlcXVlc3QuaWRPdXQgPSBvdXQuX2lkO1xuXHRyZXBlYXRSZXF1ZXN0LmF4aXMgPSBheGlzO1xuXHRyZXBlYXRSZXF1ZXN0LnJlcGVhdHMgPSByZXBlYXRzO1xuXHRyZXF1ZXN0LnJlcGVhdFJlcXVlc3QgPSByZXBlYXRSZXF1ZXN0O1xuXHR0aGlzLl9wb3N0TWVzc2FnZShyZXF1ZXN0LmVuY29kZUFCKCkpO1xuXG5cdGEuX3RyeUludmFsaWRhdGUoKTtcblx0cmV0dXJuIG91dDtcbn07XG5cblBCQ29udGV4dC5wcm90b3R5cGUuX2ludmFsaWRhdGUgPSBmdW5jdGlvbihhcnJheSkge1xuXHRpZiAoYXJyYXkuX2lkICE9PSAwKSB7XG5cdFx0dmFyIHJlcXVlc3QgPSBuZXcgUmVxdWVzdCgpO1xuXHRcdHJlcXVlc3QuaWQgPSBhbGxvY2F0b3IubmV3TWVzc2FnZUlkKCk7XG5cdFx0cmVxdWVzdC50eXBlID0gUmVxdWVzdC5UeXBlLkRFQUxMT0NBVEU7XG5cdFx0dmFyIGRlYWxsb2NhdGVSZXF1ZXN0ID0gbmV3IERlYWxsb2NhdGVSZXF1ZXN0KCk7XG5cdFx0ZGVhbGxvY2F0ZVJlcXVlc3QuaWRBID0gYXJyYXkuX2lkO1xuXHRcdHJlcXVlc3QuZGVhbGxvY2F0ZVJlcXVlc3QgPSBkZWFsbG9jYXRlUmVxdWVzdDtcblx0XHR0aGlzLl9wb3N0TWVzc2FnZShyZXF1ZXN0LmVuY29kZUFCKCkpO1xuXHR9XG59O1xuXG5QQkNvbnRleHQucHJvdG90eXBlLmZldGNoID0gZnVuY3Rpb24oKSB7XG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiQ2FsbGJhY2sgYXJndW1lbnQgbWlzc2luZ1wiKTtcblx0fVxuXHR2YXIgY2FsbGJhY2sgPSBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aCAtIDFdO1xuXHQvKiBWYWxpZGF0ZSBhcmd1bWVudHMgKi9cblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJBdCBsZWFzdCBvbmUgTkRBcnJheSBhcmd1bWVudCBleHBlY3RlZFwiKTtcblx0fVxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGggLSAxOyArK2kpIHtcblx0XHR1dGlsLmNoZWNrTkRBcnJheShhcmd1bWVudHNbaV0sIFwiYXJndW1lbnQgXCIgKyBpKTtcblx0fVxuXHR2YXIgcmVsZWFzZSA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aCAtIDE7ICsraSkge1xuXHRcdHJlbGVhc2VbaV0gPSAhYXJndW1lbnRzW2ldLl9kZWNSZWYoKTtcblx0fVxuXHR2YXIgY2FsbGJhY2tXYWl0QXJndW1lbnRzID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7XG5cdHZhciBjYWxsYmFja0FyZ3VtZW50cyA9IG5ldyBBcnJheShjYWxsYmFja1dhaXRBcmd1bWVudHMpO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IGNhbGxiYWNrV2FpdEFyZ3VtZW50czsgaSsrKSB7XG5cdFx0dmFyIGFycmF5ID0gYXJndW1lbnRzW2ldO1xuXHRcdHZhciBtZXNzYWdlSWQgPSBhbGxvY2F0b3IubmV3TWVzc2FnZUlkKCk7XG5cdFx0dGhpcy5fY2FsbGJhY2tzW21lc3NhZ2VJZF0gPSAoZnVuY3Rpb24oaSwgQXJyYXlUeXBlKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oYnVmZmVyKSB7XG5cdFx0XHRcdGNhbGxiYWNrQXJndW1lbnRzW2ldID0gbmV3IEFycmF5VHlwZShidWZmZXIpO1xuXHRcdFx0XHRpZiAoLS1jYWxsYmFja1dhaXRBcmd1bWVudHMgPT09IDApIHtcblx0XHRcdFx0XHRjYWxsYmFjay5hcHBseShudWxsLCBjYWxsYmFja0FyZ3VtZW50cyk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fSkoaSwgYXJyYXkuZGF0YVR5cGUuYXJyYXlUeXBlKTtcblx0XHR2YXIgYXJyYXlJZCA9IGFycmF5Ll9pZDtcblx0XHRpZiAocmVsZWFzZVtpXSkge1xuXHRcdFx0YXJyYXkuX2lkID0gMDtcblx0XHRcdGFycmF5SWQgPSAtYXJyYXlJZDtcblx0XHRcdGFycmF5Ll90cnlJbnZhbGlkYXRlKCk7XG5cdFx0fVxuXG5cdFx0dmFyIHJlcXVlc3QgPSBuZXcgUmVxdWVzdCgpO1xuXHRcdHJlcXVlc3QuaWQgPSBtZXNzYWdlSWQ7XG5cdFx0cmVxdWVzdC50eXBlID0gUmVxdWVzdC5UeXBlLkZFVENIO1xuXHRcdHZhciBmZXRjaFJlcXVlc3QgPSBuZXcgRmV0Y2hSZXF1ZXN0KCk7XG5cdFx0ZmV0Y2hSZXF1ZXN0LmlkQSA9IGFycmF5SWQ7XG5cdFx0cmVxdWVzdC5mZXRjaFJlcXVlc3QgPSBmZXRjaFJlcXVlc3Q7XG5cdFx0dGhpcy5fcG9zdE1lc3NhZ2UocmVxdWVzdC5lbmNvZGVBQigpKTtcblx0fVxufTtcblxuUEJDb250ZXh0LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbigpIHtcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJDYWxsYmFjayBhcmd1bWVudCBtaXNzaW5nXCIpO1xuXHR9XG5cdHZhciBjYWxsYmFjayA9IGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoIC0gMV07XG5cdC8qIFZhbGlkYXRlIGFyZ3VtZW50cyAqL1xuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIkF0IGxlYXN0IG9uZSBOREFycmF5IGFyZ3VtZW50IGV4cGVjdGVkXCIpO1xuXHR9XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aCAtIDE7ICsraSkge1xuXHRcdHV0aWwuY2hlY2tOREFycmF5KGFyZ3VtZW50c1tpXSwgXCJhcmd1bWVudCBcIiArIGkpO1xuXHR9XG5cdHZhciByZWxlYXNlID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoIC0gMTsgKytpKSB7XG5cdFx0cmVsZWFzZVtpXSA9ICFhcmd1bWVudHNbaV0uX2RlY1JlZigpO1xuXHR9XG5cdHZhciBjYWxsYmFja1dhaXRBcmd1bWVudHMgPSBhcmd1bWVudHMubGVuZ3RoIC0gMTtcblx0dmFyIGNhbGxiYWNrQXJndW1lbnRzID0gbmV3IEFycmF5KGNhbGxiYWNrV2FpdEFyZ3VtZW50cyk7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgY2FsbGJhY2tXYWl0QXJndW1lbnRzOyBpKyspIHtcblx0XHR2YXIgYXJyYXkgPSBhcmd1bWVudHNbaV07XG5cdFx0dmFyIG1lc3NhZ2VJZCA9IGFsbG9jYXRvci5uZXdNZXNzYWdlSWQoKTtcblx0XHRpZiAoYXJyYXkuc2hhcGUubGVuZ3RoID09PSAwKSB7XG5cdFx0XHR0aGlzLl9jYWxsYmFja3NbbWVzc2FnZUlkXSA9IChmdW5jdGlvbihpLCBBcnJheVR5cGUpIHtcblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKGJ1ZmZlcikge1xuXHRcdFx0XHRcdHZhciB0eXBlZEFycmF5ID0gbmV3IEFycmF5VHlwZShidWZmZXIpO1xuXHRcdFx0XHRcdGNhbGxiYWNrQXJndW1lbnRzW2ldID0gdHlwZWRBcnJheVswXTtcblx0XHRcdFx0XHRpZiAoLS1jYWxsYmFja1dhaXRBcmd1bWVudHMgPT09IDApIHtcblx0XHRcdFx0XHRcdGNhbGxiYWNrLmFwcGx5KG51bGwsIGNhbGxiYWNrQXJndW1lbnRzKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0XHR9KShpLCBhcnJheS5kYXRhVHlwZS5hcnJheVR5cGUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9jYWxsYmFja3NbbWVzc2FnZUlkXSA9IChmdW5jdGlvbihpLCBBcnJheVR5cGUsIHNoYXBlKSB7XG5cdFx0XHRcdHJldHVybiBmdW5jdGlvbihidWZmZXIpIHtcblx0XHRcdFx0XHR2YXIganNhcnJheSA9IG5ldyBBcnJheShzaGFwZVswXSk7XG5cdFx0XHRcdFx0dXRpbC5jcmVhdGVBcnJheVJlY3Vyc2l2ZShuZXcgQXJyYXlUeXBlKGJ1ZmZlciksIGpzYXJyYXksIHNoYXBlLCAwLCAwKTtcblx0XHRcdFx0XHRjYWxsYmFja0FyZ3VtZW50c1tpXSA9IGpzYXJyYXk7XG5cdFx0XHRcdFx0aWYgKC0tY2FsbGJhY2tXYWl0QXJndW1lbnRzID09PSAwKSB7XG5cdFx0XHRcdFx0XHRjYWxsYmFjay5hcHBseShudWxsLCBjYWxsYmFja0FyZ3VtZW50cyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdFx0fSkoaSwgYXJyYXkuZGF0YVR5cGUuYXJyYXlUeXBlLCBhcnJheS5zaGFwZSk7XG5cdFx0fVxuXHRcdHZhciBhcnJheUlkID0gYXJyYXkuX2lkO1xuXHRcdGlmIChyZWxlYXNlW2ldKSB7XG5cdFx0XHRhcnJheS5faWQgPSAwO1xuXHRcdFx0YXJyYXlJZCA9IC1hcnJheUlkO1xuXHRcdFx0YXJyYXkuX3RyeUludmFsaWRhdGUoKTtcblx0XHR9XG5cblx0XHR2YXIgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KCk7XG5cdFx0cmVxdWVzdC5pZCA9IG1lc3NhZ2VJZDtcblx0XHRyZXF1ZXN0LnR5cGUgPSBSZXF1ZXN0LlR5cGUuRkVUQ0g7XG5cdFx0dmFyIGZldGNoUmVxdWVzdCA9IG5ldyBGZXRjaFJlcXVlc3QoKTtcblx0XHRmZXRjaFJlcXVlc3QuaWRBID0gYXJyYXlJZDtcblx0XHRyZXF1ZXN0LmZldGNoUmVxdWVzdCA9IGZldGNoUmVxdWVzdDtcblx0XHR0aGlzLl9wb3N0TWVzc2FnZShyZXF1ZXN0LmVuY29kZUFCKCkpO1xuXHR9XG59O1xuXG5QQkNvbnRleHQucHJvdG90eXBlLmluZm8gPSBmdW5jdGlvbihjYWxsYmFjaykge1xuXHR0aHJvdyBuZXcgRXJyb3IoXCJOb3QgaW1wbGVtZW50ZWRcIik7XG4vKlx0dmFyIG1lc3NhZ2VJZCA9IGFsbG9jYXRvci5uZXdNZXNzYWdlSWQoKTtcblx0bWVzc2FnZUNhbGxiYWNrc1ttZXNzYWdlSWRdID0gY2FsbGJhY2s7XG5cdHRoaXMuX3BuYWNsT2JqZWN0LnBvc3RNZXNzYWdlKHtcblx0XHRcImlkXCI6IG1lc3NhZ2VJZCxcblx0XHRcImNvbW1hbmRcIjogXCJpbmZvXCJcblx0fSk7Ki9cbn07XG5cblBCQ29udGV4dC5wcm90b3R5cGUuYmFycmllciA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG5cdHZhciBtZXNzYWdlSWQgPSBhbGxvY2F0b3IubmV3TWVzc2FnZUlkKCk7XG5cdHRoaXMuX2NhbGxiYWNrc1ttZXNzYWdlSWRdID0gY2FsbGJhY2s7XG5cblx0dmFyIHJlcXVlc3QgPSBuZXcgUmVxdWVzdCgpO1xuXHRyZXF1ZXN0LmlkID0gbWVzc2FnZUlkO1xuXHRyZXF1ZXN0LnR5cGUgPSBSZXF1ZXN0LlR5cGUuQkFSUklFUjtcblx0dGhpcy5fcG9zdE1lc3NhZ2UocmVxdWVzdC5lbmNvZGVBQigpKTtcbn07XG5cbnZhciBiaW5hcnlBcml0aE9wID0gZnVuY3Rpb24oYSwgYiwgb3V0LCBjb250ZXh0LCBvcGVyYXRpb24sIGNvbnN0T3BlcmF0aW9uLCByZXZDb25zdE9wZXJhdGlvbikge1xuXHR2YXIgc2hhcGVPdXQgPSBudWxsLCBkYXRhVHlwZU91dCA9IG51bGwsIHJlbGVhc2VJZEEgPSBmYWxzZSwgcmVsZWFzZUlkQiA9IGZhbHNlLCBpZEEgPSAwLCBpZEIgPSAwO1xuXHRpZiAoYSBpbnN0YW5jZW9mIE5EQXJyYXkpIHtcblx0XHRpZEEgPSBhLl9pZDtcblx0XHRzaGFwZU91dCA9IGEuc2hhcGU7XG5cdFx0ZGF0YVR5cGVPdXQgPSBhLmRhdGFUeXBlO1xuXHRcdGlmIChiIGluc3RhbmNlb2YgTkRBcnJheSkge1xuXHRcdFx0aWRCID0gYi5faWQ7XG5cdFx0XHR1dGlsLmNoZWNrU2hhcGVzQ29tcGF0aWJpbGl0eShhLnNoYXBlLCBiLnNoYXBlKTtcblx0XHRcdHV0aWwuY2hlY2tEYXRhVHlwZXNDb21wYXRpYmlsaXR5KGEuZGF0YVR5cGUsIGIuZGF0YVR5cGUpO1xuXHRcdH0gZWxzZSBpZiAoIXV0aWwuaXNOdW1iZXIoYikpIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoXCJVbnN1cHBvcnRlZCB0eXBlIG9mIGJcIik7XG5cdFx0fVxuXHR9IGVsc2UgaWYgKHV0aWwuaXNOdW1iZXIoYSkpIHtcblx0XHRpZEIgPSBiLl9pZDtcblx0XHRzaGFwZU91dCA9IGIuc2hhcGU7XG5cdFx0ZGF0YVR5cGVPdXQgPSBiLmRhdGFUeXBlO1xuXHRcdHV0aWwuY2hlY2tOREFycmF5KGIsIFwiYlwiKTtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5zdXBwb3J0ZWQgdHlwZSBvZiBhXCIpO1xuXHR9XG5cdC8qIFRoZSBJRHMgb2YgYSBhbmQgYiBtdXN0IGJlIGludmFsaWRhdGVkIGJlZm9yZSB3ZSBhc3NpZ24gSUQgdG8gb3V0IGJlY2F1c2UgYS9iIGFuZCBvdXQgbWF5IGJlIHRoZSBzYW1lIGFycmF5cyAqL1xuXHRpZiAoaWRBICE9PSAwKSB7XG5cdFx0cmVsZWFzZUlkQSA9ICFhLl9kZWNSZWYoKTtcblx0XHRpZiAocmVsZWFzZUlkQSkge1xuXHRcdFx0YS5faWQgPSAwO1xuXHRcdH1cblx0fVxuXHRpZiAoaWRCICE9PSAwKSB7XG5cdFx0cmVsZWFzZUlkQiA9ICFiLl9kZWNSZWYoKTtcblx0XHRpZiAocmVsZWFzZUlkQikge1xuXHRcdFx0Yi5faWQgPSAwO1xuXHRcdH1cblx0fVxuXHR0cnkge1xuXHRcdGlmICh0eXBlb2Ygb3V0ID09PSBcInVuZGVmaW5lZFwiKSB7XG5cdFx0XHRvdXQgPSBuZXcgTkRBcnJheShzaGFwZU91dCwgZGF0YVR5cGVPdXQsIGNvbnRleHQpO1xuXHRcdFx0aWYgKHJlbGVhc2VJZEEpIHtcblx0XHRcdFx0b3V0Ll9pZCA9IGlkQTtcblx0XHRcdFx0cmVsZWFzZUlkQSA9IGZhbHNlO1xuXHRcdFx0fSBlbHNlIGlmIChyZWxlYXNlSWRCKSB7XG5cdFx0XHRcdG91dC5faWQgPSBpZEI7XG5cdFx0XHRcdHJlbGVhc2VJZEIgPSBmYWxzZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG91dC5faWQgPSBhbGxvY2F0b3IubmV3QXJyYXlJZCgpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR1dGlsLmNoZWNrTkRBcnJheShvdXQsIFwib3V0XCIpO1xuXHRcdFx0dXRpbC5jaGVja1NoYXBlc0NvbXBhdGliaWxpdHkoc2hhcGVPdXQsIG91dC5zaGFwZSk7XG5cdFx0XHR1dGlsLmNoZWNrRGF0YVR5cGVzQ29tcGF0aWJpbGl0eShkYXRhVHlwZU91dCwgb3V0LmRhdGFUeXBlKTtcblx0XHRcdG91dC5faW5jUmVmKCk7XG5cdFx0fVxuXHRcdHZhciByZXF1ZXN0ID0gbmV3IFJlcXVlc3QoKTtcblx0XHRyZXF1ZXN0LmlkID0gYWxsb2NhdG9yLm5ld01lc3NhZ2VJZCgpO1xuXHRcdGlmIChpZEEgIT09IDApIHtcblx0XHRcdGlmIChpZEIgIT09IDApIHtcblx0XHRcdFx0cmVxdWVzdC50eXBlID0gUmVxdWVzdC5UeXBlLkJJTkFSWV9PUEVSQVRJT047XG5cdFx0XHRcdHZhciBiaW5hcnlPcGVyYXRpb25SZXF1ZXN0ID0gbmV3IEJpbmFyeU9wZXJhdGlvblJlcXVlc3QoKTtcblx0XHRcdFx0YmluYXJ5T3BlcmF0aW9uUmVxdWVzdC50eXBlID0gb3BlcmF0aW9uO1xuXHRcdFx0XHRiaW5hcnlPcGVyYXRpb25SZXF1ZXN0LmlkQSA9IChyZWxlYXNlSWRBID8gLWlkQSA6IGlkQSk7XG5cdFx0XHRcdGJpbmFyeU9wZXJhdGlvblJlcXVlc3QuaWRCID0gKHJlbGVhc2VJZEIgPyAtaWRCIDogaWRCKTtcblx0XHRcdFx0YmluYXJ5T3BlcmF0aW9uUmVxdWVzdC5pZE91dCA9IG91dC5faWQ7XG5cdFx0XHRcdHJlcXVlc3QuYmluYXJ5T3BlcmF0aW9uUmVxdWVzdCA9IGJpbmFyeU9wZXJhdGlvblJlcXVlc3Q7XG5cdFx0XHRcdGNvbnRleHQuX3Bvc3RNZXNzYWdlKHJlcXVlc3QuZW5jb2RlQUIoKSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXF1ZXN0LnR5cGUgPSBSZXF1ZXN0LlR5cGUuQklOQVJZX0NPTlNUX09QRVJBVElPTjtcblx0XHRcdFx0dmFyIGJpbmFyeUNvbnN0T3BlcmF0aW9uUmVxdWVzdCA9IG5ldyBCaW5hcnlDb25zdE9wZXJhdGlvblJlcXVlc3QoKTtcblx0XHRcdFx0YmluYXJ5Q29uc3RPcGVyYXRpb25SZXF1ZXN0LnR5cGUgPSBjb25zdE9wZXJhdGlvbjtcblx0XHRcdFx0YmluYXJ5Q29uc3RPcGVyYXRpb25SZXF1ZXN0LmlkQSA9IChyZWxlYXNlSWRBID8gLWlkQSA6IGlkQSk7XG5cdFx0XHRcdGJpbmFyeUNvbnN0T3BlcmF0aW9uUmVxdWVzdC52YWx1ZUIgPSBiO1xuXHRcdFx0XHRiaW5hcnlDb25zdE9wZXJhdGlvblJlcXVlc3QuaWRPdXQgPSBvdXQuX2lkO1xuXHRcdFx0XHRyZXF1ZXN0LmJpbmFyeUNvbnN0T3BlcmF0aW9uUmVxdWVzdCA9IGJpbmFyeUNvbnN0T3BlcmF0aW9uUmVxdWVzdDtcblx0XHRcdFx0Y29udGV4dC5fcG9zdE1lc3NhZ2UocmVxdWVzdC5lbmNvZGVBQigpKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0cmVxdWVzdC50eXBlID0gUmVxdWVzdC5UeXBlLkJJTkFSWV9DT05TVF9PUEVSQVRJT047XG5cdFx0XHR2YXIgYmluYXJ5Q29uc3RPcGVyYXRpb25SZXF1ZXN0ID0gbmV3IEJpbmFyeUNvbnN0T3BlcmF0aW9uUmVxdWVzdCgpO1xuXHRcdFx0YmluYXJ5Q29uc3RPcGVyYXRpb25SZXF1ZXN0LnR5cGUgPSByZXZDb25zdE9wZXJhdGlvbjtcblx0XHRcdGJpbmFyeUNvbnN0T3BlcmF0aW9uUmVxdWVzdC5pZEEgPSAocmVsZWFzZUlkQiA/IC1pZEIgOiBpZEIpO1xuXHRcdFx0YmluYXJ5Q29uc3RPcGVyYXRpb25SZXF1ZXN0LnZhbHVlQiA9IGE7XG5cdFx0XHRiaW5hcnlDb25zdE9wZXJhdGlvblJlcXVlc3QuaWRPdXQgPSBvdXQuX2lkO1xuXHRcdFx0cmVxdWVzdC5iaW5hcnlDb25zdE9wZXJhdGlvblJlcXVlc3QgPSBiaW5hcnlDb25zdE9wZXJhdGlvblJlcXVlc3Q7XG5cdFx0XHRjb250ZXh0Ll9wb3N0TWVzc2FnZShyZXF1ZXN0LmVuY29kZUFCKCkpO1xuXHRcdH1cblx0fSBjYXRjaCAoZSkge1xuXHRcdC8qIFJlc3RvcmUgdGhlIHByZXZpb3VzIHN0YXRlICovXG5cdFx0aWYgKGlkQSAhPT0gMCkge1xuXHRcdFx0YS5faWQgPSBpZEE7XG5cdFx0XHRhLl9pbmNSZWYoKTtcblx0XHR9XG5cdFx0aWYgKGlkQiAhPT0gMCkge1xuXHRcdFx0Yi5faWQgPSBpZEI7XG5cdFx0XHRiLl9pbmNSZWYoKTtcblx0XHR9XG5cdFx0dGhyb3cgZTtcblx0fVxuXHQvKlxuXHQgKiBJZiBhIG9yIGIgYXJlIGFycmF5cywgaW52YWxpZGF0ZSB0aGVtIGFzIG5lZWRlZC5cblx0ICogSWYgYS9iIGFuZCBvdXQgYXJlIHRoZSBzYW1lLCB0aGVpciByZWYgY291bnQgaXMgbm9uLXplcm8gYXQgdGhpcyBwb2ludCwgc28gdGhleSB3aWxsIHN0YXkgdmFsaWQuXG5cdCAqL1xuXHRpZiAoaWRBICE9PSAwKSB7XG5cdFx0YS5fdHJ5SW52YWxpZGF0ZSgpO1xuXHR9XG5cdGlmIChpZEIgIT09IDApIHtcblx0XHRiLl90cnlJbnZhbGlkYXRlKCk7XG5cdH1cblx0cmV0dXJuIG91dDtcbn07XG5cbnZhciB1bmFyeUFyaXRoT3AgPSBmdW5jdGlvbihhLCBvdXQsIGNvbnRleHQsIG9wZXJhdGlvbikge1xuXHR1dGlsLmNoZWNrTkRBcnJheShhLCBcImFcIik7XG5cdHZhciBpZEEgPSBhLl9pZDtcblx0dmFyIHJlbGVhc2VJZEEgPSAhYS5fZGVjUmVmKCk7XG5cdC8qIFRoZSBJRCBvZiBhIG11c3QgYmUgaW52YWxpZGF0ZWQgYmVmb3JlIHdlIGFzc2lnbiBJRCB0byBvdXQgYmVjYXVzZSBhIGFuZCBvdXQgbWF5IGJlIHRoZSBzYW1lIGFycmF5cyAqL1xuXHRpZiAocmVsZWFzZUlkQSkge1xuXHRcdGEuX2lkID0gMDtcblx0fVxuXHR0cnkge1xuXHRcdGlmICh0eXBlb2Ygb3V0ID09PSBcInVuZGVmaW5lZFwiKSB7XG5cdFx0XHRvdXQgPSBuZXcgTkRBcnJheShhLnNoYXBlLCBhLmRhdGFUeXBlLCBjb250ZXh0KTtcblx0XHRcdGlmIChyZWxlYXNlSWRBKSB7XG5cdFx0XHRcdG91dC5faWQgPSBpZEE7XG5cdFx0XHRcdHJlbGVhc2VJZEEgPSBmYWxzZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG91dC5faWQgPSBhbGxvY2F0b3IubmV3QXJyYXlJZCgpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR1dGlsLmNoZWNrTkRBcnJheShvdXQsIFwib3V0XCIpO1xuXHRcdFx0dXRpbC5jaGVja1NoYXBlc0NvbXBhdGliaWxpdHkoYS5zaGFwZSwgb3V0LnNoYXBlKTtcblx0XHRcdHV0aWwuY2hlY2tEYXRhVHlwZXNDb21wYXRpYmlsaXR5KGEuZGF0YVR5cGUsIG91dC5kYXRhVHlwZSk7XG5cdFx0XHRvdXQuX2luY1JlZigpO1xuXHRcdH1cblx0fSBjYXRjaCAoZSkge1xuXHRcdC8qIFJlc3RvcmUgdGhlIHByZXZpb3VzIHN0YXRlICovXG5cdFx0YS5faWQgPSBpZEE7XG5cdFx0YS5faW5jUmVmKCk7XG5cdFx0dGhyb3cgZTtcblx0fVxuXG5cdHZhciByZXF1ZXN0ID0gbmV3IFJlcXVlc3QoKTtcblx0cmVxdWVzdC5pZCA9IGFsbG9jYXRvci5uZXdNZXNzYWdlSWQoKTtcblx0cmVxdWVzdC50eXBlID0gUmVxdWVzdC5UeXBlLlVOQVJZX09QRVJBVElPTjtcblx0dmFyIHVuYXJ5T3BlcmF0aW9uUmVxdWVzdCA9IG5ldyBVbmFyeU9wZXJhdGlvblJlcXVlc3QoKTtcblx0dW5hcnlPcGVyYXRpb25SZXF1ZXN0LnR5cGUgPSBvcGVyYXRpb247XG5cdHVuYXJ5T3BlcmF0aW9uUmVxdWVzdC5pZEEgPSAocmVsZWFzZUlkQSA/IC1pZEEgOiBpZEEpO1xuXHR1bmFyeU9wZXJhdGlvblJlcXVlc3QuaWRPdXQgPSBvdXQuX2lkO1xuXHRyZXF1ZXN0LnVuYXJ5T3BlcmF0aW9uUmVxdWVzdCA9IHVuYXJ5T3BlcmF0aW9uUmVxdWVzdDtcblx0Y29udGV4dC5fcG9zdE1lc3NhZ2UocmVxdWVzdC5lbmNvZGVBQigpKTtcblxuXHQvKiBJZiBhIGFuZCBvdXQgYXJlIHRoZSBzYW1lLCB0aGVpciByZWYgY291bnQgaXMgbm9uLXplcm8gYXQgdGhpcyBwb2ludCwgc28gdGhleSB3aWxsIHN0YXkgdmFsaWQuICovXG5cdGEuX3RyeUludmFsaWRhdGUoKTtcblx0cmV0dXJuIG91dDtcbn07XG5cbnZhciByZWR1Y2VBcml0aE9wID0gZnVuY3Rpb24oYSwgb3V0LCBjb250ZXh0LCBvcGVyYXRpb24pIHtcblx0dXRpbC5jaGVja05EQXJyYXkoYSwgXCJhXCIpO1xuXHR2YXIgaWRBID0gYS5faWQ7XG5cdHZhciByZWxlYXNlSWRBID0gIWEuX2RlY1JlZigpO1xuXHRpZiAocmVsZWFzZUlkQSkge1xuXHRcdGEuX2lkID0gMDtcblx0fVxuXHR0cnkge1xuXHRcdGlmICh0eXBlb2Ygb3V0ID09PSBcInVuZGVmaW5lZFwiKSB7XG5cdFx0XHRvdXQgPSBuZXcgTkRBcnJheShbXSwgYS5kYXRhVHlwZSwgY29udGV4dCk7XG5cdFx0XHRvdXQuX2lkID0gYWxsb2NhdG9yLm5ld0FycmF5SWQoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dXRpbC5jaGVja05EQXJyYXkob3V0LCBcIm91dFwiKTtcblx0XHRcdHV0aWwuY2hlY2tTaGFwZXNDb21wYXRpYmlsaXR5KG91dC5zaGFwZSwgW10pO1xuXHRcdFx0dXRpbC5jaGVja0RhdGFUeXBlc0NvbXBhdGliaWxpdHkoYS5kYXRhVHlwZSwgb3V0LmRhdGFUeXBlKTtcblx0XHRcdG91dC5faW5jUmVmKCk7XG5cdFx0fVxuXHR9IGNhdGNoIChlKSB7XG5cdFx0LyogUmVzdG9yZSB0aGUgcHJldmlvdXMgc3RhdGUgKi9cblx0XHRhLl9pZCA9IGlkQTtcblx0XHRhLl9pbmNSZWYoKTtcblx0XHR0aHJvdyBlO1xuXHR9XG5cblx0dmFyIHJlcXVlc3QgPSBuZXcgUmVxdWVzdCgpO1xuXHRyZXF1ZXN0LmlkID0gYWxsb2NhdG9yLm5ld01lc3NhZ2VJZCgpO1xuXHRyZXF1ZXN0LnR5cGUgPSBSZXF1ZXN0LlR5cGUuUkVEVUNUSU9OX09QRVJBVElPTjtcblx0dmFyIHJlZHVjdGlvblJlcXVlc3QgPSBuZXcgUmVkdWN0aW9uUmVxdWVzdCgpO1xuXHRyZWR1Y3Rpb25SZXF1ZXN0LnR5cGUgPSBvcGVyYXRpb247XG5cdHJlZHVjdGlvblJlcXVlc3QuaWRBID0gKHJlbGVhc2VJZEEgPyAtaWRBIDogaWRBKTtcblx0cmVkdWN0aW9uUmVxdWVzdC5pZE91dCA9IG91dC5faWQ7XG5cdHJlcXVlc3QucmVkdWN0aW9uUmVxdWVzdCA9IHJlZHVjdGlvblJlcXVlc3Q7XG5cdGNvbnRleHQuX3Bvc3RNZXNzYWdlKHJlcXVlc3QuZW5jb2RlQUIoKSk7XG5cblx0YS5fdHJ5SW52YWxpZGF0ZSgpO1xuXHRyZXR1cm4gb3V0O1xufTtcblxudmFyIGF4aXNSZWR1Y2VBcml0aE9wID0gZnVuY3Rpb24oYSwgYXhpcywgb3V0LCBjb250ZXh0LCBvcGVyYXRpb24pIHtcblx0dXRpbC5jaGVja05EQXJyYXkoYSwgXCJhXCIpO1xuXHR2YXIgaWRBID0gYS5faWQ7XG5cdHZhciByZWxlYXNlSWRBID0gIWEuX2RlY1JlZigpO1xuXHRpZiAocmVsZWFzZUlkQSkge1xuXHRcdGEuX2lkID0gMDtcblx0fVxuXHR0cnkge1xuXHRcdHV0aWwuY2hlY2tBeGlzKGF4aXMpO1xuXHRcdGlmICh0eXBlb2Ygb3V0ID09PSBcInVuZGVmaW5lZFwiKSB7XG5cdFx0XHRvdXQgPSBuZXcgTkRBcnJheSh1dGlsLmNvbXB1dGVBeGlzUmVkdWN0aW9uT3V0U2hhcGUoYS5zaGFwZSwgYXhpcyksIGEuZGF0YVR5cGUsIGNvbnRleHQpO1xuXHRcdFx0b3V0Ll9pZCA9IGFsbG9jYXRvci5uZXdBcnJheUlkKCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHV0aWwuY2hlY2tOREFycmF5KG91dCwgXCJvdXRcIik7XG5cdFx0XHR1dGlsLmNoZWNrU2hhcGVzQ29tcGF0aWJpbGl0eShvdXQuc2hhcGUsIFtdKTtcblx0XHRcdHV0aWwuY2hlY2tEYXRhVHlwZXNDb21wYXRpYmlsaXR5KGEuZGF0YVR5cGUsIG91dC5kYXRhVHlwZSk7XG5cdFx0XHRvdXQuX2luY1JlZigpO1xuXHRcdH1cblx0fSBjYXRjaCAoZSkge1xuXHRcdC8qIFJlc3RvcmUgdGhlIHByZXZpb3VzIHN0YXRlICovXG5cdFx0YS5faWQgPSBpZEE7XG5cdFx0YS5faW5jUmVmKCk7XG5cdFx0dGhyb3cgZTtcblx0fVxuXG5cdHZhciByZXF1ZXN0ID0gbmV3IFJlcXVlc3QoKTtcblx0cmVxdWVzdC5pZCA9IGFsbG9jYXRvci5uZXdNZXNzYWdlSWQoKTtcblx0cmVxdWVzdC50eXBlID0gUmVxdWVzdC5UeXBlLkFYSVNfUkVEVUNUSU9OX09QRVJBVElPTjtcblx0dmFyIGF4aXNSZWR1Y3Rpb25SZXF1ZXN0ID0gbmV3IEF4aXNSZWR1Y3Rpb25SZXF1ZXN0KCk7XG5cdGF4aXNSZWR1Y3Rpb25SZXF1ZXN0LnR5cGUgPSBvcGVyYXRpb247XG5cdGF4aXNSZWR1Y3Rpb25SZXF1ZXN0LmlkQSA9IChyZWxlYXNlSWRBID8gLWlkQSA6IGlkQSk7XG5cdGF4aXNSZWR1Y3Rpb25SZXF1ZXN0LmF4aXMgPSBheGlzO1xuXHRheGlzUmVkdWN0aW9uUmVxdWVzdC5pZE91dCA9IG91dC5faWQ7XG5cdHJlcXVlc3QuYXhpc1JlZHVjdGlvblJlcXVlc3QgPSBheGlzUmVkdWN0aW9uUmVxdWVzdDtcblx0Y29udGV4dC5fcG9zdE1lc3NhZ2UocmVxdWVzdC5lbmNvZGVBQigpKTtcblxuXHRhLl90cnlJbnZhbGlkYXRlKCk7XG5cdHJldHVybiBvdXQ7XG59O1xuXG52YXIgZG90QXJpdGhPcCA9IGZ1bmN0aW9uKGEsIGIsIG91dCwgY29udGV4dCkge1xuXHR1dGlsLmNoZWNrTkRBcnJheShhLCBcImFcIik7XG5cdHV0aWwuY2hlY2tOREFycmF5KGIsIFwiYlwiKTtcblx0dXRpbC5jaGVja0RhdGFUeXBlc0NvbXBhdGliaWxpdHkoYS5kYXRhVHlwZSwgYi5kYXRhVHlwZSk7XG5cdHZhciBpZEEgPSBhLl9pZDtcblx0dmFyIHJlbGVhc2VJZEEgPSAhYS5fZGVjUmVmKCk7XG5cdGlmIChyZWxlYXNlSWRBKSB7XG5cdFx0YS5faWQgPSAwO1xuXHR9XG5cdHZhciBpZEIgPSBiLl9pZDtcblx0dmFyIHJlbGVhc2VJZEIgPSAhYi5fZGVjUmVmKCk7XG5cdGlmIChyZWxlYXNlSWRCKSB7XG5cdFx0Yi5faWQgPSAwO1xuXHR9XG5cdHRyeSB7XG5cdFx0aWYgKHR5cGVvZiBvdXQgPT09IFwidW5kZWZpbmVkXCIpIHtcblx0XHRcdHZhciBzaGFwZUEgPSBhLnNoYXBlO1xuXHRcdFx0dmFyIHNoYXBlQiA9IGIuc2hhcGU7XG5cdFx0XHR2YXIgYXhpc0EgPSBNYXRoLm1heChzaGFwZUEubGVuZ3RoIC0gMSwgMCk7XG5cdFx0XHR2YXIgYXhpc0IgPSBNYXRoLm1heChzaGFwZUIubGVuZ3RoIC0gMiwgMCk7XG5cdFx0XHRpZiAoc2hhcGVBW2F4aXNBXSAhPSBzaGFwZUJbYXhpc0JdKSB7XG5cdFx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoXCJNaXNtYXRjaCBpbiByZWR1Y3Rpb24gZGltZW5zaW9uc1wiKTtcblx0XHRcdH1cblx0XHRcdHZhciBzaGFwZU91dCA9IFtdO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBheGlzQTsgaSsrKSB7XG5cdFx0XHRcdHNoYXBlT3V0LnB1c2goc2hhcGVBW2ldKTtcblx0XHRcdH1cblx0XHRcdGlmIChzaGFwZUIubGVuZ3RoID4gMSkge1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGF4aXNCOyBpKyspIHtcblx0XHRcdFx0XHRzaGFwZU91dC5wdXNoKHNoYXBlQltpXSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0c2hhcGVPdXQucHVzaChzaGFwZUJbc2hhcGVCLmxlbmd0aCAtIDFdKTtcblx0XHRcdH1cblx0XHRcdG91dCA9IG5ldyBOREFycmF5KHNoYXBlT3V0LCBhLmRhdGFUeXBlLCBjb250ZXh0KTtcblx0XHRcdG91dC5faWQgPSBhbGxvY2F0b3IubmV3QXJyYXlJZCgpO1xuXHRcdH0gZWxzZSBpZiAob3V0IGluc3RhbmNlb2YgTkRBcnJheSkge1xuXHRcdFx0dXRpbC5jaGVja05EQXJyYXkob3V0LCBcIm91dFwiKTtcblx0XHRcdHV0aWwuY2hlY2tEYXRhVHlwZXNDb21wYXRpYmlsaXR5KGEuZGF0YVR5cGUsIG91dC5kYXRhVHlwZSk7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJOb3QgaW1wbGVtZW50ZWRcIik7XG5cdFx0fVxuXHR9IGNhdGNoIChlKSB7XG5cdFx0LyogUmVzdG9yZSB0aGUgcHJldmlvdXMgc3RhdGUgKi9cblx0XHRhLl9pZCA9IGlkQTtcblx0XHRhLl9pbmNSZWYoKTtcblx0XHRiLl9pZCA9IGlkQjtcblx0XHRiLl9pbmNSZWYoKTtcblx0XHR0aHJvdyBlO1xuXHR9XG5cblx0dmFyIHJlcXVlc3QgPSBuZXcgUmVxdWVzdCgpO1xuXHRyZXF1ZXN0LmlkID0gYWxsb2NhdG9yLm5ld01lc3NhZ2VJZCgpO1xuXHRyZXF1ZXN0LnR5cGUgPSBSZXF1ZXN0LlR5cGUuRE9UX09QRVJBVElPTjtcblx0dmFyIGRvdE9wZXJhdGlvblJlcXVlc3QgPSBuZXcgRG90T3BlcmF0aW9uUmVxdWVzdCgpO1xuXHRkb3RPcGVyYXRpb25SZXF1ZXN0LmlkQSA9IChyZWxlYXNlSWRBID8gLWlkQSA6IGlkQSk7XG5cdGRvdE9wZXJhdGlvblJlcXVlc3QuaWRCID0gKHJlbGVhc2VJZEIgPyAtaWRCIDogaWRCKTtcblx0ZG90T3BlcmF0aW9uUmVxdWVzdC5pZE91dCA9IG91dC5faWQ7XG5cdHJlcXVlc3QuZG90T3BlcmF0aW9uUmVxdWVzdCA9IGRvdE9wZXJhdGlvblJlcXVlc3Q7XG5cdGNvbnRleHQuX3Bvc3RNZXNzYWdlKHJlcXVlc3QuZW5jb2RlQUIoKSk7XG5cblx0YS5fdHJ5SW52YWxpZGF0ZSgpO1xuXHRiLl90cnlJbnZhbGlkYXRlKCk7XG5cdHJldHVybiBvdXQ7XG59O1xuXG5QQkNvbnRleHQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKGEsIGIsIG91dCkge1xuXHRyZXR1cm4gYmluYXJ5QXJpdGhPcChhLCBiLCBvdXQsIHRoaXMsXG5cdFx0QmluYXJ5T3BlcmF0aW9uUmVxdWVzdC5UeXBlLkFERCxcblx0XHRCaW5hcnlDb25zdE9wZXJhdGlvblJlcXVlc3QuVHlwZS5BRERDLFxuXHRcdEJpbmFyeUNvbnN0T3BlcmF0aW9uUmVxdWVzdC5UeXBlLkFEREMpO1xufTtcblxuUEJDb250ZXh0LnByb3RvdHlwZS5zdWIgPSBmdW5jdGlvbihhLCBiLCBvdXQpIHtcblx0cmV0dXJuIGJpbmFyeUFyaXRoT3AoYSwgYiwgb3V0LCB0aGlzLFxuXHRcdEJpbmFyeU9wZXJhdGlvblJlcXVlc3QuVHlwZS5TVUIsXG5cdFx0QmluYXJ5Q29uc3RPcGVyYXRpb25SZXF1ZXN0LlR5cGUuU1VCQyxcblx0XHRCaW5hcnlDb25zdE9wZXJhdGlvblJlcXVlc3QuVHlwZS5TVUJSQyk7XG59O1xuXG5QQkNvbnRleHQucHJvdG90eXBlLm11bCA9IGZ1bmN0aW9uKGEsIGIsIG91dCkge1xuXHRyZXR1cm4gYmluYXJ5QXJpdGhPcChhLCBiLCBvdXQsIHRoaXMsXG5cdFx0QmluYXJ5T3BlcmF0aW9uUmVxdWVzdC5UeXBlLk1VTCxcblx0XHRCaW5hcnlDb25zdE9wZXJhdGlvblJlcXVlc3QuVHlwZS5NVUxDLFxuXHRcdEJpbmFyeUNvbnN0T3BlcmF0aW9uUmVxdWVzdC5UeXBlLk1VTEMpO1xufTtcblxuUEJDb250ZXh0LnByb3RvdHlwZS5kaXYgPSBmdW5jdGlvbihhLCBiLCBvdXQpIHtcblx0cmV0dXJuIGJpbmFyeUFyaXRoT3AoYSwgYiwgb3V0LCB0aGlzLFxuXHRcdEJpbmFyeU9wZXJhdGlvblJlcXVlc3QuVHlwZS5ESVYsXG5cdFx0QmluYXJ5Q29uc3RPcGVyYXRpb25SZXF1ZXN0LlR5cGUuRElWQyxcblx0XHRCaW5hcnlDb25zdE9wZXJhdGlvblJlcXVlc3QuVHlwZS5ESVZSQyk7XG59O1xuXG5QQkNvbnRleHQucHJvdG90eXBlLm5lZyA9IGZ1bmN0aW9uKGEsIG91dCkge1xuXHRyZXR1cm4gdW5hcnlBcml0aE9wKGEsIG91dCwgdGhpcyxcblx0XHRVbmFyeU9wZXJhdGlvblJlcXVlc3QuVHlwZS5ORUcpO1xufTtcblxuUEJDb250ZXh0LnByb3RvdHlwZS5hYnMgPSBmdW5jdGlvbihhLCBvdXQpIHtcblx0cmV0dXJuIHVuYXJ5QXJpdGhPcChhLCBvdXQsIHRoaXMsXG5cdFx0VW5hcnlPcGVyYXRpb25SZXF1ZXN0LlR5cGUuQUJTKTtcbn07XG5cblBCQ29udGV4dC5wcm90b3R5cGUuZXhwID0gZnVuY3Rpb24oYSwgb3V0KSB7XG5cdHJldHVybiB1bmFyeUFyaXRoT3AoYSwgb3V0LCB0aGlzLFxuXHRcdFVuYXJ5T3BlcmF0aW9uUmVxdWVzdC5UeXBlLkVYUCk7XG59O1xuXG5QQkNvbnRleHQucHJvdG90eXBlLmxvZyA9IGZ1bmN0aW9uKGEsIG91dCkge1xuXHRyZXR1cm4gdW5hcnlBcml0aE9wKGEsIG91dCwgdGhpcyxcblx0XHRVbmFyeU9wZXJhdGlvblJlcXVlc3QuVHlwZS5MT0cpO1xufTtcblxuUEJDb250ZXh0LnByb3RvdHlwZS5zcXJ0ID0gZnVuY3Rpb24oYSwgb3V0KSB7XG5cdHJldHVybiB1bmFyeUFyaXRoT3AoYSwgb3V0LCB0aGlzLFxuXHRcdFVuYXJ5T3BlcmF0aW9uUmVxdWVzdC5UeXBlLlNRUlQpO1xufTtcblxuUEJDb250ZXh0LnByb3RvdHlwZS5zcXVhcmUgPSBmdW5jdGlvbihhLCBvdXQpIHtcblx0cmV0dXJuIHVuYXJ5QXJpdGhPcChhLCBvdXQsIHRoaXMsXG5cdFx0VW5hcnlPcGVyYXRpb25SZXF1ZXN0LlR5cGUuU1FVQVJFKTtcbn07XG5cblBCQ29udGV4dC5wcm90b3R5cGUubWluID0gZnVuY3Rpb24oYSwgYXhpcykge1xuXHRpZiAodHlwZW9mIGF4aXMgPT09IFwidW5kZWZpbmVkXCIpIHtcblx0XHRyZXR1cm4gcmVkdWNlQXJpdGhPcChhLCB1bmRlZmluZWQsIHRoaXMsXG5cdFx0XHRSZWR1Y3Rpb25SZXF1ZXN0LlR5cGUuTUlOKTtcblx0fSBlbHNlIGlmICh1dGlsLmlzSW50KGF4aXMpKSB7XG5cdFx0cmV0dXJuIGF4aXNSZWR1Y2VBcml0aE9wKGEsIGF4aXMsIHVuZGVmaW5lZCwgdGhpcyxcblx0XHRcdEF4aXNSZWR1Y3Rpb25SZXF1ZXN0LlR5cGUuTUlOKTtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5zdXBwb3J0ZWQgYXhpcyB0eXBlXCIpO1xuXHR9XG59O1xuXG5QQkNvbnRleHQucHJvdG90eXBlLm1heCA9IGZ1bmN0aW9uKGEsIGF4aXMpIHtcblx0aWYgKHR5cGVvZiBheGlzID09PSBcInVuZGVmaW5lZFwiKSB7XG5cdFx0cmV0dXJuIHJlZHVjZUFyaXRoT3AoYSwgdW5kZWZpbmVkLCB0aGlzLFxuXHRcdFx0UmVkdWN0aW9uUmVxdWVzdC5UeXBlLk1BWCk7XG5cdH0gZWxzZSBpZiAodXRpbC5pc0ludChheGlzKSkge1xuXHRcdHJldHVybiBheGlzUmVkdWNlQXJpdGhPcChhLCBheGlzLCB1bmRlZmluZWQsIHRoaXMsXG5cdFx0XHRBeGlzUmVkdWN0aW9uUmVxdWVzdC5UeXBlLk1BWCk7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihcIlVuc3VwcG9ydGVkIGF4aXMgdHlwZVwiKTtcblx0fVxufTtcblxuUEJDb250ZXh0LnByb3RvdHlwZS5zdW0gPSBmdW5jdGlvbihhLCBheGlzKSB7XG5cdGlmICh0eXBlb2YgYXhpcyA9PT0gXCJ1bmRlZmluZWRcIikge1xuXHRcdHJldHVybiByZWR1Y2VBcml0aE9wKGEsIHVuZGVmaW5lZCwgdGhpcyxcblx0XHRcdFJlZHVjdGlvblJlcXVlc3QuVHlwZS5TVU0pO1xuXHR9IGVsc2UgaWYgKHV0aWwuaXNJbnQoYXhpcykpIHtcblx0XHRyZXR1cm4gYXhpc1JlZHVjZUFyaXRoT3AoYSwgYXhpcywgdW5kZWZpbmVkLCB0aGlzLFxuXHRcdFx0QXhpc1JlZHVjdGlvblJlcXVlc3QuVHlwZS5TVU0pO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoXCJVbnN1cHBvcnRlZCBheGlzIHR5cGVcIik7XG5cdH1cbn07XG5cblBCQ29udGV4dC5wcm90b3R5cGUuZG90ID0gZnVuY3Rpb24oYSwgYiwgb3V0KSB7XG5cdHJldHVybiBkb3RBcml0aE9wKGEsIGIsIG91dCwgdGhpcyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBCQ29udGV4dDtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgUEJDb250ZXh0ID0gcmVxdWlyZShcIi4vUEJDb250ZXh0XCIpO1xuXG5mdW5jdGlvbiBQTmFDbENvbnRleHQob3B0aW9ucywgY2FsbGJhY2spIHtcblx0dmFyIHNlbGYgPSB0aGlzO1xuXHR0aGlzLl9wbmFjbE9iamVjdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJvYmplY3RcIik7XG5cdHRoaXMuX3BuYWNsT2JqZWN0LndpZHRoID0gMDtcblx0dGhpcy5fcG5hY2xPYmplY3QuaGVpZ2h0ID0gMDtcblx0dGhpcy5fcG5hY2xPYmplY3QuZGF0YSA9IFBOYUNsQ29udGV4dC5nZXRNYW5pZmVzdFVSTChvcHRpb25zLmJhc2VVcmwpO1xuXHR0aGlzLl9wbmFjbE9iamVjdC50eXBlID0gXCJhcHBsaWNhdGlvbi94LXBuYWNsXCI7XG5cdHRoaXMuX3BuYWNsT2JqZWN0LmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGZ1bmN0aW9uKGUpIHtcblx0XHRzZWxmLl9tZXNzYWdpbmdDb250ZXh0Ll9vbk1lc3NhZ2UoZSk7XG5cdH0sIHRydWUpO1xuXHR0aGlzLl9tZXNzYWdpbmdDb250ZXh0ID0gbmV3IFBCQ29udGV4dChvcHRpb25zLCBmdW5jdGlvbihtZXNzYWdlKSB7XG5cdFx0c2VsZi5fcG5hY2xPYmplY3QucG9zdE1lc3NhZ2UobWVzc2FnZSk7XG5cdH0sIGNhbGxiYWNrKTtcblx0ZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLl9wbmFjbE9iamVjdCk7XG59XG5cblBOYUNsQ29udGV4dC5pc1N1cHBvcnRlZCA9IGZ1bmN0aW9uKCkge1xuXHR0cnkge1xuXHRcdHJldHVybiAodHlwZW9mIG5hdmlnYXRvci5taW1lVHlwZXNbXCJhcHBsaWNhdGlvbi94LXBuYWNsXCJdKSAhPT0gXCJ1bmRlZmluZWRcIjtcblx0fSBjYXRjaCAoZSkge1xuXHR9XG5cdHJldHVybiBmYWxzZTtcbn07XG5cblBOYUNsQ29udGV4dC5nZXRNYW5pZmVzdFVSTCA9IGZ1bmN0aW9uKGJhc2VVcmwpIHtcblx0aWYgKGJhc2VVcmwpIHtcblx0XHRyZXR1cm4gYmFzZVVybCArIFwiZnVyaW91cy5ubWZcIjtcblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gXCJmdXJpb3VzLm5tZlwiO1xuXHR9XG59O1xuXG5QTmFDbENvbnRleHQucHJvdG90eXBlLmVtcHR5ID0gZnVuY3Rpb24oc2hhcGUsIGRhdGFUeXBlKSB7XG5cdHJldHVybiB0aGlzLl9tZXNzYWdpbmdDb250ZXh0LmVtcHR5KHNoYXBlLCBkYXRhVHlwZSk7XG59O1xuXG5QTmFDbENvbnRleHQucHJvdG90eXBlLnplcm9zID0gZnVuY3Rpb24oc2hhcGUsIGRhdGFUeXBlKSB7XG5cdHJldHVybiB0aGlzLl9tZXNzYWdpbmdDb250ZXh0Lnplcm9zKHNoYXBlLCBkYXRhVHlwZSk7XG59O1xuXG5QTmFDbENvbnRleHQucHJvdG90eXBlLm9uZXMgPSBmdW5jdGlvbihzaGFwZSwgZGF0YVR5cGUpIHtcblx0cmV0dXJuIHRoaXMuX21lc3NhZ2luZ0NvbnRleHQub25lcyhzaGFwZSwgZGF0YVR5cGUpO1xufTtcblxuUE5hQ2xDb250ZXh0LnByb3RvdHlwZS5hcnJheSA9IGZ1bmN0aW9uKGRhdGEsIGRhdGFUeXBlKSB7XG5cdHJldHVybiB0aGlzLl9tZXNzYWdpbmdDb250ZXh0LmFycmF5KGRhdGEsIGRhdGFUeXBlKTtcbn07XG5cblBOYUNsQ29udGV4dC5wcm90b3R5cGUubGluc3BhY2UgPSBmdW5jdGlvbihzdGFydCwgc3RvcCwgc2FtcGxlcywgY2xvc2VkKSB7XG5cdHJldHVybiB0aGlzLl9tZXNzYWdpbmdDb250ZXh0LmxpbnNwYWNlKHN0YXJ0LCBzdG9wLCBzYW1wbGVzLCBjbG9zZWQpO1xufTtcblxuUE5hQ2xDb250ZXh0LnByb3RvdHlwZS5yZXNoYXBlID0gZnVuY3Rpb24oYSwgc2hhcGUpIHtcblx0cmV0dXJuIHRoaXMuX21lc3NhZ2luZ0NvbnRleHQucmVzaGFwZShhLCBzaGFwZSk7XG59O1xuXG5QTmFDbENvbnRleHQucHJvdG90eXBlLnJlcGVhdCA9IGZ1bmN0aW9uKGEsIHJlcGVhdHMsIGF4aXMsIG91dCkge1xuXHRyZXR1cm4gdGhpcy5fbWVzc2FnaW5nQ29udGV4dC5yZXBlYXQoYSwgcmVwZWF0cywgYXhpcywgb3V0KTtcbn07XG5cblBOYUNsQ29udGV4dC5wcm90b3R5cGUuX2ludmFsaWRhdGUgPSBmdW5jdGlvbihhcnJheSkge1xuXHRyZXR1cm4gdGhpcy5fbWVzc2FnaW5nQ29udGV4dC5faW52YWxpZGF0ZShhcnJheSk7XG59O1xuXG5QTmFDbENvbnRleHQucHJvdG90eXBlLmZldGNoID0gZnVuY3Rpb24oKSB7XG5cdHRoaXMuX21lc3NhZ2luZ0NvbnRleHQuZmV0Y2guYXBwbHkodGhpcy5fbWVzc2FnaW5nQ29udGV4dCwgYXJndW1lbnRzKTtcbn07XG5cblBOYUNsQ29udGV4dC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oKSB7XG5cdHRoaXMuX21lc3NhZ2luZ0NvbnRleHQuZ2V0LmFwcGx5KHRoaXMuX21lc3NhZ2luZ0NvbnRleHQsIGFyZ3VtZW50cyk7XG59O1xuXG5QTmFDbENvbnRleHQucHJvdG90eXBlLmluZm8gPSBmdW5jdGlvbihjYWxsYmFjaykge1xuXHR0aGlzLl9tZXNzYWdpbmdDb250ZXh0LmluZm8oY2FsbGJhY2spO1xufTtcblxuUE5hQ2xDb250ZXh0LnByb3RvdHlwZS5iYXJyaWVyID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcblx0dGhpcy5fbWVzc2FnaW5nQ29udGV4dC5iYXJyaWVyKGNhbGxiYWNrKTtcbn07XG5cblBOYUNsQ29udGV4dC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24oYSwgYiwgb3V0KSB7XG5cdHJldHVybiB0aGlzLl9tZXNzYWdpbmdDb250ZXh0LmFkZChhLCBiLCBvdXQpO1xufTtcblxuUE5hQ2xDb250ZXh0LnByb3RvdHlwZS5zdWIgPSBmdW5jdGlvbihhLCBiLCBvdXQpIHtcblx0cmV0dXJuIHRoaXMuX21lc3NhZ2luZ0NvbnRleHQuc3ViKGEsIGIsIG91dCk7XG59O1xuXG5QTmFDbENvbnRleHQucHJvdG90eXBlLm11bCA9IGZ1bmN0aW9uKGEsIGIsIG91dCkge1xuXHRyZXR1cm4gdGhpcy5fbWVzc2FnaW5nQ29udGV4dC5tdWwoYSwgYiwgb3V0KTtcbn07XG5cblBOYUNsQ29udGV4dC5wcm90b3R5cGUuZGl2ID0gZnVuY3Rpb24oYSwgYiwgb3V0KSB7XG5cdHJldHVybiB0aGlzLl9tZXNzYWdpbmdDb250ZXh0LmRpdihhLCBiLCBvdXQpO1xufTtcblxuUE5hQ2xDb250ZXh0LnByb3RvdHlwZS5uZWcgPSBmdW5jdGlvbihhLCBvdXQpIHtcblx0cmV0dXJuIHRoaXMuX21lc3NhZ2luZ0NvbnRleHQubmVnKGEsIG91dCk7XG59O1xuXG5QTmFDbENvbnRleHQucHJvdG90eXBlLmFicyA9IGZ1bmN0aW9uKGEsIG91dCkge1xuXHRyZXR1cm4gdGhpcy5fbWVzc2FnaW5nQ29udGV4dC5hYnMoYSwgb3V0KTtcbn07XG5cblBOYUNsQ29udGV4dC5wcm90b3R5cGUuZXhwID0gZnVuY3Rpb24oYSwgb3V0KSB7XG5cdHJldHVybiB0aGlzLl9tZXNzYWdpbmdDb250ZXh0LmV4cChhLCBvdXQpO1xufTtcblxuUE5hQ2xDb250ZXh0LnByb3RvdHlwZS5sb2cgPSBmdW5jdGlvbihhLCBvdXQpIHtcblx0cmV0dXJuIHRoaXMuX21lc3NhZ2luZ0NvbnRleHQubG9nKGEsIG91dCk7XG59O1xuXG5QTmFDbENvbnRleHQucHJvdG90eXBlLnNxcnQgPSBmdW5jdGlvbihhLCBvdXQpIHtcblx0cmV0dXJuIHRoaXMuX21lc3NhZ2luZ0NvbnRleHQuc3FydChhLCBvdXQpO1xufTtcblxuUE5hQ2xDb250ZXh0LnByb3RvdHlwZS5zcXVhcmUgPSBmdW5jdGlvbihhLCBvdXQpIHtcblx0cmV0dXJuIHRoaXMuX21lc3NhZ2luZ0NvbnRleHQuc3F1YXJlKGEsIG91dCk7XG59O1xuXG5QTmFDbENvbnRleHQucHJvdG90eXBlLm1pbiA9IGZ1bmN0aW9uKGEsIGF4aXMpIHtcblx0cmV0dXJuIHRoaXMuX21lc3NhZ2luZ0NvbnRleHQubWluKGEsIGF4aXMpO1xufTtcblxuUE5hQ2xDb250ZXh0LnByb3RvdHlwZS5tYXggPSBmdW5jdGlvbihhLCBheGlzKSB7XG5cdHJldHVybiB0aGlzLl9tZXNzYWdpbmdDb250ZXh0Lm1heChhLCBheGlzKTtcbn07XG5cblBOYUNsQ29udGV4dC5wcm90b3R5cGUuc3VtID0gZnVuY3Rpb24oYSwgYXhpcykge1xuXHRyZXR1cm4gdGhpcy5fbWVzc2FnaW5nQ29udGV4dC5zdW0oYSwgYXhpcyk7XG59O1xuXG5QTmFDbENvbnRleHQucHJvdG90eXBlLmRvdCA9IGZ1bmN0aW9uKGEsIGIsIG91dCkge1xuXHRyZXR1cm4gdGhpcy5fbWVzc2FnaW5nQ29udGV4dC5kb3QoYSwgYiwgb3V0KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUE5hQ2xDb250ZXh0O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBtZXNzYWdlSWQgPSAxO1xudmFyIGFycmF5SWQgPSAxO1xuXG5leHBvcnRzLm5ld01lc3NhZ2VJZCA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgaWQgPSBtZXNzYWdlSWQ7XG5cdG1lc3NhZ2VJZCA9IChtZXNzYWdlSWQrMSl8MDtcblx0cmV0dXJuIGlkO1xufTtcblxuZXhwb3J0cy5uZXdBcnJheUlkID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgaWQgPSBhcnJheUlkO1xuXHRhcnJheUlkID0gKGFycmF5SWQrMSl8MDtcblx0cmV0dXJuIGlkO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIFByb3ZpZGVzIGluZm9ybWF0aW9uIGFuZCBzdXBwb3J0IGZ1bmN0aW9uc1xuICpcbiAqIEBjbGFzcyBmdXJpb3VzXG4gKi9cblxudmFyIERhdGFUeXBlID0gcmVxdWlyZShcIi4vRGF0YVR5cGVcIik7XG52YXIgSlNDb250ZXh0ID0gcmVxdWlyZShcIi4vanMvSlNDb250ZXh0XCIpO1xudmFyIFdlYldvcmtlckNvbnRleHQgPSByZXF1aXJlKFwiLi9qcy9XZWJXb3JrZXJDb250ZXh0XCIpO1xudmFyIFBOYUNsQ29udGV4dCA9IHJlcXVpcmUoXCIuL1BOYUNsQ29udGV4dFwiKTtcbnZhciBXZWJDTENvbnRleHQgPSByZXF1aXJlKFwiLi93ZWJjbC9XZWJDTENvbnRleHRcIik7XG5cbnZhciBjdXJyZW50U2NyaXB0VXJpID0gbnVsbDtcbnRyeSB7XG5cdGN1cnJlbnRTY3JpcHRVcmkgPSBkb2N1bWVudC5jdXJyZW50U2NyaXB0LnNyYztcbn0gY2F0Y2ggKGUpIHtcblx0dHJ5IHtcblx0XHR2YXIgc2NyaXB0cyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwic2NyaXB0XCIpO1xuXHRcdGN1cnJlbnRTY3JpcHRVcmkgPSBzY3JpcHRzW3NjcmlwdHMubGVuZ3RoIC0gMV0uc3JjO1xuXHR9IGNhdGNoIChlKSB7XG5cdH1cbn1cbnZhciBjdXJyZW50U2NyaXB0RGlyID0gbnVsbDtcbmlmIChjdXJyZW50U2NyaXB0VXJpICE9PSBudWxsKSB7XG5cdHZhciBzZXBhcmF0b3JQb3MgPSBjdXJyZW50U2NyaXB0VXJpLmxhc3RJbmRleE9mKFwiL1wiKTtcblx0dmFyIGN1cnJlbnRTY3JpcHREaXIgPSBjdXJyZW50U2NyaXB0VXJpLnN1YnN0cigwLCBzZXBhcmF0b3JQb3MgKyAxKTtcbn1cblxuLyoqXG4gKiBJbml0aWFsaXplcyBhIGNvbXB1dGF0aW9uYWwgY29udGV4dC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIGluaXRcbiAqIEBhc3luY1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBbYmFja2VuZF0gLSBBIHN0cmluZyBpZGVudGlmaWVyIGZvciB0aGUgYmFja2VuZCB0byB1c2UuIFRoZSBmb2xsb3dpbmcgdmFsdWVzIGFyZSBzdXBwb3J0ZWQ6XG4gKlxuICogICAgIDx0YWJsZT5cbiAqICAgICAgICAgPHRyPlxuICogICAgICAgICAgICAgPHRoPkJhY2tlbmQgSWRlbnRpZmllcjwvdGg+XG4gKiAgICAgICAgICAgICA8dGg+SW50ZXJwcmV0YXRpb248L3RoPlxuICogICAgICAgICA8L3RyPlxuICogICAgICAgICA8dHI+XG4gKiAgICAgICAgICAgICA8dGQ+XCJqYXZhc2NyaXB0XCI8L3RkPlxuICogICAgICAgICAgICAgPHRkPkphdmFTY3JpcHQgYmFja2VuZC4gV29ya3MgaW4gYWxsIGJyb3dzZXJzIGFuZCBOb2RlLmpzLCBidXQgY2FuIG5vdCBkZWxpdmVyIG9wdGltYWwgcGVyZm9ybWFuY2UuPC90ZD5cbiAqICAgICAgICAgPC90cj5cbiAqICAgICAgICAgPHRyPlxuICogICAgICAgICAgICAgPHRkPlwicG5hY2xcIjwvdGQ+XG4gKiAgICAgICAgICAgICA8dGQ+UG9ydGFibGUgTmF0aXZlIENsaWVudCAoUE5hQ2wpIGJhY2tlbmQuIFdvcmtzIGluIENocm9taXVtLWJhc2VkIGJyb3dzZXJzLiBDYW4gYWNjZWxlcmF0ZSBjb21wdXRhdGlvbnMgdGhyb3VnaCB0aGUgdXNlIG9mIGFkdmFuY2VkIENQVSBvcHRpbWl6YXRpb24gdGVjaG5vbG9naWVzLCBzdWNoIGFzIG11bHRpLXRocmVhZGluZyBhbmQgU0lNRCBpbnN0cnVjdGlvbnMuPC90ZD5cbiAqICAgICAgICAgPC90cj5cbiAqICAgICAgICAgPHRyPlxuICogICAgICAgICAgICAgPHRkPlwid2ViY2xcIjwvdGQ+XG4gKiAgICAgICAgICAgICA8dGQ+V2ViQ0wgYmFja2VuZC4gV29ya3MgaW4gYnJvd3NlcnMgYW5kIE5vZGUuanMgd2hlbiBhIFdlYkNMIHBsdWdpbiBpcyBhdmFpbGFibGUuIENhbiB1c2UgZnVsbCBwb3dlciBvZiBDUFVzIGFuZCBHUFVzIHRvIGFjY2VsZXJhdGUgY29tcHV0YXRpb25zLjwvdGQ+XG4gKiAgICAgICAgIDwvdHI+XG4gKiAgICAgPC90YWJsZT5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIEJhY2tlbmQtc3BlY2lmaWMgb3B0aW9ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gQSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aGVuIHRoZSBiYWNrZW5kIGZpbmlzaCBpbml0aWFsaXphdGlvbi5cbiAqIEBwYXJhbSB7Q29udGV4dH0gY2FsbGJhY2suY29udGV4dCAtIEEgcmVhZHkgdG8gdXNlIGNvbXB1dGF0aW9uYWwgY29udGV4dC5cbiAqL1xudmFyIGluaXQgPSBmdW5jdGlvbihiYWNrZW5kLCBvcHRpb25zLCBjYWxsYmFjaykge1xuXHRpZiAodHlwZW9mIGNhbGxiYWNrID09PSBcInVuZGVmaW5lZFwiKSB7XG5cdFx0aWYgKHR5cGVvZiBvcHRpb25zID09PSBcInVuZGVmaW5lZFwiKSB7XG5cdFx0XHQvKiBDYWxsZWQgd2l0aCBvbmUgcGFyYW1ldGVyOiBjYWxsYmFjayAqL1xuXHRcdFx0Y2FsbGJhY2sgPSBiYWNrZW5kO1xuXHRcdFx0b3B0aW9ucyA9IHVuZGVmaW5lZDtcblx0XHRcdGJhY2tlbmQgPSB1bmRlZmluZWQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8qIENhbGxlZCB3aXRoIHR3byBwYXJhbWV0ZXJzOiBiYWNrZW5kIGFuZCBjYWxsYmFjayAqL1xuXHRcdFx0Y2FsbGJhY2sgPSBvcHRpb25zO1xuXHRcdFx0b3B0aW9ucyA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdH1cblx0aWYgKHR5cGVvZiBiYWNrZW5kID09PSBcInVuZGVmaW5lZFwiKSB7XG5cdFx0YmFja2VuZCA9IGdldERlZmF1bHRCYWNrZW5kKCk7XG5cdH1cblx0aWYgKHR5cGVvZiBvcHRpb25zID09PSBcInVuZGVmaW5lZFwiKSB7XG5cdFx0b3B0aW9ucyA9IHt9O1xuXHR9XG5cdGlmIChiYWNrZW5kID09PSBcImphdmFzY3JpcHRcIikge1xuXHRcdHZhciBhc3luYyA9IG9wdGlvbnMuYXN5bmM7XG5cdFx0aWYgKHR5cGVvZiBhc3luYyA9PT0gXCJ1bmRlZmluZWRcIikge1xuXHRcdFx0YXN5bmMgPSBXZWJXb3JrZXJDb250ZXh0LmlzU3VwcG9ydGVkKCk7XG5cdFx0fVxuXHRcdGlmIChhc3luYykge1xuXHRcdFx0b3B0aW9ucy5iYXNlVXJsID0gY3VycmVudFNjcmlwdERpcjtcblx0XHRcdHJldHVybiBuZXcgV2ViV29ya2VyQ29udGV4dChvcHRpb25zLCBjYWxsYmFjayk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBuZXcgSlNDb250ZXh0KG9wdGlvbnMsIGNhbGxiYWNrKTtcblx0XHR9XG5cdH0gZWxzZSBpZiAoYmFja2VuZCA9PT0gXCJwbmFjbFwiKSB7XG5cdFx0b3B0aW9ucy5iYXNlVXJsID0gY3VycmVudFNjcmlwdERpcjtcblx0XHRyZXR1cm4gbmV3IFBOYUNsQ29udGV4dChvcHRpb25zLCBjYWxsYmFjayk7XG5cdH0gZWxzZSBpZiAoYmFja2VuZCA9PT0gXCJ3ZWJjbFwiKSB7XG5cdFx0cmV0dXJuIG5ldyBXZWJDTENvbnRleHQob3B0aW9ucywgY2FsbGJhY2spO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIGJhY2tlbmQ6IFwiICsgYmFja2VuZCk7XG5cdH1cbn07XG5cbi8qKlxuICogRGV0ZWN0cyB0aGUgb3B0aW1hbCBiYWNrZW5kIHN1cHBvcnRlZCBieSB0aGUgYnJvd3NlciBvciBKYXZhU2NyaXB0IGVuZ2luZS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIGdldERlZmF1bHRCYWNrZW5kXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSAtIERlZmF1bHQgYmFja2VuZCBpZGVudGlmaWVyIGZyb20gdGhlIGZvbGxvd2luZyB0YWJsZTpcbiAqXG4gKiAgICAgPHRhYmxlPlxuICogICAgICAgICA8dHI+XG4gKiAgICAgICAgICAgICA8dGg+QmFja2VuZCBJZGVudGlmaWVyPC90aD5cbiAqICAgICAgICAgICAgIDx0aD5JbnRlcnByZXRhdGlvbjwvdGg+XG4gKiAgICAgICAgIDwvdHI+XG4gKiAgICAgICAgIDx0cj5cbiAqICAgICAgICAgICAgIDx0ZD5cImphdmFzY3JpcHRcIjwvdGQ+XG4gKiAgICAgICAgICAgICA8dGQ+SmF2YVNjcmlwdCBiYWNrZW5kLiBXb3JrcyBpbiBhbGwgYnJvd3NlcnMgYW5kIE5vZGUuanMsIGJ1dCBjYW4gbm90IGRlbGl2ZXIgb3B0aW1hbCBwZXJmb3JtYW5jZS48L3RkPlxuICogICAgICAgICA8L3RyPlxuICogICAgICAgICA8dHI+XG4gKiAgICAgICAgICAgICA8dGQ+XCJhc21qc1wiPC90ZD5cbiAqICAgICAgICAgICAgIDx0ZD5Bc20uanMgYmFja2VuZC4gV29ya3MgaW4gRmlyZWZveCAyOSBhbmQgbGF0ZXIuIENhbiBhY2NlbGVyYXRlIGNvbXB1dGF0aW9ucyB3aXRoIGEgbGltaXRlZCB1c2Ugb2YgbmF0aXZlIENQVSBpbnN0cnVjdGlvbnMuPC90ZD5cbiAqICAgICAgICAgPC90cj5cbiAqICAgICAgICAgPHRyPlxuICogICAgICAgICAgICAgPHRkPlwicG5hY2xcIjwvdGQ+XG4gKiAgICAgICAgICAgICA8dGQ+UG9ydGFibGUgTmF0aXZlIENsaWVudCAoUE5hQ2wpIGJhY2tlbmQuIFdvcmtzIGluIENocm9taXVtLWJhc2VkIGJyb3dzZXJzLiBDYW4gYWNjZWxlcmF0ZSBjb21wdXRhdGlvbnMgdGhyb3VnaCB0aGUgdXNlIG9mIGFkdmFuY2VkIENQVSBvcHRpbWl6YXRpb24gdGVjaG5vbG9naWVzLCBzdWNoIGFzIG11bHRpLXRocmVhZGluZyBhbmQgU0lNRCBpbnN0cnVjdGlvbnMuPC90ZD5cbiAqICAgICAgICAgPC90cj5cbiAqICAgICAgICAgPHRyPlxuICogICAgICAgICAgICAgPHRkPlwid2ViY2xcIjwvdGQ+XG4gKiAgICAgICAgICAgICA8dGQ+V2ViQ0wgYmFja2VuZC4gV29ya3MgaW4gYnJvd3NlcnMgYW5kIE5vZGUuanMgd2hlbiBhIFdlYkNMIHBsdWdpbiBpcyBhdmFpbGFibGUuIENhbiB1c2UgZnVsbCBwb3dlciBvZiBDUFVzIGFuZCBHUFVzIHRvIGFjY2VsZXJhdGUgY29tcHV0YXRpb25zLjwvdGQ+XG4gKiAgICAgICAgIDwvdHI+XG4gKiAgICAgPC90YWJsZT5cbiAqL1xudmFyIGdldERlZmF1bHRCYWNrZW5kID0gZnVuY3Rpb24oKSB7XG5cdGlmIChXZWJDTENvbnRleHQuaXNVc2FibGUoKSkge1xuXHRcdHJldHVybiBcIndlYmNsXCI7XG5cdH0gZWxzZSBpZiAoUE5hQ2xDb250ZXh0LmlzU3VwcG9ydGVkKCkpIHtcblx0XHRyZXR1cm4gXCJwbmFjbFwiO1xuXHR9IGVsc2Uge1xuXHRcdHJldHVybiBcImphdmFzY3JpcHRcIjtcblx0fVxufTtcblxuLyoqXG4gKiBEZXRlY3RzIHdoaWNoIGJhY2tlbmRzIGFyZSBzdXBwb3J0ZWQgYnkgdGhlIHN5c3RlbS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIGdldFN1cHBvcnRlZEJhY2tlbmRzXG4gKlxuICogQHJldHVybiB7U3RyaW5nW119IC0gQW4gYXJyYXkgb2Ygc3VwcG9ydGVkIGJhY2tlbmQgaWRlbnRpZmllcnMgaW4gcHJpb3JpdHkgb3JkZXIgKHByaW9yaXRpemVkIGJhY2tlbmRzIGZpcnN0KS4gVGhlIGZvbGxvd2luZyBpZGVudGlmaWVycyBjb3VsZCBiZSBwcmVzZW50OlxuICpcbiAqICAgICA8dGFibGU+XG4gKiAgICAgICAgIDx0cj5cbiAqICAgICAgICAgICAgIDx0aD5CYWNrZW5kIElkZW50aWZpZXI8L3RoPlxuICogICAgICAgICAgICAgPHRoPkludGVycHJldGF0aW9uPC90aD5cbiAqICAgICAgICAgPC90cj5cbiAqICAgICAgICAgPHRyPlxuICogICAgICAgICAgICAgPHRkPlwiamF2YXNjcmlwdFwiPC90ZD5cbiAqICAgICAgICAgICAgIDx0ZD5KYXZhU2NyaXB0IGJhY2tlbmQuIFdvcmtzIGluIGFsbCBicm93c2VycyBhbmQgTm9kZS5qcywgYnV0IGNhbiBub3QgZGVsaXZlciBvcHRpbWFsIHBlcmZvcm1hbmNlLjwvdGQ+XG4gKiAgICAgICAgIDwvdHI+XG4gKiAgICAgICAgIDx0cj5cbiAqICAgICAgICAgICAgIDx0ZD5cImFzbWpzXCI8L3RkPlxuICogICAgICAgICAgICAgPHRkPkFzbS5qcyBiYWNrZW5kLiBXb3JrcyBpbiBGaXJlZm94IDI5IGFuZCBsYXRlci4gQ2FuIGFjY2VsZXJhdGUgY29tcHV0YXRpb25zIHdpdGggYSBsaW1pdGVkIHVzZSBvZiBuYXRpdmUgQ1BVIGluc3RydWN0aW9ucy48L3RkPlxuICogICAgICAgICA8L3RyPlxuICogICAgICAgICA8dHI+XG4gKiAgICAgICAgICAgICA8dGQ+XCJwbmFjbFwiPC90ZD5cbiAqICAgICAgICAgICAgIDx0ZD5Qb3J0YWJsZSBOYXRpdmUgQ2xpZW50IChQTmFDbCkgYmFja2VuZC4gV29ya3MgaW4gQ2hyb21pdW0tYmFzZWQgYnJvd3NlcnMuIENhbiBhY2NlbGVyYXRlIGNvbXB1dGF0aW9ucyB0aHJvdWdoIHRoZSB1c2Ugb2YgYWR2YW5jZWQgQ1BVIG9wdGltaXphdGlvbiB0ZWNobm9sb2dpZXMsIHN1Y2ggYXMgbXVsdGktdGhyZWFkaW5nIGFuZCBTSU1EIGluc3RydWN0aW9ucy48L3RkPlxuICogICAgICAgICA8L3RyPlxuICogICAgICAgICA8dHI+XG4gKiAgICAgICAgICAgICA8dGQ+XCJ3ZWJjbFwiPC90ZD5cbiAqICAgICAgICAgICAgIDx0ZD5XZWJDTCBiYWNrZW5kLiBXb3JrcyBpbiBicm93c2VycyBhbmQgTm9kZS5qcyB3aGVuIGEgV2ViQ0wgcGx1Z2luIGlzIGF2YWlsYWJsZS4gQ2FuIHVzZSBmdWxsIHBvd2VyIG9mIENQVXMgYW5kIEdQVXMgdG8gYWNjZWxlcmF0ZSBjb21wdXRhdGlvbnMuPC90ZD5cbiAqICAgICAgICAgPC90cj5cbiAqICAgICA8L3RhYmxlPlxuICovXG52YXIgZ2V0U3VwcG9ydGVkQmFja2VuZHMgPSBmdW5jdGlvbigpIHtcblx0dmFyIGJhY2tlbmRzID0gW107XG5cdGlmIChXZWJDTENvbnRleHQuaXNVc2FibGUoKSkge1xuXHRcdGJhY2tlbmRzLnB1c2goXCJ3ZWJjbFwiKTtcblx0fVxuXHRpZiAoUE5hQ2xDb250ZXh0LmlzU3VwcG9ydGVkKCkpIHtcblx0XHRiYWNrZW5kcy5wdXNoKFwicG5hY2xcIik7XG5cdH1cblx0aWYgKGhhc0ZlYXR1cmUoXCJhc20uanNcIikpIHtcblx0XHRiYWNrZW5kcy5wdXNoKFwiYXNtLmpzXCIpO1xuXHR9XG5cdGJhY2tlbmRzLnB1c2goXCJqYXZhc2NyaXB0XCIpO1xuXHRyZXR1cm4gYmFja2VuZHM7XG59O1xuXG4vKipcbiAqIFF1ZXJpZXMgcG9zc2libGUgYmFja2VuZCBvcHRpb25zIGF2YWlsYWJsZSBvbiB0aGlzIHBsYXRmb3JtLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBiYWNrZW5kIC0gbmFtZSBvZiB0aGUgYmFja2VuZCB0byBxdWVyeSBvcHRpb25zIGZvci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIGdldEJhY2tlbmRPcHRpb25zXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSAtIEFuIG9iamVjdCB0aGF0IGRlc2NyaWJlcyBhdmFpbGFibGUgb3B0aW9ucy5cbiAqIFRoZSBuYW1lcyBvZiBvYmplY3QncyBwcm9wZXJ0aWVzIGNvcnJlc3BvbmQgdG8gYmFja2VuZCBvcHRpb24gbmFtZXMuXG4gKiBPYmplY3QncyBwcm9wZXJ0aWVzIGhhdmUgYXJyYXkgdmFsdWVzIHdpdGggcG9zc2libGUgb3B0aW9uIHZhbHVlcy5cbiAqIEJlbG93IGFyZSB0aGUgYmFja2VuZCBvcHRpb25zIGZvciB0aGUgYnVpbHQtaW4gYmFja2VuZHM6XG4gKlxuICogICAgIDx0YWJsZT5cbiAqICAgICAgICAgPGNhcHRpb24+T3B0aW9ucyBvZiBcImphdmFzY3JpcHRcIiBhbmQgXCJhc21qc1wiIGJhY2tlbmRzPC9jYXB0aW9uPlxuICogICAgICAgICA8dHI+XG4gKiAgICAgICAgICAgICA8dGg+T3B0aW9uIG5hbWU8L3RoPlxuICogICAgICAgICAgICAgPHRoPk9wdGlvbiB2YWx1ZXM8L3RoPlxuICogICAgICAgICAgICAgPHRoPkRlZmF1bHQgdmFsdWU8L3RoPlxuICogICAgICAgICA8L3RyPlxuICogICAgICAgICA8dHI+XG4gKiAgICAgICAgICAgICA8dGQ+XCJhc3luY1wiPC90ZD5cbiAqICAgICAgICAgICAgIDx0ZD5bdHJ1ZSwgZmFsc2VdPC90ZD5cbiAqICAgICAgICAgICAgIDx0ZD50cnVlPC90ZD5cbiAqICAgICAgICAgPC90cj5cbiAqICAgICA8L3RhYmxlPlxuICpcbiAqICAgICA8dGFibGU+XG4gKiAgICAgICAgIDxjYXB0aW9uPk9wdGlvbnMgb2YgXCJwbmFjbFwiIGJhY2tlbmQ8L2NhcHRpb24+XG4gKiAgICAgICAgIDx0cj5cbiAqICAgICAgICAgICAgIDx0aD5PcHRpb24gbmFtZTwvdGg+XG4gKiAgICAgICAgICAgICA8dGg+T3B0aW9uIHZhbHVlczwvdGg+XG4gKiAgICAgICAgICAgICA8dGg+RGVmYXVsdCB2YWx1ZTwvdGg+XG4gKiAgICAgICAgIDwvdHI+XG4gKiAgICAgICAgIDx0cj5cbiAqICAgICAgICAgICAgIDx0ZD5cIm1hbmlmZXN0XCI8L3RkPlxuICogICAgICAgICAgICAgPHRkPnVuZGVmaW5lZDwvdGQ+XG4gKiAgICAgICAgICAgICA8dGQ+VVJMIG9mIFwiZnVyaW91cy5ubWZcIiBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeSBhcyBcImZ1cmlvdXMuanNcIiBsaWJyYXJ5PC90ZD5cbiAqICAgICAgICAgPC90cj5cbiAqICAgICA8L3RhYmxlPlxuICpcbiAqICAgICA8dGFibGU+XG4gKiAgICAgICAgIDxjYXB0aW9uPk9wdGlvbnMgb2YgXCJ3ZWJjbFwiIGJhY2tlbmQ8L2NhcHRpb24+XG4gKiAgICAgICAgIDx0cj5cbiAqICAgICAgICAgICAgIDx0aD5PcHRpb24gbmFtZTwvdGg+XG4gKiAgICAgICAgICAgICA8dGg+T3B0aW9uIHZhbHVlczwvdGg+XG4gKiAgICAgICAgICAgICA8dGg+RGVmYXVsdCB2YWx1ZTwvdGg+XG4gKiAgICAgICAgIDwvdHI+XG4gKiAgICAgICAgIDx0cj5cbiAqICAgICAgICAgICAgIDx0ZD5cImRldmljZVwiPC90ZD5cbiAqICAgICAgICAgICAgIDx0ZD5EZXBlbmRzIG9uIHRoZSBwbGF0Zm9ybTwvdGQ+XG4gKiAgICAgICAgICAgICA8dGQ+RGlzY3JldGUgR1BVIGRldmljZSwgaWYgYXZhaWxhYmxlLiBPdGhlcndpc2UgaW50ZWdyYXRlZCBHUFUgZGV2aWNlLCBpZiBhdmFpbGFibGUuIE90aGVyd2lzZSBDUFUgZGV2aWNlLjwvdGQ+XG4gKiAgICAgICAgIDwvdHI+XG4gKiAgICAgPC90YWJsZT5cbiAqL1xudmFyIGdldEJhY2tlbmRPcHRpb25zID0gZnVuY3Rpb24oYmFja2VuZCkge1xuXHRpZiAoYmFja2VuZCA9PT0gXCJqYXZhc2NyaXB0XCIpIHtcblx0XHRpZiAoV2ViV29ya2VyQ29udGV4dC5pc1N1cHBvcnRlZCgpKSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcImFzeW5jXCI6IFt0cnVlLCBmYWxzZV1cblx0XHRcdH07XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiB7fTtcblx0XHR9XG5cdH0gZWxzZSBpZiAoYmFja2VuZCA9PT0gXCJwbmFjbFwiKSB7XG5cdFx0cmV0dXJuIHt9O1xuXHR9IGVsc2UgaWYgKGJhY2tlbmQgPT09IFwid2ViY2xcIikge1xuXHRcdHJldHVybiB7XG5cdFx0XHRcImRldmljZVwiOiBXZWJDTENvbnRleHQuZ2V0QXZhaWxhYmxlRGV2aWNlcygpXG5cdFx0fTtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBiYWNrZW5kOiBcIiArIGJhY2tlbmQpO1xuXHR9XG59O1xuXG4vKipcbiAqIFF1ZXJpZXMgZGVmYXVsdCBiYWNrZW5kIG9wdGlvbnMgb24gdGhpcyBwbGF0Zm9ybS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gYmFja2VuZCAtIG5hbWUgb2YgdGhlIGJhY2tlbmQgdG8gcXVlcnkgb3B0aW9ucyBmb3IuXG4gKlxuICogQHN0YXRpY1xuICogQG1ldGhvZCBnZXRCYWNrZW5kT3B0aW9uc1xuICpcbiAqIEByZXR1cm4ge09iamVjdH0gLSBBbiBvYmplY3QgdGhhdCBkZXNjcmliZXMgYXZhaWxhYmxlIG9wdGlvbnMuXG4gKiBUaGUgbmFtZXMgb2Ygb2JqZWN0J3MgcHJvcGVydGllcyBjb3JyZXNwb25kIHRvIGJhY2tlbmQgb3B0aW9uIG5hbWVzLlxuICogVGhlIHZhbHVlcyBvZiBvYmplY3QncyBwcm9wZXJ0aWVzIGNvcnJlc3BvbmQgdG8gZGVmYXVsdCBvcHRpb24gdmFsdWVzLlxuICovXG52YXIgZ2V0RGVmYXVsdEJhY2tlbmRPcHRpb25zID0gZnVuY3Rpb24oYmFja2VuZCkge1xuXHRpZiAoYmFja2VuZCA9PT0gXCJqYXZhc2NyaXB0XCIpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0XCJhc3luY1wiOiB0cnVlXG5cdFx0fTtcblx0fSBlbHNlIGlmIChiYWNrZW5kID09PSBcInBuYWNsXCIpIHtcblx0XHRpZiAoUE5hQ2xDb250ZXh0LmlzU3VwcG9ydGVkKCkpIHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFwibWFuaWZlc3RcIjogUE5hQ2xDb250ZXh0LmdldERlZmF1bHRNYW5pZmVzdFVSTCgpXG5cdFx0XHR9O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4ge307XG5cdFx0fVxuXHR9IGVsc2UgaWYgKGJhY2tlbmQgPT09IFwid2ViY2xcIikge1xuXHRcdHJldHVybiB7XG5cdFx0XHRcImRldmljZVwiOiBXZWJDTENvbnRleHQuZ2V0RGVmYXVsdERldmljZSgpXG5cdFx0fTtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBiYWNrZW5kOiBcIiArIGJhY2tlbmQpO1xuXHR9XG59O1xuXG4vKipcbiAqIERldGVjdHMgd2hldGhlciB0aGUgcmVxdWVzdGVkIGNvbXB1dGluZyBmZWF0dXJlIGlzIGF2YWlsYWJsZVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgaGFzRmVhdHVyZVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gYW4gaWRlbnRpZmllciBvZiB0aGUgb3B0aW9uYWwgZmVhdHVyZSB0byBkZXRlY3QuIFRoZSBmb2xsb3dpbmcgaWRlbnRpZmllcnMgYXJlIHN1cHBvcnRlZDpcbiAqXG4gKiAgICAgPHRhYmxlPlxuICogICAgICAgICA8dHI+XG4gKiAgICAgICAgICAgICA8dGg+RmVhdHVyZSBJZGVudGlmaWVyPC90aD5cbiAqICAgICAgICAgICAgIDx0aD5JbnRlcnByZXRhdGlvbjwvdGg+XG4gKiAgICAgICAgIDwvdHI+XG4gKiAgICAgICAgIDx0cj5cbiAqICAgICAgICAgICAgIDx0ZD5cIndlYndvcmtlcnNcIjwvdGQ+XG4gKiAgICAgICAgICAgICA8dGQ+RGV0ZWN0IGlmIHRoZSBKYXZhU2NyaXB0IGVuZ2luZSBjYW4gc3Bhd24gZGVkaWNhdGVkIFdlYiBXb3JrZXJzLjwvdGQ+XG4gKiAgICAgICAgIDwvdHI+XG4gKiAgICAgICAgIDx0cj5cbiAqICAgICAgICAgICAgIDx0ZD5cImFzbS5qc1wiPC90ZD5cbiAqICAgICAgICAgICAgIDx0ZD5EZXRlY3QgaWYgdGhlIEphdmFTY3JpcHQgZW5naW5lIHJlY29nbml6ZXMgQXNtLmpzIGRpcmVjdGl2ZS48L3RkPlxuICogICAgICAgICA8L3RyPlxuICogICAgICAgICA8dHI+XG4gKiAgICAgICAgICAgICA8dGQ+XCJzaW1kLmpzXCI8L3RkPlxuICogICAgICAgICAgICAgPHRkPkRldGVjdCBpZiB0aGUgSmF2YVNjcmlwdCBlbmdpbmUgcHJvdmlkZSBTSU1ELmZsb2F0MzJ4NCwgU0lNRC5pbnQzMng0LCBGbG9hdDMyeDRBcnJheSwgYW5kIEludDMyeDRBcnJheSBvZiBTSU1ELmpzPC90ZD5cbiAqICAgICAgICAgPC90cj5cbiAqICAgICAgICAgPHRyPlxuICogICAgICAgICAgICAgPHRkPlwid2ViZ2xcIjwvdGQ+XG4gKiAgICAgICAgICAgICA8dGQ+RGV0ZWN0IGlmIHRoZSBlbnZpcm9ubWVudCBzdXBwb3J0cyBXZWJHTCAoZWl0aGVyIGV4cGVyaW1lbnRhbCBvciBzdGFibGUgaW1wbGVtZW50YXRpb24pPC90ZD5cbiAqICAgICAgICAgPC90cj5cbiAqICAgICAgICAgPHRyPlxuICogICAgICAgICAgICAgPHRkPlwid2ViY2xcIjwvdGQ+XG4gKiAgICAgICAgICAgICA8dGQ+RGV0ZWN0IGlmIHRoZSBlbnZpcm9ubWVudCBzdXBwb3J0cyBXZWJDTDwvdGQ+XG4gKiAgICAgICAgIDwvdHI+XG4gKiAgICAgICAgIDx0cj5cbiAqICAgICAgICAgICAgIDx0ZD5cInBuYWNsXCI8L3RkPlxuICogICAgICAgICAgICAgPHRkPkRldGVjdCBpZiBQb3J0YWJsZSBOYXRpdmUgQ2xpZW50IChQTmFDbCkgaXMgc3VwcG9ydGVkIGFuZCBlbmFibGVkPC90ZD5cbiAqICAgICAgICAgPC90cj5cbiAqICAgICAgICAgPHRyPlxuICogICAgICAgICAgICAgPHRkPlwibmFjbFwiPC90ZD5cbiAqICAgICAgICAgICAgIDx0ZD5EZXRlY3QgaWYgTmF0aXZlIENsaWVudCAoTmFDbCkgaXMgc3VwcG9ydGVkIGFuZCBlbmFibGVkPC90ZD5cbiAqICAgICAgICAgPC90cj5cbiAqICAgICA8L3RhYmxlPlxuICpcbiAqIEByZXR1cm4ge0Jvb2xlYW59IC0gdHJ1ZSBpZiB0aGUgZmVhdHVyZSBpcyBzdXBwb3J0ZWQsIGZhbHNlIG90aGVyd2lzZVxuICovXG52YXIgaGFzRmVhdHVyZSA9IGZ1bmN0aW9uKG5hbWUpIHtcblx0c3dpdGNoIChuYW1lKSB7XG5cdFx0Y2FzZSBcImFzbS5qc1wiOlxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0dmFyIHVzZXJBZ2VudCA9IHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50O1xuXHRcdFx0XHR2YXIgdXNlckFnZW50Q29tcG9uZW50cyA9IHVzZXJBZ2VudC5zcGxpdCgvXFxzKy8pO1xuXHRcdFx0XHR2YXIgZmlyZWZveFJlZ2V4cCA9IC9bRmZdaXJlZm94XFwvKFxcZCspL2c7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdXNlckFnZW50Q29tcG9uZW50cy5sZW5ndGg7ICsraSkge1xuXHRcdFx0XHRcdHZhciBjb21wb25lbnQgPSB1c2VyQWdlbnRDb21wb25lbnRzW2ldO1xuXHRcdFx0XHRcdHZhciBtYXRjaCA9IGZpcmVmb3hSZWdleHAuZXhlYyhjb21wb25lbnQpO1xuXHRcdFx0XHRcdGlmIChtYXRjaCAhPT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0dmFyIGZpcmVmb3hWZXJzaW9uID0gcGFyc2VJbnQobWF0Y2hbMV0pO1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZpcmVmb3hWZXJzaW9uID49IDI5O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0Y2FzZSBcInNpbWQuanNcIjpcblx0XHRcdHJldHVybiAodHlwZW9mIFNJTUQgIT09IFwidW5kZWZpbmVkXCIpICYmXG5cdFx0XHRcdCh0eXBlb2YgRmxvYXQzMng0QXJyYXkgIT09IFwidW5kZWZpbmVkXCIpICYmXG5cdFx0XHRcdCh0eXBlb2YgSW50MzJ4NEFycmF5ICE9PSBcInVuZGVmaW5lZFwiKTtcblx0XHRjYXNlIFwid2Vid29ya2Vyc1wiOlxuXHRcdFx0cmV0dXJuICh0eXBlb2YgV29ya2VyICE9PSBcInVuZGVmaW5lZFwiKTtcblx0XHRjYXNlIFwid2ViZ2xcIjpcblx0XHRcdHRyeSB7XG5cdFx0XHRcdHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGlmIChjYW52YXMuZ2V0Q29udGV4dChcIndlYmdsXCIpICE9PSBudWxsKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0fVxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGlmIChjYW52YXMuZ2V0Q29udGV4dChcImV4cGVyaW1lbnRhbC13ZWJnbFwiKSAhPT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdH1cblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRjYXNlIFwid2ViY2xcIjpcblx0XHRcdHJldHVybiBXZWJDTENvbnRleHQuaXNTdXBwb3J0ZWQoKTtcblx0XHRjYXNlIFwicG5hY2xcIjpcblx0XHRcdHJldHVybiBQTmFDbENvbnRleHQuaXNTdXBwb3J0ZWQoKTtcblx0XHRjYXNlIFwibmFjbFwiOlxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0cmV0dXJuICh0eXBlb2YgbmF2aWdhdG9yLm1pbWVUeXBlc1tcImFwcGxpY2F0aW9uL3gtbmFjbFwiXSkgIT09IFwidW5kZWZpbmVkXCI7XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0ZGVmYXVsdDpcblx0XHRcdHRocm93IG5ldyBFcnJvcihcIlVua25vd24gZmVhdHVyZTogXCIgKyBuYW1lKTtcblx0fVxufTtcblxuZXhwb3J0cy5pbml0ID0gaW5pdDtcbmV4cG9ydHMuaGFzRmVhdHVyZSA9IGhhc0ZlYXR1cmU7XG5leHBvcnRzLmdldERlZmF1bHRCYWNrZW5kID0gZ2V0RGVmYXVsdEJhY2tlbmQ7XG5leHBvcnRzLmdldFN1cHBvcnRlZEJhY2tlbmRzID0gZ2V0U3VwcG9ydGVkQmFja2VuZHM7XG5leHBvcnRzLmdldEJhY2tlbmRPcHRpb25zID0gZ2V0QmFja2VuZE9wdGlvbnM7XG5leHBvcnRzLmdldERlZmF1bHRCYWNrZW5kT3B0aW9ucyA9IGdldERlZmF1bHRCYWNrZW5kT3B0aW9ucztcbmV4cG9ydHMuRGF0YVR5cGUgPSBEYXRhVHlwZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgTkRBcnJheSA9IHJlcXVpcmUoXCIuLy4uL05EQXJyYXlcIik7XG52YXIgRGF0YVR5cGUgPSByZXF1aXJlKFwiLi8uLi9EYXRhVHlwZVwiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4vLi4vdXRpbFwiKTtcbnZhciBqc21hdGggPSByZXF1aXJlKFwiLi9qc21hdGhcIik7XG5cbi8qKlxuICogUHJvdmlkZXMgbWV0aG9kcyBmb3IgY3JlYXRpb24sIG1hbmlwdWxhdGlvbiwgYW5kIGRlc3RydWN0aW9uIG9mIE4tZGltZW5zaW9uYWwgYXJyYXlzLlxuICogQXJpdGhtZXRpYyBvcGVyYXRpb25zIGFyZSBwb3NzaWJsZSBvbmx5IG9uIGFycmF5cyB0aGF0IGJlbG9uZyB0byB0aGUgc2FtZSBjb250ZXh0LlxuICpcbiAqIEBjbGFzcyBDb250ZXh0XG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gSlNDb250ZXh0KG9wdGlvbnMsIGNhbGxiYWNrKSB7XG5cdGNhbGxiYWNrKHRoaXMpO1xufVxuXG4vKipcbiAqIENvbnN0cnVjdHMgYW4gdW5pbmlhbGl6ZWQgTi1kaW1lbnNpb25hbCBhcnJheS5cbiAqXG4gKiBAbWV0aG9kIGVtcHR5XG4gKiBAcGFyYW0ge051bWJlcn0gc2hhcGUgLSB0aGUgZGltZW5zaW9ucyBvZiB0aGUgYXJyYXlcbiAqIEBwYXJhbSB7RGF0YVR5cGV9IGRhdGFUeXBlIC0gdGhlIHR5cGUgb2YgZWxlbWVudHMgaW4gdGhlIGFycmF5LlxuICovXG5KU0NvbnRleHQucHJvdG90eXBlLmVtcHR5ID0gZnVuY3Rpb24oc2hhcGUsIGRhdGFUeXBlKSB7XG5cdC8qIFRoZSBpcyBubyB3YXkgdG8gY3JlYXRlIHVuaW5pdGlhbGl6ZWQgdHlwZWQgYXJyYXkgaW4gSmF2YVNjcmlwdCAqL1xuXHRyZXR1cm4gdGhpcy56ZXJvcyhzaGFwZSwgZGF0YVR5cGUpO1xufTtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGFuIE4tZGltZW5zaW9uYWwgYXJyYXkgd2l0aCBlbGVtZW50cyBpbml0aWFsaXplZCB0byB6ZXJvLlxuICpcbiAqIEBtZXRob2QgemVyb3NcbiAqIEBwYXJhbSB7TnVtYmVyfSBzaGFwZSAtIHRoZSBkaW1lbnNpb25zIG9mIHRoZSBhcnJheVxuICogQHBhcmFtIHtEYXRhVHlwZX0gZGF0YVR5cGUgLSB0aGUgdHlwZSBvZiBlbGVtZW50cyBpbiB0aGUgYXJyYXkuXG4gKi9cbkpTQ29udGV4dC5wcm90b3R5cGUuemVyb3MgPSBmdW5jdGlvbihzaGFwZSwgZGF0YVR5cGUpIHtcblx0c2hhcGUgPSB1dGlsLmNoZWNrU2hhcGUoc2hhcGUpO1xuXHRpZiAodHlwZW9mIGRhdGFUeXBlID09PSBcInVuZGVmaW5lZFwiKSB7XG5cdFx0ZGF0YVR5cGUgPSBuZXcgRGF0YVR5cGUoXCJmNjRcIik7XG5cdH0gZWxzZSB7XG5cdFx0ZGF0YVR5cGUgPSB1dGlsLmNoZWNrRGF0YVR5cGUoZGF0YVR5cGUpO1xuXHR9XG5cdHZhciBhcnJheSA9IG5ldyBOREFycmF5KHNoYXBlLCBkYXRhVHlwZSwgdGhpcyk7XG5cdGFycmF5Ll9kYXRhID0gbmV3IGRhdGFUeXBlLmFycmF5VHlwZShhcnJheS5sZW5ndGgpO1xuXHRyZXR1cm4gYXJyYXk7XG59O1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYW4gTi1kaW1lbnNpb25hbCBhcnJheSB3aXRoIGVsZW1lbnRzIGluaXRpYWxpemVkIHRvIG9uZS5cbiAqXG4gKiBAbWV0aG9kIG9uZXNcbiAqIEBwYXJhbSB7TnVtYmVyfSBzaGFwZSAtIHRoZSBkaW1lbnNpb25zIG9mIHRoZSBhcnJheVxuICogQHBhcmFtIHtEYXRhVHlwZX0gZGF0YVR5cGUgLSB0aGUgdHlwZSBvZiBlbGVtZW50cyBpbiB0aGUgYXJyYXkuXG4gKi9cbkpTQ29udGV4dC5wcm90b3R5cGUub25lcyA9IGZ1bmN0aW9uKHNoYXBlLCBkYXRhVHlwZSkge1xuXHQvKiBUaGUgaXMgbm8gd2F5IHRvIGNyZWF0ZSB1bmluaXRpYWxpemVkIHR5cGVkIGFycmF5IGluIEphdmFTY3JpcHQgKi9cblx0dmFyIGFycmF5ID0gdGhpcy56ZXJvcyhzaGFwZSwgZGF0YVR5cGUpO1xuXHRqc21hdGguZmlsbChhcnJheS5fZGF0YSwgMS4wKTtcblx0cmV0dXJuIGFycmF5O1xufTtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGFuIE4tZGltZW5zaW9uYWwgYXJyYXkgb2JqZWN0IHdpdGggdGhlIHByb3ZpZGVkIGRhdGEuXG4gKlxuICogQG1ldGhvZCBhcnJheVxuICogQHBhcmFtIHtOdW1iZXJbXX0gZGF0YSAtIHRoZSBhcnJheSBkYXRhXG4gKiBAcGFyYW0ge0RhdGFUeXBlfSBkYXRhVHlwZSAtIHRoZSB0eXBlIG9mIGVsZW1lbnRzIGluIHRoZSBhcnJheS5cbiAqL1xuSlNDb250ZXh0LnByb3RvdHlwZS5hcnJheSA9IGZ1bmN0aW9uKGRhdGEsIGRhdGFUeXBlKSB7XG5cdGlmICh0eXBlb2YgZGF0YVR5cGUgPT09IFwidW5kZWZpbmVkXCIpIHtcblx0XHRkYXRhVHlwZSA9IG5ldyBEYXRhVHlwZShcImY2NFwiKTtcblx0fSBlbHNlIHtcblx0XHRkYXRhVHlwZSA9IHV0aWwuY2hlY2tEYXRhVHlwZShkYXRhVHlwZSk7XG5cdH1cblx0dmFyIHNoYXBlID0gW107XG5cdHV0aWwuZGlzY292ZXJBcnJheVNoYXBlUmVjdXJzaXZlKGRhdGEsIHNoYXBlLCAwKTtcblx0dmFyIGFycmF5ID0gdGhpcy5lbXB0eShzaGFwZSwgZGF0YVR5cGUpO1xuXHR1dGlsLmNvcHlBcnJheURhdGFSZWN1cnNpdmUoYXJyYXkuX2RhdGEsIGRhdGEsIHNoYXBlLCAwLCAwKTtcblx0cmV0dXJuIGFycmF5O1xufTtcblxuLyoqXG4gKiBEZS1hbGxvY2F0ZXMgZGF0YSBhc3NvY2lhdGVkIHdpdGggdGhlIGFycmF5LlxuICpcbiAqIEBtZXRob2QgX2ludmFsaWRhdGVcbiAqIEBwcml2YXRlXG4gKlxuICogQHBhcmFtIHtOREFycmF5fSBhcnJheSAtIHRoZSBuLWRpbWVuc2lvbmFsIGFycmF5IG9iamVjdCB3aXRoIGRhdGEgdG8gYmUgZGUtYWxsb2NhdGVkLlxuICovXG5KU0NvbnRleHQucHJvdG90eXBlLl9pbnZhbGlkYXRlID0gZnVuY3Rpb24oYXJyYXkpIHtcblx0dXRpbC5jaGVja05EQXJyYXkoYXJyYXksIFwiYXJyYXlcIik7XG5cdGFycmF5Ll9kYXRhID0gbnVsbDtcbn07XG5cbi8qKlxuICogRmV0Y2hlcyBOREFycmF5IGRhdGEgYW5kIGFzeW5jaHJvbm91c2x5IHJldHVybnMgaXQgYXMgSmF2YVNjcmlwdCB0eXBlZCBhcnJheXMuXG4gKlxuICogQG1ldGhvZCBmZXRjaFxuICogQGFzeW5jXG4gKlxuICogQHBhcmFtIHtOREFycmF5fSBhcnJheXMqIC0gTkRBcnJheXMgdG8gZmV0Y2guXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIEEgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIHdpdGggdGhlIGRhdGEgd2hlbiBpdCBpcyBhdmFpbGFibGUuXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyVmlld30gY2FsbGJhY2suYXJyYXlzKiAtIHR5cGVkIGFycmF5cyB3aXRoIHRoZSBkYXRhLiBUaGUgZWxlbWVudCB0eXBlIG9mIHRoZSB0eXBlZCBhcnJheSBtYXRjaGVzIHRoZSBkYXRhIHR5cGUgb2YgdGhlIE5EQXJyYXkuIEZvciB6ZXJvLWRpbWVuc2lvbmFsIGFycmF5cyB0aGUgb3V0cHV0IGlzIHJldHVybmVkIGFzIGEgdHlwZWQgYXJyYXkgd2l0aCBhIHNpbmdsZSBlbGVtZW50LiBNdWx0aS1kaW1lbnNpb25hbCBhcnJheXMgYXJlIHJldHVybmVkIGluIHJvdy1tYWpvciBzdG9yYWdlIGZvcm1hdC5cbiAqL1xuSlNDb250ZXh0LnByb3RvdHlwZS5mZXRjaCA9IGZ1bmN0aW9uKCkge1xuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIkNhbGxiYWNrIGFyZ3VtZW50IG1pc3NpbmdcIik7XG5cdH1cblx0dmFyIGNhbGxiYWNrID0gYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAxXTtcblx0LyogVmFsaWRhdGUgYXJndW1lbnRzICovXG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiQXQgbGVhc3Qgb25lIE5EQXJyYXkgYXJndW1lbnQgZXhwZWN0ZWRcIik7XG5cdH1cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoIC0gMTsgKytpKSB7XG5cdFx0dXRpbC5jaGVja05EQXJyYXkoYXJndW1lbnRzW2ldLCBcImFyZ3VtZW50IFwiICsgaSk7XG5cdH1cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoIC0gMTsgKytpKSB7XG5cdFx0YXJndW1lbnRzW2ldLl9kZWNSZWYoKTtcblx0fVxuXHR2YXIgY2FsbGJhY2tBcmd1bWVudHMgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IGNhbGxiYWNrQXJndW1lbnRzLmxlbmd0aDsgKytpKSB7XG5cdFx0dmFyIGFycmF5ID0gYXJndW1lbnRzW2ldO1xuXHRcdGNhbGxiYWNrQXJndW1lbnRzW2ldID0gbmV3IGFycmF5LmRhdGFUeXBlLmFycmF5VHlwZShhcnJheS5fZGF0YSk7XG5cdH1cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoIC0gMTsgKytpKSB7XG5cdFx0YXJndW1lbnRzW2ldLl90cnlJbnZhbGlkYXRlKCk7XG5cdH1cblx0Y2FsbGJhY2suYXBwbHkobnVsbCwgY2FsbGJhY2tBcmd1bWVudHMpO1xufTtcblxuLyoqXG4gKiBGZXRjaGVzIE5EQXJyYXkgZGF0YSBhbmQgYXN5bmNocm9ub3VzbHkgcmV0dXJucyBpdCBhcyBKYXZhU2NyaXB0IGFycmF5cyBvciBudW1iZXJzLlxuICpcbiAqIEBtZXRob2QgZ2V0XG4gKiBAYXN5bmNcbiAqXG4gKiBAcGFyYW0ge05EQXJyYXl9IGFycmF5cyogLSBOREFycmF5cyB0byBmZXRjaC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gQSBjYWxsYmFjayB0byBiZSBjYWxsZWQgd2l0aCB0aGUgZGF0YSB3aGVuIGl0IGlzIGF2YWlsYWJsZS5cbiAqIEBwYXJhbSB7TnVtYmVyfE51bWJlcltdfSBjYWxsYmFjay5hcnJheXMqIC0gSmF2YVNjcmlwdCBudW1iZXJzIG9yIG11bHRpZGltZW5zaW9uYWwgYXJyYXlzIHdpdGggdGhlIGRhdGEuIFRoZSBudW1iZXIgYW5kIG9yZGVyIG9mIGFyZ3VtZW50cyBtYXRjaGVzIHRoZSBOREFycmF5cyBwYXNzZWQgdG8gdGhlIG1ldGhvZCBjYWxsLlxuICovXG5KU0NvbnRleHQucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKCkge1xuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIkNhbGxiYWNrIGFyZ3VtZW50IG1pc3NpbmdcIik7XG5cdH1cblx0dmFyIGNhbGxiYWNrID0gYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAxXTtcblx0LyogVmFsaWRhdGUgYXJndW1lbnRzICovXG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiQXQgbGVhc3Qgb25lIE5EQXJyYXkgYXJndW1lbnQgZXhwZWN0ZWRcIik7XG5cdH1cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoIC0gMTsgKytpKSB7XG5cdFx0dXRpbC5jaGVja05EQXJyYXkoYXJndW1lbnRzW2ldLCBcImFyZ3VtZW50IFwiICsgaSk7XG5cdH1cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoIC0gMTsgKytpKSB7XG5cdFx0YXJndW1lbnRzW2ldLl9kZWNSZWYoKTtcblx0fVxuXHR2YXIgY2FsbGJhY2tBcmd1bWVudHMgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IGNhbGxiYWNrQXJndW1lbnRzLmxlbmd0aDsgKytpKSB7XG5cdFx0dmFyIGFycmF5ID0gYXJndW1lbnRzW2ldO1xuXHRcdGlmIChhcnJheS5zaGFwZS5sZW5ndGggPT09IDApIHtcblx0XHRcdGNhbGxiYWNrQXJndW1lbnRzW2ldID0gYXJyYXkuX2RhdGFbMF07XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBqc2FycmF5ID0gbmV3IEFycmF5KGFycmF5LnNoYXBlWzBdKTtcblx0XHRcdHV0aWwuY3JlYXRlQXJyYXlSZWN1cnNpdmUoYXJyYXkuX2RhdGEsIGpzYXJyYXksIGFycmF5LnNoYXBlLCAwLCAwKTtcblx0XHRcdGNhbGxiYWNrQXJndW1lbnRzW2ldID0ganNhcnJheTtcblx0XHR9XG5cdH1cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoIC0gMTsgKytpKSB7XG5cdFx0YXJndW1lbnRzW2ldLl90cnlJbnZhbGlkYXRlKCk7XG5cdH1cblx0Y2FsbGJhY2suYXBwbHkobnVsbCwgY2FsbGJhY2tBcmd1bWVudHMpO1xufTtcblxuLyoqXG4gKiBXYWl0cyB1bnRpbCBwcmV2aW91cyBjb21tYW5kcyBmaW5pc2hlZCBleGVjdXRpb24gYW5kIGNhbGxzIHRoZSBjYWxsYmFjay5cbiAqXG4gKiBAbWV0aG9kIGJhcnJpZXJcbiAqIEBhc3luY1xuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gQSBjYWxsYmFjayB0byBiZSBjYWxsZWQgYWZ0ZXIgdGhlIHByZXZpb3VzIGNvbW1hbmRzIHJldGlyZS5cbiAqL1xuSlNDb250ZXh0LnByb3RvdHlwZS5iYXJyaWVyID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcblx0Y2FsbGJhY2soKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhbm90aGVyIGFycmF5IHdpdGggdGhlIHNhbWUgZGF0YSwgYnV0IGRpZmZlcmVudCBkaW1lbnNpb25zLlxuICpcbiAqIEBtZXRob2QgcmVzaGFwZVxuICogQHBhcmFtIHsoTkRBcnJheXxOdW1iZXIpfSBzaGFwZSAtIGRpbWVuc2lvbnMgb2YgdGhlIG5ldyBhcnJheS5cbiAqL1xuSlNDb250ZXh0LnByb3RvdHlwZS5yZXNoYXBlID0gZnVuY3Rpb24oYXJyYXksIHNoYXBlKSB7XG5cdHNoYXBlID0gdXRpbC5jaGVja1NoYXBlKHNoYXBlKTtcblx0aWYgKHV0aWwuY29tcHV0ZUxlbmd0aChzaGFwZSkgIT09IGFycmF5Lmxlbmd0aCkge1xuXHRcdHRocm93IG5ldyBSYW5nZUVycm9yKFwiVGhlIHNoYXBlIGlzIG5vdCBjb21wYXRpYmxlIHdpdGggdGhlIGFycmF5XCIpO1xuXHR9XG5cdHZhciBvdXQgPSBuZXcgTkRBcnJheShzaGFwZSwgYXJyYXkuZGF0YVR5cGUsIHRoaXMpO1xuXHRpZiAoYXJyYXkuX2RlY1JlZigpKSB7XG5cdFx0b3V0Ll9kYXRhID0gbmV3IG91dC5kYXRhVHlwZS5hcnJheVR5cGUob3V0Lmxlbmd0aCk7XG5cdFx0b3V0Ll9kYXRhLnNldChhcnJheS5fZGF0YSk7XG5cdH0gZWxzZSB7XG5cdFx0b3V0Ll9kYXRhID0gYXJyYXkuX2RhdGE7XG5cdFx0YXJyYXkuX3RyeUludmFsaWRhdGUoKTtcblx0fVxuXHRyZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBEdXBsaWNhdGVzIGFycmF5IGVsZW1lbnRzIGFsb25nIHRoZSBzcGVjaWZpZWQgYXhpcy5cbiAqXG4gKiBAbWV0aG9kIHJlcGVhdFxuICogQHBhcmFtIHtOREFycmF5fSBhIC0gdGhlIGlucHV0IGFycmF5LlxuICogQHBhcmFtIHtOdW1iZXJ9IHJlcGVhdHMgLSB0aGUgbnVtYmVyIG9mIHRpbWVzIHRvIHJlcGVhdCBlYWNoIGVsZW1lbnQuXG4gKiBAcGFyYW0ge051bWJlcn0gYXhpcyAtIHRoZSBheGlzIGFsb25nIHdoaWNoIHRoZSBlbGVtZW50cyB3aWxsIGJlIGR1cGxpY2F0ZWQuXG4gKiBAcGFyYW0ge05EQXJyYXl9IFtvdXRdIC0gYW4gb3V0cHV0IGFycmF5IHRvIHN0b3JlIHRoZSByZXN1bHQuXG4gKiBAcmV0dXJuIHtOREFycmF5fSAtIGFuIE4tZGltZW5zaW9uYWwgYXJyYXkgd2l0aCByZXBlYXRlZCBlbGVtZW50cyBvZiBhcnJheSAqKmEqKi5cbiAqL1xuSlNDb250ZXh0LnByb3RvdHlwZS5yZXBlYXQgPSBmdW5jdGlvbihhLCByZXBlYXRzLCBheGlzLCBvdXQpIHtcblx0dXRpbC5jaGVja05EQXJyYXkoYSwgXCJhXCIpO1xuXHRyZXBlYXRzID0gdXRpbC5jaGVja1JlcGVhdHMocmVwZWF0cyk7XG5cdGF4aXMgPSB1dGlsLmNoZWNrQXhpcyhheGlzLCBhLnNoYXBlLmxlbmd0aCk7XG5cdHZhciBzaGFwZUEgPSBhLnNoYXBlO1xuXHR2YXIgc2hhcGVPdXQgPSBzaGFwZUEuc2xpY2UoMCk7XG5cdHNoYXBlT3V0W2F4aXNdICo9IHJlcGVhdHM7XG5cdGEuX2RlY1JlZigpO1xuXHR0cnkge1xuXHRcdGlmICh0eXBlb2Ygb3V0ID09PSBcInVuZGVmaW5lZFwiKSB7XG5cdFx0XHRvdXQgPSB0aGlzLmVtcHR5KHNoYXBlT3V0LCBhLmRhdGFUeXBlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dXRpbC5jaGVja05EQXJyYXkob3V0LCBcIm91dFwiKTtcblx0XHRcdHV0aWwuY2hlY2tTaGFwZXNDb21wYXRpYmlsaXR5KG91dC5zaGFwZSwgc2hhcGVPdXQpO1xuXHRcdFx0dXRpbC5jaGVja0RhdGFUeXBlc0NvbXBhdGliaWxpdHkoYS5kYXRhVHlwZSwgb3V0LmRhdGFUeXBlKTtcblx0XHRcdG91dC5faW5jUmVmKCk7XG5cdFx0fVxuXHRcdHZhciBvdXRlclN0cmlkZSA9IHV0aWwuY29tcHV0ZU91dGVyU3RyaWRlKHNoYXBlQSwgYXhpcyk7XG5cdFx0dmFyIGlubmVyU3RyaWRlID0gdXRpbC5jb21wdXRlSW5uZXJTdHJpZGUoc2hhcGVBLCBheGlzKTtcblx0XHRqc21hdGgucmVwZWF0KGEuX2RhdGEsIG91dC5fZGF0YSwgb3V0ZXJTdHJpZGUsIGlubmVyU3RyaWRlLCBzaGFwZUFbYXhpc10sIHJlcGVhdHMpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0YS5faW5jUmVmKCk7XG5cdFx0dGhyb3cgZTtcblx0fVxuXHRhLl90cnlJbnZhbGlkYXRlKCk7XG5cdHJldHVybiBvdXQ7XG59O1xuXG52YXIgYmluYXJ5QXJpdGhPcCA9IGZ1bmN0aW9uKGEsIGIsIG91dCwgY29udGV4dCwgb3BlcmF0aW9uLCBvcGVyYXRpb25Db25zdCwgb3BlcmF0aW9uUmV2Q29uc3QpIHtcblx0dmFyIHNoYXBlT3V0ID0gbnVsbCwgZGF0YVR5cGVPdXQgPSBudWxsO1xuXHRpZiAoYSBpbnN0YW5jZW9mIE5EQXJyYXkpIHtcblx0XHRzaGFwZU91dCA9IGEuc2hhcGU7XG5cdFx0ZGF0YVR5cGVPdXQgPSBhLmRhdGFUeXBlO1xuXHRcdGlmIChiIGluc3RhbmNlb2YgTkRBcnJheSkge1xuXHRcdFx0dXRpbC5jaGVja1NoYXBlc0NvbXBhdGliaWxpdHkoYS5zaGFwZSwgYi5zaGFwZSk7XG5cdFx0XHR1dGlsLmNoZWNrRGF0YVR5cGVzQ29tcGF0aWJpbGl0eShhLmRhdGFUeXBlLCBiLmRhdGFUeXBlKTtcblx0XHR9IGVsc2UgaWYgKCF1dGlsLmlzTnVtYmVyKGIpKSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5zdXBwb3J0ZWQgdHlwZSBvZiBiXCIpO1xuXHRcdH1cblx0fSBlbHNlIGlmICh1dGlsLmlzTnVtYmVyKGEpKSB7XG5cdFx0c2hhcGVPdXQgPSBiLnNoYXBlO1xuXHRcdGRhdGFUeXBlT3V0ID0gYi5kYXRhVHlwZTtcblx0XHR1dGlsLmNoZWNrTkRBcnJheShiLCBcImJcIik7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihcIlVuc3VwcG9ydGVkIHR5cGUgb2YgYVwiKTtcblx0fVxuXHRpZiAoYSBpbnN0YW5jZW9mIE5EQXJyYXkpIHtcblx0XHRhLl9kZWNSZWYoKTtcblx0fVxuXHRpZiAoYiBpbnN0YW5jZW9mIE5EQXJyYXkpIHtcblx0XHRiLl9kZWNSZWYoKTtcblx0fVxuXHR0cnkge1xuXHRcdGlmICh0eXBlb2Ygb3V0ID09PSBcInVuZGVmaW5lZFwiKSB7XG5cdFx0XHRvdXQgPSBuZXcgTkRBcnJheShzaGFwZU91dCwgZGF0YVR5cGVPdXQsIGNvbnRleHQpO1xuXHRcdFx0aWYgKChhIGluc3RhbmNlb2YgTkRBcnJheSkgJiYgIWEuX2hhc1JlZnMoKSkge1xuXHRcdFx0XHRvdXQuX2RhdGEgPSBhLl9kYXRhO1xuXHRcdFx0fSBlbHNlIGlmICgoYiBpbnN0YW5jZW9mIE5EQXJyYXkpICYmICFiLl9oYXNSZWZzKCkpIHtcblx0XHRcdFx0b3V0Ll9kYXRhID0gYi5fZGF0YTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG91dC5fZGF0YSA9IG5ldyBkYXRhVHlwZU91dC5hcnJheVR5cGUob3V0Lmxlbmd0aCk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHV0aWwuY2hlY2tOREFycmF5KG91dCwgXCJvdXRcIik7XG5cdFx0XHR1dGlsLmNoZWNrU2hhcGVzQ29tcGF0aWJpbGl0eShzaGFwZU91dCwgb3V0LnNoYXBlKTtcblx0XHRcdHV0aWwuY2hlY2tEYXRhVHlwZXNDb21wYXRpYmlsaXR5KGRhdGFUeXBlT3V0LCBvdXQuZGF0YVR5cGUpO1xuXHRcdFx0b3V0Ll9pbmNSZWYoKTtcblx0XHR9XG5cdFx0aWYgKGEgaW5zdGFuY2VvZiBOREFycmF5KSB7XG5cdFx0XHRpZiAoYiBpbnN0YW5jZW9mIE5EQXJyYXkpIHtcblx0XHRcdFx0b3BlcmF0aW9uKGEuX2RhdGEsIGIuX2RhdGEsIG91dC5fZGF0YSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvcGVyYXRpb25Db25zdChhLl9kYXRhLCArYiwgb3V0Ll9kYXRhKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0b3BlcmF0aW9uUmV2Q29uc3QoYi5fZGF0YSwgK2EsIG91dC5fZGF0YSk7XG5cdFx0fVxuXHR9IGNhdGNoIChlKSB7XG5cdFx0LyogUmVzdG9yZSB0aGUgcHJldmlvdXMgc3RhdGUgKi9cblx0XHRpZiAoYSBpbnN0YW5jZW9mIE5EQXJyYXkpIHtcblx0XHRcdGEuX2luY1JlZigpO1xuXHRcdH1cblx0XHRpZiAoYiBpbnN0YW5jZW9mIE5EQXJyYXkpIHtcblx0XHRcdGIuX2luY1JlZigpO1xuXHRcdH1cblx0XHR0aHJvdyBlO1xuXHR9XG5cdGlmIChhIGluc3RhbmNlb2YgTkRBcnJheSkge1xuXHRcdGEuX3RyeUludmFsaWRhdGUoKTtcblx0fVxuXHRpZiAoYiBpbnN0YW5jZW9mIE5EQXJyYXkpIHtcblx0XHRiLl90cnlJbnZhbGlkYXRlKCk7XG5cdH1cblx0cmV0dXJuIG91dDtcbn07XG5cbnZhciB1bmFyeUFyaXRoT3AgPSBmdW5jdGlvbihhLCBvdXQsIGNvbnRleHQsIG9wZXJhdGlvbikge1xuXHR1dGlsLmNoZWNrTkRBcnJheShhLCBcImFcIik7XG5cdGEuX2RlY1JlZigpO1xuXHR0cnkge1xuXHRcdGlmICh0eXBlb2Ygb3V0ID09PSBcInVuZGVmaW5lZFwiKSB7XG5cdFx0XHRvdXQgPSBuZXcgTkRBcnJheShhLnNoYXBlLCBhLmRhdGFUeXBlLCBjb250ZXh0KTtcblx0XHRcdGlmICgoYSBpbnN0YW5jZW9mIE5EQXJyYXkpICYmICFhLl9oYXNSZWZzKCkpIHtcblx0XHRcdFx0b3V0Ll9kYXRhID0gYS5fZGF0YTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG91dC5fZGF0YSA9IG5ldyBhLmRhdGFUeXBlLmFycmF5VHlwZShvdXQubGVuZ3RoKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dXRpbC5jaGVja05EQXJyYXkob3V0LCBcIm91dFwiKTtcblx0XHRcdHV0aWwuY2hlY2tTaGFwZXNDb21wYXRpYmlsaXR5KGEuc2hhcGUsIG91dC5zaGFwZSk7XG5cdFx0XHR1dGlsLmNoZWNrRGF0YVR5cGVzQ29tcGF0aWJpbGl0eShhLmRhdGFUeXBlLCBvdXQuZGF0YVR5cGUpO1xuXHRcdFx0b3V0Ll9pbmNSZWYoKTtcblx0XHR9XG5cdFx0b3BlcmF0aW9uKGEuX2RhdGEsIG91dC5fZGF0YSk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHQvKiBSZXN0b3JlIHRoZSBwcmV2aW91cyBzdGF0ZSAqL1xuXHRcdGEuX2luY1JlZigpO1xuXHRcdHRocm93IGU7XG5cdH1cblx0YS5fdHJ5SW52YWxpZGF0ZSgpO1xuXHRyZXR1cm4gb3V0O1xufTtcblxudmFyIGF4aXNSZWR1Y2VPcCA9IGZ1bmN0aW9uKGEsIGF4aXMsIG91dCwgY29udGV4dCwgb3BlcmF0aW9uLCBheGlzT3BlcmF0aW9uKSB7XG5cdHV0aWwuY2hlY2tOREFycmF5KGEsIFwiYVwiKTtcblx0aWYgKHR5cGVvZiBheGlzID09PSBcInVuZGVmaW5lZFwiKSB7XG5cdFx0aWYgKHR5cGVvZiBvdXQgPT09IFwidW5kZWZpbmVkXCIpIHtcblx0XHRcdG91dCA9IGNvbnRleHQuZW1wdHkoW10sIGEuZGF0YVR5cGUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR1dGlsLmNoZWNrTkRBcnJheShvdXQsIFwib3V0XCIpO1xuXHRcdFx0dXRpbC5jaGVja1NoYXBlc0NvbXBhdGliaWxpdHkoW10sIG91dC5zaGFwZSk7XG5cdFx0XHR1dGlsLmNoZWNrRGF0YVR5cGVzQ29tcGF0aWJpbGl0eShhLmRhdGFUeXBlLCBvdXQuZGF0YVR5cGUpO1xuXHRcdFx0b3V0Ll9pbmNSZWYoKTtcblx0XHR9XG5cdFx0b3BlcmF0aW9uKGEuX2RhdGEsIG91dC5fZGF0YSk7XG5cdFx0YS5fdHJ5UmVsZWFzZSgpO1xuXHRcdHJldHVybiBvdXQ7XG5cdH0gZWxzZSB7XG5cdFx0YXhpcyA9IHV0aWwuY2hlY2tBeGlzKGF4aXMsIGEuc2hhcGUubGVuZ3RoKTtcblx0XHR2YXIgc2hhcGVPdXQgPSB1dGlsLmNvbXB1dGVBeGlzUmVkdWN0aW9uT3V0U2hhcGUoYS5zaGFwZSwgYXhpcyk7XG5cdFx0aWYgKHR5cGVvZiBvdXQgPT09IFwidW5kZWZpbmVkXCIpIHtcblx0XHRcdG91dCA9IGNvbnRleHQuZW1wdHkoc2hhcGVPdXQsIGEuZGF0YVR5cGUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR1dGlsLmNoZWNrTkRBcnJheShvdXQsIFwib3V0XCIpO1xuXHRcdFx0dXRpbC5jaGVja1NoYXBlc0NvbXBhdGliaWxpdHkoW10sIG91dC5zaGFwZSk7XG5cdFx0XHR1dGlsLmNoZWNrRGF0YVR5cGVzQ29tcGF0aWJpbGl0eShhLmRhdGFUeXBlLCBvdXQuZGF0YVR5cGUpO1xuXHRcdFx0b3V0Ll9pbmNSZWYoKTtcblx0XHR9XG5cdFx0YXhpc09wZXJhdGlvbihhLl9kYXRhLCBvdXQuX2RhdGEsXG5cdFx0XHR1dGlsLmNvbXB1dGVPdXRlclN0cmlkZShhLnNoYXBlLCBheGlzKSxcblx0XHRcdHV0aWwuY29tcHV0ZUlubmVyU3RyaWRlKGEuc2hhcGUsIGF4aXMpLFxuXHRcdFx0YS5zaGFwZVtheGlzXSk7XG5cdFx0YS5fdHJ5UmVsZWFzZSgpO1xuXHRcdHJldHVybiBvdXQ7XG5cdH1cbn07XG5cbi8qKlxuICogQWRkcyBvbmUgbnVtYmVyIG9yIGFycmF5IHdpdGggYW5vdGhlciBudW1iZXIgb3IgYXJyYXkuXG4gKiBBZGRpdGlvbiBpcyBwZXJmb3JtZWQgZWxlbWVudC1ieS1lbGVtZW50LlxuICpcbiAqIEBtZXRob2QgYWRkXG4gKiBAcGFyYW0geyhOREFycmF5fE51bWJlcil9IGEgLSBvbmUgbnVtYmVyIG9yIGFycmF5IHRvIGFkZC4gSWYgKipiKiogaXMgYSAqTnVtYmVyKiwgKiphKiogbXVzdCBiZSBhbiAqTkRBcnJheSouXG4gKiBAcGFyYW0geyhOREFycmF5fE51bWJlcil9IGIgLSBhbm90aGVyIG51bWJlciBvciBhcnJheSB0byBhZGQuIElmICoqYSoqIGlzIGEgKk51bWJlciosICoqYioqIG11c3QgYmUgYW4gKk5EQXJyYXkqLlxuICogQHBhcmFtIHtOREFycmF5fSBbb3V0XSAtIHRoZSBhcnJheSB3aGVyZSB0aGUgcmVzdWx0IGlzIHRvIGJlIHN0b3JlZC4gSWYgcHJvdmlkZWQsIG11c3QgbWF0Y2ggdGhlIHNoYXBlIGFuZCBkYXRhIHR5cGUgb2YgaW5wdXQgYXJyYXlzLlxuICogQHJldHVybiB7TkRBcnJheX0gLSB0aGUgcmVzdWx0IG9mIGVsZW1lbnQtd2lzZSBhZGRpdGlvbiBvZiAqKmEqKiBhbmQgKipiKiouXG4gKi9cbkpTQ29udGV4dC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24oYSwgYiwgb3V0KSB7XG5cdHJldHVybiBiaW5hcnlBcml0aE9wKGEsIGIsIG91dCwgdGhpcywganNtYXRoLmFkZCwganNtYXRoLmFkZENvbnN0LCBqc21hdGguYWRkQ29uc3QpO1xufTtcblxuLyoqXG4gKiBTdWJ0cmFjdHMgb25lIG51bWJlciBvciBhcnJheSBmcm9tIGFub3RoZXIgbnVtYmVyIG9yIGFycmF5LlxuICogU3VidHJhY3Rpb24gaXMgcGVyZm9ybWVkIGVsZW1lbnQtYnktZWxlbWVudC5cbiAqXG4gKiBAbWV0aG9kIHN1YlxuICogQHBhcmFtIHsoTkRBcnJheXxOdW1iZXIpfSBhIC0gdGhlIG51bWJlciBvciBhcnJheSB0byBzdWJ0cmFjdCBmcm9tLiBJZiAqKmIqKiBpcyBhICpOdW1iZXIqLCAqKmEqKiBtdXN0IGJlIGFuICpOREFycmF5Ki5cbiAqIEBwYXJhbSB7KE5EQXJyYXl8TnVtYmVyKX0gYiAtIHRoZSBudW1iZXIgb3IgYXJyYXkgdG8gc3VidHJhY3QuIElmICoqYSoqIGlzIGEgKk51bWJlciosICoqYioqIG11c3QgYmUgYW4gKk5EQXJyYXkqLlxuICogQHBhcmFtIHtOREFycmF5fSBbb3V0XSAtIHRoZSBhcnJheSB3aGVyZSB0aGUgcmVzdWx0IGlzIHRvIGJlIHN0b3JlZC4gSWYgcHJvdmlkZWQsIG11c3QgbWF0Y2ggdGhlIHNoYXBlIGFuZCBkYXRhIHR5cGUgb2YgaW5wdXQgYXJyYXlzLlxuICogQHJldHVybiB7TkRBcnJheX0gLSB0aGUgcmVzdWx0IG9mIGVsZW1lbnQtd2lzZSBzdWJ0cmFjdGlvbiBvZiAqKmIqKiBmcm9tICoqYSoqLlxuICovXG5KU0NvbnRleHQucHJvdG90eXBlLnN1YiA9IGZ1bmN0aW9uKGEsIGIsIG91dCkge1xuXHRyZXR1cm4gYmluYXJ5QXJpdGhPcChhLCBiLCBvdXQsIHRoaXMsIGpzbWF0aC5zdWIsIGpzbWF0aC5zdWJDb25zdCwganNtYXRoLnN1YlJldkNvbnN0KTtcbn07XG5cbi8qKlxuICogTXVsdGlwbGllcyBvbmUgbnVtYmVyIG9yIGFycmF5IGJ5IGFub3RoZXIgbnVtYmVyIG9yIGFycmF5LlxuICogTXVsdGlwbGljYXRpb24gaXMgcGVyZm9ybWVkIGVsZW1lbnQtYnktZWxlbWVudC5cbiAqXG4gKiBAbWV0aG9kIG11bFxuICogQHBhcmFtIHsoTkRBcnJheXxOdW1iZXIpfSBhIC0gb25lIG51bWJlciBvciBhcnJheSB0byBtdWx0aXBseS4gSWYgKipiKiogaXMgYSAqTnVtYmVyKiwgKiphKiogbXVzdCBiZSBhbiAqTkRBcnJheSouXG4gKiBAcGFyYW0geyhOREFycmF5fE51bWJlcil9IGIgLSBhbm90aGVyIG51bWJlciBvciBhcnJheSB0byBtdWx0aXBseS4gSWYgKiphKiogaXMgYSAqTnVtYmVyKiwgKipiKiogbXVzdCBiZSBhbiAqTkRBcnJheSouXG4gKiBAcGFyYW0ge05EQXJyYXl9IFtvdXRdIC0gdGhlIGFycmF5IHdoZXJlIHRoZSByZXN1bHQgaXMgdG8gYmUgc3RvcmVkLiBJZiBwcm92aWRlZCwgbXVzdCBtYXRjaCB0aGUgc2hhcGUgYW5kIGRhdGEgdHlwZSBvZiBpbnB1dCBhcnJheXMuXG4gKiBAcmV0dXJuIHtOREFycmF5fSAtIHRoZSByZXN1bHQgb2YgZWxlbWVudC13aXNlIG11bHRpcGxpY2F0aW9uIG9mICoqYSoqIGFuZCAqKmIqKi5cbiAqL1xuSlNDb250ZXh0LnByb3RvdHlwZS5tdWwgPSBmdW5jdGlvbihhLCBiLCBvdXQpIHtcblx0cmV0dXJuIGJpbmFyeUFyaXRoT3AoYSwgYiwgb3V0LCB0aGlzLCBqc21hdGgubXVsLCBqc21hdGgubXVsQ29uc3QsIGpzbWF0aC5tdWxDb25zdCk7XG59O1xuXG4vKipcbiAqIERpdmlkZXMgb25lIG51bWJlciBvciBhcnJheSBieSBhbm90aGVyIG51bWJlciBvciBhcnJheS5cbiAqIERpdmlzaW9uIGlzIHBlcmZvcm1lZCBlbGVtZW50LWJ5LWVsZW1lbnQuXG4gKlxuICogQG1ldGhvZCBkaXZcbiAqIEBwYXJhbSB7KE5EQXJyYXl8TnVtYmVyKX0gYSAtIHRoZSBudW1iZXIgb3IgYXJyYXkgdG8gZGl2aWRlLiBJZiAqKmIqKiBpcyBhICpOdW1iZXIqLCAqKmEqKiBtdXN0IGJlIGFuICpOREFycmF5Ki5cbiAqIEBwYXJhbSB7KE5EQXJyYXl8TnVtYmVyKX0gYiAtIHRoZSBudW1iZXIgb3IgYXJyYXkgdG8gZGl2aWRlIGJ5LiBJZiAqKmEqKiBpcyBhICpOdW1iZXIqLCAqKmIqKiBtdXN0IGJlIGFuICpOREFycmF5Ki5cbiAqIEBwYXJhbSB7TkRBcnJheX0gW291dF0gLSB0aGUgYXJyYXkgd2hlcmUgdGhlIHJlc3VsdCBpcyB0byBiZSBzdG9yZWQuIElmIHByb3ZpZGVkLCBtdXN0IG1hdGNoIHRoZSBzaGFwZSBhbmQgZGF0YSB0eXBlIG9mIGlucHV0IGFycmF5cy5cbiAqIEByZXR1cm4ge05EQXJyYXl9IC0gdGhlIHJlc3VsdCBvZiBlbGVtZW50LXdpc2UgZGl2aXNpb24gb2YgKiphKiogYnkgKipiKiouXG4gKi9cbkpTQ29udGV4dC5wcm90b3R5cGUuZGl2ID0gZnVuY3Rpb24oYSwgYiwgb3V0KSB7XG5cdHJldHVybiBiaW5hcnlBcml0aE9wKGEsIGIsIG91dCwgdGhpcywganNtYXRoLmRpdiwganNtYXRoLmRpdkNvbnN0LCBqc21hdGguZGl2UmV2Q29uc3QpO1xufTtcblxuSlNDb250ZXh0LnByb3RvdHlwZS5taW4gPSBmdW5jdGlvbihhLCBheGlzLCBvdXQpIHtcblx0cmV0dXJuIGF4aXNSZWR1Y2VPcChhLCBheGlzLCBvdXQsIHRoaXMsIGpzbWF0aC5taW4sIGpzbWF0aC5heGlzTWluKTtcbn07XG5cbkpTQ29udGV4dC5wcm90b3R5cGUubWF4ID0gZnVuY3Rpb24oYSwgYXhpcywgb3V0KSB7XG5cdHJldHVybiBheGlzUmVkdWNlT3AoYSwgYXhpcywgb3V0LCB0aGlzLCBqc21hdGgubWF4LCBqc21hdGguYXhpc01heCk7XG59O1xuXG5KU0NvbnRleHQucHJvdG90eXBlLnN1bSA9IGZ1bmN0aW9uKGEsIGF4aXMsIG91dCkge1xuXHRyZXR1cm4gYXhpc1JlZHVjZU9wKGEsIGF4aXMsIG91dCwgdGhpcywganNtYXRoLnN1bSwganNtYXRoLmF4aXNTdW0pO1xufTtcblxuLyoqXG4gKiBOZWdhdGVzIGFycmF5IGVsZW1lbnRzLlxuICpcbiAqIEBtZXRob2QgbmVnXG4gKiBAcGFyYW0ge05EQXJyYXl9IGEgLSB0aGUgYXJyYXkgb2YgZWxlbWVudHMgdG8gYmUgbmVnYXRlZC5cbiAqIEBwYXJhbSB7TkRBcnJheX0gW291dF0gLSB0aGUgYXJyYXkgZm9yIG5lZ2F0ZWQgZWxlbWVudHMuIElmIHN1cHBsaWVkLCBtdXN0IG1hdGNoIHRoZSBkaW1lbnNpb25zIGFuZCBkYXRhIHR5cGUgb2YgdGhlICoqYSoqIGFycmF5LlxuICovXG5KU0NvbnRleHQucHJvdG90eXBlLm5lZyA9IGZ1bmN0aW9uKGEsIG91dCkge1xuXHRyZXR1cm4gdW5hcnlBcml0aE9wKGEsIG91dCwgdGhpcywganNtYXRoLm5lZyk7XG59O1xuXG4vKipcbiAqIENvbXB1dGVzIGFic29sdXRlIHZhbHVlIG9mIGFycmF5IGVsZW1lbnRzLlxuICpcbiAqIEBtZXRob2QgYWJzXG4gKiBAcGFyYW0ge05EQXJyYXl9IGEgLSB0aGUgYXJyYXkgb2YgaW5wdXQgZWxlbWVudHMuXG4gKiBAcGFyYW0ge05EQXJyYXl9IFtvdXRdIC0gdGhlIGFycmF5IGZvciBjb21wdXRlZCBhYnNvbHV0ZSB2YWx1ZXMuIElmIHN1cHBsaWVkLCBtdXN0IG1hdGNoIHRoZSBkaW1lbnNpb25zIGFuZCBkYXRhIHR5cGUgb2YgdGhlICoqYSoqIGFycmF5LlxuICovXG5KU0NvbnRleHQucHJvdG90eXBlLmFicyA9IGZ1bmN0aW9uKGEsIG91dCkge1xuXHRyZXR1cm4gdW5hcnlBcml0aE9wKGEsIG91dCwgdGhpcywganNtYXRoLmFicyk7XG59O1xuXG4vKipcbiAqIEV4cG9uZW50aWF0ZXMgYXJyYXkgZWxlbWVudHMuXG4gKlxuICogQG1ldGhvZCBleHBcbiAqIEBwYXJhbSB7TkRBcnJheX0gYSAtIHRoZSBhcnJheSBvZiBlbGVtZW50cyB0byBiZSBleHBvbmVudGlhdGVkLlxuICogQHBhcmFtIHtOREFycmF5fSBbb3V0XSAtIHRoZSBhcnJheSBmb3IgZXhwb25lbnRpYXRlZCBlbGVtZW50cy4gSWYgc3VwcGxpZWQsIG11c3QgbWF0Y2ggdGhlIGRpbWVuc2lvbnMgYW5kIGRhdGEgdHlwZSBvZiB0aGUgKiphKiogYXJyYXkuXG4gKi9cbkpTQ29udGV4dC5wcm90b3R5cGUuZXhwID0gZnVuY3Rpb24oYSwgb3V0KSB7XG5cdHJldHVybiB1bmFyeUFyaXRoT3AoYSwgb3V0LCB0aGlzLCBqc21hdGguZXhwKTtcbn07XG5cbi8qKlxuICogQ29tcHV0ZXMgbG9nYXJpdGhtIG9mIGFycmF5IGVsZW1lbnRzLlxuICpcbiAqIEBtZXRob2QgbG9nXG4gKiBAcGFyYW0ge05EQXJyYXl9IGEgLSB0aGUgYXJyYXkgb2YgaW5wdXQgZWxlbWVudHMuXG4gKiBAcGFyYW0ge05EQXJyYXl9IFtvdXRdIC0gdGhlIGFycmF5IGZvciBjb21wdXRlZCBsb2dhcml0aG0gdmFsdWVzLiBJZiBzdXBwbGllZCwgbXVzdCBtYXRjaCB0aGUgZGltZW5zaW9ucyBhbmQgZGF0YSB0eXBlIG9mIHRoZSAqKmEqKiBhcnJheS5cbiAqL1xuSlNDb250ZXh0LnByb3RvdHlwZS5sb2cgPSBmdW5jdGlvbihhLCBvdXQpIHtcblx0cmV0dXJuIHVuYXJ5QXJpdGhPcChhLCBvdXQsIHRoaXMsIGpzbWF0aC5sb2cpO1xufTtcblxuLyoqXG4gKiBDb21wdXRlcyBzcXVhcmUgcm9vdCBvZiBhcnJheSBlbGVtZW50cy5cbiAqXG4gKiBAbWV0aG9kIHNxcnRcbiAqIEBwYXJhbSB7TkRBcnJheX0gYSAtIHRoZSBhcnJheSBvZiBpbnB1dCBlbGVtZW50cy5cbiAqIEBwYXJhbSB7TkRBcnJheX0gW291dF0gLSB0aGUgYXJyYXkgZm9yIGNvbXB1dGVkIHNxdWFyZSByb290IHZhbHVlcy4gSWYgc3VwcGxpZWQsIG11c3QgbWF0Y2ggdGhlIGRpbWVuc2lvbnMgYW5kIGRhdGEgdHlwZSBvZiB0aGUgKiphKiogYXJyYXkuXG4gKi9cbkpTQ29udGV4dC5wcm90b3R5cGUuc3FydCA9IGZ1bmN0aW9uKGEsIG91dCkge1xuXHRyZXR1cm4gdW5hcnlBcml0aE9wKGEsIG91dCwgdGhpcywganNtYXRoLnNxcnQpO1xufTtcblxuLyoqXG4gKiBTcXVhcmVzIGFycmF5IGVsZW1lbnRzLlxuICpcbiAqIEBtZXRob2Qgc3F1YXJlXG4gKiBAcGFyYW0ge05EQXJyYXl9IGEgLSB0aGUgYXJyYXkgb2YgZWxlbWVudHMgdG8gYmUgc3F1YXJlZC5cbiAqIEBwYXJhbSB7TkRBcnJheX0gW291dF0gLSB0aGUgYXJyYXkgZm9yIHNxdWFyZWQgZWxlbWVudHMuIElmIHN1cHBsaWVkLCBtdXN0IG1hdGNoIHRoZSBkaW1lbnNpb25zIGFuZCBkYXRhIHR5cGUgb2YgdGhlICoqYSoqIGFycmF5LlxuICovXG5KU0NvbnRleHQucHJvdG90eXBlLnNxdWFyZSA9IGZ1bmN0aW9uKGEsIG91dCkge1xuXHRyZXR1cm4gdW5hcnlBcml0aE9wKGEsIG91dCwgdGhpcywganNtYXRoLnNxdWFyZSk7XG59O1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBkb3QgcHJvZHVjdCBvZiB0d28gTi1kaW1lbnNpb25hbCBhcnJheXMuXG4gKlxuICogQG1ldGhvZCBkb3RcbiAqIEBwYXJhbSB7TkRBcnJheX0gYSAtIHRoZSBmaXJzdCBpbnB1dCBhcnJheS5cbiAqIEBwYXJhbSB7TkRBcnJheX0gYiAtIHRoZSBzZWNvbmQgaW5wdXQgYXJyYXkuXG4gKiBAcGFyYW0ge05EQXJyYXl9IFtvdXRdIC0gdGhlIG91dHB1dCBhcnJheS4gSWYgc3VwcGxpZWQsIG11c3QgbWF0Y2ggdGhlIGRhdGEgdHlwZSBvZiAqKmEqKiBhbmQgKipiKiogYXJyYXlzIGFuZCBoYXZlIHRoZSBleHBlY3RlZCBzaGFwZS4gQ2FuIG5vdCBiZSB0aGUgc2FtZSBhcnJheSBhcyAqKmEqKiBvciAqKmIqKi5cbiAqIEByZXR1cm4ge05EQXJyYXl9IC0gdGhlIGFycmF5IHdpdGggdGhlIGRvdCBwcm9kdWN0IG9mICoqYSoqIGFuZCAqKmIqKi5cbiAqL1xuSlNDb250ZXh0LnByb3RvdHlwZS5kb3QgPSBmdW5jdGlvbihhLCBiLCBvdXQpIHtcblx0dXRpbC5jaGVja05EQXJyYXkoYSwgXCJhXCIpO1xuXHR1dGlsLmNoZWNrTkRBcnJheShiLCBcImJcIik7XG5cdHV0aWwuY2hlY2tEYXRhVHlwZXNDb21wYXRpYmlsaXR5KGEuZGF0YVR5cGUsIGIuZGF0YVR5cGUpO1xuXG5cdC8qIFRoZSBheGlzIG9mIGIgdXNlZCBpbiByZWR1Y3Rpb246IGF4aXMgMCBmb3IgMUQgYXJyYXksIHNlY29uZC10by1sYXN0IGF4aXMgZm9yIE5EIGFycmF5ICovXG5cdHZhciBhQXhpcyA9IE1hdGgubWF4KGEuc2hhcGUubGVuZ3RoIC0gMSwgMCk7XG5cdHZhciBiQXhpcyA9IE1hdGgubWF4KGIuc2hhcGUubGVuZ3RoIC0gMiwgMCk7XG5cdHZhciByZWR1Y3Rpb25EaW0gPSBhLnNoYXBlW2FBeGlzXTtcblx0aWYgKHJlZHVjdGlvbkRpbSAhPT0gYi5zaGFwZVtiQXhpc10pIHtcblx0XHR0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkFycmF5cyBoYXZlIGluY29tcGF0aWJsZSByZWR1Y3Rpb24gZGltZW5zaW9uc1wiKTtcblx0fVxuXHR2YXIgc2hhcGVPdXQgPSBbXSwgc3RyaWRlQSA9IDEsIG91dGVyU3RyaWRlQiA9IDEsIGlubmVyU3RyaWRlQiA9IDE7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgYUF4aXM7IGkrKykge1xuXHRcdHNoYXBlT3V0LnB1c2goYS5zaGFwZVtpXSk7XG5cdFx0c3RyaWRlQSAqPSBhLnNoYXBlW2ldO1xuXHR9XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgYi5zaGFwZS5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBkaW0gPSBiLnNoYXBlW2ldO1xuXHRcdGlmIChpIDwgYkF4aXMpIHtcblx0XHRcdG91dGVyU3RyaWRlQiAqPSBkaW07XG5cdFx0XHRzaGFwZU91dC5wdXNoKGRpbSk7XG5cdFx0fSBlbHNlIGlmIChpID4gYkF4aXMpIHtcblx0XHRcdGlubmVyU3RyaWRlQiAqPSBkaW07XG5cdFx0XHRzaGFwZU91dC5wdXNoKGRpbSk7XG5cdFx0fVxuXHR9XG5cdGlmICh0eXBlb2Ygb3V0ID09PSBcInVuZGVmaW5lZFwiKSB7XG5cdFx0b3V0ID0gdGhpcy5lbXB0eShzaGFwZU91dCwgYS5kYXRhVHlwZSk7XG5cdH0gZWxzZSBpZiAob3V0IGluc3RhbmNlb2YgTkRBcnJheSkge1xuXHRcdHV0aWwuY2hlY2tOREFycmF5KG91dCwgXCJvdXRcIik7XG5cdFx0dXRpbC5jaGVja1NoYXBlc0NvbXBhdGliaWxpdHkob3V0LnNoYXBlLCBzaGFwZU91dCk7XG5cdFx0dXRpbC5jaGVja0RhdGFUeXBlc0NvbXBhdGliaWxpdHkob3V0LmRhdGFUeXBlLCBhLmRhdGFUeXBlKTtcblx0XHR1dGlsLmNoZWNrRGlmZmVyZW50TkRBcnJheXMoYSwgb3V0LCBcImFcIiwgXCJvdXRcIik7XG5cdFx0dXRpbC5jaGVja0RpZmZlcmVudE5EQXJyYXlzKGIsIG91dCwgXCJiXCIsIFwib3V0XCIpO1xuXHRcdG91dC5faW5jUmVmKCk7XG5cdH1cblx0anNtYXRoLmRvdChhLl9kYXRhLCBiLl9kYXRhLCBvdXQuX2RhdGEsIHN0cmlkZUEsIG91dGVyU3RyaWRlQiwgaW5uZXJTdHJpZGVCLCByZWR1Y3Rpb25EaW0pO1xuXHRhLl90cnlSZWxlYXNlKCk7XG5cdGIuX3RyeVJlbGVhc2UoKTtcblx0cmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcml0aG1ldGljIHNlcXVlbmNlLlxuICpcbiAqIEBtZXRob2QgbGluc3BhY2VcbiAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydCAtIHRoZSBzdGFydGluZyBlbmRwb2ludCBvZiB0aGUgc2VxdWVuY2UuIE11c3QgYmUgYSBmaW5pdGUgbnVtYmVyLlxuICogQHBhcmFtIHtOdW1iZXJ9IHN0b3AgLSB0aGUgZmluYWwgZW5kcG9pbnQgb2YgdGhlIHNlcXVlbmNlLiBNdXN0IGJlIGEgZmluaXRlIG51bWJlci5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbc2FtcGxlcz01MF0gLSB0aGUgbnVtYmVyIG9mIHNhbXBsZXMgaW4gdGhlIHNlcXVlbmN5LiBNdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlci5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW2Nsb3NlZD10cnVlXSAtIGFuIGluZGljYXRvciBvZiB3aGV0aGVyIHRoZSBmaW5hbCBlbmRwb2ludCAoYHN0b3BgIGFyZ3VtZW50KSBzaG91bGQgYmUgaW5jbHVkZWQgaW4gdGhlIHNlcXVlbmNlLlxuICovXG5KU0NvbnRleHQucHJvdG90eXBlLmxpbnNwYWNlID0gZnVuY3Rpb24oc3RhcnQsIHN0b3AsIHNhbXBsZXMsIGNsb3NlZCkge1xuXHRpZiAoIXV0aWwuaXNSZWFsKHN0YXJ0KSkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3Ioc3RhcnQgKyBcIiBpcyBub3QgYSByZWFsIG51bWJlclwiKTtcblx0fVxuXHRpZiAoIXV0aWwuaXNSZWFsKHN0b3ApKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihzdG9wICsgXCIgaXMgbm90IGEgcmVhbCBudW1iZXJcIik7XG5cdH1cblx0aWYgKHR5cGVvZiBzYW1wbGVzID09PSBcInVuZGVmaW5lZFwiKSB7XG5cdFx0LyogRGVmYXVsdCB2YWx1ZSBpbiBOdW1QeSAqL1xuXHRcdHNhbXBsZXMgPSA1MDtcblx0fSBlbHNlIGlmICghdXRpbC5pc0ludChzYW1wbGVzKSkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3Ioc2FtcGxlcyArIFwiIGlzIG5vdCBhbiBpbnRlZ2VyXCIpO1xuXHR9IGVsc2UgaWYgKHNhbXBsZXMgPD0gMCkge1xuXHRcdHRocm93IG5ldyBSYW5nZUVycm9yKFwiVGhlIG51bWJlciBvZiBzYW1wbGVzIG11c3QgYmUgcG9zaXRpdmVcIik7XG5cdH1cblx0aWYgKHR5cGVvZiBjbG9zZWQgPT09IFwidW5kZWZpbmVkXCIpIHtcblx0XHRjbG9zZWQgPSB0cnVlO1xuXHR9XG5cdGlmIChjbG9zZWQgJiYgKHNhbXBsZXMgPT09IDEpKSB7XG5cdFx0dGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUaGUgbnVtYmVyIG9mIHNhbXBsZXMgbXVzdCBiZSBhIGxlYXN0IDIgKGZvciBzdGFydCBhbmQgZW5kIHBvaW50cylcIik7XG5cdH1cblx0dmFyIGFycmF5ID0gdGhpcy5lbXB0eShzYW1wbGVzLCBuZXcgRGF0YVR5cGUoXCJmNjRcIikpO1xuXHR2YXIgZGF0YSA9IGFycmF5Ll9kYXRhO1xuXHR2YXIgcmFuZ2UgPSBzdG9wIC0gc3RhcnQ7XG5cdHZhciBuID0gKGNsb3NlZCkgPyBzYW1wbGVzIC0gMSA6IHNhbXBsZXM7XG5cdHZhciBzdGVwID0gcmFuZ2UgLyBuO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IHNhbXBsZXM7IGkrKykge1xuXHRcdGRhdGFbaV0gPSBzdGFydCArIHN0ZXAgKiBpO1xuXHR9XG5cdHJldHVybiBhcnJheTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSlNDb250ZXh0O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBQQkNvbnRleHQgPSByZXF1aXJlKFwiLi8uLi9QQkNvbnRleHQuanNcIik7XG5cbmZ1bmN0aW9uIFdlYldvcmtlckNvbnRleHQob3B0aW9ucywgY2FsbGJhY2spIHtcblx0dmFyIHNlbGYgPSB0aGlzO1xuXHR0aGlzLl93b3JrZXIgPSBuZXcgV29ya2VyKFdlYldvcmtlckNvbnRleHQuZ2V0V29ya2VyVVJMKG9wdGlvbnMuYmFzZVVybCkpO1xuXHR0aGlzLl93b3JrZXIuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgZnVuY3Rpb24oZSkge1xuXHRcdHNlbGYuX21lc3NhZ2luZ0NvbnRleHQuX29uTWVzc2FnZShlKTtcblx0fSwgdHJ1ZSk7XG5cdHRoaXMuX21lc3NhZ2luZ0NvbnRleHQgPSBuZXcgUEJDb250ZXh0KG9wdGlvbnMsIGZ1bmN0aW9uKG1lc3NhZ2UpIHtcblx0XHRzZWxmLl93b3JrZXIucG9zdE1lc3NhZ2UobWVzc2FnZSwgW21lc3NhZ2VdKTtcblx0fSwgY2FsbGJhY2spO1xufVxuXG5XZWJXb3JrZXJDb250ZXh0LmlzU3VwcG9ydGVkID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0eXBlb2YgV29ya2VyICE9PSBcInVuZGVmaW5lZFwiO1xufTtcblxuV2ViV29ya2VyQ29udGV4dC5nZXRXb3JrZXJVUkwgPSBmdW5jdGlvbihiYXNlVXJsKSB7XG5cdGlmIChiYXNlVXJsKSB7XG5cdFx0cmV0dXJuIGJhc2VVcmwgKyBcImZ1cmlvdXMtd29ya2VyLm1pbi5qc1wiO1xuXHR9IGVsc2Uge1xuXHRcdHJldHVybiBcImZ1cmlvdXMtd29ya2VyLm1pbi5qc1wiO1xuXHR9XG59O1xuXG5XZWJXb3JrZXJDb250ZXh0LnByb3RvdHlwZS5lbXB0eSA9IGZ1bmN0aW9uKHNoYXBlLCBkYXRhVHlwZSkge1xuXHRyZXR1cm4gdGhpcy5fbWVzc2FnaW5nQ29udGV4dC5lbXB0eShzaGFwZSwgZGF0YVR5cGUpO1xufTtcblxuV2ViV29ya2VyQ29udGV4dC5wcm90b3R5cGUuemVyb3MgPSBmdW5jdGlvbihzaGFwZSwgZGF0YVR5cGUpIHtcblx0cmV0dXJuIHRoaXMuX21lc3NhZ2luZ0NvbnRleHQuemVyb3Moc2hhcGUsIGRhdGFUeXBlKTtcbn07XG5cbldlYldvcmtlckNvbnRleHQucHJvdG90eXBlLm9uZXMgPSBmdW5jdGlvbihzaGFwZSwgZGF0YVR5cGUpIHtcblx0cmV0dXJuIHRoaXMuX21lc3NhZ2luZ0NvbnRleHQub25lcyhzaGFwZSwgZGF0YVR5cGUpO1xufTtcblxuV2ViV29ya2VyQ29udGV4dC5wcm90b3R5cGUuYXJyYXkgPSBmdW5jdGlvbihkYXRhLCBkYXRhVHlwZSkge1xuXHRyZXR1cm4gdGhpcy5fbWVzc2FnaW5nQ29udGV4dC5hcnJheShkYXRhLCBkYXRhVHlwZSk7XG59O1xuXG5XZWJXb3JrZXJDb250ZXh0LnByb3RvdHlwZS5saW5zcGFjZSA9IGZ1bmN0aW9uKHN0YXJ0LCBzdG9wLCBzYW1wbGVzLCBjbG9zZWQpIHtcblx0cmV0dXJuIHRoaXMuX21lc3NhZ2luZ0NvbnRleHQubGluc3BhY2Uoc3RhcnQsIHN0b3AsIHNhbXBsZXMsIGNsb3NlZCk7XG59O1xuXG5XZWJXb3JrZXJDb250ZXh0LnByb3RvdHlwZS5yZXNoYXBlID0gZnVuY3Rpb24oYSwgc2hhcGUpIHtcblx0cmV0dXJuIHRoaXMuX21lc3NhZ2luZ0NvbnRleHQucmVzaGFwZShhLCBzaGFwZSk7XG59O1xuXG5XZWJXb3JrZXJDb250ZXh0LnByb3RvdHlwZS5yZXBlYXQgPSBmdW5jdGlvbihhLCByZXBlYXRzLCBheGlzLCBvdXQpIHtcblx0cmV0dXJuIHRoaXMuX21lc3NhZ2luZ0NvbnRleHQucmVwZWF0KGEsIHJlcGVhdHMsIGF4aXMsIG91dCk7XG59O1xuXG5XZWJXb3JrZXJDb250ZXh0LnByb3RvdHlwZS5faW52YWxpZGF0ZSA9IGZ1bmN0aW9uKGFycmF5KSB7XG5cdHJldHVybiB0aGlzLl9tZXNzYWdpbmdDb250ZXh0Ll9pbnZhbGlkYXRlKGFycmF5KTtcbn07XG5cbldlYldvcmtlckNvbnRleHQucHJvdG90eXBlLmZldGNoID0gZnVuY3Rpb24oKSB7XG5cdHRoaXMuX21lc3NhZ2luZ0NvbnRleHQuZmV0Y2guYXBwbHkodGhpcy5fbWVzc2FnaW5nQ29udGV4dCwgYXJndW1lbnRzKTtcbn07XG5cbldlYldvcmtlckNvbnRleHQucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKCkge1xuXHR0aGlzLl9tZXNzYWdpbmdDb250ZXh0LmdldC5hcHBseSh0aGlzLl9tZXNzYWdpbmdDb250ZXh0LCBhcmd1bWVudHMpO1xufTtcblxuV2ViV29ya2VyQ29udGV4dC5wcm90b3R5cGUuaW5mbyA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG5cdHRoaXMuX21lc3NhZ2luZ0NvbnRleHQuaW5mbyhjYWxsYmFjayk7XG59O1xuXG5XZWJXb3JrZXJDb250ZXh0LnByb3RvdHlwZS5iYXJyaWVyID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcblx0dGhpcy5fbWVzc2FnaW5nQ29udGV4dC5iYXJyaWVyKGNhbGxiYWNrKTtcbn07XG5cbldlYldvcmtlckNvbnRleHQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKGEsIGIsIG91dCkge1xuXHRyZXR1cm4gdGhpcy5fbWVzc2FnaW5nQ29udGV4dC5hZGQoYSwgYiwgb3V0KTtcbn07XG5cbldlYldvcmtlckNvbnRleHQucHJvdG90eXBlLnN1YiA9IGZ1bmN0aW9uKGEsIGIsIG91dCkge1xuXHRyZXR1cm4gdGhpcy5fbWVzc2FnaW5nQ29udGV4dC5zdWIoYSwgYiwgb3V0KTtcbn07XG5cbldlYldvcmtlckNvbnRleHQucHJvdG90eXBlLm11bCA9IGZ1bmN0aW9uKGEsIGIsIG91dCkge1xuXHRyZXR1cm4gdGhpcy5fbWVzc2FnaW5nQ29udGV4dC5tdWwoYSwgYiwgb3V0KTtcbn07XG5cbldlYldvcmtlckNvbnRleHQucHJvdG90eXBlLmRpdiA9IGZ1bmN0aW9uKGEsIGIsIG91dCkge1xuXHRyZXR1cm4gdGhpcy5fbWVzc2FnaW5nQ29udGV4dC5kaXYoYSwgYiwgb3V0KTtcbn07XG5cbldlYldvcmtlckNvbnRleHQucHJvdG90eXBlLm5lZyA9IGZ1bmN0aW9uKGEsIG91dCkge1xuXHRyZXR1cm4gdGhpcy5fbWVzc2FnaW5nQ29udGV4dC5uZWcoYSwgb3V0KTtcbn07XG5cbldlYldvcmtlckNvbnRleHQucHJvdG90eXBlLmFicyA9IGZ1bmN0aW9uKGEsIG91dCkge1xuXHRyZXR1cm4gdGhpcy5fbWVzc2FnaW5nQ29udGV4dC5hYnMoYSwgb3V0KTtcbn07XG5cbldlYldvcmtlckNvbnRleHQucHJvdG90eXBlLmV4cCA9IGZ1bmN0aW9uKGEsIG91dCkge1xuXHRyZXR1cm4gdGhpcy5fbWVzc2FnaW5nQ29udGV4dC5leHAoYSwgb3V0KTtcbn07XG5cbldlYldvcmtlckNvbnRleHQucHJvdG90eXBlLmxvZyA9IGZ1bmN0aW9uKGEsIG91dCkge1xuXHRyZXR1cm4gdGhpcy5fbWVzc2FnaW5nQ29udGV4dC5sb2coYSwgb3V0KTtcbn07XG5cbldlYldvcmtlckNvbnRleHQucHJvdG90eXBlLnNxcnQgPSBmdW5jdGlvbihhLCBvdXQpIHtcblx0cmV0dXJuIHRoaXMuX21lc3NhZ2luZ0NvbnRleHQuc3FydChhLCBvdXQpO1xufTtcblxuV2ViV29ya2VyQ29udGV4dC5wcm90b3R5cGUuc3F1YXJlID0gZnVuY3Rpb24oYSwgb3V0KSB7XG5cdHJldHVybiB0aGlzLl9tZXNzYWdpbmdDb250ZXh0LnNxdWFyZShhLCBvdXQpO1xufTtcblxuV2ViV29ya2VyQ29udGV4dC5wcm90b3R5cGUubWluID0gZnVuY3Rpb24oYSwgYXhpcykge1xuXHRyZXR1cm4gdGhpcy5fbWVzc2FnaW5nQ29udGV4dC5taW4oYSwgYXhpcyk7XG59O1xuXG5XZWJXb3JrZXJDb250ZXh0LnByb3RvdHlwZS5tYXggPSBmdW5jdGlvbihhLCBheGlzKSB7XG5cdHJldHVybiB0aGlzLl9tZXNzYWdpbmdDb250ZXh0Lm1heChhLCBheGlzKTtcbn07XG5cbldlYldvcmtlckNvbnRleHQucHJvdG90eXBlLnN1bSA9IGZ1bmN0aW9uKGEsIGF4aXMpIHtcblx0cmV0dXJuIHRoaXMuX21lc3NhZ2luZ0NvbnRleHQuc3VtKGEsIGF4aXMpO1xufTtcblxuV2ViV29ya2VyQ29udGV4dC5wcm90b3R5cGUuZG90ID0gZnVuY3Rpb24oYSwgYiwgb3V0KSB7XG5cdHJldHVybiB0aGlzLl9tZXNzYWdpbmdDb250ZXh0LmRvdChhLCBiLCBvdXQpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBXZWJXb3JrZXJDb250ZXh0O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogSmF2YVNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiBjb21wdXRhdGlvbmFsIG1ldGhvZHNcbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNsYXNzIEpTTWF0aFxuICovXG5cbi8qKlxuICogU2V0cyBhbGwgYXJyYXkgZWxlbWVudHMgdG8gdGhlIHNwZWNpZmllZCB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyVmlld30gZGF0YSAtIHRoZSBhcnJheSBkYXRhIGJ1ZmZlci5cbiAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIHRoZSBjb25zdGFudCB0byBmaWxsIHRoZSBidWZmZXIgd2l0aC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHN0YXRpY1xuICogQG1ldGhvZCBmaWxsXG4gKi9cbmV4cG9ydHMuZmlsbCA9IGZ1bmN0aW9uKGRhdGEsIHZhbHVlKSB7XG5cdHZhciBuID0gZGF0YS5sZW5ndGg7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKSB7XG5cdFx0ZGF0YVtpXSA9IHZhbHVlO1xuXHR9XG59O1xuXG4vKipcbiAqIEFkZHMgdHdvIGFycmF5cy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyVmlld30gZGF0YUEgLSB0aGUgaW5wdXQgYXVnZW5kIGFycmF5LlxuICogQHBhcmFtIHtBcnJheUJ1ZmZlclZpZXd9IGRhdGFCIC0gdGhlIGlucHV0IGFkZGVuZCBhcnJheS5cbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJWaWV3fSBkYXRhT3V0IC0gdGhlIG91dHB1dCBzdW0gYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgYWRkXG4gKi9cbmV4cG9ydHMuYWRkID0gZnVuY3Rpb24oZGF0YUEsIGRhdGFCLCBkYXRhT3V0KSB7XG5cdHZhciBuID0gZGF0YU91dC5sZW5ndGg7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKSB7XG5cdFx0ZGF0YU91dFtpXSA9IGRhdGFBW2ldICsgZGF0YUJbaV07XG5cdH1cbn07XG5cbi8qKlxuICogQWRkcyBhIGNvbnN0YW50IHRvIGFuIGFycmF5LlxuICpcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJWaWV3fSBkYXRhQSAtIHRoZSBpbnB1dCBhdWdlbmQgYXJyYXkuXG4gKiBAcGFyYW0ge051bWJlcn0gdmFsdWVCIC0gdGhlIGFkZGVuZCBjb25zdGFudC5cbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJWaWV3fSBkYXRhT3V0IC0gdGhlIG91dHB1dCBzdW0gYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgYWRkQ29uc3RcbiAqL1xuZXhwb3J0cy5hZGRDb25zdCA9IGZ1bmN0aW9uKGRhdGFBLCB2YWx1ZUIsIGRhdGFPdXQpIHtcblx0dmFyIG4gPSBkYXRhT3V0Lmxlbmd0aDtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpIHtcblx0XHRkYXRhT3V0W2ldID0gZGF0YUFbaV0gKyB2YWx1ZUI7XG5cdH1cbn07XG5cbi8qKlxuICogU3VidHJhY3RzIHR3byBhcnJheXMuXG4gKlxuICogQHBhcmFtIHtBcnJheUJ1ZmZlclZpZXd9IGRhdGFBIC0gdGhlIGlucHV0IG1pbnVlbmQgYXJyYXkuXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyVmlld30gZGF0YUIgLSB0aGUgaW5wdXQgc3VidHJhaGVuZCBhcnJheS5cbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJWaWV3fSBkYXRhT3V0IC0gdGhlIG91dHB1dCBkaWZmZXJlbmNlIGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIHN1YlxuICovXG5leHBvcnRzLnN1YiA9IGZ1bmN0aW9uKGRhdGFBLCBkYXRhQiwgZGF0YU91dCkge1xuXHR2YXIgbiA9IGRhdGFPdXQubGVuZ3RoO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSkge1xuXHRcdGRhdGFPdXRbaV0gPSBkYXRhQVtpXSAtIGRhdGFCW2ldO1xuXHR9XG59O1xuXG4vKipcbiAqIFN1YnRyYWN0cyBhIGNvbnN0YW50IGZyb20gYW4gYXJyYXkuXG4gKlxuICogQHBhcmFtIHtBcnJheUJ1ZmZlclZpZXd9IGRhdGFBIC0gdGhlIGlucHV0IG1pbnVlbmQgYXJyYXkuXG4gKiBAcGFyYW0ge051bWJlcn0gdmFsdWVCIC0gdGhlIHN1YnRyYWhlbmQgY29uc3RhbnQuXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyVmlld30gZGF0YU91dCAtIHRoZSBvdXRwdXQgZGlmZmVyZW5jZSBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHN0YXRpY1xuICogQG1ldGhvZCBzdWJDb25zdFxuICovXG5leHBvcnRzLnN1YkNvbnN0ID0gZnVuY3Rpb24oZGF0YUEsIHZhbHVlQiwgZGF0YU91dCkge1xuXHR2YXIgbiA9IGRhdGFPdXQubGVuZ3RoO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSkge1xuXHRcdGRhdGFPdXRbaV0gPSBkYXRhQVtpXSAtIHZhbHVlQjtcblx0fVxufTtcblxuLyoqXG4gKiBTdWJ0cmFjdHMgYW4gYXJyYXkgZnJvbSBhIGNvbnN0YW50LlxuICpcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJWaWV3fSBkYXRhQSAtIHRoZSBpbnB1dCBzdWJ0cmFoZW5kIGFycmF5LlxuICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlQiAtIHRoZSBtaW51ZW5kIGNvbnN0YW50LlxuICogQHBhcmFtIHtBcnJheUJ1ZmZlclZpZXd9IGRhdGFPdXQgLSB0aGUgb3V0cHV0IGRpZmZlcmVuY2UgYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2Qgc3ViUmV2Q29uc3RcbiAqL1xuZXhwb3J0cy5zdWJSZXZDb25zdCA9IGZ1bmN0aW9uKGRhdGFBLCB2YWx1ZUIsIGRhdGFPdXQpIHtcblx0dmFyIG4gPSBkYXRhT3V0Lmxlbmd0aDtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpIHtcblx0XHRkYXRhT3V0W2ldID0gdmFsdWVCIC0gZGF0YUFbaV07XG5cdH1cbn07XG5cbi8qKlxuICogTXVsdGlwbGllcyB0d28gYXJyYXlzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJWaWV3fSBkYXRhQSAtIHRoZSBpbnB1dCBtdWx0aXBsaWNhbmQgYXJyYXkuXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyVmlld30gZGF0YUIgLSB0aGUgaW5wdXQgbXVsdGlwbGllciBhcnJheS5cbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJWaWV3fSBkYXRhT3V0IC0gdGhlIG91dHB1dCBwcm9kdWN0IGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIG11bFxuICovXG5leHBvcnRzLm11bCA9IGZ1bmN0aW9uKGRhdGFBLCBkYXRhQiwgZGF0YU91dCkge1xuXHR2YXIgbiA9IGRhdGFPdXQubGVuZ3RoO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSkge1xuXHRcdGRhdGFPdXRbaV0gPSBkYXRhQVtpXSAqIGRhdGFCW2ldO1xuXHR9XG59O1xuXG4vKipcbiAqIE11bHRpcGxpZXMgYW4gYXJyYXkgYnkgYSBjb25zdGFudC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyVmlld30gZGF0YUEgLSB0aGUgaW5wdXQgbXVsdGlwbGljYW5kIGFycmF5LlxuICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlQiAtIHRoZSBtdWx0aXBsaWVyIGNvbnN0YW50LlxuICogQHBhcmFtIHtBcnJheUJ1ZmZlclZpZXd9IGRhdGFPdXQgLSB0aGUgb3V0cHV0IHByb2R1Y3QgYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgbXVsQ29uc3RcbiAqL1xuZXhwb3J0cy5tdWxDb25zdCA9IGZ1bmN0aW9uKGRhdGFBLCB2YWx1ZUIsIGRhdGFPdXQpIHtcblx0dmFyIG4gPSBkYXRhT3V0Lmxlbmd0aDtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpIHtcblx0XHRkYXRhT3V0W2ldID0gZGF0YUFbaV0gKiB2YWx1ZUI7XG5cdH1cbn07XG5cbi8qKlxuICogRGl2aWRlcyB0d28gYXJyYXlzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJWaWV3fSBkYXRhQSAtIHRoZSBpbnB1dCBkaXZpZGVuZCBhcnJheS5cbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJWaWV3fSBkYXRhQiAtIHRoZSBpbnB1dCBkaXZpc29yIGFycmF5LlxuICogQHBhcmFtIHtBcnJheUJ1ZmZlclZpZXd9IGRhdGFPdXQgLSB0aGUgb3V0cHV0IHF1b3RpZW50IGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIGRpdlxuICovXG5leHBvcnRzLmRpdiA9IGZ1bmN0aW9uKGRhdGFBLCBkYXRhQiwgZGF0YU91dCkge1xuXHR2YXIgbiA9IGRhdGFPdXQubGVuZ3RoO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSkge1xuXHRcdGRhdGFPdXRbaV0gPSBkYXRhQVtpXSAvIGRhdGFCW2ldO1xuXHR9XG59O1xuXG4vKipcbiAqIERpdmlkZXMgYW4gYXJyYXkgYnkgYSBjb25zdGFudC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyVmlld30gZGF0YUEgLSB0aGUgaW5wdXQgZGl2aWRlbmQgYXJyYXkuXG4gKiBAcGFyYW0ge051bWJlcn0gdmFsdWVCIC0gdGhlIGRpdmlzb3IgY29uc3RhbnQuXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyVmlld30gZGF0YU91dCAtIHRoZSBvdXRwdXQgcXVvdGllbnQgYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgZGl2Q29uc3RcbiAqL1xuZXhwb3J0cy5kaXZDb25zdCA9IGZ1bmN0aW9uKGRhdGFBLCB2YWx1ZUIsIGRhdGFPdXQpIHtcblx0dmFyIG4gPSBkYXRhT3V0Lmxlbmd0aDtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpIHtcblx0XHRkYXRhT3V0W2ldID0gZGF0YUFbaV0gLyB2YWx1ZUI7XG5cdH1cbn07XG5cbi8qKlxuICogRGl2aWRlcyBhIGNvbnN0YW50IGJ5IGFuIGFycmF5LlxuICpcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJWaWV3fSBkYXRhQSAtIHRoZSBpbnB1dCBkaXZpc29yIGFycmF5LlxuICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlQiAtIHRoZSBkaXZpZGVuZCBjb25zdGFudC5cbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJWaWV3fSBkYXRhT3V0IC0gdGhlIG91dHB1dCBxdW90aWVudCBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHN0YXRpY1xuICogQG1ldGhvZCBkaXZSZXZDb25zdFxuICovXG5leHBvcnRzLmRpdlJldkNvbnN0ID0gZnVuY3Rpb24oZGF0YUEsIHZhbHVlQiwgZGF0YU91dCkge1xuXHR2YXIgbiA9IGRhdGFPdXQubGVuZ3RoO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSkge1xuXHRcdGRhdGFPdXRbaV0gPSB2YWx1ZUIgLyBkYXRhQVtpXTtcblx0fVxufTtcblxuLyoqXG4gKiBOZWdhdGVzIGFuIGFycmF5LlxuICpcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJWaWV3fSBkYXRhQSAtIHRoZSBpbnB1dCBhcnJheS5cbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJWaWV3fSBkYXRhT3V0IC0gdGhlIG91dHB1dCBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHN0YXRpY1xuICogQG1ldGhvZCBuZWdcbiAqL1xuZXhwb3J0cy5uZWcgPSBmdW5jdGlvbihkYXRhQSwgZGF0YU91dCkge1xuXHR2YXIgbiA9IGRhdGFPdXQubGVuZ3RoO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSkge1xuXHRcdGRhdGFPdXRbaV0gPSAtZGF0YUFbaV07XG5cdH1cbn07XG5cbi8qKlxuICogQ29tcHV0ZXMgYWJzb2x1dGUgdmFsdWUgb2YgYXJyYXkgZWxlbWVudHMuXG4gKlxuICogQHBhcmFtIHtBcnJheUJ1ZmZlclZpZXd9IGRhdGFBIC0gdGhlIGlucHV0IGFycmF5LlxuICogQHBhcmFtIHtBcnJheUJ1ZmZlclZpZXd9IGRhdGFPdXQgLSB0aGUgb3V0cHV0IGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIGFic1xuICovXG5leHBvcnRzLmFicyA9IGZ1bmN0aW9uKGRhdGFBLCBkYXRhT3V0KSB7XG5cdHZhciBuID0gZGF0YU91dC5sZW5ndGg7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKSB7XG5cdFx0ZGF0YU91dFtpXSA9IE1hdGguYWJzKGRhdGFBW2ldKTtcblx0fVxufTtcblxuLyoqXG4gKiBFeHBvbmVudGlhdGVzIGFycmF5IGVsZW1lbnRzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJWaWV3fSBkYXRhQSAtIHRoZSBpbnB1dCBhcnJheS5cbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJWaWV3fSBkYXRhT3V0IC0gdGhlIG91dHB1dCBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHN0YXRpY1xuICogQG1ldGhvZCBleHBcbiAqL1xuZXhwb3J0cy5leHAgPSBmdW5jdGlvbihkYXRhQSwgZGF0YU91dCkge1xuXHR2YXIgbiA9IGRhdGFPdXQubGVuZ3RoO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSkge1xuXHRcdGRhdGFPdXRbaV0gPSBNYXRoLmV4cChkYXRhQVtpXSk7XG5cdH1cbn07XG5cbi8qKlxuICogQ29tcHV0ZXMgbG9nYXJpdGhtIG9mIGFycmF5IGVsZW1lbnRzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJWaWV3fSBkYXRhQSAtIHRoZSBpbnB1dCBhcnJheS5cbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJWaWV3fSBkYXRhT3V0IC0gdGhlIG91dHB1dCBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHN0YXRpY1xuICogQG1ldGhvZCBsb2dcbiAqL1xuZXhwb3J0cy5sb2cgPSBmdW5jdGlvbihkYXRhQSwgZGF0YU91dCkge1xuXHR2YXIgbiA9IGRhdGFPdXQubGVuZ3RoO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSkge1xuXHRcdGRhdGFPdXRbaV0gPSBNYXRoLmxvZyhkYXRhQVtpXSk7XG5cdH1cbn07XG5cbi8qKlxuICogQ29tcHV0ZXMgc3F1YXJlIHJvb3Qgb2YgYXJyYXkgZWxlbWVudHMuXG4gKlxuICogQHBhcmFtIHtBcnJheUJ1ZmZlclZpZXd9IGRhdGFBIC0gdGhlIGlucHV0IGFycmF5LlxuICogQHBhcmFtIHtBcnJheUJ1ZmZlclZpZXd9IGRhdGFPdXQgLSB0aGUgb3V0cHV0IGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIHNxcnRcbiAqL1xuZXhwb3J0cy5zcXJ0ID0gZnVuY3Rpb24oZGF0YUEsIGRhdGFPdXQpIHtcblx0dmFyIG4gPSBkYXRhT3V0Lmxlbmd0aDtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpIHtcblx0XHRkYXRhT3V0W2ldID0gTWF0aC5zcXJ0KGRhdGFBW2ldKTtcblx0fVxufTtcblxuLyoqXG4gKiBTcXVhcmVzIGFycmF5IGVsZW1lbnRzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJWaWV3fSBkYXRhQSAtIHRoZSBpbnB1dCBhcnJheS5cbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJWaWV3fSBkYXRhT3V0IC0gdGhlIG91dHB1dCBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHN0YXRpY1xuICogQG1ldGhvZCBzcXVhcmVcbiAqL1xuZXhwb3J0cy5zcXVhcmUgPSBmdW5jdGlvbihkYXRhQSwgZGF0YU91dCkge1xuXHR2YXIgbiA9IGRhdGFPdXQubGVuZ3RoO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSkge1xuXHRcdHZhciBhID0gZGF0YUFbaV07XG5cdFx0ZGF0YU91dFtpXSA9IGEgKiBhO1xuXHR9XG59O1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBtaW5pbXVtIHZhbHVlIG9mIGVsZW1lbnRzIGluIGFuIGFycmF5LlxuICpcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJWaWV3fSBkYXRhQSAtIHRoZSBpbnB1dCBhcnJheSB0byBjb21wdXRlIG1pbmltdW0gb24uXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyVmlld30gZGF0YU91dCAtIHRoZSBvdXRwdXQgYXJyYXkgdG8gc3RvcmUgdGhlIG1pbmltdW0gYXQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgbWluXG4gKi9cbmV4cG9ydHMubWluID0gZnVuY3Rpb24oZGF0YUEsIGRhdGFPdXQpIHtcblx0LyogQ29tcHV0YXRpb24gb2YgYWxsLWFycmF5IG1pbiAqL1xuXHR2YXIgbGVuZ3RoQSA9IGRhdGFBLmxlbmd0aDtcblx0dmFyIHJlc3VsdCA9IGRhdGFBWzBdO1xuXHRmb3IgKHZhciBpID0gMTsgaSA8IGxlbmd0aEE7ICsraSkge1xuXHRcdHJlc3VsdCA9IE1hdGgubWluKHJlc3VsdCwgZGF0YUFbaV0pO1xuXHR9XG5cdGRhdGFPdXRbMF0gPSByZXN1bHQ7XG59O1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBtYXhpbXVtIHZhbHVlIG9mIGVsZW1lbnRzIGluIGFuIGFycmF5LlxuICpcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJWaWV3fSBkYXRhQSAtIHRoZSBpbnB1dCBhcnJheSB0byBjb21wdXRlIG1heGltdW0gb24uXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyVmlld30gZGF0YU91dCAtIHRoZSBvdXRwdXQgYXJyYXkgdG8gc3RvcmUgdGhlIG1heGltdW0gYXQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgbWF4XG4gKi9cbmV4cG9ydHMubWF4ID0gZnVuY3Rpb24oZGF0YUEsIGRhdGFPdXQpIHtcblx0LyogQ29tcHV0YXRpb24gb2YgYWxsLWFycmF5IG1pbiAqL1xuXHR2YXIgbGVuZ3RoQSA9IGRhdGFBLmxlbmd0aDtcblx0dmFyIHJlc3VsdCA9IGRhdGFBWzBdO1xuXHRmb3IgKHZhciBpID0gMTsgaSA8IGxlbmd0aEE7ICsraSkge1xuXHRcdHJlc3VsdCA9IE1hdGgubWF4KHJlc3VsdCwgZGF0YUFbaV0pO1xuXHR9XG5cdGRhdGFPdXRbMF0gPSByZXN1bHQ7XG59O1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBzdW0gb2YgZWxlbWVudHMgaW4gYW4gYXJyYXkuXG4gKlxuICogQHBhcmFtIHtBcnJheUJ1ZmZlclZpZXd9IGRhdGFBIC0gdGhlIGlucHV0IGFycmF5IHdpdGggZWxlbWVudHMgdG8gc3VtIHVwLlxuICogQHBhcmFtIHtBcnJheUJ1ZmZlclZpZXd9IGRhdGFPdXQgLSB0aGUgb3V0cHV0IGFycmF5IHRvIHN0b3JlIHRoZSBzdW0gYXQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgbWluXG4gKi9cbmV4cG9ydHMuc3VtID0gZnVuY3Rpb24oZGF0YUEsIGRhdGFPdXQpIHtcblx0dmFyIGxlbmd0aEEgPSBkYXRhQS5sZW5ndGg7XG5cdHZhciByZXN1bHQgPSAwLjA7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoQTsgKytpKSB7XG5cdFx0cmVzdWx0ICs9IGRhdGFBW2ldO1xuXHR9XG5cdGRhdGFPdXRbMF0gPSByZXN1bHQ7XG59O1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBtaW5pbXVtIHZhbHVlIG9mIGVsZW1lbnRzIGFsb25nIGFuIGF4aXMuXG4gKlxuICogQHBhcmFtIHtBcnJheUJ1ZmZlclZpZXd9IGRhdGFBIC0gdGhlIGlucHV0IGFycmF5IHRvIGNvbXB1dGUgbWluaW1hIG9uLlxuICogQHBhcmFtIHtBcnJheUJ1ZmZlclZpZXd9IGRhdGFPdXQgLSB0aGUgb3V0cHV0IGFycmF5IHRvIHN0b3JlIHRoZSBtaW5pbWEgYXQuXG4gKiBAcGFyYW0ge051bWJlcn0gb3V0ZXJTdHJpZGUgLSB0aGUgcHJvZHVjdCBvZiBpbnB1dCBhcnJheSBkaW1lbnNpb25zIHByZWNlZWRpbmcgdGhlIHJlZHVjdGlvbiBkaW1lbnNpb24uXG4gKiBAcGFyYW0ge051bWJlcn0gaW5uZXJTdHJpZGUgLSB0aGUgcHJvZHVjdCBvZiBpbnB1dCBhcnJheSBkaW1lbnNpb25zIGZvbGxvd2luZyB0aGUgcmVkdWN0aW9uIGRpbWVuc2lvbi5cbiAqIEBwYXJhbSB7TnVtYmVyfSByZWR1Y3Rpb25EaW0gLSB0aGUgbGVuZ3RoIG9mIGlucHV0IGFycmF5IGFsb25nIHRoZSByZWR1Y3Rpb24gZGltZW5zaW9uLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIGF4aXNNaW5cbiAqL1xuZXhwb3J0cy5heGlzTWluID0gZnVuY3Rpb24oZGF0YUEsIGRhdGFPdXQsIG91dGVyU3RyaWRlLCBpbm5lclN0cmlkZSwgcmVkdWN0aW9uRGltKSB7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgb3V0ZXJTdHJpZGU7ICsraSkge1xuXHRcdGZvciAodmFyIGsgPSAwOyBrIDwgaW5uZXJTdHJpZGU7ICsraykge1xuXHRcdFx0dmFyIG9mZnNldCA9IGkgKiByZWR1Y3Rpb25EaW0gKiBpbm5lclN0cmlkZSArIGs7XG5cdFx0XHR2YXIgY3VycmVudE1pbiA9IGRhdGFBW29mZnNldF07XG5cdFx0XHRmb3IgKHZhciBqID0gMTsgaiA8IHJlZHVjdGlvbkRpbTsgKytqKSB7XG5cdFx0XHRcdG9mZnNldCArPSBpbm5lclN0cmlkZTtcblx0XHRcdFx0Y3VycmVudE1pbiA9IE1hdGgubWluKGN1cnJlbnRNaW4sIGRhdGFBW29mZnNldF0pO1xuXHRcdFx0fVxuXHRcdFx0ZGF0YU91dFtpICogaW5uZXJTdHJpZGUgKyBrXSA9IGN1cnJlbnRNaW47XG5cdFx0fVxuXHR9XG59O1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBtYXhpbXVtIHZhbHVlIG9mIGVsZW1lbnRzIGFsb25nIGFuIGF4aXMuXG4gKlxuICogQHBhcmFtIHtBcnJheUJ1ZmZlclZpZXd9IGRhdGFBIC0gdGhlIGlucHV0IGFycmF5IHRvIGNvbXB1dGUgbWF4aW1hIG9uLlxuICogQHBhcmFtIHtBcnJheUJ1ZmZlclZpZXd9IGRhdGFPdXQgLSB0aGUgb3V0cHV0IGFycmF5IHRvIHN0b3JlIHRoZSBtYXhpbWEgYXQuXG4gKiBAcGFyYW0ge051bWJlcn0gb3V0ZXJTdHJpZGUgLSB0aGUgcHJvZHVjdCBvZiBpbnB1dCBhcnJheSBkaW1lbnNpb25zIHByZWNlZWRpbmcgdGhlIHJlZHVjdGlvbiBkaW1lbnNpb24uXG4gKiBAcGFyYW0ge051bWJlcn0gaW5uZXJTdHJpZGUgLSB0aGUgcHJvZHVjdCBvZiBpbnB1dCBhcnJheSBkaW1lbnNpb25zIGZvbGxvd2luZyB0aGUgcmVkdWN0aW9uIGRpbWVuc2lvbi5cbiAqIEBwYXJhbSB7TnVtYmVyfSByZWR1Y3Rpb25EaW0gLSB0aGUgbGVuZ3RoIG9mIGlucHV0IGFycmF5IGFsb25nIHRoZSByZWR1Y3Rpb24gZGltZW5zaW9uLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIGF4aXNNYXhcbiAqL1xuZXhwb3J0cy5heGlzTWF4ID0gZnVuY3Rpb24oZGF0YUEsIGRhdGFPdXQsIG91dGVyU3RyaWRlLCBpbm5lclN0cmlkZSwgcmVkdWN0aW9uRGltKSB7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgb3V0ZXJTdHJpZGU7ICsraSkge1xuXHRcdGZvciAodmFyIGsgPSAwOyBrIDwgaW5uZXJTdHJpZGU7ICsraykge1xuXHRcdFx0dmFyIG9mZnNldCA9IGkgKiByZWR1Y3Rpb25EaW0gKiBpbm5lclN0cmlkZSArIGs7XG5cdFx0XHR2YXIgY3VycmVudE1heCA9IGRhdGFBW29mZnNldF07XG5cdFx0XHRmb3IgKHZhciBqID0gMTsgaiA8IHJlZHVjdGlvbkRpbTsgKytqKSB7XG5cdFx0XHRcdG9mZnNldCArPSBpbm5lclN0cmlkZTtcblx0XHRcdFx0Y3VycmVudE1heCA9IE1hdGgubWF4KGN1cnJlbnRNYXgsIGRhdGFBW29mZnNldF0pO1xuXHRcdFx0fVxuXHRcdFx0ZGF0YU91dFtpICogaW5uZXJTdHJpZGUgKyBrXSA9IGN1cnJlbnRNYXg7XG5cdFx0fVxuXHR9XG59O1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBzdW0gb2YgZWxlbWVudHMgYWxvbmcgYW4gYXhpcy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyVmlld30gZGF0YUEgLSB0aGUgaW5wdXQgYXJyYXkgdG8gc3VtIHVwLlxuICogQHBhcmFtIHtBcnJheUJ1ZmZlclZpZXd9IGRhdGFPdXQgLSB0aGUgb3V0cHV0IGFycmF5IHRvIHN0b3JlIHRoZSBzdW1zIGF0LlxuICogQHBhcmFtIHtOdW1iZXJ9IG91dGVyU3RyaWRlIC0gdGhlIHByb2R1Y3Qgb2YgaW5wdXQgYXJyYXkgZGltZW5zaW9ucyBwcmVjZWVkaW5nIHRoZSByZWR1Y3Rpb24gZGltZW5zaW9uLlxuICogQHBhcmFtIHtOdW1iZXJ9IGlubmVyU3RyaWRlIC0gdGhlIHByb2R1Y3Qgb2YgaW5wdXQgYXJyYXkgZGltZW5zaW9ucyBmb2xsb3dpbmcgdGhlIHJlZHVjdGlvbiBkaW1lbnNpb24uXG4gKiBAcGFyYW0ge051bWJlcn0gcmVkdWN0aW9uRGltIC0gdGhlIGxlbmd0aCBvZiBpbnB1dCBhcnJheSBhbG9uZyB0aGUgcmVkdWN0aW9uIGRpbWVuc2lvbi5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHN0YXRpY1xuICogQG1ldGhvZCBheGlzU3VtXG4gKi9cbmV4cG9ydHMuYXhpc1N1bSA9IGZ1bmN0aW9uKGRhdGFBLCBkYXRhT3V0LCBvdXRlclN0cmlkZSwgaW5uZXJTdHJpZGUsIHJlZHVjdGlvbkRpbSkge1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IG91dGVyU3RyaWRlOyArK2kpIHtcblx0XHRmb3IgKHZhciBrID0gMDsgayA8IGlubmVyU3RyaWRlOyArK2spIHtcblx0XHRcdHZhciBvZmZzZXQgPSBpICogcmVkdWN0aW9uRGltICogaW5uZXJTdHJpZGUgKyBrO1xuXHRcdFx0dmFyIGN1cnJlbnRTdW0gPSBkYXRhQVtvZmZzZXRdO1xuXHRcdFx0Zm9yICh2YXIgaiA9IDE7IGogPCByZWR1Y3Rpb25EaW07ICsraikge1xuXHRcdFx0XHRvZmZzZXQgKz0gaW5uZXJTdHJpZGU7XG5cdFx0XHRcdGN1cnJlbnRTdW0gKz0gZGF0YUFbb2Zmc2V0XTtcblx0XHRcdH1cblx0XHRcdGRhdGFPdXRbaSAqIGlubmVyU3RyaWRlICsga10gPSBjdXJyZW50U3VtO1xuXHRcdH1cblx0fVxufTtcblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgZG90IHByb2R1Y3Qgb2YgdHdvIE4tZGltZW5zaW9uYWwgYXJyYXlzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJWaWV3fSBkYXRhQSAtIGFuIGlucHV0IG11bHRpcGxpY2FuZCBhcnJheS5cbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJWaWV3fSBkYXRhQiAtIGFuIGlucHV0IG11bHRpcGxpZXIgYXJyYXkuXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyVmlld30gZGF0YU91dCAtIHRoZSBvdXRwdXQgcHJvZHVjdCBhcnJheS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBzdHJpZGVBIC0gdGhlIHByb2R1Y3Qgb2YgdGhlIHRoZSBtdWx0aXBsaWNhbmQgZGltZW5zaW9ucyBwcmVjZWVkaW5nIHRoZSByZWR1Y3Rpb24gZGltZW5zaW9uLlxuICogQHBhcmFtIHtOdW1iZXJ9IG91dGVyU3RyaWRlQiAtIHRoZSBwcm9kdWN0IG9mIHRoZSBtdWx0aXBsaWVyIGRpbWVuc2lvbnMgcHJlY2VlZGluZyB0aGUgcmVkdWN0aW9uIGRpbWVuc2lvbi5cbiAqIEBwYXJhbSB7TnVtYmVyfSBpbm5lclN0cmlkZUIgLSB0aGUgcHJvZHVjdCBvZiB0aGUgbXVsdGlwbGllciBkaW1lbnNpb25zIGZvbGxvd2luZyB0aGUgcmVkdWN0aW9uIGRpbWVuc2lvbi5cbiAqIEBwYXJhbSB7TnVtYmVyfSByZWR1Y3Rpb25EaW0gLSB0aGUgbGVuZ3RoIG9mIGlucHV0cyBhcnJheXMgYWxvbmcgdGhlIHJlZHVjdGlvbiBkaW1lbnNpb24uXG4gKlxuICogQHByaXZhdGVcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgZG90XG4gKi9cbmV4cG9ydHMuZG90ID0gZnVuY3Rpb24oZGF0YUEsIGRhdGFCLCBkYXRhT3V0LCBzdHJpZGVBLCBvdXRlclN0cmlkZUIsIGlubmVyU3RyaWRlQiwgcmVkdWN0aW9uRGltKSB7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgc3RyaWRlQTsgKytpKSB7XG5cdFx0Zm9yICh2YXIgaiA9IDA7IGogPCByZWR1Y3Rpb25EaW07ICsraikge1xuXHRcdFx0Zm9yICh2YXIgayA9IDA7IGsgPCBvdXRlclN0cmlkZUI7ICsraykge1xuXHRcdFx0XHRmb3IgKHZhciBsID0gMDsgbCA8IGlubmVyU3RyaWRlQjsgKytsKSB7XG5cdFx0XHRcdFx0ZGF0YU91dFsoaSpvdXRlclN0cmlkZUIgKyBrKSAqIGlubmVyU3RyaWRlQiArIGxdICs9IGRhdGFBW2kqcmVkdWN0aW9uRGltK2pdICogZGF0YUJbKGsqcmVkdWN0aW9uRGltK2opKmlubmVyU3RyaWRlQitsXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufTtcblxuLyoqXG4gKiBSZXBsaWNhdGVzIGFycmF5IGVsZW1lbnRzIGFsb25nIGFuIGF4aXMuXG4gKlxuICogQHBhcmFtIHtBcnJheUJ1ZmZlclZpZXd9IGRhdGFBIC0gdGhlIGlucHV0IGFycmF5LlxuICogQHBhcmFtIHtBcnJheUJ1ZmZlclZpZXd9IGRhdGFPdXQgLSB0aGUgb3V0cHV0IGFycmF5IGZvciByZXBlYXRlZCBlbGVtZW50cy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBvdXRlclN0cmlkZSAtIHRoZSBwcm9kdWN0IG9mIGlucHV0IGFycmF5IGRpbWVuc2lvbnMgcHJlY2VlZGluZyB0aGUgZXhwYW5zaW9uIGRpbWVuc2lvbi5cbiAqIEBwYXJhbSB7TnVtYmVyfSBpbm5lclN0cmlkZSAtIHRoZSBwcm9kdWN0IG9mIGlucHV0IGFycmF5IGRpbWVuc2lvbnMgZm9sbG93aW5nIHRoZSBleHBhbnNpb24gZGltZW5zaW9uLlxuICogQHBhcmFtIHtOdW1iZXJ9IGV4cGFuc2lvbkRpbSAtIHRoZSBsZW5ndGggb2YgaW5wdXQgYXJyYXkgYWxvbmcgdGhlIGV4cGFuc2lvbiBkaW1lbnNpb24uXG4gKiBAcGFyYW0ge051bWJlcn0gcmVwZWF0cyAtIHRoZSBudW1iZXIgb2YgdGltZXMgZWFjaCBlbGVtZW50IHdpbGwgYmUgcmVwbGljYXRlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHN0YXRpY1xuICogQG1ldGhvZCByZXBlYXRcbiAqL1xuZXhwb3J0cy5yZXBlYXQgPSBmdW5jdGlvbihkYXRhQSwgZGF0YU91dCwgb3V0ZXJTdHJpZGUsIGlubmVyU3RyaWRlLCBleHBhbnNpb25EaW0sIHJlcGVhdHMpIHtcblx0aWYgKGlubmVyU3RyaWRlIDwgcmVwZWF0cykge1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgb3V0ZXJTdHJpZGU7ICsraSkge1xuXHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBleHBhbnNpb25EaW07ICsraikge1xuXHRcdFx0XHRmb3IgKHZhciBrID0gMDsgayA8IGlubmVyU3RyaWRlOyArK2spIHtcblx0XHRcdFx0XHR2YXIgdmFsdWVBID0gZGF0YUFbKGkgKiBleHBhbnNpb25EaW0gKyBqKSAqIGlubmVyU3RyaWRlICsga107XG5cdFx0XHRcdFx0Zm9yICh2YXIgYyA9IDA7IGMgPCByZXBlYXRzOyArK2MpIHtcblx0XHRcdFx0XHRcdGRhdGFPdXRbKChpICogZXhwYW5zaW9uRGltICsgaikgKiByZXBlYXRzICsgYykgKiBpbm5lclN0cmlkZSArIGtdID0gdmFsdWVBO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG91dGVyU3RyaWRlOyArK2kpIHtcblx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgZXhwYW5zaW9uRGltOyArK2opIHtcblx0XHRcdFx0dmFyIHJvd0EgPSBkYXRhQS5zdWJhcnJheSgoaSAqIGV4cGFuc2lvbkRpbSArIGopICogaW5uZXJTdHJpZGUsIChpICogZXhwYW5zaW9uRGltICsgaiArIDEpICogaW5uZXJTdHJpZGUpO1xuXHRcdFx0XHRmb3IgKHZhciBjID0gMDsgYyA8IHJlcGVhdHM7ICsrYykge1xuXHRcdFx0XHRcdGRhdGFPdXQuc2V0KHJvd0EsICgoaSAqIGV4cGFuc2lvbkRpbSArIGopICogcmVwZWF0cyArIGMpICogaW5uZXJTdHJpZGUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59O1xuIiwiXG52YXIgcHJvdG9idWZqcyA9IHJlcXVpcmUoXCJwcm90b2J1ZmpzXCIpO1xucHJvdG9idWZqcy5jb252ZXJ0RmllbGRzVG9DYW1lbENhc2UgPSB0cnVlO1xudmFyIHJlcXVlc3RzUHJvdG8gPSBcInBhY2thZ2UgZnVyaW91cztcXG5cXG5vcHRpb24gb3B0aW1pemVfZm9yID0gTElURV9SVU5USU1FO1xcblxcbmVudW0gRGF0YVR5cGUge1xcblxcdEZMT0FUNjQgPSAwO1xcblxcdEZMT0FUMzIgPSAxO1xcbn1cXG5cXG5tZXNzYWdlIFJlcXVlc3Qge1xcblxcdGVudW0gVHlwZSB7XFxuXFx0XFx0RU1QVFlfQVJSQVkgICAgICAgICAgICAgID0gIDA7XFxuXFx0XFx0REFUQV9BUlJBWSAgICAgICAgICAgICAgID0gIDE7XFxuXFx0XFx0Q09OU1RfQVJSQVkgICAgICAgICAgICAgID0gIDI7XFxuXFx0XFx0TElOU1BBQ0UgICAgICAgICAgICAgICAgID0gIDM7XFxuXFx0XFx0UkVTSEFQRSAgICAgICAgICAgICAgICAgID0gIDQ7XFxuXFx0XFx0UkVQRUFUICAgICAgICAgICAgICAgICAgID0gIDU7XFxuXFx0XFx0REVBTExPQ0FURSAgICAgICAgICAgICAgID0gIDY7XFxuXFx0XFx0RkVUQ0ggICAgICAgICAgICAgICAgICAgID0gIDc7XFxuXFx0XFx0QkFSUklFUiAgICAgICAgICAgICAgICAgID0gIDg7XFxuXFx0XFx0SU5GTyAgICAgICAgICAgICAgICAgICAgID0gIDk7XFxuXFx0XFx0QklOQVJZX09QRVJBVElPTiAgICAgICAgID0gMTA7XFxuXFx0XFx0QklOQVJZX0NPTlNUX09QRVJBVElPTiAgID0gMTE7XFxuXFx0XFx0VU5BUllfT1BFUkFUSU9OICAgICAgICAgID0gMTI7XFxuXFx0XFx0UkVEVUNUSU9OX09QRVJBVElPTiAgICAgID0gMTM7XFxuXFx0XFx0QVhJU19SRURVQ1RJT05fT1BFUkFUSU9OID0gMTQ7XFxuXFx0XFx0RE9UX09QRVJBVElPTiAgICAgICAgICAgID0gMTU7XFxuXFx0fVxcblxcdHJlcXVpcmVkIGZpeGVkMzIgICAgICAgICAgICAgICAgICAgICBpZCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAgMTtcXG5cXHRyZXF1aXJlZCBUeXBlICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSAgICAgICAgICAgICAgICAgICAgICAgICAgID0gIDI7XFxuXFxuXFx0b3B0aW9uYWwgRW1wdHlBcnJheVJlcXVlc3QgICAgICAgICAgIGVtcHR5X2FycmF5X3JlcXVlc3QgICAgICAgICAgICA9ICAzO1xcblxcdG9wdGlvbmFsIERhdGFBcnJheVJlcXVlc3QgICAgICAgICAgICBkYXRhX2FycmF5X3JlcXVlc3QgICAgICAgICAgICAgPSAgNDtcXG5cXHRvcHRpb25hbCBDb25zdEFycmF5UmVxdWVzdCAgICAgICAgICAgY29uc3RfYXJyYXlfcmVxdWVzdCAgICAgICAgICAgID0gIDU7XFxuXFx0b3B0aW9uYWwgTGluc3BhY2VSZXF1ZXN0ICAgICAgICAgICAgIGxpbnNwYWNlX3JlcXVlc3QgICAgICAgICAgICAgICA9ICA2O1xcblxcdG9wdGlvbmFsIFJlc2hhcGVSZXF1ZXN0ICAgICAgICAgICAgICByZXNoYXBlX3JlcXVlc3QgICAgICAgICAgICAgICAgPSAgNztcXG5cXHRvcHRpb25hbCBSZXBlYXRSZXF1ZXN0ICAgICAgICAgICAgICAgcmVwZWF0X3JlcXVlc3QgICAgICAgICAgICAgICAgID0gIDg7XFxuXFx0b3B0aW9uYWwgRGVhbGxvY2F0ZVJlcXVlc3QgICAgICAgICAgIGRlYWxsb2NhdGVfcmVxdWVzdCAgICAgICAgICAgICA9ICA5O1xcblxcdG9wdGlvbmFsIEZldGNoUmVxdWVzdCAgICAgICAgICAgICAgICBmZXRjaF9yZXF1ZXN0ICAgICAgICAgICAgICAgICAgPSAxMDtcXG5cXHRvcHRpb25hbCBCaW5hcnlPcGVyYXRpb25SZXF1ZXN0ICAgICAgYmluYXJ5X29wZXJhdGlvbl9yZXF1ZXN0ICAgICAgID0gMTE7XFxuXFx0b3B0aW9uYWwgQmluYXJ5Q29uc3RPcGVyYXRpb25SZXF1ZXN0IGJpbmFyeV9jb25zdF9vcGVyYXRpb25fcmVxdWVzdCA9IDEyO1xcblxcdG9wdGlvbmFsIFVuYXJ5T3BlcmF0aW9uUmVxdWVzdCAgICAgICB1bmFyeV9vcGVyYXRpb25fcmVxdWVzdCAgICAgICAgPSAxMztcXG5cXHRvcHRpb25hbCBSZWR1Y3Rpb25SZXF1ZXN0ICAgICAgICAgICAgcmVkdWN0aW9uX3JlcXVlc3QgICAgICAgICAgICAgID0gMTQ7XFxuXFx0b3B0aW9uYWwgQXhpc1JlZHVjdGlvblJlcXVlc3QgICAgICAgIGF4aXNfcmVkdWN0aW9uX3JlcXVlc3QgICAgICAgICA9IDE1O1xcblxcdG9wdGlvbmFsIERvdE9wZXJhdGlvblJlcXVlc3QgICAgICAgICBkb3Rfb3BlcmF0aW9uX3JlcXVlc3QgICAgICAgICAgPSAxNjtcXG59XFxuXFxubWVzc2FnZSBFbXB0eUFycmF5UmVxdWVzdCB7XFxuXFx0cmVxdWlyZWQgZml4ZWQzMiAgaWRfb3V0ICAgICAgPSAxO1xcblxcdHJlcGVhdGVkIHVpbnQzMiAgIHNoYXBlICAgICAgID0gMiBbcGFja2VkPXRydWVdO1xcblxcdHJlcXVpcmVkIERhdGFUeXBlIGRhdGFfdHlwZSAgID0gMztcXG59XFxuXFxubWVzc2FnZSBEYXRhQXJyYXlSZXF1ZXN0IHtcXG5cXHRyZXF1aXJlZCBmaXhlZDMyICBpZF9vdXQgICAgICA9IDE7XFxuXFx0cmVwZWF0ZWQgdWludDMyICAgc2hhcGUgICAgICAgPSAyIFtwYWNrZWQ9dHJ1ZV07XFxuXFx0cmVxdWlyZWQgRGF0YVR5cGUgZGF0YV90eXBlICAgPSAzO1xcblxcdHJlcXVpcmVkIGJ5dGVzICAgIGRhdGFfYnVmZmVyID0gNDtcXG59XFxuXFxubWVzc2FnZSBDb25zdEFycmF5UmVxdWVzdCB7XFxuXFx0cmVxdWlyZWQgZml4ZWQzMiAgaWRfb3V0ICAgICAgPSAxO1xcblxcdHJlcGVhdGVkIHVpbnQzMiAgIHNoYXBlICAgICAgID0gMiBbcGFja2VkPXRydWVdO1xcblxcdHJlcXVpcmVkIERhdGFUeXBlIGRhdGFfdHlwZSAgID0gMztcXG5cXHRyZXF1aXJlZCBkb3VibGUgICBmaWxsX3ZhbHVlICA9IDQ7XFxufVxcblxcbm1lc3NhZ2UgTGluc3BhY2VSZXF1ZXN0IHtcXG5cXHRyZXF1aXJlZCBzZml4ZWQzMiAgaWRfb3V0ICAgICA9IDE7XFxuXFx0cmVxdWlyZWQgZG91YmxlICAgIHN0YXJ0ICAgICAgPSAyO1xcblxcdHJlcXVpcmVkIGRvdWJsZSAgICBzdG9wICAgICAgID0gMztcXG5cXHRyZXF1aXJlZCB1aW50MzIgICAgc2FtcGxlcyAgICA9IDQ7XFxuXFx0cmVxdWlyZWQgYm9vbCAgICAgIGNsb3NlZCAgICAgPSA1O1xcblxcdHJlcXVpcmVkIERhdGFUeXBlICBkYXRhX3R5cGUgID0gNjtcXG59XFxuXFxubWVzc2FnZSBSZXNoYXBlUmVxdWVzdCB7XFxuXFx0cmVxdWlyZWQgc2ZpeGVkMzIgIGlkX2EgICAgICA9IDE7XFxuXFx0cmVxdWlyZWQgZml4ZWQzMiAgIGlkX291dCAgICA9IDI7XFxuXFx0cmVwZWF0ZWQgdWludDMyICAgIHNoYXBlX291dCA9IDMgW3BhY2tlZD10cnVlXTtcXG59XFxuXFxubWVzc2FnZSBSZXBlYXRSZXF1ZXN0IHtcXG5cXHRyZXF1aXJlZCBzZml4ZWQzMiBpZF9hICAgID0gMTtcXG5cXHRyZXF1aXJlZCBmaXhlZDMyICBpZF9vdXQgID0gMjtcXG5cXHRyZXF1aXJlZCB1aW50MzIgICBheGlzICAgID0gMztcXG5cXHRyZXF1aXJlZCB1aW50MzIgICByZXBlYXRzID0gNDtcXG59XFxuXFxubWVzc2FnZSBEZWFsbG9jYXRlUmVxdWVzdCB7XFxuXFx0cmVxdWlyZWQgZml4ZWQzMiBpZF9hID0gMTtcXG59XFxuXFxubWVzc2FnZSBGZXRjaFJlcXVlc3Qge1xcblxcdHJlcXVpcmVkIHNmaXhlZDMyIGlkX2EgPSAxO1xcbn1cXG5cXG5tZXNzYWdlIEJpbmFyeU9wZXJhdGlvblJlcXVlc3Qge1xcblxcdGVudW0gVHlwZSB7XFxuXFx0XFx0QUREID0gMDtcXG5cXHRcXHRTVUIgPSAxO1xcblxcdFxcdE1VTCA9IDI7XFxuXFx0XFx0RElWID0gMztcXG5cXHR9XFxuXFx0cmVxdWlyZWQgVHlwZSAgICAgdHlwZSAgID0gMTtcXG5cXHRyZXF1aXJlZCBzZml4ZWQzMiBpZF9hICAgPSAyO1xcblxcdHJlcXVpcmVkIHNmaXhlZDMyIGlkX2IgICA9IDM7XFxuXFx0cmVxdWlyZWQgZml4ZWQzMiAgaWRfb3V0ID0gNDtcXG59XFxuXFxubWVzc2FnZSBCaW5hcnlDb25zdE9wZXJhdGlvblJlcXVlc3Qge1xcblxcdGVudW0gVHlwZSB7XFxuXFx0XFx0QUREQyAgPSAwO1xcblxcdFxcdFNVQkMgID0gMTtcXG5cXHRcXHRTVUJSQyA9IDI7XFxuXFx0XFx0TVVMQyAgPSAzO1xcblxcdFxcdERJVkMgID0gNDtcXG5cXHRcXHRESVZSQyA9IDU7XFxuXFx0fVxcblxcdHJlcXVpcmVkIFR5cGUgICAgIHR5cGUgICAgPSAxO1xcblxcdHJlcXVpcmVkIHNmaXhlZDMyIGlkX2EgICAgPSAyO1xcblxcdHJlcXVpcmVkIGRvdWJsZSAgIHZhbHVlX2IgPSAzO1xcblxcdHJlcXVpcmVkIGZpeGVkMzIgIGlkX291dCAgPSA0O1xcbn1cXG5cXG5tZXNzYWdlIFVuYXJ5T3BlcmF0aW9uUmVxdWVzdCB7XFxuXFx0ZW51bSBUeXBlIHtcXG5cXHRcXHRORUcgICAgPSAwO1xcblxcdFxcdEFCUyAgICA9IDE7XFxuXFx0XFx0RVhQICAgID0gMjtcXG5cXHRcXHRMT0cgICAgPSAzO1xcblxcdFxcdFNRUlQgICA9IDQ7XFxuXFx0XFx0U1FVQVJFID0gNTtcXG5cXHR9XFxuXFx0cmVxdWlyZWQgVHlwZSAgICAgdHlwZSAgID0gMTtcXG5cXHRyZXF1aXJlZCBzZml4ZWQzMiBpZF9hICAgPSAyO1xcblxcdHJlcXVpcmVkIGZpeGVkMzIgIGlkX291dCA9IDM7XFxufVxcblxcbm1lc3NhZ2UgUmVkdWN0aW9uUmVxdWVzdCB7XFxuXFx0ZW51bSBUeXBlIHtcXG5cXHRcXHRTVU0gPSAwO1xcblxcdFxcdE1JTiA9IDE7XFxuXFx0XFx0TUFYID0gMjtcXG5cXHR9XFxuXFx0cmVxdWlyZWQgVHlwZSAgICAgdHlwZSAgID0gMTtcXG5cXHRyZXF1aXJlZCBzZml4ZWQzMiBpZF9hICAgPSAyO1xcblxcdHJlcXVpcmVkIGZpeGVkMzIgIGlkX291dCA9IDM7XFxufVxcblxcbm1lc3NhZ2UgQXhpc1JlZHVjdGlvblJlcXVlc3Qge1xcblxcdGVudW0gVHlwZSB7XFxuXFx0XFx0U1VNID0gMDtcXG5cXHRcXHRNSU4gPSAxO1xcblxcdFxcdE1BWCA9IDI7XFxuXFx0fVxcblxcdHJlcXVpcmVkIFR5cGUgICAgIHR5cGUgICA9IDE7XFxuXFx0cmVxdWlyZWQgc2ZpeGVkMzIgaWRfYSAgID0gMjtcXG5cXHRyZXF1aXJlZCB1aW50MzIgICBheGlzICAgPSAzO1xcblxcdHJlcXVpcmVkIGZpeGVkMzIgIGlkX291dCA9IDQ7XFxufVxcblxcbm1lc3NhZ2UgRG90T3BlcmF0aW9uUmVxdWVzdCB7XFxuXFx0cmVxdWlyZWQgc2ZpeGVkMzIgaWRfYSAgID0gMTtcXG5cXHRyZXF1aXJlZCBzZml4ZWQzMiBpZF9iICAgPSAyO1xcblxcdHJlcXVpcmVkIGZpeGVkMzIgIGlkX291dCA9IDM7XFxufVxcblwiO1xubW9kdWxlLmV4cG9ydHMgPSBwcm90b2J1ZmpzLmxvYWRQcm90byhyZXF1ZXN0c1Byb3RvKS5idWlsZChcImZ1cmlvdXNcIik7XG4iLCJcbnZhciBwcm90b2J1ZmpzID0gcmVxdWlyZShcInByb3RvYnVmanNcIik7XG5wcm90b2J1ZmpzLmNvbnZlcnRGaWVsZHNUb0NhbWVsQ2FzZSA9IHRydWU7XG52YXIgcmVzcG9uc2VzUHJvdG8gPSBcInBhY2thZ2UgZnVyaW91cztcXG5cXG5vcHRpb24gb3B0aW1pemVfZm9yID0gTElURV9SVU5USU1FO1xcblxcbm1lc3NhZ2UgUmVzcG9uc2Uge1xcblxcdGVudW0gVHlwZSB7XFxuXFx0XFx0RkVUQ0ggICA9IDA7XFxuXFx0XFx0RVJST1IgICA9IDE7XFxuXFx0XFx0SU5JVCAgICA9IDI7XFxuXFx0XFx0QkFSUklFUiA9IDM7XFxuXFx0XFx0SU5GTyAgICA9IDQ7XFxuXFx0fVxcblxcdHJlcXVpcmVkIGZpeGVkMzIgICAgICAgICBpZCAgICAgICAgICAgICAgID0gMTtcXG5cXHRyZXF1aXJlZCBUeXBlICAgICAgICAgICAgdHlwZSAgICAgICAgICAgICA9IDI7XFxuXFxuXFx0b3B0aW9uYWwgRmV0Y2hSZXNwb25zZSAgIGZldGNoX3Jlc3BvbnNlICAgPSAzO1xcblxcdG9wdGlvbmFsIEVycm9yUmVzcG9uc2UgICBlcnJvcl9yZXNwb25zZSAgID0gNDtcXG5cXHRvcHRpb25hbCBJbml0UmVzcG9uc2UgICAgaW5pdF9yZXNwb25zZSAgICA9IDU7XFxuXFx0b3B0aW9uYWwgSW5mb1Jlc3BvbnNlICAgIGluZm9fcmVzcG9uc2UgICAgPSA3O1xcbn1cXG5cXG5tZXNzYWdlIEZldGNoUmVzcG9uc2Uge1xcblxcdHJlcXVpcmVkIGJ5dGVzIGRhdGFfYnVmZmVyID0gMTtcXG59XFxuXFxubWVzc2FnZSBFcnJvclJlc3BvbnNlIHtcXG5cXHRlbnVtIFR5cGUge1xcblxcdFxcdFJVTlRJTUUgID0gMDtcXG5cXHRcXHRBUkdVTUVOVCA9IDE7XFxuXFx0XFx0UEFSU0UgICAgPSAyO1xcblxcdH1cXG5cXHRyZXF1aXJlZCBUeXBlICAgdHlwZSAgICAgICAgPSAxO1xcblxcdG9wdGlvbmFsIHN0cmluZyBkZXNjcmlwdGlvbiA9IDI7XFxufVxcblxcbm1lc3NhZ2UgSW5pdFJlc3BvbnNlIHtcXG5cXHRvcHRpb25hbCB1aW50MzIgY29uY3VycmVuY3kgPSAxO1xcbn1cXG5cXG5tZXNzYWdlIEluZm9SZXNwb25zZSB7XFxufVxcblwiO1xubW9kdWxlLmV4cG9ydHMgPSBwcm90b2J1ZmpzLmxvYWRQcm90byhyZXNwb25zZXNQcm90bykuYnVpbGQoXCJmdXJpb3VzXCIpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogUHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9uc1xuICpcbiAqIEBwcml2YXRlXG4gKiBAY2xhc3MgdXRpbFxuICovXG5cbnZhciBpc051bWJlciA9IGZ1bmN0aW9uKG4pIHtcblx0cmV0dXJuIG4gPT09ICtuO1xufTtcbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcblxudmFyIGlzUmVhbCA9IGZ1bmN0aW9uKG4pIHtcblx0cmV0dXJuIChuID09PSArbikgJiYgKGlzRmluaXRlKG4pKTtcbn07XG5leHBvcnRzLmlzUmVhbCA9IGlzUmVhbDtcblxudmFyIGlzSW50ID0gZnVuY3Rpb24obikge1xuXHRyZXR1cm4gbiA9PT0gKG58MCk7XG59O1xuZXhwb3J0cy5pc0ludCA9IGlzSW50O1xuXG5leHBvcnRzLmlzUG9zaXRpdmVJbnQgPSBmdW5jdGlvbihuKSB7XG5cdHJldHVybiAobiA9PT0gK24pICYmIChuID09PSAobnwwKSkgJiYgKG4gPiAwKTtcbn07XG5cbmV4cG9ydHMuaXNOb25OZWdhdGl2ZUludCA9IGZ1bmN0aW9uKG4pIHtcblx0cmV0dXJuIChuID09PSArbikgJiYgKG4gPT09IChufDApKSAmJiAobiA+PSAwKTtcbn07XG5cbnZhciBpc0FycmF5ID0gZnVuY3Rpb24obGlzdCkge1xuXHRyZXR1cm4gbGlzdCBpbnN0YW5jZW9mIEFycmF5O1xufTtcbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5cbmV4cG9ydHMuaXNJbnRBcnJheSA9IGZ1bmN0aW9uKGxpc3QpIHtcblx0aWYgKGV4cG9ydHMuaXNBcnJheShsaXN0KSkge1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKCFleHBvcnRzLmlzSW50KGxpc3RbaV0pKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59O1xuXG5leHBvcnRzLmlzUG9zaXRpdmVJbnRBcnJheSA9IGZ1bmN0aW9uKGxpc3QpIHtcblx0aWYgKGV4cG9ydHMuaXNBcnJheShsaXN0KSkge1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKCFleHBvcnRzLmlzUG9zaXRpdmVJbnQobGlzdFtpXSkpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn07XG5cbmV4cG9ydHMuYXNJbnRBcnJheSA9IGZ1bmN0aW9uIChsaXN0KSB7XG5cdGlmIChleHBvcnRzLmlzSW50KGxpc3QpKSB7XG5cdFx0cmV0dXJuIFtsaXN0XTtcblx0fSBlbHNlIGlmIChleHBvcnRzLmlzSW50QXJyYXkobGlzdCkpIHtcblx0XHRyZXR1cm4gbGlzdDtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKGxpc3QgKyBcIiBjYW4gbm90IGJlIGNvbnZlcnRlZCB0byBpbnRlZ2VyIGFycmF5XCIpO1xuXHR9XG59O1xuXG4vKipcbiAqIENvbXBhcmVzIGZvciBlcXVhbGl0eSB0d28gYXJyYXlzIG9mIHByaW1pdGl2ZSB0eXBlcy5cbiAqXG4gKiBAcGFyYW0ge051bWJlcltdfSBhcnJheUEgLSB0aGUgZmlyc3QgYXJyYXkgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7TnVtYmVyW119IGFycmF5QiAtIHRoZSBzZWNvbmQgYXJyYXkgdG8gY29tcGFyZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogICAgIGlmICghdXRpbC5hcnJheUVxdWFscyhhLnNoYXBlLCBiLnNoYXBlKSkge1xuICpcdCAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhIGFuZCBiIGhhdmUgaW5jb21wYXRpYmxlIHNoYXBlc1wiKTtcbiAqICAgICB9XG4gKlxuICogQHByaXZhdGVcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgYXJyYXlFcXVhbHNcbiAqL1xuZXhwb3J0cy5hcnJheUVxdWFscyA9IGZ1bmN0aW9uKGFycmF5QSwgYXJyYXlCKSB7XG5cdGlmIChhcnJheUEgPT09IGFycmF5Qikge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cdGlmIChhcnJheUEubGVuZ3RoICE9PSBhcnJheUIubGVuZ3RoKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cdHZhciBuID0gYXJyYXlBLmxlbmd0aDtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpIHtcblx0XHRpZiAoYXJyYXlBW2ldICE9PSBhcnJheUJbaV0pIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIHRydWU7XG59O1xuXG5leHBvcnRzLnJvdW5kVXAgPSBmdW5jdGlvbiAobnVtYmVyLCBtdWx0aXBsZSkge1xuXHRyZXR1cm4gTWF0aC5jZWlsKG51bWJlciAvIG11bHRpcGxlKSAqIG11bHRpcGxlO1xufTtcblxuLyoqXG4gKiBWYWxpZGF0ZSB0aGUgc2hhcGUgYXJndW1lbnQuXG4gKiBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlIGFyZ3VtZW50IHJlcHJlc2VudHMgYSB2YWxpZCBzaGFwZS5cbiAqIFJldHVybnMgdGhlIHNoYXBlIGFzIGFuIGludGVnZXIgYXJyYXkuXG4gKlxuICogQHBhcmFtIHsoTnVtYmVyfE51bWJlcltdKX0gc2hhcGUgLSB0aGUgc2hhcGUgYXJndW1lbnQgdG8gdmFsaWRhdGUuXG4gKlxuICogQGV4YW1wbGVcbiAqICAgICBzaGFwZSA9IHV0aWwuY2hlY2tTaGFwZShzaGFwZSk7XG4gKlxuICogQHByaXZhdGVcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgY2hlY2tTaGFwZVxuICovXG52YXIgY2hlY2tTaGFwZSA9IGZ1bmN0aW9uKHNoYXBlKSB7XG5cdGlmIChpc051bWJlcihzaGFwZSkpIHtcblx0XHRyZXR1cm4gY2hlY2tTaGFwZShbc2hhcGVdKTtcblx0fSBlbHNlIGlmIChpc0FycmF5KHNoYXBlKSkge1xuXHRcdHZhciBuID0gc2hhcGUubGVuZ3RoO1xuXHRcdHZhciBvdXRTaGFwZSA9IG5ldyBBcnJheShuKTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuXHRcdFx0aWYgKCFpc051bWJlcihzaGFwZVtpXSkpIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiU2hhcGUgaGFzIG5vbi1udW1lcmljIGRpbWVuc2lvbnNcIik7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIWlzSW50KHNoYXBlW2ldKSkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJTaGFwZSBtdXN0IGhhdmUgaW50ZWdlciBkaW1lbnNpb25zXCIpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHNoYXBlW2ldIDwgMSkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJEZWdlbmVyYXRlIHNoYXBlXCIpO1xuXHRcdFx0fVxuXHRcdFx0b3V0U2hhcGVbaV0gPSBzaGFwZVtpXXwwO1xuXHRcdH1cblx0XHRyZXR1cm4gb3V0U2hhcGU7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiU2hhcGUgbXVzdCBiZSBhbiBpbnRlZ2VyIG9yIGludGVnZXIgYXJyYXlcIik7XG5cdH1cbn07XG5leHBvcnRzLmNoZWNrU2hhcGUgPSBjaGVja1NoYXBlO1xuXG4vKipcbiAqIENoZWNrcyB0aGF0IHRoZSB0d28gc2hhcGVzIGFyZSBzaW1pbGFyLlxuICogVGhyb3dzIGFuIGVycm9yIGlmIHRoZSB0d28gc2hhcGVzIGFyZSBkaWZmZXJlbnQuXG4gKiBJZiB0aGUgZGF0YSB0eXBlcyBhcmUgY29tcGF0aWJsZSwgdGhlIGZ1bmN0aW9uIGRvZXMgbm90aGluZy5cbiAqXG4gKiBAcGFyYW0ge051bWJlcltdfSBzaGFwZUEgLSBvbmUgdmFsaWQgc2hhcGUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7TnVtYmVyW119IHNoYXBlQiAtIGFub3RoZXIgdmFsaWQgc2hhcGUgdG8gY29tcGFyZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogICAgIHV0aWwuY2hlY2tTaGFwZXNDb21wYXRpYmlsaXR5KGEuc2hhcGUsIGIuc2hhcGUpO1xuICpcbiAqIEBwcml2YXRlXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIGNoZWNrU2hhcGVzQ29tcGF0aWJpbGl0eVxuICovXG5leHBvcnRzLmNoZWNrU2hhcGVzQ29tcGF0aWJpbGl0eSA9IGZ1bmN0aW9uKHNoYXBlQSwgc2hhcGVCKSB7XG5cdGlmIChzaGFwZUEubGVuZ3RoICE9IHNoYXBlQi5sZW5ndGgpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc2hhcGVzIGhhdmUgZGlmZmVyZW50IGRpbWVuc2lvbnNcIik7XG5cdH1cblx0dmFyIG4gPSBzaGFwZUEubGVuZ3RoO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuXHRcdGlmIChzaGFwZUFbaV0gIT0gc2hhcGVCW2ldKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc2hhcGVzIGFyZSBkaWZmZXJlbnRcIik7XG5cdFx0fVxuXHR9XG59O1xuXG4vKipcbiAqIENvbXB1dGVzIGFycmF5IGxlbmd0aCBmcm9tIGl0cyBzaGFwZS5cbiAqXG4gKiBAcGFyYW0ge051bWJlcltdfSBzaGFwZSAtIGFuIGFycmF5IHNoYXBlLiAgVGhlIHNoYXBlIG11c3QgYmUgdmFsaWQgdy5yLnQuICoqY2hlY2tTaGFwZSoqIGZ1bmN0aW9uLlxuICpcbiAqIEBleGFtcGxlXG4gKiAgICAgdmFyIGxlbmd0aCA9IHV0aWwuY29tcHV0ZUxlbmd0aChzaGFwZSk7XG4gKlxuICogQHByaXZhdGVcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgY29tcHV0ZUxlbmd0aFxuICovXG5leHBvcnRzLmNvbXB1dGVMZW5ndGggPSBmdW5jdGlvbihzaGFwZSkge1xuXHR2YXIgbGVuZ3RoID0gMTtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzaGFwZS5sZW5ndGg7ICsraSkge1xuXHRcdGxlbmd0aCAqPSBzaGFwZVtpXTtcblx0fVxuXHRyZXR1cm4gbGVuZ3RoO1xufTtcblxuLyoqXG4gKiBDaGVja3MgdGhlIHRoZSBhcmd1bWVudCByZXByZXNlbnRzIGEgZGF0YSB0eXBlLlxuICogVGhyb3dzIGFuIGVycm9yIGlmIHRoZSBhcmd1bWVudCBpcyBub3Qgb2YgRGF0YVR5cGUgdHlwZS5cbiAqIElmIHRoZSBhcmd1bWVudCBpcyBhIERhdGFUeXBlIG9iamVjdCwgdGhlIGZ1bmN0aW9uIGRvZXMgbm90aGluZy5cbiAqXG4gKiBAcGFyYW0ge0RhdGFUeXBlfSBkYXRhVHlwZSAtIHRoZSBleHBlY3RlZGx5IGRhdGEgdHlwZSBvYmplY3QgdG8gdmFsaWRhdGUuXG4gKiBAcmV0dXJuIHtEYXRhVHlwZX0gLSBhIGRhdGEgdHlwZSBvYmplY3QgZXF1aXZhbGVudCB0byB0aGUgYXJndW1lbnQuXG4gKlxuICogQGV4YW1wbGVcbiAqICAgICBkYXRhVHlwZSA9IHV0aWwuY2hlY2tEYXRhVHlwZShkYXRhVHlwZSk7XG4gKlxuICogQHByaXZhdGVcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgY2hlY2tEYXRhVHlwZVxuICovXG5leHBvcnRzLmNoZWNrRGF0YVR5cGUgPSBmdW5jdGlvbihkYXRhVHlwZSkge1xuXHR2YXIgRGF0YVR5cGUgPSByZXF1aXJlKFwiLi9EYXRhVHlwZVwiKTtcblx0aWYgKCEoZGF0YVR5cGUgaW5zdGFuY2VvZiBEYXRhVHlwZSkpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKFwiZGF0YVR5cGUgaXMgbm90IGFuIGluc3RhbmNlIG9mIERhdGFUeXBlXCIpO1xuXHR9XG5cdHJldHVybiBkYXRhVHlwZTtcbn07XG5cbi8qKlxuICogQ2hlY2tzIHRoYXQgdGhlIHR3byBkYXRhIHR5cGVzIGFyZSBjb21wYXRpYmxlLlxuICogVGhyb3dzIGFuIGVycm9yIGlmIHRoZSBkYXRhIHR5cGVzIGRvIG5vdCBtYXRjaC5cbiAqIElmIHRoZSBkYXRhIHR5cGVzIGFyZSBjb21wYXRpYmxlLCB0aGUgZnVuY3Rpb24gZG9lcyBub3RoaW5nLlxuICpcbiAqIEBwYXJhbSB7RGF0YVR5cGV9IGRhdGFUeXBlQSAtIHRoZSBmaXJzdCBkYXRhIHR5cGUuXG4gKiBAcGFyYW0ge0RhdGFUeXBlfSBkYXRhVHlwZUIgLSB0aGUgc2Vjb25kIGRhdGEgdHlwZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogICAgIHV0aWwuY2hlY2tEYXRhVHlwZXNDb21wYXRpYmlsaXR5KGEuZGF0YVR5cGUsIGIuZGF0YVR5cGUpO1xuICpcbiAqIEBwcml2YXRlXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIGNoZWNrRGF0YVR5cGVzQ29tcGF0aWJpbGl0eVxuICovXG5leHBvcnRzLmNoZWNrRGF0YVR5cGVzQ29tcGF0aWJpbGl0eSA9IGZ1bmN0aW9uKGRhdGFUeXBlQSwgZGF0YVR5cGVCKSB7XG5cdGlmICghZGF0YVR5cGVBLmVxdWFscyhkYXRhVHlwZUIpKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiVGhlIGRhdGEgdHlwZXMgYXJlIG5vdCBjb21wYXRpYmxlXCIpO1xuXHR9XG59O1xuXG4vKipcbiAqIFZhbGlkYXRlcyBhbiBOREFycmF5IHBhcmFtZXRlci5cbiAqIFRocm93cyBhbiBlcnJvciBpZiB0aGUgZXhwZWN0ZWQgTkRBcnJheSBhcmd1bWVudCBoYXMgb3RoZXIgdHlwZSBvciBpZiBpdCBoYXMgYmVlbiBpbnZhbGlkYXRlZC5cbiAqIElmIHRoZSBhcmd1bWVudCBpcyBhIHZhbGlkIE5EQXJyYXksIHRoZSBmdW5jdGlvbiBkb2VzIG5vdGhpbmcuXG4gKlxuICogQHBhcmFtIHtOREFycmF5fSBhcnJheSAtIHRoZSBleHBlY3RlZGx5IE5EQXJyYXkgYXJndW1lbnQgdG8gYmUgdmFsaWRhdGVkLlxuICogQHBhcmFtIHtTdHJpbmd9IHZhbmFtZSAtIHRoZSBuYW1lIG9mIHRoZSBOREFycmF5IGFyZ3VtZW50IHRvIGJlIHVzZWQgaW4gZXJyb3IgbWVzc2FnZXMuXG4gKlxuICogQGV4YW1wbGVcbiAqICAgICB1dGlsLmNoZWNrTkRBcnJheShvdXQsIFwib3V0XCIpO1xuICpcbiAqIEBwcml2YXRlXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIGNoZWNrTkRBcnJheVxuICovXG5leHBvcnRzLmNoZWNrTkRBcnJheSA9IGZ1bmN0aW9uKGFycmF5LCB2YXJuYW1lKSB7XG5cdHZhciBOREFycmF5ID0gcmVxdWlyZShcIi4vTkRBcnJheVwiKTtcblx0aWYgKCEoYXJyYXkgaW5zdGFuY2VvZiBOREFycmF5KSkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IodmFybmFtZSArIFwiIGlzIG5vdCBhbiBOREFycmF5XCIpO1xuXHR9XG5cdGlmICghYXJyYXkuaXNWYWxpZCgpKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKHZhcm5hbWUgKyBcIiBpcyBhbiBpbnZhbGlkYXRlZCBhcnJheVwiKTtcblx0fVxufTtcblxuLyoqXG4gKiBDaGVja3MgdGhhdCB0aGUgdHdvIGFycmF5cyBhcmUgZGlmZmVyZW50LlxuICogVGhyb3dzIGFuIGVycm9yIGlmIHRoZXkgcmVmZXIgdG8gdGhlIHNhbWUgb2JqZWN0LlxuICogSWYgdGhlIGFycmF5cyBhcmUgZGlmZmVyZW50LCB0aGUgZnVuY3Rpb24gZG9lcyBub3RoaW5nLlxuICpcbiAqIEBwYXJhbSB7TkRBcnJheX0gYSAtIHRoZSBmaXJzdCBhcnJheSB0byBjaGVjay4gTXVzdCBiZSBhbiBOREFycmF5IG9iamVjdC5cbiAqIEBwYXJhbSB7TkRBcnJheX0gYiAtIHRoZSBzZWNvbmQgYXJyYXkgdG8gY2hlY2suIE11c3QgYmUgYW4gTkRBcnJheSBvYmplY3QuXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFybmFtZUEgLSBuYW1lIG9mIHRoZSBmaXJzdCBhcnJheSB2YXJpYWJsZS4gVGhpcyBuYW1lIG1heSBiZSB1c2VkIGluIGFuIGVycm9yIG1lc3NhZ2UuXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFybmFtZUIgLSBuYW1lIG9mIHRoZSBzZWNvbmQgYXJyYXkgdmFyaWFibGUuIFRoaXMgbmFtZSBtYXkgYmUgdXNlZCBpbiBhbiBlcnJvciBtZXNzYWdlLlxuICpcbiAqIEBleGFtcGxlXG4gKiAgICAgdXRpbC5jaGVja0RpZmZlcmVudE5EQXJyYXlzKGEsIG91dCwgXCJhXCIsIFwib3V0XCIpO1xuICpcbiAqIEBwcml2YXRlXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIGNoZWNrRGlmZmVyZW50TkRBcnJheXNcbiAqL1xuZXhwb3J0cy5jaGVja0RpZmZlcmVudE5EQXJyYXlzID0gZnVuY3Rpb24oYSwgYiwgdmFybmFtZUEsIHZhcm5hbWVCKSB7XG5cdGlmIChhID09PSBiKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiVGhlIGFycmF5cyBcIiArIHZhcm5hbWVBICsgXCIgYW5kIFwiICsgdmFybmFtZUIgKyBcIiBtdXN0IGJlIGRpZmZlcmVudFwiKTtcblx0fVxufTtcblxuLyoqXG4gKiBWYWxpZGF0ZXMgKipyZXBlYXRzKiogcGFyYW1ldGVyIGZvciByZXBlYXRpdGlvbi90aWxpbmcgb2YgYXJyYXkgYWxvbmcgYW4gYXhpcy5cbiAqIFRocm93cyBhbiBlcnJvciBpZiAqKnJlcGVhdHMqKiBpcyBub3QgYW4gaW50ZWdlciBvciBpZiAqKnJlcGVhdHMqKiBpcyBzbWFsbGVyIHRoYW4gMi5cbiAqIElmICoqcmVwZWF0cyoqIGlzIHZhbGlkLCB0aGUgZnVuY3Rpb24gZG9lcyBub3RoaW5nLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSByZXBlYXRzIC0gdGhlIHJlcGVhdHMgYXJndW1lbnQgdG8gYmUgdmVyaWZpZWQuXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IC0gKipyZXBlYXRzKiogY2FzdGVkIHRvIGludGVnZXIuXG4gKlxuICogQGV4YW1wbGVcbiAqICAgICByZXBlYXRzID0gdXRpbC5jaGVja1JlcGVhdHMocmVwZWF0cyk7XG4gKlxuICogQHByaXZhdGVcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgY2hlY2tSZXBlYXRzXG4gKi9cbmV4cG9ydHMuY2hlY2tSZXBlYXRzID0gZnVuY3Rpb24ocmVwZWF0cykge1xuXHRpZiAoIWlzSW50KHJlcGVhdHMpKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihcIlJlcGVhdHMgaXMgbm90IGFuIGludGVnZXJcIik7XG5cdH1cblx0aWYgKHJlcGVhdHMgPD0gMSkge1xuXHRcdHRocm93IG5ldyBSYW5nZUVycm9yKFwiUmVwZWF0cyBzaG91bGQgYmUgZ3JlYXRlciB0aGFuIDFcIik7XG5cdH1cblx0cmV0dXJuIHJlcGVhdHN8MDtcbn07XG5cbi8qKlxuICogVmFsaWRhdGVzIGF4aXMgcGFyYW1ldGVyIGZvciByZWR1Y3Rpb25zIGFsb25nIGFuIGF4aXMuXG4gKiBUaHJvd3MgYW4gZXJyb3IgaWYgYXhpcyBpcyBub3QgYW4gaW50ZWdlciwgaWYgYXhpcyBpcyBuZWdhdGl2ZSwgb3IgYXhpcyBleGNlZWRzIHRoZSBudW1iZXIgb2YgZGltZW5zaW9ucy5cbiAqIElmIGF4aXMgaXMgdmFsaWQsIHRoZSBmdW5jdGlvbiBkb2VzIG5vdGhpbmcuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGF4aXMgLSB0aGUgYXhpcyBhcmd1bWVudCB0byBiZSB2ZXJpZmllZC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBudW1EaW1lbnNpb25zIC0gdGhlIG51bWJlciBvZiBkaW1lbnNpb25zIGluIHRoZSBhcnJheSBiZWluZyByZWR1Y2VkLlxuICogQHJldHVybiB7TnVtYmVyfSAtIGF4aXMgY2FzdGVkIHRvIGludGVnZXIuXG4gKlxuICogQGV4YW1wbGVcbiAqICAgICBheGlzID0gdXRpbC5jaGVja0F4aXMoYXhpcywgbmRhcnJheS5zaGFwZS5sZW5ndGgpO1xuICpcbiAqIEBwcml2YXRlXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kXG4gKi9cbmV4cG9ydHMuY2hlY2tBeGlzID0gZnVuY3Rpb24oYXhpcywgbnVtRGltZW5zaW9ucykge1xuXHRpZiAoIWlzSW50KGF4aXMpKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihcIkF4aXMgaXMgbm90IGFuIGludGVnZXJcIik7XG5cdH1cblx0aWYgKGF4aXMgPCAwKSB7XG5cdFx0dGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJBeGlzIGlzIG5lZ2F0aXZlXCIpO1xuXHR9XG5cdC8qIEUuZy4gMy1kaW1lbnNpb25hbCBhcnJheSBoYXMgYXhlcyAwLCAxLCAyIChidXQgbm90IDMhKSAqL1xuXHRpZiAoYXhpcyA+PSBudW1EaW1lbnNpb25zKSB7XG5cdFx0dGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJBeGlzIG91dCBvZiByYW5nZVwiKTtcblx0fVxuXHRyZXR1cm4gYXhpc3wwO1xufTtcblxuLyoqXG4gKiBWYWxpZGF0ZXMgdGhlIHNoYXBlIG9mIG91dHB1dCBhcnJheSBmb3IgcmVkdWN0aW9ucyBhbG9uZyBhbiBheGlzLlxuICogVGhyb3dzIGFuIGVycm9yIGlmIHRoZSBzaGFwZSBvZiB0aGUgb3V0cHV0IGFycmF5IGRvZXMgbWF0Y2ggdGhlIHNoYXBlIG9mIGlucHV0IGFycmF5IGFmdGVyIHJlZHVjdGlvbiBhbG9uZyB0aGUgYXhpcy5cbiAqXG4gKiBAcGFyYW0ge051bWJlcltdfSBpblNoYXBlIC0gdGhlIHNoYXBlIG9mIHRoZSBpbnB1dCBhcnJheS5cbiAqIEBwYXJhbSB7TnVtYmVyW119IG91dFNoYXBlIC0gdGhlIHNoYXBlIG9mIHRoZSBvdXRwdXQgYXJyYXkgdG8gYmUgdmFsaWRhdGVkLlxuICogQHBhcmFtIHtOdW1iZXJ9IGF4aXMgLSB0aGUgYXhpcyBmb3IgcmVkdWN0aW9uIG9mIGlucHV0IGFycmF5LiBNdXN0IGJlIHZhbGlkIHcuci50LiBpblNoYXBlLlxuICpcbiAqIEBleGFtcGxlXG4gKiAgICAgdXRpbC5jaGVja0F4aXNSZWR1Y3Rpb25PdXRTaGFwZShpbkFycmF5LnNoYXBlLCBvdXRBcnJheS5zaGFwZSwgYXhpcyk7XG4gKlxuICogQHByaXZhdGVcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2RcbiAqL1xuZXhwb3J0cy5jaGVja0F4aXNSZWR1Y3Rpb25PdXRTaGFwZSA9IGZ1bmN0aW9uKGluU2hhcGUsIG91dFNoYXBlLCBheGlzKSB7XG5cdGlmIChpblNoYXBlLmxlbmd0aCAhPT0gb3V0U2hhcGUubGVuZ3RoICsgMSkge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIk91dHB1dCBhcnJheSBoYXMgaW52YWxpZCBudW1iZXIgb2YgZGltZW5zaW9ucyBmb3IgdGhpcyBvcGVyYXRpb25cIik7XG5cdH1cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBheGlzOyArK2kpIHtcblx0XHRpZiAoaW5TaGFwZVtpXSAhPT0gb3V0U2hhcGVbaV0pIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihcIk91dHB1dCBhcnJheSBoYXMgaW52YWxpZCBzaGFwZSBmb3IgdGhpcyBvcGVyYXRpb25cIik7XG5cdFx0fVxuXHR9XG5cdGZvciAodmFyIGkgPSBheGlzICsgMTsgaSA8IGluU2hhcGUubGVuZ3RoOyArK2kpIHtcblx0XHRpZiAoaW5TaGFwZVtpXSAhPT0gb3V0U2hhcGVbaS0xXSkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiT3V0cHV0IGFycmF5IGhhcyBpbnZhbGlkIHNoYXBlIGZvciB0aGlzIG9wZXJhdGlvblwiKTtcblx0XHR9XG5cdH1cbn07XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIHNoYXBlIG9mIGFuIGFycmF5IGFmdGVyIHJlZHVjdGlvbiBhbG9uZyBhbiBheGlzLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyW119IGluU2hhcGUgLSB0aGUgc2hhcGUgb2YgdGhlIGlucHV0IGFycmF5LlxuICogQHBhcmFtIHtOdW1iZXJ9IGF4aXMgLSB0aGUgYXhpcyBmb3IgcmVkdWN0aW9uIG9mIGlucHV0IGFycmF5LiBNdXN0IGJlIHZhbGlkIHcuci50LiBpblNoYXBlLlxuICogQHJldHVybiB7TnVtYmVyW119IC0gdGhlIHNoYXBlIG9mIHRoZSBvdXRwdXQgYXJyYXkuXG4gKlxuICogQGV4YW1wbGVcbiAqICAgICB2YXIgb3V0U2hhcGUgPSB1dGlsLmdldEF4aXNSZWR1Y3Rpb25PdXRTaGFwZShpbkFycmF5LnNoYXBlLCBheGlzKTtcbiAqICAgICB2YXIgb3V0QXJyYXkgPSBuZXcgTkRBcnJheShvdXRTaGFwZSwgaW5BcnJheS5kYXRhVHlwZSwgY29udGV4dCk7XG4gKlxuICogQHByaXZhdGVcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2RcbiAqL1xuZXhwb3J0cy5jb21wdXRlQXhpc1JlZHVjdGlvbk91dFNoYXBlID0gZnVuY3Rpb24oaW5TaGFwZSwgYXhpcykge1xuXHR2YXIgb3V0U2hhcGUgPSBbXTtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBpblNoYXBlLmxlbmd0aDsgKytpKSB7XG5cdFx0aWYgKGkgIT09IGF4aXMpIHtcblx0XHRcdG91dFNoYXBlLnB1c2goaW5TaGFwZVtpXSk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBvdXRTaGFwZTtcbn07XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIHByb2R1Y3Qgb2YgYXJyYXkgZGltZW5zaW9ucyBiZWZvcmUgdGhlIGF4aXMuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJbXX0gc2hhcGUgLSB0aGUgc2hhcGUgb2YgdGhlIGFycmF5LlxuICogQHBhcmFtIHtOdW1iZXJ9IGF4aXMgLSB0aGUgYXhpcyB1c2VkIGluIGFuIG9wZXJhdGlvbi4gTXVzdCBiZSB2YWxpZCB3LnIudC4gc2hhcGUuXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IC0gdGhlIHByb2R1Y3Qgb2YgYXJyYXkgZGltZW5zaW9ucyBiZWZvcmUgYXhpcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogICAgIC8vIDUtZGltZW5zaW9uYWwgYXJyYXlcbiAqICAgICB2YXIgbmRhcnJheSA9IGNvbnRleHQuZW1wdHkoWzIsIDMsIDQsIDUsIDZdKTtcbiAqICAgICAvLyBSZXR1cm5zIDYgPSAyKjNcbiAqICAgICB2YXIgb3V0ZXJTdHJpZGUgPSBjb21wdXRlT3V0ZXJTdHJpZGUobmRhcnJheSwgMik7XG4gKlxuICogQHByaXZhdGVcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2RcbiAqL1xuZXhwb3J0cy5jb21wdXRlT3V0ZXJTdHJpZGUgPSBmdW5jdGlvbihzaGFwZSwgYXhpcykge1xuXHR2YXIgb3V0ZXJTdHJpZGUgPSAxO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IGF4aXM7ICsraSkge1xuXHRcdG91dGVyU3RyaWRlICo9IHNoYXBlW2ldO1xuXHR9XG5cdHJldHVybiBvdXRlclN0cmlkZTtcbn07XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIHByb2R1Y3Qgb2YgYXJyYXkgZGltZW5zaW9ucyBhZnRlciB0aGUgYXhpcy5cbiAqXG4gKiBAcGFyYW0ge051bWJlcltdfSBzaGFwZSAtIHRoZSBzaGFwZSBvZiB0aGUgYXJyYXkuXG4gKiBAcGFyYW0ge051bWJlcn0gYXhpcyAtIHRoZSBheGlzIHVzZWQgaW4gYW4gb3BlcmF0aW9uLiBNdXN0IGJlIHZhbGlkIHcuci50LiBzaGFwZS5cbiAqIEByZXR1cm4ge051bWJlcn0gLSB0aGUgcHJvZHVjdCBvZiBhcnJheSBkaW1lbnNpb25zIGFmdGVyIGF4aXMuXG4gKlxuICogQGV4YW1wbGVcbiAqICAgICAvLyA1LWRpbWVuc2lvbmFsIGFycmF5XG4gKiAgICAgdmFyIG5kYXJyYXkgPSBjb250ZXh0LmVtcHR5KFsyLCAzLCA0LCA1LCA2XSk7XG4gKiAgICAgLy8gUmV0dXJucyA2ID0gMiozXG4gKiAgICAgdmFyIGlubmVyU3RyaWRlID0gY29tcHV0ZUlubmVyU3RyaWRlKG5kYXJyYXksIDIpO1xuICpcbiAqIEBwcml2YXRlXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kXG4gKi9cbmV4cG9ydHMuY29tcHV0ZUlubmVyU3RyaWRlID0gZnVuY3Rpb24oc2hhcGUsIGF4aXMpIHtcblx0dmFyIGlubmVyU3RyaWRlID0gMTtcblx0Zm9yICh2YXIgaSA9IGF4aXMgKyAxOyBpIDwgc2hhcGUubGVuZ3RoOyArK2kpIHtcblx0XHRpbm5lclN0cmlkZSAqPSBzaGFwZVtpXTtcblx0fVxuXHRyZXR1cm4gaW5uZXJTdHJpZGU7XG59O1xuXG52YXIgZGlzY292ZXJBcnJheVNoYXBlUmVjdXJzaXZlID0gZnVuY3Rpb24oZGF0YSwgc2hhcGUsIGxldmVsKSB7XG5cdGlmIChpc0FycmF5KGRhdGEpKSB7XG5cdFx0aWYgKHNoYXBlLmxlbmd0aCA8PSBsZXZlbCkge1xuXHRcdFx0LyogRGlzY292ZXJlZCBhIG5ldyBsZXZlbCBvZiBzdWItYXJyYXlzLiBSZWNvcmQgaXRzIGRpbWVuc2lvbi4gKi9cblx0XHRcdHNoYXBlLnB1c2goZGF0YS5sZW5ndGgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvKiBPbmx5IGNoZWNrIGRpbWVuc2lvbiAqL1xuXHRcdFx0aWYgKHNoYXBlW2xldmVsXSAhPSBkYXRhLmxlbmd0aCkge1xuXHRcdFx0XHR0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlN1Yi1hcnJheSBcIiArIGRhdGEgKyBcIiBkb2VzIG5vdCBtYXRjaCB0aGUgZXhwZWN0ZWQgZGltZW5zaW9uIG9mIFwiICsgc2hhcGVbbGV2ZWxdKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRkaXNjb3ZlckFycmF5U2hhcGVSZWN1cnNpdmUoZGF0YVtpXSwgc2hhcGUsIGxldmVsICsgMSk7XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdGlmIChsZXZlbCAhPSBzaGFwZS5sZW5ndGgpIHtcblx0XHRcdHRocm93IG5ldyBSYW5nZUVycm9yKFwiU3ViLWFycmF5IFtcIiArIGRhdGEgKyBcIl0gZG9lcyBub3QgbWF0Y2ggdGhlIGV4cGVjdGVkIGRpbWVuc2lvbiBvZiBcIiArIHNoYXBlW2xldmVsXSk7XG5cdFx0fVxuXHRcdGlmICghaXNOdW1iZXIoZGF0YSkpIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoXCJOb24tbnVtZXJpYyBlbGVtZW50OiBcIiArIGRhdGEpO1xuXHRcdH1cblx0fVxufTtcbmV4cG9ydHMuZGlzY292ZXJBcnJheVNoYXBlUmVjdXJzaXZlID0gZGlzY292ZXJBcnJheVNoYXBlUmVjdXJzaXZlO1xuXG52YXIgY29weUFycmF5RGF0YVJlY3Vyc2l2ZSA9IGZ1bmN0aW9uKGRhdGFCdWZmZXIsIGRhdGFBcnJheSwgc2hhcGUsIGxldmVsLCBvZmZzZXQpIHtcblx0dmFyIG4gPSBzaGFwZVtsZXZlbF07XG5cdGlmIChsZXZlbCA9PT0gc2hhcGUubGVuZ3RoIC0gMSkge1xuXHRcdGRhdGFCdWZmZXIuc2V0KGRhdGFBcnJheSwgb2Zmc2V0ICogbik7XG5cdH0gZWxzZSB7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcblx0XHRcdGNvcHlBcnJheURhdGFSZWN1cnNpdmUoZGF0YUJ1ZmZlciwgZGF0YUFycmF5W2ldLCBzaGFwZSwgbGV2ZWwgKyAxLCBvZmZzZXQgKiBuICArIGkpO1xuXHRcdH1cblx0fVxufTtcbmV4cG9ydHMuY29weUFycmF5RGF0YVJlY3Vyc2l2ZSA9IGNvcHlBcnJheURhdGFSZWN1cnNpdmU7XG5cbnZhciBjcmVhdGVBcnJheVJlY3Vyc2l2ZSA9IGZ1bmN0aW9uKGRhdGFCdWZmZXIsIGRhdGFBcnJheSwgc2hhcGUsIGxldmVsLCBvZmZzZXQpIHtcblx0dmFyIG4gPSBzaGFwZVtsZXZlbF07XG5cdGlmIChsZXZlbCA9PT0gc2hhcGUubGVuZ3RoIC0gMSkge1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG5cdFx0XHRkYXRhQXJyYXlbaV0gPSBkYXRhQnVmZmVyW29mZnNldCAqIG4gKyBpXTtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcblx0XHRcdGRhdGFBcnJheVtpXSA9IG5ldyBBcnJheShzaGFwZVtsZXZlbCArIDFdKTtcblx0XHRcdGNyZWF0ZUFycmF5UmVjdXJzaXZlKGRhdGFCdWZmZXIsIGRhdGFBcnJheVtpXSwgc2hhcGUsIGxldmVsICsgMSwgb2Zmc2V0ICogbiAgKyBpKTtcblx0XHR9XG5cdH1cbn07XG5leHBvcnRzLmNyZWF0ZUFycmF5UmVjdXJzaXZlID0gY3JlYXRlQXJyYXlSZWN1cnNpdmU7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIE5EQXJyYXkgPSByZXF1aXJlKFwiLi4vTkRBcnJheVwiKTtcbnZhciBEYXRhVHlwZSA9IHJlcXVpcmUoXCIuLi9EYXRhVHlwZVwiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG5cblxuLyogQnVnZ3kgaW4gQ2hyb21pdW0tV2ViQ0wgKi9cbnZhciB1c2VCdWZmZXJDcmVhdGlvbldpdGhJbml0ID0gZmFsc2U7XG5cbnZhciBpc05vZGVXZWJDTCA9IGZhbHNlO1xudmFyIGNsID0gdm9pZCAwO1xudmFyIGF2YWlsYWJsZURldmljZXMgPSBudWxsO1xudmFyIGF2YWlsYWJsZURldmljZXNEZXNjcmlwdGlvbnMgPSBudWxsO1xudmFyIGRlZmF1bHREZXZpY2VJbmRleCA9IC0xO1xuXG4vKipcbiAqIElmIHRoZSBnbG9iYWwgY2wgdmFyaWFibGUgaXMgdW5kZWZpbmVkLCB0aGlzIG1ldGhvZCB3b3VsZCBpbml0aWFsaXplIGl0IHdpdGggYSBXZWJDTCBpbnN0YW5jZS5cbiAqIFdvcmtzIGZvciBib3RoIGJyb3dzZXIgYW5kIE5vZGUuanNcbiAqXG4gKiBAcHJpdmF0ZVxuICogQHN0YXRpY1xuICogQG1ldGhvZCBpbml0V2ViQ0xcbiAqIEByZXR1cm4ge1dlYkNMfSAtIGFuIGluc3RhbmNlIG9mIFdlYkNMIG9iamVjdCBmcm9tIFdlYkNMIHNwZWNpZmljYXRpb24uIElmIFdlYkNMIGlzIG5vdCBzdXBwb3J0ZWQsIHJldHVybiBudWxsLlxuICovXG52YXIgaW5pdFdlYkNMID0gZnVuY3Rpb24oKSB7XG5cdGlmICh0eXBlb2YgY2wgPT09IFwidW5kZWZpbmVkXCIpIHtcblx0XHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIikge1xuXHRcdFx0Y2wgPSAodHlwZW9mIHdpbmRvdy53ZWJjbCAhPT0gXCJ1bmRlZmluZWRcIikgPyB3aW5kb3cud2ViY2wgOiBudWxsO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRjbCA9IHJlcXVpcmUoXCJub2RlLXdlYmNsXCIpO1xuXHRcdFx0XHRpc05vZGVXZWJDTCA9IHRydWU7XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdGNsID0gbnVsbDtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0cmV0dXJuIGNsO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGVtcHR5IFdlYkNMRXZlbnQuXG4gKiBXb3JrcyBmb3IgYm90aCBicm93c2VyIGFuZCBOb2RlLmpzXG4gKlxuICogQHByaXZhdGVcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgY3JlYXRlRXZlbnRcbiAqIEByZXR1cm4ge1dlYkNMRXZlbnR9IC0gYW4gZW1wdHkgaW5zdGFuY2Ugb2YgV2ViQ0xFdmVudC5cbiAqL1xudmFyIGNyZWF0ZUV2ZW50ID0gZnVuY3Rpb24oKSB7XG5cdGlmIChpc05vZGVXZWJDTCkge1xuXHRcdHJldHVybiBuZXcgY2wuV2ViQ0xFdmVudCgpO1xuXHR9IGVsc2Uge1xuXHRcdHJldHVybiBuZXcgV2ViQ0xFdmVudCgpO1xuXHR9XG59O1xuXG4vKipcbiAqIFRyaWVzIHRvIHJlbGVhc2UgYSBXZWJDTCByZXNvdXJjZSBhbmQgaWdub3JlcyBhbnkgZXJyb3JzIGluIHRoZSBwcm9jZXNzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbWV0aG9kIHRyeVJsZWFzZVxuICogQHBhcmFtIHtPYmplY3R9IHdlYmNsT2JqZWN0IC0gYSBXZWJDTCBvYmplY3QuXG4gKiBAcmV0dXJuIHtCb29sZWFufSAtIHRydWUgaWYgdGhlIG9iamVjdCB3YXMgc3VjY2Vzc2Z1bGx5IHJlbGVhc2VkIGFuZCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbnZhciB0cnlSZWxlYXNlID0gZnVuY3Rpb24od2ViY2xSZXNvdXJjZSkge1xuXHRpZiAod2ViY2xSZXNvdXJjZSAhPT0gbnVsbCkge1xuXHRcdHRyeSB7XG5cdFx0XHR3ZWJjbFJlc291cmNlLnJlbGVhc2UoKTtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdC8qIFNpbGVudGx5IGlnbm9yZSAqL1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIFdlYkNMIGRldmljZSBzdXBwb3J0cyBLSFJfZnA2NCBleHRlbnNpb24uXG4gKlxuICogQHByaXZhdGVcbiAqIEBtZXRob2QgaXNGUDY0Q2FwYWJsZVxuICogQHBhcmFtIHtXZWJDTERldmljZX0gZGV2aWNlIC0gdGhlIGRldmljZSB0byBjaGVjayBmb3IgS0hSX2ZwNjQgc3VwcG9ydC5cbiAqIEByZXR1cm4ge0Jvb2xlYW59IC0gdHJ1ZSBpZiB0aGUgZGV2aWNlIHN1cHBvcnRzIEtIUl9mcDY0IGFuZCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbnZhciBpc0ZQNjRDYXBhYmxlID0gZnVuY3Rpb24oZGV2aWNlKSB7XG5cdHZhciBleHRlbnNpb25zID0gZGV2aWNlLmdldFN1cHBvcnRlZEV4dGVuc2lvbnMoKTtcblx0aWYgKGV4dGVuc2lvbnMuaW5kZXhPZihcIktIUl9mcDY0XCIpID09PSAtMSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXHQvKlxuXHQgKiBEdWUgdG8gYSBidWcgV2ViS2l0LVdlYkNMIG1heSByZXBvcnQgS0hSX2ZwNjQgZXZlbiBpZiBpdCBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoZSB1bmRlcmx5aW5nIE9wZW5DTCBkZXZpY2UuXG5cdCAqIFNlZSBidWcgaHR0cHM6Ly9naXRodWIuY29tL1NSQS1TaWxpY29uVmFsbGV5L3dlYmtpdC13ZWJjbC9pc3N1ZXMvNTM2XG5cdCAqL1xuXHR2YXIgdGVzdFNvdXJjZSA9IFwia2VybmVsIHZvaWQgZm9vKGdsb2JhbCBkb3VibGUqIGJhcikgeyB9XCI7XG5cdHZhciBjb250ZXh0ID0gbnVsbCwgcHJvZ3JhbSA9IG51bGw7XG5cdHRyeSB7XG5cdFx0Y29udGV4dCA9IGNsLmNyZWF0ZUNvbnRleHQoZGV2aWNlKTtcblx0XHRwcm9ncmFtID0gY29udGV4dC5jcmVhdGVQcm9ncmFtKHRlc3RTb3VyY2UpO1xuXHRcdHByb2dyYW0uYnVpbGQoKTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fSBmaW5hbGx5IHtcblx0XHR0cnlSZWxlYXNlKHByb2dyYW0pO1xuXHRcdHRyeVJlbGVhc2UoY29udGV4dCk7XG5cdH1cbn07XG5cbi8qKlxuICogSW5pdGlhbGlzZXMgYW5kIHJldHVybnMgYSBsaXN0IG9mIFdlYkNMIGRldmljZXMgc3VpdGFibGUgZm9yIGNvbXB1dGF0aW9uLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIGdldEF2YWlsYWJsZURldmljZXNcbiAqIEByZXR1cm4ge1dlYkNMRGV2aWNlW119IC0gYSBsaXN0IG9mIEdQVSBhbmQgQ1BVIFdlYkNMIGRldmljZXMgdGhhdCBzdXBwb3J0IEtIUl9GUDY0IChtYXkgYmUgZW1wdHkpLlxuICovXG52YXIgZ2V0QXZhaWxhYmxlRGV2aWNlcyA9IGZ1bmN0aW9uKCkge1xuXHRpZiAoYXZhaWxhYmxlRGV2aWNlcyA9PT0gbnVsbCkge1xuXHRcdGF2YWlsYWJsZURldmljZXMgPSBbXTtcblx0XHR2YXIgd2ViY2wgPSBpbml0V2ViQ0woKTtcblx0XHRpZiAod2ViY2wgIT09IG51bGwpIHtcblx0XHRcdHZhciBwbGF0Zm9ybXMgPSBjbC5nZXRQbGF0Zm9ybXMoKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgcGxhdGZvcm1zLmxlbmd0aDsgKytpKSB7XG5cdFx0XHRcdHZhciBwbGF0Zm9ybSA9IHBsYXRmb3Jtc1tpXTtcblx0XHRcdFx0dmFyIGRldmljZXMgPSBwbGF0Zm9ybS5nZXREZXZpY2VzKGNsLkRFVklDRV9UWVBFX0FMTCk7XG5cdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgZGV2aWNlcy5sZW5ndGg7ICsraikge1xuXHRcdFx0XHRcdHZhciBkZXZpY2UgPSBkZXZpY2VzW2pdO1xuXHRcdFx0XHRcdGlmIChpc0ZQNjRDYXBhYmxlKGRldmljZSkpIHtcblx0XHRcdFx0XHRcdGF2YWlsYWJsZURldmljZXMucHVzaChkZXZpY2UpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRnZW5lcmF0ZUF2YWlsYWJsZURldmljZXNEZXNjcmlwdGlvbnMoKTtcblx0fVxuXHRyZXR1cm4gYXZhaWxhYmxlRGV2aWNlcztcbn07XG5cbnZhciBnZW5lcmF0ZUF2YWlsYWJsZURldmljZXNEZXNjcmlwdGlvbnMgPSBmdW5jdGlvbigpIHtcblx0YXZhaWxhYmxlRGV2aWNlc0Rlc2NyaXB0aW9ucyA9IFtdO1xuXHQvKiBJZiBkZXZpY2VzIG5hbWVzIGFyZSBhdmFpbGFibGUsIHVzZSB0aGVtICovXG5cdHZhciBoYXZlTmFtZXMgPSB0cnVlO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IGF2YWlsYWJsZURldmljZXMubGVuZ3RoOyArK2kpIHtcblx0XHR2YXIgZGV2aWNlID0gYXZhaWxhYmxlRGV2aWNlc1tpXTtcblx0XHR2YXIgbmFtZSA9IGRldmljZS5nZXRJbmZvKGNsLkRFVklDRV9OQU1FKTtcblx0XHRpZiAoKG5hbWUgPT09IG51bGwpIHx8IChuYW1lID09PSBcIlwiKSkge1xuXHRcdFx0aGF2ZU5hbWVzID0gZmFsc2U7XG5cdFx0XHRicmVhaztcblx0XHR9XG5cdFx0YXZhaWxhYmxlRGV2aWNlc0Rlc2NyaXB0aW9uc1tpXSA9IG5hbWU7XG5cdH1cblx0aWYgKCFoYXZlTmFtZXMpIHtcblx0XHQvKiBBdCBsZWFzdCBzb21lIG5hbWVzIGFyZSBub3QgYXZhaWxhYmxlOiB0cnkgdG8gYXNzaWduIG5hbWVzIGJhc2VkIG9uIGNsYXNzaWZpY2F0aW9uIChlLmcuIFwiQ1BVXCIsIFwiZEdQVVwiLCBcImlHUFVcIikgKi9cblx0XHR2YXIgY3B1Q291bnQgPSAwLCBpZ3B1Q291bnQgPSAwLCBkZ3B1Q291bnQgPSAwO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYXZhaWxhYmxlRGV2aWNlcy5sZW5ndGg7ICsraSkge1xuXHRcdFx0dmFyIGRldmljZSA9IGF2YWlsYWJsZURldmljZXNbaV07XG5cdFx0XHR2YXIgY2xhc3NpZmljYXRpb24gPSBjbGFzc2lmeURldmljZShkZXZpY2UpO1xuXHRcdFx0aWYgKGNsYXNzaWZpY2F0aW9uID09PSBcImNwdVwiKSB7XG5cdFx0XHRcdCsrY3B1Q291bnQ7XG5cdFx0XHRcdGF2YWlsYWJsZURldmljZXNEZXNjcmlwdGlvbnNbaV0gPSBcIkNQVVwiO1xuXHRcdFx0fSBlbHNlIGlmIChjbGFzc2lmaWNhdGlvbiA9PT0gXCJpZ3B1XCIpIHtcblx0XHRcdFx0KytpZ3B1Q291bnQ7XG5cdFx0XHRcdGF2YWlsYWJsZURldmljZXNEZXNjcmlwdGlvbnNbaV0gPSBcImlHUFVcIjtcblx0XHRcdH0gZWxzZSBpZiAoY2xhc3NpZmljYXRpb24gPT09IFwiZGdwdVwiKSB7XG5cdFx0XHRcdCsrZGdwdUNvdW50O1xuXHRcdFx0XHRhdmFpbGFibGVEZXZpY2VzRGVzY3JpcHRpb25zW2ldID0gXCJkR1BVXCI7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJJbXBvc3NpYmxlIGRldmljZSBjbGFzc2lmaWNhdGlvbjogXCIgKyBjbGFzc2lmaWNhdGlvbik7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmICgoY3B1Q291bnQgPiAxKSB8fCAoaWdwdUNvdW50ID4gMSkgfHwgKGRncHVDb3VudCA+IDEpKSB7XG5cdFx0XHQvKiBXZSBoYXZlIG11bHRpcGxlIGRldmljZXMgb2YgdGhlIHNhbWUgdHlwZS4gTmVlZCB0byB1c2UgbW9yZSBjb21wbGljYXRlZCBuYW1pbmcgc2NoZW1lICovXG5cdFx0XHR2YXIgY3B1SW5kZXggPSAwLCBpZ3B1SW5kZXggPSAwLCBkZ3B1SW5kZXggPSAwO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhdmFpbGFibGVEZXZpY2VzLmxlbmd0aDsgKytpKSB7XG5cdFx0XHRcdHZhciBkZXZpY2UgPSBhdmFpbGFibGVEZXZpY2VzW2ldO1xuXHRcdFx0XHR2YXIgY2xhc3NpZmljYXRpb24gPSBjbGFzc2lmeURldmljZShkZXZpY2UpO1xuXHRcdFx0XHRpZiAoY2xhc3NpZmljYXRpb24gPT09IFwiY3B1XCIpIHtcblx0XHRcdFx0XHRpZiAoY3B1Q291bnQgPiAxKSB7XG5cdFx0XHRcdFx0XHQrK2NwdUluZGV4O1xuXHRcdFx0XHRcdFx0YXZhaWxhYmxlRGV2aWNlc0Rlc2NyaXB0aW9uc1tpXSA9IFwiQ1BVICNcIiArIGNwdUluZGV4O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIGlmIChjbGFzc2lmaWNhdGlvbiA9PT0gXCJpZ3B1XCIpIHtcblx0XHRcdFx0XHRpZiAoaWdwdUNvdW50ID4gMSkge1xuXHRcdFx0XHRcdFx0KytpZ3B1SW5kZXg7XG5cdFx0XHRcdFx0XHRhdmFpbGFibGVEZXZpY2VzRGVzY3JpcHRpb25zW2ldID0gXCJpR1BVICNcIiArIGlncHVJbmRleDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSBpZiAoY2xhc3NpZmljYXRpb24gPT09IFwiZGdwdVwiKSB7XG5cdFx0XHRcdFx0aWYgKGRncHVDb3VudCA+IDEpIHtcblx0XHRcdFx0XHRcdCsrZGdwdUNvdW50O1xuXHRcdFx0XHRcdFx0YXZhaWxhYmxlRGV2aWNlc0Rlc2NyaXB0aW9uc1tpXSA9IFwiZEdQVSAjXCIgKyBkZ3B1SW5kZXg7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIkltcG9zc2libGUgZGV2aWNlIGNsYXNzaWZpY2F0aW9uOiBcIiArIGNsYXNzaWZpY2F0aW9uKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufTtcblxuLyoqXG4gKiBDbGFzc2lmaWVzIFdlYkNMIGRldmljZSB0byBvbmUgb2YgZm91ciBjYXRlZ29yaWVzOlxuICogLSBcImNwdVwiIGZvciBDUFUgZGV2aWNlcy5cbiAqIC0gXCJpZ3B1XCIgZm9yIEdQVXMgaW50ZWdyYXRlZCB3aXRoIENQVSBwYWNrYWdlIG9yIGNoaXBzZXQuXG4gKiAtIFwiZGdwdVwiIGZvciBkaXNjcmV0ZSBHUFVzLlxuICogLSBcInVua25vd25cIiBmb3Igb3RoZXIgdHlwZXMgb2YgZGV2aWNlcyAoZS5nLiBGUEdBcylcbiAqXG4gKiBAcHJpdmF0ZVxuICogQG1ldGhvZCBjbGFzc2lmeURldmljZVxuICogQHBhcmFtIHtXZWJDTERldmljZX0gZGV2aWNlIC0gdGhlIFdlYkNMIGRldmljZSB0byBjbGFzc2lmeS5cbiAqIEByZXR1cm4ge1N0cmluZ30gLSBvbmUgb2YgdGhlIHN0cmluZ3MgZGVzY3JpYmVkIGFib3ZlLlxuICovXG52YXIgY2xhc3NpZnlEZXZpY2UgPSBmdW5jdGlvbihkZXZpY2UpIHtcblx0dHJ5IHtcblx0XHR2YXIgZGV2aWNlVHlwZSA9IGRldmljZS5nZXRJbmZvKGNsLkRFVklDRV9UWVBFKTtcblx0XHRpZiAoZGV2aWNlVHlwZSA9PT0gY2wuREVWSUNFX1RZUEVfQ1BVKSB7XG5cdFx0XHRyZXR1cm4gXCJjcHVcIjtcblx0XHR9IGVsc2UgaWYgKGRldmljZVR5cGUgPT09IGNsLkRFVklDRV9UWVBFX0dQVSkge1xuXHRcdFx0dmFyIGlzSG9zdFVuaWZpZWRNZW1vcnkgPSBkZXZpY2UuZ2V0SW5mbyhjbC5ERVZJQ0VfSE9TVF9VTklGSUVEX01FTU9SWSk7XG5cdFx0XHRyZXR1cm4gKGlzSG9zdFVuaWZpZWRNZW1vcnkgPyBcImlncHVcIiA6IFwiZGdwdVwiKTtcblx0XHR9XG5cdH0gY2F0Y2ggKGUpIHtcblx0fVxuXHRyZXR1cm4gXCJ1bmtub3duXCI7XG59O1xuXG4vKipcbiAqIFNlbGVjdHMgdGhlIG9wdGltYWwgV2ViQ0wgZGV2aWNlIGFtb25nIHRoZSBhdmFpbGFibGUgZGV2aWNlcy5cbiAqIFRoZSBwcmlvcml0eSBvZiBkZXZpY2VzOiBcImRncHVcIiA+IFwiaWdwdVwiID4gXCJjcHVcIlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbWV0aG9kIGdldERlZmF1bHREZXZpY2VJbmRleFxuICogQHJldHVybiB7V2ViQ0xEZXZpY2V9IC0gdGhlIHNlbGVjdGVkIGRldmljZSBmcm9tIHRoZSBsaXN0LlxuICovXG52YXIgZ2V0RGVmYXVsdERldmljZUluZGV4ID0gZnVuY3Rpb24oKSB7XG5cdGlmIChkZWZhdWx0RGV2aWNlSW5kZXggPT09IC0xKSB7XG5cdFx0dmFyIGF2YWlsYWJsZURldmljZXMgPSBnZXRBdmFpbGFibGVEZXZpY2VzKCk7XG5cdFx0aWYgKGF2YWlsYWJsZURldmljZXMubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRkZWZhdWx0RGV2aWNlSW5kZXggPSAtMjtcblx0XHRcdHJldHVybiBkZWZhdWx0RGV2aWNlSW5kZXg7XG5cdFx0fVxuXHRcdHZhciBkZXZpY2VDbGFzc2lmaWNhdGlvbnMgPSBbXTtcblx0XHQvKiBTZWFyY2ggZm9yIFwiZGdwdVwiICovXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhdmFpbGFibGVEZXZpY2VzLmxlbmd0aDsgKytpKSB7XG5cdFx0XHR2YXIgZGV2aWNlID0gYXZhaWxhYmxlRGV2aWNlc1tpXTtcblx0XHRcdHZhciBkZXZpY2VDbGFzcyA9IGNsYXNzaWZ5RGV2aWNlKGRldmljZSk7XG5cdFx0XHRpZiAoZGV2aWNlQ2xhc3MgPT09IFwiZGdwdVwiKSB7XG5cdFx0XHRcdGRlZmF1bHREZXZpY2VJbmRleCA9IGk7XG5cdFx0XHRcdHJldHVybiBpO1xuXHRcdFx0fVxuXHRcdFx0ZGV2aWNlQ2xhc3NpZmljYXRpb25zLnB1c2goZGV2aWNlQ2xhc3MpO1xuXHRcdH1cblx0XHQvKiBTZWFyY2ggZm9yIFwiaWdwdVwiICovXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhdmFpbGFibGVEZXZpY2VzLmxlbmd0aDsgKytpKSB7XG5cdFx0XHRpZiAoZGV2aWNlQ2xhc3NpZmljYXRpb25zW2ldID09PSBcImlncHVcIikge1xuXHRcdFx0XHRkZWZhdWx0RGV2aWNlSW5kZXggPSBpO1xuXHRcdFx0XHRyZXR1cm4gaTtcblx0XHRcdH1cblx0XHR9XG5cdFx0LyogU2VhcmNoIGZvciBcImNwdVwiICovXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhdmFpbGFibGVEZXZpY2VzLmxlbmd0aDsgKytpKSB7XG5cdFx0XHRpZiAoZGV2aWNlQ2xhc3NpZmljYXRpb25zW2ldID09PSBcImNwdVwiKSB7XG5cdFx0XHRcdGRlZmF1bHREZXZpY2VJbmRleCA9IGk7XG5cdFx0XHRcdHJldHVybiBpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRyZXR1cm4gZGVmYXVsdERldmljZUluZGV4O1xufTtcblxudmFyIGNyZWF0ZUtlcm5lbHMgPSBmdW5jdGlvbihwcm9ncmFtKSB7XG5cdHZhciBrZXJuZWxzID0ge1xuXHRcdHNldDoge1xuXHRcdFx0ZjMyOiBwcm9ncmFtLmNyZWF0ZUtlcm5lbChcInNldF9mMzJcIiksXG5cdFx0XHRmNjQ6IHByb2dyYW0uY3JlYXRlS2VybmVsKFwic2V0X2Y2NFwiKVxuXHRcdH0sXG5cdFx0bGluc3BhY2U6IHtcblx0XHRcdGYzMjogcHJvZ3JhbS5jcmVhdGVLZXJuZWwoXCJsaW5zcGFjZV9mMzJcIiksXG5cdFx0XHRmNjQ6IHByb2dyYW0uY3JlYXRlS2VybmVsKFwibGluc3BhY2VfZjY0XCIpXG5cdFx0fSxcblx0XHRyZXBlYXQ6IHtcblx0XHRcdGYzMjogcHJvZ3JhbS5jcmVhdGVLZXJuZWwoXCJyZXBlYXRfZjMyXCIpLFxuXHRcdFx0ZjY0OiBwcm9ncmFtLmNyZWF0ZUtlcm5lbChcInJlcGVhdF9mNjRcIilcblx0XHR9LFxuXHRcdGFkZDoge1xuXHRcdFx0ZjMyOiBwcm9ncmFtLmNyZWF0ZUtlcm5lbChcImFkZF9mMzJcIiksXG5cdFx0XHRmNjQ6IHByb2dyYW0uY3JlYXRlS2VybmVsKFwiYWRkX2Y2NFwiKVxuXHRcdH0sXG5cdFx0c3ViOiB7XG5cdFx0XHRmMzI6IHByb2dyYW0uY3JlYXRlS2VybmVsKFwic3ViX2YzMlwiKSxcblx0XHRcdGY2NDogcHJvZ3JhbS5jcmVhdGVLZXJuZWwoXCJzdWJfZjY0XCIpXG5cdFx0fSxcblx0XHRtdWw6IHtcblx0XHRcdGYzMjogcHJvZ3JhbS5jcmVhdGVLZXJuZWwoXCJtdWxfZjMyXCIpLFxuXHRcdFx0ZjY0OiBwcm9ncmFtLmNyZWF0ZUtlcm5lbChcIm11bF9mNjRcIilcblx0XHR9LFxuXHRcdGRpdjoge1xuXHRcdFx0ZjMyOiBwcm9ncmFtLmNyZWF0ZUtlcm5lbChcImRpdl9mMzJcIiksXG5cdFx0XHRmNjQ6IHByb2dyYW0uY3JlYXRlS2VybmVsKFwiZGl2X2Y2NFwiKVxuXHRcdH0sXG5cdFx0YWRkYzoge1xuXHRcdFx0ZjMyOiBwcm9ncmFtLmNyZWF0ZUtlcm5lbChcImFkZGNfZjMyXCIpLFxuXHRcdFx0ZjY0OiBwcm9ncmFtLmNyZWF0ZUtlcm5lbChcImFkZGNfZjY0XCIpXG5cdFx0fSxcblx0XHRzdWJjOiB7XG5cdFx0XHRmMzI6IHByb2dyYW0uY3JlYXRlS2VybmVsKFwic3ViY19mMzJcIiksXG5cdFx0XHRmNjQ6IHByb2dyYW0uY3JlYXRlS2VybmVsKFwic3ViY19mNjRcIilcblx0XHR9LFxuXHRcdHN1YnJjOiB7XG5cdFx0XHRmMzI6IHByb2dyYW0uY3JlYXRlS2VybmVsKFwic3VicmNfZjMyXCIpLFxuXHRcdFx0ZjY0OiBwcm9ncmFtLmNyZWF0ZUtlcm5lbChcInN1YnJjX2Y2NFwiKVxuXHRcdH0sXG5cdFx0bXVsYzoge1xuXHRcdFx0ZjMyOiBwcm9ncmFtLmNyZWF0ZUtlcm5lbChcIm11bGNfZjMyXCIpLFxuXHRcdFx0ZjY0OiBwcm9ncmFtLmNyZWF0ZUtlcm5lbChcIm11bGNfZjY0XCIpXG5cdFx0fSxcblx0XHRkaXZjOiB7XG5cdFx0XHRmMzI6IHByb2dyYW0uY3JlYXRlS2VybmVsKFwiZGl2Y19mMzJcIiksXG5cdFx0XHRmNjQ6IHByb2dyYW0uY3JlYXRlS2VybmVsKFwiZGl2Y19mNjRcIilcblx0XHR9LFxuXHRcdGRpdnJjOiB7XG5cdFx0XHRmMzI6IHByb2dyYW0uY3JlYXRlS2VybmVsKFwiZGl2cmNfZjMyXCIpLFxuXHRcdFx0ZjY0OiBwcm9ncmFtLmNyZWF0ZUtlcm5lbChcImRpdnJjX2Y2NFwiKVxuXHRcdH0sXG5cdFx0bmVnOiB7XG5cdFx0XHRmMzI6IHByb2dyYW0uY3JlYXRlS2VybmVsKFwibmVnX2YzMlwiKSxcblx0XHRcdGY2NDogcHJvZ3JhbS5jcmVhdGVLZXJuZWwoXCJuZWdfZjY0XCIpXG5cdFx0fSxcblx0XHRhYnM6IHtcblx0XHRcdGYzMjogcHJvZ3JhbS5jcmVhdGVLZXJuZWwoXCJhYnNfZjMyXCIpLFxuXHRcdFx0ZjY0OiBwcm9ncmFtLmNyZWF0ZUtlcm5lbChcImFic19mNjRcIilcblx0XHR9LFxuXHRcdGV4cDoge1xuXHRcdFx0ZjMyOiBwcm9ncmFtLmNyZWF0ZUtlcm5lbChcImV4cF9mMzJcIiksXG5cdFx0XHRmNjQ6IHByb2dyYW0uY3JlYXRlS2VybmVsKFwiZXhwX2Y2NFwiKVxuXHRcdH0sXG5cdFx0bG9nOiB7XG5cdFx0XHRmMzI6IHByb2dyYW0uY3JlYXRlS2VybmVsKFwibG9nX2YzMlwiKSxcblx0XHRcdGY2NDogcHJvZ3JhbS5jcmVhdGVLZXJuZWwoXCJsb2dfZjY0XCIpXG5cdFx0fSxcblx0XHRzcXJ0OiB7XG5cdFx0XHRmMzI6IHByb2dyYW0uY3JlYXRlS2VybmVsKFwic3FydF9mMzJcIiksXG5cdFx0XHRmNjQ6IHByb2dyYW0uY3JlYXRlS2VybmVsKFwic3FydF9mNjRcIilcblx0XHR9LFxuXHRcdHNxdWFyZToge1xuXHRcdFx0ZjMyOiBwcm9ncmFtLmNyZWF0ZUtlcm5lbChcInNxdWFyZV9mMzJcIiksXG5cdFx0XHRmNjQ6IHByb2dyYW0uY3JlYXRlS2VybmVsKFwic3F1YXJlX2Y2NFwiKVxuXHRcdH0sXG5cdFx0c3VtOiB7XG5cdFx0XHRmMzI6IHByb2dyYW0uY3JlYXRlS2VybmVsKFwic3VtX2YzMl9ncHVcIiksXG5cdFx0XHRmNjQ6IHByb2dyYW0uY3JlYXRlS2VybmVsKFwic3VtX2Y2NF9ncHVcIilcblx0XHR9LFxuXHRcdG1pbjoge1xuXHRcdFx0ZjMyOiBwcm9ncmFtLmNyZWF0ZUtlcm5lbChcIm1pbl9mMzJfZ3B1XCIpLFxuXHRcdFx0ZjY0OiBwcm9ncmFtLmNyZWF0ZUtlcm5lbChcIm1pbl9mNjRfZ3B1XCIpXG5cdFx0fSxcblx0XHRtYXg6IHtcblx0XHRcdGYzMjogcHJvZ3JhbS5jcmVhdGVLZXJuZWwoXCJtYXhfZjMyX2dwdVwiKSxcblx0XHRcdGY2NDogcHJvZ3JhbS5jcmVhdGVLZXJuZWwoXCJtYXhfZjY0X2dwdVwiKVxuXHRcdH0sXG5cdFx0YXN1bToge1xuXHRcdFx0ZjMyOiBwcm9ncmFtLmNyZWF0ZUtlcm5lbChcImFzdW1fZjMyXCIpLFxuXHRcdFx0ZjY0OiBwcm9ncmFtLmNyZWF0ZUtlcm5lbChcImFzdW1fZjY0XCIpXG5cdFx0fSxcblx0XHRhbWluOiB7XG5cdFx0XHRmMzI6IHByb2dyYW0uY3JlYXRlS2VybmVsKFwiYW1pbl9mMzJcIiksXG5cdFx0XHRmNjQ6IHByb2dyYW0uY3JlYXRlS2VybmVsKFwiYW1pbl9mNjRcIilcblx0XHR9LFxuXHRcdGFtYXg6IHtcblx0XHRcdGYzMjogcHJvZ3JhbS5jcmVhdGVLZXJuZWwoXCJhbWF4X2YzMlwiKSxcblx0XHRcdGY2NDogcHJvZ3JhbS5jcmVhdGVLZXJuZWwoXCJhbWF4X2Y2NFwiKVxuXHRcdH0sXG5cdFx0ZG90OiB7XG5cdFx0XHRmMzI6IHByb2dyYW0uY3JlYXRlS2VybmVsKFwiZG90X2YzMlwiKSxcblx0XHRcdGY2NDogcHJvZ3JhbS5jcmVhdGVLZXJuZWwoXCJkb3RfZjY0XCIpXG5cdFx0fVxuXHR9O1xuXHRyZXR1cm4ga2VybmVscztcbn07XG5cbmZ1bmN0aW9uIFdlYkNMQ29udGV4dChvcHRpb25zLCBjYWxsYmFjaykge1xuXHRpbml0V2ViQ0woKTtcblx0dmFyIGJpbmFyeUtlcm5lbHNTb3VyY2UgPSBcImtlcm5lbCB2b2lkIGFkZF9mMzIoXFxuXFx0dWludCBsZW5ndGgsXFxuXFx0Z2xvYmFsIGZsb2F0KiBhLFxcblxcdGdsb2JhbCBmbG9hdCogYixcXG5cXHRnbG9iYWwgZmxvYXQqIG91dClcXG57XFxuXFx0Y29uc3QgdWludCBpZCA9IGdldF9nbG9iYWxfaWQoMCk7XFxuXFx0aWYgKGlkIDwgbGVuZ3RoKSB7XFxuXFx0XFx0b3V0W2lkXSA9IGFbaWRdICsgYltpZF07XFxuXFx0fVxcbn1cXG5rZXJuZWwgdm9pZCBhZGRfZjY0KFxcblxcdHVpbnQgbGVuZ3RoLFxcblxcdGdsb2JhbCBkb3VibGUqIGEsXFxuXFx0Z2xvYmFsIGRvdWJsZSogYixcXG5cXHRnbG9iYWwgZG91YmxlKiBvdXQpXFxue1xcblxcdGNvbnN0IHVpbnQgaWQgPSBnZXRfZ2xvYmFsX2lkKDApO1xcblxcdGlmIChpZCA8IGxlbmd0aCkge1xcblxcdFxcdG91dFtpZF0gPSBhW2lkXSArIGJbaWRdO1xcblxcdH1cXG59XFxua2VybmVsIHZvaWQgc3ViX2YzMihcXG5cXHR1aW50IGxlbmd0aCxcXG5cXHRnbG9iYWwgZmxvYXQqIGEsXFxuXFx0Z2xvYmFsIGZsb2F0KiBiLFxcblxcdGdsb2JhbCBmbG9hdCogb3V0KVxcbntcXG5cXHRjb25zdCB1aW50IGlkID0gZ2V0X2dsb2JhbF9pZCgwKTtcXG5cXHRpZiAoaWQgPCBsZW5ndGgpIHtcXG5cXHRcXHRvdXRbaWRdID0gYVtpZF0gLSBiW2lkXTtcXG5cXHR9XFxufVxcbmtlcm5lbCB2b2lkIHN1Yl9mNjQoXFxuXFx0dWludCBsZW5ndGgsXFxuXFx0Z2xvYmFsIGRvdWJsZSogYSxcXG5cXHRnbG9iYWwgZG91YmxlKiBiLFxcblxcdGdsb2JhbCBkb3VibGUqIG91dClcXG57XFxuXFx0Y29uc3QgdWludCBpZCA9IGdldF9nbG9iYWxfaWQoMCk7XFxuXFx0aWYgKGlkIDwgbGVuZ3RoKSB7XFxuXFx0XFx0b3V0W2lkXSA9IGFbaWRdIC0gYltpZF07XFxuXFx0fVxcbn1cXG5rZXJuZWwgdm9pZCBtdWxfZjMyKFxcblxcdHVpbnQgbGVuZ3RoLFxcblxcdGdsb2JhbCBmbG9hdCogYSxcXG5cXHRnbG9iYWwgZmxvYXQqIGIsXFxuXFx0Z2xvYmFsIGZsb2F0KiBvdXQpXFxue1xcblxcdGNvbnN0IHVpbnQgaWQgPSBnZXRfZ2xvYmFsX2lkKDApO1xcblxcdGlmIChpZCA8IGxlbmd0aCkge1xcblxcdFxcdG91dFtpZF0gPSBhW2lkXSAqIGJbaWRdO1xcblxcdH1cXG59XFxua2VybmVsIHZvaWQgbXVsX2Y2NChcXG5cXHR1aW50IGxlbmd0aCxcXG5cXHRnbG9iYWwgZG91YmxlKiBhLFxcblxcdGdsb2JhbCBkb3VibGUqIGIsXFxuXFx0Z2xvYmFsIGRvdWJsZSogb3V0KVxcbntcXG5cXHRjb25zdCB1aW50IGlkID0gZ2V0X2dsb2JhbF9pZCgwKTtcXG5cXHRpZiAoaWQgPCBsZW5ndGgpIHtcXG5cXHRcXHRvdXRbaWRdID0gYVtpZF0gKiBiW2lkXTtcXG5cXHR9XFxufVxcbmtlcm5lbCB2b2lkIGRpdl9mMzIoXFxuXFx0dWludCBsZW5ndGgsXFxuXFx0Z2xvYmFsIGZsb2F0KiBhLFxcblxcdGdsb2JhbCBmbG9hdCogYixcXG5cXHRnbG9iYWwgZmxvYXQqIG91dClcXG57XFxuXFx0Y29uc3QgdWludCBpZCA9IGdldF9nbG9iYWxfaWQoMCk7XFxuXFx0aWYgKGlkIDwgbGVuZ3RoKSB7XFxuXFx0XFx0b3V0W2lkXSA9IGFbaWRdIC8gYltpZF07XFxuXFx0fVxcbn1cXG5rZXJuZWwgdm9pZCBkaXZfZjY0KFxcblxcdHVpbnQgbGVuZ3RoLFxcblxcdGdsb2JhbCBkb3VibGUqIGEsXFxuXFx0Z2xvYmFsIGRvdWJsZSogYixcXG5cXHRnbG9iYWwgZG91YmxlKiBvdXQpXFxue1xcblxcdGNvbnN0IHVpbnQgaWQgPSBnZXRfZ2xvYmFsX2lkKDApO1xcblxcdGlmIChpZCA8IGxlbmd0aCkge1xcblxcdFxcdG91dFtpZF0gPSBhW2lkXSAvIGJbaWRdO1xcblxcdH1cXG59XFxua2VybmVsIHZvaWQgYWRkY19mMzIoXFxuXFx0dWludCBsZW5ndGgsXFxuXFx0Z2xvYmFsIGZsb2F0KiBhLFxcblxcdGZsb2F0IGIsXFxuXFx0Z2xvYmFsIGZsb2F0KiBvdXQpXFxue1xcblxcdGNvbnN0IHVpbnQgaWQgPSBnZXRfZ2xvYmFsX2lkKDApO1xcblxcdGlmIChpZCA8IGxlbmd0aCkge1xcblxcdFxcdG91dFtpZF0gPSBhW2lkXSArIGI7XFxuXFx0fVxcbn1cXG5rZXJuZWwgdm9pZCBhZGRjX2Y2NChcXG5cXHR1aW50IGxlbmd0aCxcXG5cXHRnbG9iYWwgZG91YmxlKiBhLFxcblxcdGRvdWJsZSBiLFxcblxcdGdsb2JhbCBkb3VibGUqIG91dClcXG57XFxuXFx0Y29uc3QgdWludCBpZCA9IGdldF9nbG9iYWxfaWQoMCk7XFxuXFx0aWYgKGlkIDwgbGVuZ3RoKSB7XFxuXFx0XFx0b3V0W2lkXSA9IGFbaWRdICsgYjtcXG5cXHR9XFxufVxcbmtlcm5lbCB2b2lkIHN1YmNfZjMyKFxcblxcdHVpbnQgbGVuZ3RoLFxcblxcdGdsb2JhbCBmbG9hdCogYSxcXG5cXHRmbG9hdCBiLFxcblxcdGdsb2JhbCBmbG9hdCogb3V0KVxcbntcXG5cXHRjb25zdCB1aW50IGlkID0gZ2V0X2dsb2JhbF9pZCgwKTtcXG5cXHRpZiAoaWQgPCBsZW5ndGgpIHtcXG5cXHRcXHRvdXRbaWRdID0gYVtpZF0gLSBiO1xcblxcdH1cXG59XFxua2VybmVsIHZvaWQgc3ViY19mNjQoXFxuXFx0dWludCBsZW5ndGgsXFxuXFx0Z2xvYmFsIGRvdWJsZSogYSxcXG5cXHRkb3VibGUgYixcXG5cXHRnbG9iYWwgZG91YmxlKiBvdXQpXFxue1xcblxcdGNvbnN0IHVpbnQgaWQgPSBnZXRfZ2xvYmFsX2lkKDApO1xcblxcdGlmIChpZCA8IGxlbmd0aCkge1xcblxcdFxcdG91dFtpZF0gPSBhW2lkXSAtIGI7XFxuXFx0fVxcbn1cXG5rZXJuZWwgdm9pZCBzdWJyY19mMzIoXFxuXFx0dWludCBsZW5ndGgsXFxuXFx0Z2xvYmFsIGZsb2F0KiBhLFxcblxcdGZsb2F0IGIsXFxuXFx0Z2xvYmFsIGZsb2F0KiBvdXQpXFxue1xcblxcdGNvbnN0IHVpbnQgaWQgPSBnZXRfZ2xvYmFsX2lkKDApO1xcblxcdGlmIChpZCA8IGxlbmd0aCkge1xcblxcdFxcdG91dFtpZF0gPSBiIC8gYVtpZF07XFxuXFx0fVxcbn1cXG5rZXJuZWwgdm9pZCBzdWJyY19mNjQoXFxuXFx0dWludCBsZW5ndGgsXFxuXFx0Z2xvYmFsIGRvdWJsZSogYSxcXG5cXHRkb3VibGUgYixcXG5cXHRnbG9iYWwgZG91YmxlKiBvdXQpXFxue1xcblxcdGNvbnN0IHVpbnQgaWQgPSBnZXRfZ2xvYmFsX2lkKDApO1xcblxcdGlmIChpZCA8IGxlbmd0aCkge1xcblxcdFxcdG91dFtpZF0gPSBiIC8gYVtpZF07XFxuXFx0fVxcbn1cXG5rZXJuZWwgdm9pZCBtdWxjX2YzMihcXG5cXHR1aW50IGxlbmd0aCxcXG5cXHRnbG9iYWwgZmxvYXQqIGEsXFxuXFx0ZmxvYXQgYixcXG5cXHRnbG9iYWwgZmxvYXQqIG91dClcXG57XFxuXFx0Y29uc3QgdWludCBpZCA9IGdldF9nbG9iYWxfaWQoMCk7XFxuXFx0aWYgKGlkIDwgbGVuZ3RoKSB7XFxuXFx0XFx0b3V0W2lkXSA9IGFbaWRdICogYjtcXG5cXHR9XFxufVxcbmtlcm5lbCB2b2lkIG11bGNfZjY0KFxcblxcdHVpbnQgbGVuZ3RoLFxcblxcdGdsb2JhbCBkb3VibGUqIGEsXFxuXFx0ZG91YmxlIGIsXFxuXFx0Z2xvYmFsIGRvdWJsZSogb3V0KVxcbntcXG5cXHRjb25zdCB1aW50IGlkID0gZ2V0X2dsb2JhbF9pZCgwKTtcXG5cXHRpZiAoaWQgPCBsZW5ndGgpIHtcXG5cXHRcXHRvdXRbaWRdID0gYVtpZF0gKiBiO1xcblxcdH1cXG59XFxua2VybmVsIHZvaWQgZGl2Y19mMzIoXFxuXFx0dWludCBsZW5ndGgsXFxuXFx0Z2xvYmFsIGZsb2F0KiBhLFxcblxcdGZsb2F0IGIsXFxuXFx0Z2xvYmFsIGZsb2F0KiBvdXQpXFxue1xcblxcdGNvbnN0IHVpbnQgaWQgPSBnZXRfZ2xvYmFsX2lkKDApO1xcblxcdGlmIChpZCA8IGxlbmd0aCkge1xcblxcdFxcdG91dFtpZF0gPSBhW2lkXSAvIGI7XFxuXFx0fVxcbn1cXG5rZXJuZWwgdm9pZCBkaXZjX2Y2NChcXG5cXHR1aW50IGxlbmd0aCxcXG5cXHRnbG9iYWwgZG91YmxlKiBhLFxcblxcdGRvdWJsZSBiLFxcblxcdGdsb2JhbCBkb3VibGUqIG91dClcXG57XFxuXFx0Y29uc3QgdWludCBpZCA9IGdldF9nbG9iYWxfaWQoMCk7XFxuXFx0aWYgKGlkIDwgbGVuZ3RoKSB7XFxuXFx0XFx0b3V0W2lkXSA9IGFbaWRdIC8gYjtcXG5cXHR9XFxufVxcbmtlcm5lbCB2b2lkIGRpdnJjX2YzMihcXG5cXHR1aW50IGxlbmd0aCxcXG5cXHRnbG9iYWwgZmxvYXQqIGEsXFxuXFx0ZmxvYXQgYixcXG5cXHRnbG9iYWwgZmxvYXQqIG91dClcXG57XFxuXFx0Y29uc3QgdWludCBpZCA9IGdldF9nbG9iYWxfaWQoMCk7XFxuXFx0aWYgKGlkIDwgbGVuZ3RoKSB7XFxuXFx0XFx0b3V0W2lkXSA9IGIgLyBhW2lkXTtcXG5cXHR9XFxufVxcbmtlcm5lbCB2b2lkIGRpdnJjX2Y2NChcXG5cXHR1aW50IGxlbmd0aCxcXG5cXHRnbG9iYWwgZG91YmxlKiBhLFxcblxcdGRvdWJsZSBiLFxcblxcdGdsb2JhbCBkb3VibGUqIG91dClcXG57XFxuXFx0Y29uc3QgdWludCBpZCA9IGdldF9nbG9iYWxfaWQoMCk7XFxuXFx0aWYgKGlkIDwgbGVuZ3RoKSB7XFxuXFx0XFx0b3V0W2lkXSA9IGIgLyBhW2lkXTtcXG5cXHR9XFxufVxcblwiO1xuXHR2YXIgdW5hcnlLZXJuZWxzU291cmNlID0gXCJrZXJuZWwgdm9pZCBuZWdfZjMyKFxcblxcdHVpbnQgbGVuZ3RoLFxcblxcdGdsb2JhbCBmbG9hdCogYSxcXG5cXHRnbG9iYWwgZmxvYXQqIG91dClcXG57XFxuXFx0Y29uc3QgdWludCBpZCA9IGdldF9nbG9iYWxfaWQoMCk7XFxuXFx0aWYgKGlkIDwgbGVuZ3RoKSB7XFxuXFx0XFx0b3V0W2lkXSA9IC1hW2lkXTtcXG5cXHR9XFxufVxcbmtlcm5lbCB2b2lkIG5lZ19mNjQoXFxuXFx0dWludCBsZW5ndGgsXFxuXFx0Z2xvYmFsIGRvdWJsZSogYSxcXG5cXHRnbG9iYWwgZG91YmxlKiBvdXQpXFxue1xcblxcdGNvbnN0IHVpbnQgaWQgPSBnZXRfZ2xvYmFsX2lkKDApO1xcblxcdGlmIChpZCA8IGxlbmd0aCkge1xcblxcdFxcdG91dFtpZF0gPSAtYVtpZF07XFxuXFx0fVxcbn1cXG5rZXJuZWwgdm9pZCBhYnNfZjMyKFxcblxcdHVpbnQgbGVuZ3RoLFxcblxcdGdsb2JhbCBmbG9hdCogYSxcXG5cXHRnbG9iYWwgZmxvYXQqIG91dClcXG57XFxuXFx0Y29uc3QgdWludCBpZCA9IGdldF9nbG9iYWxfaWQoMCk7XFxuXFx0aWYgKGlkIDwgbGVuZ3RoKSB7XFxuXFx0XFx0b3V0W2lkXSA9IGZhYnMoYVtpZF0pO1xcblxcdH1cXG59XFxua2VybmVsIHZvaWQgYWJzX2Y2NChcXG5cXHR1aW50IGxlbmd0aCxcXG5cXHRnbG9iYWwgZG91YmxlKiBhLFxcblxcdGdsb2JhbCBkb3VibGUqIG91dClcXG57XFxuXFx0Y29uc3QgdWludCBpZCA9IGdldF9nbG9iYWxfaWQoMCk7XFxuXFx0aWYgKGlkIDwgbGVuZ3RoKSB7XFxuXFx0XFx0b3V0W2lkXSA9IGZhYnMoYVtpZF0pO1xcblxcdH1cXG59XFxua2VybmVsIHZvaWQgZXhwX2YzMihcXG5cXHR1aW50IGxlbmd0aCxcXG5cXHRnbG9iYWwgZmxvYXQqIGEsXFxuXFx0Z2xvYmFsIGZsb2F0KiBvdXQpXFxue1xcblxcdGNvbnN0IHVpbnQgaWQgPSBnZXRfZ2xvYmFsX2lkKDApO1xcblxcdGlmIChpZCA8IGxlbmd0aCkge1xcblxcdFxcdG91dFtpZF0gPSBleHAoYVtpZF0pO1xcblxcdH1cXG59XFxua2VybmVsIHZvaWQgZXhwX2Y2NChcXG5cXHR1aW50IGxlbmd0aCxcXG5cXHRnbG9iYWwgZG91YmxlKiBhLFxcblxcdGdsb2JhbCBkb3VibGUqIG91dClcXG57XFxuXFx0Y29uc3QgdWludCBpZCA9IGdldF9nbG9iYWxfaWQoMCk7XFxuXFx0aWYgKGlkIDwgbGVuZ3RoKSB7XFxuXFx0XFx0b3V0W2lkXSA9IGV4cChhW2lkXSk7XFxuXFx0fVxcbn1cXG5rZXJuZWwgdm9pZCBsb2dfZjMyKFxcblxcdHVpbnQgbGVuZ3RoLFxcblxcdGdsb2JhbCBmbG9hdCogYSxcXG5cXHRnbG9iYWwgZmxvYXQqIG91dClcXG57XFxuXFx0Y29uc3QgdWludCBpZCA9IGdldF9nbG9iYWxfaWQoMCk7XFxuXFx0aWYgKGlkIDwgbGVuZ3RoKSB7XFxuXFx0XFx0b3V0W2lkXSA9IGxvZyhhW2lkXSk7XFxuXFx0fVxcbn1cXG5rZXJuZWwgdm9pZCBsb2dfZjY0KFxcblxcdHVpbnQgbGVuZ3RoLFxcblxcdGdsb2JhbCBkb3VibGUqIGEsXFxuXFx0Z2xvYmFsIGRvdWJsZSogb3V0KVxcbntcXG5cXHRjb25zdCB1aW50IGlkID0gZ2V0X2dsb2JhbF9pZCgwKTtcXG5cXHRpZiAoaWQgPCBsZW5ndGgpIHtcXG5cXHRcXHRvdXRbaWRdID0gbG9nKGFbaWRdKTtcXG5cXHR9XFxufVxcbmtlcm5lbCB2b2lkIHNxcnRfZjMyKFxcblxcdHVpbnQgbGVuZ3RoLFxcblxcdGdsb2JhbCBmbG9hdCogYSxcXG5cXHRnbG9iYWwgZmxvYXQqIG91dClcXG57XFxuXFx0Y29uc3QgdWludCBpZCA9IGdldF9nbG9iYWxfaWQoMCk7XFxuXFx0aWYgKGlkIDwgbGVuZ3RoKSB7XFxuXFx0XFx0b3V0W2lkXSA9IHNxcnQoYVtpZF0pO1xcblxcdH1cXG59XFxua2VybmVsIHZvaWQgc3FydF9mNjQoXFxuXFx0dWludCBsZW5ndGgsXFxuXFx0Z2xvYmFsIGRvdWJsZSogYSxcXG5cXHRnbG9iYWwgZG91YmxlKiBvdXQpXFxue1xcblxcdGNvbnN0IHVpbnQgaWQgPSBnZXRfZ2xvYmFsX2lkKDApO1xcblxcdGlmIChpZCA8IGxlbmd0aCkge1xcblxcdFxcdG91dFtpZF0gPSBzcXJ0KGFbaWRdKTtcXG5cXHR9XFxufVxcbmtlcm5lbCB2b2lkIHNxdWFyZV9mMzIoXFxuXFx0dWludCBsZW5ndGgsXFxuXFx0Z2xvYmFsIGZsb2F0KiBhLFxcblxcdGdsb2JhbCBmbG9hdCogb3V0KVxcbntcXG5cXHRjb25zdCB1aW50IGlkID0gZ2V0X2dsb2JhbF9pZCgwKTtcXG5cXHRpZiAoaWQgPCBsZW5ndGgpIHtcXG5cXHRcXHRjb25zdCBmbG9hdCBhVmFsID0gYVtpZF07IFxcblxcdFxcdG91dFtpZF0gPSBhVmFsICogYVZhbDtcXG5cXHR9XFxufVxcbmtlcm5lbCB2b2lkIHNxdWFyZV9mNjQoXFxuXFx0dWludCBsZW5ndGgsXFxuXFx0Z2xvYmFsIGRvdWJsZSogYSxcXG5cXHRnbG9iYWwgZG91YmxlKiBvdXQpXFxue1xcblxcdGNvbnN0IHVpbnQgaWQgPSBnZXRfZ2xvYmFsX2lkKDApO1xcblxcdGlmIChpZCA8IGxlbmd0aCkge1xcblxcdFxcdGNvbnN0IGRvdWJsZSBhVmFsID0gYVtpZF07XFxuXFx0XFx0b3V0W2lkXSA9IGFWYWwgKiBhVmFsO1xcblxcdH1cXG59XFxuXCI7XG5cdHZhciByZWR1Y3Rpb25LZXJuZWxzU291cmNlID0gXCJrZXJuZWwgdm9pZCBzdW1fZjMyX2dwdShcXG5cXHR1aW50IGxlbmd0aCxcXG5cXHRnbG9iYWwgZmxvYXQqIGEsXFxuXFx0bG9jYWwgZmxvYXQqIHNjcmF0Y2gsXFxuXFx0Z2xvYmFsIGZsb2F0KiBvdXQpXFxue1xcblxcdGNvbnN0IHVpbnQgZ2xvYmFsU2l6ZSA9IGdldF9nbG9iYWxfc2l6ZSgwKTtcXG5cXHR1aW50IGdsb2JhbEluZGV4ID0gZ2V0X2dsb2JhbF9pZCgwKTtcXG5cXHRmbG9hdCBhY2N1bXVsYXRvciA9IDAuMGY7XFxuXFx0d2hpbGUgKGdsb2JhbEluZGV4IDwgbGVuZ3RoKSB7XFxuXFx0XFx0YWNjdW11bGF0b3IgKz0gYVtnbG9iYWxJbmRleF07XFxuXFx0XFx0Z2xvYmFsSW5kZXggKz0gZ2xvYmFsU2l6ZTtcXG5cXHR9XFxuXFxuXFx0dWludCBsb2NhbEluZGV4ID0gZ2V0X2xvY2FsX2lkKDApO1xcblxcdHNjcmF0Y2hbbG9jYWxJbmRleF0gPSBhY2N1bXVsYXRvcjtcXG5cXHRiYXJyaWVyKENMS19MT0NBTF9NRU1fRkVOQ0UpO1xcblxcdGZvciAodWludCBvZmZzZXQgPSBnZXRfbG9jYWxfc2l6ZSgwKSAvIDI7IG9mZnNldCAhPSAwOyBvZmZzZXQgPj49IDEpIHtcXG5cXHRcXHRpZiAobG9jYWxJbmRleCA8IG9mZnNldCkge1xcblxcdFxcdFxcdHNjcmF0Y2hbbG9jYWxJbmRleF0gKz0gc2NyYXRjaFtsb2NhbEluZGV4ICsgb2Zmc2V0XTtcXG5cXHRcXHR9XFxuXFx0XFx0YmFycmllcihDTEtfTE9DQUxfTUVNX0ZFTkNFKTtcXG5cXHR9XFxuXFx0aWYgKGxvY2FsSW5kZXggPT0gMCkge1xcblxcdFxcdG91dFtnZXRfZ3JvdXBfaWQoMCldID0gc2NyYXRjaFswXTtcXG5cXHR9XFxufVxcblxcbmtlcm5lbCB2b2lkIHN1bV9mNjRfZ3B1KFxcblxcdHVpbnQgbGVuZ3RoLFxcblxcdGdsb2JhbCBkb3VibGUqIGEsXFxuXFx0bG9jYWwgZG91YmxlKiBzY3JhdGNoLFxcblxcdGdsb2JhbCBkb3VibGUqIG91dClcXG57XFxuXFx0Y29uc3QgdWludCBnbG9iYWxTaXplID0gZ2V0X2dsb2JhbF9zaXplKDApO1xcblxcdHVpbnQgZ2xvYmFsSW5kZXggPSBnZXRfZ2xvYmFsX2lkKDApO1xcblxcdGRvdWJsZSBhY2N1bXVsYXRvciA9IDAuMDtcXG5cXHR3aGlsZSAoZ2xvYmFsSW5kZXggPCBsZW5ndGgpIHtcXG5cXHRcXHRhY2N1bXVsYXRvciArPSBhW2dsb2JhbEluZGV4XTtcXG5cXHRcXHRnbG9iYWxJbmRleCArPSBnbG9iYWxTaXplO1xcblxcdH1cXG5cXG5cXHR1aW50IGxvY2FsSW5kZXggPSBnZXRfbG9jYWxfaWQoMCk7XFxuXFx0c2NyYXRjaFtsb2NhbEluZGV4XSA9IGFjY3VtdWxhdG9yO1xcblxcdGJhcnJpZXIoQ0xLX0xPQ0FMX01FTV9GRU5DRSk7XFxuXFx0Zm9yICh1aW50IG9mZnNldCA9IGdldF9sb2NhbF9zaXplKDApIC8gMjsgb2Zmc2V0ICE9IDA7IG9mZnNldCA+Pj0gMSkge1xcblxcdFxcdGlmIChsb2NhbEluZGV4IDwgb2Zmc2V0KSB7XFxuXFx0XFx0XFx0c2NyYXRjaFtsb2NhbEluZGV4XSArPSBzY3JhdGNoW2xvY2FsSW5kZXggKyBvZmZzZXRdO1xcblxcdFxcdH1cXG5cXHRcXHRiYXJyaWVyKENMS19MT0NBTF9NRU1fRkVOQ0UpO1xcblxcdH1cXG5cXHRpZiAobG9jYWxJbmRleCA9PSAwKSB7XFxuXFx0XFx0b3V0W2dldF9ncm91cF9pZCgwKV0gPSBzY3JhdGNoWzBdO1xcblxcdH1cXG59XFxuXFxua2VybmVsIHZvaWQgbWluX2YzMl9ncHUoXFxuXFx0dWludCBsZW5ndGgsXFxuXFx0Z2xvYmFsIGZsb2F0KiBhLFxcblxcdGxvY2FsIGZsb2F0KiBzY3JhdGNoLFxcblxcdGdsb2JhbCBmbG9hdCogb3V0KVxcbntcXG5cXHRjb25zdCB1aW50IGdsb2JhbFNpemUgPSBnZXRfZ2xvYmFsX3NpemUoMCk7XFxuXFx0dWludCBnbG9iYWxJbmRleCA9IGdldF9nbG9iYWxfaWQoMCk7XFxuXFx0ZmxvYXQgYWNjdW11bGF0b3IgPSBJTkZJTklUWTtcXG5cXHR3aGlsZSAoZ2xvYmFsSW5kZXggPCBsZW5ndGgpIHtcXG5cXHRcXHRhY2N1bXVsYXRvciA9IG1pbihhY2N1bXVsYXRvciwgYVtnbG9iYWxJbmRleF0pO1xcblxcdFxcdGdsb2JhbEluZGV4ICs9IGdsb2JhbFNpemU7XFxuXFx0fVxcblxcblxcdHVpbnQgbG9jYWxJbmRleCA9IGdldF9sb2NhbF9pZCgwKTtcXG5cXHRzY3JhdGNoW2xvY2FsSW5kZXhdID0gYWNjdW11bGF0b3I7XFxuXFx0YmFycmllcihDTEtfTE9DQUxfTUVNX0ZFTkNFKTtcXG5cXHRmb3IgKHVpbnQgb2Zmc2V0ID0gZ2V0X2xvY2FsX3NpemUoMCkgLyAyOyBvZmZzZXQgIT0gMDsgb2Zmc2V0ID4+PSAxKSB7XFxuXFx0XFx0aWYgKGxvY2FsSW5kZXggPCBvZmZzZXQpIHtcXG5cXHRcXHRcXHRzY3JhdGNoW2xvY2FsSW5kZXhdID0gbWluKHNjcmF0Y2hbbG9jYWxJbmRleF0sIHNjcmF0Y2hbbG9jYWxJbmRleCArIG9mZnNldF0pO1xcblxcdFxcdH1cXG5cXHRcXHRiYXJyaWVyKENMS19MT0NBTF9NRU1fRkVOQ0UpO1xcblxcdH1cXG5cXHRpZiAobG9jYWxJbmRleCA9PSAwKSB7XFxuXFx0XFx0b3V0W2dldF9ncm91cF9pZCgwKV0gPSBzY3JhdGNoWzBdO1xcblxcdH1cXG59XFxuXFxua2VybmVsIHZvaWQgbWluX2Y2NF9ncHUoXFxuXFx0dWludCBsZW5ndGgsXFxuXFx0Z2xvYmFsIGRvdWJsZSogYSxcXG5cXHRsb2NhbCBkb3VibGUqIHNjcmF0Y2gsXFxuXFx0Z2xvYmFsIGRvdWJsZSogb3V0KVxcbntcXG5cXHRjb25zdCB1aW50IGdsb2JhbFNpemUgPSBnZXRfZ2xvYmFsX3NpemUoMCk7XFxuXFx0dWludCBnbG9iYWxJbmRleCA9IGdldF9nbG9iYWxfaWQoMCk7XFxuXFx0ZG91YmxlIGFjY3VtdWxhdG9yID0gSU5GSU5JVFk7XFxuXFx0d2hpbGUgKGdsb2JhbEluZGV4IDwgbGVuZ3RoKSB7XFxuXFx0XFx0YWNjdW11bGF0b3IgPSBtaW4oYWNjdW11bGF0b3IsIGFbZ2xvYmFsSW5kZXhdKTtcXG5cXHRcXHRnbG9iYWxJbmRleCArPSBnbG9iYWxTaXplO1xcblxcdH1cXG5cXG5cXHR1aW50IGxvY2FsSW5kZXggPSBnZXRfbG9jYWxfaWQoMCk7XFxuXFx0c2NyYXRjaFtsb2NhbEluZGV4XSA9IGFjY3VtdWxhdG9yO1xcblxcdGJhcnJpZXIoQ0xLX0xPQ0FMX01FTV9GRU5DRSk7XFxuXFx0Zm9yICh1aW50IG9mZnNldCA9IGdldF9sb2NhbF9zaXplKDApIC8gMjsgb2Zmc2V0ICE9IDA7IG9mZnNldCA+Pj0gMSkge1xcblxcdFxcdGlmIChsb2NhbEluZGV4IDwgb2Zmc2V0KSB7XFxuXFx0XFx0XFx0c2NyYXRjaFtsb2NhbEluZGV4XSA9IG1pbihzY3JhdGNoW2xvY2FsSW5kZXhdLCBzY3JhdGNoW2xvY2FsSW5kZXggKyBvZmZzZXRdKTtcXG5cXHRcXHR9XFxuXFx0XFx0YmFycmllcihDTEtfTE9DQUxfTUVNX0ZFTkNFKTtcXG5cXHR9XFxuXFx0aWYgKGxvY2FsSW5kZXggPT0gMCkge1xcblxcdFxcdG91dFtnZXRfZ3JvdXBfaWQoMCldID0gc2NyYXRjaFswXTtcXG5cXHR9XFxufVxcblxcbmtlcm5lbCB2b2lkIG1heF9mMzJfZ3B1KFxcblxcdHVpbnQgbGVuZ3RoLFxcblxcdGdsb2JhbCBmbG9hdCogYSxcXG5cXHRsb2NhbCBmbG9hdCogc2NyYXRjaCxcXG5cXHRnbG9iYWwgZmxvYXQqIG91dClcXG57XFxuXFx0Y29uc3QgdWludCBnbG9iYWxTaXplID0gZ2V0X2dsb2JhbF9zaXplKDApO1xcblxcdHVpbnQgZ2xvYmFsSW5kZXggPSBnZXRfZ2xvYmFsX2lkKDApO1xcblxcdGZsb2F0IGFjY3VtdWxhdG9yID0gLUlORklOSVRZO1xcblxcdHdoaWxlIChnbG9iYWxJbmRleCA8IGxlbmd0aCkge1xcblxcdFxcdGFjY3VtdWxhdG9yID0gbWF4KGFjY3VtdWxhdG9yLCBhW2dsb2JhbEluZGV4XSk7XFxuXFx0XFx0Z2xvYmFsSW5kZXggKz0gZ2xvYmFsU2l6ZTtcXG5cXHR9XFxuXFxuXFx0dWludCBsb2NhbEluZGV4ID0gZ2V0X2xvY2FsX2lkKDApO1xcblxcdHNjcmF0Y2hbbG9jYWxJbmRleF0gPSBhY2N1bXVsYXRvcjtcXG5cXHRiYXJyaWVyKENMS19MT0NBTF9NRU1fRkVOQ0UpO1xcblxcdGZvciAodWludCBvZmZzZXQgPSBnZXRfbG9jYWxfc2l6ZSgwKSAvIDI7IG9mZnNldCAhPSAwOyBvZmZzZXQgPj49IDEpIHtcXG5cXHRcXHRpZiAobG9jYWxJbmRleCA8IG9mZnNldCkge1xcblxcdFxcdFxcdHNjcmF0Y2hbbG9jYWxJbmRleF0gPSBtYXgoc2NyYXRjaFtsb2NhbEluZGV4XSwgc2NyYXRjaFtsb2NhbEluZGV4ICsgb2Zmc2V0XSk7XFxuXFx0XFx0fVxcblxcdFxcdGJhcnJpZXIoQ0xLX0xPQ0FMX01FTV9GRU5DRSk7XFxuXFx0fVxcblxcdGlmIChsb2NhbEluZGV4ID09IDApIHtcXG5cXHRcXHRvdXRbZ2V0X2dyb3VwX2lkKDApXSA9IHNjcmF0Y2hbMF07XFxuXFx0fVxcbn1cXG5cXG5rZXJuZWwgdm9pZCBtYXhfZjY0X2dwdShcXG5cXHR1aW50IGxlbmd0aCxcXG5cXHRnbG9iYWwgZG91YmxlKiBhLFxcblxcdGxvY2FsIGRvdWJsZSogc2NyYXRjaCxcXG5cXHRnbG9iYWwgZG91YmxlKiBvdXQpXFxue1xcblxcdGNvbnN0IHVpbnQgZ2xvYmFsU2l6ZSA9IGdldF9nbG9iYWxfc2l6ZSgwKTtcXG5cXHR1aW50IGdsb2JhbEluZGV4ID0gZ2V0X2dsb2JhbF9pZCgwKTtcXG5cXHRkb3VibGUgYWNjdW11bGF0b3IgPSAtSU5GSU5JVFk7XFxuXFx0d2hpbGUgKGdsb2JhbEluZGV4IDwgbGVuZ3RoKSB7XFxuXFx0XFx0YWNjdW11bGF0b3IgPSBtYXgoYWNjdW11bGF0b3IsIGFbZ2xvYmFsSW5kZXhdKTtcXG5cXHRcXHRnbG9iYWxJbmRleCArPSBnbG9iYWxTaXplO1xcblxcdH1cXG5cXG5cXHR1aW50IGxvY2FsSW5kZXggPSBnZXRfbG9jYWxfaWQoMCk7XFxuXFx0c2NyYXRjaFtsb2NhbEluZGV4XSA9IGFjY3VtdWxhdG9yO1xcblxcdGJhcnJpZXIoQ0xLX0xPQ0FMX01FTV9GRU5DRSk7XFxuXFx0Zm9yICh1aW50IG9mZnNldCA9IGdldF9sb2NhbF9zaXplKDApIC8gMjsgb2Zmc2V0ICE9IDA7IG9mZnNldCA+Pj0gMSkge1xcblxcdFxcdGlmIChsb2NhbEluZGV4IDwgb2Zmc2V0KSB7XFxuXFx0XFx0XFx0c2NyYXRjaFtsb2NhbEluZGV4XSA9IG1heChzY3JhdGNoW2xvY2FsSW5kZXhdLCBzY3JhdGNoW2xvY2FsSW5kZXggKyBvZmZzZXRdKTtcXG5cXHRcXHR9XFxuXFx0XFx0YmFycmllcihDTEtfTE9DQUxfTUVNX0ZFTkNFKTtcXG5cXHR9XFxuXFx0aWYgKGxvY2FsSW5kZXggPT0gMCkge1xcblxcdFxcdG91dFtnZXRfZ3JvdXBfaWQoMCldID0gc2NyYXRjaFswXTtcXG5cXHR9XFxufVxcblwiO1xuXHR2YXIgYXhpc1JlZHVjdGlvbktlcm5lbHNTb3VyY2UgPSBcImtlcm5lbCB2b2lkIGFzdW1fZjMyKFxcblxcdHVpbnQgcmVkdWN0aW9uRGltLFxcblxcdGdsb2JhbCBmbG9hdCogYSxcXG5cXHRnbG9iYWwgZmxvYXQqIG91dClcXG57XFxuXFx0Y29uc3QgdWludCBpbm5lclN0cmlkZSA9IGdldF9nbG9iYWxfc2l6ZSgxKTtcXG5cXHRjb25zdCB1aW50IGkgPSBnZXRfZ2xvYmFsX2lkKDApO1xcblxcdGNvbnN0IHVpbnQgayA9IGdldF9nbG9iYWxfaWQoMSk7XFxuXFx0YSArPSBpICogcmVkdWN0aW9uRGltICogaW5uZXJTdHJpZGUgKyBrO1xcblxcdGZsb2F0IGFjY3VtdWxhdG9yID0gKmE7XFxuXFx0d2hpbGUgKC0tcmVkdWN0aW9uRGltKSB7XFxuXFx0XFx0YSArPSBpbm5lclN0cmlkZTtcXG5cXHRcXHRhY2N1bXVsYXRvciArPSAqYTtcXG5cXHR9XFxuXFx0b3V0W2kgKiBpbm5lclN0cmlkZSArIGtdID0gYWNjdW11bGF0b3I7XFxufVxcblxcbmtlcm5lbCB2b2lkIGFzdW1fZjY0KFxcblxcdHVpbnQgcmVkdWN0aW9uRGltLFxcblxcdGdsb2JhbCBkb3VibGUqIGEsXFxuXFx0Z2xvYmFsIGRvdWJsZSogb3V0KVxcbntcXG5cXHRjb25zdCB1aW50IGlubmVyU3RyaWRlID0gZ2V0X2dsb2JhbF9zaXplKDEpO1xcblxcdGNvbnN0IHVpbnQgaSA9IGdldF9nbG9iYWxfaWQoMCk7XFxuXFx0Y29uc3QgdWludCBrID0gZ2V0X2dsb2JhbF9pZCgxKTtcXG5cXHRhICs9IGkgKiByZWR1Y3Rpb25EaW0gKiBpbm5lclN0cmlkZSArIGs7XFxuXFx0ZG91YmxlIGFjY3VtdWxhdG9yID0gKmE7XFxuXFx0d2hpbGUgKC0tcmVkdWN0aW9uRGltKSB7XFxuXFx0XFx0YSArPSBpbm5lclN0cmlkZTtcXG5cXHRcXHRhY2N1bXVsYXRvciArPSAqYTtcXG5cXHR9XFxuXFx0b3V0W2kgKiBpbm5lclN0cmlkZSArIGtdID0gYWNjdW11bGF0b3I7XFxufVxcblxcbmtlcm5lbCB2b2lkIGFtaW5fZjMyKFxcblxcdHVpbnQgcmVkdWN0aW9uRGltLFxcblxcdGdsb2JhbCBmbG9hdCogYSxcXG5cXHRnbG9iYWwgZmxvYXQqIG91dClcXG57XFxuXFx0Y29uc3QgdWludCBpbm5lclN0cmlkZSA9IGdldF9nbG9iYWxfc2l6ZSgxKTtcXG5cXHRjb25zdCB1aW50IGkgPSBnZXRfZ2xvYmFsX2lkKDApO1xcblxcdGNvbnN0IHVpbnQgayA9IGdldF9nbG9iYWxfaWQoMSk7XFxuXFx0YSArPSBpICogcmVkdWN0aW9uRGltICogaW5uZXJTdHJpZGUgKyBrO1xcblxcdGZsb2F0IGFjY3VtdWxhdG9yID0gKmE7XFxuXFx0d2hpbGUgKC0tcmVkdWN0aW9uRGltKSB7XFxuXFx0XFx0YSArPSBpbm5lclN0cmlkZTtcXG5cXHRcXHRhY2N1bXVsYXRvciA9IG1pbihhY2N1bXVsYXRvciwgKmEpO1xcblxcdH1cXG5cXHRvdXRbaSAqIGlubmVyU3RyaWRlICsga10gPSBhY2N1bXVsYXRvcjtcXG59XFxuXFxua2VybmVsIHZvaWQgYW1pbl9mNjQoXFxuXFx0dWludCByZWR1Y3Rpb25EaW0sXFxuXFx0Z2xvYmFsIGRvdWJsZSogYSxcXG5cXHRnbG9iYWwgZG91YmxlKiBvdXQpXFxue1xcblxcdGNvbnN0IHVpbnQgaW5uZXJTdHJpZGUgPSBnZXRfZ2xvYmFsX3NpemUoMSk7XFxuXFx0Y29uc3QgdWludCBpID0gZ2V0X2dsb2JhbF9pZCgwKTtcXG5cXHRjb25zdCB1aW50IGsgPSBnZXRfZ2xvYmFsX2lkKDEpO1xcblxcdGEgKz0gaSAqIHJlZHVjdGlvbkRpbSAqIGlubmVyU3RyaWRlICsgaztcXG5cXHRkb3VibGUgYWNjdW11bGF0b3IgPSAqYTtcXG5cXHR3aGlsZSAoLS1yZWR1Y3Rpb25EaW0pIHtcXG5cXHRcXHRhICs9IGlubmVyU3RyaWRlO1xcblxcdFxcdGFjY3VtdWxhdG9yID0gbWluKGFjY3VtdWxhdG9yLCAqYSk7XFxuXFx0fVxcblxcdG91dFtpICogaW5uZXJTdHJpZGUgKyBrXSA9IGFjY3VtdWxhdG9yO1xcbn1cXG5cXG5rZXJuZWwgdm9pZCBhbWF4X2YzMihcXG5cXHR1aW50IHJlZHVjdGlvbkRpbSxcXG5cXHRnbG9iYWwgZmxvYXQqIGEsXFxuXFx0Z2xvYmFsIGZsb2F0KiBvdXQpXFxue1xcblxcdGNvbnN0IHVpbnQgaW5uZXJTdHJpZGUgPSBnZXRfZ2xvYmFsX3NpemUoMSk7XFxuXFx0Y29uc3QgdWludCBpID0gZ2V0X2dsb2JhbF9pZCgwKTtcXG5cXHRjb25zdCB1aW50IGsgPSBnZXRfZ2xvYmFsX2lkKDEpO1xcblxcdGEgKz0gaSAqIHJlZHVjdGlvbkRpbSAqIGlubmVyU3RyaWRlICsgaztcXG5cXHRmbG9hdCBhY2N1bXVsYXRvciA9ICphO1xcblxcdHdoaWxlICgtLXJlZHVjdGlvbkRpbSkge1xcblxcdFxcdGEgKz0gaW5uZXJTdHJpZGU7XFxuXFx0XFx0YWNjdW11bGF0b3IgPSBtYXgoYWNjdW11bGF0b3IsICphKTtcXG5cXHR9XFxuXFx0b3V0W2kgKiBpbm5lclN0cmlkZSArIGtdID0gYWNjdW11bGF0b3I7XFxufVxcblxcbmtlcm5lbCB2b2lkIGFtYXhfZjY0KFxcblxcdHVpbnQgcmVkdWN0aW9uRGltLFxcblxcdGdsb2JhbCBkb3VibGUqIGEsXFxuXFx0Z2xvYmFsIGRvdWJsZSogb3V0KVxcbntcXG5cXHRjb25zdCB1aW50IGlubmVyU3RyaWRlID0gZ2V0X2dsb2JhbF9zaXplKDEpO1xcblxcdGNvbnN0IHVpbnQgaSA9IGdldF9nbG9iYWxfaWQoMCk7XFxuXFx0Y29uc3QgdWludCBrID0gZ2V0X2dsb2JhbF9pZCgxKTtcXG5cXHRhICs9IGkgKiByZWR1Y3Rpb25EaW0gKiBpbm5lclN0cmlkZSArIGs7XFxuXFx0ZG91YmxlIGFjY3VtdWxhdG9yID0gKmE7XFxuXFx0d2hpbGUgKC0tcmVkdWN0aW9uRGltKSB7XFxuXFx0XFx0YSArPSBpbm5lclN0cmlkZTtcXG5cXHRcXHRhY2N1bXVsYXRvciA9IG1heChhY2N1bXVsYXRvciwgKmEpO1xcblxcdH1cXG5cXHRvdXRbaSAqIGlubmVyU3RyaWRlICsga10gPSBhY2N1bXVsYXRvcjtcXG59XFxuXCI7XG5cdHZhciBwcm9kdWN0S2VybmVsc1NvdXJjZSA9IFwia2VybmVsIHZvaWQgZG90X2YzMihcXG5cXHR1aW50IHJlZHVjdGlvbkRpbSxcXG5cXHRnbG9iYWwgZmxvYXQqIGEsXFxuXFx0Z2xvYmFsIGZsb2F0KiBiLFxcblxcdGdsb2JhbCBmbG9hdCogb3V0KVxcbntcXG5cXHRjb25zdCB1aW50IGkgPSBnZXRfZ2xvYmFsX2lkKDApO1xcblxcdGNvbnN0IHVpbnQgayA9IGdldF9nbG9iYWxfaWQoMSk7XFxuXFx0Y29uc3QgdWludCBsID0gZ2V0X2dsb2JhbF9pZCgyKTtcXG5cXHRjb25zdCB1aW50IG91dGVyU3RyaWRlQiA9IGdldF9nbG9iYWxfc2l6ZSgxKTtcXG5cXHRjb25zdCB1aW50IGlubmVyU3RyaWRlQiA9IGdldF9nbG9iYWxfc2l6ZSgyKTtcXG5cXG5cXHRmbG9hdCBhY2N1bXVsYXRvciA9IDAuMGY7XFxuXFx0Zm9yICh1aW50IGogPSAwOyBqIDwgcmVkdWN0aW9uRGltOyArK2opIHtcXG5cXHRcXHRhY2N1bXVsYXRvciArPSBhW2kqcmVkdWN0aW9uRGltK2pdICogYlsoaypyZWR1Y3Rpb25EaW0raikqaW5uZXJTdHJpZGVCK2xdO1xcblxcdH1cXG5cXHRvdXRbKGkqb3V0ZXJTdHJpZGVCICsgaykgKiBpbm5lclN0cmlkZUIgKyBsXSA9IGFjY3VtdWxhdG9yO1xcbn1cXG5cXG5rZXJuZWwgdm9pZCBkb3RfZjY0KFxcblxcdHVpbnQgcmVkdWN0aW9uRGltLFxcblxcdGdsb2JhbCBkb3VibGUqIGEsXFxuXFx0Z2xvYmFsIGRvdWJsZSogYixcXG5cXHRnbG9iYWwgZG91YmxlKiBvdXQpXFxue1xcblxcdGNvbnN0IHVpbnQgaSA9IGdldF9nbG9iYWxfaWQoMCk7XFxuXFx0Y29uc3QgdWludCBrID0gZ2V0X2dsb2JhbF9pZCgxKTtcXG5cXHRjb25zdCB1aW50IGwgPSBnZXRfZ2xvYmFsX2lkKDIpO1xcblxcdGNvbnN0IHVpbnQgb3V0ZXJTdHJpZGVCID0gZ2V0X2dsb2JhbF9zaXplKDEpO1xcblxcdGNvbnN0IHVpbnQgaW5uZXJTdHJpZGVCID0gZ2V0X2dsb2JhbF9zaXplKDIpO1xcblxcblxcdGRvdWJsZSBhY2N1bXVsYXRvciA9IDAuMDtcXG5cXHRmb3IgKHVpbnQgaiA9IDA7IGogPCByZWR1Y3Rpb25EaW07ICsraikge1xcblxcdFxcdGFjY3VtdWxhdG9yICs9IGFbaSpyZWR1Y3Rpb25EaW0ral0gKiBiWyhrKnJlZHVjdGlvbkRpbStqKSppbm5lclN0cmlkZUIrbF07XFxuXFx0fVxcblxcdG91dFsoaSpvdXRlclN0cmlkZUIgKyBrKSAqIGlubmVyU3RyaWRlQiArIGxdID0gYWNjdW11bGF0b3I7XFxufVxcblwiO1xuXHR2YXIgdXRpbEtlcm5lbHNTb3VyY2UgPSBcImtlcm5lbCB2b2lkIHNldF9mMzIoXFxuXFx0dWludCBsZW5ndGgsXFxuXFx0Z2xvYmFsIGZsb2F0KiBvdXQsXFxuXFx0ZmxvYXQgdmFsdWUpXFxue1xcblxcdGNvbnN0IHVpbnQgaWQgPSBnZXRfZ2xvYmFsX2lkKDApO1xcblxcdGlmIChpZCA8IGxlbmd0aCkge1xcblxcdFxcdG91dFtpZF0gPSB2YWx1ZTtcXG5cXHR9XFxufVxcbmtlcm5lbCB2b2lkIHNldF9mNjQoXFxuXFx0dWludCBsZW5ndGgsXFxuXFx0Z2xvYmFsIGRvdWJsZSogb3V0LFxcblxcdGRvdWJsZSB2YWx1ZSlcXG57XFxuXFx0Y29uc3QgdWludCBpZCA9IGdldF9nbG9iYWxfaWQoMCk7XFxuXFx0aWYgKGlkIDwgbGVuZ3RoKSB7XFxuXFx0XFx0b3V0W2lkXSA9IHZhbHVlO1xcblxcdH1cXG59XFxuXFxua2VybmVsIHZvaWQgbGluc3BhY2VfZjMyKFxcblxcdHVpbnQgbGVuZ3RoLFxcblxcdGdsb2JhbCBmbG9hdCogb3V0LFxcblxcdGZsb2F0IHN0YXJ0LFxcblxcdGZsb2F0IHN0ZXApXFxue1xcblxcdGNvbnN0IHVpbnQgaWQgPSBnZXRfZ2xvYmFsX2lkKDApO1xcblxcdGlmIChpZCA8IGxlbmd0aCkge1xcblxcdFxcdG91dFtpZF0gPSBzdGFydCArIHN0ZXAgKiAoKGZsb2F0KSBpZCk7XFxuXFx0fVxcbn1cXG5rZXJuZWwgdm9pZCBsaW5zcGFjZV9mNjQoXFxuXFx0dWludCBsZW5ndGgsXFxuXFx0Z2xvYmFsIGRvdWJsZSogb3V0LFxcblxcdGRvdWJsZSBzdGFydCxcXG5cXHRkb3VibGUgc3RlcClcXG57XFxuXFx0Y29uc3QgdWludCBpZCA9IGdldF9nbG9iYWxfaWQoMCk7XFxuXFx0aWYgKGlkIDwgbGVuZ3RoKSB7XFxuXFx0XFx0b3V0W2lkXSA9IHN0YXJ0ICsgc3RlcCAqICgoZG91YmxlKSBpZCk7XFxuXFx0fVxcbn1cXG5cXG5rZXJuZWwgdm9pZCByZXBlYXRfZjMyKFxcblxcdHVpbnQgZXhwYW5zaW9uRGltLFxcblxcdHVpbnQgaW5uZXJTdHJpZGUsXFxuXFx0dWludCByZXBlYXRzLFxcblxcdGdsb2JhbCBmbG9hdCAqcmVzdHJpY3QgYSxcXG5cXHRnbG9iYWwgZmxvYXQgKnJlc3RyaWN0IG91dClcXG57XFxuXFx0Y29uc3QgdWludCBpID0gZ2V0X2dsb2JhbF9pZCgwKTtcXG5cXHRjb25zdCB1aW50IGogPSBnZXRfZ2xvYmFsX2lkKDEpO1xcblxcdGNvbnN0IHVpbnQgayA9IGdldF9nbG9iYWxfaWQoMik7XFxuXFx0Y29uc3QgZmxvYXQgdmFsdWUgPSBhWyhpICogZXhwYW5zaW9uRGltICsgaikgKiBpbm5lclN0cmlkZSArIGtdO1xcblxcdHVpbnQgb2Zmc2V0T3V0ID0gKGkgKiBleHBhbnNpb25EaW0gKyBqKSAqIHJlcGVhdHMgKiBpbm5lclN0cmlkZSArIGs7XFxuXFx0Zm9yICh1aW50IGMgPSAwOyBjIDwgcmVwZWF0czsgKytjKSB7XFxuXFx0XFx0b3V0W29mZnNldE91dF0gPSB2YWx1ZTtcXG5cXHRcXHRvZmZzZXRPdXQgKz0gaW5uZXJTdHJpZGU7XFxuXFx0fVxcbn1cXG5rZXJuZWwgdm9pZCByZXBlYXRfZjY0KFxcblxcdHVpbnQgZXhwYW5zaW9uRGltLFxcblxcdHVpbnQgaW5uZXJTdHJpZGUsXFxuXFx0dWludCByZXBlYXRzLFxcblxcdGdsb2JhbCBkb3VibGUgKnJlc3RyaWN0IGEsXFxuXFx0Z2xvYmFsIGRvdWJsZSAqcmVzdHJpY3Qgb3V0KVxcbntcXG5cXHRjb25zdCB1aW50IGkgPSBnZXRfZ2xvYmFsX2lkKDApO1xcblxcdGNvbnN0IHVpbnQgaiA9IGdldF9nbG9iYWxfaWQoMSk7XFxuXFx0Y29uc3QgdWludCBrID0gZ2V0X2dsb2JhbF9pZCgyKTtcXG5cXHRjb25zdCBkb3VibGUgdmFsdWUgPSBhWyhpICogZXhwYW5zaW9uRGltICsgaikgKiBpbm5lclN0cmlkZSArIGtdO1xcblxcdHVpbnQgb2Zmc2V0T3V0ID0gKGkgKiBleHBhbnNpb25EaW0gKyBqKSAqIHJlcGVhdHMgKiBpbm5lclN0cmlkZSArIGs7XFxuXFx0Zm9yICh1aW50IGMgPSAwOyBjIDwgcmVwZWF0czsgKytjKSB7XFxuXFx0XFx0b3V0W29mZnNldE91dF0gPSB2YWx1ZTtcXG5cXHRcXHRvZmZzZXRPdXQgKz0gaW5uZXJTdHJpZGU7XFxuXFx0fVxcbn1cXG5cIjtcblx0dmFyIHNvdXJjZSA9IGJpbmFyeUtlcm5lbHNTb3VyY2UgKyB1bmFyeUtlcm5lbHNTb3VyY2UgKyBcblx0XHRyZWR1Y3Rpb25LZXJuZWxzU291cmNlICsgYXhpc1JlZHVjdGlvbktlcm5lbHNTb3VyY2UgKyBcblx0XHRwcm9kdWN0S2VybmVsc1NvdXJjZSArIHV0aWxLZXJuZWxzU291cmNlO1xuXG5cdHZhciBhc3luY0NhbGxiYWNrcyA9IG9wdGlvbnMuYXN5bmNDYWxsYmFja3M7XG5cdGlmICh0eXBlb2YgYXN5bmNDYWxsYmFja3MgPT09IFwidW5kZWZpbmVkXCIpIHtcblx0XHQvKiBDdXJyZW50bHkgb25seSBOb2RlLVdlYkNMIHN1cHBvcnRzIGFzeW5jaHJvbm91cyBjYWxsYmFja3MgKi9cblx0XHR0aGlzLmFzeW5jQ2FsbGJhY2tzID0gaXNOb2RlV2ViQ0w7XG5cdH0gZWxzZSB7XG5cdFx0dGhpcy5hc3luY0NhbGxiYWNrcyA9ICEhYXN5bmNDYWxsYmFja3M7XG5cdH1cblx0dmFyIGRldmljZU5hbWUgPSBvcHRpb25zLmRldmljZTtcblx0aWYgKGRldmljZU5hbWUpIHtcblx0XHR2YXIgZGV2aWNlSW5kZXggPSBhdmFpbGFibGVEZXZpY2VzRGVzY3JpcHRpb25zLmluZGV4T2YoZGV2aWNlTmFtZSk7XG5cdFx0aWYgKGRldmljZUluZGV4ID09PSAtMSkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBXZWJDTCBkZXZpY2UgbmFtZTogXCIgKyBkZXZpY2VOYW1lKTtcblx0XHR9XG5cdFx0dGhpcy5kZXZpY2UgPSBhdmFpbGFibGVEZXZpY2VzW2RldmljZUluZGV4XTtcblx0fSBlbHNlIHtcblx0XHR2YXIgZGV2aWNlSW5kZXggPSBnZXREZWZhdWx0RGV2aWNlSW5kZXgoKTtcblx0XHRpZiAoZGV2aWNlSW5kZXggPCAwKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJObyBzdWl0YWJsZSBXZWJDTCBkZXZpY2UgZm91bmRcIik7XG5cdFx0fVxuXHRcdHRoaXMuZGV2aWNlID0gYXZhaWxhYmxlRGV2aWNlc1tkZXZpY2VJbmRleF07XG5cdH1cblx0dGhpcy5kZXZpY2UuZW5hYmxlRXh0ZW5zaW9uKFwiS0hSX2ZwNjRcIik7XG5cdHRoaXMuZGV2aWNlSW5mbyA9IHtcblx0XHRkZXZpY2VDbGFzczogY2xhc3NpZnlEZXZpY2UodGhpcy5kZXZpY2UpLFxuXHRcdGxvY2FsTWVtb3J5U2l6ZTogdGhpcy5kZXZpY2UuZ2V0SW5mbyhjbC5ERVZJQ0VfTE9DQUxfTUVNX1NJWkUpLFxuXHRcdG1heENvbXB1dGVVbml0czogdGhpcy5kZXZpY2UuZ2V0SW5mbyhjbC5ERVZJQ0VfTUFYX0NPTVBVVEVfVU5JVFMpLFxuXHRcdG1heFdvcmtHcm91cFNpemU6IHRoaXMuZGV2aWNlLmdldEluZm8oY2wuREVWSUNFX01BWF9XT1JLX0dST1VQX1NJWkUpLFxuXHRcdG1heFdvcmtJdGVtU2l6ZXM6IHRoaXMuZGV2aWNlLmdldEluZm8oY2wuREVWSUNFX01BWF9XT1JLX0lURU1fU0laRVMpXG5cdH07XG5cdHRoaXMuY29udGV4dCA9IGNsLmNyZWF0ZUNvbnRleHQodGhpcy5kZXZpY2UpO1xuXHR0aGlzLnF1ZXVlID0gdGhpcy5jb250ZXh0LmNyZWF0ZUNvbW1hbmRRdWV1ZSh0aGlzLmRldmljZSk7XG5cdHRoaXMucHJvZ3JhbSA9IHRoaXMuY29udGV4dC5jcmVhdGVQcm9ncmFtKHNvdXJjZSk7XG5cdHRyeSB7XG5cdFx0LyogQ2hyb21pdW0tV2ViQ0wgcmVxdWlyZXMgYSBsaXN0IG9mIGRldmljZXMgKi9cblx0XHR0aGlzLnByb2dyYW0uYnVpbGQoW3RoaXMuZGV2aWNlXSk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRpZiAoZS5uYW1lID09PSBcIklOVkFMSURfREVWSUNFXCIpIHtcblx0XHRcdC8qIE5va2lhLVdlYkNMIG9ubHkgd29ya3Mgd2l0aCBubyBhcmd1bWVudHMgdG8gV2ViQ0xQcm9ncmFtLmJ1aWxkICovXG5cdFx0XHR0aGlzLnByb2dyYW0uYnVpbGQoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhyb3cgZTtcblx0XHR9XG5cdH1cblx0dGhpcy5rZXJuZWxzID0gY3JlYXRlS2VybmVscyh0aGlzLnByb2dyYW0pO1xuXHQvKiBDb250ZXh0IGlzIHJlYWR5IGZvciBjb21wdXRhdGlvbnMgKi9cblx0Y2FsbGJhY2sodGhpcyk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbmFtZXMgb2YgZGV2aWNlcyB0aGF0IGNhbiBiZSB1c2VkIGZvciBjb21wdXRhdGlvbi5cbiAqIEFueSBvZiB0aGVzZSBuYW1lcyBjYW4gYmUgcGFzc2VkIGFzIGEgXCJkZXZpY2VcIiBvcHRpb24gd2hlbiBjcmVhdGluZyBhIFdlYkNMIGNvbnRleHQuXG4gKlxuICogQHN0YXRpY1xuICogQG1ldGhvZCBnZXRBdmFpbGFibGVEZXZpY2VzXG4gKiBAcmV0dXJuIHtTdHJpbmdbXX0gLSBhIHBvc3NpYmx5IGVtcHR5IGxpc3Qgb2YgYXZhaWxhYmxlIGRldmljZSBuYW1lcy5cbiAqL1xuV2ViQ0xDb250ZXh0LmdldEF2YWlsYWJsZURldmljZXMgPSBmdW5jdGlvbigpIHtcblx0aWYgKFdlYkNMQ29udGV4dC5pc1VzYWJsZSgpKSB7XG5cdFx0cmV0dXJuIGF2YWlsYWJsZURldmljZXNEZXNjcmlwdGlvbnM7XG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIFtdO1xuXHR9XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG5hbWUgb2YgdGhlIGRlZmF1bHQgZGV2aWNlIHVzZWQgZm9yIGNvbXB1dGF0aW9uLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgZ2V0RGVmYXVsdERldmljZVxuICogQHJldHVybiB7U3RyaW5nfSAtIHRoZSBuYW1lIG9mIHRoZSBkZWZhdWx0IFdlYkNMIGRldmljZSBvciBudWxsIGlmIG5vIHN1aXRhYmxlIGRldmljZSBhdmFpbGFibGUuXG4gKi9cbldlYkNMQ29udGV4dC5nZXREZWZhdWx0RGV2aWNlID0gZnVuY3Rpb24oKSB7XG5cdHZhciBkZXZpY2VJbmRleCA9IGdldERlZmF1bHREZXZpY2VJbmRleCgpO1xuXHRpZiAoZGV2aWNlSW5kZXggPCAwKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIGF2YWlsYWJsZURldmljZXNEZXNjcmlwdGlvbnNbZGV2aWNlSW5kZXhdO1xuXHR9XG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiBXZWJDTCBpcyBzdXBwb3J0ZWQgYnkgdGhlIGVudmlyb25tZW50LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgaXNTdXBwb3J0ZWRcbiAqIEByZXR1cm4ge0Jvb2xlYW59IC0gdHJ1ZSBpZiBXZWJDTCBpcyBzdXBwb3J0ZWQgb24gdGhpcyBzeXN0ZW0gYW5kIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuV2ViQ0xDb250ZXh0LmlzU3VwcG9ydGVkID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiBpbml0V2ViQ0woKSAhPT0gbnVsbDtcbn07XG5cbi8qKlxuICogQ2hlY2tzIGlmIFdlYkNMIGNhbiBiZSB1c2VkIGZvciBjb21wdXRhdGlvbi5cbiAqIFdlYkNMIGlzIHVzYWJsZSBmb3IgY29tcHV0YXRpb25zIGlmIGl0IGlzIHN1cHBvcnRlZCBieSBKUyBlbmdpbmUgKG9yIE5vZGUuanMpIGFuZCB0aGVyZSBpcyBhdCBsZWFzdCBvbmUgQ1BVIG9yIEdQVSBkZXZpY2Ugd2l0aCBLSFJfZnA2NCBleHRlbnNpb24uXG4gKlxuICogQHN0YXRpY1xuICogQG1ldGhvZCBpc1VzYWJsZVxuICogQHJldHVybiB7Qm9vbGVhbn0gLSB0cnVlIGlmIFdlYkNMIGlzIHVzYWJsZSBvbiB0aGlzIHN5c3RlbSBhbmQgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5XZWJDTENvbnRleHQuaXNVc2FibGUgPSBmdW5jdGlvbigpIHtcblx0dmFyIHdlYmNsID0gaW5pdFdlYkNMKCk7XG5cdGlmICh3ZWJjbCA9PT0gbnVsbCkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXHR2YXIgYXZhaWxhYmxlRGV2aWNlcyA9IGdldEF2YWlsYWJsZURldmljZXMoKTtcblx0cmV0dXJuIGF2YWlsYWJsZURldmljZXMubGVuZ3RoICE9PSAwO1xufTtcblxuV2ViQ0xDb250ZXh0LnByb3RvdHlwZS5lbXB0eSA9IGZ1bmN0aW9uKHNoYXBlLCBkYXRhVHlwZSkge1xuXHRzaGFwZSA9IHV0aWwuY2hlY2tTaGFwZShzaGFwZSk7XG5cdGlmICh0eXBlb2YgZGF0YVR5cGUgPT09IFwidW5kZWZpbmVkXCIpIHtcblx0XHRkYXRhVHlwZSA9IG5ldyBEYXRhVHlwZShcImY2NFwiKTtcblx0fSBlbHNlIGlmICghKGRhdGFUeXBlIGluc3RhbmNlb2YgRGF0YVR5cGUpKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihkYXRhVHlwZSArIFwiIGlzIG5vdCBhbiBpbnN0YW5jZSBvZiBEYXRhVHlwZVwiKTtcblx0fVxuXHR2YXIgYXJyYXkgPSBuZXcgTkRBcnJheShzaGFwZSwgZGF0YVR5cGUsIHRoaXMpO1xuXHRhcnJheS5fYnVmZmVyID0gdGhpcy5jb250ZXh0LmNyZWF0ZUJ1ZmZlcihjbC5NRU1fUkVBRF9XUklURSwgYXJyYXkubGVuZ3RoICogZGF0YVR5cGUuc2l6ZSk7XG5cdHJldHVybiBhcnJheTtcbn07XG5cbldlYkNMQ29udGV4dC5wcm90b3R5cGUuemVyb3MgPSBmdW5jdGlvbihzaGFwZSwgZGF0YVR5cGUpIHtcblx0c2hhcGUgPSB1dGlsLmNoZWNrU2hhcGUoc2hhcGUpO1xuXHRpZiAodHlwZW9mIGRhdGFUeXBlID09PSBcInVuZGVmaW5lZFwiKSB7XG5cdFx0ZGF0YVR5cGUgPSBuZXcgRGF0YVR5cGUoXCJmNjRcIik7XG5cdH0gZWxzZSBpZiAoIShkYXRhVHlwZSBpbnN0YW5jZW9mIERhdGFUeXBlKSkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoZGF0YVR5cGUgKyBcIiBpcyBub3QgYW4gaW5zdGFuY2Ugb2YgRGF0YVR5cGVcIik7XG5cdH1cblx0dmFyIGFycmF5ID0gbmV3IE5EQXJyYXkoc2hhcGUsIGRhdGFUeXBlLCB0aGlzKTtcblx0YXJyYXkuX2J1ZmZlciA9IHRoaXMuY29udGV4dC5jcmVhdGVCdWZmZXIoY2wuTUVNX1JFQURfV1JJVEUsIGFycmF5Lmxlbmd0aCAqIGRhdGFUeXBlLnNpemUpO1xuXHR2YXIga2VybmVsID0gdGhpcy5rZXJuZWxzLnNldFtkYXRhVHlwZS50eXBlXTtcblx0a2VybmVsLnNldEFyZygwLCBuZXcgVWludDMyQXJyYXkoW2FycmF5Lmxlbmd0aF0pKTtcblx0a2VybmVsLnNldEFyZygxLCBhcnJheS5fYnVmZmVyKTtcblx0a2VybmVsLnNldEFyZygyLCBuZXcgZGF0YVR5cGUuYXJyYXlUeXBlKFswLjBdKSk7XG5cdHRoaXMucXVldWUuZW5xdWV1ZU5EUmFuZ2VLZXJuZWwoa2VybmVsLCAxLCBudWxsLCBbYXJyYXkubGVuZ3RoXSk7XG5cdHJldHVybiBhcnJheTtcbn07XG5cbldlYkNMQ29udGV4dC5wcm90b3R5cGUub25lcyA9IGZ1bmN0aW9uKHNoYXBlLCBkYXRhVHlwZSkge1xuXHRzaGFwZSA9IHV0aWwuY2hlY2tTaGFwZShzaGFwZSk7XG5cdGlmICh0eXBlb2YgZGF0YVR5cGUgPT09IFwidW5kZWZpbmVkXCIpIHtcblx0XHRkYXRhVHlwZSA9IG5ldyBEYXRhVHlwZShcImY2NFwiKTtcblx0fSBlbHNlIGlmICghKGRhdGFUeXBlIGluc3RhbmNlb2YgRGF0YVR5cGUpKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihkYXRhVHlwZSArIFwiIGlzIG5vdCBhbiBpbnN0YW5jZSBvZiBEYXRhVHlwZVwiKTtcblx0fVxuXHR2YXIgYXJyYXkgPSBuZXcgTkRBcnJheShzaGFwZSwgZGF0YVR5cGUsIHRoaXMpO1xuXHRhcnJheS5fYnVmZmVyID0gdGhpcy5jb250ZXh0LmNyZWF0ZUJ1ZmZlcihjbC5NRU1fUkVBRF9XUklURSwgYXJyYXkubGVuZ3RoICogZGF0YVR5cGUuc2l6ZSk7XG5cdHZhciBrZXJuZWwgPSB0aGlzLmtlcm5lbHMuc2V0W2RhdGFUeXBlLnR5cGVdO1xuXHRrZXJuZWwuc2V0QXJnKDAsIG5ldyBVaW50MzJBcnJheShbYXJyYXkubGVuZ3RoXSkpO1xuXHRrZXJuZWwuc2V0QXJnKDEsIGFycmF5Ll9idWZmZXIpO1xuXHRrZXJuZWwuc2V0QXJnKDIsIG5ldyBkYXRhVHlwZS5hcnJheVR5cGUoWzEuMF0pKTtcblx0dGhpcy5xdWV1ZS5lbnF1ZXVlTkRSYW5nZUtlcm5lbChrZXJuZWwsIDEsIG51bGwsIFthcnJheS5sZW5ndGhdKTtcblx0cmV0dXJuIGFycmF5O1xufTtcblxuV2ViQ0xDb250ZXh0LnByb3RvdHlwZS5hcnJheSA9IGZ1bmN0aW9uKGRhdGEsIGRhdGFUeXBlKSB7XG5cdGlmICh0eXBlb2YgZGF0YVR5cGUgPT09IFwidW5kZWZpbmVkXCIpIHtcblx0XHRkYXRhVHlwZSA9IG5ldyBEYXRhVHlwZShcImY2NFwiKTtcblx0fSBlbHNlIHtcblx0XHRkYXRhVHlwZSA9IHV0aWwuY2hlY2tEYXRhVHlwZShkYXRhVHlwZSk7XG5cdH1cblx0dmFyIHNoYXBlID0gW107XG5cdHV0aWwuZGlzY292ZXJBcnJheVNoYXBlUmVjdXJzaXZlKGRhdGEsIHNoYXBlLCAwKTtcblx0dmFyIGFycmF5ID0gbmV3IE5EQXJyYXkoc2hhcGUsIGRhdGFUeXBlLCB0aGlzKTtcblx0dmFyIGJ1ZmZlciA9IG5ldyBkYXRhVHlwZS5hcnJheVR5cGUoYXJyYXkubGVuZ3RoKTtcblx0dXRpbC5jb3B5QXJyYXlEYXRhUmVjdXJzaXZlKGJ1ZmZlciwgZGF0YSwgc2hhcGUsIDAsIDApO1xuXHRpZiAodXNlQnVmZmVyQ3JlYXRpb25XaXRoSW5pdCkge1xuXHRcdGFycmF5Ll9idWZmZXIgPSB0aGlzLmNvbnRleHQuY3JlYXRlQnVmZmVyKGNsLk1FTV9SRUFEX1dSSVRFLCBidWZmZXIuYnl0ZUxlbmd0aCwgYnVmZmVyKTtcblx0fSBlbHNlIHtcblx0XHRhcnJheS5fYnVmZmVyID0gdGhpcy5jb250ZXh0LmNyZWF0ZUJ1ZmZlcihjbC5NRU1fUkVBRF9XUklURSwgYnVmZmVyLmJ5dGVMZW5ndGgpO1xuXHRcdHRoaXMucXVldWUuZW5xdWV1ZVdyaXRlQnVmZmVyKGFycmF5Ll9idWZmZXIsIGZhbHNlLCAwLCBidWZmZXIuYnl0ZUxlbmd0aCwgYnVmZmVyKTtcblx0fVxuXHRyZXR1cm4gYXJyYXk7XG59O1xuXG5XZWJDTENvbnRleHQucHJvdG90eXBlLmxpbnNwYWNlID0gZnVuY3Rpb24oc3RhcnQsIHN0b3AsIHNhbXBsZXMsIGNsb3NlZCkge1xuXHRpZiAoIXV0aWwuaXNSZWFsKHN0YXJ0KSkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3Ioc3RhcnQgKyBcIiBpcyBub3QgYSByZWFsIG51bWJlclwiKTtcblx0fVxuXHRpZiAoIXV0aWwuaXNSZWFsKHN0b3ApKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihzdG9wICsgXCIgaXMgbm90IGEgcmVhbCBudW1iZXJcIik7XG5cdH1cblx0aWYgKHR5cGVvZiBzYW1wbGVzID09PSBcInVuZGVmaW5lZFwiKSB7XG5cdFx0LyogRGVmYXVsdCB2YWx1ZSBpbiBOdW1QeSAqL1xuXHRcdHNhbXBsZXMgPSA1MDtcblx0fSBlbHNlIGlmICghdXRpbC5pc0ludChzYW1wbGVzKSkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3Ioc2FtcGxlcyArIFwiIGlzIG5vdCBhbiBpbnRlZ2VyXCIpO1xuXHR9IGVsc2UgaWYgKHNhbXBsZXMgPD0gMCkge1xuXHRcdHRocm93IG5ldyBSYW5nZUVycm9yKFwiVGhlIG51bWJlciBvZiBzYW1wbGVzIG11c3QgYmUgcG9zaXRpdmVcIik7XG5cdH1cblx0aWYgKHR5cGVvZiBjbG9zZWQgPT09IFwidW5kZWZpbmVkXCIpIHtcblx0XHRjbG9zZWQgPSB0cnVlO1xuXHR9XG5cdGlmIChjbG9zZWQgJiYgKHNhbXBsZXMgPT09IDEpKSB7XG5cdFx0dGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUaGUgbnVtYmVyIG9mIHNhbXBsZXMgbXVzdCBiZSBhIGxlYXN0IDIgKGZvciBzdGFydCBhbmQgZW5kIHBvaW50cylcIik7XG5cdH1cblxuXHR2YXIgZGF0YVR5cGUgPSBuZXcgRGF0YVR5cGUoXCJmNjRcIik7XG5cdHZhciBhcnJheSA9IG5ldyBOREFycmF5KFtzYW1wbGVzXSwgZGF0YVR5cGUsIHRoaXMpO1xuXHRhcnJheS5fYnVmZmVyID0gdGhpcy5jb250ZXh0LmNyZWF0ZUJ1ZmZlcihjbC5NRU1fUkVBRF9XUklURSwgc2FtcGxlcyAqIGRhdGFUeXBlLnNpemUpO1xuXG5cdHZhciByYW5nZSA9IHN0b3AgLSBzdGFydDtcblx0dmFyIG4gPSAoY2xvc2VkKSA/IHNhbXBsZXMgLSAxIDogc2FtcGxlcztcblx0dmFyIHN0ZXAgPSByYW5nZSAvIG47XG5cblx0dmFyIGtlcm5lbCA9IHRoaXMua2VybmVscy5saW5zcGFjZVtkYXRhVHlwZS50eXBlXTtcblx0a2VybmVsLnNldEFyZygwLCBuZXcgVWludDMyQXJyYXkoW2FycmF5Lmxlbmd0aF0pKTtcblx0a2VybmVsLnNldEFyZygxLCBhcnJheS5fYnVmZmVyKTtcblx0a2VybmVsLnNldEFyZygyLCBuZXcgZGF0YVR5cGUuYXJyYXlUeXBlKFtzdGFydF0pKTtcblx0a2VybmVsLnNldEFyZygzLCBuZXcgZGF0YVR5cGUuYXJyYXlUeXBlKFtzdGVwXSkpO1xuXHR0aGlzLnF1ZXVlLmVucXVldWVORFJhbmdlS2VybmVsKGtlcm5lbCwgMSwgbnVsbCwgW2FycmF5Lmxlbmd0aF0pO1xuXG5cdHJldHVybiBhcnJheTtcbn07XG5cbldlYkNMQ29udGV4dC5wcm90b3R5cGUuX2ludmFsaWRhdGUgPSBmdW5jdGlvbihhcnJheSkge1xuXHRpZiAoYXJyYXkuX2J1ZmZlciAhPT0gbnVsbCkge1xuXHRcdC8qIFdvcmstYXJvdW5kIGZvciBDaHJvbWl1bS1XZWJDTCB0aGF0IGN1cnJlbnRseSBsYWNrcyBXZWJDTE1lbU9iamVjdC5yZWxlYXNlIG1ldGhvZCAqL1xuXHRcdGlmICh0eXBlb2YgYXJyYXkuX2J1ZmZlci5yZWxlYXNlICE9PSBcInVuZGVmaW5lZFwiKSB7XG5cdFx0XHRhcnJheS5fYnVmZmVyLnJlbGVhc2UoKTtcblx0XHR9XG5cdFx0YXJyYXkuX2J1ZmZlciA9IG51bGw7XG5cdH1cbn07XG5cbldlYkNMQ29udGV4dC5wcm90b3R5cGUuZmV0Y2ggPSBmdW5jdGlvbigpIHtcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJDYWxsYmFjayBhcmd1bWVudCBtaXNzaW5nXCIpO1xuXHR9XG5cdHZhciBjYWxsYmFjayA9IGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoIC0gMV07XG5cdC8qIFZhbGlkYXRlIGFyZ3VtZW50cyAqL1xuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIkF0IGxlYXN0IG9uZSBOREFycmF5IGFyZ3VtZW50IGV4cGVjdGVkXCIpO1xuXHR9XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aCAtIDE7IGkrKykge1xuXHRcdGlmICghKGFyZ3VtZW50c1tpXSBpbnN0YW5jZW9mIE5EQXJyYXkpKSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKFwiQXJndW1lbnQgXCIgKyBpICsgXCIgaXMgbm90IGFuIE5EQXJyYXlcIik7XG5cdFx0fVxuXHR9XG5cdHZhciBjYWxsYmFja1dhaXRBcmd1bWVudHMgPSBhcmd1bWVudHMubGVuZ3RoIC0gMTtcblx0dmFyIGNhbGxiYWNrQXJndW1lbnRzID0gbmV3IEFycmF5KGNhbGxiYWNrV2FpdEFyZ3VtZW50cyk7XG5cdGlmICh0aGlzLmFzeW5jQ2FsbGJhY2tzKSB7XG5cdFx0dmFyIGFzeW5jRXZlbnRzID0gW107XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjYWxsYmFja1dhaXRBcmd1bWVudHM7IGkrKykge1xuXHRcdFx0dmFyIGFycmF5ID0gYXJndW1lbnRzW2ldO1xuXHRcdFx0KGZ1bmN0aW9uKHF1ZXVlLCBpLCBzaGFwZSwgQXJyYXlUeXBlKSB7XG5cdFx0XHRcdHZhciBidWZmZXIgPSBuZXcgQXJyYXlUeXBlKGFycmF5Lmxlbmd0aCk7XG5cdFx0XHRcdHZhciByZWFkRmluaXNoRXZlbnQgPSBjcmVhdGVFdmVudCgpO1xuXHRcdFx0XHRhc3luY0V2ZW50cy5wdXNoKHJlYWRGaW5pc2hFdmVudCk7XG5cdFx0XHRcdHF1ZXVlLmVucXVldWVSZWFkQnVmZmVyKGFycmF5Ll9idWZmZXIsIGZhbHNlLCAwLCBidWZmZXIuYnl0ZUxlbmd0aCwgYnVmZmVyLCBudWxsLCByZWFkRmluaXNoRXZlbnQpO1xuXHRcdFx0XHRyZWFkRmluaXNoRXZlbnQuc2V0Q2FsbGJhY2soY2wuQ09NUExFVEUsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJlYWRGaW5pc2hFdmVudC5yZWxlYXNlKCk7XG5cdFx0XHRcdFx0Y2FsbGJhY2tBcmd1bWVudHNbaV0gPSBidWZmZXI7XG5cdFx0XHRcdFx0aWYgKC0tY2FsbGJhY2tXYWl0QXJndW1lbnRzID09PSAwKSB7XG5cdFx0XHRcdFx0XHRjYWxsYmFjay5hcHBseShudWxsLCBjYWxsYmFja0FyZ3VtZW50cyk7XG5cdFx0XHRcdFx0XHQvKiBPcGVuQ0wgc3RhbmRhcmQ6IGNvbW1hbmRzIGVucXVldWVkIGluIGEgY2FsbGJhY2sgd29uJ3Qgc3RhcnQgdW50aWwgY2xGbHVzaCAqL1xuXHRcdFx0XHRcdFx0cXVldWUuZmx1c2goKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSkodGhpcy5xdWV1ZSwgaSwgYXJyYXkuc2hhcGUsIGFycmF5LmRhdGFUeXBlLmFycmF5VHlwZSk7XG5cdFx0XHQvKiBUaGlzIGxpbmUgbW9zdGx5IHNlcmlhbGl6ZXMgZXhlY3V0aW9uLiBVbmZvcnR1bmF0ZWx5LCB3aXRob3V0IGl0IG5vdGhpbmcgd29ya3MgKi9cblx0XHRcdGNsLndhaXRGb3JFdmVudHMoYXN5bmNFdmVudHMpO1xuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGNhbGxiYWNrV2FpdEFyZ3VtZW50czsgaSsrKSB7XG5cdFx0XHR2YXIgYXJyYXkgPSBhcmd1bWVudHNbaV07XG5cdFx0XHR2YXIgYnVmZmVyID0gbmV3IGFycmF5LmRhdGFUeXBlLmFycmF5VHlwZShhcnJheS5sZW5ndGgpO1xuXHRcdFx0dGhpcy5xdWV1ZS5lbnF1ZXVlUmVhZEJ1ZmZlcihhcnJheS5fYnVmZmVyLCB0cnVlLCAwLCBidWZmZXIuYnl0ZUxlbmd0aCwgYnVmZmVyKTtcblx0XHRcdGNhbGxiYWNrQXJndW1lbnRzW2ldID0gYnVmZmVyO1xuXHRcdH1cblx0XHRjYWxsYmFjay5hcHBseShudWxsLCBjYWxsYmFja0FyZ3VtZW50cyk7XG5cdH1cbn07XG5cbldlYkNMQ29udGV4dC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oKSB7XG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiQ2FsbGJhY2sgYXJndW1lbnQgbWlzc2luZ1wiKTtcblx0fVxuXHR2YXIgY2FsbGJhY2sgPSBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aCAtIDFdO1xuXHQvKiBWYWxpZGF0ZSBhcmd1bWVudHMgKi9cblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJBdCBsZWFzdCBvbmUgTkRBcnJheSBhcmd1bWVudCBleHBlY3RlZFwiKTtcblx0fVxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGggLSAxOyBpKyspIHtcblx0XHRpZiAoIShhcmd1bWVudHNbaV0gaW5zdGFuY2VvZiBOREFycmF5KSkge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihcIkFyZ3VtZW50IFwiICsgaSArIFwiIGlzIG5vdCBhbiBOREFycmF5XCIpO1xuXHRcdH1cblx0fVxuXHR2YXIgY2FsbGJhY2tXYWl0QXJndW1lbnRzID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7XG5cdHZhciBjYWxsYmFja0FyZ3VtZW50cyA9IG5ldyBBcnJheShjYWxsYmFja1dhaXRBcmd1bWVudHMpO1xuXHRpZiAodGhpcy5hc3luY0NhbGxiYWNrcykge1xuXHRcdHZhciBhc3luY0V2ZW50cyA9IFtdO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgY2FsbGJhY2tXYWl0QXJndW1lbnRzOyBpKyspIHtcblx0XHRcdHZhciBhcnJheSA9IGFyZ3VtZW50c1tpXTtcblx0XHRcdChmdW5jdGlvbihxdWV1ZSwgaSwgc2hhcGUsIEFycmF5VHlwZSkge1xuXHRcdFx0XHR2YXIgYnVmZmVyID0gbmV3IEFycmF5VHlwZShhcnJheS5sZW5ndGgpO1xuXHRcdFx0XHR2YXIgcmVhZEZpbmlzaEV2ZW50ID0gY3JlYXRlRXZlbnQoKTtcblx0XHRcdFx0YXN5bmNFdmVudHMucHVzaChyZWFkRmluaXNoRXZlbnQpO1xuXHRcdFx0XHRxdWV1ZS5lbnF1ZXVlUmVhZEJ1ZmZlcihhcnJheS5fYnVmZmVyLCBmYWxzZSwgMCwgYnVmZmVyLmJ5dGVMZW5ndGgsIGJ1ZmZlciwgbnVsbCwgcmVhZEZpbmlzaEV2ZW50KTtcblx0XHRcdFx0aWYgKHNoYXBlLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0XHRcdHJlYWRGaW5pc2hFdmVudC5zZXRDYWxsYmFjayhjbC5DT01QTEVURSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRyZWFkRmluaXNoRXZlbnQucmVsZWFzZSgpO1xuXHRcdFx0XHRcdFx0Y2FsbGJhY2tBcmd1bWVudHNbaV0gPSBidWZmZXJbMF07XG5cdFx0XHRcdFx0XHRpZiAoLS1jYWxsYmFja1dhaXRBcmd1bWVudHMgPT09IDApIHtcblx0XHRcdFx0XHRcdFx0Y2FsbGJhY2suYXBwbHkobnVsbCwgY2FsbGJhY2tBcmd1bWVudHMpO1xuXHRcdFx0XHRcdFx0XHQvKiBPcGVuQ0wgc3RhbmRhcmQ6IGNvbW1hbmRzIGVucXVldWVkIGluIGEgY2FsbGJhY2sgd29uJ3Qgc3RhcnQgdW50aWwgY2xGbHVzaCAqL1xuXHRcdFx0XHRcdFx0XHRxdWV1ZS5mbHVzaCgpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJlYWRGaW5pc2hFdmVudC5zZXRDYWxsYmFjayhjbC5DT01QTEVURSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRyZWFkRmluaXNoRXZlbnQucmVsZWFzZSgpO1xuXHRcdFx0XHRcdFx0dmFyIGpzYXJyYXkgPSBuZXcgQXJyYXkoc2hhcGVbMF0pO1xuXHRcdFx0XHRcdFx0dXRpbC5jcmVhdGVBcnJheVJlY3Vyc2l2ZShuZXcgQXJyYXlUeXBlKGJ1ZmZlciksIGpzYXJyYXksIHNoYXBlLCAwLCAwKTtcblx0XHRcdFx0XHRcdGNhbGxiYWNrQXJndW1lbnRzW2ldID0ganNhcnJheTtcblx0XHRcdFx0XHRcdGlmICgtLWNhbGxiYWNrV2FpdEFyZ3VtZW50cyA9PT0gMCkge1xuXHRcdFx0XHRcdFx0XHRjYWxsYmFjay5hcHBseShudWxsLCBjYWxsYmFja0FyZ3VtZW50cyk7XG5cdFx0XHRcdFx0XHRcdC8qIE9wZW5DTCBzdGFuZGFyZDogY29tbWFuZHMgZW5xdWV1ZWQgaW4gYSBjYWxsYmFjayB3b24ndCBzdGFydCB1bnRpbCBjbEZsdXNoICovXG5cdFx0XHRcdFx0XHRcdHF1ZXVlLmZsdXNoKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pKHRoaXMucXVldWUsIGksIGFycmF5LnNoYXBlLCBhcnJheS5kYXRhVHlwZS5hcnJheVR5cGUpO1xuXHRcdFx0LyogVGhpcyBsaW5lIG1vc3RseSBzZXJpYWxpemVzIGV4ZWN1dGlvbi4gVW5mb3J0dW5hdGVseSwgd2l0aG91dCBpdCBub3RoaW5nIHdvcmtzICovXG5cdFx0XHRjbC53YWl0Rm9yRXZlbnRzKGFzeW5jRXZlbnRzKTtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjYWxsYmFja1dhaXRBcmd1bWVudHM7IGkrKykge1xuXHRcdFx0dmFyIGFycmF5ID0gYXJndW1lbnRzW2ldO1xuXHRcdFx0dmFyIGJ1ZmZlciA9IG5ldyBhcnJheS5kYXRhVHlwZS5hcnJheVR5cGUoYXJyYXkubGVuZ3RoKTtcblx0XHRcdHRoaXMucXVldWUuZW5xdWV1ZVJlYWRCdWZmZXIoYXJyYXkuX2J1ZmZlciwgdHJ1ZSwgMCwgYnVmZmVyLmJ5dGVMZW5ndGgsIGJ1ZmZlcik7XG5cdFx0XHRpZiAoYXJyYXkuc2hhcGUubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRcdGNhbGxiYWNrQXJndW1lbnRzW2ldID0gYnVmZmVyWzBdO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIGpzYXJyYXkgPSBuZXcgQXJyYXkoYXJyYXkuc2hhcGVbMF0pO1xuXHRcdFx0XHR1dGlsLmNyZWF0ZUFycmF5UmVjdXJzaXZlKG5ldyBhcnJheS5kYXRhVHlwZS5hcnJheVR5cGUoYnVmZmVyKSwganNhcnJheSwgYXJyYXkuc2hhcGUsIDAsIDApO1xuXHRcdFx0XHRjYWxsYmFja0FyZ3VtZW50c1tpXSA9IGpzYXJyYXk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGNhbGxiYWNrLmFwcGx5KG51bGwsIGNhbGxiYWNrQXJndW1lbnRzKTtcblx0fVxufTtcblxuV2ViQ0xDb250ZXh0LnByb3RvdHlwZS5iYXJyaWVyID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcblx0dmFyIGJhcnJpZXJFdmVudCA9IGNyZWF0ZUV2ZW50KCk7XG5cdHRoaXMucXVldWUuZW5xdWV1ZU1hcmtlcihiYXJyaWVyRXZlbnQpO1xuXHRpZiAodGhpcy5hc3luY0NhbGxiYWNrcykge1xuXHRcdHZhciBxdWV1ZSA9IHRoaXMucXVldWU7XG5cdFx0YmFycmllckV2ZW50LnNldENhbGxiYWNrKGNsLkNPTVBMRVRFLCBmdW5jdGlvbigpIHtcblx0XHRcdGJhcnJpZXJFdmVudC5yZWxlYXNlKCk7XG5cdFx0XHRjYWxsYmFjaygpO1xuXHRcdFx0LyogT3BlbkNMIHN0YW5kYXJkOiBjb21tYW5kcyBlbnF1ZXVlZCBpbiBhIGNhbGxiYWNrIHdvbid0IHN0YXJ0IHVudGlsIGNsRmx1c2ggKi9cblx0XHRcdHF1ZXVlLmZsdXNoKCk7XG5cdFx0fSk7XG5cdFx0Y2wud2FpdEZvckV2ZW50cyhbYmFycmllckV2ZW50XSk7XG5cdH0gZWxzZSB7XG5cdFx0Y2wud2FpdEZvckV2ZW50cyhbYmFycmllckV2ZW50XSk7XG5cdFx0Y2FsbGJhY2soKTtcblx0fVxufTtcblxuV2ViQ0xDb250ZXh0LnByb3RvdHlwZS5yZXNoYXBlID0gZnVuY3Rpb24oYSwgc2hhcGUpIHtcblx0c2hhcGUgPSB1dGlsLmNoZWNrU2hhcGUoc2hhcGUpO1xuXHRpZiAodXRpbC5jb21wdXRlTGVuZ3RoKHNoYXBlKSAhPT0gYS5sZW5ndGgpIHtcblx0XHR0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlRoZSBzaGFwZSBpcyBub3QgY29tcGF0aWJsZSB3aXRoIHRoZSBhcnJheVwiKTtcblx0fVxuXHR2YXIgb3V0ID0gbmV3IE5EQXJyYXkoc2hhcGUsIGEuZGF0YVR5cGUsIHRoaXMpO1xuXHRpZiAoYS5fZGVjUmVmKCkpIHtcblx0XHRvdXQuX2J1ZmZlciA9IHRoaXMuY29udGV4dC5jcmVhdGVCdWZmZXIod2ViY2wuTUVNX1JFQURfV1JJVEUsIG91dC5sZW5ndGggKiBvdXQuZGF0YVR5cGUuc2l6ZSk7XG5cdFx0dGhpcy5xdWV1ZS5lbnF1ZXVlQ29weUJ1ZmZlcihhLl9idWZmZXIsIG91dC5fYnVmZmVyLCAwLCAwLCBvdXQubGVuZ3RoICogb3V0LmRhdGFUeXBlLnNpemUpO1xuXHR9IGVsc2Uge1xuXHRcdG91dC5fYnVmZmVyID0gYS5fYnVmZmVyO1xuXHRcdGEuX2J1ZmZlciA9IG51bGw7XG5cdH1cblx0cmV0dXJuIG91dDtcbn07XG5cbldlYkNMQ29udGV4dC5wcm90b3R5cGUucmVwZWF0ID0gZnVuY3Rpb24oYSwgcmVwZWF0cywgYXhpcywgb3V0KSB7XG5cdHV0aWwuY2hlY2tOREFycmF5KGEsIFwiYVwiKTtcblx0cmVwZWF0cyA9IHV0aWwuY2hlY2tSZXBlYXRzKHJlcGVhdHMpO1xuXHRheGlzID0gdXRpbC5jaGVja0F4aXMoYXhpcywgYS5zaGFwZS5sZW5ndGgpO1xuXHR2YXIgc2hhcGVBID0gYS5zaGFwZTtcblx0dmFyIHNoYXBlT3V0ID0gc2hhcGVBLnNsaWNlKDApO1xuXHRzaGFwZU91dFtheGlzXSAqPSByZXBlYXRzO1xuXHRhLl9kZWNSZWYoKTtcblx0dHJ5IHtcblx0XHRpZiAodHlwZW9mIG91dCA9PT0gXCJ1bmRlZmluZWRcIikge1xuXHRcdFx0b3V0ID0gbmV3IE5EQXJyYXkoc2hhcGVPdXQsIGEuZGF0YVR5cGUsIHRoaXMpO1xuXHRcdFx0b3V0Ll9idWZmZXIgPSB0aGlzLmNvbnRleHQuY3JlYXRlQnVmZmVyKGNsLk1FTV9SRUFEX1dSSVRFLCBvdXQubGVuZ3RoICogb3V0LmRhdGFUeXBlLnNpemUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR1dGlsLmNoZWNrTkRBcnJheShvdXQsIFwib3V0XCIpO1xuXHRcdFx0dXRpbC5jaGVja1NoYXBlc0NvbXBhdGliaWxpdHkob3V0LnNoYXBlLCBzaGFwZU91dCk7XG5cdFx0XHR1dGlsLmNoZWNrRGF0YVR5cGVzQ29tcGF0aWJpbGl0eShhLmRhdGFUeXBlLCBvdXQuZGF0YVR5cGUpO1xuXHRcdFx0b3V0Ll9pbmNSZWYoKTtcblx0XHR9XG5cdFx0dmFyIG91dGVyU3RyaWRlID0gdXRpbC5jb21wdXRlT3V0ZXJTdHJpZGUoc2hhcGVBLCBheGlzKTtcblx0XHR2YXIgZXhwYW5zaW9uRGltID0gc2hhcGVBW2F4aXNdO1xuXHRcdHZhciBpbm5lclN0cmlkZSA9IHV0aWwuY29tcHV0ZUlubmVyU3RyaWRlKHNoYXBlQSwgYXhpcyk7XG5cdFx0dmFyIGtlcm5lbCA9IHRoaXMua2VybmVscy5yZXBlYXRbYS5kYXRhVHlwZS50eXBlXTtcblx0XHRrZXJuZWwuc2V0QXJnKDAsIG5ldyBVaW50MzJBcnJheShbZXhwYW5zaW9uRGltXSkpO1xuXHRcdGtlcm5lbC5zZXRBcmcoMSwgbmV3IFVpbnQzMkFycmF5KFtpbm5lclN0cmlkZV0pKTtcblx0XHRrZXJuZWwuc2V0QXJnKDIsIG5ldyBVaW50MzJBcnJheShbcmVwZWF0c10pKTtcblx0XHRrZXJuZWwuc2V0QXJnKDMsIGEuX2J1ZmZlcik7XG5cdFx0a2VybmVsLnNldEFyZyg0LCBvdXQuX2J1ZmZlcik7XG5cdFx0dGhpcy5xdWV1ZS5lbnF1ZXVlTkRSYW5nZUtlcm5lbChrZXJuZWwsIDMsIG51bGwsIFtvdXRlclN0cmlkZSwgZXhwYW5zaW9uRGltLCBpbm5lclN0cmlkZV0pO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0YS5faW5jUmVmKCk7XG5cdFx0dGhyb3cgZTtcblx0fVxuXHRhLl90cnlJbnZhbGlkYXRlKCk7XG5cdHJldHVybiBvdXQ7XG59O1xuXG52YXIgYmluYXJ5QXJpdGhPcCA9IGZ1bmN0aW9uKGEsIGIsIG91dCwgZnVyaW91c0NvbnRleHQsIGJpbmFyeU9wS2VybmVscywgYmluYXJ5Q29uc3RPcEtlcm5lbHMsIGJpbmFyeVJldkNvbnN0S2VybmVscykge1xuXHR2YXIgc2hhcGVPdXQgPSBudWxsLCBkYXRhVHlwZU91dCA9IG51bGw7XG5cdHZhciBidWZmZXJBID0gbnVsbCwgYnVmZmVyQiA9IG51bGw7XG5cdGlmIChhIGluc3RhbmNlb2YgTkRBcnJheSkge1xuXHRcdGJ1ZmZlckEgPSBhLl9idWZmZXI7XG5cdFx0c2hhcGVPdXQgPSBhLnNoYXBlO1xuXHRcdGRhdGFUeXBlT3V0ID0gYS5kYXRhVHlwZTtcblx0XHRpZiAoYiBpbnN0YW5jZW9mIE5EQXJyYXkpIHtcblx0XHRcdGJ1ZmZlckIgPSBiLl9idWZmZXI7XG5cdFx0XHR1dGlsLmNoZWNrU2hhcGVzQ29tcGF0aWJpbGl0eShhLnNoYXBlLCBiLnNoYXBlKTtcblx0XHRcdHV0aWwuY2hlY2tEYXRhVHlwZXNDb21wYXRpYmlsaXR5KGEuZGF0YVR5cGUsIGIuZGF0YVR5cGUpO1xuXHRcdH0gZWxzZSBpZiAoIXV0aWwuaXNOdW1iZXIoYikpIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoXCJVbnN1cHBvcnRlZCB0eXBlIG9mIGJcIik7XG5cdFx0fVxuXHR9IGVsc2UgaWYgKHV0aWwuaXNOdW1iZXIoYSkpIHtcblx0XHR1dGlsLmNoZWNrTkRBcnJheShiLCBcImJcIik7XG5cdFx0YnVmZmVyQiA9IGIuX2J1ZmZlcjtcblx0XHRzaGFwZU91dCA9IGIuc2hhcGU7XG5cdFx0ZGF0YVR5cGVPdXQgPSBiLmRhdGFUeXBlO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoXCJVbnN1cHBvcnRlZCB0eXBlIG9mIGFcIik7XG5cdH1cblx0aWYgKGEgaW5zdGFuY2VvZiBOREFycmF5KSB7XG5cdFx0YS5fZGVjUmVmKCk7XG5cdH1cblx0aWYgKGIgaW5zdGFuY2VvZiBOREFycmF5KSB7XG5cdFx0Yi5fZGVjUmVmKCk7XG5cdH1cblx0dHJ5IHtcblx0XHRpZiAodHlwZW9mIG91dCA9PT0gXCJ1bmRlZmluZWRcIikge1xuXHRcdFx0b3V0ID0gbmV3IE5EQXJyYXkoc2hhcGVPdXQsIGRhdGFUeXBlT3V0LCBmdXJpb3VzQ29udGV4dCk7XG5cdFx0XHRpZiAoKGEgaW5zdGFuY2VvZiBOREFycmF5KSAmJiAhYS5faGFzUmVmcygpKSB7XG5cdFx0XHRcdG91dC5fYnVmZmVyID0gYS5fYnVmZmVyO1xuXHRcdFx0XHRhLl9idWZmZXIgPSBudWxsO1xuXHRcdFx0fSBlbHNlIGlmICgoYiBpbnN0YW5jZW9mIE5EQXJyYXkpICYmICFiLl9oYXNSZWZzKCkpIHtcblx0XHRcdFx0b3V0Ll9idWZmZXIgPSBiLl9idWZmZXI7XG5cdFx0XHRcdGIuX2J1ZmZlciA9IG51bGw7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvdXQuX2J1ZmZlciA9IGZ1cmlvdXNDb250ZXh0LmNvbnRleHQuY3JlYXRlQnVmZmVyKGNsLk1FTV9SRUFEX1dSSVRFLCBvdXQubGVuZ3RoICogb3V0LmRhdGFUeXBlLnNpemUpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR1dGlsLmNoZWNrTkRBcnJheShvdXQsIFwib3V0XCIpO1xuXHRcdFx0dXRpbC5jaGVja1NoYXBlc0NvbXBhdGliaWxpdHkoc2hhcGVPdXQsIG91dC5zaGFwZSk7XG5cdFx0XHR1dGlsLmNoZWNrRGF0YVR5cGVzQ29tcGF0aWJpbGl0eShkYXRhVHlwZU91dCwgb3V0LmRhdGFUeXBlKTtcblx0XHRcdG91dC5faW5jUmVmKCk7XG5cdFx0fVxuXHRcdGlmIChhIGluc3RhbmNlb2YgTkRBcnJheSkge1xuXHRcdFx0aWYgKGIgaW5zdGFuY2VvZiBOREFycmF5KSB7XG5cdFx0XHRcdHZhciBrZXJuZWwgPSBiaW5hcnlPcEtlcm5lbHNbZGF0YVR5cGVPdXQudHlwZV07XG5cdFx0XHRcdGtlcm5lbC5zZXRBcmcoMCwgbmV3IFVpbnQzMkFycmF5KFtvdXQubGVuZ3RoXSkpO1xuXHRcdFx0XHRrZXJuZWwuc2V0QXJnKDEsIGJ1ZmZlckEpO1xuXHRcdFx0XHRrZXJuZWwuc2V0QXJnKDIsIGJ1ZmZlckIpO1xuXHRcdFx0XHRrZXJuZWwuc2V0QXJnKDMsIG91dC5fYnVmZmVyKTtcblx0XHRcdFx0ZnVyaW91c0NvbnRleHQucXVldWUuZW5xdWV1ZU5EUmFuZ2VLZXJuZWwoa2VybmVsLCAxLCBudWxsLCBbb3V0Lmxlbmd0aF0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIGtlcm5lbCA9IGJpbmFyeUNvbnN0T3BLZXJuZWxzW2RhdGFUeXBlT3V0LnR5cGVdO1xuXHRcdFx0XHRrZXJuZWwuc2V0QXJnKDAsIG5ldyBVaW50MzJBcnJheShbb3V0Lmxlbmd0aF0pKTtcblx0XHRcdFx0a2VybmVsLnNldEFyZygxLCBidWZmZXJBKTtcblx0XHRcdFx0a2VybmVsLnNldEFyZygyLCBuZXcgZGF0YVR5cGVPdXQuYXJyYXlUeXBlKFtiXSkpO1xuXHRcdFx0XHRrZXJuZWwuc2V0QXJnKDMsIG91dC5fYnVmZmVyKTtcblx0XHRcdFx0ZnVyaW91c0NvbnRleHQucXVldWUuZW5xdWV1ZU5EUmFuZ2VLZXJuZWwoa2VybmVsLCAxLCBudWxsLCBbb3V0Lmxlbmd0aF0pO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIga2VybmVsID0gYmluYXJ5UmV2Q29uc3RLZXJuZWxzW2RhdGFUeXBlT3V0LnR5cGVdO1xuXHRcdFx0a2VybmVsLnNldEFyZygwLCBuZXcgVWludDMyQXJyYXkoW291dC5sZW5ndGhdKSk7XG5cdFx0XHRrZXJuZWwuc2V0QXJnKDEsIGJ1ZmZlckIpO1xuXHRcdFx0a2VybmVsLnNldEFyZygyLCBuZXcgZGF0YVR5cGVPdXQuYXJyYXlUeXBlKFthXSkpO1xuXHRcdFx0a2VybmVsLnNldEFyZygzLCBvdXQuX2J1ZmZlcik7XG5cdFx0XHRmdXJpb3VzQ29udGV4dC5xdWV1ZS5lbnF1ZXVlTkRSYW5nZUtlcm5lbChrZXJuZWwsIDEsIG51bGwsIFtvdXQubGVuZ3RoXSk7XG5cdFx0fVxuXHR9IGNhdGNoIChlKSB7XG5cdFx0LyogUmVzdG9yZSB0aGUgcHJldmlvdXMgc3RhdGUgKi9cblx0XHRpZiAoYSBpbnN0YW5jZW9mIE5EQXJyYXkpIHtcblx0XHRcdGEuX2luY1JlZigpO1xuXHRcdH1cblx0XHRpZiAoYiBpbnN0YW5jZW9mIE5EQXJyYXkpIHtcblx0XHRcdGIuX2luY1JlZigpO1xuXHRcdH1cblx0XHR0aHJvdyBlO1xuXHR9XG5cdGlmIChhIGluc3RhbmNlb2YgTkRBcnJheSkge1xuXHRcdGEuX3RyeUludmFsaWRhdGUoKTtcblx0fVxuXHRpZiAoYiBpbnN0YW5jZW9mIE5EQXJyYXkpIHtcblx0XHRiLl90cnlJbnZhbGlkYXRlKCk7XG5cdH1cblx0cmV0dXJuIG91dDtcbn07XG5cbnZhciB1bmFyeUFyaXRoT3AgPSBmdW5jdGlvbihhLCBvdXQsIGZ1cmlvdXNDb250ZXh0LCB1bmFyeU9wS2VybmVscykge1xuXHR1dGlsLmNoZWNrTkRBcnJheShhLCBcImFcIik7XG5cdGEuX2RlY1JlZigpO1xuXHR2YXIgYnVmZmVyQSA9IGEuX2J1ZmZlcjtcblx0dHJ5IHtcblx0XHRpZiAodHlwZW9mIG91dCA9PT0gXCJ1bmRlZmluZWRcIikge1xuXHRcdFx0b3V0ID0gbmV3IE5EQXJyYXkoYS5zaGFwZSwgYS5kYXRhVHlwZSwgZnVyaW91c0NvbnRleHQpO1xuXHRcdFx0aWYgKChhIGluc3RhbmNlb2YgTkRBcnJheSkgJiYgIWEuX2hhc1JlZnMoKSkge1xuXHRcdFx0XHRvdXQuX2J1ZmZlciA9IGEuX2J1ZmZlcjtcblx0XHRcdFx0YS5fYnVmZmVyID0gbnVsbDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG91dC5fYnVmZmVyID0gZnVyaW91c0NvbnRleHQuY29udGV4dC5jcmVhdGVCdWZmZXIoY2wuTUVNX1JFQURfV1JJVEUsIG91dC5sZW5ndGggKiBvdXQuZGF0YVR5cGUuc2l6ZSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHV0aWwuY2hlY2tOREFycmF5KG91dCwgXCJvdXRcIik7XG5cdFx0XHR1dGlsLmNoZWNrU2hhcGVzQ29tcGF0aWJpbGl0eShhLnNoYXBlLCBvdXQuc2hhcGUpO1xuXHRcdFx0dXRpbC5jaGVja0RhdGFUeXBlc0NvbXBhdGliaWxpdHkoYS5kYXRhVHlwZSwgb3V0LmRhdGFUeXBlKTtcblx0XHRcdG91dC5faW5jUmVmKCk7XG5cdFx0fVxuXHRcdHZhciBrZXJuZWwgPSB1bmFyeU9wS2VybmVsc1thLmRhdGFUeXBlLnR5cGVdO1xuXHRcdGtlcm5lbC5zZXRBcmcoMCwgbmV3IFVpbnQzMkFycmF5KFtvdXQubGVuZ3RoXSkpO1xuXHRcdGtlcm5lbC5zZXRBcmcoMSwgYnVmZmVyQSk7XG5cdFx0a2VybmVsLnNldEFyZygyLCBvdXQuX2J1ZmZlcik7XG5cdFx0ZnVyaW91c0NvbnRleHQucXVldWUuZW5xdWV1ZU5EUmFuZ2VLZXJuZWwoa2VybmVsLCAxLCBudWxsLCBbb3V0Lmxlbmd0aF0pO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0LyogUmVzdG9yZSB0aGUgcHJldmlvdXMgc3RhdGUgKi9cblx0XHRhLl9pbmNSZWYoKTtcblx0XHR0aHJvdyBlO1xuXHR9XG5cdGEuX3RyeUludmFsaWRhdGUoKTtcblx0cmV0dXJuIG91dDtcbn07XG5cbnZhciBheGlzUmVkdWNlT3AgPSBmdW5jdGlvbihhLCBheGlzLCBvdXQsIGZ1cmlvdXNDb250ZXh0LCByZWR1Y2VLZXJuZWxzLCBheGlzUmVkdWNlS2VybmVscykge1xuXHR1dGlsLmNoZWNrTkRBcnJheShhLCBcImFcIik7XG5cdGlmICh0eXBlb2YgYXhpcyA9PT0gXCJ1bmRlZmluZWRcIikge1xuXHRcdGlmICh0eXBlb2Ygb3V0ID09PSBcInVuZGVmaW5lZFwiKSB7XG5cdFx0XHRvdXQgPSBuZXcgTkRBcnJheShbXSwgYS5kYXRhVHlwZSwgZnVyaW91c0NvbnRleHQpO1xuXHRcdFx0b3V0Ll9idWZmZXIgPSBmdXJpb3VzQ29udGV4dC5jb250ZXh0LmNyZWF0ZUJ1ZmZlcihjbC5NRU1fUkVBRF9XUklURSwgYS5kYXRhVHlwZS5zaXplKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dXRpbC5jaGVja05EQXJyYXkob3V0LCBcIm91dFwiKTtcblx0XHRcdHV0aWwuY2hlY2tTaGFwZXNDb21wYXRpYmlsaXR5KFtdLCBvdXQuc2hhcGUpO1xuXHRcdFx0dXRpbC5jaGVja0RhdGFUeXBlc0NvbXBhdGliaWxpdHkoYS5kYXRhVHlwZSwgb3V0LmRhdGFUeXBlKTtcblx0XHRcdG91dC5faW5jUmVmKCk7XG5cdFx0fVxuXHRcdHZhciBsZW5ndGhBID0gYS5sZW5ndGg7XG5cdFx0dmFyIG1heFdvcmtJdGVtc1BlckNVID0gTWF0aC5taW4oXG5cdFx0XHRNYXRoLm1pbihmdXJpb3VzQ29udGV4dC5kZXZpY2VJbmZvLm1heFdvcmtHcm91cFNpemUsXG5cdFx0XHRcdGZ1cmlvdXNDb250ZXh0LmRldmljZUluZm8ubWF4V29ya0l0ZW1TaXplc1swXSksIFxuXHRcdFx0ZnVyaW91c0NvbnRleHQuZGV2aWNlSW5mby5sb2NhbE1lbW9yeVNpemUgLyBhLmRhdGFUeXBlLnNpemUpO1xuXHRcdC8qIFRoZSBtaW5pbWFsIGFtbW91bnQgb2YgcGFyYWxsZWxpc20gdGhhdCBqdXN0aWZpZXMgc3dpdGNoaW5nIHRvIHR3by1wYXNzIHJlZHVjdGlvbiAqL1xuXHRcdHZhciBwYXJhbGxlbGlzYXRpb25UaHJlc2hvbGQgPSAxNjtcblx0XHR2YXIga2VybmVsID0gcmVkdWNlS2VybmVsc1thLmRhdGFUeXBlLnR5cGVdO1xuXHRcdGlmIChsZW5ndGhBIDwgbWF4V29ya0l0ZW1zUGVyQ1UgKiBwYXJhbGxlbGlzYXRpb25UaHJlc2hvbGQpIHtcblx0XHRcdC8qIE9uZSByZWR1Y3Rpb24gaXMgZW5vdWdoICovXG5cdFx0XHRrZXJuZWwuc2V0QXJnKDAsIG5ldyBVaW50MzJBcnJheShbbGVuZ3RoQV0pKTtcblx0XHRcdGtlcm5lbC5zZXRBcmcoMSwgYS5fYnVmZmVyKTtcblx0XHRcdGtlcm5lbC5zZXRBcmcoMiwgbmV3IFVpbnQzMkFycmF5KFttYXhXb3JrSXRlbXNQZXJDVSAqIGEuZGF0YVR5cGUuc2l6ZV0pKTtcblx0XHRcdGtlcm5lbC5zZXRBcmcoMywgb3V0Ll9idWZmZXIpO1xuXHRcdFx0LyogSW1wb3J0YW50OiB1c2Ugb25seSBvbmUgd29yayBncm91cCAqL1xuXHRcdFx0ZnVyaW91c0NvbnRleHQucXVldWUuZW5xdWV1ZU5EUmFuZ2VLZXJuZWwoa2VybmVsLCAxLCBudWxsLCBbbWF4V29ya0l0ZW1zUGVyQ1VdLCBbbWF4V29ya0l0ZW1zUGVyQ1VdKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0LyogVHdvLXN0ZXAgcmVkdWN0aW9uICovXG5cdFx0XHR2YXIgbWF4Q29tcHV0ZVVuaXRzID0gZnVyaW91c0NvbnRleHQuZGV2aWNlSW5mby5tYXhDb21wdXRlVW5pdHM7XG5cdFx0XHR2YXIgd29ya0dyb3VwU2l6ZU11bHRpcGxlID0ga2VybmVsLmdldFdvcmtHcm91cEluZm8oZnVyaW91c0NvbnRleHQuZGV2aWNlLCBjbC5LRVJORUxfUFJFRkVSUkVEX1dPUktfR1JPVVBfU0laRV9NVUxUSVBMRSk7XG5cdFx0XHR2YXIgdGVtcEJ1ZmZlciA9IGZ1cmlvdXNDb250ZXh0LmNvbnRleHQuY3JlYXRlQnVmZmVyKGNsLk1FTV9SRUFEX1dSSVRFLCBtYXhDb21wdXRlVW5pdHMgKiBhLmRhdGFUeXBlLnNpemUpO1xuXG5cdFx0XHRrZXJuZWwuc2V0QXJnKDAsIG5ldyBVaW50MzJBcnJheShbbGVuZ3RoQV0pKTtcblx0XHRcdGtlcm5lbC5zZXRBcmcoMSwgYS5fYnVmZmVyKTtcblx0XHRcdGtlcm5lbC5zZXRBcmcoMiwgbmV3IFVpbnQzMkFycmF5KFttYXhXb3JrSXRlbXNQZXJDVSAqIGEuZGF0YVR5cGUuc2l6ZV0pKTtcblx0XHRcdGtlcm5lbC5zZXRBcmcoMywgdGVtcEJ1ZmZlcik7XG5cdFx0XHRmdXJpb3VzQ29udGV4dC5xdWV1ZS5lbnF1ZXVlTkRSYW5nZUtlcm5lbChrZXJuZWwsIDEsIG51bGwsXG5cdFx0XHRcdFttYXhXb3JrSXRlbXNQZXJDVSAqIG1heENvbXB1dGVVbml0c10sXG5cdFx0XHRcdFttYXhXb3JrSXRlbXNQZXJDVV0pO1xuXG5cdFx0XHR2YXIgd29ya0dyb3VwU2l6ZSA9IE1hdGgubWluKG1heFdvcmtJdGVtc1BlckNVLFxuXHRcdFx0XHR1dGlsLnJvdW5kVXAobWF4Q29tcHV0ZVVuaXRzLCB3b3JrR3JvdXBTaXplTXVsdGlwbGUpKTtcblx0XHRcdGtlcm5lbC5zZXRBcmcoMCwgbmV3IFVpbnQzMkFycmF5KFttYXhDb21wdXRlVW5pdHNdKSk7XG5cdFx0XHRrZXJuZWwuc2V0QXJnKDEsIHRlbXBCdWZmZXIpO1xuXHRcdFx0a2VybmVsLnNldEFyZygyLCBuZXcgVWludDMyQXJyYXkoW3dvcmtHcm91cFNpemUgKiBhLmRhdGFUeXBlLnNpemVdKSk7XG5cdFx0XHRrZXJuZWwuc2V0QXJnKDMsIG91dC5fYnVmZmVyKTtcblx0XHRcdC8qIEltcG9ydGFudDogdXNlIG9ubHkgb25lIHdvcmsgZ3JvdXAgKi9cblx0XHRcdGZ1cmlvdXNDb250ZXh0LnF1ZXVlLmVucXVldWVORFJhbmdlS2VybmVsKGtlcm5lbCwgMSwgbnVsbCxcblx0XHRcdFx0W3dvcmtHcm91cFNpemVdLFxuXHRcdFx0XHRbd29ya0dyb3VwU2l6ZV0pO1xuXG5cdFx0XHR0ZW1wQnVmZmVyLnJlbGVhc2UoKTtcblx0XHR9XG5cdFx0YS5fdHJ5UmVsZWFzZSgpO1xuXHRcdHJldHVybiBvdXQ7XG5cdH0gZWxzZSB7XG5cdFx0YXhpcyA9IHV0aWwuY2hlY2tBeGlzKGF4aXMsIGEuc2hhcGUubGVuZ3RoKTtcblx0XHR2YXIgc2hhcGVPdXQgPSB1dGlsLmNvbXB1dGVBeGlzUmVkdWN0aW9uT3V0U2hhcGUoYS5zaGFwZSwgYXhpcyk7XG5cdFx0aWYgKHR5cGVvZiBvdXQgPT09IFwidW5kZWZpbmVkXCIpIHtcblx0XHRcdG91dCA9IG5ldyBOREFycmF5KHNoYXBlT3V0LCBhLmRhdGFUeXBlLCBmdXJpb3VzQ29udGV4dCk7XG5cdFx0XHRvdXQuX2J1ZmZlciA9IGZ1cmlvdXNDb250ZXh0LmNvbnRleHQuY3JlYXRlQnVmZmVyKGNsLk1FTV9SRUFEX1dSSVRFLCBhLmRhdGFUeXBlLnNpemUgKiBvdXQubGVuZ3RoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dXRpbC5jaGVja05EQXJyYXkob3V0LCBcIm91dFwiKTtcblx0XHRcdHV0aWwuY2hlY2tTaGFwZXNDb21wYXRpYmlsaXR5KFtdLCBvdXQuc2hhcGUpO1xuXHRcdFx0dXRpbC5jaGVja0RhdGFUeXBlc0NvbXBhdGliaWxpdHkoYS5kYXRhVHlwZSwgb3V0LmRhdGFUeXBlKTtcblx0XHRcdG91dC5faW5jUmVmKCk7XG5cdFx0fVxuXHRcdHZhciBvdXRlclN0cmlkZSA9IHV0aWwuY29tcHV0ZU91dGVyU3RyaWRlKGEuc2hhcGUsIGF4aXMpO1xuXHRcdHZhciByZWR1Y3Rpb25EaW0gPSBhLnNoYXBlW2F4aXNdO1xuXHRcdHZhciBpbm5lclN0cmlkZSA9IHV0aWwuY29tcHV0ZUlubmVyU3RyaWRlKGEuc2hhcGUsIGF4aXMpO1xuXHRcdHZhciBrZXJuZWwgPSBheGlzUmVkdWNlS2VybmVsc1thLmRhdGFUeXBlLnR5cGVdO1xuXHRcdGtlcm5lbC5zZXRBcmcoMCwgbmV3IFVpbnQzMkFycmF5KFtyZWR1Y3Rpb25EaW1dKSk7XG5cdFx0a2VybmVsLnNldEFyZygxLCBhLl9idWZmZXIpO1xuXHRcdGtlcm5lbC5zZXRBcmcoMiwgb3V0Ll9idWZmZXIpO1xuXHRcdGZ1cmlvdXNDb250ZXh0LnF1ZXVlLmVucXVldWVORFJhbmdlS2VybmVsKGtlcm5lbCwgMiwgbnVsbCxcblx0XHRcdFtvdXRlclN0cmlkZSwgaW5uZXJTdHJpZGVdKTtcblx0XHRhLl90cnlSZWxlYXNlKCk7XG5cdFx0cmV0dXJuIG91dDtcblx0fVxufTtcblxuXG5XZWJDTENvbnRleHQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKGEsIGIsIG91dCkge1xuXHRyZXR1cm4gYmluYXJ5QXJpdGhPcChhLCBiLCBvdXQsIHRoaXMsIHRoaXMua2VybmVscy5hZGQsIHRoaXMua2VybmVscy5hZGRjLCB0aGlzLmtlcm5lbHMuYWRkYyk7XG59O1xuXG5XZWJDTENvbnRleHQucHJvdG90eXBlLnN1YiA9IGZ1bmN0aW9uKGEsIGIsIG91dCkge1xuXHRyZXR1cm4gYmluYXJ5QXJpdGhPcChhLCBiLCBvdXQsIHRoaXMsIHRoaXMua2VybmVscy5zdWIsIHRoaXMua2VybmVscy5zdWJjLCB0aGlzLmtlcm5lbHMuc3VicmMpO1xufTtcblxuV2ViQ0xDb250ZXh0LnByb3RvdHlwZS5tdWwgPSBmdW5jdGlvbihhLCBiLCBvdXQpIHtcblx0cmV0dXJuIGJpbmFyeUFyaXRoT3AoYSwgYiwgb3V0LCB0aGlzLCB0aGlzLmtlcm5lbHMubXVsLCB0aGlzLmtlcm5lbHMubXVsYywgdGhpcy5rZXJuZWxzLm11bGMpO1xufTtcblxuV2ViQ0xDb250ZXh0LnByb3RvdHlwZS5kaXYgPSBmdW5jdGlvbihhLCBiLCBvdXQpIHtcblx0cmV0dXJuIGJpbmFyeUFyaXRoT3AoYSwgYiwgb3V0LCB0aGlzLCB0aGlzLmtlcm5lbHMuZGl2LCB0aGlzLmtlcm5lbHMuZGl2YywgdGhpcy5rZXJuZWxzLmRpdnJjKTtcbn07XG5cbldlYkNMQ29udGV4dC5wcm90b3R5cGUubmVnID0gZnVuY3Rpb24oYSwgb3V0KSB7XG5cdHJldHVybiB1bmFyeUFyaXRoT3AoYSwgb3V0LCB0aGlzLCB0aGlzLmtlcm5lbHMubmVnKTtcbn07XG5cbldlYkNMQ29udGV4dC5wcm90b3R5cGUuYWJzID0gZnVuY3Rpb24oYSwgb3V0KSB7XG5cdHJldHVybiB1bmFyeUFyaXRoT3AoYSwgb3V0LCB0aGlzLCB0aGlzLmtlcm5lbHMuYWJzKTtcbn07XG5cbldlYkNMQ29udGV4dC5wcm90b3R5cGUuZXhwID0gZnVuY3Rpb24oYSwgb3V0KSB7XG5cdHJldHVybiB1bmFyeUFyaXRoT3AoYSwgb3V0LCB0aGlzLCB0aGlzLmtlcm5lbHMuZXhwKTtcbn07XG5cbldlYkNMQ29udGV4dC5wcm90b3R5cGUubG9nID0gZnVuY3Rpb24oYSwgb3V0KSB7XG5cdHJldHVybiB1bmFyeUFyaXRoT3AoYSwgb3V0LCB0aGlzLCB0aGlzLmtlcm5lbHMubG9nKTtcbn07XG5cbldlYkNMQ29udGV4dC5wcm90b3R5cGUuc3FydCA9IGZ1bmN0aW9uKGEsIG91dCkge1xuXHRyZXR1cm4gdW5hcnlBcml0aE9wKGEsIG91dCwgdGhpcywgdGhpcy5rZXJuZWxzLnNxcnQpO1xufTtcblxuV2ViQ0xDb250ZXh0LnByb3RvdHlwZS5zcXVhcmUgPSBmdW5jdGlvbihhLCBvdXQpIHtcblx0cmV0dXJuIHVuYXJ5QXJpdGhPcChhLCBvdXQsIHRoaXMsIHRoaXMua2VybmVscy5zcXVhcmUpO1xufTtcblxuV2ViQ0xDb250ZXh0LnByb3RvdHlwZS5taW4gPSBmdW5jdGlvbihhLCBheGlzLCBvdXQpIHtcblx0cmV0dXJuIGF4aXNSZWR1Y2VPcChhLCBheGlzLCBvdXQsIHRoaXMsIHRoaXMua2VybmVscy5taW4sIHRoaXMua2VybmVscy5hbWluKTtcbn07XG5cbldlYkNMQ29udGV4dC5wcm90b3R5cGUubWF4ID0gZnVuY3Rpb24oYSwgYXhpcywgb3V0KSB7XG5cdHJldHVybiBheGlzUmVkdWNlT3AoYSwgYXhpcywgb3V0LCB0aGlzLCB0aGlzLmtlcm5lbHMubWF4LCB0aGlzLmtlcm5lbHMuYW1heCk7XG59O1xuXG5XZWJDTENvbnRleHQucHJvdG90eXBlLnN1bSA9IGZ1bmN0aW9uKGEsIGF4aXMsIG91dCkge1xuXHRyZXR1cm4gYXhpc1JlZHVjZU9wKGEsIGF4aXMsIG91dCwgdGhpcywgdGhpcy5rZXJuZWxzLnN1bSwgdGhpcy5rZXJuZWxzLmFzdW0pO1xufTtcblxuV2ViQ0xDb250ZXh0LnByb3RvdHlwZS5kb3QgPSBmdW5jdGlvbihhLCBiLCBvdXQpIHtcblx0dXRpbC5jaGVja05EQXJyYXkoYSwgXCJhXCIpO1xuXHR1dGlsLmNoZWNrTkRBcnJheShiLCBcImJcIik7XG5cdHV0aWwuY2hlY2tEYXRhVHlwZXNDb21wYXRpYmlsaXR5KGEuZGF0YVR5cGUsIGIuZGF0YVR5cGUpO1xuXG5cdC8qIFRoZSBheGlzIG9mIGIgdXNlZCBpbiByZWR1Y3Rpb246IGF4aXMgMCBmb3IgMUQgYXJyYXksIHNlY29uZC10by1sYXN0IGF4aXMgZm9yIE5EIGFycmF5ICovXG5cdHZhciBhQXhpcyA9IE1hdGgubWF4KGEuc2hhcGUubGVuZ3RoIC0gMSwgMCk7XG5cdHZhciBiQXhpcyA9IE1hdGgubWF4KGIuc2hhcGUubGVuZ3RoIC0gMiwgMCk7XG5cdHZhciByZWR1Y3Rpb25EaW0gPSBhLnNoYXBlW2FBeGlzXTtcblx0aWYgKHJlZHVjdGlvbkRpbSAhPT0gYi5zaGFwZVtiQXhpc10pIHtcblx0XHR0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkFycmF5cyBoYXZlIGluY29tcGF0aWJsZSByZWR1Y3Rpb24gZGltZW5zaW9uc1wiKTtcblx0fVxuXHR2YXIgc2hhcGVPdXQgPSBbXSwgc3RyaWRlQSA9IDEsIG91dGVyU3RyaWRlQiA9IDEsIGlubmVyU3RyaWRlQiA9IDE7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgYUF4aXM7IGkrKykge1xuXHRcdHNoYXBlT3V0LnB1c2goYS5zaGFwZVtpXSk7XG5cdFx0c3RyaWRlQSAqPSBhLnNoYXBlW2ldO1xuXHR9XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgYi5zaGFwZS5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBkaW0gPSBiLnNoYXBlW2ldO1xuXHRcdGlmIChpIDwgYkF4aXMpIHtcblx0XHRcdG91dGVyU3RyaWRlQiAqPSBkaW07XG5cdFx0XHRzaGFwZU91dC5wdXNoKGRpbSk7XG5cdFx0fSBlbHNlIGlmIChpID4gYkF4aXMpIHtcblx0XHRcdGlubmVyU3RyaWRlQiAqPSBkaW07XG5cdFx0XHRzaGFwZU91dC5wdXNoKGRpbSk7XG5cdFx0fVxuXHR9XG5cdGlmICh0eXBlb2Ygb3V0ID09PSBcInVuZGVmaW5lZFwiKSB7XG5cdFx0b3V0ID0gdGhpcy5lbXB0eShzaGFwZU91dCwgYS5kYXRhVHlwZSk7XG5cdH0gZWxzZSBpZiAob3V0IGluc3RhbmNlb2YgTkRBcnJheSkge1xuXHRcdHV0aWwuY2hlY2tOREFycmF5KG91dCwgXCJvdXRcIik7XG5cdFx0dXRpbC5jaGVja1NoYXBlc0NvbXBhdGliaWxpdHkob3V0LnNoYXBlLCBzaGFwZU91dCk7XG5cdFx0dXRpbC5jaGVja0RhdGFUeXBlc0NvbXBhdGliaWxpdHkob3V0LmRhdGFUeXBlLCBhLmRhdGFUeXBlKTtcblx0XHR1dGlsLmNoZWNrRGlmZmVyZW50TkRBcnJheXMoYSwgb3V0LCBcImFcIiwgXCJvdXRcIik7XG5cdFx0dXRpbC5jaGVja0RpZmZlcmVudE5EQXJyYXlzKGIsIG91dCwgXCJiXCIsIFwib3V0XCIpO1xuXHRcdG91dC5faW5jUmVmKCk7XG5cdH1cblx0dmFyIGtlcm5lbCA9IHRoaXMua2VybmVscy5kb3Rbb3V0LmRhdGFUeXBlLnR5cGVdO1xuXHRrZXJuZWwuc2V0QXJnKDAsIG5ldyBVaW50MzJBcnJheShbcmVkdWN0aW9uRGltXSkpO1xuXHRrZXJuZWwuc2V0QXJnKDEsIGEuX2J1ZmZlcik7XG5cdGtlcm5lbC5zZXRBcmcoMiwgYi5fYnVmZmVyKTtcblx0a2VybmVsLnNldEFyZygzLCBvdXQuX2J1ZmZlcik7XG5cdHRoaXMucXVldWUuZW5xdWV1ZU5EUmFuZ2VLZXJuZWwoa2VybmVsLCAzLCBudWxsLFxuXHRcdFtzdHJpZGVBLCBvdXRlclN0cmlkZUIsIGlubmVyU3RyaWRlQl0pO1xuXHRhLl90cnlSZWxlYXNlKCk7XG5cdGIuX3RyeVJlbGVhc2UoKTtcblx0cmV0dXJuIG91dDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gV2ViQ0xDb250ZXh0O1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9jaGFpJyk7XG4iLCIvKiFcbiAqIGNoYWlcbiAqIENvcHlyaWdodChjKSAyMDExLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG52YXIgdXNlZCA9IFtdXG4gICwgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8qIVxuICogQ2hhaSB2ZXJzaW9uXG4gKi9cblxuZXhwb3J0cy52ZXJzaW9uID0gJzEuOS4xJztcblxuLyohXG4gKiBBc3NlcnRpb24gRXJyb3JcbiAqL1xuXG5leHBvcnRzLkFzc2VydGlvbkVycm9yID0gcmVxdWlyZSgnYXNzZXJ0aW9uLWVycm9yJyk7XG5cbi8qIVxuICogVXRpbHMgZm9yIHBsdWdpbnMgKG5vdCBleHBvcnRlZClcbiAqL1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vY2hhaS91dGlscycpO1xuXG4vKipcbiAqICMgLnVzZShmdW5jdGlvbilcbiAqXG4gKiBQcm92aWRlcyBhIHdheSB0byBleHRlbmQgdGhlIGludGVybmFscyBvZiBDaGFpXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn1cbiAqIEByZXR1cm5zIHt0aGlzfSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy51c2UgPSBmdW5jdGlvbiAoZm4pIHtcbiAgaWYgKCF+dXNlZC5pbmRleE9mKGZuKSkge1xuICAgIGZuKHRoaXMsIHV0aWwpO1xuICAgIHVzZWQucHVzaChmbik7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qIVxuICogQ29uZmlndXJhdGlvblxuICovXG5cbnZhciBjb25maWcgPSByZXF1aXJlKCcuL2NoYWkvY29uZmlnJyk7XG5leHBvcnRzLmNvbmZpZyA9IGNvbmZpZztcblxuLyohXG4gKiBQcmltYXJ5IGBBc3NlcnRpb25gIHByb3RvdHlwZVxuICovXG5cbnZhciBhc3NlcnRpb24gPSByZXF1aXJlKCcuL2NoYWkvYXNzZXJ0aW9uJyk7XG5leHBvcnRzLnVzZShhc3NlcnRpb24pO1xuXG4vKiFcbiAqIENvcmUgQXNzZXJ0aW9uc1xuICovXG5cbnZhciBjb3JlID0gcmVxdWlyZSgnLi9jaGFpL2NvcmUvYXNzZXJ0aW9ucycpO1xuZXhwb3J0cy51c2UoY29yZSk7XG5cbi8qIVxuICogRXhwZWN0IGludGVyZmFjZVxuICovXG5cbnZhciBleHBlY3QgPSByZXF1aXJlKCcuL2NoYWkvaW50ZXJmYWNlL2V4cGVjdCcpO1xuZXhwb3J0cy51c2UoZXhwZWN0KTtcblxuLyohXG4gKiBTaG91bGQgaW50ZXJmYWNlXG4gKi9cblxudmFyIHNob3VsZCA9IHJlcXVpcmUoJy4vY2hhaS9pbnRlcmZhY2Uvc2hvdWxkJyk7XG5leHBvcnRzLnVzZShzaG91bGQpO1xuXG4vKiFcbiAqIEFzc2VydCBpbnRlcmZhY2VcbiAqL1xuXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnLi9jaGFpL2ludGVyZmFjZS9hc3NlcnQnKTtcbmV4cG9ydHMudXNlKGFzc2VydCk7XG4iLCIvKiFcbiAqIGNoYWlcbiAqIGh0dHA6Ly9jaGFpanMuY29tXG4gKiBDb3B5cmlnaHQoYykgMjAxMS0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxudmFyIGNvbmZpZyA9IHJlcXVpcmUoJy4vY29uZmlnJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKF9jaGFpLCB1dGlsKSB7XG4gIC8qIVxuICAgKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICAgKi9cblxuICB2YXIgQXNzZXJ0aW9uRXJyb3IgPSBfY2hhaS5Bc3NlcnRpb25FcnJvclxuICAgICwgZmxhZyA9IHV0aWwuZmxhZztcblxuICAvKiFcbiAgICogTW9kdWxlIGV4cG9ydC5cbiAgICovXG5cbiAgX2NoYWkuQXNzZXJ0aW9uID0gQXNzZXJ0aW9uO1xuXG4gIC8qIVxuICAgKiBBc3NlcnRpb24gQ29uc3RydWN0b3JcbiAgICpcbiAgICogQ3JlYXRlcyBvYmplY3QgZm9yIGNoYWluaW5nLlxuICAgKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG5cbiAgZnVuY3Rpb24gQXNzZXJ0aW9uIChvYmosIG1zZywgc3RhY2spIHtcbiAgICBmbGFnKHRoaXMsICdzc2ZpJywgc3RhY2sgfHwgYXJndW1lbnRzLmNhbGxlZSk7XG4gICAgZmxhZyh0aGlzLCAnb2JqZWN0Jywgb2JqKTtcbiAgICBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgfVxuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBc3NlcnRpb24sICdpbmNsdWRlU3RhY2snLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnNvbGUud2FybignQXNzZXJ0aW9uLmluY2x1ZGVTdGFjayBpcyBkZXByZWNhdGVkLCB1c2UgY2hhaS5jb25maWcuaW5jbHVkZVN0YWNrIGluc3RlYWQuJyk7XG4gICAgICByZXR1cm4gY29uZmlnLmluY2x1ZGVTdGFjaztcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIGNvbnNvbGUud2FybignQXNzZXJ0aW9uLmluY2x1ZGVTdGFjayBpcyBkZXByZWNhdGVkLCB1c2UgY2hhaS5jb25maWcuaW5jbHVkZVN0YWNrIGluc3RlYWQuJyk7XG4gICAgICBjb25maWcuaW5jbHVkZVN0YWNrID0gdmFsdWU7XG4gICAgfVxuICB9KTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQXNzZXJ0aW9uLCAnc2hvd0RpZmYnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnNvbGUud2FybignQXNzZXJ0aW9uLnNob3dEaWZmIGlzIGRlcHJlY2F0ZWQsIHVzZSBjaGFpLmNvbmZpZy5zaG93RGlmZiBpbnN0ZWFkLicpO1xuICAgICAgcmV0dXJuIGNvbmZpZy5zaG93RGlmZjtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIGNvbnNvbGUud2FybignQXNzZXJ0aW9uLnNob3dEaWZmIGlzIGRlcHJlY2F0ZWQsIHVzZSBjaGFpLmNvbmZpZy5zaG93RGlmZiBpbnN0ZWFkLicpO1xuICAgICAgY29uZmlnLnNob3dEaWZmID0gdmFsdWU7XG4gICAgfVxuICB9KTtcblxuICBBc3NlcnRpb24uYWRkUHJvcGVydHkgPSBmdW5jdGlvbiAobmFtZSwgZm4pIHtcbiAgICB1dGlsLmFkZFByb3BlcnR5KHRoaXMucHJvdG90eXBlLCBuYW1lLCBmbik7XG4gIH07XG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCA9IGZ1bmN0aW9uIChuYW1lLCBmbikge1xuICAgIHV0aWwuYWRkTWV0aG9kKHRoaXMucHJvdG90eXBlLCBuYW1lLCBmbik7XG4gIH07XG5cbiAgQXNzZXJ0aW9uLmFkZENoYWluYWJsZU1ldGhvZCA9IGZ1bmN0aW9uIChuYW1lLCBmbiwgY2hhaW5pbmdCZWhhdmlvcikge1xuICAgIHV0aWwuYWRkQ2hhaW5hYmxlTWV0aG9kKHRoaXMucHJvdG90eXBlLCBuYW1lLCBmbiwgY2hhaW5pbmdCZWhhdmlvcik7XG4gIH07XG5cbiAgQXNzZXJ0aW9uLm92ZXJ3cml0ZVByb3BlcnR5ID0gZnVuY3Rpb24gKG5hbWUsIGZuKSB7XG4gICAgdXRpbC5vdmVyd3JpdGVQcm9wZXJ0eSh0aGlzLnByb3RvdHlwZSwgbmFtZSwgZm4pO1xuICB9O1xuXG4gIEFzc2VydGlvbi5vdmVyd3JpdGVNZXRob2QgPSBmdW5jdGlvbiAobmFtZSwgZm4pIHtcbiAgICB1dGlsLm92ZXJ3cml0ZU1ldGhvZCh0aGlzLnByb3RvdHlwZSwgbmFtZSwgZm4pO1xuICB9O1xuXG4gIEFzc2VydGlvbi5vdmVyd3JpdGVDaGFpbmFibGVNZXRob2QgPSBmdW5jdGlvbiAobmFtZSwgZm4sIGNoYWluaW5nQmVoYXZpb3IpIHtcbiAgICB1dGlsLm92ZXJ3cml0ZUNoYWluYWJsZU1ldGhvZCh0aGlzLnByb3RvdHlwZSwgbmFtZSwgZm4sIGNoYWluaW5nQmVoYXZpb3IpO1xuICB9O1xuXG4gIC8qIVxuICAgKiAjIyMgLmFzc2VydChleHByZXNzaW9uLCBtZXNzYWdlLCBuZWdhdGVNZXNzYWdlLCBleHBlY3RlZCwgYWN0dWFsKVxuICAgKlxuICAgKiBFeGVjdXRlcyBhbiBleHByZXNzaW9uIGFuZCBjaGVjayBleHBlY3RhdGlvbnMuIFRocm93cyBBc3NlcnRpb25FcnJvciBmb3IgcmVwb3J0aW5nIGlmIHRlc3QgZG9lc24ndCBwYXNzLlxuICAgKlxuICAgKiBAbmFtZSBhc3NlcnRcbiAgICogQHBhcmFtIHtQaGlsb3NvcGhpY2FsfSBleHByZXNzaW9uIHRvIGJlIHRlc3RlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSB0byBkaXNwbGF5IGlmIGZhaWxzXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuZWdhdGVkTWVzc2FnZSB0byBkaXNwbGF5IGlmIG5lZ2F0ZWQgZXhwcmVzc2lvbiBmYWlsc1xuICAgKiBAcGFyYW0ge01peGVkfSBleHBlY3RlZCB2YWx1ZSAocmVtZW1iZXIgdG8gY2hlY2sgZm9yIG5lZ2F0aW9uKVxuICAgKiBAcGFyYW0ge01peGVkfSBhY3R1YWwgKG9wdGlvbmFsKSB3aWxsIGRlZmF1bHQgdG8gYHRoaXMub2JqYFxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG5cbiAgQXNzZXJ0aW9uLnByb3RvdHlwZS5hc3NlcnQgPSBmdW5jdGlvbiAoZXhwciwgbXNnLCBuZWdhdGVNc2csIGV4cGVjdGVkLCBfYWN0dWFsLCBzaG93RGlmZikge1xuICAgIHZhciBvayA9IHV0aWwudGVzdCh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmICh0cnVlICE9PSBzaG93RGlmZikgc2hvd0RpZmYgPSBmYWxzZTtcbiAgICBpZiAodHJ1ZSAhPT0gY29uZmlnLnNob3dEaWZmKSBzaG93RGlmZiA9IGZhbHNlO1xuXG4gICAgaWYgKCFvaykge1xuICAgICAgdmFyIG1zZyA9IHV0aWwuZ2V0TWVzc2FnZSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICAgICwgYWN0dWFsID0gdXRpbC5nZXRBY3R1YWwodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHRocm93IG5ldyBBc3NlcnRpb25FcnJvcihtc2csIHtcbiAgICAgICAgICBhY3R1YWw6IGFjdHVhbFxuICAgICAgICAsIGV4cGVjdGVkOiBleHBlY3RlZFxuICAgICAgICAsIHNob3dEaWZmOiBzaG93RGlmZlxuICAgICAgfSwgKGNvbmZpZy5pbmNsdWRlU3RhY2spID8gdGhpcy5hc3NlcnQgOiBmbGFnKHRoaXMsICdzc2ZpJykpO1xuICAgIH1cbiAgfTtcblxuICAvKiFcbiAgICogIyMjIC5fb2JqXG4gICAqXG4gICAqIFF1aWNrIHJlZmVyZW5jZSB0byBzdG9yZWQgYGFjdHVhbGAgdmFsdWUgZm9yIHBsdWdpbiBkZXZlbG9wZXJzLlxuICAgKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFzc2VydGlvbi5wcm90b3R5cGUsICdfb2JqJyxcbiAgICB7IGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZmxhZyh0aGlzLCAnb2JqZWN0Jyk7XG4gICAgICB9XG4gICAgLCBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgZmxhZyh0aGlzLCAnb2JqZWN0JywgdmFsKTtcbiAgICAgIH1cbiAgfSk7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgLyoqXG4gICAqICMjIyBjb25maWcuaW5jbHVkZVN0YWNrXG4gICAqXG4gICAqIFVzZXIgY29uZmlndXJhYmxlIHByb3BlcnR5LCBpbmZsdWVuY2VzIHdoZXRoZXIgc3RhY2sgdHJhY2VcbiAgICogaXMgaW5jbHVkZWQgaW4gQXNzZXJ0aW9uIGVycm9yIG1lc3NhZ2UuIERlZmF1bHQgb2YgZmFsc2VcbiAgICogc3VwcHJlc3NlcyBzdGFjayB0cmFjZSBpbiB0aGUgZXJyb3IgbWVzc2FnZS5cbiAgICpcbiAgICogICAgIGNoYWkuY29uZmlnLmluY2x1ZGVTdGFjayA9IHRydWU7ICAvLyBlbmFibGUgc3RhY2sgb24gZXJyb3JcbiAgICpcbiAgICogQHBhcmFtIHtCb29sZWFufVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICAgaW5jbHVkZVN0YWNrOiBmYWxzZSxcblxuICAvKipcbiAgICogIyMjIGNvbmZpZy5zaG93RGlmZlxuICAgKlxuICAgKiBVc2VyIGNvbmZpZ3VyYWJsZSBwcm9wZXJ0eSwgaW5mbHVlbmNlcyB3aGV0aGVyIG9yIG5vdFxuICAgKiB0aGUgYHNob3dEaWZmYCBmbGFnIHNob3VsZCBiZSBpbmNsdWRlZCBpbiB0aGUgdGhyb3duXG4gICAqIEFzc2VydGlvbkVycm9ycy4gYGZhbHNlYCB3aWxsIGFsd2F5cyBiZSBgZmFsc2VgOyBgdHJ1ZWBcbiAgICogd2lsbCBiZSB0cnVlIHdoZW4gdGhlIGFzc2VydGlvbiBoYXMgcmVxdWVzdGVkIGEgZGlmZlxuICAgKiBiZSBzaG93bi5cbiAgICpcbiAgICogQHBhcmFtIHtCb29sZWFufVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBzaG93RGlmZjogdHJ1ZSxcblxuICAvKipcbiAgICogIyMjIGNvbmZpZy50cnVuY2F0ZVRocmVzaG9sZFxuICAgKlxuICAgKiBVc2VyIGNvbmZpZ3VyYWJsZSBwcm9wZXJ0eSwgc2V0cyBsZW5ndGggdGhyZXNob2xkIGZvciBhY3R1YWwgYW5kXG4gICAqIGV4cGVjdGVkIHZhbHVlcyBpbiBhc3NlcnRpb24gZXJyb3JzLiBJZiB0aGlzIHRocmVzaG9sZCBpcyBleGNlZWRlZCxcbiAgICogdGhlIHZhbHVlIGlzIHRydW5jYXRlZC5cbiAgICpcbiAgICogU2V0IGl0IHRvIHplcm8gaWYgeW91IHdhbnQgdG8gZGlzYWJsZSB0cnVuY2F0aW5nIGFsdG9nZXRoZXIuXG4gICAqXG4gICAqICAgICBjaGFpLmNvbmZpZy50cnVuY2F0ZVRocmVzaG9sZCA9IDA7ICAvLyBkaXNhYmxlIHRydW5jYXRpbmdcbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIHRydW5jYXRlVGhyZXNob2xkOiA0MFxuXG59O1xuIiwiLyohXG4gKiBjaGFpXG4gKiBodHRwOi8vY2hhaWpzLmNvbVxuICogQ29weXJpZ2h0KGMpIDIwMTEtMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNoYWksIF8pIHtcbiAgdmFyIEFzc2VydGlvbiA9IGNoYWkuQXNzZXJ0aW9uXG4gICAgLCB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdcbiAgICAsIGZsYWcgPSBfLmZsYWc7XG5cbiAgLyoqXG4gICAqICMjIyBMYW5ndWFnZSBDaGFpbnNcbiAgICpcbiAgICogVGhlIGZvbGxvd2luZyBhcmUgcHJvdmlkZWQgYXMgY2hhaW5hYmxlIGdldHRlcnMgdG9cbiAgICogaW1wcm92ZSB0aGUgcmVhZGFiaWxpdHkgb2YgeW91ciBhc3NlcnRpb25zLiBUaGV5XG4gICAqIGRvIG5vdCBwcm92aWRlIHRlc3RpbmcgY2FwYWJpbGl0aWVzIHVubGVzcyB0aGV5XG4gICAqIGhhdmUgYmVlbiBvdmVyd3JpdHRlbiBieSBhIHBsdWdpbi5cbiAgICpcbiAgICogKipDaGFpbnMqKlxuICAgKlxuICAgKiAtIHRvXG4gICAqIC0gYmVcbiAgICogLSBiZWVuXG4gICAqIC0gaXNcbiAgICogLSB0aGF0XG4gICAqIC0gYW5kXG4gICAqIC0gaGFzXG4gICAqIC0gaGF2ZVxuICAgKiAtIHdpdGhcbiAgICogLSBhdFxuICAgKiAtIG9mXG4gICAqIC0gc2FtZVxuICAgKlxuICAgKiBAbmFtZSBsYW5ndWFnZSBjaGFpbnNcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgWyAndG8nLCAnYmUnLCAnYmVlbidcbiAgLCAnaXMnLCAnYW5kJywgJ2hhcycsICdoYXZlJ1xuICAsICd3aXRoJywgJ3RoYXQnLCAnYXQnXG4gICwgJ29mJywgJ3NhbWUnIF0uZm9yRWFjaChmdW5jdGlvbiAoY2hhaW4pIHtcbiAgICBBc3NlcnRpb24uYWRkUHJvcGVydHkoY2hhaW4sIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0pO1xuICB9KTtcblxuICAvKipcbiAgICogIyMjIC5ub3RcbiAgICpcbiAgICogTmVnYXRlcyBhbnkgb2YgYXNzZXJ0aW9ucyBmb2xsb3dpbmcgaW4gdGhlIGNoYWluLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KGZvbykudG8ubm90LmVxdWFsKCdiYXInKTtcbiAgICogICAgIGV4cGVjdChnb29kRm4pLnRvLm5vdC50aHJvdyhFcnJvcik7XG4gICAqICAgICBleHBlY3QoeyBmb286ICdiYXonIH0pLnRvLmhhdmUucHJvcGVydHkoJ2ZvbycpXG4gICAqICAgICAgIC5hbmQubm90LmVxdWFsKCdiYXInKTtcbiAgICpcbiAgICogQG5hbWUgbm90XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEFzc2VydGlvbi5hZGRQcm9wZXJ0eSgnbm90JywgZnVuY3Rpb24gKCkge1xuICAgIGZsYWcodGhpcywgJ25lZ2F0ZScsIHRydWUpO1xuICB9KTtcblxuICAvKipcbiAgICogIyMjIC5kZWVwXG4gICAqXG4gICAqIFNldHMgdGhlIGBkZWVwYCBmbGFnLCBsYXRlciB1c2VkIGJ5IHRoZSBgZXF1YWxgIGFuZFxuICAgKiBgcHJvcGVydHlgIGFzc2VydGlvbnMuXG4gICAqXG4gICAqICAgICBleHBlY3QoZm9vKS50by5kZWVwLmVxdWFsKHsgYmFyOiAnYmF6JyB9KTtcbiAgICogICAgIGV4cGVjdCh7IGZvbzogeyBiYXI6IHsgYmF6OiAncXV1eCcgfSB9IH0pXG4gICAqICAgICAgIC50by5oYXZlLmRlZXAucHJvcGVydHkoJ2Zvby5iYXIuYmF6JywgJ3F1dXgnKTtcbiAgICpcbiAgICogQG5hbWUgZGVlcFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkUHJvcGVydHkoJ2RlZXAnLCBmdW5jdGlvbiAoKSB7XG4gICAgZmxhZyh0aGlzLCAnZGVlcCcsIHRydWUpO1xuICB9KTtcblxuICAvKipcbiAgICogIyMjIC5hKHR5cGUpXG4gICAqXG4gICAqIFRoZSBgYWAgYW5kIGBhbmAgYXNzZXJ0aW9ucyBhcmUgYWxpYXNlcyB0aGF0IGNhbiBiZVxuICAgKiB1c2VkIGVpdGhlciBhcyBsYW5ndWFnZSBjaGFpbnMgb3IgdG8gYXNzZXJ0IGEgdmFsdWUnc1xuICAgKiB0eXBlLlxuICAgKlxuICAgKiAgICAgLy8gdHlwZW9mXG4gICAqICAgICBleHBlY3QoJ3Rlc3QnKS50by5iZS5hKCdzdHJpbmcnKTtcbiAgICogICAgIGV4cGVjdCh7IGZvbzogJ2JhcicgfSkudG8uYmUuYW4oJ29iamVjdCcpO1xuICAgKiAgICAgZXhwZWN0KG51bGwpLnRvLmJlLmEoJ251bGwnKTtcbiAgICogICAgIGV4cGVjdCh1bmRlZmluZWQpLnRvLmJlLmFuKCd1bmRlZmluZWQnKTtcbiAgICpcbiAgICogICAgIC8vIGxhbmd1YWdlIGNoYWluXG4gICAqICAgICBleHBlY3QoZm9vKS50by5iZS5hbi5pbnN0YW5jZW9mKEZvbyk7XG4gICAqXG4gICAqIEBuYW1lIGFcbiAgICogQGFsaWFzIGFuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gYW4gKHR5cGUsIG1zZykge1xuICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuICAgIHR5cGUgPSB0eXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgICAsIGFydGljbGUgPSB+WyAnYScsICdlJywgJ2knLCAnbycsICd1JyBdLmluZGV4T2YodHlwZS5jaGFyQXQoMCkpID8gJ2FuICcgOiAnYSAnO1xuXG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIHR5cGUgPT09IF8udHlwZShvYmopXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlICcgKyBhcnRpY2xlICsgdHlwZVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSBub3QgdG8gYmUgJyArIGFydGljbGUgKyB0eXBlXG4gICAgKTtcbiAgfVxuXG4gIEFzc2VydGlvbi5hZGRDaGFpbmFibGVNZXRob2QoJ2FuJywgYW4pO1xuICBBc3NlcnRpb24uYWRkQ2hhaW5hYmxlTWV0aG9kKCdhJywgYW4pO1xuXG4gIC8qKlxuICAgKiAjIyMgLmluY2x1ZGUodmFsdWUpXG4gICAqXG4gICAqIFRoZSBgaW5jbHVkZWAgYW5kIGBjb250YWluYCBhc3NlcnRpb25zIGNhbiBiZSB1c2VkIGFzIGVpdGhlciBwcm9wZXJ0eVxuICAgKiBiYXNlZCBsYW5ndWFnZSBjaGFpbnMgb3IgYXMgbWV0aG9kcyB0byBhc3NlcnQgdGhlIGluY2x1c2lvbiBvZiBhbiBvYmplY3RcbiAgICogaW4gYW4gYXJyYXkgb3IgYSBzdWJzdHJpbmcgaW4gYSBzdHJpbmcuIFdoZW4gdXNlZCBhcyBsYW5ndWFnZSBjaGFpbnMsXG4gICAqIHRoZXkgdG9nZ2xlIHRoZSBgY29udGFpbmAgZmxhZyBmb3IgdGhlIGBrZXlzYCBhc3NlcnRpb24uXG4gICAqXG4gICAqICAgICBleHBlY3QoWzEsMiwzXSkudG8uaW5jbHVkZSgyKTtcbiAgICogICAgIGV4cGVjdCgnZm9vYmFyJykudG8uY29udGFpbignZm9vJyk7XG4gICAqICAgICBleHBlY3QoeyBmb286ICdiYXInLCBoZWxsbzogJ3VuaXZlcnNlJyB9KS50by5pbmNsdWRlLmtleXMoJ2ZvbycpO1xuICAgKlxuICAgKiBAbmFtZSBpbmNsdWRlXG4gICAqIEBhbGlhcyBjb250YWluXG4gICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ3xOdW1iZXJ9IG9ialxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGluY2x1ZGVDaGFpbmluZ0JlaGF2aW9yICgpIHtcbiAgICBmbGFnKHRoaXMsICdjb250YWlucycsIHRydWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5jbHVkZSAodmFsLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0Jyk7XG4gICAgdmFyIGV4cGVjdGVkID0gZmFsc2U7XG4gICAgaWYgKF8udHlwZShvYmopID09PSAnYXJyYXknICYmIF8udHlwZSh2YWwpID09PSAnb2JqZWN0Jykge1xuICAgICAgZm9yICh2YXIgaSBpbiBvYmopIHtcbiAgICAgICAgaWYgKF8uZXFsKG9ialtpXSwgdmFsKSkge1xuICAgICAgICAgIGV4cGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoXy50eXBlKHZhbCkgPT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAoIWZsYWcodGhpcywgJ25lZ2F0ZScpKSB7XG4gICAgICAgIGZvciAodmFyIGsgaW4gdmFsKSBuZXcgQXNzZXJ0aW9uKG9iaikucHJvcGVydHkoaywgdmFsW2tdKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHN1YnNldCA9IHt9XG4gICAgICBmb3IgKHZhciBrIGluIHZhbCkgc3Vic2V0W2tdID0gb2JqW2tdXG4gICAgICBleHBlY3RlZCA9IF8uZXFsKHN1YnNldCwgdmFsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhwZWN0ZWQgPSBvYmogJiYgfm9iai5pbmRleE9mKHZhbClcbiAgICB9XG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIGV4cGVjdGVkXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGluY2x1ZGUgJyArIF8uaW5zcGVjdCh2YWwpXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBpbmNsdWRlICcgKyBfLmluc3BlY3QodmFsKSk7XG4gIH1cblxuICBBc3NlcnRpb24uYWRkQ2hhaW5hYmxlTWV0aG9kKCdpbmNsdWRlJywgaW5jbHVkZSwgaW5jbHVkZUNoYWluaW5nQmVoYXZpb3IpO1xuICBBc3NlcnRpb24uYWRkQ2hhaW5hYmxlTWV0aG9kKCdjb250YWluJywgaW5jbHVkZSwgaW5jbHVkZUNoYWluaW5nQmVoYXZpb3IpO1xuXG4gIC8qKlxuICAgKiAjIyMgLm9rXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIHRydXRoeS5cbiAgICpcbiAgICogICAgIGV4cGVjdCgnZXZlcnRoaW5nJykudG8uYmUub2s7XG4gICAqICAgICBleHBlY3QoMSkudG8uYmUub2s7XG4gICAqICAgICBleHBlY3QoZmFsc2UpLnRvLm5vdC5iZS5vaztcbiAgICogICAgIGV4cGVjdCh1bmRlZmluZWQpLnRvLm5vdC5iZS5vaztcbiAgICogICAgIGV4cGVjdChudWxsKS50by5ub3QuYmUub2s7XG4gICAqXG4gICAqIEBuYW1lIG9rXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEFzc2VydGlvbi5hZGRQcm9wZXJ0eSgnb2snLCBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIHRydXRoeSdcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgZmFsc3knKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqICMjIyAudHJ1ZVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyBgdHJ1ZWAuXG4gICAqXG4gICAqICAgICBleHBlY3QodHJ1ZSkudG8uYmUudHJ1ZTtcbiAgICogICAgIGV4cGVjdCgxKS50by5ub3QuYmUudHJ1ZTtcbiAgICpcbiAgICogQG5hbWUgdHJ1ZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkUHJvcGVydHkoJ3RydWUnLCBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIHRydWUgPT09IGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIHRydWUnXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIGZhbHNlJ1xuICAgICAgLCB0aGlzLm5lZ2F0ZSA/IGZhbHNlIDogdHJ1ZVxuICAgICk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiAjIyMgLmZhbHNlXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIGBmYWxzZWAuXG4gICAqXG4gICAqICAgICBleHBlY3QoZmFsc2UpLnRvLmJlLmZhbHNlO1xuICAgKiAgICAgZXhwZWN0KDApLnRvLm5vdC5iZS5mYWxzZTtcbiAgICpcbiAgICogQG5hbWUgZmFsc2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQXNzZXJ0aW9uLmFkZFByb3BlcnR5KCdmYWxzZScsIGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgZmFsc2UgPT09IGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIGZhbHNlJ1xuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSB0cnVlJ1xuICAgICAgLCB0aGlzLm5lZ2F0ZSA/IHRydWUgOiBmYWxzZVxuICAgICk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiAjIyMgLm51bGxcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaXMgYG51bGxgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KG51bGwpLnRvLmJlLm51bGw7XG4gICAqICAgICBleHBlY3QodW5kZWZpbmVkKS5ub3QudG8uYmUubnVsbDtcbiAgICpcbiAgICogQG5hbWUgbnVsbFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkUHJvcGVydHkoJ251bGwnLCBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIG51bGwgPT09IGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIG51bGwnXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IG5vdCB0byBiZSBudWxsJ1xuICAgICk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiAjIyMgLnVuZGVmaW5lZFxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyBgdW5kZWZpbmVkYC5cbiAgICpcbiAgICogICAgIGV4cGVjdCh1bmRlZmluZWQpLnRvLmJlLnVuZGVmaW5lZDtcbiAgICogICAgIGV4cGVjdChudWxsKS50by5ub3QuYmUudW5kZWZpbmVkO1xuICAgKlxuICAgKiBAbmFtZSB1bmRlZmluZWRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQXNzZXJ0aW9uLmFkZFByb3BlcnR5KCd1bmRlZmluZWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIHVuZGVmaW5lZCA9PT0gZmxhZyh0aGlzLCAnb2JqZWN0JylcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgdW5kZWZpbmVkJ1xuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSBub3QgdG8gYmUgdW5kZWZpbmVkJ1xuICAgICk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiAjIyMgLmV4aXN0XG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIG5laXRoZXIgYG51bGxgIG5vciBgdW5kZWZpbmVkYC5cbiAgICpcbiAgICogICAgIHZhciBmb28gPSAnaGknXG4gICAqICAgICAgICwgYmFyID0gbnVsbFxuICAgKiAgICAgICAsIGJhejtcbiAgICpcbiAgICogICAgIGV4cGVjdChmb28pLnRvLmV4aXN0O1xuICAgKiAgICAgZXhwZWN0KGJhcikudG8ubm90LmV4aXN0O1xuICAgKiAgICAgZXhwZWN0KGJheikudG8ubm90LmV4aXN0O1xuICAgKlxuICAgKiBAbmFtZSBleGlzdFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkUHJvcGVydHkoJ2V4aXN0JywgZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICBudWxsICE9IGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGV4aXN0J1xuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgZXhpc3QnXG4gICAgKTtcbiAgfSk7XG5cblxuICAvKipcbiAgICogIyMjIC5lbXB0eVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCdzIGxlbmd0aCBpcyBgMGAuIEZvciBhcnJheXMsIGl0IGNoZWNrc1xuICAgKiB0aGUgYGxlbmd0aGAgcHJvcGVydHkuIEZvciBvYmplY3RzLCBpdCBnZXRzIHRoZSBjb3VudCBvZlxuICAgKiBlbnVtZXJhYmxlIGtleXMuXG4gICAqXG4gICAqICAgICBleHBlY3QoW10pLnRvLmJlLmVtcHR5O1xuICAgKiAgICAgZXhwZWN0KCcnKS50by5iZS5lbXB0eTtcbiAgICogICAgIGV4cGVjdCh7fSkudG8uYmUuZW1wdHk7XG4gICAqXG4gICAqIEBuYW1lIGVtcHR5XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEFzc2VydGlvbi5hZGRQcm9wZXJ0eSgnZW1wdHknLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgICAsIGV4cGVjdGVkID0gb2JqO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSB8fCAnc3RyaW5nJyA9PT0gdHlwZW9mIG9iamVjdCkge1xuICAgICAgZXhwZWN0ZWQgPSBvYmoubGVuZ3RoO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGV4cGVjdGVkID0gT2JqZWN0LmtleXMob2JqKS5sZW5ndGg7XG4gICAgfVxuXG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICFleHBlY3RlZFxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSBlbXB0eSdcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gbm90IHRvIGJlIGVtcHR5J1xuICAgICk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiAjIyMgLmFyZ3VtZW50c1xuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyBhbiBhcmd1bWVudHMgb2JqZWN0LlxuICAgKlxuICAgKiAgICAgZnVuY3Rpb24gdGVzdCAoKSB7XG4gICAqICAgICAgIGV4cGVjdChhcmd1bWVudHMpLnRvLmJlLmFyZ3VtZW50cztcbiAgICogICAgIH1cbiAgICpcbiAgICogQG5hbWUgYXJndW1lbnRzXG4gICAqIEBhbGlhcyBBcmd1bWVudHNcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gY2hlY2tBcmd1bWVudHMgKCkge1xuICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKVxuICAgICAgLCB0eXBlID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaik7XG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICdbb2JqZWN0IEFyZ3VtZW50c10nID09PSB0eXBlXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIGFyZ3VtZW50cyBidXQgZ290ICcgKyB0eXBlXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBiZSBhcmd1bWVudHMnXG4gICAgKTtcbiAgfVxuXG4gIEFzc2VydGlvbi5hZGRQcm9wZXJ0eSgnYXJndW1lbnRzJywgY2hlY2tBcmd1bWVudHMpO1xuICBBc3NlcnRpb24uYWRkUHJvcGVydHkoJ0FyZ3VtZW50cycsIGNoZWNrQXJndW1lbnRzKTtcblxuICAvKipcbiAgICogIyMjIC5lcXVhbCh2YWx1ZSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaXMgc3RyaWN0bHkgZXF1YWwgKGA9PT1gKSB0byBgdmFsdWVgLlxuICAgKiBBbHRlcm5hdGVseSwgaWYgdGhlIGBkZWVwYCBmbGFnIGlzIHNldCwgYXNzZXJ0cyB0aGF0XG4gICAqIHRoZSB0YXJnZXQgaXMgZGVlcGx5IGVxdWFsIHRvIGB2YWx1ZWAuXG4gICAqXG4gICAqICAgICBleHBlY3QoJ2hlbGxvJykudG8uZXF1YWwoJ2hlbGxvJyk7XG4gICAqICAgICBleHBlY3QoNDIpLnRvLmVxdWFsKDQyKTtcbiAgICogICAgIGV4cGVjdCgxKS50by5ub3QuZXF1YWwodHJ1ZSk7XG4gICAqICAgICBleHBlY3QoeyBmb286ICdiYXInIH0pLnRvLm5vdC5lcXVhbCh7IGZvbzogJ2JhcicgfSk7XG4gICAqICAgICBleHBlY3QoeyBmb286ICdiYXInIH0pLnRvLmRlZXAuZXF1YWwoeyBmb286ICdiYXInIH0pO1xuICAgKlxuICAgKiBAbmFtZSBlcXVhbFxuICAgKiBAYWxpYXMgZXF1YWxzXG4gICAqIEBhbGlhcyBlcVxuICAgKiBAYWxpYXMgZGVlcC5lcXVhbFxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGFzc2VydEVxdWFsICh2YWwsIG1zZykge1xuICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKTtcbiAgICBpZiAoZmxhZyh0aGlzLCAnZGVlcCcpKSB7XG4gICAgICByZXR1cm4gdGhpcy5lcWwodmFsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICAgdmFsID09PSBvYmpcbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBlcXVhbCAje2V4cH0nXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGVxdWFsICN7ZXhwfSdcbiAgICAgICAgLCB2YWxcbiAgICAgICAgLCB0aGlzLl9vYmpcbiAgICAgICAgLCB0cnVlXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2VxdWFsJywgYXNzZXJ0RXF1YWwpO1xuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdlcXVhbHMnLCBhc3NlcnRFcXVhbCk7XG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2VxJywgYXNzZXJ0RXF1YWwpO1xuXG4gIC8qKlxuICAgKiAjIyMgLmVxbCh2YWx1ZSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaXMgZGVlcGx5IGVxdWFsIHRvIGB2YWx1ZWAuXG4gICAqXG4gICAqICAgICBleHBlY3QoeyBmb286ICdiYXInIH0pLnRvLmVxbCh7IGZvbzogJ2JhcicgfSk7XG4gICAqICAgICBleHBlY3QoWyAxLCAyLCAzIF0pLnRvLmVxbChbIDEsIDIsIDMgXSk7XG4gICAqXG4gICAqIEBuYW1lIGVxbFxuICAgKiBAYWxpYXMgZXFsc1xuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGFzc2VydEVxbChvYmosIG1zZykge1xuICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICBfLmVxbChvYmosIGZsYWcodGhpcywgJ29iamVjdCcpKVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBkZWVwbHkgZXF1YWwgI3tleHB9J1xuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgZGVlcGx5IGVxdWFsICN7ZXhwfSdcbiAgICAgICwgb2JqXG4gICAgICAsIHRoaXMuX29ialxuICAgICAgLCB0cnVlXG4gICAgKTtcbiAgfVxuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2VxbCcsIGFzc2VydEVxbCk7XG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2VxbHMnLCBhc3NlcnRFcWwpO1xuXG4gIC8qKlxuICAgKiAjIyMgLmFib3ZlKHZhbHVlKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyBncmVhdGVyIHRoYW4gYHZhbHVlYC5cbiAgICpcbiAgICogICAgIGV4cGVjdCgxMCkudG8uYmUuYWJvdmUoNSk7XG4gICAqXG4gICAqIENhbiBhbHNvIGJlIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCBgbGVuZ3RoYCB0b1xuICAgKiBhc3NlcnQgYSBtaW5pbXVtIGxlbmd0aC4gVGhlIGJlbmVmaXQgYmVpbmcgYVxuICAgKiBtb3JlIGluZm9ybWF0aXZlIGVycm9yIG1lc3NhZ2UgdGhhbiBpZiB0aGUgbGVuZ3RoXG4gICAqIHdhcyBzdXBwbGllZCBkaXJlY3RseS5cbiAgICpcbiAgICogICAgIGV4cGVjdCgnZm9vJykudG8uaGF2ZS5sZW5ndGguYWJvdmUoMik7XG4gICAqICAgICBleHBlY3QoWyAxLCAyLCAzIF0pLnRvLmhhdmUubGVuZ3RoLmFib3ZlKDIpO1xuICAgKlxuICAgKiBAbmFtZSBhYm92ZVxuICAgKiBAYWxpYXMgZ3RcbiAgICogQGFsaWFzIGdyZWF0ZXJUaGFuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGFzc2VydEFib3ZlIChuLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0Jyk7XG4gICAgaWYgKGZsYWcodGhpcywgJ2RvTGVuZ3RoJykpIHtcbiAgICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2cpLnRvLmhhdmUucHJvcGVydHkoJ2xlbmd0aCcpO1xuICAgICAgdmFyIGxlbiA9IG9iai5sZW5ndGg7XG4gICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgICBsZW4gPiBuXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gaGF2ZSBhIGxlbmd0aCBhYm92ZSAje2V4cH0gYnV0IGdvdCAje2FjdH0nXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGhhdmUgYSBsZW5ndGggYWJvdmUgI3tleHB9J1xuICAgICAgICAsIG5cbiAgICAgICAgLCBsZW5cbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgIG9iaiA+IG5cbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSBhYm92ZSAnICsgblxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIGF0IG1vc3QgJyArIG5cbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnYWJvdmUnLCBhc3NlcnRBYm92ZSk7XG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2d0JywgYXNzZXJ0QWJvdmUpO1xuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdncmVhdGVyVGhhbicsIGFzc2VydEFib3ZlKTtcblxuICAvKipcbiAgICogIyMjIC5sZWFzdCh2YWx1ZSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIGB2YWx1ZWAuXG4gICAqXG4gICAqICAgICBleHBlY3QoMTApLnRvLmJlLmF0LmxlYXN0KDEwKTtcbiAgICpcbiAgICogQ2FuIGFsc28gYmUgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIGBsZW5ndGhgIHRvXG4gICAqIGFzc2VydCBhIG1pbmltdW0gbGVuZ3RoLiBUaGUgYmVuZWZpdCBiZWluZyBhXG4gICAqIG1vcmUgaW5mb3JtYXRpdmUgZXJyb3IgbWVzc2FnZSB0aGFuIGlmIHRoZSBsZW5ndGhcbiAgICogd2FzIHN1cHBsaWVkIGRpcmVjdGx5LlxuICAgKlxuICAgKiAgICAgZXhwZWN0KCdmb28nKS50by5oYXZlLmxlbmd0aC5vZi5hdC5sZWFzdCgyKTtcbiAgICogICAgIGV4cGVjdChbIDEsIDIsIDMgXSkudG8uaGF2ZS5sZW5ndGgub2YuYXQubGVhc3QoMyk7XG4gICAqXG4gICAqIEBuYW1lIGxlYXN0XG4gICAqIEBhbGlhcyBndGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gYXNzZXJ0TGVhc3QgKG4sIG1zZykge1xuICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKTtcbiAgICBpZiAoZmxhZyh0aGlzLCAnZG9MZW5ndGgnKSkge1xuICAgICAgbmV3IEFzc2VydGlvbihvYmosIG1zZykudG8uaGF2ZS5wcm9wZXJ0eSgnbGVuZ3RoJyk7XG4gICAgICB2YXIgbGVuID0gb2JqLmxlbmd0aDtcbiAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgIGxlbiA+PSBuXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gaGF2ZSBhIGxlbmd0aCBhdCBsZWFzdCAje2V4cH0gYnV0IGdvdCAje2FjdH0nXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gaGF2ZSBhIGxlbmd0aCBiZWxvdyAje2V4cH0nXG4gICAgICAgICwgblxuICAgICAgICAsIGxlblxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICAgb2JqID49IG5cbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSBhdCBsZWFzdCAnICsgblxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIGJlbG93ICcgKyBuXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2xlYXN0JywgYXNzZXJ0TGVhc3QpO1xuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdndGUnLCBhc3NlcnRMZWFzdCk7XG5cbiAgLyoqXG4gICAqICMjIyAuYmVsb3codmFsdWUpXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIGxlc3MgdGhhbiBgdmFsdWVgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KDUpLnRvLmJlLmJlbG93KDEwKTtcbiAgICpcbiAgICogQ2FuIGFsc28gYmUgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIGBsZW5ndGhgIHRvXG4gICAqIGFzc2VydCBhIG1heGltdW0gbGVuZ3RoLiBUaGUgYmVuZWZpdCBiZWluZyBhXG4gICAqIG1vcmUgaW5mb3JtYXRpdmUgZXJyb3IgbWVzc2FnZSB0aGFuIGlmIHRoZSBsZW5ndGhcbiAgICogd2FzIHN1cHBsaWVkIGRpcmVjdGx5LlxuICAgKlxuICAgKiAgICAgZXhwZWN0KCdmb28nKS50by5oYXZlLmxlbmd0aC5iZWxvdyg0KTtcbiAgICogICAgIGV4cGVjdChbIDEsIDIsIDMgXSkudG8uaGF2ZS5sZW5ndGguYmVsb3coNCk7XG4gICAqXG4gICAqIEBuYW1lIGJlbG93XG4gICAqIEBhbGlhcyBsdFxuICAgKiBAYWxpYXMgbGVzc1RoYW5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gYXNzZXJ0QmVsb3cgKG4sIG1zZykge1xuICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKTtcbiAgICBpZiAoZmxhZyh0aGlzLCAnZG9MZW5ndGgnKSkge1xuICAgICAgbmV3IEFzc2VydGlvbihvYmosIG1zZykudG8uaGF2ZS5wcm9wZXJ0eSgnbGVuZ3RoJyk7XG4gICAgICB2YXIgbGVuID0gb2JqLmxlbmd0aDtcbiAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgIGxlbiA8IG5cbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBoYXZlIGEgbGVuZ3RoIGJlbG93ICN7ZXhwfSBidXQgZ290ICN7YWN0fSdcbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgaGF2ZSBhIGxlbmd0aCBiZWxvdyAje2V4cH0nXG4gICAgICAgICwgblxuICAgICAgICAsIGxlblxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICAgb2JqIDwgblxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIGJlbG93ICcgKyBuXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgYXQgbGVhc3QgJyArIG5cbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnYmVsb3cnLCBhc3NlcnRCZWxvdyk7XG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2x0JywgYXNzZXJ0QmVsb3cpO1xuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdsZXNzVGhhbicsIGFzc2VydEJlbG93KTtcblxuICAvKipcbiAgICogIyMjIC5tb3N0KHZhbHVlKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYHZhbHVlYC5cbiAgICpcbiAgICogICAgIGV4cGVjdCg1KS50by5iZS5hdC5tb3N0KDUpO1xuICAgKlxuICAgKiBDYW4gYWxzbyBiZSB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggYGxlbmd0aGAgdG9cbiAgICogYXNzZXJ0IGEgbWF4aW11bSBsZW5ndGguIFRoZSBiZW5lZml0IGJlaW5nIGFcbiAgICogbW9yZSBpbmZvcm1hdGl2ZSBlcnJvciBtZXNzYWdlIHRoYW4gaWYgdGhlIGxlbmd0aFxuICAgKiB3YXMgc3VwcGxpZWQgZGlyZWN0bHkuXG4gICAqXG4gICAqICAgICBleHBlY3QoJ2ZvbycpLnRvLmhhdmUubGVuZ3RoLm9mLmF0Lm1vc3QoNCk7XG4gICAqICAgICBleHBlY3QoWyAxLCAyLCAzIF0pLnRvLmhhdmUubGVuZ3RoLm9mLmF0Lm1vc3QoMyk7XG4gICAqXG4gICAqIEBuYW1lIG1vc3RcbiAgICogQGFsaWFzIGx0ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBmdW5jdGlvbiBhc3NlcnRNb3N0IChuLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0Jyk7XG4gICAgaWYgKGZsYWcodGhpcywgJ2RvTGVuZ3RoJykpIHtcbiAgICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2cpLnRvLmhhdmUucHJvcGVydHkoJ2xlbmd0aCcpO1xuICAgICAgdmFyIGxlbiA9IG9iai5sZW5ndGg7XG4gICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgICBsZW4gPD0gblxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGhhdmUgYSBsZW5ndGggYXQgbW9zdCAje2V4cH0gYnV0IGdvdCAje2FjdH0nXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gaGF2ZSBhIGxlbmd0aCBhYm92ZSAje2V4cH0nXG4gICAgICAgICwgblxuICAgICAgICAsIGxlblxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICAgb2JqIDw9IG5cbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSBhdCBtb3N0ICcgKyBuXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgYWJvdmUgJyArIG5cbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnbW9zdCcsIGFzc2VydE1vc3QpO1xuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdsdGUnLCBhc3NlcnRNb3N0KTtcblxuICAvKipcbiAgICogIyMjIC53aXRoaW4oc3RhcnQsIGZpbmlzaClcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaXMgd2l0aGluIGEgcmFuZ2UuXG4gICAqXG4gICAqICAgICBleHBlY3QoNykudG8uYmUud2l0aGluKDUsMTApO1xuICAgKlxuICAgKiBDYW4gYWxzbyBiZSB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggYGxlbmd0aGAgdG9cbiAgICogYXNzZXJ0IGEgbGVuZ3RoIHJhbmdlLiBUaGUgYmVuZWZpdCBiZWluZyBhXG4gICAqIG1vcmUgaW5mb3JtYXRpdmUgZXJyb3IgbWVzc2FnZSB0aGFuIGlmIHRoZSBsZW5ndGhcbiAgICogd2FzIHN1cHBsaWVkIGRpcmVjdGx5LlxuICAgKlxuICAgKiAgICAgZXhwZWN0KCdmb28nKS50by5oYXZlLmxlbmd0aC53aXRoaW4oMiw0KTtcbiAgICogICAgIGV4cGVjdChbIDEsIDIsIDMgXSkudG8uaGF2ZS5sZW5ndGgud2l0aGluKDIsNCk7XG4gICAqXG4gICAqIEBuYW1lIHdpdGhpblxuICAgKiBAcGFyYW0ge051bWJlcn0gc3RhcnQgbG93ZXJib3VuZCBpbmNsdXNpdmVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGZpbmlzaCB1cHBlcmJvdW5kIGluY2x1c2l2ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ3dpdGhpbicsIGZ1bmN0aW9uIChzdGFydCwgZmluaXNoLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0JylcbiAgICAgICwgcmFuZ2UgPSBzdGFydCArICcuLicgKyBmaW5pc2g7XG4gICAgaWYgKGZsYWcodGhpcywgJ2RvTGVuZ3RoJykpIHtcbiAgICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2cpLnRvLmhhdmUucHJvcGVydHkoJ2xlbmd0aCcpO1xuICAgICAgdmFyIGxlbiA9IG9iai5sZW5ndGg7XG4gICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgICBsZW4gPj0gc3RhcnQgJiYgbGVuIDw9IGZpbmlzaFxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGhhdmUgYSBsZW5ndGggd2l0aGluICcgKyByYW5nZVxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBoYXZlIGEgbGVuZ3RoIHdpdGhpbiAnICsgcmFuZ2VcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgIG9iaiA+PSBzdGFydCAmJiBvYmogPD0gZmluaXNoXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgd2l0aGluICcgKyByYW5nZVxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBiZSB3aXRoaW4gJyArIHJhbmdlXG4gICAgICApO1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqICMjIyAuaW5zdGFuY2VvZihjb25zdHJ1Y3RvcilcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaXMgYW4gaW5zdGFuY2Ugb2YgYGNvbnN0cnVjdG9yYC5cbiAgICpcbiAgICogICAgIHZhciBUZWEgPSBmdW5jdGlvbiAobmFtZSkgeyB0aGlzLm5hbWUgPSBuYW1lOyB9XG4gICAqICAgICAgICwgQ2hhaSA9IG5ldyBUZWEoJ2NoYWknKTtcbiAgICpcbiAgICogICAgIGV4cGVjdChDaGFpKS50by5iZS5hbi5pbnN0YW5jZW9mKFRlYSk7XG4gICAqICAgICBleHBlY3QoWyAxLCAyLCAzIF0pLnRvLmJlLmluc3RhbmNlb2YoQXJyYXkpO1xuICAgKlxuICAgKiBAbmFtZSBpbnN0YW5jZW9mXG4gICAqIEBwYXJhbSB7Q29uc3RydWN0b3J9IGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQGFsaWFzIGluc3RhbmNlT2ZcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gYXNzZXJ0SW5zdGFuY2VPZiAoY29uc3RydWN0b3IsIG1zZykge1xuICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuICAgIHZhciBuYW1lID0gXy5nZXROYW1lKGNvbnN0cnVjdG9yKTtcbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgZmxhZyh0aGlzLCAnb2JqZWN0JykgaW5zdGFuY2VvZiBjb25zdHJ1Y3RvclxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSBhbiBpbnN0YW5jZSBvZiAnICsgbmFtZVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgYmUgYW4gaW5zdGFuY2Ugb2YgJyArIG5hbWVcbiAgICApO1xuICB9O1xuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2luc3RhbmNlb2YnLCBhc3NlcnRJbnN0YW5jZU9mKTtcbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnaW5zdGFuY2VPZicsIGFzc2VydEluc3RhbmNlT2YpO1xuXG4gIC8qKlxuICAgKiAjIyMgLnByb3BlcnR5KG5hbWUsIFt2YWx1ZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGhhcyBhIHByb3BlcnR5IGBuYW1lYCwgb3B0aW9uYWxseSBhc3NlcnRpbmcgdGhhdFxuICAgKiB0aGUgdmFsdWUgb2YgdGhhdCBwcm9wZXJ0eSBpcyBzdHJpY3RseSBlcXVhbCB0byAgYHZhbHVlYC5cbiAgICogSWYgdGhlIGBkZWVwYCBmbGFnIGlzIHNldCwgeW91IGNhbiB1c2UgZG90LSBhbmQgYnJhY2tldC1ub3RhdGlvbiBmb3IgZGVlcFxuICAgKiByZWZlcmVuY2VzIGludG8gb2JqZWN0cyBhbmQgYXJyYXlzLlxuICAgKlxuICAgKiAgICAgLy8gc2ltcGxlIHJlZmVyZW5jaW5nXG4gICAqICAgICB2YXIgb2JqID0geyBmb286ICdiYXInIH07XG4gICAqICAgICBleHBlY3Qob2JqKS50by5oYXZlLnByb3BlcnR5KCdmb28nKTtcbiAgICogICAgIGV4cGVjdChvYmopLnRvLmhhdmUucHJvcGVydHkoJ2ZvbycsICdiYXInKTtcbiAgICpcbiAgICogICAgIC8vIGRlZXAgcmVmZXJlbmNpbmdcbiAgICogICAgIHZhciBkZWVwT2JqID0ge1xuICAgKiAgICAgICAgIGdyZWVuOiB7IHRlYTogJ21hdGNoYScgfVxuICAgKiAgICAgICAsIHRlYXM6IFsgJ2NoYWknLCAnbWF0Y2hhJywgeyB0ZWE6ICdrb25hY2hhJyB9IF1cbiAgICogICAgIH07XG5cbiAgICogICAgIGV4cGVjdChkZWVwT2JqKS50by5oYXZlLmRlZXAucHJvcGVydHkoJ2dyZWVuLnRlYScsICdtYXRjaGEnKTtcbiAgICogICAgIGV4cGVjdChkZWVwT2JqKS50by5oYXZlLmRlZXAucHJvcGVydHkoJ3RlYXNbMV0nLCAnbWF0Y2hhJyk7XG4gICAqICAgICBleHBlY3QoZGVlcE9iaikudG8uaGF2ZS5kZWVwLnByb3BlcnR5KCd0ZWFzWzJdLnRlYScsICdrb25hY2hhJyk7XG4gICAqXG4gICAqIFlvdSBjYW4gYWxzbyB1c2UgYW4gYXJyYXkgYXMgdGhlIHN0YXJ0aW5nIHBvaW50IG9mIGEgYGRlZXAucHJvcGVydHlgXG4gICAqIGFzc2VydGlvbiwgb3IgdHJhdmVyc2UgbmVzdGVkIGFycmF5cy5cbiAgICpcbiAgICogICAgIHZhciBhcnIgPSBbXG4gICAqICAgICAgICAgWyAnY2hhaScsICdtYXRjaGEnLCAna29uYWNoYScgXVxuICAgKiAgICAgICAsIFsgeyB0ZWE6ICdjaGFpJyB9XG4gICAqICAgICAgICAgLCB7IHRlYTogJ21hdGNoYScgfVxuICAgKiAgICAgICAgICwgeyB0ZWE6ICdrb25hY2hhJyB9IF1cbiAgICogICAgIF07XG4gICAqXG4gICAqICAgICBleHBlY3QoYXJyKS50by5oYXZlLmRlZXAucHJvcGVydHkoJ1swXVsxXScsICdtYXRjaGEnKTtcbiAgICogICAgIGV4cGVjdChhcnIpLnRvLmhhdmUuZGVlcC5wcm9wZXJ0eSgnWzFdWzJdLnRlYScsICdrb25hY2hhJyk7XG4gICAqXG4gICAqIEZ1cnRoZXJtb3JlLCBgcHJvcGVydHlgIGNoYW5nZXMgdGhlIHN1YmplY3Qgb2YgdGhlIGFzc2VydGlvblxuICAgKiB0byBiZSB0aGUgdmFsdWUgb2YgdGhhdCBwcm9wZXJ0eSBmcm9tIHRoZSBvcmlnaW5hbCBvYmplY3QuIFRoaXNcbiAgICogcGVybWl0cyBmb3IgZnVydGhlciBjaGFpbmFibGUgYXNzZXJ0aW9ucyBvbiB0aGF0IHByb3BlcnR5LlxuICAgKlxuICAgKiAgICAgZXhwZWN0KG9iaikudG8uaGF2ZS5wcm9wZXJ0eSgnZm9vJylcbiAgICogICAgICAgLnRoYXQuaXMuYSgnc3RyaW5nJyk7XG4gICAqICAgICBleHBlY3QoZGVlcE9iaikudG8uaGF2ZS5wcm9wZXJ0eSgnZ3JlZW4nKVxuICAgKiAgICAgICAudGhhdC5pcy5hbignb2JqZWN0JylcbiAgICogICAgICAgLnRoYXQuZGVlcC5lcXVhbHMoeyB0ZWE6ICdtYXRjaGEnIH0pO1xuICAgKiAgICAgZXhwZWN0KGRlZXBPYmopLnRvLmhhdmUucHJvcGVydHkoJ3RlYXMnKVxuICAgKiAgICAgICAudGhhdC5pcy5hbignYXJyYXknKVxuICAgKiAgICAgICAud2l0aC5kZWVwLnByb3BlcnR5KCdbMl0nKVxuICAgKiAgICAgICAgIC50aGF0LmRlZXAuZXF1YWxzKHsgdGVhOiAna29uYWNoYScgfSk7XG4gICAqXG4gICAqIEBuYW1lIHByb3BlcnR5XG4gICAqIEBhbGlhcyBkZWVwLnByb3BlcnR5XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlIChvcHRpb25hbClcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAcmV0dXJucyB2YWx1ZSBvZiBwcm9wZXJ0eSBmb3IgY2hhaW5pbmdcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgncHJvcGVydHknLCBmdW5jdGlvbiAobmFtZSwgdmFsLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcblxuICAgIHZhciBkZXNjcmlwdG9yID0gZmxhZyh0aGlzLCAnZGVlcCcpID8gJ2RlZXAgcHJvcGVydHkgJyA6ICdwcm9wZXJ0eSAnXG4gICAgICAsIG5lZ2F0ZSA9IGZsYWcodGhpcywgJ25lZ2F0ZScpXG4gICAgICAsIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgICAsIHZhbHVlID0gZmxhZyh0aGlzLCAnZGVlcCcpXG4gICAgICAgID8gXy5nZXRQYXRoVmFsdWUobmFtZSwgb2JqKVxuICAgICAgICA6IG9ialtuYW1lXTtcblxuICAgIGlmIChuZWdhdGUgJiYgdW5kZWZpbmVkICE9PSB2YWwpIHtcbiAgICAgIGlmICh1bmRlZmluZWQgPT09IHZhbHVlKSB7XG4gICAgICAgIG1zZyA9IChtc2cgIT0gbnVsbCkgPyBtc2cgKyAnOiAnIDogJyc7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cgKyBfLmluc3BlY3Qob2JqKSArICcgaGFzIG5vICcgKyBkZXNjcmlwdG9yICsgXy5pbnNwZWN0KG5hbWUpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICAgdW5kZWZpbmVkICE9PSB2YWx1ZVxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGhhdmUgYSAnICsgZGVzY3JpcHRvciArIF8uaW5zcGVjdChuYW1lKVxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBoYXZlICcgKyBkZXNjcmlwdG9yICsgXy5pbnNwZWN0KG5hbWUpKTtcbiAgICB9XG5cbiAgICBpZiAodW5kZWZpbmVkICE9PSB2YWwpIHtcbiAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgIHZhbCA9PT0gdmFsdWVcbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBoYXZlIGEgJyArIGRlc2NyaXB0b3IgKyBfLmluc3BlY3QobmFtZSkgKyAnIG9mICN7ZXhwfSwgYnV0IGdvdCAje2FjdH0nXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGhhdmUgYSAnICsgZGVzY3JpcHRvciArIF8uaW5zcGVjdChuYW1lKSArICcgb2YgI3thY3R9J1xuICAgICAgICAsIHZhbFxuICAgICAgICAsIHZhbHVlXG4gICAgICApO1xuICAgIH1cblxuICAgIGZsYWcodGhpcywgJ29iamVjdCcsIHZhbHVlKTtcbiAgfSk7XG5cblxuICAvKipcbiAgICogIyMjIC5vd25Qcm9wZXJ0eShuYW1lKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBoYXMgYW4gb3duIHByb3BlcnR5IGBuYW1lYC5cbiAgICpcbiAgICogICAgIGV4cGVjdCgndGVzdCcpLnRvLmhhdmUub3duUHJvcGVydHkoJ2xlbmd0aCcpO1xuICAgKlxuICAgKiBAbmFtZSBvd25Qcm9wZXJ0eVxuICAgKiBAYWxpYXMgaGF2ZU93blByb3BlcnR5XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gYXNzZXJ0T3duUHJvcGVydHkgKG5hbWUsIG1zZykge1xuICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKTtcbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgb2JqLmhhc093blByb3BlcnR5KG5hbWUpXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGhhdmUgb3duIHByb3BlcnR5ICcgKyBfLmluc3BlY3QobmFtZSlcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGhhdmUgb3duIHByb3BlcnR5ICcgKyBfLmluc3BlY3QobmFtZSlcbiAgICApO1xuICB9XG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnb3duUHJvcGVydHknLCBhc3NlcnRPd25Qcm9wZXJ0eSk7XG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2hhdmVPd25Qcm9wZXJ0eScsIGFzc2VydE93blByb3BlcnR5KTtcblxuICAvKipcbiAgICogIyMjIC5sZW5ndGgodmFsdWUpXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0J3MgYGxlbmd0aGAgcHJvcGVydHkgaGFzXG4gICAqIHRoZSBleHBlY3RlZCB2YWx1ZS5cbiAgICpcbiAgICogICAgIGV4cGVjdChbIDEsIDIsIDNdKS50by5oYXZlLmxlbmd0aCgzKTtcbiAgICogICAgIGV4cGVjdCgnZm9vYmFyJykudG8uaGF2ZS5sZW5ndGgoNik7XG4gICAqXG4gICAqIENhbiBhbHNvIGJlIHVzZWQgYXMgYSBjaGFpbiBwcmVjdXJzb3IgdG8gYSB2YWx1ZVxuICAgKiBjb21wYXJpc29uIGZvciB0aGUgbGVuZ3RoIHByb3BlcnR5LlxuICAgKlxuICAgKiAgICAgZXhwZWN0KCdmb28nKS50by5oYXZlLmxlbmd0aC5hYm92ZSgyKTtcbiAgICogICAgIGV4cGVjdChbIDEsIDIsIDMgXSkudG8uaGF2ZS5sZW5ndGguYWJvdmUoMik7XG4gICAqICAgICBleHBlY3QoJ2ZvbycpLnRvLmhhdmUubGVuZ3RoLmJlbG93KDQpO1xuICAgKiAgICAgZXhwZWN0KFsgMSwgMiwgMyBdKS50by5oYXZlLmxlbmd0aC5iZWxvdyg0KTtcbiAgICogICAgIGV4cGVjdCgnZm9vJykudG8uaGF2ZS5sZW5ndGgud2l0aGluKDIsNCk7XG4gICAqICAgICBleHBlY3QoWyAxLCAyLCAzIF0pLnRvLmhhdmUubGVuZ3RoLndpdGhpbigyLDQpO1xuICAgKlxuICAgKiBAbmFtZSBsZW5ndGhcbiAgICogQGFsaWFzIGxlbmd0aE9mXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBsZW5ndGhcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBmdW5jdGlvbiBhc3NlcnRMZW5ndGhDaGFpbiAoKSB7XG4gICAgZmxhZyh0aGlzLCAnZG9MZW5ndGgnLCB0cnVlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFzc2VydExlbmd0aCAobiwgbXNnKSB7XG4gICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpO1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2cpLnRvLmhhdmUucHJvcGVydHkoJ2xlbmd0aCcpO1xuICAgIHZhciBsZW4gPSBvYmoubGVuZ3RoO1xuXG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIGxlbiA9PSBuXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGhhdmUgYSBsZW5ndGggb2YgI3tleHB9IGJ1dCBnb3QgI3thY3R9J1xuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgaGF2ZSBhIGxlbmd0aCBvZiAje2FjdH0nXG4gICAgICAsIG5cbiAgICAgICwgbGVuXG4gICAgKTtcbiAgfVxuXG4gIEFzc2VydGlvbi5hZGRDaGFpbmFibGVNZXRob2QoJ2xlbmd0aCcsIGFzc2VydExlbmd0aCwgYXNzZXJ0TGVuZ3RoQ2hhaW4pO1xuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdsZW5ndGhPZicsIGFzc2VydExlbmd0aCwgYXNzZXJ0TGVuZ3RoQ2hhaW4pO1xuXG4gIC8qKlxuICAgKiAjIyMgLm1hdGNoKHJlZ2V4cClcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgbWF0Y2hlcyBhIHJlZ3VsYXIgZXhwcmVzc2lvbi5cbiAgICpcbiAgICogICAgIGV4cGVjdCgnZm9vYmFyJykudG8ubWF0Y2goL15mb28vKTtcbiAgICpcbiAgICogQG5hbWUgbWF0Y2hcbiAgICogQHBhcmFtIHtSZWdFeHB9IFJlZ3VsYXJFeHByZXNzaW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnbWF0Y2gnLCBmdW5jdGlvbiAocmUsIG1zZykge1xuICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKTtcbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgcmUuZXhlYyhvYmopXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG1hdGNoICcgKyByZVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSBub3QgdG8gbWF0Y2ggJyArIHJlXG4gICAgKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqICMjIyAuc3RyaW5nKHN0cmluZylcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSBzdHJpbmcgdGFyZ2V0IGNvbnRhaW5zIGFub3RoZXIgc3RyaW5nLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KCdmb29iYXInKS50by5oYXZlLnN0cmluZygnYmFyJyk7XG4gICAqXG4gICAqIEBuYW1lIHN0cmluZ1xuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnc3RyaW5nJywgZnVuY3Rpb24gKHN0ciwgbXNnKSB7XG4gICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpO1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2cpLmlzLmEoJ3N0cmluZycpO1xuXG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIH5vYmouaW5kZXhPZihzdHIpXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGNvbnRhaW4gJyArIF8uaW5zcGVjdChzdHIpXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBjb250YWluICcgKyBfLmluc3BlY3Qoc3RyKVxuICAgICk7XG4gIH0pO1xuXG5cbiAgLyoqXG4gICAqICMjIyAua2V5cyhrZXkxLCBba2V5Ml0sIFsuLi5dKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBoYXMgZXhhY3RseSB0aGUgZ2l2ZW4ga2V5cywgb3JcbiAgICogYXNzZXJ0cyB0aGUgaW5jbHVzaW9uIG9mIHNvbWUga2V5cyB3aGVuIHVzaW5nIHRoZVxuICAgKiBgaW5jbHVkZWAgb3IgYGNvbnRhaW5gIG1vZGlmaWVycy5cbiAgICpcbiAgICogICAgIGV4cGVjdCh7IGZvbzogMSwgYmFyOiAyIH0pLnRvLmhhdmUua2V5cyhbJ2ZvbycsICdiYXInXSk7XG4gICAqICAgICBleHBlY3QoeyBmb286IDEsIGJhcjogMiwgYmF6OiAzIH0pLnRvLmNvbnRhaW4ua2V5cygnZm9vJywgJ2JhcicpO1xuICAgKlxuICAgKiBAbmFtZSBrZXlzXG4gICAqIEBhbGlhcyBrZXlcbiAgICogQHBhcmFtIHtTdHJpbmcuLi58QXJyYXl9IGtleXNcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gYXNzZXJ0S2V5cyAoa2V5cykge1xuICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKVxuICAgICAgLCBzdHJcbiAgICAgICwgb2sgPSB0cnVlO1xuXG4gICAga2V5cyA9IGtleXMgaW5zdGFuY2VvZiBBcnJheVxuICAgICAgPyBrZXlzXG4gICAgICA6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cbiAgICBpZiAoIWtleXMubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoJ2tleXMgcmVxdWlyZWQnKTtcblxuICAgIHZhciBhY3R1YWwgPSBPYmplY3Qua2V5cyhvYmopXG4gICAgICAsIGxlbiA9IGtleXMubGVuZ3RoO1xuXG4gICAgLy8gSW5jbHVzaW9uXG4gICAgb2sgPSBrZXlzLmV2ZXJ5KGZ1bmN0aW9uKGtleSl7XG4gICAgICByZXR1cm4gfmFjdHVhbC5pbmRleE9mKGtleSk7XG4gICAgfSk7XG5cbiAgICAvLyBTdHJpY3RcbiAgICBpZiAoIWZsYWcodGhpcywgJ25lZ2F0ZScpICYmICFmbGFnKHRoaXMsICdjb250YWlucycpKSB7XG4gICAgICBvayA9IG9rICYmIGtleXMubGVuZ3RoID09IGFjdHVhbC5sZW5ndGg7XG4gICAgfVxuXG4gICAgLy8gS2V5IHN0cmluZ1xuICAgIGlmIChsZW4gPiAxKSB7XG4gICAgICBrZXlzID0ga2V5cy5tYXAoZnVuY3Rpb24oa2V5KXtcbiAgICAgICAgcmV0dXJuIF8uaW5zcGVjdChrZXkpO1xuICAgICAgfSk7XG4gICAgICB2YXIgbGFzdCA9IGtleXMucG9wKCk7XG4gICAgICBzdHIgPSBrZXlzLmpvaW4oJywgJykgKyAnLCBhbmQgJyArIGxhc3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IF8uaW5zcGVjdChrZXlzWzBdKTtcbiAgICB9XG5cbiAgICAvLyBGb3JtXG4gICAgc3RyID0gKGxlbiA+IDEgPyAna2V5cyAnIDogJ2tleSAnKSArIHN0cjtcblxuICAgIC8vIEhhdmUgLyBpbmNsdWRlXG4gICAgc3RyID0gKGZsYWcodGhpcywgJ2NvbnRhaW5zJykgPyAnY29udGFpbiAnIDogJ2hhdmUgJykgKyBzdHI7XG5cbiAgICAvLyBBc3NlcnRpb25cbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgb2tcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gJyArIHN0clxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgJyArIHN0clxuICAgICk7XG4gIH1cblxuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdrZXlzJywgYXNzZXJ0S2V5cyk7XG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2tleScsIGFzc2VydEtleXMpO1xuXG4gIC8qKlxuICAgKiAjIyMgLnRocm93KGNvbnN0cnVjdG9yKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIGZ1bmN0aW9uIHRhcmdldCB3aWxsIHRocm93IGEgc3BlY2lmaWMgZXJyb3IsIG9yIHNwZWNpZmljIHR5cGUgb2YgZXJyb3JcbiAgICogKGFzIGRldGVybWluZWQgdXNpbmcgYGluc3RhbmNlb2ZgKSwgb3B0aW9uYWxseSB3aXRoIGEgUmVnRXhwIG9yIHN0cmluZyBpbmNsdXNpb24gdGVzdFxuICAgKiBmb3IgdGhlIGVycm9yJ3MgbWVzc2FnZS5cbiAgICpcbiAgICogICAgIHZhciBlcnIgPSBuZXcgUmVmZXJlbmNlRXJyb3IoJ1RoaXMgaXMgYSBiYWQgZnVuY3Rpb24uJyk7XG4gICAqICAgICB2YXIgZm4gPSBmdW5jdGlvbiAoKSB7IHRocm93IGVycjsgfVxuICAgKiAgICAgZXhwZWN0KGZuKS50by50aHJvdyhSZWZlcmVuY2VFcnJvcik7XG4gICAqICAgICBleHBlY3QoZm4pLnRvLnRocm93KEVycm9yKTtcbiAgICogICAgIGV4cGVjdChmbikudG8udGhyb3coL2JhZCBmdW5jdGlvbi8pO1xuICAgKiAgICAgZXhwZWN0KGZuKS50by5ub3QudGhyb3coJ2dvb2QgZnVuY3Rpb24nKTtcbiAgICogICAgIGV4cGVjdChmbikudG8udGhyb3coUmVmZXJlbmNlRXJyb3IsIC9iYWQgZnVuY3Rpb24vKTtcbiAgICogICAgIGV4cGVjdChmbikudG8udGhyb3coZXJyKTtcbiAgICogICAgIGV4cGVjdChmbikudG8ubm90LnRocm93KG5ldyBSYW5nZUVycm9yKCdPdXQgb2YgcmFuZ2UuJykpO1xuICAgKlxuICAgKiBQbGVhc2Ugbm90ZSB0aGF0IHdoZW4gYSB0aHJvdyBleHBlY3RhdGlvbiBpcyBuZWdhdGVkLCBpdCB3aWxsIGNoZWNrIGVhY2hcbiAgICogcGFyYW1ldGVyIGluZGVwZW5kZW50bHksIHN0YXJ0aW5nIHdpdGggZXJyb3IgY29uc3RydWN0b3IgdHlwZS4gVGhlIGFwcHJvcHJpYXRlIHdheVxuICAgKiB0byBjaGVjayBmb3IgdGhlIGV4aXN0ZW5jZSBvZiBhIHR5cGUgb2YgZXJyb3IgYnV0IGZvciBhIG1lc3NhZ2UgdGhhdCBkb2VzIG5vdCBtYXRjaFxuICAgKiBpcyB0byB1c2UgYGFuZGAuXG4gICAqXG4gICAqICAgICBleHBlY3QoZm4pLnRvLnRocm93KFJlZmVyZW5jZUVycm9yKVxuICAgKiAgICAgICAgLmFuZC5ub3QudGhyb3coL2dvb2QgZnVuY3Rpb24vKTtcbiAgICpcbiAgICogQG5hbWUgdGhyb3dcbiAgICogQGFsaWFzIHRocm93c1xuICAgKiBAYWxpYXMgVGhyb3dcbiAgICogQHBhcmFtIHtFcnJvckNvbnN0cnVjdG9yfSBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge1N0cmluZ3xSZWdFeHB9IGV4cGVjdGVkIGVycm9yIG1lc3NhZ2VcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0Vycm9yI0Vycm9yX3R5cGVzXG4gICAqIEByZXR1cm5zIGVycm9yIGZvciBjaGFpbmluZyAobnVsbCBpZiBubyBlcnJvcilcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gYXNzZXJ0VGhyb3dzIChjb25zdHJ1Y3RvciwgZXJyTXNnLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0Jyk7XG4gICAgbmV3IEFzc2VydGlvbihvYmosIG1zZykuaXMuYSgnZnVuY3Rpb24nKTtcblxuICAgIHZhciB0aHJvd24gPSBmYWxzZVxuICAgICAgLCBkZXNpcmVkRXJyb3IgPSBudWxsXG4gICAgICAsIG5hbWUgPSBudWxsXG4gICAgICAsIHRocm93bkVycm9yID0gbnVsbDtcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICBlcnJNc2cgPSBudWxsO1xuICAgICAgY29uc3RydWN0b3IgPSBudWxsO1xuICAgIH0gZWxzZSBpZiAoY29uc3RydWN0b3IgJiYgKGNvbnN0cnVjdG9yIGluc3RhbmNlb2YgUmVnRXhwIHx8ICdzdHJpbmcnID09PSB0eXBlb2YgY29uc3RydWN0b3IpKSB7XG4gICAgICBlcnJNc2cgPSBjb25zdHJ1Y3RvcjtcbiAgICAgIGNvbnN0cnVjdG9yID0gbnVsbDtcbiAgICB9IGVsc2UgaWYgKGNvbnN0cnVjdG9yICYmIGNvbnN0cnVjdG9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIGRlc2lyZWRFcnJvciA9IGNvbnN0cnVjdG9yO1xuICAgICAgY29uc3RydWN0b3IgPSBudWxsO1xuICAgICAgZXJyTXNnID0gbnVsbDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBjb25zdHJ1Y3RvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgbmFtZSA9IGNvbnN0cnVjdG9yLnByb3RvdHlwZS5uYW1lIHx8IGNvbnN0cnVjdG9yLm5hbWU7XG4gICAgICBpZiAobmFtZSA9PT0gJ0Vycm9yJyAmJiBjb25zdHJ1Y3RvciAhPT0gRXJyb3IpIHtcbiAgICAgICAgbmFtZSA9IChuZXcgY29uc3RydWN0b3IoKSkubmFtZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3RydWN0b3IgPSBudWxsO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBvYmooKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIC8vIGZpcnN0LCBjaGVjayBkZXNpcmVkIGVycm9yXG4gICAgICBpZiAoZGVzaXJlZEVycm9yKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgICAgZXJyID09PSBkZXNpcmVkRXJyb3JcbiAgICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIHRocm93ICN7ZXhwfSBidXQgI3thY3R9IHdhcyB0aHJvd24nXG4gICAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgdGhyb3cgI3tleHB9J1xuICAgICAgICAgICwgKGRlc2lyZWRFcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZGVzaXJlZEVycm9yLnRvU3RyaW5nKCkgOiBkZXNpcmVkRXJyb3IpXG4gICAgICAgICAgLCAoZXJyIGluc3RhbmNlb2YgRXJyb3IgPyBlcnIudG9TdHJpbmcoKSA6IGVycilcbiAgICAgICAgKTtcblxuICAgICAgICBmbGFnKHRoaXMsICdvYmplY3QnLCBlcnIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgLy8gbmV4dCwgY2hlY2sgY29uc3RydWN0b3JcbiAgICAgIGlmIChjb25zdHJ1Y3Rvcikge1xuICAgICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgICAgIGVyciBpbnN0YW5jZW9mIGNvbnN0cnVjdG9yXG4gICAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byB0aHJvdyAje2V4cH0gYnV0ICN7YWN0fSB3YXMgdGhyb3duJ1xuICAgICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IHRocm93ICN7ZXhwfSBidXQgI3thY3R9IHdhcyB0aHJvd24nXG4gICAgICAgICAgLCBuYW1lXG4gICAgICAgICAgLCAoZXJyIGluc3RhbmNlb2YgRXJyb3IgPyBlcnIudG9TdHJpbmcoKSA6IGVycilcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAoIWVyck1zZykge1xuICAgICAgICAgIGZsYWcodGhpcywgJ29iamVjdCcsIGVycik7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gbmV4dCwgY2hlY2sgbWVzc2FnZVxuICAgICAgdmFyIG1lc3NhZ2UgPSAnb2JqZWN0JyA9PT0gXy50eXBlKGVycikgJiYgXCJtZXNzYWdlXCIgaW4gZXJyXG4gICAgICAgID8gZXJyLm1lc3NhZ2VcbiAgICAgICAgOiAnJyArIGVycjtcblxuICAgICAgaWYgKChtZXNzYWdlICE9IG51bGwpICYmIGVyck1zZyAmJiBlcnJNc2cgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICAgICBlcnJNc2cuZXhlYyhtZXNzYWdlKVxuICAgICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gdGhyb3cgZXJyb3IgbWF0Y2hpbmcgI3tleHB9IGJ1dCBnb3QgI3thY3R9J1xuICAgICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gdGhyb3cgZXJyb3Igbm90IG1hdGNoaW5nICN7ZXhwfSdcbiAgICAgICAgICAsIGVyck1zZ1xuICAgICAgICAgICwgbWVzc2FnZVxuICAgICAgICApO1xuXG4gICAgICAgIGZsYWcodGhpcywgJ29iamVjdCcsIGVycik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSBlbHNlIGlmICgobWVzc2FnZSAhPSBudWxsKSAmJiBlcnJNc2cgJiYgJ3N0cmluZycgPT09IHR5cGVvZiBlcnJNc2cpIHtcbiAgICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICAgICB+bWVzc2FnZS5pbmRleE9mKGVyck1zZylcbiAgICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIHRocm93IGVycm9yIGluY2x1ZGluZyAje2V4cH0gYnV0IGdvdCAje2FjdH0nXG4gICAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byB0aHJvdyBlcnJvciBub3QgaW5jbHVkaW5nICN7YWN0fSdcbiAgICAgICAgICAsIGVyck1zZ1xuICAgICAgICAgICwgbWVzc2FnZVxuICAgICAgICApO1xuXG4gICAgICAgIGZsYWcodGhpcywgJ29iamVjdCcsIGVycik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3duID0gdHJ1ZTtcbiAgICAgICAgdGhyb3duRXJyb3IgPSBlcnI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGFjdHVhbGx5R290ID0gJydcbiAgICAgICwgZXhwZWN0ZWRUaHJvd24gPSBuYW1lICE9PSBudWxsXG4gICAgICAgID8gbmFtZVxuICAgICAgICA6IGRlc2lyZWRFcnJvclxuICAgICAgICAgID8gJyN7ZXhwfScgLy9fLmluc3BlY3QoZGVzaXJlZEVycm9yKVxuICAgICAgICAgIDogJ2FuIGVycm9yJztcblxuICAgIGlmICh0aHJvd24pIHtcbiAgICAgIGFjdHVhbGx5R290ID0gJyBidXQgI3thY3R9IHdhcyB0aHJvd24nXG4gICAgfVxuXG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIHRocm93biA9PT0gdHJ1ZVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byB0aHJvdyAnICsgZXhwZWN0ZWRUaHJvd24gKyBhY3R1YWxseUdvdFxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgdGhyb3cgJyArIGV4cGVjdGVkVGhyb3duICsgYWN0dWFsbHlHb3RcbiAgICAgICwgKGRlc2lyZWRFcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZGVzaXJlZEVycm9yLnRvU3RyaW5nKCkgOiBkZXNpcmVkRXJyb3IpXG4gICAgICAsICh0aHJvd25FcnJvciBpbnN0YW5jZW9mIEVycm9yID8gdGhyb3duRXJyb3IudG9TdHJpbmcoKSA6IHRocm93bkVycm9yKVxuICAgICk7XG5cbiAgICBmbGFnKHRoaXMsICdvYmplY3QnLCB0aHJvd25FcnJvcik7XG4gIH07XG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgndGhyb3cnLCBhc3NlcnRUaHJvd3MpO1xuICBBc3NlcnRpb24uYWRkTWV0aG9kKCd0aHJvd3MnLCBhc3NlcnRUaHJvd3MpO1xuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdUaHJvdycsIGFzc2VydFRocm93cyk7XG5cbiAgLyoqXG4gICAqICMjIyAucmVzcG9uZFRvKG1ldGhvZClcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSBvYmplY3Qgb3IgY2xhc3MgdGFyZ2V0IHdpbGwgcmVzcG9uZCB0byBhIG1ldGhvZC5cbiAgICpcbiAgICogICAgIEtsYXNzLnByb3RvdHlwZS5iYXIgPSBmdW5jdGlvbigpe307XG4gICAqICAgICBleHBlY3QoS2xhc3MpLnRvLnJlc3BvbmRUbygnYmFyJyk7XG4gICAqICAgICBleHBlY3Qob2JqKS50by5yZXNwb25kVG8oJ2JhcicpO1xuICAgKlxuICAgKiBUbyBjaGVjayBpZiBhIGNvbnN0cnVjdG9yIHdpbGwgcmVzcG9uZCB0byBhIHN0YXRpYyBmdW5jdGlvbixcbiAgICogc2V0IHRoZSBgaXRzZWxmYCBmbGFnLlxuICAgKlxuICAgKiAgICAgS2xhc3MuYmF6ID0gZnVuY3Rpb24oKXt9O1xuICAgKiAgICAgZXhwZWN0KEtsYXNzKS5pdHNlbGYudG8ucmVzcG9uZFRvKCdiYXonKTtcbiAgICpcbiAgICogQG5hbWUgcmVzcG9uZFRvXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2RcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdyZXNwb25kVG8nLCBmdW5jdGlvbiAobWV0aG9kLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0JylcbiAgICAgICwgaXRzZWxmID0gZmxhZyh0aGlzLCAnaXRzZWxmJylcbiAgICAgICwgY29udGV4dCA9ICgnZnVuY3Rpb24nID09PSBfLnR5cGUob2JqKSAmJiAhaXRzZWxmKVxuICAgICAgICA/IG9iai5wcm90b3R5cGVbbWV0aG9kXVxuICAgICAgICA6IG9ialttZXRob2RdO1xuXG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICdmdW5jdGlvbicgPT09IHR5cGVvZiBjb250ZXh0XG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIHJlc3BvbmQgdG8gJyArIF8uaW5zcGVjdChtZXRob2QpXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCByZXNwb25kIHRvICcgKyBfLmluc3BlY3QobWV0aG9kKVxuICAgICk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiAjIyMgLml0c2VsZlxuICAgKlxuICAgKiBTZXRzIHRoZSBgaXRzZWxmYCBmbGFnLCBsYXRlciB1c2VkIGJ5IHRoZSBgcmVzcG9uZFRvYCBhc3NlcnRpb24uXG4gICAqXG4gICAqICAgICBmdW5jdGlvbiBGb28oKSB7fVxuICAgKiAgICAgRm9vLmJhciA9IGZ1bmN0aW9uKCkge31cbiAgICogICAgIEZvby5wcm90b3R5cGUuYmF6ID0gZnVuY3Rpb24oKSB7fVxuICAgKlxuICAgKiAgICAgZXhwZWN0KEZvbykuaXRzZWxmLnRvLnJlc3BvbmRUbygnYmFyJyk7XG4gICAqICAgICBleHBlY3QoRm9vKS5pdHNlbGYubm90LnRvLnJlc3BvbmRUbygnYmF6Jyk7XG4gICAqXG4gICAqIEBuYW1lIGl0c2VsZlxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkUHJvcGVydHkoJ2l0c2VsZicsIGZ1bmN0aW9uICgpIHtcbiAgICBmbGFnKHRoaXMsICdpdHNlbGYnLCB0cnVlKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqICMjIyAuc2F0aXNmeShtZXRob2QpXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IHBhc3NlcyBhIGdpdmVuIHRydXRoIHRlc3QuXG4gICAqXG4gICAqICAgICBleHBlY3QoMSkudG8uc2F0aXNmeShmdW5jdGlvbihudW0pIHsgcmV0dXJuIG51bSA+IDA7IH0pO1xuICAgKlxuICAgKiBAbmFtZSBzYXRpc2Z5XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG1hdGNoZXJcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdzYXRpc2Z5JywgZnVuY3Rpb24gKG1hdGNoZXIsIG1zZykge1xuICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKTtcbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgbWF0Y2hlcihvYmopXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIHNhdGlzZnkgJyArIF8ub2JqRGlzcGxheShtYXRjaGVyKVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3Qgc2F0aXNmeScgKyBfLm9iakRpc3BsYXkobWF0Y2hlcilcbiAgICAgICwgdGhpcy5uZWdhdGUgPyBmYWxzZSA6IHRydWVcbiAgICAgICwgbWF0Y2hlcihvYmopXG4gICAgKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqICMjIyAuY2xvc2VUbyhleHBlY3RlZCwgZGVsdGEpXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIGVxdWFsIGBleHBlY3RlZGAsIHRvIHdpdGhpbiBhICsvLSBgZGVsdGFgIHJhbmdlLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KDEuNSkudG8uYmUuY2xvc2VUbygxLCAwLjUpO1xuICAgKlxuICAgKiBAbmFtZSBjbG9zZVRvXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBleHBlY3RlZFxuICAgKiBAcGFyYW0ge051bWJlcn0gZGVsdGFcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdjbG9zZVRvJywgZnVuY3Rpb24gKGV4cGVjdGVkLCBkZWx0YSwgbXNnKSB7XG4gICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpO1xuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICBNYXRoLmFicyhvYmogLSBleHBlY3RlZCkgPD0gZGVsdGFcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgY2xvc2UgdG8gJyArIGV4cGVjdGVkICsgJyArLy0gJyArIGRlbHRhXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IG5vdCB0byBiZSBjbG9zZSB0byAnICsgZXhwZWN0ZWQgKyAnICsvLSAnICsgZGVsdGFcbiAgICApO1xuICB9KTtcblxuICBmdW5jdGlvbiBpc1N1YnNldE9mKHN1YnNldCwgc3VwZXJzZXQsIGNtcCkge1xuICAgIHJldHVybiBzdWJzZXQuZXZlcnkoZnVuY3Rpb24oZWxlbSkge1xuICAgICAgaWYgKCFjbXApIHJldHVybiBzdXBlcnNldC5pbmRleE9mKGVsZW0pICE9PSAtMTtcblxuICAgICAgcmV0dXJuIHN1cGVyc2V0LnNvbWUoZnVuY3Rpb24oZWxlbTIpIHtcbiAgICAgICAgcmV0dXJuIGNtcChlbGVtLCBlbGVtMik7XG4gICAgICB9KTtcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqICMjIyAubWVtYmVycyhzZXQpXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIGEgc3VwZXJzZXQgb2YgYHNldGAsXG4gICAqIG9yIHRoYXQgdGhlIHRhcmdldCBhbmQgYHNldGAgaGF2ZSB0aGUgc2FtZSBzdHJpY3RseS1lcXVhbCAoPT09KSBtZW1iZXJzLlxuICAgKiBBbHRlcm5hdGVseSwgaWYgdGhlIGBkZWVwYCBmbGFnIGlzIHNldCwgc2V0IG1lbWJlcnMgYXJlIGNvbXBhcmVkIGZvciBkZWVwXG4gICAqIGVxdWFsaXR5LlxuICAgKlxuICAgKiAgICAgZXhwZWN0KFsxLCAyLCAzXSkudG8uaW5jbHVkZS5tZW1iZXJzKFszLCAyXSk7XG4gICAqICAgICBleHBlY3QoWzEsIDIsIDNdKS50by5ub3QuaW5jbHVkZS5tZW1iZXJzKFszLCAyLCA4XSk7XG4gICAqXG4gICAqICAgICBleHBlY3QoWzQsIDJdKS50by5oYXZlLm1lbWJlcnMoWzIsIDRdKTtcbiAgICogICAgIGV4cGVjdChbNSwgMl0pLnRvLm5vdC5oYXZlLm1lbWJlcnMoWzUsIDIsIDFdKTtcbiAgICpcbiAgICogICAgIGV4cGVjdChbeyBpZDogMSB9XSkudG8uZGVlcC5pbmNsdWRlLm1lbWJlcnMoW3sgaWQ6IDEgfV0pO1xuICAgKlxuICAgKiBAbmFtZSBtZW1iZXJzXG4gICAqIEBwYXJhbSB7QXJyYXl9IHNldFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ21lbWJlcnMnLCBmdW5jdGlvbiAoc3Vic2V0LCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0Jyk7XG5cbiAgICBuZXcgQXNzZXJ0aW9uKG9iaikudG8uYmUuYW4oJ2FycmF5Jyk7XG4gICAgbmV3IEFzc2VydGlvbihzdWJzZXQpLnRvLmJlLmFuKCdhcnJheScpO1xuXG4gICAgdmFyIGNtcCA9IGZsYWcodGhpcywgJ2RlZXAnKSA/IF8uZXFsIDogdW5kZWZpbmVkO1xuXG4gICAgaWYgKGZsYWcodGhpcywgJ2NvbnRhaW5zJykpIHtcbiAgICAgIHJldHVybiB0aGlzLmFzc2VydChcbiAgICAgICAgICBpc1N1YnNldE9mKHN1YnNldCwgb2JqLCBjbXApXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgYSBzdXBlcnNldCBvZiAje2FjdH0nXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGJlIGEgc3VwZXJzZXQgb2YgI3thY3R9J1xuICAgICAgICAsIG9ialxuICAgICAgICAsIHN1YnNldFxuICAgICAgKTtcbiAgICB9XG5cbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgaXNTdWJzZXRPZihvYmosIHN1YnNldCwgY21wKSAmJiBpc1N1YnNldE9mKHN1YnNldCwgb2JqLCBjbXApXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gaGF2ZSB0aGUgc2FtZSBtZW1iZXJzIGFzICN7YWN0fSdcbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgaGF2ZSB0aGUgc2FtZSBtZW1iZXJzIGFzICN7YWN0fSdcbiAgICAgICAgLCBvYmpcbiAgICAgICAgLCBzdWJzZXRcbiAgICApO1xuICB9KTtcbn07XG4iLCIvKiFcbiAqIGNoYWlcbiAqIENvcHlyaWdodChjKSAyMDExLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNoYWksIHV0aWwpIHtcblxuICAvKiFcbiAgICogQ2hhaSBkZXBlbmRlbmNpZXMuXG4gICAqL1xuXG4gIHZhciBBc3NlcnRpb24gPSBjaGFpLkFzc2VydGlvblxuICAgICwgZmxhZyA9IHV0aWwuZmxhZztcblxuICAvKiFcbiAgICogTW9kdWxlIGV4cG9ydC5cbiAgICovXG5cbiAgLyoqXG4gICAqICMjIyBhc3NlcnQoZXhwcmVzc2lvbiwgbWVzc2FnZSlcbiAgICpcbiAgICogV3JpdGUgeW91ciBvd24gdGVzdCBleHByZXNzaW9ucy5cbiAgICpcbiAgICogICAgIGFzc2VydCgnZm9vJyAhPT0gJ2JhcicsICdmb28gaXMgbm90IGJhcicpO1xuICAgKiAgICAgYXNzZXJ0KEFycmF5LmlzQXJyYXkoW10pLCAnZW1wdHkgYXJyYXlzIGFyZSBhcnJheXMnKTtcbiAgICpcbiAgICogQHBhcmFtIHtNaXhlZH0gZXhwcmVzc2lvbiB0byB0ZXN0IGZvciB0cnV0aGluZXNzXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIHRvIGRpc3BsYXkgb24gZXJyb3JcbiAgICogQG5hbWUgYXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIHZhciBhc3NlcnQgPSBjaGFpLmFzc2VydCA9IGZ1bmN0aW9uIChleHByZXNzLCBlcnJtc2cpIHtcbiAgICB2YXIgdGVzdCA9IG5ldyBBc3NlcnRpb24obnVsbCwgbnVsbCwgY2hhaS5hc3NlcnQpO1xuICAgIHRlc3QuYXNzZXJ0KFxuICAgICAgICBleHByZXNzXG4gICAgICAsIGVycm1zZ1xuICAgICAgLCAnWyBuZWdhdGlvbiBtZXNzYWdlIHVuYXZhaWxhYmxlIF0nXG4gICAgKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5mYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIFttZXNzYWdlXSwgW29wZXJhdG9yXSlcbiAgICpcbiAgICogVGhyb3cgYSBmYWlsdXJlLiBOb2RlLmpzIGBhc3NlcnRgIG1vZHVsZS1jb21wYXRpYmxlLlxuICAgKlxuICAgKiBAbmFtZSBmYWlsXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGFjdHVhbFxuICAgKiBAcGFyYW0ge01peGVkfSBleHBlY3RlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gb3BlcmF0b3JcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmZhaWwgPSBmdW5jdGlvbiAoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgb3BlcmF0b3IpIHtcbiAgICBtZXNzYWdlID0gbWVzc2FnZSB8fCAnYXNzZXJ0LmZhaWwoKSc7XG4gICAgdGhyb3cgbmV3IGNoYWkuQXNzZXJ0aW9uRXJyb3IobWVzc2FnZSwge1xuICAgICAgICBhY3R1YWw6IGFjdHVhbFxuICAgICAgLCBleHBlY3RlZDogZXhwZWN0ZWRcbiAgICAgICwgb3BlcmF0b3I6IG9wZXJhdG9yXG4gICAgfSwgYXNzZXJ0LmZhaWwpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLm9rKG9iamVjdCwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYG9iamVjdGAgaXMgdHJ1dGh5LlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lm9rKCdldmVyeXRoaW5nJywgJ2V2ZXJ5dGhpbmcgaXMgb2snKTtcbiAgICogICAgIGFzc2VydC5vayhmYWxzZSwgJ3RoaXMgd2lsbCBmYWlsJyk7XG4gICAqXG4gICAqIEBuYW1lIG9rXG4gICAqIEBwYXJhbSB7TWl4ZWR9IG9iamVjdCB0byB0ZXN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5vayA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2cpLmlzLm9rO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLm5vdE9rKG9iamVjdCwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYG9iamVjdGAgaXMgZmFsc3kuXG4gICAqXG4gICAqICAgICBhc3NlcnQubm90T2soJ2V2ZXJ5dGhpbmcnLCAndGhpcyB3aWxsIGZhaWwnKTtcbiAgICogICAgIGFzc2VydC5ub3RPayhmYWxzZSwgJ3RoaXMgd2lsbCBwYXNzJyk7XG4gICAqXG4gICAqIEBuYW1lIG5vdE9rXG4gICAqIEBwYXJhbSB7TWl4ZWR9IG9iamVjdCB0byB0ZXN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5ub3RPayA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2cpLmlzLm5vdC5vaztcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5lcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgbm9uLXN0cmljdCBlcXVhbGl0eSAoYD09YCkgb2YgYGFjdHVhbGAgYW5kIGBleHBlY3RlZGAuXG4gICAqXG4gICAqICAgICBhc3NlcnQuZXF1YWwoMywgJzMnLCAnPT0gY29lcmNlcyB2YWx1ZXMgdG8gc3RyaW5ncycpO1xuICAgKlxuICAgKiBAbmFtZSBlcXVhbFxuICAgKiBAcGFyYW0ge01peGVkfSBhY3R1YWxcbiAgICogQHBhcmFtIHtNaXhlZH0gZXhwZWN0ZWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmVxdWFsID0gZnVuY3Rpb24gKGFjdCwgZXhwLCBtc2cpIHtcbiAgICB2YXIgdGVzdCA9IG5ldyBBc3NlcnRpb24oYWN0LCBtc2csIGFzc2VydC5lcXVhbCk7XG5cbiAgICB0ZXN0LmFzc2VydChcbiAgICAgICAgZXhwID09IGZsYWcodGVzdCwgJ29iamVjdCcpXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGVxdWFsICN7ZXhwfSdcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGVxdWFsICN7YWN0fSdcbiAgICAgICwgZXhwXG4gICAgICAsIGFjdFxuICAgICk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAubm90RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIG5vbi1zdHJpY3QgaW5lcXVhbGl0eSAoYCE9YCkgb2YgYGFjdHVhbGAgYW5kIGBleHBlY3RlZGAuXG4gICAqXG4gICAqICAgICBhc3NlcnQubm90RXF1YWwoMywgNCwgJ3RoZXNlIG51bWJlcnMgYXJlIG5vdCBlcXVhbCcpO1xuICAgKlxuICAgKiBAbmFtZSBub3RFcXVhbFxuICAgKiBAcGFyYW0ge01peGVkfSBhY3R1YWxcbiAgICogQHBhcmFtIHtNaXhlZH0gZXhwZWN0ZWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm5vdEVxdWFsID0gZnVuY3Rpb24gKGFjdCwgZXhwLCBtc2cpIHtcbiAgICB2YXIgdGVzdCA9IG5ldyBBc3NlcnRpb24oYWN0LCBtc2csIGFzc2VydC5ub3RFcXVhbCk7XG5cbiAgICB0ZXN0LmFzc2VydChcbiAgICAgICAgZXhwICE9IGZsYWcodGVzdCwgJ29iamVjdCcpXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBlcXVhbCAje2V4cH0nXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGVxdWFsICN7YWN0fSdcbiAgICAgICwgZXhwXG4gICAgICAsIGFjdFxuICAgICk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuc3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHN0cmljdCBlcXVhbGl0eSAoYD09PWApIG9mIGBhY3R1YWxgIGFuZCBgZXhwZWN0ZWRgLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LnN0cmljdEVxdWFsKHRydWUsIHRydWUsICd0aGVzZSBib29sZWFucyBhcmUgc3RyaWN0bHkgZXF1YWwnKTtcbiAgICpcbiAgICogQG5hbWUgc3RyaWN0RXF1YWxcbiAgICogQHBhcmFtIHtNaXhlZH0gYWN0dWFsXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGV4cGVjdGVkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5zdHJpY3RFcXVhbCA9IGZ1bmN0aW9uIChhY3QsIGV4cCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihhY3QsIG1zZykudG8uZXF1YWwoZXhwKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5ub3RTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgc3RyaWN0IGluZXF1YWxpdHkgKGAhPT1gKSBvZiBgYWN0dWFsYCBhbmQgYGV4cGVjdGVkYC5cbiAgICpcbiAgICogICAgIGFzc2VydC5ub3RTdHJpY3RFcXVhbCgzLCAnMycsICdubyBjb2VyY2lvbiBmb3Igc3RyaWN0IGVxdWFsaXR5Jyk7XG4gICAqXG4gICAqIEBuYW1lIG5vdFN0cmljdEVxdWFsXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGFjdHVhbFxuICAgKiBAcGFyYW0ge01peGVkfSBleHBlY3RlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQubm90U3RyaWN0RXF1YWwgPSBmdW5jdGlvbiAoYWN0LCBleHAsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oYWN0LCBtc2cpLnRvLm5vdC5lcXVhbChleHApO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmRlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgYWN0dWFsYCBpcyBkZWVwbHkgZXF1YWwgdG8gYGV4cGVjdGVkYC5cbiAgICpcbiAgICogICAgIGFzc2VydC5kZWVwRXF1YWwoeyB0ZWE6ICdncmVlbicgfSwgeyB0ZWE6ICdncmVlbicgfSk7XG4gICAqXG4gICAqIEBuYW1lIGRlZXBFcXVhbFxuICAgKiBAcGFyYW0ge01peGVkfSBhY3R1YWxcbiAgICogQHBhcmFtIHtNaXhlZH0gZXhwZWN0ZWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmRlZXBFcXVhbCA9IGZ1bmN0aW9uIChhY3QsIGV4cCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihhY3QsIG1zZykudG8uZXFsKGV4cCk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAubm90RGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0IHRoYXQgYGFjdHVhbGAgaXMgbm90IGRlZXBseSBlcXVhbCB0byBgZXhwZWN0ZWRgLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lm5vdERlZXBFcXVhbCh7IHRlYTogJ2dyZWVuJyB9LCB7IHRlYTogJ2phc21pbmUnIH0pO1xuICAgKlxuICAgKiBAbmFtZSBub3REZWVwRXF1YWxcbiAgICogQHBhcmFtIHtNaXhlZH0gYWN0dWFsXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGV4cGVjdGVkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5ub3REZWVwRXF1YWwgPSBmdW5jdGlvbiAoYWN0LCBleHAsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oYWN0LCBtc2cpLnRvLm5vdC5lcWwoZXhwKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc1RydWUodmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAgaXMgdHJ1ZS5cbiAgICpcbiAgICogICAgIHZhciB0ZWFTZXJ2ZWQgPSB0cnVlO1xuICAgKiAgICAgYXNzZXJ0LmlzVHJ1ZSh0ZWFTZXJ2ZWQsICd0aGUgdGVhIGhhcyBiZWVuIHNlcnZlZCcpO1xuICAgKlxuICAgKiBAbmFtZSBpc1RydWVcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzVHJ1ZSA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2cpLmlzWyd0cnVlJ107XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNGYWxzZSh2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBpcyBmYWxzZS5cbiAgICpcbiAgICogICAgIHZhciB0ZWFTZXJ2ZWQgPSBmYWxzZTtcbiAgICogICAgIGFzc2VydC5pc0ZhbHNlKHRlYVNlcnZlZCwgJ25vIHRlYSB5ZXQ/IGhtbS4uLicpO1xuICAgKlxuICAgKiBAbmFtZSBpc0ZhbHNlXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc0ZhbHNlID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZykuaXNbJ2ZhbHNlJ107XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNOdWxsKHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgIGlzIG51bGwuXG4gICAqXG4gICAqICAgICBhc3NlcnQuaXNOdWxsKGVyciwgJ3RoZXJlIHdhcyBubyBlcnJvcicpO1xuICAgKlxuICAgKiBAbmFtZSBpc051bGxcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzTnVsbCA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2cpLnRvLmVxdWFsKG51bGwpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzTm90TnVsbCh2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBpcyBub3QgbnVsbC5cbiAgICpcbiAgICogICAgIHZhciB0ZWEgPSAndGFzdHkgY2hhaSc7XG4gICAqICAgICBhc3NlcnQuaXNOb3ROdWxsKHRlYSwgJ2dyZWF0LCB0aW1lIGZvciB0ZWEhJyk7XG4gICAqXG4gICAqIEBuYW1lIGlzTm90TnVsbFxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNOb3ROdWxsID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZykudG8ubm90LmVxdWFsKG51bGwpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzVW5kZWZpbmVkKHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgIGlzIGB1bmRlZmluZWRgLlxuICAgKlxuICAgKiAgICAgdmFyIHRlYTtcbiAgICogICAgIGFzc2VydC5pc1VuZGVmaW5lZCh0ZWEsICdubyB0ZWEgZGVmaW5lZCcpO1xuICAgKlxuICAgKiBAbmFtZSBpc1VuZGVmaW5lZFxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNVbmRlZmluZWQgPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnKS50by5lcXVhbCh1bmRlZmluZWQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzRGVmaW5lZCh2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBpcyBub3QgYHVuZGVmaW5lZGAuXG4gICAqXG4gICAqICAgICB2YXIgdGVhID0gJ2N1cCBvZiBjaGFpJztcbiAgICogICAgIGFzc2VydC5pc0RlZmluZWQodGVhLCAndGVhIGhhcyBiZWVuIGRlZmluZWQnKTtcbiAgICpcbiAgICogQG5hbWUgaXNEZWZpbmVkXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc0RlZmluZWQgPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnKS50by5ub3QuZXF1YWwodW5kZWZpbmVkKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc0Z1bmN0aW9uKHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgIGlzIGEgZnVuY3Rpb24uXG4gICAqXG4gICAqICAgICBmdW5jdGlvbiBzZXJ2ZVRlYSgpIHsgcmV0dXJuICdjdXAgb2YgdGVhJzsgfTtcbiAgICogICAgIGFzc2VydC5pc0Z1bmN0aW9uKHNlcnZlVGVhLCAnZ3JlYXQsIHdlIGNhbiBoYXZlIHRlYSBub3cnKTtcbiAgICpcbiAgICogQG5hbWUgaXNGdW5jdGlvblxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNGdW5jdGlvbiA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2cpLnRvLmJlLmEoJ2Z1bmN0aW9uJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNOb3RGdW5jdGlvbih2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBpcyBfbm90XyBhIGZ1bmN0aW9uLlxuICAgKlxuICAgKiAgICAgdmFyIHNlcnZlVGVhID0gWyAnaGVhdCcsICdwb3VyJywgJ3NpcCcgXTtcbiAgICogICAgIGFzc2VydC5pc05vdEZ1bmN0aW9uKHNlcnZlVGVhLCAnZ3JlYXQsIHdlIGhhdmUgbGlzdGVkIHRoZSBzdGVwcycpO1xuICAgKlxuICAgKiBAbmFtZSBpc05vdEZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc05vdEZ1bmN0aW9uID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZykudG8ubm90LmJlLmEoJ2Z1bmN0aW9uJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNPYmplY3QodmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAgaXMgYW4gb2JqZWN0IChhcyByZXZlYWxlZCBieVxuICAgKiBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2ApLlxuICAgKlxuICAgKiAgICAgdmFyIHNlbGVjdGlvbiA9IHsgbmFtZTogJ0NoYWknLCBzZXJ2ZTogJ3dpdGggc3BpY2VzJyB9O1xuICAgKiAgICAgYXNzZXJ0LmlzT2JqZWN0KHNlbGVjdGlvbiwgJ3RlYSBzZWxlY3Rpb24gaXMgYW4gb2JqZWN0Jyk7XG4gICAqXG4gICAqIEBuYW1lIGlzT2JqZWN0XG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc09iamVjdCA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2cpLnRvLmJlLmEoJ29iamVjdCcpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzTm90T2JqZWN0KHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgIGlzIF9ub3RfIGFuIG9iamVjdC5cbiAgICpcbiAgICogICAgIHZhciBzZWxlY3Rpb24gPSAnY2hhaSdcbiAgICogICAgIGFzc2VydC5pc05vdE9iamVjdChzZWxlY3Rpb24sICd0ZWEgc2VsZWN0aW9uIGlzIG5vdCBhbiBvYmplY3QnKTtcbiAgICogICAgIGFzc2VydC5pc05vdE9iamVjdChudWxsLCAnbnVsbCBpcyBub3QgYW4gb2JqZWN0Jyk7XG4gICAqXG4gICAqIEBuYW1lIGlzTm90T2JqZWN0XG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc05vdE9iamVjdCA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2cpLnRvLm5vdC5iZS5hKCdvYmplY3QnKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc0FycmF5KHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgIGlzIGFuIGFycmF5LlxuICAgKlxuICAgKiAgICAgdmFyIG1lbnUgPSBbICdncmVlbicsICdjaGFpJywgJ29vbG9uZycgXTtcbiAgICogICAgIGFzc2VydC5pc0FycmF5KG1lbnUsICd3aGF0IGtpbmQgb2YgdGVhIGRvIHdlIHdhbnQ/Jyk7XG4gICAqXG4gICAqIEBuYW1lIGlzQXJyYXlcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzQXJyYXkgPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnKS50by5iZS5hbignYXJyYXknKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc05vdEFycmF5KHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgIGlzIF9ub3RfIGFuIGFycmF5LlxuICAgKlxuICAgKiAgICAgdmFyIG1lbnUgPSAnZ3JlZW58Y2hhaXxvb2xvbmcnO1xuICAgKiAgICAgYXNzZXJ0LmlzTm90QXJyYXkobWVudSwgJ3doYXQga2luZCBvZiB0ZWEgZG8gd2Ugd2FudD8nKTtcbiAgICpcbiAgICogQG5hbWUgaXNOb3RBcnJheVxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNOb3RBcnJheSA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2cpLnRvLm5vdC5iZS5hbignYXJyYXknKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc1N0cmluZyh2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBpcyBhIHN0cmluZy5cbiAgICpcbiAgICogICAgIHZhciB0ZWFPcmRlciA9ICdjaGFpJztcbiAgICogICAgIGFzc2VydC5pc1N0cmluZyh0ZWFPcmRlciwgJ29yZGVyIHBsYWNlZCcpO1xuICAgKlxuICAgKiBAbmFtZSBpc1N0cmluZ1xuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNTdHJpbmcgPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnKS50by5iZS5hKCdzdHJpbmcnKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc05vdFN0cmluZyh2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBpcyBfbm90XyBhIHN0cmluZy5cbiAgICpcbiAgICogICAgIHZhciB0ZWFPcmRlciA9IDQ7XG4gICAqICAgICBhc3NlcnQuaXNOb3RTdHJpbmcodGVhT3JkZXIsICdvcmRlciBwbGFjZWQnKTtcbiAgICpcbiAgICogQG5hbWUgaXNOb3RTdHJpbmdcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzTm90U3RyaW5nID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZykudG8ubm90LmJlLmEoJ3N0cmluZycpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzTnVtYmVyKHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgIGlzIGEgbnVtYmVyLlxuICAgKlxuICAgKiAgICAgdmFyIGN1cHMgPSAyO1xuICAgKiAgICAgYXNzZXJ0LmlzTnVtYmVyKGN1cHMsICdob3cgbWFueSBjdXBzJyk7XG4gICAqXG4gICAqIEBuYW1lIGlzTnVtYmVyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNOdW1iZXIgPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnKS50by5iZS5hKCdudW1iZXInKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc05vdE51bWJlcih2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBpcyBfbm90XyBhIG51bWJlci5cbiAgICpcbiAgICogICAgIHZhciBjdXBzID0gJzIgY3VwcyBwbGVhc2UnO1xuICAgKiAgICAgYXNzZXJ0LmlzTm90TnVtYmVyKGN1cHMsICdob3cgbWFueSBjdXBzJyk7XG4gICAqXG4gICAqIEBuYW1lIGlzTm90TnVtYmVyXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc05vdE51bWJlciA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2cpLnRvLm5vdC5iZS5hKCdudW1iZXInKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc0Jvb2xlYW4odmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAgaXMgYSBib29sZWFuLlxuICAgKlxuICAgKiAgICAgdmFyIHRlYVJlYWR5ID0gdHJ1ZVxuICAgKiAgICAgICAsIHRlYVNlcnZlZCA9IGZhbHNlO1xuICAgKlxuICAgKiAgICAgYXNzZXJ0LmlzQm9vbGVhbih0ZWFSZWFkeSwgJ2lzIHRoZSB0ZWEgcmVhZHknKTtcbiAgICogICAgIGFzc2VydC5pc0Jvb2xlYW4odGVhU2VydmVkLCAnaGFzIHRlYSBiZWVuIHNlcnZlZCcpO1xuICAgKlxuICAgKiBAbmFtZSBpc0Jvb2xlYW5cbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzQm9vbGVhbiA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2cpLnRvLmJlLmEoJ2Jvb2xlYW4nKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc05vdEJvb2xlYW4odmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAgaXMgX25vdF8gYSBib29sZWFuLlxuICAgKlxuICAgKiAgICAgdmFyIHRlYVJlYWR5ID0gJ3llcCdcbiAgICogICAgICAgLCB0ZWFTZXJ2ZWQgPSAnbm9wZSc7XG4gICAqXG4gICAqICAgICBhc3NlcnQuaXNOb3RCb29sZWFuKHRlYVJlYWR5LCAnaXMgdGhlIHRlYSByZWFkeScpO1xuICAgKiAgICAgYXNzZXJ0LmlzTm90Qm9vbGVhbih0ZWFTZXJ2ZWQsICdoYXMgdGVhIGJlZW4gc2VydmVkJyk7XG4gICAqXG4gICAqIEBuYW1lIGlzTm90Qm9vbGVhblxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNOb3RCb29sZWFuID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZykudG8ubm90LmJlLmEoJ2Jvb2xlYW4nKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC50eXBlT2YodmFsdWUsIG5hbWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAncyB0eXBlIGlzIGBuYW1lYCwgYXMgZGV0ZXJtaW5lZCBieVxuICAgKiBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AuXG4gICAqXG4gICAqICAgICBhc3NlcnQudHlwZU9mKHsgdGVhOiAnY2hhaScgfSwgJ29iamVjdCcsICd3ZSBoYXZlIGFuIG9iamVjdCcpO1xuICAgKiAgICAgYXNzZXJ0LnR5cGVPZihbJ2NoYWknLCAnamFzbWluZSddLCAnYXJyYXknLCAnd2UgaGF2ZSBhbiBhcnJheScpO1xuICAgKiAgICAgYXNzZXJ0LnR5cGVPZigndGVhJywgJ3N0cmluZycsICd3ZSBoYXZlIGEgc3RyaW5nJyk7XG4gICAqICAgICBhc3NlcnQudHlwZU9mKC90ZWEvLCAncmVnZXhwJywgJ3dlIGhhdmUgYSByZWd1bGFyIGV4cHJlc3Npb24nKTtcbiAgICogICAgIGFzc2VydC50eXBlT2YobnVsbCwgJ251bGwnLCAnd2UgaGF2ZSBhIG51bGwnKTtcbiAgICogICAgIGFzc2VydC50eXBlT2YodW5kZWZpbmVkLCAndW5kZWZpbmVkJywgJ3dlIGhhdmUgYW4gdW5kZWZpbmVkJyk7XG4gICAqXG4gICAqIEBuYW1lIHR5cGVPZlxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQudHlwZU9mID0gZnVuY3Rpb24gKHZhbCwgdHlwZSwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZykudG8uYmUuYSh0eXBlKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5ub3RUeXBlT2YodmFsdWUsIG5hbWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAncyB0eXBlIGlzIF9ub3RfIGBuYW1lYCwgYXMgZGV0ZXJtaW5lZCBieVxuICAgKiBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AuXG4gICAqXG4gICAqICAgICBhc3NlcnQubm90VHlwZU9mKCd0ZWEnLCAnbnVtYmVyJywgJ3N0cmluZ3MgYXJlIG5vdCBudW1iZXJzJyk7XG4gICAqXG4gICAqIEBuYW1lIG5vdFR5cGVPZlxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZW9mIG5hbWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm5vdFR5cGVPZiA9IGZ1bmN0aW9uICh2YWwsIHR5cGUsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2cpLnRvLm5vdC5iZS5hKHR5cGUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmluc3RhbmNlT2Yob2JqZWN0LCBjb25zdHJ1Y3RvciwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBpcyBhbiBpbnN0YW5jZSBvZiBgY29uc3RydWN0b3JgLlxuICAgKlxuICAgKiAgICAgdmFyIFRlYSA9IGZ1bmN0aW9uIChuYW1lKSB7IHRoaXMubmFtZSA9IG5hbWU7IH1cbiAgICogICAgICAgLCBjaGFpID0gbmV3IFRlYSgnY2hhaScpO1xuICAgKlxuICAgKiAgICAgYXNzZXJ0Lmluc3RhbmNlT2YoY2hhaSwgVGVhLCAnY2hhaSBpcyBhbiBpbnN0YW5jZSBvZiB0ZWEnKTtcbiAgICpcbiAgICogQG5hbWUgaW5zdGFuY2VPZlxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7Q29uc3RydWN0b3J9IGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pbnN0YW5jZU9mID0gZnVuY3Rpb24gKHZhbCwgdHlwZSwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZykudG8uYmUuaW5zdGFuY2VPZih0eXBlKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5ub3RJbnN0YW5jZU9mKG9iamVjdCwgY29uc3RydWN0b3IsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyBgdmFsdWVgIGlzIG5vdCBhbiBpbnN0YW5jZSBvZiBgY29uc3RydWN0b3JgLlxuICAgKlxuICAgKiAgICAgdmFyIFRlYSA9IGZ1bmN0aW9uIChuYW1lKSB7IHRoaXMubmFtZSA9IG5hbWU7IH1cbiAgICogICAgICAgLCBjaGFpID0gbmV3IFN0cmluZygnY2hhaScpO1xuICAgKlxuICAgKiAgICAgYXNzZXJ0Lm5vdEluc3RhbmNlT2YoY2hhaSwgVGVhLCAnY2hhaSBpcyBub3QgYW4gaW5zdGFuY2Ugb2YgdGVhJyk7XG4gICAqXG4gICAqIEBuYW1lIG5vdEluc3RhbmNlT2ZcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgKiBAcGFyYW0ge0NvbnN0cnVjdG9yfSBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQubm90SW5zdGFuY2VPZiA9IGZ1bmN0aW9uICh2YWwsIHR5cGUsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2cpLnRvLm5vdC5iZS5pbnN0YW5jZU9mKHR5cGUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmluY2x1ZGUoaGF5c3RhY2ssIG5lZWRsZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYGhheXN0YWNrYCBpbmNsdWRlcyBgbmVlZGxlYC4gV29ya3NcbiAgICogZm9yIHN0cmluZ3MgYW5kIGFycmF5cy5cbiAgICpcbiAgICogICAgIGFzc2VydC5pbmNsdWRlKCdmb29iYXInLCAnYmFyJywgJ2Zvb2JhciBjb250YWlucyBzdHJpbmcgXCJiYXJcIicpO1xuICAgKiAgICAgYXNzZXJ0LmluY2x1ZGUoWyAxLCAyLCAzIF0sIDMsICdhcnJheSBjb250YWlucyB2YWx1ZScpO1xuICAgKlxuICAgKiBAbmFtZSBpbmNsdWRlXG4gICAqIEBwYXJhbSB7QXJyYXl8U3RyaW5nfSBoYXlzdGFja1xuICAgKiBAcGFyYW0ge01peGVkfSBuZWVkbGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmluY2x1ZGUgPSBmdW5jdGlvbiAoZXhwLCBpbmMsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oZXhwLCBtc2csIGFzc2VydC5pbmNsdWRlKS5pbmNsdWRlKGluYyk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAubm90SW5jbHVkZShoYXlzdGFjaywgbmVlZGxlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgaGF5c3RhY2tgIGRvZXMgbm90IGluY2x1ZGUgYG5lZWRsZWAuIFdvcmtzXG4gICAqIGZvciBzdHJpbmdzIGFuZCBhcnJheXMuXG4gICAqaVxuICAgKiAgICAgYXNzZXJ0Lm5vdEluY2x1ZGUoJ2Zvb2JhcicsICdiYXonLCAnc3RyaW5nIG5vdCBpbmNsdWRlIHN1YnN0cmluZycpO1xuICAgKiAgICAgYXNzZXJ0Lm5vdEluY2x1ZGUoWyAxLCAyLCAzIF0sIDQsICdhcnJheSBub3QgaW5jbHVkZSBjb250YWluIHZhbHVlJyk7XG4gICAqXG4gICAqIEBuYW1lIG5vdEluY2x1ZGVcbiAgICogQHBhcmFtIHtBcnJheXxTdHJpbmd9IGhheXN0YWNrXG4gICAqIEBwYXJhbSB7TWl4ZWR9IG5lZWRsZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQubm90SW5jbHVkZSA9IGZ1bmN0aW9uIChleHAsIGluYywgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihleHAsIG1zZywgYXNzZXJ0Lm5vdEluY2x1ZGUpLm5vdC5pbmNsdWRlKGluYyk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAubWF0Y2godmFsdWUsIHJlZ2V4cCwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBtYXRjaGVzIHRoZSByZWd1bGFyIGV4cHJlc3Npb24gYHJlZ2V4cGAuXG4gICAqXG4gICAqICAgICBhc3NlcnQubWF0Y2goJ2Zvb2JhcicsIC9eZm9vLywgJ3JlZ2V4cCBtYXRjaGVzJyk7XG4gICAqXG4gICAqIEBuYW1lIG1hdGNoXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7UmVnRXhwfSByZWdleHBcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm1hdGNoID0gZnVuY3Rpb24gKGV4cCwgcmUsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oZXhwLCBtc2cpLnRvLm1hdGNoKHJlKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5ub3RNYXRjaCh2YWx1ZSwgcmVnZXhwLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgIGRvZXMgbm90IG1hdGNoIHRoZSByZWd1bGFyIGV4cHJlc3Npb24gYHJlZ2V4cGAuXG4gICAqXG4gICAqICAgICBhc3NlcnQubm90TWF0Y2goJ2Zvb2JhcicsIC9eZm9vLywgJ3JlZ2V4cCBkb2VzIG5vdCBtYXRjaCcpO1xuICAgKlxuICAgKiBAbmFtZSBub3RNYXRjaFxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1JlZ0V4cH0gcmVnZXhwXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5ub3RNYXRjaCA9IGZ1bmN0aW9uIChleHAsIHJlLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKGV4cCwgbXNnKS50by5ub3QubWF0Y2gocmUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLnByb3BlcnR5KG9iamVjdCwgcHJvcGVydHksIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGhhcyBhIHByb3BlcnR5IG5hbWVkIGJ5IGBwcm9wZXJ0eWAuXG4gICAqXG4gICAqICAgICBhc3NlcnQucHJvcGVydHkoeyB0ZWE6IHsgZ3JlZW46ICdtYXRjaGEnIH19LCAndGVhJyk7XG4gICAqXG4gICAqIEBuYW1lIHByb3BlcnR5XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5wcm9wZXJ0eSA9IGZ1bmN0aW9uIChvYmosIHByb3AsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2cpLnRvLmhhdmUucHJvcGVydHkocHJvcCk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAubm90UHJvcGVydHkob2JqZWN0LCBwcm9wZXJ0eSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYG9iamVjdGAgZG9lcyBfbm90XyBoYXZlIGEgcHJvcGVydHkgbmFtZWQgYnkgYHByb3BlcnR5YC5cbiAgICpcbiAgICogICAgIGFzc2VydC5ub3RQcm9wZXJ0eSh7IHRlYTogeyBncmVlbjogJ21hdGNoYScgfX0sICdjb2ZmZWUnKTtcbiAgICpcbiAgICogQG5hbWUgbm90UHJvcGVydHlcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHlcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm5vdFByb3BlcnR5ID0gZnVuY3Rpb24gKG9iaiwgcHJvcCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihvYmosIG1zZykudG8ubm90LmhhdmUucHJvcGVydHkocHJvcCk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuZGVlcFByb3BlcnR5KG9iamVjdCwgcHJvcGVydHksIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGhhcyBhIHByb3BlcnR5IG5hbWVkIGJ5IGBwcm9wZXJ0eWAsIHdoaWNoIGNhbiBiZSBhXG4gICAqIHN0cmluZyB1c2luZyBkb3QtIGFuZCBicmFja2V0LW5vdGF0aW9uIGZvciBkZWVwIHJlZmVyZW5jZS5cbiAgICpcbiAgICogICAgIGFzc2VydC5kZWVwUHJvcGVydHkoeyB0ZWE6IHsgZ3JlZW46ICdtYXRjaGEnIH19LCAndGVhLmdyZWVuJyk7XG4gICAqXG4gICAqIEBuYW1lIGRlZXBQcm9wZXJ0eVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuZGVlcFByb3BlcnR5ID0gZnVuY3Rpb24gKG9iaiwgcHJvcCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihvYmosIG1zZykudG8uaGF2ZS5kZWVwLnByb3BlcnR5KHByb3ApO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLm5vdERlZXBQcm9wZXJ0eShvYmplY3QsIHByb3BlcnR5LCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBkb2VzIF9ub3RfIGhhdmUgYSBwcm9wZXJ0eSBuYW1lZCBieSBgcHJvcGVydHlgLCB3aGljaFxuICAgKiBjYW4gYmUgYSBzdHJpbmcgdXNpbmcgZG90LSBhbmQgYnJhY2tldC1ub3RhdGlvbiBmb3IgZGVlcCByZWZlcmVuY2UuXG4gICAqXG4gICAqICAgICBhc3NlcnQubm90RGVlcFByb3BlcnR5KHsgdGVhOiB7IGdyZWVuOiAnbWF0Y2hhJyB9fSwgJ3RlYS5vb2xvbmcnKTtcbiAgICpcbiAgICogQG5hbWUgbm90RGVlcFByb3BlcnR5XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5ub3REZWVwUHJvcGVydHkgPSBmdW5jdGlvbiAob2JqLCBwcm9wLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnKS50by5ub3QuaGF2ZS5kZWVwLnByb3BlcnR5KHByb3ApO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLnByb3BlcnR5VmFsKG9iamVjdCwgcHJvcGVydHksIHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBoYXMgYSBwcm9wZXJ0eSBuYW1lZCBieSBgcHJvcGVydHlgIHdpdGggdmFsdWUgZ2l2ZW5cbiAgICogYnkgYHZhbHVlYC5cbiAgICpcbiAgICogICAgIGFzc2VydC5wcm9wZXJ0eVZhbCh7IHRlYTogJ2lzIGdvb2QnIH0sICd0ZWEnLCAnaXMgZ29vZCcpO1xuICAgKlxuICAgKiBAbmFtZSBwcm9wZXJ0eVZhbFxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eVxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQucHJvcGVydHlWYWwgPSBmdW5jdGlvbiAob2JqLCBwcm9wLCB2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2cpLnRvLmhhdmUucHJvcGVydHkocHJvcCwgdmFsKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5wcm9wZXJ0eU5vdFZhbChvYmplY3QsIHByb3BlcnR5LCB2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYG9iamVjdGAgaGFzIGEgcHJvcGVydHkgbmFtZWQgYnkgYHByb3BlcnR5YCwgYnV0IHdpdGggYSB2YWx1ZVxuICAgKiBkaWZmZXJlbnQgZnJvbSB0aGF0IGdpdmVuIGJ5IGB2YWx1ZWAuXG4gICAqXG4gICAqICAgICBhc3NlcnQucHJvcGVydHlOb3RWYWwoeyB0ZWE6ICdpcyBnb29kJyB9LCAndGVhJywgJ2lzIGJhZCcpO1xuICAgKlxuICAgKiBAbmFtZSBwcm9wZXJ0eU5vdFZhbFxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eVxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQucHJvcGVydHlOb3RWYWwgPSBmdW5jdGlvbiAob2JqLCBwcm9wLCB2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2cpLnRvLm5vdC5oYXZlLnByb3BlcnR5KHByb3AsIHZhbCk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuZGVlcFByb3BlcnR5VmFsKG9iamVjdCwgcHJvcGVydHksIHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBoYXMgYSBwcm9wZXJ0eSBuYW1lZCBieSBgcHJvcGVydHlgIHdpdGggdmFsdWUgZ2l2ZW5cbiAgICogYnkgYHZhbHVlYC4gYHByb3BlcnR5YCBjYW4gdXNlIGRvdC0gYW5kIGJyYWNrZXQtbm90YXRpb24gZm9yIGRlZXBcbiAgICogcmVmZXJlbmNlLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LmRlZXBQcm9wZXJ0eVZhbCh7IHRlYTogeyBncmVlbjogJ21hdGNoYScgfX0sICd0ZWEuZ3JlZW4nLCAnbWF0Y2hhJyk7XG4gICAqXG4gICAqIEBuYW1lIGRlZXBQcm9wZXJ0eVZhbFxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eVxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuZGVlcFByb3BlcnR5VmFsID0gZnVuY3Rpb24gKG9iaiwgcHJvcCwgdmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnKS50by5oYXZlLmRlZXAucHJvcGVydHkocHJvcCwgdmFsKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5kZWVwUHJvcGVydHlOb3RWYWwob2JqZWN0LCBwcm9wZXJ0eSwgdmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGhhcyBhIHByb3BlcnR5IG5hbWVkIGJ5IGBwcm9wZXJ0eWAsIGJ1dCB3aXRoIGEgdmFsdWVcbiAgICogZGlmZmVyZW50IGZyb20gdGhhdCBnaXZlbiBieSBgdmFsdWVgLiBgcHJvcGVydHlgIGNhbiB1c2UgZG90LSBhbmRcbiAgICogYnJhY2tldC1ub3RhdGlvbiBmb3IgZGVlcCByZWZlcmVuY2UuXG4gICAqXG4gICAqICAgICBhc3NlcnQuZGVlcFByb3BlcnR5Tm90VmFsKHsgdGVhOiB7IGdyZWVuOiAnbWF0Y2hhJyB9fSwgJ3RlYS5ncmVlbicsICdrb25hY2hhJyk7XG4gICAqXG4gICAqIEBuYW1lIGRlZXBQcm9wZXJ0eU5vdFZhbFxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eVxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuZGVlcFByb3BlcnR5Tm90VmFsID0gZnVuY3Rpb24gKG9iaiwgcHJvcCwgdmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnKS50by5ub3QuaGF2ZS5kZWVwLnByb3BlcnR5KHByb3AsIHZhbCk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAubGVuZ3RoT2Yob2JqZWN0LCBsZW5ndGgsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGhhcyBhIGBsZW5ndGhgIHByb3BlcnR5IHdpdGggdGhlIGV4cGVjdGVkIHZhbHVlLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lmxlbmd0aE9mKFsxLDIsM10sIDMsICdhcnJheSBoYXMgbGVuZ3RoIG9mIDMnKTtcbiAgICogICAgIGFzc2VydC5sZW5ndGhPZignZm9vYmFyJywgNSwgJ3N0cmluZyBoYXMgbGVuZ3RoIG9mIDYnKTtcbiAgICpcbiAgICogQG5hbWUgbGVuZ3RoT2ZcbiAgICogQHBhcmFtIHtNaXhlZH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBsZW5ndGhcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lmxlbmd0aE9mID0gZnVuY3Rpb24gKGV4cCwgbGVuLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKGV4cCwgbXNnKS50by5oYXZlLmxlbmd0aChsZW4pO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLnRocm93cyhmdW5jdGlvbiwgW2NvbnN0cnVjdG9yL3N0cmluZy9yZWdleHBdLCBbc3RyaW5nL3JlZ2V4cF0sIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBmdW5jdGlvbmAgd2lsbCB0aHJvdyBhbiBlcnJvciB0aGF0IGlzIGFuIGluc3RhbmNlIG9mXG4gICAqIGBjb25zdHJ1Y3RvcmAsIG9yIGFsdGVybmF0ZWx5IHRoYXQgaXQgd2lsbCB0aHJvdyBhbiBlcnJvciB3aXRoIG1lc3NhZ2VcbiAgICogbWF0Y2hpbmcgYHJlZ2V4cGAuXG4gICAqXG4gICAqICAgICBhc3NlcnQudGhyb3coZm4sICdmdW5jdGlvbiB0aHJvd3MgYSByZWZlcmVuY2UgZXJyb3InKTtcbiAgICogICAgIGFzc2VydC50aHJvdyhmbiwgL2Z1bmN0aW9uIHRocm93cyBhIHJlZmVyZW5jZSBlcnJvci8pO1xuICAgKiAgICAgYXNzZXJ0LnRocm93KGZuLCBSZWZlcmVuY2VFcnJvcik7XG4gICAqICAgICBhc3NlcnQudGhyb3coZm4sIFJlZmVyZW5jZUVycm9yLCAnZnVuY3Rpb24gdGhyb3dzIGEgcmVmZXJlbmNlIGVycm9yJyk7XG4gICAqICAgICBhc3NlcnQudGhyb3coZm4sIFJlZmVyZW5jZUVycm9yLCAvZnVuY3Rpb24gdGhyb3dzIGEgcmVmZXJlbmNlIGVycm9yLyk7XG4gICAqXG4gICAqIEBuYW1lIHRocm93c1xuICAgKiBAYWxpYXMgdGhyb3dcbiAgICogQGFsaWFzIFRocm93XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7RXJyb3JDb25zdHJ1Y3Rvcn0gY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtSZWdFeHB9IHJlZ2V4cFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0Vycm9yI0Vycm9yX3R5cGVzXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5UaHJvdyA9IGZ1bmN0aW9uIChmbiwgZXJydCwgZXJycywgbXNnKSB7XG4gICAgaWYgKCdzdHJpbmcnID09PSB0eXBlb2YgZXJydCB8fCBlcnJ0IGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICBlcnJzID0gZXJydDtcbiAgICAgIGVycnQgPSBudWxsO1xuICAgIH1cblxuICAgIHZhciBhc3NlcnRFcnIgPSBuZXcgQXNzZXJ0aW9uKGZuLCBtc2cpLnRvLlRocm93KGVycnQsIGVycnMpO1xuICAgIHJldHVybiBmbGFnKGFzc2VydEVyciwgJ29iamVjdCcpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmRvZXNOb3RUaHJvdyhmdW5jdGlvbiwgW2NvbnN0cnVjdG9yL3JlZ2V4cF0sIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBmdW5jdGlvbmAgd2lsbCBfbm90XyB0aHJvdyBhbiBlcnJvciB0aGF0IGlzIGFuIGluc3RhbmNlIG9mXG4gICAqIGBjb25zdHJ1Y3RvcmAsIG9yIGFsdGVybmF0ZWx5IHRoYXQgaXQgd2lsbCBub3QgdGhyb3cgYW4gZXJyb3Igd2l0aCBtZXNzYWdlXG4gICAqIG1hdGNoaW5nIGByZWdleHBgLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LmRvZXNOb3RUaHJvdyhmbiwgRXJyb3IsICdmdW5jdGlvbiBkb2VzIG5vdCB0aHJvdycpO1xuICAgKlxuICAgKiBAbmFtZSBkb2VzTm90VGhyb3dcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuY3Rpb25cbiAgICogQHBhcmFtIHtFcnJvckNvbnN0cnVjdG9yfSBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge1JlZ0V4cH0gcmVnZXhwXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRXJyb3IjRXJyb3JfdHlwZXNcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmRvZXNOb3RUaHJvdyA9IGZ1bmN0aW9uIChmbiwgdHlwZSwgbXNnKSB7XG4gICAgaWYgKCdzdHJpbmcnID09PSB0eXBlb2YgdHlwZSkge1xuICAgICAgbXNnID0gdHlwZTtcbiAgICAgIHR5cGUgPSBudWxsO1xuICAgIH1cblxuICAgIG5ldyBBc3NlcnRpb24oZm4sIG1zZykudG8ubm90LlRocm93KHR5cGUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLm9wZXJhdG9yKHZhbDEsIG9wZXJhdG9yLCB2YWwyLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIENvbXBhcmVzIHR3byB2YWx1ZXMgdXNpbmcgYG9wZXJhdG9yYC5cbiAgICpcbiAgICogICAgIGFzc2VydC5vcGVyYXRvcigxLCAnPCcsIDIsICdldmVyeXRoaW5nIGlzIG9rJyk7XG4gICAqICAgICBhc3NlcnQub3BlcmF0b3IoMSwgJz4nLCAyLCAndGhpcyB3aWxsIGZhaWwnKTtcbiAgICpcbiAgICogQG5hbWUgb3BlcmF0b3JcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsMVxuICAgKiBAcGFyYW0ge1N0cmluZ30gb3BlcmF0b3JcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsMlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQub3BlcmF0b3IgPSBmdW5jdGlvbiAodmFsLCBvcGVyYXRvciwgdmFsMiwgbXNnKSB7XG4gICAgaWYgKCF+Wyc9PScsICc9PT0nLCAnPicsICc+PScsICc8JywgJzw9JywgJyE9JywgJyE9PSddLmluZGV4T2Yob3BlcmF0b3IpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgb3BlcmF0b3IgXCInICsgb3BlcmF0b3IgKyAnXCInKTtcbiAgICB9XG4gICAgdmFyIHRlc3QgPSBuZXcgQXNzZXJ0aW9uKGV2YWwodmFsICsgb3BlcmF0b3IgKyB2YWwyKSwgbXNnKTtcbiAgICB0ZXN0LmFzc2VydChcbiAgICAgICAgdHJ1ZSA9PT0gZmxhZyh0ZXN0LCAnb2JqZWN0JylcbiAgICAgICwgJ2V4cGVjdGVkICcgKyB1dGlsLmluc3BlY3QodmFsKSArICcgdG8gYmUgJyArIG9wZXJhdG9yICsgJyAnICsgdXRpbC5pbnNwZWN0KHZhbDIpXG4gICAgICAsICdleHBlY3RlZCAnICsgdXRpbC5pbnNwZWN0KHZhbCkgKyAnIHRvIG5vdCBiZSAnICsgb3BlcmF0b3IgKyAnICcgKyB1dGlsLmluc3BlY3QodmFsMikgKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5jbG9zZVRvKGFjdHVhbCwgZXhwZWN0ZWQsIGRlbHRhLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIGVxdWFsIGBleHBlY3RlZGAsIHRvIHdpdGhpbiBhICsvLSBgZGVsdGFgIHJhbmdlLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LmNsb3NlVG8oMS41LCAxLCAwLjUsICdudW1iZXJzIGFyZSBjbG9zZScpO1xuICAgKlxuICAgKiBAbmFtZSBjbG9zZVRvXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBhY3R1YWxcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGV4cGVjdGVkXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkZWx0YVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuY2xvc2VUbyA9IGZ1bmN0aW9uIChhY3QsIGV4cCwgZGVsdGEsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oYWN0LCBtc2cpLnRvLmJlLmNsb3NlVG8oZXhwLCBkZWx0YSk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuc2FtZU1lbWJlcnMoc2V0MSwgc2V0MiwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHNldDFgIGFuZCBgc2V0MmAgaGF2ZSB0aGUgc2FtZSBtZW1iZXJzLlxuICAgKiBPcmRlciBpcyBub3QgdGFrZW4gaW50byBhY2NvdW50LlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LnNhbWVNZW1iZXJzKFsgMSwgMiwgMyBdLCBbIDIsIDEsIDMgXSwgJ3NhbWUgbWVtYmVycycpO1xuICAgKlxuICAgKiBAbmFtZSBzYW1lTWVtYmVyc1xuICAgKiBAcGFyYW0ge0FycmF5fSBzdXBlcnNldFxuICAgKiBAcGFyYW0ge0FycmF5fSBzdWJzZXRcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LnNhbWVNZW1iZXJzID0gZnVuY3Rpb24gKHNldDEsIHNldDIsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oc2V0MSwgbXNnKS50by5oYXZlLnNhbWUubWVtYmVycyhzZXQyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiAjIyMgLmluY2x1ZGVNZW1iZXJzKHN1cGVyc2V0LCBzdWJzZXQsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBzdWJzZXRgIGlzIGluY2x1ZGVkIGluIGBzdXBlcnNldGAuXG4gICAqIE9yZGVyIGlzIG5vdCB0YWtlbiBpbnRvIGFjY291bnQuXG4gICAqXG4gICAqICAgICBhc3NlcnQuaW5jbHVkZU1lbWJlcnMoWyAxLCAyLCAzIF0sIFsgMiwgMSBdLCAnaW5jbHVkZSBtZW1iZXJzJyk7XG4gICAqXG4gICAqIEBuYW1lIGluY2x1ZGVNZW1iZXJzXG4gICAqIEBwYXJhbSB7QXJyYXl9IHN1cGVyc2V0XG4gICAqIEBwYXJhbSB7QXJyYXl9IHN1YnNldFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaW5jbHVkZU1lbWJlcnMgPSBmdW5jdGlvbiAoc3VwZXJzZXQsIHN1YnNldCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihzdXBlcnNldCwgbXNnKS50by5pbmNsdWRlLm1lbWJlcnMoc3Vic2V0KTtcbiAgfVxuXG4gIC8qIVxuICAgKiBVbmRvY3VtZW50ZWQgLyB1bnRlc3RlZFxuICAgKi9cblxuICBhc3NlcnQuaWZFcnJvciA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2cpLnRvLm5vdC5iZS5vaztcbiAgfTtcblxuICAvKiFcbiAgICogQWxpYXNlcy5cbiAgICovXG5cbiAgKGZ1bmN0aW9uIGFsaWFzKG5hbWUsIGFzKXtcbiAgICBhc3NlcnRbYXNdID0gYXNzZXJ0W25hbWVdO1xuICAgIHJldHVybiBhbGlhcztcbiAgfSlcbiAgKCdUaHJvdycsICd0aHJvdycpXG4gICgnVGhyb3cnLCAndGhyb3dzJyk7XG59O1xuIiwiLyohXG4gKiBjaGFpXG4gKiBDb3B5cmlnaHQoYykgMjAxMS0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY2hhaSwgdXRpbCkge1xuICBjaGFpLmV4cGVjdCA9IGZ1bmN0aW9uICh2YWwsIG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gbmV3IGNoYWkuQXNzZXJ0aW9uKHZhbCwgbWVzc2FnZSk7XG4gIH07XG59O1xuXG4iLCIvKiFcbiAqIGNoYWlcbiAqIENvcHlyaWdodChjKSAyMDExLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjaGFpLCB1dGlsKSB7XG4gIHZhciBBc3NlcnRpb24gPSBjaGFpLkFzc2VydGlvbjtcblxuICBmdW5jdGlvbiBsb2FkU2hvdWxkICgpIHtcbiAgICAvLyBleHBsaWNpdGx5IGRlZmluZSB0aGlzIG1ldGhvZCBhcyBmdW5jdGlvbiBhcyB0byBoYXZlIGl0J3MgbmFtZSB0byBpbmNsdWRlIGFzIGBzc2ZpYFxuICAgIGZ1bmN0aW9uIHNob3VsZEdldHRlcigpIHtcbiAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgU3RyaW5nIHx8IHRoaXMgaW5zdGFuY2VvZiBOdW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBc3NlcnRpb24odGhpcy5jb25zdHJ1Y3Rvcih0aGlzKSwgbnVsbCwgc2hvdWxkR2V0dGVyKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcyBpbnN0YW5jZW9mIEJvb2xlYW4pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBc3NlcnRpb24odGhpcyA9PSB0cnVlLCBudWxsLCBzaG91bGRHZXR0ZXIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBBc3NlcnRpb24odGhpcywgbnVsbCwgc2hvdWxkR2V0dGVyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2hvdWxkU2V0dGVyKHZhbHVlKSB7XG4gICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2NoYWlqcy9jaGFpL2lzc3Vlcy84NjogdGhpcyBtYWtlc1xuICAgICAgLy8gYHdoYXRldmVyLnNob3VsZCA9IHNvbWVWYWx1ZWAgYWN0dWFsbHkgc2V0IGBzb21lVmFsdWVgLCB3aGljaCBpc1xuICAgICAgLy8gZXNwZWNpYWxseSB1c2VmdWwgZm9yIGBnbG9iYWwuc2hvdWxkID0gcmVxdWlyZSgnY2hhaScpLnNob3VsZCgpYC5cbiAgICAgIC8vXG4gICAgICAvLyBOb3RlIHRoYXQgd2UgaGF2ZSB0byB1c2UgW1tEZWZpbmVQcm9wZXJ0eV1dIGluc3RlYWQgb2YgW1tQdXRdXVxuICAgICAgLy8gc2luY2Ugb3RoZXJ3aXNlIHdlIHdvdWxkIHRyaWdnZXIgdGhpcyB2ZXJ5IHNldHRlciFcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnc2hvdWxkJywge1xuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBtb2RpZnkgT2JqZWN0LnByb3RvdHlwZSB0byBoYXZlIGBzaG91bGRgXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE9iamVjdC5wcm90b3R5cGUsICdzaG91bGQnLCB7XG4gICAgICBzZXQ6IHNob3VsZFNldHRlclxuICAgICAgLCBnZXQ6IHNob3VsZEdldHRlclxuICAgICAgLCBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcblxuICAgIHZhciBzaG91bGQgPSB7fTtcblxuICAgIHNob3VsZC5lcXVhbCA9IGZ1bmN0aW9uICh2YWwxLCB2YWwyLCBtc2cpIHtcbiAgICAgIG5ldyBBc3NlcnRpb24odmFsMSwgbXNnKS50by5lcXVhbCh2YWwyKTtcbiAgICB9O1xuXG4gICAgc2hvdWxkLlRocm93ID0gZnVuY3Rpb24gKGZuLCBlcnJ0LCBlcnJzLCBtc2cpIHtcbiAgICAgIG5ldyBBc3NlcnRpb24oZm4sIG1zZykudG8uVGhyb3coZXJydCwgZXJycyk7XG4gICAgfTtcblxuICAgIHNob3VsZC5leGlzdCA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZykudG8uZXhpc3Q7XG4gICAgfVxuXG4gICAgLy8gbmVnYXRpb25cbiAgICBzaG91bGQubm90ID0ge31cblxuICAgIHNob3VsZC5ub3QuZXF1YWwgPSBmdW5jdGlvbiAodmFsMSwgdmFsMiwgbXNnKSB7XG4gICAgICBuZXcgQXNzZXJ0aW9uKHZhbDEsIG1zZykudG8ubm90LmVxdWFsKHZhbDIpO1xuICAgIH07XG5cbiAgICBzaG91bGQubm90LlRocm93ID0gZnVuY3Rpb24gKGZuLCBlcnJ0LCBlcnJzLCBtc2cpIHtcbiAgICAgIG5ldyBBc3NlcnRpb24oZm4sIG1zZykudG8ubm90LlRocm93KGVycnQsIGVycnMpO1xuICAgIH07XG5cbiAgICBzaG91bGQubm90LmV4aXN0ID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnKS50by5ub3QuZXhpc3Q7XG4gICAgfVxuXG4gICAgc2hvdWxkWyd0aHJvdyddID0gc2hvdWxkWydUaHJvdyddO1xuICAgIHNob3VsZC5ub3RbJ3Rocm93J10gPSBzaG91bGQubm90WydUaHJvdyddO1xuXG4gICAgcmV0dXJuIHNob3VsZDtcbiAgfTtcblxuICBjaGFpLnNob3VsZCA9IGxvYWRTaG91bGQ7XG4gIGNoYWkuU2hvdWxkID0gbG9hZFNob3VsZDtcbn07XG4iLCIvKiFcbiAqIENoYWkgLSBhZGRDaGFpbmluZ01ldGhvZCB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyohXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzXG4gKi9cblxudmFyIHRyYW5zZmVyRmxhZ3MgPSByZXF1aXJlKCcuL3RyYW5zZmVyRmxhZ3MnKTtcbnZhciBmbGFnID0gcmVxdWlyZSgnLi9mbGFnJyk7XG52YXIgY29uZmlnID0gcmVxdWlyZSgnLi4vY29uZmlnJyk7XG5cbi8qIVxuICogTW9kdWxlIHZhcmlhYmxlc1xuICovXG5cbi8vIENoZWNrIHdoZXRoZXIgYF9fcHJvdG9fX2AgaXMgc3VwcG9ydGVkXG52YXIgaGFzUHJvdG9TdXBwb3J0ID0gJ19fcHJvdG9fXycgaW4gT2JqZWN0O1xuXG4vLyBXaXRob3V0IGBfX3Byb3RvX19gIHN1cHBvcnQsIHRoaXMgbW9kdWxlIHdpbGwgbmVlZCB0byBhZGQgcHJvcGVydGllcyB0byBhIGZ1bmN0aW9uLlxuLy8gSG93ZXZlciwgc29tZSBGdW5jdGlvbi5wcm90b3R5cGUgbWV0aG9kcyBjYW5ub3QgYmUgb3ZlcndyaXR0ZW4sXG4vLyBhbmQgdGhlcmUgc2VlbXMgbm8gZWFzeSBjcm9zcy1wbGF0Zm9ybSB3YXkgdG8gZGV0ZWN0IHRoZW0gKEBzZWUgY2hhaWpzL2NoYWkvaXNzdWVzLzY5KS5cbnZhciBleGNsdWRlTmFtZXMgPSAvXig/Omxlbmd0aHxuYW1lfGFyZ3VtZW50c3xjYWxsZXIpJC87XG5cbi8vIENhY2hlIGBGdW5jdGlvbmAgcHJvcGVydGllc1xudmFyIGNhbGwgID0gRnVuY3Rpb24ucHJvdG90eXBlLmNhbGwsXG4gICAgYXBwbHkgPSBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHk7XG5cbi8qKlxuICogIyMjIGFkZENoYWluYWJsZU1ldGhvZCAoY3R4LCBuYW1lLCBtZXRob2QsIGNoYWluaW5nQmVoYXZpb3IpXG4gKlxuICogQWRkcyBhIG1ldGhvZCB0byBhbiBvYmplY3QsIHN1Y2ggdGhhdCB0aGUgbWV0aG9kIGNhbiBhbHNvIGJlIGNoYWluZWQuXG4gKlxuICogICAgIHV0aWxzLmFkZENoYWluYWJsZU1ldGhvZChjaGFpLkFzc2VydGlvbi5wcm90b3R5cGUsICdmb28nLCBmdW5jdGlvbiAoc3RyKSB7XG4gKiAgICAgICB2YXIgb2JqID0gdXRpbHMuZmxhZyh0aGlzLCAnb2JqZWN0Jyk7XG4gKiAgICAgICBuZXcgY2hhaS5Bc3NlcnRpb24ob2JqKS50by5iZS5lcXVhbChzdHIpO1xuICogICAgIH0pO1xuICpcbiAqIENhbiBhbHNvIGJlIGFjY2Vzc2VkIGRpcmVjdGx5IGZyb20gYGNoYWkuQXNzZXJ0aW9uYC5cbiAqXG4gKiAgICAgY2hhaS5Bc3NlcnRpb24uYWRkQ2hhaW5hYmxlTWV0aG9kKCdmb28nLCBmbiwgY2hhaW5pbmdCZWhhdmlvcik7XG4gKlxuICogVGhlIHJlc3VsdCBjYW4gdGhlbiBiZSB1c2VkIGFzIGJvdGggYSBtZXRob2QgYXNzZXJ0aW9uLCBleGVjdXRpbmcgYm90aCBgbWV0aG9kYCBhbmRcbiAqIGBjaGFpbmluZ0JlaGF2aW9yYCwgb3IgYXMgYSBsYW5ndWFnZSBjaGFpbiwgd2hpY2ggb25seSBleGVjdXRlcyBgY2hhaW5pbmdCZWhhdmlvcmAuXG4gKlxuICogICAgIGV4cGVjdChmb29TdHIpLnRvLmJlLmZvbygnYmFyJyk7XG4gKiAgICAgZXhwZWN0KGZvb1N0cikudG8uYmUuZm9vLmVxdWFsKCdmb28nKTtcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY3R4IG9iamVjdCB0byB3aGljaCB0aGUgbWV0aG9kIGlzIGFkZGVkXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBvZiBtZXRob2QgdG8gYWRkXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBtZXRob2QgZnVuY3Rpb24gdG8gYmUgdXNlZCBmb3IgYG5hbWVgLCB3aGVuIGNhbGxlZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2hhaW5pbmdCZWhhdmlvciBmdW5jdGlvbiB0byBiZSBjYWxsZWQgZXZlcnkgdGltZSB0aGUgcHJvcGVydHkgaXMgYWNjZXNzZWRcbiAqIEBuYW1lIGFkZENoYWluYWJsZU1ldGhvZFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjdHgsIG5hbWUsIG1ldGhvZCwgY2hhaW5pbmdCZWhhdmlvcikge1xuICBpZiAodHlwZW9mIGNoYWluaW5nQmVoYXZpb3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICBjaGFpbmluZ0JlaGF2aW9yID0gZnVuY3Rpb24gKCkgeyB9O1xuICB9XG5cbiAgdmFyIGNoYWluYWJsZUJlaGF2aW9yID0ge1xuICAgICAgbWV0aG9kOiBtZXRob2RcbiAgICAsIGNoYWluaW5nQmVoYXZpb3I6IGNoYWluaW5nQmVoYXZpb3JcbiAgfTtcblxuICAvLyBzYXZlIHRoZSBtZXRob2RzIHNvIHdlIGNhbiBvdmVyd3JpdGUgdGhlbSBsYXRlciwgaWYgd2UgbmVlZCB0by5cbiAgaWYgKCFjdHguX19tZXRob2RzKSB7XG4gICAgY3R4Ll9fbWV0aG9kcyA9IHt9O1xuICB9XG4gIGN0eC5fX21ldGhvZHNbbmFtZV0gPSBjaGFpbmFibGVCZWhhdmlvcjtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3R4LCBuYW1lLFxuICAgIHsgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNoYWluYWJsZUJlaGF2aW9yLmNoYWluaW5nQmVoYXZpb3IuY2FsbCh0aGlzKTtcblxuICAgICAgICB2YXIgYXNzZXJ0ID0gZnVuY3Rpb24gYXNzZXJ0KCkge1xuICAgICAgICAgIHZhciBvbGRfc3NmaSA9IGZsYWcodGhpcywgJ3NzZmknKTtcbiAgICAgICAgICBpZiAob2xkX3NzZmkgJiYgY29uZmlnLmluY2x1ZGVTdGFjayA9PT0gZmFsc2UpXG4gICAgICAgICAgICBmbGFnKHRoaXMsICdzc2ZpJywgYXNzZXJ0KTtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gY2hhaW5hYmxlQmVoYXZpb3IubWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gdGhpcyA6IHJlc3VsdDtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBVc2UgYF9fcHJvdG9fX2AgaWYgYXZhaWxhYmxlXG4gICAgICAgIGlmIChoYXNQcm90b1N1cHBvcnQpIHtcbiAgICAgICAgICAvLyBJbmhlcml0IGFsbCBwcm9wZXJ0aWVzIGZyb20gdGhlIG9iamVjdCBieSByZXBsYWNpbmcgdGhlIGBGdW5jdGlvbmAgcHJvdG90eXBlXG4gICAgICAgICAgdmFyIHByb3RvdHlwZSA9IGFzc2VydC5fX3Byb3RvX18gPSBPYmplY3QuY3JlYXRlKHRoaXMpO1xuICAgICAgICAgIC8vIFJlc3RvcmUgdGhlIGBjYWxsYCBhbmQgYGFwcGx5YCBtZXRob2RzIGZyb20gYEZ1bmN0aW9uYFxuICAgICAgICAgIHByb3RvdHlwZS5jYWxsID0gY2FsbDtcbiAgICAgICAgICBwcm90b3R5cGUuYXBwbHkgPSBhcHBseTtcbiAgICAgICAgfVxuICAgICAgICAvLyBPdGhlcndpc2UsIHJlZGVmaW5lIGFsbCBwcm9wZXJ0aWVzIChzbG93ISlcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdmFyIGFzc2VydGVyTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhjdHgpO1xuICAgICAgICAgIGFzc2VydGVyTmFtZXMuZm9yRWFjaChmdW5jdGlvbiAoYXNzZXJ0ZXJOYW1lKSB7XG4gICAgICAgICAgICBpZiAoIWV4Y2x1ZGVOYW1lcy50ZXN0KGFzc2VydGVyTmFtZSkpIHtcbiAgICAgICAgICAgICAgdmFyIHBkID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjdHgsIGFzc2VydGVyTmFtZSk7XG4gICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhc3NlcnQsIGFzc2VydGVyTmFtZSwgcGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJhbnNmZXJGbGFncyh0aGlzLCBhc3NlcnQpO1xuICAgICAgICByZXR1cm4gYXNzZXJ0O1xuICAgICAgfVxuICAgICwgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufTtcbiIsIi8qIVxuICogQ2hhaSAtIGFkZE1ldGhvZCB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxudmFyIGNvbmZpZyA9IHJlcXVpcmUoJy4uL2NvbmZpZycpO1xuXG4vKipcbiAqICMjIyAuYWRkTWV0aG9kIChjdHgsIG5hbWUsIG1ldGhvZClcbiAqXG4gKiBBZGRzIGEgbWV0aG9kIHRvIHRoZSBwcm90b3R5cGUgb2YgYW4gb2JqZWN0LlxuICpcbiAqICAgICB1dGlscy5hZGRNZXRob2QoY2hhaS5Bc3NlcnRpb24ucHJvdG90eXBlLCAnZm9vJywgZnVuY3Rpb24gKHN0cikge1xuICogICAgICAgdmFyIG9iaiA9IHV0aWxzLmZsYWcodGhpcywgJ29iamVjdCcpO1xuICogICAgICAgbmV3IGNoYWkuQXNzZXJ0aW9uKG9iaikudG8uYmUuZXF1YWwoc3RyKTtcbiAqICAgICB9KTtcbiAqXG4gKiBDYW4gYWxzbyBiZSBhY2Nlc3NlZCBkaXJlY3RseSBmcm9tIGBjaGFpLkFzc2VydGlvbmAuXG4gKlxuICogICAgIGNoYWkuQXNzZXJ0aW9uLmFkZE1ldGhvZCgnZm9vJywgZm4pO1xuICpcbiAqIFRoZW4gY2FuIGJlIHVzZWQgYXMgYW55IG90aGVyIGFzc2VydGlvbi5cbiAqXG4gKiAgICAgZXhwZWN0KGZvb1N0cikudG8uYmUuZm9vKCdiYXInKTtcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY3R4IG9iamVjdCB0byB3aGljaCB0aGUgbWV0aG9kIGlzIGFkZGVkXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBvZiBtZXRob2QgdG8gYWRkXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBtZXRob2QgZnVuY3Rpb24gdG8gYmUgdXNlZCBmb3IgbmFtZVxuICogQG5hbWUgYWRkTWV0aG9kXG4gKiBAYXBpIHB1YmxpY1xuICovXG52YXIgZmxhZyA9IHJlcXVpcmUoJy4vZmxhZycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjdHgsIG5hbWUsIG1ldGhvZCkge1xuICBjdHhbbmFtZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9sZF9zc2ZpID0gZmxhZyh0aGlzLCAnc3NmaScpO1xuICAgIGlmIChvbGRfc3NmaSAmJiBjb25maWcuaW5jbHVkZVN0YWNrID09PSBmYWxzZSlcbiAgICAgIGZsYWcodGhpcywgJ3NzZmknLCBjdHhbbmFtZV0pO1xuICAgIHZhciByZXN1bHQgPSBtZXRob2QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICByZXR1cm4gcmVzdWx0ID09PSB1bmRlZmluZWQgPyB0aGlzIDogcmVzdWx0O1xuICB9O1xufTtcbiIsIi8qIVxuICogQ2hhaSAtIGFkZFByb3BlcnR5IHV0aWxpdHlcbiAqIENvcHlyaWdodChjKSAyMDEyLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4vKipcbiAqICMjIyBhZGRQcm9wZXJ0eSAoY3R4LCBuYW1lLCBnZXR0ZXIpXG4gKlxuICogQWRkcyBhIHByb3BlcnR5IHRvIHRoZSBwcm90b3R5cGUgb2YgYW4gb2JqZWN0LlxuICpcbiAqICAgICB1dGlscy5hZGRQcm9wZXJ0eShjaGFpLkFzc2VydGlvbi5wcm90b3R5cGUsICdmb28nLCBmdW5jdGlvbiAoKSB7XG4gKiAgICAgICB2YXIgb2JqID0gdXRpbHMuZmxhZyh0aGlzLCAnb2JqZWN0Jyk7XG4gKiAgICAgICBuZXcgY2hhaS5Bc3NlcnRpb24ob2JqKS50by5iZS5pbnN0YW5jZW9mKEZvbyk7XG4gKiAgICAgfSk7XG4gKlxuICogQ2FuIGFsc28gYmUgYWNjZXNzZWQgZGlyZWN0bHkgZnJvbSBgY2hhaS5Bc3NlcnRpb25gLlxuICpcbiAqICAgICBjaGFpLkFzc2VydGlvbi5hZGRQcm9wZXJ0eSgnZm9vJywgZm4pO1xuICpcbiAqIFRoZW4gY2FuIGJlIHVzZWQgYXMgYW55IG90aGVyIGFzc2VydGlvbi5cbiAqXG4gKiAgICAgZXhwZWN0KG15Rm9vKS50by5iZS5mb287XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGN0eCBvYmplY3QgdG8gd2hpY2ggdGhlIHByb3BlcnR5IGlzIGFkZGVkXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBvZiBwcm9wZXJ0eSB0byBhZGRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGdldHRlciBmdW5jdGlvbiB0byBiZSB1c2VkIGZvciBuYW1lXG4gKiBAbmFtZSBhZGRQcm9wZXJ0eVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjdHgsIG5hbWUsIGdldHRlcikge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3R4LCBuYW1lLFxuICAgIHsgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBnZXR0ZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gdGhpcyA6IHJlc3VsdDtcbiAgICAgIH1cbiAgICAsIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn07XG4iLCIvKiFcbiAqIENoYWkgLSBmbGFnIHV0aWxpdHlcbiAqIENvcHlyaWdodChjKSAyMDEyLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4vKipcbiAqICMjIyBmbGFnKG9iamVjdCAsa2V5LCBbdmFsdWVdKVxuICpcbiAqIEdldCBvciBzZXQgYSBmbGFnIHZhbHVlIG9uIGFuIG9iamVjdC4gSWYgYVxuICogdmFsdWUgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSBzZXQsIGVsc2UgaXQgd2lsbFxuICogcmV0dXJuIHRoZSBjdXJyZW50bHkgc2V0IHZhbHVlIG9yIGB1bmRlZmluZWRgIGlmXG4gKiB0aGUgdmFsdWUgaXMgbm90IHNldC5cbiAqXG4gKiAgICAgdXRpbHMuZmxhZyh0aGlzLCAnZm9vJywgJ2JhcicpOyAvLyBzZXR0ZXJcbiAqICAgICB1dGlscy5mbGFnKHRoaXMsICdmb28nKTsgLy8gZ2V0dGVyLCByZXR1cm5zIGBiYXJgXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCAoY29uc3RydWN0ZWQgQXNzZXJ0aW9uXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKiBAcGFyYW0ge01peGVkfSB2YWx1ZSAob3B0aW9uYWwpXG4gKiBAbmFtZSBmbGFnXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmosIGtleSwgdmFsdWUpIHtcbiAgdmFyIGZsYWdzID0gb2JqLl9fZmxhZ3MgfHwgKG9iai5fX2ZsYWdzID0gT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgZmxhZ3Nba2V5XSA9IHZhbHVlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmbGFnc1trZXldO1xuICB9XG59O1xuIiwiLyohXG4gKiBDaGFpIC0gZ2V0QWN0dWFsIHV0aWxpdHlcbiAqIENvcHlyaWdodChjKSAyMDEyLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4vKipcbiAqICMgZ2V0QWN0dWFsKG9iamVjdCwgW2FjdHVhbF0pXG4gKlxuICogUmV0dXJucyB0aGUgYGFjdHVhbGAgdmFsdWUgZm9yIGFuIEFzc2VydGlvblxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgKGNvbnN0cnVjdGVkIEFzc2VydGlvbilcbiAqIEBwYXJhbSB7QXJndW1lbnRzfSBjaGFpLkFzc2VydGlvbi5wcm90b3R5cGUuYXNzZXJ0IGFyZ3VtZW50c1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iaiwgYXJncykge1xuICByZXR1cm4gYXJncy5sZW5ndGggPiA0ID8gYXJnc1s0XSA6IG9iai5fb2JqO1xufTtcbiIsIi8qIVxuICogQ2hhaSAtIGdldEVudW1lcmFibGVQcm9wZXJ0aWVzIHV0aWxpdHlcbiAqIENvcHlyaWdodChjKSAyMDEyLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4vKipcbiAqICMjIyAuZ2V0RW51bWVyYWJsZVByb3BlcnRpZXMob2JqZWN0KVxuICpcbiAqIFRoaXMgYWxsb3dzIHRoZSByZXRyaWV2YWwgb2YgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBhbiBvYmplY3QsXG4gKiBpbmhlcml0ZWQgb3Igbm90LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqIEBuYW1lIGdldEVudW1lcmFibGVQcm9wZXJ0aWVzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0RW51bWVyYWJsZVByb3BlcnRpZXMob2JqZWN0KSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yICh2YXIgbmFtZSBpbiBvYmplY3QpIHtcbiAgICByZXN1bHQucHVzaChuYW1lKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcbiIsIi8qIVxuICogQ2hhaSAtIG1lc3NhZ2UgY29tcG9zaXRpb24gdXRpbGl0eVxuICogQ29weXJpZ2h0KGMpIDIwMTItMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qIVxuICogTW9kdWxlIGRlcGVuZGFuY2llc1xuICovXG5cbnZhciBmbGFnID0gcmVxdWlyZSgnLi9mbGFnJylcbiAgLCBnZXRBY3R1YWwgPSByZXF1aXJlKCcuL2dldEFjdHVhbCcpXG4gICwgaW5zcGVjdCA9IHJlcXVpcmUoJy4vaW5zcGVjdCcpXG4gICwgb2JqRGlzcGxheSA9IHJlcXVpcmUoJy4vb2JqRGlzcGxheScpO1xuXG4vKipcbiAqICMjIyAuZ2V0TWVzc2FnZShvYmplY3QsIG1lc3NhZ2UsIG5lZ2F0ZU1lc3NhZ2UpXG4gKlxuICogQ29uc3RydWN0IHRoZSBlcnJvciBtZXNzYWdlIGJhc2VkIG9uIGZsYWdzXG4gKiBhbmQgdGVtcGxhdGUgdGFncy4gVGVtcGxhdGUgdGFncyB3aWxsIHJldHVyblxuICogYSBzdHJpbmdpZmllZCBpbnNwZWN0aW9uIG9mIHRoZSBvYmplY3QgcmVmZXJlbmNlZC5cbiAqXG4gKiBNZXNzYWdlIHRlbXBsYXRlIHRhZ3M6XG4gKiAtIGAje3RoaXN9YCBjdXJyZW50IGFzc2VydGVkIG9iamVjdFxuICogLSBgI3thY3R9YCBhY3R1YWwgdmFsdWVcbiAqIC0gYCN7ZXhwfWAgZXhwZWN0ZWQgdmFsdWVcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IChjb25zdHJ1Y3RlZCBBc3NlcnRpb24pXG4gKiBAcGFyYW0ge0FyZ3VtZW50c30gY2hhaS5Bc3NlcnRpb24ucHJvdG90eXBlLmFzc2VydCBhcmd1bWVudHNcbiAqIEBuYW1lIGdldE1lc3NhZ2VcbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqLCBhcmdzKSB7XG4gIHZhciBuZWdhdGUgPSBmbGFnKG9iaiwgJ25lZ2F0ZScpXG4gICAgLCB2YWwgPSBmbGFnKG9iaiwgJ29iamVjdCcpXG4gICAgLCBleHBlY3RlZCA9IGFyZ3NbM11cbiAgICAsIGFjdHVhbCA9IGdldEFjdHVhbChvYmosIGFyZ3MpXG4gICAgLCBtc2cgPSBuZWdhdGUgPyBhcmdzWzJdIDogYXJnc1sxXVxuICAgICwgZmxhZ01zZyA9IGZsYWcob2JqLCAnbWVzc2FnZScpO1xuXG4gIG1zZyA9IG1zZyB8fCAnJztcbiAgbXNnID0gbXNnXG4gICAgLnJlcGxhY2UoLyN7dGhpc30vZywgb2JqRGlzcGxheSh2YWwpKVxuICAgIC5yZXBsYWNlKC8je2FjdH0vZywgb2JqRGlzcGxheShhY3R1YWwpKVxuICAgIC5yZXBsYWNlKC8je2V4cH0vZywgb2JqRGlzcGxheShleHBlY3RlZCkpO1xuXG4gIHJldHVybiBmbGFnTXNnID8gZmxhZ01zZyArICc6ICcgKyBtc2cgOiBtc2c7XG59O1xuIiwiLyohXG4gKiBDaGFpIC0gZ2V0TmFtZSB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyoqXG4gKiAjIGdldE5hbWUoZnVuYylcbiAqXG4gKiBHZXRzIHRoZSBuYW1lIG9mIGEgZnVuY3Rpb24sIGluIGEgY3Jvc3MtYnJvd3NlciB3YXkuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gYSBmdW5jdGlvbiAodXN1YWxseSBhIGNvbnN0cnVjdG9yKVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGZ1bmMpIHtcbiAgaWYgKGZ1bmMubmFtZSkgcmV0dXJuIGZ1bmMubmFtZTtcblxuICB2YXIgbWF0Y2ggPSAvXlxccz9mdW5jdGlvbiAoW14oXSopXFwoLy5leGVjKGZ1bmMpO1xuICByZXR1cm4gbWF0Y2ggJiYgbWF0Y2hbMV0gPyBtYXRjaFsxXSA6IFwiXCI7XG59O1xuIiwiLyohXG4gKiBDaGFpIC0gZ2V0UGF0aFZhbHVlIHV0aWxpdHlcbiAqIENvcHlyaWdodChjKSAyMDEyLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9sb2dpY2FscGFyYWRveC9maWx0clxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyoqXG4gKiAjIyMgLmdldFBhdGhWYWx1ZShwYXRoLCBvYmplY3QpXG4gKlxuICogVGhpcyBhbGxvd3MgdGhlIHJldHJpZXZhbCBvZiB2YWx1ZXMgaW4gYW5cbiAqIG9iamVjdCBnaXZlbiBhIHN0cmluZyBwYXRoLlxuICpcbiAqICAgICB2YXIgb2JqID0ge1xuICogICAgICAgICBwcm9wMToge1xuICogICAgICAgICAgICAgYXJyOiBbJ2EnLCAnYicsICdjJ11cbiAqICAgICAgICAgICAsIHN0cjogJ0hlbGxvJ1xuICogICAgICAgICB9XG4gKiAgICAgICAsIHByb3AyOiB7XG4gKiAgICAgICAgICAgICBhcnI6IFsgeyBuZXN0ZWQ6ICdVbml2ZXJzZScgfSBdXG4gKiAgICAgICAgICAgLCBzdHI6ICdIZWxsbyBhZ2FpbiEnXG4gKiAgICAgICAgIH1cbiAqICAgICB9XG4gKlxuICogVGhlIGZvbGxvd2luZyB3b3VsZCBiZSB0aGUgcmVzdWx0cy5cbiAqXG4gKiAgICAgZ2V0UGF0aFZhbHVlKCdwcm9wMS5zdHInLCBvYmopOyAvLyBIZWxsb1xuICogICAgIGdldFBhdGhWYWx1ZSgncHJvcDEuYXR0WzJdJywgb2JqKTsgLy8gYlxuICogICAgIGdldFBhdGhWYWx1ZSgncHJvcDIuYXJyWzBdLm5lc3RlZCcsIG9iaik7IC8vIFVuaXZlcnNlXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm5zIHtPYmplY3R9IHZhbHVlIG9yIGB1bmRlZmluZWRgXG4gKiBAbmFtZSBnZXRQYXRoVmFsdWVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxudmFyIGdldFBhdGhWYWx1ZSA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHBhdGgsIG9iaikge1xuICB2YXIgcGFyc2VkID0gcGFyc2VQYXRoKHBhdGgpO1xuICByZXR1cm4gX2dldFBhdGhWYWx1ZShwYXJzZWQsIG9iaik7XG59O1xuXG4vKiFcbiAqICMjIHBhcnNlUGF0aChwYXRoKVxuICpcbiAqIEhlbHBlciBmdW5jdGlvbiB1c2VkIHRvIHBhcnNlIHN0cmluZyBvYmplY3RcbiAqIHBhdGhzLiBVc2UgaW4gY29uanVuY3Rpb24gd2l0aCBgX2dldFBhdGhWYWx1ZWAuXG4gKlxuICogICAgICB2YXIgcGFyc2VkID0gcGFyc2VQYXRoKCdteW9iamVjdC5wcm9wZXJ0eS5zdWJwcm9wJyk7XG4gKlxuICogIyMjIFBhdGhzOlxuICpcbiAqICogQ2FuIGJlIGFzIG5lYXIgaW5maW5pdGVseSBkZWVwIGFuZCBuZXN0ZWRcbiAqICogQXJyYXlzIGFyZSBhbHNvIHZhbGlkIHVzaW5nIHRoZSBmb3JtYWwgYG15b2JqZWN0LmRvY3VtZW50WzNdLnByb3BlcnR5YC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICogQHJldHVybnMge09iamVjdH0gcGFyc2VkXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZVBhdGggKHBhdGgpIHtcbiAgdmFyIHN0ciA9IHBhdGgucmVwbGFjZSgvXFxbL2csICcuWycpXG4gICAgLCBwYXJ0cyA9IHN0ci5tYXRjaCgvKFxcXFxcXC58W14uXSs/KSsvZyk7XG4gIHJldHVybiBwYXJ0cy5tYXAoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdmFyIHJlID0gL1xcWyhcXGQrKVxcXSQvXG4gICAgICAsIG1BcnIgPSByZS5leGVjKHZhbHVlKVxuICAgIGlmIChtQXJyKSByZXR1cm4geyBpOiBwYXJzZUZsb2F0KG1BcnJbMV0pIH07XG4gICAgZWxzZSByZXR1cm4geyBwOiB2YWx1ZSB9O1xuICB9KTtcbn07XG5cbi8qIVxuICogIyMgX2dldFBhdGhWYWx1ZShwYXJzZWQsIG9iailcbiAqXG4gKiBIZWxwZXIgY29tcGFuaW9uIGZ1bmN0aW9uIGZvciBgLnBhcnNlUGF0aGAgdGhhdCByZXR1cm5zXG4gKiB0aGUgdmFsdWUgbG9jYXRlZCBhdCB0aGUgcGFyc2VkIGFkZHJlc3MuXG4gKlxuICogICAgICB2YXIgdmFsdWUgPSBnZXRQYXRoVmFsdWUocGFyc2VkLCBvYmopO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXJzZWQgZGVmaW5pdGlvbiBmcm9tIGBwYXJzZVBhdGhgLlxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCB0byBzZWFyY2ggYWdhaW5zdFxuICogQHJldHVybnMge09iamVjdHxVbmRlZmluZWR9IHZhbHVlXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBfZ2V0UGF0aFZhbHVlIChwYXJzZWQsIG9iaikge1xuICB2YXIgdG1wID0gb2JqXG4gICAgLCByZXM7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gcGFyc2VkLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHZhciBwYXJ0ID0gcGFyc2VkW2ldO1xuICAgIGlmICh0bXApIHtcbiAgICAgIGlmICgndW5kZWZpbmVkJyAhPT0gdHlwZW9mIHBhcnQucClcbiAgICAgICAgdG1wID0gdG1wW3BhcnQucF07XG4gICAgICBlbHNlIGlmICgndW5kZWZpbmVkJyAhPT0gdHlwZW9mIHBhcnQuaSlcbiAgICAgICAgdG1wID0gdG1wW3BhcnQuaV07XG4gICAgICBpZiAoaSA9PSAobCAtIDEpKSByZXMgPSB0bXA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcztcbn07XG4iLCIvKiFcbiAqIENoYWkgLSBnZXRQcm9wZXJ0aWVzIHV0aWxpdHlcbiAqIENvcHlyaWdodChjKSAyMDEyLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4vKipcbiAqICMjIyAuZ2V0UHJvcGVydGllcyhvYmplY3QpXG4gKlxuICogVGhpcyBhbGxvd3MgdGhlIHJldHJpZXZhbCBvZiBwcm9wZXJ0eSBuYW1lcyBvZiBhbiBvYmplY3QsIGVudW1lcmFibGUgb3Igbm90LFxuICogaW5oZXJpdGVkIG9yIG5vdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKiBAbmFtZSBnZXRQcm9wZXJ0aWVzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0UHJvcGVydGllcyhvYmplY3QpIHtcbiAgdmFyIHJlc3VsdCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHN1YmplY3QpO1xuXG4gIGZ1bmN0aW9uIGFkZFByb3BlcnR5KHByb3BlcnR5KSB7XG4gICAgaWYgKHJlc3VsdC5pbmRleE9mKHByb3BlcnR5KSA9PT0gLTEpIHtcbiAgICAgIHJlc3VsdC5wdXNoKHByb3BlcnR5KTtcbiAgICB9XG4gIH1cblxuICB2YXIgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yoc3ViamVjdCk7XG4gIHdoaWxlIChwcm90byAhPT0gbnVsbCkge1xuICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHByb3RvKS5mb3JFYWNoKGFkZFByb3BlcnR5KTtcbiAgICBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihwcm90byk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcbiIsIi8qIVxuICogY2hhaVxuICogQ29weXJpZ2h0KGMpIDIwMTEgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4vKiFcbiAqIE1haW4gZXhwb3J0c1xuICovXG5cbnZhciBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLyohXG4gKiB0ZXN0IHV0aWxpdHlcbiAqL1xuXG5leHBvcnRzLnRlc3QgPSByZXF1aXJlKCcuL3Rlc3QnKTtcblxuLyohXG4gKiB0eXBlIHV0aWxpdHlcbiAqL1xuXG5leHBvcnRzLnR5cGUgPSByZXF1aXJlKCcuL3R5cGUnKTtcblxuLyohXG4gKiBtZXNzYWdlIHV0aWxpdHlcbiAqL1xuXG5leHBvcnRzLmdldE1lc3NhZ2UgPSByZXF1aXJlKCcuL2dldE1lc3NhZ2UnKTtcblxuLyohXG4gKiBhY3R1YWwgdXRpbGl0eVxuICovXG5cbmV4cG9ydHMuZ2V0QWN0dWFsID0gcmVxdWlyZSgnLi9nZXRBY3R1YWwnKTtcblxuLyohXG4gKiBJbnNwZWN0IHV0aWxcbiAqL1xuXG5leHBvcnRzLmluc3BlY3QgPSByZXF1aXJlKCcuL2luc3BlY3QnKTtcblxuLyohXG4gKiBPYmplY3QgRGlzcGxheSB1dGlsXG4gKi9cblxuZXhwb3J0cy5vYmpEaXNwbGF5ID0gcmVxdWlyZSgnLi9vYmpEaXNwbGF5Jyk7XG5cbi8qIVxuICogRmxhZyB1dGlsaXR5XG4gKi9cblxuZXhwb3J0cy5mbGFnID0gcmVxdWlyZSgnLi9mbGFnJyk7XG5cbi8qIVxuICogRmxhZyB0cmFuc2ZlcnJpbmcgdXRpbGl0eVxuICovXG5cbmV4cG9ydHMudHJhbnNmZXJGbGFncyA9IHJlcXVpcmUoJy4vdHJhbnNmZXJGbGFncycpO1xuXG4vKiFcbiAqIERlZXAgZXF1YWwgdXRpbGl0eVxuICovXG5cbmV4cG9ydHMuZXFsID0gcmVxdWlyZSgnZGVlcC1lcWwnKTtcblxuLyohXG4gKiBEZWVwIHBhdGggdmFsdWVcbiAqL1xuXG5leHBvcnRzLmdldFBhdGhWYWx1ZSA9IHJlcXVpcmUoJy4vZ2V0UGF0aFZhbHVlJyk7XG5cbi8qIVxuICogRnVuY3Rpb24gbmFtZVxuICovXG5cbmV4cG9ydHMuZ2V0TmFtZSA9IHJlcXVpcmUoJy4vZ2V0TmFtZScpO1xuXG4vKiFcbiAqIGFkZCBQcm9wZXJ0eVxuICovXG5cbmV4cG9ydHMuYWRkUHJvcGVydHkgPSByZXF1aXJlKCcuL2FkZFByb3BlcnR5Jyk7XG5cbi8qIVxuICogYWRkIE1ldGhvZFxuICovXG5cbmV4cG9ydHMuYWRkTWV0aG9kID0gcmVxdWlyZSgnLi9hZGRNZXRob2QnKTtcblxuLyohXG4gKiBvdmVyd3JpdGUgUHJvcGVydHlcbiAqL1xuXG5leHBvcnRzLm92ZXJ3cml0ZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9vdmVyd3JpdGVQcm9wZXJ0eScpO1xuXG4vKiFcbiAqIG92ZXJ3cml0ZSBNZXRob2RcbiAqL1xuXG5leHBvcnRzLm92ZXJ3cml0ZU1ldGhvZCA9IHJlcXVpcmUoJy4vb3ZlcndyaXRlTWV0aG9kJyk7XG5cbi8qIVxuICogQWRkIGEgY2hhaW5hYmxlIG1ldGhvZFxuICovXG5cbmV4cG9ydHMuYWRkQ2hhaW5hYmxlTWV0aG9kID0gcmVxdWlyZSgnLi9hZGRDaGFpbmFibGVNZXRob2QnKTtcblxuLyohXG4gKiBPdmVyd3JpdGUgY2hhaW5hYmxlIG1ldGhvZFxuICovXG5cbmV4cG9ydHMub3ZlcndyaXRlQ2hhaW5hYmxlTWV0aG9kID0gcmVxdWlyZSgnLi9vdmVyd3JpdGVDaGFpbmFibGVNZXRob2QnKTtcblxuIiwiLy8gVGhpcyBpcyAoYWxtb3N0KSBkaXJlY3RseSBmcm9tIE5vZGUuanMgdXRpbHNcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qb3llbnQvbm9kZS9ibG9iL2Y4YzMzNWQwY2FmNDdmMTZkMzE0MTNmODlhYTI4ZWRhMzg3OGUzYWEvbGliL3V0aWwuanNcblxudmFyIGdldE5hbWUgPSByZXF1aXJlKCcuL2dldE5hbWUnKTtcbnZhciBnZXRQcm9wZXJ0aWVzID0gcmVxdWlyZSgnLi9nZXRQcm9wZXJ0aWVzJyk7XG52YXIgZ2V0RW51bWVyYWJsZVByb3BlcnRpZXMgPSByZXF1aXJlKCcuL2dldEVudW1lcmFibGVQcm9wZXJ0aWVzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gaW5zcGVjdDtcblxuLyoqXG4gKiBFY2hvcyB0aGUgdmFsdWUgb2YgYSB2YWx1ZS4gVHJ5cyB0byBwcmludCB0aGUgdmFsdWUgb3V0XG4gKiBpbiB0aGUgYmVzdCB3YXkgcG9zc2libGUgZ2l2ZW4gdGhlIGRpZmZlcmVudCB0eXBlcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gcHJpbnQgb3V0LlxuICogQHBhcmFtIHtCb29sZWFufSBzaG93SGlkZGVuIEZsYWcgdGhhdCBzaG93cyBoaWRkZW4gKG5vdCBlbnVtZXJhYmxlKVxuICogICAgcHJvcGVydGllcyBvZiBvYmplY3RzLlxuICogQHBhcmFtIHtOdW1iZXJ9IGRlcHRoIERlcHRoIGluIHdoaWNoIHRvIGRlc2NlbmQgaW4gb2JqZWN0LiBEZWZhdWx0IGlzIDIuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGNvbG9ycyBGbGFnIHRvIHR1cm4gb24gQU5TSSBlc2NhcGUgY29kZXMgdG8gY29sb3IgdGhlXG4gKiAgICBvdXRwdXQuIERlZmF1bHQgaXMgZmFsc2UgKG5vIGNvbG9yaW5nKS5cbiAqL1xuZnVuY3Rpb24gaW5zcGVjdChvYmosIHNob3dIaWRkZW4sIGRlcHRoLCBjb2xvcnMpIHtcbiAgdmFyIGN0eCA9IHtcbiAgICBzaG93SGlkZGVuOiBzaG93SGlkZGVuLFxuICAgIHNlZW46IFtdLFxuICAgIHN0eWxpemU6IGZ1bmN0aW9uIChzdHIpIHsgcmV0dXJuIHN0cjsgfVxuICB9O1xuICByZXR1cm4gZm9ybWF0VmFsdWUoY3R4LCBvYmosICh0eXBlb2YgZGVwdGggPT09ICd1bmRlZmluZWQnID8gMiA6IGRlcHRoKSk7XG59XG5cbi8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tLzEwNDQxMjgvXG52YXIgZ2V0T3V0ZXJIVE1MID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICBpZiAoJ291dGVySFRNTCcgaW4gZWxlbWVudCkgcmV0dXJuIGVsZW1lbnQub3V0ZXJIVE1MO1xuICB2YXIgbnMgPSBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIjtcbiAgdmFyIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhucywgJ18nKTtcbiAgdmFyIGVsZW1Qcm90byA9ICh3aW5kb3cuSFRNTEVsZW1lbnQgfHwgd2luZG93LkVsZW1lbnQpLnByb3RvdHlwZTtcbiAgdmFyIHhtbFNlcmlhbGl6ZXIgPSBuZXcgWE1MU2VyaWFsaXplcigpO1xuICB2YXIgaHRtbDtcbiAgaWYgKGRvY3VtZW50LnhtbFZlcnNpb24pIHtcbiAgICByZXR1cm4geG1sU2VyaWFsaXplci5zZXJpYWxpemVUb1N0cmluZyhlbGVtZW50KTtcbiAgfSBlbHNlIHtcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoZWxlbWVudC5jbG9uZU5vZGUoZmFsc2UpKTtcbiAgICBodG1sID0gY29udGFpbmVyLmlubmVySFRNTC5yZXBsYWNlKCc+PCcsICc+JyArIGVsZW1lbnQuaW5uZXJIVE1MICsgJzwnKTtcbiAgICBjb250YWluZXIuaW5uZXJIVE1MID0gJyc7XG4gICAgcmV0dXJuIGh0bWw7XG4gIH1cbn07XG5cbi8vIFJldHVybnMgdHJ1ZSBpZiBvYmplY3QgaXMgYSBET00gZWxlbWVudC5cbnZhciBpc0RPTUVsZW1lbnQgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gIGlmICh0eXBlb2YgSFRNTEVsZW1lbnQgPT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG9iamVjdCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBvYmplY3QgJiZcbiAgICAgIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmXG4gICAgICBvYmplY3Qubm9kZVR5cGUgPT09IDEgJiZcbiAgICAgIHR5cGVvZiBvYmplY3Qubm9kZU5hbWUgPT09ICdzdHJpbmcnO1xuICB9XG59O1xuXG5mdW5jdGlvbiBmb3JtYXRWYWx1ZShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMpIHtcbiAgLy8gUHJvdmlkZSBhIGhvb2sgZm9yIHVzZXItc3BlY2lmaWVkIGluc3BlY3QgZnVuY3Rpb25zLlxuICAvLyBDaGVjayB0aGF0IHZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIGFuIGluc3BlY3QgZnVuY3Rpb24gb24gaXRcbiAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZS5pbnNwZWN0ID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAvLyBGaWx0ZXIgb3V0IHRoZSB1dGlsIG1vZHVsZSwgaXQncyBpbnNwZWN0IGZ1bmN0aW9uIGlzIHNwZWNpYWxcbiAgICAgIHZhbHVlLmluc3BlY3QgIT09IGV4cG9ydHMuaW5zcGVjdCAmJlxuICAgICAgLy8gQWxzbyBmaWx0ZXIgb3V0IGFueSBwcm90b3R5cGUgb2JqZWN0cyB1c2luZyB0aGUgY2lyY3VsYXIgY2hlY2suXG4gICAgICAhKHZhbHVlLmNvbnN0cnVjdG9yICYmIHZhbHVlLmNvbnN0cnVjdG9yLnByb3RvdHlwZSA9PT0gdmFsdWUpKSB7XG4gICAgdmFyIHJldCA9IHZhbHVlLmluc3BlY3QocmVjdXJzZVRpbWVzKTtcbiAgICBpZiAodHlwZW9mIHJldCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHJldCA9IGZvcm1hdFZhbHVlKGN0eCwgcmV0LCByZWN1cnNlVGltZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLy8gUHJpbWl0aXZlIHR5cGVzIGNhbm5vdCBoYXZlIHByb3BlcnRpZXNcbiAgdmFyIHByaW1pdGl2ZSA9IGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKTtcbiAgaWYgKHByaW1pdGl2ZSkge1xuICAgIHJldHVybiBwcmltaXRpdmU7XG4gIH1cblxuICAvLyBJZiBpdCdzIERPTSBlbGVtLCBnZXQgb3V0ZXIgSFRNTC5cbiAgaWYgKGlzRE9NRWxlbWVudCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZ2V0T3V0ZXJIVE1MKHZhbHVlKTtcbiAgfVxuXG4gIC8vIExvb2sgdXAgdGhlIGtleXMgb2YgdGhlIG9iamVjdC5cbiAgdmFyIHZpc2libGVLZXlzID0gZ2V0RW51bWVyYWJsZVByb3BlcnRpZXModmFsdWUpO1xuICB2YXIga2V5cyA9IGN0eC5zaG93SGlkZGVuID8gZ2V0UHJvcGVydGllcyh2YWx1ZSkgOiB2aXNpYmxlS2V5cztcblxuICAvLyBTb21lIHR5cGUgb2Ygb2JqZWN0IHdpdGhvdXQgcHJvcGVydGllcyBjYW4gYmUgc2hvcnRjdXR0ZWQuXG4gIC8vIEluIElFLCBlcnJvcnMgaGF2ZSBhIHNpbmdsZSBgc3RhY2tgIHByb3BlcnR5LCBvciBpZiB0aGV5IGFyZSB2YW5pbGxhIGBFcnJvcmAsXG4gIC8vIGEgYHN0YWNrYCBwbHVzIGBkZXNjcmlwdGlvbmAgcHJvcGVydHk7IGlnbm9yZSB0aG9zZSBmb3IgY29uc2lzdGVuY3kuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCB8fCAoaXNFcnJvcih2YWx1ZSkgJiYgKFxuICAgICAgKGtleXMubGVuZ3RoID09PSAxICYmIGtleXNbMF0gPT09ICdzdGFjaycpIHx8XG4gICAgICAoa2V5cy5sZW5ndGggPT09IDIgJiYga2V5c1swXSA9PT0gJ2Rlc2NyaXB0aW9uJyAmJiBrZXlzWzFdID09PSAnc3RhY2snKVxuICAgICApKSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciBuYW1lID0gZ2V0TmFtZSh2YWx1ZSk7XG4gICAgICB2YXIgbmFtZVN1ZmZpeCA9IG5hbWUgPyAnOiAnICsgbmFtZSA6ICcnO1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbRnVuY3Rpb24nICsgbmFtZVN1ZmZpeCArICddJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9XG4gICAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShEYXRlLnByb3RvdHlwZS50b1VUQ1N0cmluZy5jYWxsKHZhbHVlKSwgJ2RhdGUnKTtcbiAgICB9XG4gICAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBiYXNlID0gJycsIGFycmF5ID0gZmFsc2UsIGJyYWNlcyA9IFsneycsICd9J107XG5cbiAgLy8gTWFrZSBBcnJheSBzYXkgdGhhdCB0aGV5IGFyZSBBcnJheVxuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBhcnJheSA9IHRydWU7XG4gICAgYnJhY2VzID0gWydbJywgJ10nXTtcbiAgfVxuXG4gIC8vIE1ha2UgZnVuY3Rpb25zIHNheSB0aGF0IHRoZXkgYXJlIGZ1bmN0aW9uc1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIG5hbWUgPSBnZXROYW1lKHZhbHVlKTtcbiAgICB2YXIgbmFtZVN1ZmZpeCA9IG5hbWUgPyAnOiAnICsgbmFtZSA6ICcnO1xuICAgIGJhc2UgPSAnIFtGdW5jdGlvbicgKyBuYW1lU3VmZml4ICsgJ10nO1xuICB9XG5cbiAgLy8gTWFrZSBSZWdFeHBzIHNheSB0aGF0IHRoZXkgYXJlIFJlZ0V4cHNcbiAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBkYXRlcyB3aXRoIHByb3BlcnRpZXMgZmlyc3Qgc2F5IHRoZSBkYXRlXG4gIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIERhdGUucHJvdG90eXBlLnRvVVRDU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBlcnJvciB3aXRoIG1lc3NhZ2UgZmlyc3Qgc2F5IHRoZSBlcnJvclxuICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwICYmICghYXJyYXkgfHwgdmFsdWUubGVuZ3RoID09IDApKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyBicmFjZXNbMV07XG4gIH1cblxuICBpZiAocmVjdXJzZVRpbWVzIDwgMCkge1xuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW09iamVjdF0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuXG4gIGN0eC5zZWVuLnB1c2godmFsdWUpO1xuXG4gIHZhciBvdXRwdXQ7XG4gIGlmIChhcnJheSkge1xuICAgIG91dHB1dCA9IGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpO1xuICB9IGVsc2Uge1xuICAgIG91dHB1dCA9IGtleXMubWFwKGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpO1xuICAgIH0pO1xuICB9XG5cbiAgY3R4LnNlZW4ucG9wKCk7XG5cbiAgcmV0dXJuIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKTtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSkge1xuICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ3VuZGVmaW5lZCcsICd1bmRlZmluZWQnKTtcblxuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICB2YXIgc2ltcGxlID0gJ1xcJycgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkucmVwbGFjZSgvXlwifFwiJC9nLCAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpICsgJ1xcJyc7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoc2ltcGxlLCAnc3RyaW5nJyk7XG5cbiAgICBjYXNlICdudW1iZXInOlxuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdudW1iZXInKTtcblxuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdib29sZWFuJyk7XG4gIH1cbiAgLy8gRm9yIHNvbWUgcmVhc29uIHR5cGVvZiBudWxsIGlzIFwib2JqZWN0XCIsIHNvIHNwZWNpYWwgY2FzZSBoZXJlLlxuICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ251bGwnLCAnbnVsbCcpO1xuICB9XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0RXJyb3IodmFsdWUpIHtcbiAgcmV0dXJuICdbJyArIEVycm9yLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSArICddJztcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKSB7XG4gIHZhciBvdXRwdXQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBTdHJpbmcoaSkpKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIFN0cmluZyhpKSwgdHJ1ZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXQucHVzaCgnJyk7XG4gICAgfVxuICB9XG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAoIWtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAga2V5LCB0cnVlKSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KSB7XG4gIHZhciBuYW1lLCBzdHI7XG4gIGlmICh2YWx1ZS5fX2xvb2t1cEdldHRlcl9fKSB7XG4gICAgaWYgKHZhbHVlLl9fbG9va3VwR2V0dGVyX18oa2V5KSkge1xuICAgICAgaWYgKHZhbHVlLl9fbG9va3VwU2V0dGVyX18oa2V5KSkge1xuICAgICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlci9TZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh2YWx1ZS5fX2xvb2t1cFNldHRlcl9fKGtleSkpIHtcbiAgICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tTZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHZpc2libGVLZXlzLmluZGV4T2Yoa2V5KSA8IDApIHtcbiAgICBuYW1lID0gJ1snICsga2V5ICsgJ10nO1xuICB9XG4gIGlmICghc3RyKSB7XG4gICAgaWYgKGN0eC5zZWVuLmluZGV4T2YodmFsdWVba2V5XSkgPCAwKSB7XG4gICAgICBpZiAocmVjdXJzZVRpbWVzID09PSBudWxsKSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgdmFsdWVba2V5XSwgbnVsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIHZhbHVlW2tleV0sIHJlY3Vyc2VUaW1lcyAtIDEpO1xuICAgICAgfVxuICAgICAgaWYgKHN0ci5pbmRleE9mKCdcXG4nKSA+IC0xKSB7XG4gICAgICAgIGlmIChhcnJheSkge1xuICAgICAgICAgIHN0ciA9IHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKS5zdWJzdHIoMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyID0gJ1xcbicgKyBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbQ2lyY3VsYXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cbiAgaWYgKHR5cGVvZiBuYW1lID09PSAndW5kZWZpbmVkJykge1xuICAgIGlmIChhcnJheSAmJiBrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICBuYW1lID0gSlNPTi5zdHJpbmdpZnkoJycgKyBrZXkpO1xuICAgIGlmIChuYW1lLm1hdGNoKC9eXCIoW2EtekEtWl9dW2EtekEtWl8wLTldKilcIiQvKSkge1xuICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyKDEsIG5hbWUubGVuZ3RoIC0gMik7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ25hbWUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJylcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyheXCJ8XCIkKS9nLCBcIidcIik7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ3N0cmluZycpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuYW1lICsgJzogJyArIHN0cjtcbn1cblxuXG5mdW5jdGlvbiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcykge1xuICB2YXIgbnVtTGluZXNFc3QgPSAwO1xuICB2YXIgbGVuZ3RoID0gb3V0cHV0LnJlZHVjZShmdW5jdGlvbihwcmV2LCBjdXIpIHtcbiAgICBudW1MaW5lc0VzdCsrO1xuICAgIGlmIChjdXIuaW5kZXhPZignXFxuJykgPj0gMCkgbnVtTGluZXNFc3QrKztcbiAgICByZXR1cm4gcHJldiArIGN1ci5sZW5ndGggKyAxO1xuICB9LCAwKTtcblxuICBpZiAobGVuZ3RoID4gNjApIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICtcbiAgICAgICAgICAgKGJhc2UgPT09ICcnID8gJycgOiBiYXNlICsgJ1xcbiAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIG91dHB1dC5qb2luKCcsXFxuICAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIGJyYWNlc1sxXTtcbiAgfVxuXG4gIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgJyAnICsgb3V0cHV0LmpvaW4oJywgJykgKyAnICcgKyBicmFjZXNbMV07XG59XG5cbmZ1bmN0aW9uIGlzQXJyYXkoYXIpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXIpIHx8XG4gICAgICAgICAodHlwZW9mIGFyID09PSAnb2JqZWN0JyAmJiBvYmplY3RUb1N0cmluZyhhcikgPT09ICdbb2JqZWN0IEFycmF5XScpO1xufVxuXG5mdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICByZXR1cm4gdHlwZW9mIHJlID09PSAnb2JqZWN0JyAmJiBvYmplY3RUb1N0cmluZyhyZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuXG5mdW5jdGlvbiBpc0RhdGUoZCkge1xuICByZXR1cm4gdHlwZW9mIGQgPT09ICdvYmplY3QnICYmIG9iamVjdFRvU3RyaW5nKGQpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5cbmZ1bmN0aW9uIGlzRXJyb3IoZSkge1xuICByZXR1cm4gdHlwZW9mIGUgPT09ICdvYmplY3QnICYmIG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nO1xufVxuXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG59XG4iLCIvKiFcbiAqIENoYWkgLSBmbGFnIHV0aWxpdHlcbiAqIENvcHlyaWdodChjKSAyMDEyLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4vKiFcbiAqIE1vZHVsZSBkZXBlbmRhbmNpZXNcbiAqL1xuXG52YXIgaW5zcGVjdCA9IHJlcXVpcmUoJy4vaW5zcGVjdCcpO1xudmFyIGNvbmZpZyA9IHJlcXVpcmUoJy4uL2NvbmZpZycpO1xuXG4vKipcbiAqICMjIyAub2JqRGlzcGxheSAob2JqZWN0KVxuICpcbiAqIERldGVybWluZXMgaWYgYW4gb2JqZWN0IG9yIGFuIGFycmF5IG1hdGNoZXNcbiAqIGNyaXRlcmlhIHRvIGJlIGluc3BlY3RlZCBpbi1saW5lIGZvciBlcnJvclxuICogbWVzc2FnZXMgb3Igc2hvdWxkIGJlIHRydW5jYXRlZC5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSBqYXZhc2NyaXB0IG9iamVjdCB0byBpbnNwZWN0XG4gKiBAbmFtZSBvYmpEaXNwbGF5XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iaikge1xuICB2YXIgc3RyID0gaW5zcGVjdChvYmopXG4gICAgLCB0eXBlID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaik7XG5cbiAgaWYgKGNvbmZpZy50cnVuY2F0ZVRocmVzaG9sZCAmJiBzdHIubGVuZ3RoID49IGNvbmZpZy50cnVuY2F0ZVRocmVzaG9sZCkge1xuICAgIGlmICh0eXBlID09PSAnW29iamVjdCBGdW5jdGlvbl0nKSB7XG4gICAgICByZXR1cm4gIW9iai5uYW1lIHx8IG9iai5uYW1lID09PSAnJ1xuICAgICAgICA/ICdbRnVuY3Rpb25dJ1xuICAgICAgICA6ICdbRnVuY3Rpb246ICcgKyBvYmoubmFtZSArICddJztcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgIHJldHVybiAnWyBBcnJheSgnICsgb2JqLmxlbmd0aCArICcpIF0nO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKVxuICAgICAgICAsIGtzdHIgPSBrZXlzLmxlbmd0aCA+IDJcbiAgICAgICAgICA/IGtleXMuc3BsaWNlKDAsIDIpLmpvaW4oJywgJykgKyAnLCAuLi4nXG4gICAgICAgICAgOiBrZXlzLmpvaW4oJywgJyk7XG4gICAgICByZXR1cm4gJ3sgT2JqZWN0ICgnICsga3N0ciArICcpIH0nO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG59O1xuIiwiLyohXG4gKiBDaGFpIC0gb3ZlcndyaXRlQ2hhaW5hYmxlTWV0aG9kIHV0aWxpdHlcbiAqIENvcHlyaWdodChjKSAyMDEyLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4vKipcbiAqICMjIyBvdmVyd3JpdGVDaGFpbmFibGVNZXRob2QgKGN0eCwgbmFtZSwgZm4pXG4gKlxuICogT3ZlcndpdGVzIGFuIGFscmVhZHkgZXhpc3RpbmcgY2hhaW5hYmxlIG1ldGhvZFxuICogYW5kIHByb3ZpZGVzIGFjY2VzcyB0byB0aGUgcHJldmlvdXMgZnVuY3Rpb24gb3JcbiAqIHByb3BlcnR5LiAgTXVzdCByZXR1cm4gZnVuY3Rpb25zIHRvIGJlIHVzZWQgZm9yXG4gKiBuYW1lLlxuICpcbiAqICAgICB1dGlscy5vdmVyd3JpdGVDaGFpbmFibGVNZXRob2QoY2hhaS5Bc3NlcnRpb24ucHJvdG90eXBlLCAnbGVuZ3RoJyxcbiAqICAgICAgIGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAqICAgICAgIH1cbiAqICAgICAsIGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAqICAgICAgIH1cbiAqICAgICApO1xuICpcbiAqIENhbiBhbHNvIGJlIGFjY2Vzc2VkIGRpcmVjdGx5IGZyb20gYGNoYWkuQXNzZXJ0aW9uYC5cbiAqXG4gKiAgICAgY2hhaS5Bc3NlcnRpb24ub3ZlcndyaXRlQ2hhaW5hYmxlTWV0aG9kKCdmb28nLCBmbiwgZm4pO1xuICpcbiAqIFRoZW4gY2FuIGJlIHVzZWQgYXMgYW55IG90aGVyIGFzc2VydGlvbi5cbiAqXG4gKiAgICAgZXhwZWN0KG15Rm9vKS50by5oYXZlLmxlbmd0aCgzKTtcbiAqICAgICBleHBlY3QobXlGb28pLnRvLmhhdmUubGVuZ3RoLmFib3ZlKDMpO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjdHggb2JqZWN0IHdob3NlIG1ldGhvZCAvIHByb3BlcnR5IGlzIHRvIGJlIG92ZXJ3cml0dGVuXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBvZiBtZXRob2QgLyBwcm9wZXJ0eSB0byBvdmVyd3JpdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG1ldGhvZCBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBmdW5jdGlvbiB0byBiZSB1c2VkIGZvciBuYW1lXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjaGFpbmluZ0JlaGF2aW9yIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIGZ1bmN0aW9uIHRvIGJlIHVzZWQgZm9yIHByb3BlcnR5XG4gKiBAbmFtZSBvdmVyd3JpdGVDaGFpbmFibGVNZXRob2RcbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY3R4LCBuYW1lLCBtZXRob2QsIGNoYWluaW5nQmVoYXZpb3IpIHtcbiAgdmFyIGNoYWluYWJsZUJlaGF2aW9yID0gY3R4Ll9fbWV0aG9kc1tuYW1lXTtcblxuICB2YXIgX2NoYWluaW5nQmVoYXZpb3IgPSBjaGFpbmFibGVCZWhhdmlvci5jaGFpbmluZ0JlaGF2aW9yO1xuICBjaGFpbmFibGVCZWhhdmlvci5jaGFpbmluZ0JlaGF2aW9yID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXN1bHQgPSBjaGFpbmluZ0JlaGF2aW9yKF9jaGFpbmluZ0JlaGF2aW9yKS5jYWxsKHRoaXMpO1xuICAgIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IHRoaXMgOiByZXN1bHQ7XG4gIH07XG5cbiAgdmFyIF9tZXRob2QgPSBjaGFpbmFibGVCZWhhdmlvci5tZXRob2Q7XG4gIGNoYWluYWJsZUJlaGF2aW9yLm1ldGhvZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVzdWx0ID0gbWV0aG9kKF9tZXRob2QpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgcmV0dXJuIHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gdGhpcyA6IHJlc3VsdDtcbiAgfTtcbn07XG4iLCIvKiFcbiAqIENoYWkgLSBvdmVyd3JpdGVNZXRob2QgdXRpbGl0eVxuICogQ29weXJpZ2h0KGMpIDIwMTItMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qKlxuICogIyMjIG92ZXJ3cml0ZU1ldGhvZCAoY3R4LCBuYW1lLCBmbilcbiAqXG4gKiBPdmVyd2l0ZXMgYW4gYWxyZWFkeSBleGlzdGluZyBtZXRob2QgYW5kIHByb3ZpZGVzXG4gKiBhY2Nlc3MgdG8gcHJldmlvdXMgZnVuY3Rpb24uIE11c3QgcmV0dXJuIGZ1bmN0aW9uXG4gKiB0byBiZSB1c2VkIGZvciBuYW1lLlxuICpcbiAqICAgICB1dGlscy5vdmVyd3JpdGVNZXRob2QoY2hhaS5Bc3NlcnRpb24ucHJvdG90eXBlLCAnZXF1YWwnLCBmdW5jdGlvbiAoX3N1cGVyKSB7XG4gKiAgICAgICByZXR1cm4gZnVuY3Rpb24gKHN0cikge1xuICogICAgICAgICB2YXIgb2JqID0gdXRpbHMuZmxhZyh0aGlzLCAnb2JqZWN0Jyk7XG4gKiAgICAgICAgIGlmIChvYmogaW5zdGFuY2VvZiBGb28pIHtcbiAqICAgICAgICAgICBuZXcgY2hhaS5Bc3NlcnRpb24ob2JqLnZhbHVlKS50by5lcXVhbChzdHIpO1xuICogICAgICAgICB9IGVsc2Uge1xuICogICAgICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICogICAgICAgICB9XG4gKiAgICAgICB9XG4gKiAgICAgfSk7XG4gKlxuICogQ2FuIGFsc28gYmUgYWNjZXNzZWQgZGlyZWN0bHkgZnJvbSBgY2hhaS5Bc3NlcnRpb25gLlxuICpcbiAqICAgICBjaGFpLkFzc2VydGlvbi5vdmVyd3JpdGVNZXRob2QoJ2ZvbycsIGZuKTtcbiAqXG4gKiBUaGVuIGNhbiBiZSB1c2VkIGFzIGFueSBvdGhlciBhc3NlcnRpb24uXG4gKlxuICogICAgIGV4cGVjdChteUZvbykudG8uZXF1YWwoJ2JhcicpO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjdHggb2JqZWN0IHdob3NlIG1ldGhvZCBpcyB0byBiZSBvdmVyd3JpdHRlblxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgb2YgbWV0aG9kIHRvIG92ZXJ3cml0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gbWV0aG9kIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIGZ1bmN0aW9uIHRvIGJlIHVzZWQgZm9yIG5hbWVcbiAqIEBuYW1lIG92ZXJ3cml0ZU1ldGhvZFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjdHgsIG5hbWUsIG1ldGhvZCkge1xuICB2YXIgX21ldGhvZCA9IGN0eFtuYW1lXVxuICAgICwgX3N1cGVyID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcblxuICBpZiAoX21ldGhvZCAmJiAnZnVuY3Rpb24nID09PSB0eXBlb2YgX21ldGhvZClcbiAgICBfc3VwZXIgPSBfbWV0aG9kO1xuXG4gIGN0eFtuYW1lXSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVzdWx0ID0gbWV0aG9kKF9zdXBlcikuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICByZXR1cm4gcmVzdWx0ID09PSB1bmRlZmluZWQgPyB0aGlzIDogcmVzdWx0O1xuICB9XG59O1xuIiwiLyohXG4gKiBDaGFpIC0gb3ZlcndyaXRlUHJvcGVydHkgdXRpbGl0eVxuICogQ29weXJpZ2h0KGMpIDIwMTItMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qKlxuICogIyMjIG92ZXJ3cml0ZVByb3BlcnR5IChjdHgsIG5hbWUsIGZuKVxuICpcbiAqIE92ZXJ3aXRlcyBhbiBhbHJlYWR5IGV4aXN0aW5nIHByb3BlcnR5IGdldHRlciBhbmQgcHJvdmlkZXNcbiAqIGFjY2VzcyB0byBwcmV2aW91cyB2YWx1ZS4gTXVzdCByZXR1cm4gZnVuY3Rpb24gdG8gdXNlIGFzIGdldHRlci5cbiAqXG4gKiAgICAgdXRpbHMub3ZlcndyaXRlUHJvcGVydHkoY2hhaS5Bc3NlcnRpb24ucHJvdG90eXBlLCAnb2snLCBmdW5jdGlvbiAoX3N1cGVyKSB7XG4gKiAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICogICAgICAgICB2YXIgb2JqID0gdXRpbHMuZmxhZyh0aGlzLCAnb2JqZWN0Jyk7XG4gKiAgICAgICAgIGlmIChvYmogaW5zdGFuY2VvZiBGb28pIHtcbiAqICAgICAgICAgICBuZXcgY2hhaS5Bc3NlcnRpb24ob2JqLm5hbWUpLnRvLmVxdWFsKCdiYXInKTtcbiAqICAgICAgICAgfSBlbHNlIHtcbiAqICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAqICAgICAgICAgfVxuICogICAgICAgfVxuICogICAgIH0pO1xuICpcbiAqXG4gKiBDYW4gYWxzbyBiZSBhY2Nlc3NlZCBkaXJlY3RseSBmcm9tIGBjaGFpLkFzc2VydGlvbmAuXG4gKlxuICogICAgIGNoYWkuQXNzZXJ0aW9uLm92ZXJ3cml0ZVByb3BlcnR5KCdmb28nLCBmbik7XG4gKlxuICogVGhlbiBjYW4gYmUgdXNlZCBhcyBhbnkgb3RoZXIgYXNzZXJ0aW9uLlxuICpcbiAqICAgICBleHBlY3QobXlGb28pLnRvLmJlLm9rO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjdHggb2JqZWN0IHdob3NlIHByb3BlcnR5IGlzIHRvIGJlIG92ZXJ3cml0dGVuXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBvZiBwcm9wZXJ0eSB0byBvdmVyd3JpdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGdldHRlciBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBnZXR0ZXIgZnVuY3Rpb24gdG8gYmUgdXNlZCBmb3IgbmFtZVxuICogQG5hbWUgb3ZlcndyaXRlUHJvcGVydHlcbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY3R4LCBuYW1lLCBnZXR0ZXIpIHtcbiAgdmFyIF9nZXQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGN0eCwgbmFtZSlcbiAgICAsIF9zdXBlciA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gIGlmIChfZ2V0ICYmICdmdW5jdGlvbicgPT09IHR5cGVvZiBfZ2V0LmdldClcbiAgICBfc3VwZXIgPSBfZ2V0LmdldFxuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdHgsIG5hbWUsXG4gICAgeyBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGdldHRlcihfc3VwZXIpLmNhbGwodGhpcyk7XG4gICAgICAgIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IHRoaXMgOiByZXN1bHQ7XG4gICAgICB9XG4gICAgLCBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59O1xuIiwiLyohXG4gKiBDaGFpIC0gdGVzdCB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyohXG4gKiBNb2R1bGUgZGVwZW5kYW5jaWVzXG4gKi9cblxudmFyIGZsYWcgPSByZXF1aXJlKCcuL2ZsYWcnKTtcblxuLyoqXG4gKiAjIHRlc3Qob2JqZWN0LCBleHByZXNzaW9uKVxuICpcbiAqIFRlc3QgYW5kIG9iamVjdCBmb3IgZXhwcmVzc2lvbi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IChjb25zdHJ1Y3RlZCBBc3NlcnRpb24pXG4gKiBAcGFyYW0ge0FyZ3VtZW50c30gY2hhaS5Bc3NlcnRpb24ucHJvdG90eXBlLmFzc2VydCBhcmd1bWVudHNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmosIGFyZ3MpIHtcbiAgdmFyIG5lZ2F0ZSA9IGZsYWcob2JqLCAnbmVnYXRlJylcbiAgICAsIGV4cHIgPSBhcmdzWzBdO1xuICByZXR1cm4gbmVnYXRlID8gIWV4cHIgOiBleHByO1xufTtcbiIsIi8qIVxuICogQ2hhaSAtIHRyYW5zZmVyRmxhZ3MgdXRpbGl0eVxuICogQ29weXJpZ2h0KGMpIDIwMTItMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qKlxuICogIyMjIHRyYW5zZmVyRmxhZ3MoYXNzZXJ0aW9uLCBvYmplY3QsIGluY2x1ZGVBbGwgPSB0cnVlKVxuICpcbiAqIFRyYW5zZmVyIGFsbCB0aGUgZmxhZ3MgZm9yIGBhc3NlcnRpb25gIHRvIGBvYmplY3RgLiBJZlxuICogYGluY2x1ZGVBbGxgIGlzIHNldCB0byBgZmFsc2VgLCB0aGVuIHRoZSBiYXNlIENoYWlcbiAqIGFzc2VydGlvbiBmbGFncyAobmFtZWx5IGBvYmplY3RgLCBgc3NmaWAsIGFuZCBgbWVzc2FnZWApXG4gKiB3aWxsIG5vdCBiZSB0cmFuc2ZlcnJlZC5cbiAqXG4gKlxuICogICAgIHZhciBuZXdBc3NlcnRpb24gPSBuZXcgQXNzZXJ0aW9uKCk7XG4gKiAgICAgdXRpbHMudHJhbnNmZXJGbGFncyhhc3NlcnRpb24sIG5ld0Fzc2VydGlvbik7XG4gKlxuICogICAgIHZhciBhbm90aGVyQXNzZXJpdG9uID0gbmV3IEFzc2VydGlvbihteU9iaik7XG4gKiAgICAgdXRpbHMudHJhbnNmZXJGbGFncyhhc3NlcnRpb24sIGFub3RoZXJBc3NlcnRpb24sIGZhbHNlKTtcbiAqXG4gKiBAcGFyYW0ge0Fzc2VydGlvbn0gYXNzZXJ0aW9uIHRoZSBhc3NlcnRpb24gdG8gdHJhbnNmZXIgdGhlIGZsYWdzIGZyb21cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgdGhlIG9iamVjdCB0byB0cmFuc2ZlciB0aGUgZmxhZ3MgdG9vOyB1c3VhbGx5IGEgbmV3IGFzc2VydGlvblxuICogQHBhcmFtIHtCb29sZWFufSBpbmNsdWRlQWxsXG4gKiBAbmFtZSBnZXRBbGxGbGFnc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXNzZXJ0aW9uLCBvYmplY3QsIGluY2x1ZGVBbGwpIHtcbiAgdmFyIGZsYWdzID0gYXNzZXJ0aW9uLl9fZmxhZ3MgfHwgKGFzc2VydGlvbi5fX2ZsYWdzID0gT2JqZWN0LmNyZWF0ZShudWxsKSk7XG5cbiAgaWYgKCFvYmplY3QuX19mbGFncykge1xuICAgIG9iamVjdC5fX2ZsYWdzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfVxuXG4gIGluY2x1ZGVBbGwgPSBhcmd1bWVudHMubGVuZ3RoID09PSAzID8gaW5jbHVkZUFsbCA6IHRydWU7XG5cbiAgZm9yICh2YXIgZmxhZyBpbiBmbGFncykge1xuICAgIGlmIChpbmNsdWRlQWxsIHx8XG4gICAgICAgIChmbGFnICE9PSAnb2JqZWN0JyAmJiBmbGFnICE9PSAnc3NmaScgJiYgZmxhZyAhPSAnbWVzc2FnZScpKSB7XG4gICAgICBvYmplY3QuX19mbGFnc1tmbGFnXSA9IGZsYWdzW2ZsYWddO1xuICAgIH1cbiAgfVxufTtcbiIsIi8qIVxuICogQ2hhaSAtIHR5cGUgdXRpbGl0eVxuICogQ29weXJpZ2h0KGMpIDIwMTItMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qIVxuICogRGV0ZWN0YWJsZSBqYXZhc2NyaXB0IG5hdGl2ZXNcbiAqL1xuXG52YXIgbmF0aXZlcyA9IHtcbiAgICAnW29iamVjdCBBcmd1bWVudHNdJzogJ2FyZ3VtZW50cydcbiAgLCAnW29iamVjdCBBcnJheV0nOiAnYXJyYXknXG4gICwgJ1tvYmplY3QgRGF0ZV0nOiAnZGF0ZSdcbiAgLCAnW29iamVjdCBGdW5jdGlvbl0nOiAnZnVuY3Rpb24nXG4gICwgJ1tvYmplY3QgTnVtYmVyXSc6ICdudW1iZXInXG4gICwgJ1tvYmplY3QgUmVnRXhwXSc6ICdyZWdleHAnXG4gICwgJ1tvYmplY3QgU3RyaW5nXSc6ICdzdHJpbmcnXG59O1xuXG4vKipcbiAqICMjIyB0eXBlKG9iamVjdClcbiAqXG4gKiBCZXR0ZXIgaW1wbGVtZW50YXRpb24gb2YgYHR5cGVvZmAgZGV0ZWN0aW9uIHRoYXQgY2FuXG4gKiBiZSB1c2VkIGNyb3NzLWJyb3dzZXIuIEhhbmRsZXMgdGhlIGluY29uc2lzdGVuY2llcyBvZlxuICogQXJyYXksIGBudWxsYCwgYW5kIGB1bmRlZmluZWRgIGRldGVjdGlvbi5cbiAqXG4gKiAgICAgdXRpbHMudHlwZSh7fSkgLy8gJ29iamVjdCdcbiAqICAgICB1dGlscy50eXBlKG51bGwpIC8vIGBudWxsJ1xuICogICAgIHV0aWxzLnR5cGUodW5kZWZpbmVkKSAvLyBgdW5kZWZpbmVkYFxuICogICAgIHV0aWxzLnR5cGUoW10pIC8vIGBhcnJheWBcbiAqXG4gKiBAcGFyYW0ge01peGVkfSBvYmplY3QgdG8gZGV0ZWN0IHR5cGUgb2ZcbiAqIEBuYW1lIHR5cGVcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iaikge1xuICB2YXIgc3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaik7XG4gIGlmIChuYXRpdmVzW3N0cl0pIHJldHVybiBuYXRpdmVzW3N0cl07XG4gIGlmIChvYmogPT09IG51bGwpIHJldHVybiAnbnVsbCc7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgcmV0dXJuICd1bmRlZmluZWQnO1xuICBpZiAob2JqID09PSBPYmplY3Qob2JqKSkgcmV0dXJuICdvYmplY3QnO1xuICByZXR1cm4gdHlwZW9mIG9iajtcbn07XG4iLCIvKiFcbiAqIGFzc2VydGlvbi1lcnJvclxuICogQ29weXJpZ2h0KGMpIDIwMTMgSmFrZSBMdWVyIDxqYWtlQHF1YWxpYW5jeS5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4vKiFcbiAqIFJldHVybiBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBjb3B5IHByb3BlcnRpZXMgZnJvbVxuICogb25lIG9iamVjdCB0byBhbm90aGVyIGV4Y2x1ZGluZyBhbnkgb3JpZ2luYWxseVxuICogbGlzdGVkLiBSZXR1cm5lZCBmdW5jdGlvbiB3aWxsIGNyZWF0ZSBhIG5ldyBge31gLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBleGNsdWRlZCBwcm9wZXJ0aWVzIC4uLlxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cblxuZnVuY3Rpb24gZXhjbHVkZSAoKSB7XG4gIHZhciBleGNsdWRlcyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblxuICBmdW5jdGlvbiBleGNsdWRlUHJvcHMgKHJlcywgb2JqKSB7XG4gICAgT2JqZWN0LmtleXMob2JqKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIGlmICghfmV4Y2x1ZGVzLmluZGV4T2Yoa2V5KSkgcmVzW2tleV0gPSBvYmpba2V5XTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiBleHRlbmRFeGNsdWRlICgpIHtcbiAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKVxuICAgICAgLCBpID0gMFxuICAgICAgLCByZXMgPSB7fTtcblxuICAgIGZvciAoOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgZXhjbHVkZVByb3BzKHJlcywgYXJnc1tpXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcztcbiAgfTtcbn07XG5cbi8qIVxuICogUHJpbWFyeSBFeHBvcnRzXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBBc3NlcnRpb25FcnJvcjtcblxuLyoqXG4gKiAjIyMgQXNzZXJ0aW9uRXJyb3JcbiAqXG4gKiBBbiBleHRlbnNpb24gb2YgdGhlIEphdmFTY3JpcHQgYEVycm9yYCBjb25zdHJ1Y3RvciBmb3JcbiAqIGFzc2VydGlvbiBhbmQgdmFsaWRhdGlvbiBzY2VuYXJpb3MuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wZXJ0aWVzIHRvIGluY2x1ZGUgKG9wdGlvbmFsKVxuICogQHBhcmFtIHtjYWxsZWV9IHN0YXJ0IHN0YWNrIGZ1bmN0aW9uIChvcHRpb25hbClcbiAqL1xuXG5mdW5jdGlvbiBBc3NlcnRpb25FcnJvciAobWVzc2FnZSwgX3Byb3BzLCBzc2YpIHtcbiAgdmFyIGV4dGVuZCA9IGV4Y2x1ZGUoJ25hbWUnLCAnbWVzc2FnZScsICdzdGFjaycsICdjb25zdHJ1Y3RvcicsICd0b0pTT04nKVxuICAgICwgcHJvcHMgPSBleHRlbmQoX3Byb3BzIHx8IHt9KTtcblxuICAvLyBkZWZhdWx0IHZhbHVlc1xuICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8ICdVbnNwZWNpZmllZCBBc3NlcnRpb25FcnJvcic7XG4gIHRoaXMuc2hvd0RpZmYgPSBmYWxzZTtcblxuICAvLyBjb3B5IGZyb20gcHJvcGVydGllc1xuICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICB0aGlzW2tleV0gPSBwcm9wc1trZXldO1xuICB9XG5cbiAgLy8gY2FwdHVyZSBzdGFjayB0cmFjZVxuICBzc2YgPSBzc2YgfHwgYXJndW1lbnRzLmNhbGxlZTtcbiAgaWYgKHNzZiAmJiBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHNzZik7XG4gIH1cbn1cblxuLyohXG4gKiBJbmhlcml0IGZyb20gRXJyb3IucHJvdG90eXBlXG4gKi9cblxuQXNzZXJ0aW9uRXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xuXG4vKiFcbiAqIFN0YXRpY2FsbHkgc2V0IG5hbWVcbiAqL1xuXG5Bc3NlcnRpb25FcnJvci5wcm90b3R5cGUubmFtZSA9ICdBc3NlcnRpb25FcnJvcic7XG5cbi8qIVxuICogRW5zdXJlIGNvcnJlY3QgY29uc3RydWN0b3JcbiAqL1xuXG5Bc3NlcnRpb25FcnJvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBBc3NlcnRpb25FcnJvcjtcblxuLyoqXG4gKiBBbGxvdyBlcnJvcnMgdG8gYmUgY29udmVydGVkIHRvIEpTT04gZm9yIHN0YXRpYyB0cmFuc2Zlci5cbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGluY2x1ZGUgc3RhY2sgKGRlZmF1bHQ6IGB0cnVlYClcbiAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0IHRoYXQgY2FuIGJlIGBKU09OLnN0cmluZ2lmeWBcbiAqL1xuXG5Bc3NlcnRpb25FcnJvci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKHN0YWNrKSB7XG4gIHZhciBleHRlbmQgPSBleGNsdWRlKCdjb25zdHJ1Y3RvcicsICd0b0pTT04nLCAnc3RhY2snKVxuICAgICwgcHJvcHMgPSBleHRlbmQoeyBuYW1lOiB0aGlzLm5hbWUgfSwgdGhpcyk7XG5cbiAgLy8gaW5jbHVkZSBzdGFjayBpZiBleGlzdHMgYW5kIG5vdCB0dXJuZWQgb2ZmXG4gIGlmIChmYWxzZSAhPT0gc3RhY2sgJiYgdGhpcy5zdGFjaykge1xuICAgIHByb3BzLnN0YWNrID0gdGhpcy5zdGFjaztcbiAgfVxuXG4gIHJldHVybiBwcm9wcztcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL2VxbCcpO1xuIiwiLyohXG4gKiBkZWVwLWVxbFxuICogQ29weXJpZ2h0KGMpIDIwMTMgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4vKiFcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXNcbiAqL1xuXG52YXIgdHlwZSA9IHJlcXVpcmUoJ3R5cGUtZGV0ZWN0Jyk7XG5cbi8qIVxuICogQnVmZmVyLmlzQnVmZmVyIGJyb3dzZXIgc2hpbVxuICovXG5cbnZhciBCdWZmZXI7XG50cnkgeyBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7IH1cbmNhdGNoKGV4KSB7XG4gIEJ1ZmZlciA9IHt9O1xuICBCdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGZhbHNlOyB9XG59XG5cbi8qIVxuICogUHJpbWFyeSBFeHBvcnRcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlZXBFcXVhbDtcblxuLyoqXG4gKiBBc3NlcnQgc3VwZXItc3RyaWN0IChlZ2FsKSBlcXVhbGl0eSBiZXR3ZWVuXG4gKiB0d28gb2JqZWN0cyBvZiBhbnkgdHlwZS5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSBhXG4gKiBAcGFyYW0ge01peGVkfSBiXG4gKiBAcGFyYW0ge0FycmF5fSBtZW1vaXNlZCAob3B0aW9uYWwpXG4gKiBAcmV0dXJuIHtCb29sZWFufSBlcXVhbCBtYXRjaFxuICovXG5cbmZ1bmN0aW9uIGRlZXBFcXVhbChhLCBiLCBtKSB7XG4gIGlmIChzYW1lVmFsdWUoYSwgYikpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmICgnZGF0ZScgPT09IHR5cGUoYSkpIHtcbiAgICByZXR1cm4gZGF0ZUVxdWFsKGEsIGIpO1xuICB9IGVsc2UgaWYgKCdyZWdleHAnID09PSB0eXBlKGEpKSB7XG4gICAgcmV0dXJuIHJlZ2V4cEVxdWFsKGEsIGIpO1xuICB9IGVsc2UgaWYgKEJ1ZmZlci5pc0J1ZmZlcihhKSkge1xuICAgIHJldHVybiBidWZmZXJFcXVhbChhLCBiKTtcbiAgfSBlbHNlIGlmICgnYXJndW1lbnRzJyA9PT0gdHlwZShhKSkge1xuICAgIHJldHVybiBhcmd1bWVudHNFcXVhbChhLCBiLCBtKTtcbiAgfSBlbHNlIGlmICghdHlwZUVxdWFsKGEsIGIpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2UgaWYgKCgnb2JqZWN0JyAhPT0gdHlwZShhKSAmJiAnb2JqZWN0JyAhPT0gdHlwZShiKSlcbiAgJiYgKCdhcnJheScgIT09IHR5cGUoYSkgJiYgJ2FycmF5JyAhPT0gdHlwZShiKSkpIHtcbiAgICByZXR1cm4gc2FtZVZhbHVlKGEsIGIpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBvYmplY3RFcXVhbChhLCBiLCBtKTtcbiAgfVxufVxuXG4vKiFcbiAqIFN0cmljdCAoZWdhbCkgZXF1YWxpdHkgdGVzdC4gRW5zdXJlcyB0aGF0IE5hTiBhbHdheXNcbiAqIGVxdWFscyBOYU4gYW5kIGAtMGAgZG9lcyBub3QgZXF1YWwgYCswYC5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSBhXG4gKiBAcGFyYW0ge01peGVkfSBiXG4gKiBAcmV0dXJuIHtCb29sZWFufSBlcXVhbCBtYXRjaFxuICovXG5cbmZ1bmN0aW9uIHNhbWVWYWx1ZShhLCBiKSB7XG4gIGlmIChhID09PSBiKSByZXR1cm4gYSAhPT0gMCB8fCAxIC8gYSA9PT0gMSAvIGI7XG4gIHJldHVybiBhICE9PSBhICYmIGIgIT09IGI7XG59XG5cbi8qIVxuICogQ29tcGFyZSB0aGUgdHlwZXMgb2YgdHdvIGdpdmVuIG9iamVjdHMgYW5kXG4gKiByZXR1cm4gaWYgdGhleSBhcmUgZXF1YWwuIE5vdGUgdGhhdCBhbiBBcnJheVxuICogaGFzIGEgdHlwZSBvZiBgYXJyYXlgIChub3QgYG9iamVjdGApIGFuZCBhcmd1bWVudHNcbiAqIGhhdmUgYSB0eXBlIG9mIGBhcmd1bWVudHNgIChub3QgYGFycmF5YC9gb2JqZWN0YCkuXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gYVxuICogQHBhcmFtIHtNaXhlZH0gYlxuICogQHJldHVybiB7Qm9vbGVhbn0gcmVzdWx0XG4gKi9cblxuZnVuY3Rpb24gdHlwZUVxdWFsKGEsIGIpIHtcbiAgcmV0dXJuIHR5cGUoYSkgPT09IHR5cGUoYik7XG59XG5cbi8qIVxuICogQ29tcGFyZSB0d28gRGF0ZSBvYmplY3RzIGJ5IGFzc2VydGluZyB0aGF0XG4gKiB0aGUgdGltZSB2YWx1ZXMgYXJlIGVxdWFsIHVzaW5nIGBzYXZlVmFsdWVgLlxuICpcbiAqIEBwYXJhbSB7RGF0ZX0gYVxuICogQHBhcmFtIHtEYXRlfSBiXG4gKiBAcmV0dXJuIHtCb29sZWFufSByZXN1bHRcbiAqL1xuXG5mdW5jdGlvbiBkYXRlRXF1YWwoYSwgYikge1xuICBpZiAoJ2RhdGUnICE9PSB0eXBlKGIpKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBzYW1lVmFsdWUoYS5nZXRUaW1lKCksIGIuZ2V0VGltZSgpKTtcbn1cblxuLyohXG4gKiBDb21wYXJlIHR3byByZWd1bGFyIGV4cHJlc3Npb25zIGJ5IGNvbnZlcnRpbmcgdGhlbVxuICogdG8gc3RyaW5nIGFuZCBjaGVja2luZyBmb3IgYHNhbWVWYWx1ZWAuXG4gKlxuICogQHBhcmFtIHtSZWdFeHB9IGFcbiAqIEBwYXJhbSB7UmVnRXhwfSBiXG4gKiBAcmV0dXJuIHtCb29sZWFufSByZXN1bHRcbiAqL1xuXG5mdW5jdGlvbiByZWdleHBFcXVhbChhLCBiKSB7XG4gIGlmICgncmVnZXhwJyAhPT0gdHlwZShiKSkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gc2FtZVZhbHVlKGEudG9TdHJpbmcoKSwgYi50b1N0cmluZygpKTtcbn1cblxuLyohXG4gKiBBc3NlcnQgZGVlcCBlcXVhbGl0eSBvZiB0d28gYGFyZ3VtZW50c2Agb2JqZWN0cy5cbiAqIFVuZm9ydHVuYXRlbHksIHRoZXNlIG11c3QgYmUgc2xpY2VkIHRvIGFycmF5c1xuICogcHJpb3IgdG8gdGVzdCB0byBlbnN1cmUgbm8gYmFkIGJlaGF2aW9yLlxuICpcbiAqIEBwYXJhbSB7QXJndW1lbnRzfSBhXG4gKiBAcGFyYW0ge0FyZ3VtZW50c30gYlxuICogQHBhcmFtIHtBcnJheX0gbWVtb2l6ZSAob3B0aW9uYWwpXG4gKiBAcmV0dXJuIHtCb29sZWFufSByZXN1bHRcbiAqL1xuXG5mdW5jdGlvbiBhcmd1bWVudHNFcXVhbChhLCBiLCBtKSB7XG4gIGlmICgnYXJndW1lbnRzJyAhPT0gdHlwZShiKSkgcmV0dXJuIGZhbHNlO1xuICBhID0gW10uc2xpY2UuY2FsbChhKTtcbiAgYiA9IFtdLnNsaWNlLmNhbGwoYik7XG4gIHJldHVybiBkZWVwRXF1YWwoYSwgYiwgbSk7XG59XG5cbi8qIVxuICogR2V0IGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBhIGdpdmVuIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYVxuICogQHJldHVybiB7QXJyYXl9IHByb3BlcnR5IG5hbWVzXG4gKi9cblxuZnVuY3Rpb24gZW51bWVyYWJsZShhKSB7XG4gIHZhciByZXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIGEpIHJlcy5wdXNoKGtleSk7XG4gIHJldHVybiByZXM7XG59XG5cbi8qIVxuICogU2ltcGxlIGVxdWFsaXR5IGZvciBmbGF0IGl0ZXJhYmxlIG9iamVjdHNcbiAqIHN1Y2ggYXMgQXJyYXlzIG9yIE5vZGUuanMgYnVmZmVycy5cbiAqXG4gKiBAcGFyYW0ge0l0ZXJhYmxlfSBhXG4gKiBAcGFyYW0ge0l0ZXJhYmxlfSBiXG4gKiBAcmV0dXJuIHtCb29sZWFufSByZXN1bHRcbiAqL1xuXG5mdW5jdGlvbiBpdGVyYWJsZUVxdWFsKGEsIGIpIHtcbiAgaWYgKGEubGVuZ3RoICE9PSAgYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcblxuICB2YXIgaSA9IDA7XG4gIHZhciBtYXRjaCA9IHRydWU7XG5cbiAgZm9yICg7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIG1hdGNoID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWF0Y2g7XG59XG5cbi8qIVxuICogRXh0ZW5zaW9uIHRvIGBpdGVyYWJsZUVxdWFsYCBzcGVjaWZpY2FsbHlcbiAqIGZvciBOb2RlLmpzIEJ1ZmZlcnMuXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGFcbiAqIEBwYXJhbSB7TWl4ZWR9IGJcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHJlc3VsdFxuICovXG5cbmZ1bmN0aW9uIGJ1ZmZlckVxdWFsKGEsIGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIGl0ZXJhYmxlRXF1YWwoYSwgYik7XG59XG5cbi8qIVxuICogQmxvY2sgZm9yIGBvYmplY3RFcXVhbGAgZW5zdXJpbmcgbm9uLWV4aXN0aW5nXG4gKiB2YWx1ZXMgZG9uJ3QgZ2V0IGluLlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IG9iamVjdFxuICogQHJldHVybiB7Qm9vbGVhbn0gcmVzdWx0XG4gKi9cblxuZnVuY3Rpb24gaXNWYWx1ZShhKSB7XG4gIHJldHVybiBhICE9PSBudWxsICYmIGEgIT09IHVuZGVmaW5lZDtcbn1cblxuLyohXG4gKiBSZWN1cnNpdmVseSBjaGVjayB0aGUgZXF1YWxpdHkgb2YgdHdvIG9iamVjdHMuXG4gKiBPbmNlIGJhc2ljIHNhbWVuZXNzIGhhcyBiZWVuIGVzdGFibGlzaGVkIGl0IHdpbGxcbiAqIGRlZmVyIHRvIGBkZWVwRXF1YWxgIGZvciBlYWNoIGVudW1lcmFibGUga2V5XG4gKiBpbiB0aGUgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IGFcbiAqIEBwYXJhbSB7TWl4ZWR9IGJcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHJlc3VsdFxuICovXG5cbmZ1bmN0aW9uIG9iamVjdEVxdWFsKGEsIGIsIG0pIHtcbiAgaWYgKCFpc1ZhbHVlKGEpIHx8ICFpc1ZhbHVlKGIpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGEucHJvdG90eXBlICE9PSBiLnByb3RvdHlwZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBpO1xuICBpZiAobSkge1xuICAgIGZvciAoaSA9IDA7IGkgPCBtLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoKG1baV1bMF0gPT09IGEgJiYgbVtpXVsxXSA9PT0gYilcbiAgICAgIHx8ICAobVtpXVswXSA9PT0gYiAmJiBtW2ldWzFdID09PSBhKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbSA9IFtdO1xuICB9XG5cbiAgdHJ5IHtcbiAgICB2YXIga2EgPSBlbnVtZXJhYmxlKGEpO1xuICAgIHZhciBrYiA9IGVudW1lcmFibGUoYik7XG4gIH0gY2F0Y2ggKGV4KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAga2Euc29ydCgpO1xuICBrYi5zb3J0KCk7XG5cbiAgaWYgKCFpdGVyYWJsZUVxdWFsKGthLCBrYikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBtLnB1c2goWyBhLCBiIF0pO1xuXG4gIHZhciBrZXk7XG4gIGZvciAoaSA9IGthLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAga2V5ID0ga2FbaV07XG4gICAgaWYgKCFkZWVwRXF1YWwoYVtrZXldLCBiW2tleV0sIG0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL3R5cGUnKTtcbiIsIi8qIVxuICogdHlwZS1kZXRlY3RcbiAqIENvcHlyaWdodChjKSAyMDEzIGpha2UgbHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyohXG4gKiBQcmltYXJ5IEV4cG9ydHNcbiAqL1xuXG52YXIgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZ2V0VHlwZTtcblxuLyohXG4gKiBEZXRlY3RhYmxlIGphdmFzY3JpcHQgbmF0aXZlc1xuICovXG5cbnZhciBuYXRpdmVzID0ge1xuICAgICdbb2JqZWN0IEFycmF5XSc6ICdhcnJheSdcbiAgLCAnW29iamVjdCBSZWdFeHBdJzogJ3JlZ2V4cCdcbiAgLCAnW29iamVjdCBGdW5jdGlvbl0nOiAnZnVuY3Rpb24nXG4gICwgJ1tvYmplY3QgQXJndW1lbnRzXSc6ICdhcmd1bWVudHMnXG4gICwgJ1tvYmplY3QgRGF0ZV0nOiAnZGF0ZSdcbn07XG5cbi8qKlxuICogIyMjIHR5cGVPZiAob2JqKVxuICpcbiAqIFVzZSBzZXZlcmFsIGRpZmZlcmVudCB0ZWNobmlxdWVzIHRvIGRldGVybWluZVxuICogdGhlIHR5cGUgb2Ygb2JqZWN0IGJlaW5nIHRlc3RlZC5cbiAqXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gb2JqZWN0XG4gKiBAcmV0dXJuIHtTdHJpbmd9IG9iamVjdCB0eXBlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGdldFR5cGUgKG9iaikge1xuICB2YXIgc3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaik7XG4gIGlmIChuYXRpdmVzW3N0cl0pIHJldHVybiBuYXRpdmVzW3N0cl07XG4gIGlmIChvYmogPT09IG51bGwpIHJldHVybiAnbnVsbCc7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgcmV0dXJuICd1bmRlZmluZWQnO1xuICBpZiAob2JqID09PSBPYmplY3Qob2JqKSkgcmV0dXJuICdvYmplY3QnO1xuICByZXR1cm4gdHlwZW9mIG9iajtcbn1cblxuZXhwb3J0cy5MaWJyYXJ5ID0gTGlicmFyeTtcblxuLyoqXG4gKiAjIyMgTGlicmFyeVxuICpcbiAqIENyZWF0ZSBhIHJlcG9zaXRvcnkgZm9yIGN1c3RvbSB0eXBlIGRldGVjdGlvbi5cbiAqXG4gKiBgYGBqc1xuICogdmFyIGxpYiA9IG5ldyB0eXBlLkxpYnJhcnk7XG4gKiBgYGBcbiAqXG4gKi9cblxuZnVuY3Rpb24gTGlicmFyeSAoKSB7XG4gIHRoaXMudGVzdHMgPSB7fTtcbn1cblxuLyoqXG4gKiAjIyMjIC5vZiAob2JqKVxuICpcbiAqIEV4cG9zZSByZXBsYWNlbWVudCBgdHlwZW9mYCBkZXRlY3Rpb24gdG8gdGhlIGxpYnJhcnkuXG4gKlxuICogYGBganNcbiAqIGlmICgnc3RyaW5nJyA9PT0gbGliLm9mKCdoZWxsbyB3b3JsZCcpKSB7XG4gKiAgIC8vIC4uLlxuICogfVxuICogYGBgXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gb2JqZWN0IHRvIHRlc3RcbiAqIEByZXR1cm4ge1N0cmluZ30gdHlwZVxuICovXG5cbkxpYnJhcnkucHJvdG90eXBlLm9mID0gZ2V0VHlwZTtcblxuLyoqXG4gKiAjIyMjIC5kZWZpbmUgKHR5cGUsIHRlc3QpXG4gKlxuICogQWRkIGEgdGVzdCB0byBmb3IgdGhlIGAudGVzdCgpYCBhc3NlcnRpb24uXG4gKlxuICogQ2FuIGJlIGRlZmluZWQgYXMgYSByZWd1bGFyIGV4cHJlc3Npb246XG4gKlxuICogYGBganNcbiAqIGxpYi5kZWZpbmUoJ2ludCcsIC9eWzAtOV0rJC8pO1xuICogYGBgXG4gKlxuICogLi4uIG9yIGFzIGEgZnVuY3Rpb246XG4gKlxuICogYGBganNcbiAqIGxpYi5kZWZpbmUoJ2JsbicsIGZ1bmN0aW9uIChvYmopIHtcbiAqICAgaWYgKCdib29sZWFuJyA9PT0gbGliLm9mKG9iaikpIHJldHVybiB0cnVlO1xuICogICB2YXIgYmxucyA9IFsgJ3llcycsICdubycsICd0cnVlJywgJ2ZhbHNlJywgMSwgMCBdO1xuICogICBpZiAoJ3N0cmluZycgPT09IGxpYi5vZihvYmopKSBvYmogPSBvYmoudG9Mb3dlckNhc2UoKTtcbiAqICAgcmV0dXJuICEhIH5ibG5zLmluZGV4T2Yob2JqKTtcbiAqIH0pO1xuICogYGBgXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqIEBwYXJhbSB7UmVnRXhwfEZ1bmN0aW9ufSB0ZXN0XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkxpYnJhcnkucHJvdG90eXBlLmRlZmluZSA9IGZ1bmN0aW9uICh0eXBlLCB0ZXN0KSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSByZXR1cm4gdGhpcy50ZXN0c1t0eXBlXTtcbiAgdGhpcy50ZXN0c1t0eXBlXSA9IHRlc3Q7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiAjIyMjIC50ZXN0IChvYmosIHRlc3QpXG4gKlxuICogQXNzZXJ0IHRoYXQgYW4gb2JqZWN0IGlzIG9mIHR5cGUuIFdpbGwgZmlyc3RcbiAqIGNoZWNrIG5hdGl2ZXMsIGFuZCBpZiB0aGF0IGRvZXMgbm90IHBhc3MgaXQgd2lsbFxuICogdXNlIHRoZSB1c2VyIGRlZmluZWQgY3VzdG9tIHRlc3RzLlxuICpcbiAqIGBgYGpzXG4gKiBhc3NlcnQobGliLnRlc3QoJzEnLCAnaW50JykpO1xuICogYXNzZXJ0KGxpYi50ZXN0KCd5ZXMnLCAnYmxuJykpO1xuICogYGBgXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gb2JqZWN0XG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICogQHJldHVybiB7Qm9vbGVhbn0gcmVzdWx0XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkxpYnJhcnkucHJvdG90eXBlLnRlc3QgPSBmdW5jdGlvbiAob2JqLCB0eXBlKSB7XG4gIGlmICh0eXBlID09PSBnZXRUeXBlKG9iaikpIHJldHVybiB0cnVlO1xuICB2YXIgdGVzdCA9IHRoaXMudGVzdHNbdHlwZV07XG5cbiAgaWYgKHRlc3QgJiYgJ3JlZ2V4cCcgPT09IGdldFR5cGUodGVzdCkpIHtcbiAgICByZXR1cm4gdGVzdC50ZXN0KG9iaik7XG4gIH0gZWxzZSBpZiAodGVzdCAmJiAnZnVuY3Rpb24nID09PSBnZXRUeXBlKHRlc3QpKSB7XG4gICAgcmV0dXJuIHRlc3Qob2JqKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoJ1R5cGUgdGVzdCBcIicgKyB0eXBlICsgJ1wiIG5vdCBkZWZpbmVkIG9yIGludmFsaWQuJyk7XG4gIH1cbn07XG4iLG51bGwsIi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cblxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG52YXIgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5TbG93QnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTBcbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTJcblxuLyoqXG4gKiBJZiBgVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBVc2UgT2JqZWN0IGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBOb3RlOlxuICpcbiAqIC0gSW1wbGVtZW50YXRpb24gbXVzdCBzdXBwb3J0IGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWAgaW5zdGFuY2VzLlxuICogICBGaXJlZm94IDQtMjkgbGFja2VkIHN1cHBvcnQsIGZpeGVkIGluIEZpcmVmb3ggMzArLlxuICogICBTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOC5cbiAqXG4gKiAgLSBDaHJvbWUgOS0xMCBpcyBtaXNzaW5nIHRoZSBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uLlxuICpcbiAqICAtIElFMTAgaGFzIGEgYnJva2VuIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhcnJheXMgb2ZcbiAqICAgIGluY29ycmVjdCBsZW5ndGggaW4gc29tZSBzaXR1YXRpb25zLlxuICpcbiAqIFdlIGRldGVjdCB0aGVzZSBidWdneSBicm93c2VycyBhbmQgc2V0IGBUWVBFRF9BUlJBWV9TVVBQT1JUYCB0byBgZmFsc2VgIHNvIHRoZXkgd2lsbFxuICogZ2V0IHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24sIHdoaWNoIGlzIHNsb3dlciBidXQgd2lsbCB3b3JrIGNvcnJlY3RseS5cbiAqL1xudmFyIFRZUEVEX0FSUkFZX1NVUFBPUlQgPSAoZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIHZhciBidWYgPSBuZXcgQXJyYXlCdWZmZXIoMClcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoYnVmKVxuICAgIGFyci5mb28gPSBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9XG4gICAgcmV0dXJuIDQyID09PSBhcnIuZm9vKCkgJiYgLy8gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWRcbiAgICAgICAgdHlwZW9mIGFyci5zdWJhcnJheSA9PT0gJ2Z1bmN0aW9uJyAmJiAvLyBjaHJvbWUgOS0xMCBsYWNrIGBzdWJhcnJheWBcbiAgICAgICAgbmV3IFVpbnQ4QXJyYXkoMSkuc3ViYXJyYXkoMSwgMSkuYnl0ZUxlbmd0aCA9PT0gMCAvLyBpZTEwIGhhcyBicm9rZW4gYHN1YmFycmF5YFxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn0pKClcblxuLyoqXG4gKiBDbGFzczogQnVmZmVyXG4gKiA9PT09PT09PT09PT09XG4gKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBhcmUgYXVnbWVudGVkXG4gKiB3aXRoIGZ1bmN0aW9uIHByb3BlcnRpZXMgZm9yIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBBUEkgZnVuY3Rpb25zLiBXZSB1c2VcbiAqIGBVaW50OEFycmF5YCBzbyB0aGF0IHNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0IHJldHVybnNcbiAqIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIEJ5IGF1Z21lbnRpbmcgdGhlIGluc3RhbmNlcywgd2UgY2FuIGF2b2lkIG1vZGlmeWluZyB0aGUgYFVpbnQ4QXJyYXlgXG4gKiBwcm90b3R5cGUuXG4gKi9cbmZ1bmN0aW9uIEJ1ZmZlciAoc3ViamVjdCwgZW5jb2RpbmcsIG5vWmVybykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQnVmZmVyKSlcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihzdWJqZWN0LCBlbmNvZGluZywgbm9aZXJvKVxuXG4gIHZhciB0eXBlID0gdHlwZW9mIHN1YmplY3RcblxuICAvLyBGaW5kIHRoZSBsZW5ndGhcbiAgdmFyIGxlbmd0aFxuICBpZiAodHlwZSA9PT0gJ251bWJlcicpXG4gICAgbGVuZ3RoID0gc3ViamVjdCA+IDAgPyBzdWJqZWN0ID4+PiAwIDogMFxuICBlbHNlIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgIGlmIChlbmNvZGluZyA9PT0gJ2Jhc2U2NCcpXG4gICAgICBzdWJqZWN0ID0gYmFzZTY0Y2xlYW4oc3ViamVjdClcbiAgICBsZW5ndGggPSBCdWZmZXIuYnl0ZUxlbmd0aChzdWJqZWN0LCBlbmNvZGluZylcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnb2JqZWN0JyAmJiBzdWJqZWN0ICE9PSBudWxsKSB7IC8vIGFzc3VtZSBvYmplY3QgaXMgYXJyYXktbGlrZVxuICAgIGlmIChzdWJqZWN0LnR5cGUgPT09ICdCdWZmZXInICYmIGlzQXJyYXkoc3ViamVjdC5kYXRhKSlcbiAgICAgIHN1YmplY3QgPSBzdWJqZWN0LmRhdGFcbiAgICBsZW5ndGggPSArc3ViamVjdC5sZW5ndGggPiAwID8gTWF0aC5mbG9vcigrc3ViamVjdC5sZW5ndGgpIDogMFxuICB9IGVsc2VcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG5lZWRzIHRvIGJlIGEgbnVtYmVyLCBhcnJheSBvciBzdHJpbmcuJylcblxuICB2YXIgYnVmXG4gIGlmIChUWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUHJlZmVycmVkOiBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIGJ1ZiA9IEJ1ZmZlci5fYXVnbWVudChuZXcgVWludDhBcnJheShsZW5ndGgpKVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gVEhJUyBpbnN0YW5jZSBvZiBCdWZmZXIgKGNyZWF0ZWQgYnkgYG5ld2ApXG4gICAgYnVmID0gdGhpc1xuICAgIGJ1Zi5sZW5ndGggPSBsZW5ndGhcbiAgICBidWYuX2lzQnVmZmVyID0gdHJ1ZVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKFRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgdHlwZW9mIHN1YmplY3QuYnl0ZUxlbmd0aCA9PT0gJ251bWJlcicpIHtcbiAgICAvLyBTcGVlZCBvcHRpbWl6YXRpb24gLS0gdXNlIHNldCBpZiB3ZSdyZSBjb3B5aW5nIGZyb20gYSB0eXBlZCBhcnJheVxuICAgIGJ1Zi5fc2V0KHN1YmplY3QpXG4gIH0gZWxzZSBpZiAoaXNBcnJheWlzaChzdWJqZWN0KSkge1xuICAgIC8vIFRyZWF0IGFycmF5LWlzaCBvYmplY3RzIGFzIGEgYnl0ZSBhcnJheVxuICAgIGlmIChCdWZmZXIuaXNCdWZmZXIoc3ViamVjdCkpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKylcbiAgICAgICAgYnVmW2ldID0gc3ViamVjdC5yZWFkVUludDgoaSlcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKVxuICAgICAgICBidWZbaV0gPSAoKHN1YmplY3RbaV0gJSAyNTYpICsgMjU2KSAlIDI1NlxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgIGJ1Zi53cml0ZShzdWJqZWN0LCAwLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJyAmJiAhVFlQRURfQVJSQVlfU1VQUE9SVCAmJiAhbm9aZXJvKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBidWZbaV0gPSAwXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ1ZlxufVxuXG4vLyBTVEFUSUMgTUVUSE9EU1xuLy8gPT09PT09PT09PT09PT1cblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3Jhdyc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIChiKSB7XG4gIHJldHVybiAhIShiICE9IG51bGwgJiYgYi5faXNCdWZmZXIpXG59XG5cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gZnVuY3Rpb24gKHN0ciwgZW5jb2RpbmcpIHtcbiAgdmFyIHJldFxuICBzdHIgPSBzdHIudG9TdHJpbmcoKVxuICBzd2l0Y2ggKGVuY29kaW5nIHx8ICd1dGY4Jykge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgICByZXQgPSBzdHIubGVuZ3RoIC8gMlxuICAgICAgYnJlYWtcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgICByZXQgPSB1dGY4VG9CeXRlcyhzdHIpLmxlbmd0aFxuICAgICAgYnJlYWtcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdyYXcnOlxuICAgICAgcmV0ID0gc3RyLmxlbmd0aFxuICAgICAgYnJlYWtcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgcmV0ID0gYmFzZTY0VG9CeXRlcyhzdHIpLmxlbmd0aFxuICAgICAgYnJlYWtcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0ID0gc3RyLmxlbmd0aCAqIDJcbiAgICAgIGJyZWFrXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZycpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gKGxpc3QsIHRvdGFsTGVuZ3RoKSB7XG4gIGFzc2VydChpc0FycmF5KGxpc3QpLCAnVXNhZ2U6IEJ1ZmZlci5jb25jYXQobGlzdFssIGxlbmd0aF0pJylcblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcigwKVxuICB9IGVsc2UgaWYgKGxpc3QubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIGxpc3RbMF1cbiAgfVxuXG4gIHZhciBpXG4gIGlmICh0b3RhbExlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdG90YWxMZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRvdGFsTGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZiA9IG5ldyBCdWZmZXIodG90YWxMZW5ndGgpXG4gIHZhciBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBsaXN0W2ldXG4gICAgaXRlbS5jb3B5KGJ1ZiwgcG9zKVxuICAgIHBvcyArPSBpdGVtLmxlbmd0aFxuICB9XG4gIHJldHVybiBidWZcbn1cblxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiAoYSwgYikge1xuICBhc3NlcnQoQnVmZmVyLmlzQnVmZmVyKGEpICYmIEJ1ZmZlci5pc0J1ZmZlcihiKSwgJ0FyZ3VtZW50cyBtdXN0IGJlIEJ1ZmZlcnMnKVxuICB2YXIgeCA9IGEubGVuZ3RoXG4gIHZhciB5ID0gYi5sZW5ndGhcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuICYmIGFbaV0gPT09IGJbaV07IGkrKykge31cbiAgaWYgKGkgIT09IGxlbikge1xuICAgIHggPSBhW2ldXG4gICAgeSA9IGJbaV1cbiAgfVxuICBpZiAoeCA8IHkpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICBpZiAoeSA8IHgpIHtcbiAgICByZXR1cm4gMVxuICB9XG4gIHJldHVybiAwXG59XG5cbi8vIEJVRkZFUiBJTlNUQU5DRSBNRVRIT0RTXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PVxuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIC8vIG11c3QgYmUgYW4gZXZlbiBudW1iZXIgb2YgZGlnaXRzXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGFzc2VydChzdHJMZW4gJSAyID09PSAwLCAnSW52YWxpZCBoZXggc3RyaW5nJylcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDJcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGJ5dGUgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXG4gICAgYXNzZXJ0KCFpc05hTihieXRlKSwgJ0ludmFsaWQgaGV4IHN0cmluZycpXG4gICAgYnVmW29mZnNldCArIGldID0gYnl0ZVxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHZhciBjaGFyc1dyaXR0ZW4gPSBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG4gIHJldHVybiBjaGFyc1dyaXR0ZW5cbn1cblxuZnVuY3Rpb24gYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHZhciBjaGFyc1dyaXR0ZW4gPSBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxuICByZXR1cm4gY2hhcnNXcml0dGVuXG59XG5cbmZ1bmN0aW9uIGJpbmFyeVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGFzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHZhciBjaGFyc1dyaXR0ZW4gPSBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbiAgcmV0dXJuIGNoYXJzV3JpdHRlblxufVxuXG5mdW5jdGlvbiB1dGYxNmxlV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgY2hhcnNXcml0dGVuID0gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxuICByZXR1cm4gY2hhcnNXcml0dGVuXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gU3VwcG9ydCBib3RoIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZylcbiAgLy8gYW5kIHRoZSBsZWdhY3kgKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIGlmICghaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGhcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgfSBlbHNlIHsgIC8vIGxlZ2FjeVxuICAgIHZhciBzd2FwID0gZW5jb2RpbmdcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIG9mZnNldCA9IGxlbmd0aFxuICAgIGxlbmd0aCA9IHN3YXBcbiAgfVxuXG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cbiAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcgfHwgJ3V0ZjgnKS50b0xvd2VyQ2FzZSgpXG5cbiAgdmFyIHJldFxuICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICAgIHJldCA9IGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIHJldCA9IHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgICByZXQgPSBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICByZXQgPSBiaW5hcnlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgcmV0ID0gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldCA9IHV0ZjE2bGVXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nJylcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG5cbiAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcgfHwgJ3V0ZjgnKS50b0xvd2VyQ2FzZSgpXG4gIHN0YXJ0ID0gTnVtYmVyKHN0YXJ0KSB8fCAwXG4gIGVuZCA9IChlbmQgPT09IHVuZGVmaW5lZCkgPyBzZWxmLmxlbmd0aCA6IE51bWJlcihlbmQpXG5cbiAgLy8gRmFzdHBhdGggZW1wdHkgc3RyaW5nc1xuICBpZiAoZW5kID09PSBzdGFydClcbiAgICByZXR1cm4gJydcblxuICB2YXIgcmV0XG4gIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgICAgcmV0ID0gaGV4U2xpY2Uoc2VsZiwgc3RhcnQsIGVuZClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgICAgcmV0ID0gdXRmOFNsaWNlKHNlbGYsIHN0YXJ0LCBlbmQpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIHJldCA9IGFzY2lpU2xpY2Uoc2VsZiwgc3RhcnQsIGVuZClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgIHJldCA9IGJpbmFyeVNsaWNlKHNlbGYsIHN0YXJ0LCBlbmQpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICByZXQgPSBiYXNlNjRTbGljZShzZWxmLCBzdGFydCwgZW5kKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0ID0gdXRmMTZsZVNsaWNlKHNlbGYsIHN0YXJ0LCBlbmQpXG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2RpbmcnKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiAoYikge1xuICBhc3NlcnQoQnVmZmVyLmlzQnVmZmVyKGIpLCAnQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiAoYikge1xuICBhc3NlcnQoQnVmZmVyLmlzQnVmZmVyKGIpLCAnQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAodGFyZ2V0LCB0YXJnZXRfc3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHNvdXJjZSA9IHRoaXNcblxuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAoIXRhcmdldF9zdGFydCkgdGFyZ2V0X3N0YXJ0ID0gMFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHNvdXJjZS5sZW5ndGggPT09IDApIHJldHVyblxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgYXNzZXJ0KGVuZCA+PSBzdGFydCwgJ3NvdXJjZUVuZCA8IHNvdXJjZVN0YXJ0JylcbiAgYXNzZXJ0KHRhcmdldF9zdGFydCA+PSAwICYmIHRhcmdldF9zdGFydCA8IHRhcmdldC5sZW5ndGgsXG4gICAgICAndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGFzc2VydChzdGFydCA+PSAwICYmIHN0YXJ0IDwgc291cmNlLmxlbmd0aCwgJ3NvdXJjZVN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBhc3NlcnQoZW5kID49IDAgJiYgZW5kIDw9IHNvdXJjZS5sZW5ndGgsICdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKVxuICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0X3N0YXJ0IDwgZW5kIC0gc3RhcnQpXG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldF9zdGFydCArIHN0YXJ0XG5cbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XG5cbiAgaWYgKGxlbiA8IDEwMCB8fCAhVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0X3N0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0YXJnZXQuX3NldCh0aGlzLnN1YmFycmF5KHN0YXJ0LCBzdGFydCArIGxlbiksIHRhcmdldF9zdGFydClcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJlcyA9ICcnXG4gIHZhciB0bXAgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICBpZiAoYnVmW2ldIDw9IDB4N0YpIHtcbiAgICAgIHJlcyArPSBkZWNvZGVVdGY4Q2hhcih0bXApICsgU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gICAgICB0bXAgPSAnJ1xuICAgIH0gZWxzZSB7XG4gICAgICB0bXAgKz0gJyUnICsgYnVmW2ldLnRvU3RyaW5nKDE2KVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXMgKyBkZWNvZGVVdGY4Q2hhcih0bXApXG59XG5cbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gYmluYXJ5U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICByZXR1cm4gYXNjaWlTbGljZShidWYsIHN0YXJ0LCBlbmQpXG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cblxuICB2YXIgb3V0ID0gJydcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICBvdXQgKz0gdG9IZXgoYnVmW2ldKVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHZhciByZXMgPSAnJ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyBieXRlc1tpICsgMV0gKiAyNTYpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gfn5zdGFydFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kXG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlbjtcbiAgICBpZiAoc3RhcnQgPCAwKVxuICAgICAgc3RhcnQgPSAwXG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuXG4gICAgaWYgKGVuZCA8IDApXG4gICAgICBlbmQgPSAwXG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpXG4gICAgZW5kID0gc3RhcnRcblxuICBpZiAoVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHJldHVybiBCdWZmZXIuX2F1Z21lbnQodGhpcy5zdWJhcnJheShzdGFydCwgZW5kKSlcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2xpY2VMZW4gPSBlbmQgLSBzdGFydFxuICAgIHZhciBuZXdCdWYgPSBuZXcgQnVmZmVyKHNsaWNlTGVuLCB1bmRlZmluZWQsIHRydWUpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbGljZUxlbjsgaSsrKSB7XG4gICAgICBuZXdCdWZbaV0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gICAgcmV0dXJuIG5ld0J1ZlxuICB9XG59XG5cbi8vIGBnZXRgIHdpbGwgYmUgcmVtb3ZlZCBpbiBOb2RlIDAuMTMrXG5CdWZmZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgY29uc29sZS5sb2coJy5nZXQoKSBpcyBkZXByZWNhdGVkLiBBY2Nlc3MgdXNpbmcgYXJyYXkgaW5kZXhlcyBpbnN0ZWFkLicpXG4gIHJldHVybiB0aGlzLnJlYWRVSW50OChvZmZzZXQpXG59XG5cbi8vIGBzZXRgIHdpbGwgYmUgcmVtb3ZlZCBpbiBOb2RlIDAuMTMrXG5CdWZmZXIucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh2LCBvZmZzZXQpIHtcbiAgY29uc29sZS5sb2coJy5zZXQoKSBpcyBkZXByZWNhdGVkLiBBY2Nlc3MgdXNpbmcgYXJyYXkgaW5kZXhlcyBpbnN0ZWFkLicpXG4gIHJldHVybiB0aGlzLndyaXRlVUludDgodiwgb2Zmc2V0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgPCB0aGlzLmxlbmd0aCwgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgfVxuXG4gIGlmIChvZmZzZXQgPj0gdGhpcy5sZW5ndGgpXG4gICAgcmV0dXJuXG5cbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5mdW5jdGlvbiByZWFkVUludDE2IChidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDEgPCBidWYubGVuZ3RoLCAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgdmFyIHZhbFxuICBpZiAobGl0dGxlRW5kaWFuKSB7XG4gICAgdmFsID0gYnVmW29mZnNldF1cbiAgICBpZiAob2Zmc2V0ICsgMSA8IGxlbilcbiAgICAgIHZhbCB8PSBidWZbb2Zmc2V0ICsgMV0gPDwgOFxuICB9IGVsc2Uge1xuICAgIHZhbCA9IGJ1ZltvZmZzZXRdIDw8IDhcbiAgICBpZiAob2Zmc2V0ICsgMSA8IGxlbilcbiAgICAgIHZhbCB8PSBidWZbb2Zmc2V0ICsgMV1cbiAgfVxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRVSW50MTYodGhpcywgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZFVJbnQxNih0aGlzLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gcmVhZFVJbnQzMiAoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyAzIDwgYnVmLmxlbmd0aCwgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIHZhciB2YWxcbiAgaWYgKGxpdHRsZUVuZGlhbikge1xuICAgIGlmIChvZmZzZXQgKyAyIDwgbGVuKVxuICAgICAgdmFsID0gYnVmW29mZnNldCArIDJdIDw8IDE2XG4gICAgaWYgKG9mZnNldCArIDEgPCBsZW4pXG4gICAgICB2YWwgfD0gYnVmW29mZnNldCArIDFdIDw8IDhcbiAgICB2YWwgfD0gYnVmW29mZnNldF1cbiAgICBpZiAob2Zmc2V0ICsgMyA8IGxlbilcbiAgICAgIHZhbCA9IHZhbCArIChidWZbb2Zmc2V0ICsgM10gPDwgMjQgPj4+IDApXG4gIH0gZWxzZSB7XG4gICAgaWYgKG9mZnNldCArIDEgPCBsZW4pXG4gICAgICB2YWwgPSBidWZbb2Zmc2V0ICsgMV0gPDwgMTZcbiAgICBpZiAob2Zmc2V0ICsgMiA8IGxlbilcbiAgICAgIHZhbCB8PSBidWZbb2Zmc2V0ICsgMl0gPDwgOFxuICAgIGlmIChvZmZzZXQgKyAzIDwgbGVuKVxuICAgICAgdmFsIHw9IGJ1ZltvZmZzZXQgKyAzXVxuICAgIHZhbCA9IHZhbCArIChidWZbb2Zmc2V0XSA8PCAyNCA+Pj4gMClcbiAgfVxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRVSW50MzIodGhpcywgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZFVJbnQzMih0aGlzLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgPCB0aGlzLmxlbmd0aCwgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgfVxuXG4gIGlmIChvZmZzZXQgPj0gdGhpcy5sZW5ndGgpXG4gICAgcmV0dXJuXG5cbiAgdmFyIG5lZyA9IHRoaXNbb2Zmc2V0XSAmIDB4ODBcbiAgaWYgKG5lZylcbiAgICByZXR1cm4gKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xXG4gIGVsc2VcbiAgICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbmZ1bmN0aW9uIHJlYWRJbnQxNiAoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyAxIDwgYnVmLmxlbmd0aCwgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIHZhciB2YWwgPSByZWFkVUludDE2KGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIHRydWUpXG4gIHZhciBuZWcgPSB2YWwgJiAweDgwMDBcbiAgaWYgKG5lZylcbiAgICByZXR1cm4gKDB4ZmZmZiAtIHZhbCArIDEpICogLTFcbiAgZWxzZVxuICAgIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkSW50MTYodGhpcywgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkSW50MTYodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHJlYWRJbnQzMiAoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyAzIDwgYnVmLmxlbmd0aCwgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIHZhciB2YWwgPSByZWFkVUludDMyKGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIHRydWUpXG4gIHZhciBuZWcgPSB2YWwgJiAweDgwMDAwMDAwXG4gIGlmIChuZWcpXG4gICAgcmV0dXJuICgweGZmZmZmZmZmIC0gdmFsICsgMSkgKiAtMVxuICBlbHNlXG4gICAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRJbnQzMih0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRJbnQzMih0aGlzLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gcmVhZEZsb2F0IChidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgKyAzIDwgYnVmLmxlbmd0aCwgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgfVxuXG4gIHJldHVybiBpZWVlNzU0LnJlYWQoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZEZsb2F0KHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZEZsb2F0KHRoaXMsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiByZWFkRG91YmxlIChidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgKyA3IDwgYnVmLmxlbmd0aCwgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgfVxuXG4gIHJldHVybiBpZWVlNzU0LnJlYWQoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWREb3VibGUodGhpcywgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZERvdWJsZSh0aGlzLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCwgJ21pc3NpbmcgdmFsdWUnKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCA8IHRoaXMubGVuZ3RoLCAndHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgICB2ZXJpZnVpbnQodmFsdWUsIDB4ZmYpXG4gIH1cblxuICBpZiAob2Zmc2V0ID49IHRoaXMubGVuZ3RoKSByZXR1cm5cblxuICB0aGlzW29mZnNldF0gPSB2YWx1ZVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5mdW5jdGlvbiB3cml0ZVVJbnQxNiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCwgJ21pc3NpbmcgdmFsdWUnKVxuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyAxIDwgYnVmLmxlbmd0aCwgJ3RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gICAgdmVyaWZ1aW50KHZhbHVlLCAweGZmZmYpXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGxlbiAtIG9mZnNldCwgMik7IGkgPCBqOyBpKyspIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPVxuICAgICAgICAodmFsdWUgJiAoMHhmZiA8PCAoOCAqIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpKSkpID4+PlxuICAgICAgICAgICAgKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkgKiA4XG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlVUludDMyIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLCAnbWlzc2luZyB2YWx1ZScpXG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDMgPCBidWYubGVuZ3RoLCAndHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgICB2ZXJpZnVpbnQodmFsdWUsIDB4ZmZmZmZmZmYpXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGxlbiAtIG9mZnNldCwgNCk7IGkgPCBqOyBpKyspIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPVxuICAgICAgICAodmFsdWUgPj4+IChsaXR0bGVFbmRpYW4gPyBpIDogMyAtIGkpICogOCkgJiAweGZmXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCwgJ21pc3NpbmcgdmFsdWUnKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCA8IHRoaXMubGVuZ3RoLCAnVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgICB2ZXJpZnNpbnQodmFsdWUsIDB4N2YsIC0weDgwKVxuICB9XG5cbiAgaWYgKG9mZnNldCA+PSB0aGlzLmxlbmd0aClcbiAgICByZXR1cm5cblxuICBpZiAodmFsdWUgPj0gMClcbiAgICB0aGlzLndyaXRlVUludDgodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpXG4gIGVsc2VcbiAgICB0aGlzLndyaXRlVUludDgoMHhmZiArIHZhbHVlICsgMSwgb2Zmc2V0LCBub0Fzc2VydClcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuZnVuY3Rpb24gd3JpdGVJbnQxNiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCwgJ21pc3NpbmcgdmFsdWUnKVxuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyAxIDwgYnVmLmxlbmd0aCwgJ1RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gICAgdmVyaWZzaW50KHZhbHVlLCAweDdmZmYsIC0weDgwMDApXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICBpZiAodmFsdWUgPj0gMClcbiAgICB3cml0ZVVJbnQxNihidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpXG4gIGVsc2VcbiAgICB3cml0ZVVJbnQxNihidWYsIDB4ZmZmZiArIHZhbHVlICsgMSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZUludDMyIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLCAnbWlzc2luZyB2YWx1ZScpXG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDMgPCBidWYubGVuZ3RoLCAnVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgICB2ZXJpZnNpbnQodmFsdWUsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgaWYgKHZhbHVlID49IDApXG4gICAgd3JpdGVVSW50MzIoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KVxuICBlbHNlXG4gICAgd3JpdGVVSW50MzIoYnVmLCAweGZmZmZmZmZmICsgdmFsdWUgKyAxLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsICdtaXNzaW5nIHZhbHVlJylcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMyA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICAgIHZlcmlmSUVFRTc1NCh2YWx1ZSwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsICdtaXNzaW5nIHZhbHVlJylcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgNyA8IGJ1Zi5sZW5ndGgsXG4gICAgICAgICdUcnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICAgIHZlcmlmSUVFRTc1NCh2YWx1ZSwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gZmlsbCh2YWx1ZSwgc3RhcnQ9MCwgZW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiAodmFsdWUsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCF2YWx1ZSkgdmFsdWUgPSAwXG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCkgZW5kID0gdGhpcy5sZW5ndGhcblxuICBhc3NlcnQoZW5kID49IHN0YXJ0LCAnZW5kIDwgc3RhcnQnKVxuXG4gIC8vIEZpbGwgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuXG4gIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuXG5cbiAgYXNzZXJ0KHN0YXJ0ID49IDAgJiYgc3RhcnQgPCB0aGlzLmxlbmd0aCwgJ3N0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBhc3NlcnQoZW5kID49IDAgJiYgZW5kIDw9IHRoaXMubGVuZ3RoLCAnZW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIHZhciBpXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgdGhpc1tpXSA9IHZhbHVlXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBieXRlcyA9IHV0ZjhUb0J5dGVzKHZhbHVlLnRvU3RyaW5nKCkpXG4gICAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aFxuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgIHRoaXNbaV0gPSBieXRlc1tpICUgbGVuXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG91dCA9IFtdXG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgb3V0W2ldID0gdG9IZXgodGhpc1tpXSlcbiAgICBpZiAoaSA9PT0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUykge1xuICAgICAgb3V0W2kgKyAxXSA9ICcuLi4nXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuICByZXR1cm4gJzxCdWZmZXIgJyArIG91dC5qb2luKCcgJykgKyAnPidcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGBBcnJheUJ1ZmZlcmAgd2l0aCB0aGUgKmNvcGllZCogbWVtb3J5IG9mIHRoZSBidWZmZXIgaW5zdGFuY2UuXG4gKiBBZGRlZCBpbiBOb2RlIDAuMTIuIE9ubHkgYXZhaWxhYmxlIGluIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBBcnJheUJ1ZmZlci5cbiAqL1xuQnVmZmVyLnByb3RvdHlwZS50b0FycmF5QnVmZmVyID0gZnVuY3Rpb24gKCkge1xuICBpZiAodHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKFRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAgIHJldHVybiAobmV3IEJ1ZmZlcih0aGlzKSkuYnVmZmVyXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBidWYgPSBuZXcgVWludDhBcnJheSh0aGlzLmxlbmd0aClcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBidWYubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgYnVmW2ldID0gdGhpc1tpXVxuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1Zi5idWZmZXJcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdCdWZmZXIudG9BcnJheUJ1ZmZlciBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3NlcicpXG4gIH1cbn1cblxuLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG52YXIgQlAgPSBCdWZmZXIucHJvdG90eXBlXG5cbi8qKlxuICogQXVnbWVudCBhIFVpbnQ4QXJyYXkgKmluc3RhbmNlKiAobm90IHRoZSBVaW50OEFycmF5IGNsYXNzISkgd2l0aCBCdWZmZXIgbWV0aG9kc1xuICovXG5CdWZmZXIuX2F1Z21lbnQgPSBmdW5jdGlvbiAoYXJyKSB7XG4gIGFyci5faXNCdWZmZXIgPSB0cnVlXG5cbiAgLy8gc2F2ZSByZWZlcmVuY2UgdG8gb3JpZ2luYWwgVWludDhBcnJheSBnZXQvc2V0IG1ldGhvZHMgYmVmb3JlIG92ZXJ3cml0aW5nXG4gIGFyci5fZ2V0ID0gYXJyLmdldFxuICBhcnIuX3NldCA9IGFyci5zZXRcblxuICAvLyBkZXByZWNhdGVkLCB3aWxsIGJlIHJlbW92ZWQgaW4gbm9kZSAwLjEzK1xuICBhcnIuZ2V0ID0gQlAuZ2V0XG4gIGFyci5zZXQgPSBCUC5zZXRcblxuICBhcnIud3JpdGUgPSBCUC53cml0ZVxuICBhcnIudG9TdHJpbmcgPSBCUC50b1N0cmluZ1xuICBhcnIudG9Mb2NhbGVTdHJpbmcgPSBCUC50b1N0cmluZ1xuICBhcnIudG9KU09OID0gQlAudG9KU09OXG4gIGFyci5lcXVhbHMgPSBCUC5lcXVhbHNcbiAgYXJyLmNvbXBhcmUgPSBCUC5jb21wYXJlXG4gIGFyci5jb3B5ID0gQlAuY29weVxuICBhcnIuc2xpY2UgPSBCUC5zbGljZVxuICBhcnIucmVhZFVJbnQ4ID0gQlAucmVhZFVJbnQ4XG4gIGFyci5yZWFkVUludDE2TEUgPSBCUC5yZWFkVUludDE2TEVcbiAgYXJyLnJlYWRVSW50MTZCRSA9IEJQLnJlYWRVSW50MTZCRVxuICBhcnIucmVhZFVJbnQzMkxFID0gQlAucmVhZFVJbnQzMkxFXG4gIGFyci5yZWFkVUludDMyQkUgPSBCUC5yZWFkVUludDMyQkVcbiAgYXJyLnJlYWRJbnQ4ID0gQlAucmVhZEludDhcbiAgYXJyLnJlYWRJbnQxNkxFID0gQlAucmVhZEludDE2TEVcbiAgYXJyLnJlYWRJbnQxNkJFID0gQlAucmVhZEludDE2QkVcbiAgYXJyLnJlYWRJbnQzMkxFID0gQlAucmVhZEludDMyTEVcbiAgYXJyLnJlYWRJbnQzMkJFID0gQlAucmVhZEludDMyQkVcbiAgYXJyLnJlYWRGbG9hdExFID0gQlAucmVhZEZsb2F0TEVcbiAgYXJyLnJlYWRGbG9hdEJFID0gQlAucmVhZEZsb2F0QkVcbiAgYXJyLnJlYWREb3VibGVMRSA9IEJQLnJlYWREb3VibGVMRVxuICBhcnIucmVhZERvdWJsZUJFID0gQlAucmVhZERvdWJsZUJFXG4gIGFyci53cml0ZVVJbnQ4ID0gQlAud3JpdGVVSW50OFxuICBhcnIud3JpdGVVSW50MTZMRSA9IEJQLndyaXRlVUludDE2TEVcbiAgYXJyLndyaXRlVUludDE2QkUgPSBCUC53cml0ZVVJbnQxNkJFXG4gIGFyci53cml0ZVVJbnQzMkxFID0gQlAud3JpdGVVSW50MzJMRVxuICBhcnIud3JpdGVVSW50MzJCRSA9IEJQLndyaXRlVUludDMyQkVcbiAgYXJyLndyaXRlSW50OCA9IEJQLndyaXRlSW50OFxuICBhcnIud3JpdGVJbnQxNkxFID0gQlAud3JpdGVJbnQxNkxFXG4gIGFyci53cml0ZUludDE2QkUgPSBCUC53cml0ZUludDE2QkVcbiAgYXJyLndyaXRlSW50MzJMRSA9IEJQLndyaXRlSW50MzJMRVxuICBhcnIud3JpdGVJbnQzMkJFID0gQlAud3JpdGVJbnQzMkJFXG4gIGFyci53cml0ZUZsb2F0TEUgPSBCUC53cml0ZUZsb2F0TEVcbiAgYXJyLndyaXRlRmxvYXRCRSA9IEJQLndyaXRlRmxvYXRCRVxuICBhcnIud3JpdGVEb3VibGVMRSA9IEJQLndyaXRlRG91YmxlTEVcbiAgYXJyLndyaXRlRG91YmxlQkUgPSBCUC53cml0ZURvdWJsZUJFXG4gIGFyci5maWxsID0gQlAuZmlsbFxuICBhcnIuaW5zcGVjdCA9IEJQLmluc3BlY3RcbiAgYXJyLnRvQXJyYXlCdWZmZXIgPSBCUC50b0FycmF5QnVmZmVyXG5cbiAgcmV0dXJuIGFyclxufVxuXG52YXIgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rXFwvMC05QS16XS9nXG5cbmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHN0ciA9IHN0cmluZ3RyaW0oc3RyKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJylcbiAgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgIHN0ciA9IHN0ciArICc9J1xuICB9XG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gc3RyaW5ndHJpbSAoc3RyKSB7XG4gIGlmIChzdHIudHJpbSkgcmV0dXJuIHN0ci50cmltKClcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJylcbn1cblxuZnVuY3Rpb24gaXNBcnJheSAoc3ViamVjdCkge1xuICByZXR1cm4gKEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHN1YmplY3QpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHN1YmplY3QpID09PSAnW29iamVjdCBBcnJheV0nXG4gIH0pKHN1YmplY3QpXG59XG5cbmZ1bmN0aW9uIGlzQXJyYXlpc2ggKHN1YmplY3QpIHtcbiAgcmV0dXJuIGlzQXJyYXkoc3ViamVjdCkgfHwgQnVmZmVyLmlzQnVmZmVyKHN1YmplY3QpIHx8XG4gICAgICBzdWJqZWN0ICYmIHR5cGVvZiBzdWJqZWN0ID09PSAnb2JqZWN0JyAmJlxuICAgICAgdHlwZW9mIHN1YmplY3QubGVuZ3RoID09PSAnbnVtYmVyJ1xufVxuXG5mdW5jdGlvbiB0b0hleCAobikge1xuICBpZiAobiA8IDE2KSByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNilcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGIgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGlmIChiIDw9IDB4N0YpIHtcbiAgICAgIGJ5dGVBcnJheS5wdXNoKGIpXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBzdGFydCA9IGlcbiAgICAgIGlmIChiID49IDB4RDgwMCAmJiBiIDw9IDB4REZGRikgaSsrXG4gICAgICB2YXIgaCA9IGVuY29kZVVSSUNvbXBvbmVudChzdHIuc2xpY2Uoc3RhcnQsIGkrMSkpLnN1YnN0cigxKS5zcGxpdCgnJScpXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGgubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgYnl0ZUFycmF5LnB1c2gocGFyc2VJbnQoaFtqXSwgMTYpKVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGMsIGhpLCBsb1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShzdHIpXG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKVxuICAgICAgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiBkZWNvZGVVdGY4Q2hhciAoc3RyKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChzdHIpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RkZGRCkgLy8gVVRGIDggaW52YWxpZCBjaGFyXG4gIH1cbn1cblxuLypcbiAqIFdlIGhhdmUgdG8gbWFrZSBzdXJlIHRoYXQgdGhlIHZhbHVlIGlzIGEgdmFsaWQgaW50ZWdlci4gVGhpcyBtZWFucyB0aGF0IGl0XG4gKiBpcyBub24tbmVnYXRpdmUuIEl0IGhhcyBubyBmcmFjdGlvbmFsIGNvbXBvbmVudCBhbmQgdGhhdCBpdCBkb2VzIG5vdFxuICogZXhjZWVkIHRoZSBtYXhpbXVtIGFsbG93ZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHZlcmlmdWludCAodmFsdWUsIG1heCkge1xuICBhc3NlcnQodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJywgJ2Nhbm5vdCB3cml0ZSBhIG5vbi1udW1iZXIgYXMgYSBudW1iZXInKVxuICBhc3NlcnQodmFsdWUgPj0gMCwgJ3NwZWNpZmllZCBhIG5lZ2F0aXZlIHZhbHVlIGZvciB3cml0aW5nIGFuIHVuc2lnbmVkIHZhbHVlJylcbiAgYXNzZXJ0KHZhbHVlIDw9IG1heCwgJ3ZhbHVlIGlzIGxhcmdlciB0aGFuIG1heGltdW0gdmFsdWUgZm9yIHR5cGUnKVxuICBhc3NlcnQoTWF0aC5mbG9vcih2YWx1ZSkgPT09IHZhbHVlLCAndmFsdWUgaGFzIGEgZnJhY3Rpb25hbCBjb21wb25lbnQnKVxufVxuXG5mdW5jdGlvbiB2ZXJpZnNpbnQgKHZhbHVlLCBtYXgsIG1pbikge1xuICBhc3NlcnQodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJywgJ2Nhbm5vdCB3cml0ZSBhIG5vbi1udW1iZXIgYXMgYSBudW1iZXInKVxuICBhc3NlcnQodmFsdWUgPD0gbWF4LCAndmFsdWUgbGFyZ2VyIHRoYW4gbWF4aW11bSBhbGxvd2VkIHZhbHVlJylcbiAgYXNzZXJ0KHZhbHVlID49IG1pbiwgJ3ZhbHVlIHNtYWxsZXIgdGhhbiBtaW5pbXVtIGFsbG93ZWQgdmFsdWUnKVxuICBhc3NlcnQoTWF0aC5mbG9vcih2YWx1ZSkgPT09IHZhbHVlLCAndmFsdWUgaGFzIGEgZnJhY3Rpb25hbCBjb21wb25lbnQnKVxufVxuXG5mdW5jdGlvbiB2ZXJpZklFRUU3NTQgKHZhbHVlLCBtYXgsIG1pbikge1xuICBhc3NlcnQodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJywgJ2Nhbm5vdCB3cml0ZSBhIG5vbi1udW1iZXIgYXMgYSBudW1iZXInKVxuICBhc3NlcnQodmFsdWUgPD0gbWF4LCAndmFsdWUgbGFyZ2VyIHRoYW4gbWF4aW11bSBhbGxvd2VkIHZhbHVlJylcbiAgYXNzZXJ0KHZhbHVlID49IG1pbiwgJ3ZhbHVlIHNtYWxsZXIgdGhhbiBtaW5pbXVtIGFsbG93ZWQgdmFsdWUnKVxufVxuXG5mdW5jdGlvbiBhc3NlcnQgKHRlc3QsIG1lc3NhZ2UpIHtcbiAgaWYgKCF0ZXN0KSB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSB8fCAnRmFpbGVkIGFzc2VydGlvbicpXG59XG4iLCJ2YXIgbG9va3VwID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nO1xuXG47KGZ1bmN0aW9uIChleHBvcnRzKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuICB2YXIgQXJyID0gKHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJylcbiAgICA/IFVpbnQ4QXJyYXlcbiAgICA6IEFycmF5XG5cblx0dmFyIFBMVVMgICA9ICcrJy5jaGFyQ29kZUF0KDApXG5cdHZhciBTTEFTSCAgPSAnLycuY2hhckNvZGVBdCgwKVxuXHR2YXIgTlVNQkVSID0gJzAnLmNoYXJDb2RlQXQoMClcblx0dmFyIExPV0VSICA9ICdhJy5jaGFyQ29kZUF0KDApXG5cdHZhciBVUFBFUiAgPSAnQScuY2hhckNvZGVBdCgwKVxuXG5cdGZ1bmN0aW9uIGRlY29kZSAoZWx0KSB7XG5cdFx0dmFyIGNvZGUgPSBlbHQuY2hhckNvZGVBdCgwKVxuXHRcdGlmIChjb2RlID09PSBQTFVTKVxuXHRcdFx0cmV0dXJuIDYyIC8vICcrJ1xuXHRcdGlmIChjb2RlID09PSBTTEFTSClcblx0XHRcdHJldHVybiA2MyAvLyAnLydcblx0XHRpZiAoY29kZSA8IE5VTUJFUilcblx0XHRcdHJldHVybiAtMSAvL25vIG1hdGNoXG5cdFx0aWYgKGNvZGUgPCBOVU1CRVIgKyAxMClcblx0XHRcdHJldHVybiBjb2RlIC0gTlVNQkVSICsgMjYgKyAyNlxuXHRcdGlmIChjb2RlIDwgVVBQRVIgKyAyNilcblx0XHRcdHJldHVybiBjb2RlIC0gVVBQRVJcblx0XHRpZiAoY29kZSA8IExPV0VSICsgMjYpXG5cdFx0XHRyZXR1cm4gY29kZSAtIExPV0VSICsgMjZcblx0fVxuXG5cdGZ1bmN0aW9uIGI2NFRvQnl0ZUFycmF5IChiNjQpIHtcblx0XHR2YXIgaSwgaiwgbCwgdG1wLCBwbGFjZUhvbGRlcnMsIGFyclxuXG5cdFx0aWYgKGI2NC5sZW5ndGggJSA0ID4gMCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0Jylcblx0XHR9XG5cblx0XHQvLyB0aGUgbnVtYmVyIG9mIGVxdWFsIHNpZ25zIChwbGFjZSBob2xkZXJzKVxuXHRcdC8vIGlmIHRoZXJlIGFyZSB0d28gcGxhY2Vob2xkZXJzLCB0aGFuIHRoZSB0d28gY2hhcmFjdGVycyBiZWZvcmUgaXRcblx0XHQvLyByZXByZXNlbnQgb25lIGJ5dGVcblx0XHQvLyBpZiB0aGVyZSBpcyBvbmx5IG9uZSwgdGhlbiB0aGUgdGhyZWUgY2hhcmFjdGVycyBiZWZvcmUgaXQgcmVwcmVzZW50IDIgYnl0ZXNcblx0XHQvLyB0aGlzIGlzIGp1c3QgYSBjaGVhcCBoYWNrIHRvIG5vdCBkbyBpbmRleE9mIHR3aWNlXG5cdFx0dmFyIGxlbiA9IGI2NC5sZW5ndGhcblx0XHRwbGFjZUhvbGRlcnMgPSAnPScgPT09IGI2NC5jaGFyQXQobGVuIC0gMikgPyAyIDogJz0nID09PSBiNjQuY2hhckF0KGxlbiAtIDEpID8gMSA6IDBcblxuXHRcdC8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuXHRcdGFyciA9IG5ldyBBcnIoYjY0Lmxlbmd0aCAqIDMgLyA0IC0gcGxhY2VIb2xkZXJzKVxuXG5cdFx0Ly8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuXHRcdGwgPSBwbGFjZUhvbGRlcnMgPiAwID8gYjY0Lmxlbmd0aCAtIDQgOiBiNjQubGVuZ3RoXG5cblx0XHR2YXIgTCA9IDBcblxuXHRcdGZ1bmN0aW9uIHB1c2ggKHYpIHtcblx0XHRcdGFycltMKytdID0gdlxuXHRcdH1cblxuXHRcdGZvciAoaSA9IDAsIGogPSAwOyBpIDwgbDsgaSArPSA0LCBqICs9IDMpIHtcblx0XHRcdHRtcCA9IChkZWNvZGUoYjY0LmNoYXJBdChpKSkgPDwgMTgpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAxKSkgPDwgMTIpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAyKSkgPDwgNikgfCBkZWNvZGUoYjY0LmNoYXJBdChpICsgMykpXG5cdFx0XHRwdXNoKCh0bXAgJiAweEZGMDAwMCkgPj4gMTYpXG5cdFx0XHRwdXNoKCh0bXAgJiAweEZGMDApID4+IDgpXG5cdFx0XHRwdXNoKHRtcCAmIDB4RkYpXG5cdFx0fVxuXG5cdFx0aWYgKHBsYWNlSG9sZGVycyA9PT0gMikge1xuXHRcdFx0dG1wID0gKGRlY29kZShiNjQuY2hhckF0KGkpKSA8PCAyKSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMSkpID4+IDQpXG5cdFx0XHRwdXNoKHRtcCAmIDB4RkYpXG5cdFx0fSBlbHNlIGlmIChwbGFjZUhvbGRlcnMgPT09IDEpIHtcblx0XHRcdHRtcCA9IChkZWNvZGUoYjY0LmNoYXJBdChpKSkgPDwgMTApIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAxKSkgPDwgNCkgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDIpKSA+PiAyKVxuXHRcdFx0cHVzaCgodG1wID4+IDgpICYgMHhGRilcblx0XHRcdHB1c2godG1wICYgMHhGRilcblx0XHR9XG5cblx0XHRyZXR1cm4gYXJyXG5cdH1cblxuXHRmdW5jdGlvbiB1aW50OFRvQmFzZTY0ICh1aW50OCkge1xuXHRcdHZhciBpLFxuXHRcdFx0ZXh0cmFCeXRlcyA9IHVpbnQ4Lmxlbmd0aCAlIDMsIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG5cdFx0XHRvdXRwdXQgPSBcIlwiLFxuXHRcdFx0dGVtcCwgbGVuZ3RoXG5cblx0XHRmdW5jdGlvbiBlbmNvZGUgKG51bSkge1xuXHRcdFx0cmV0dXJuIGxvb2t1cC5jaGFyQXQobnVtKVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG5cdFx0XHRyZXR1cm4gZW5jb2RlKG51bSA+PiAxOCAmIDB4M0YpICsgZW5jb2RlKG51bSA+PiAxMiAmIDB4M0YpICsgZW5jb2RlKG51bSA+PiA2ICYgMHgzRikgKyBlbmNvZGUobnVtICYgMHgzRilcblx0XHR9XG5cblx0XHQvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG5cdFx0Zm9yIChpID0gMCwgbGVuZ3RoID0gdWludDgubGVuZ3RoIC0gZXh0cmFCeXRlczsgaSA8IGxlbmd0aDsgaSArPSAzKSB7XG5cdFx0XHR0ZW1wID0gKHVpbnQ4W2ldIDw8IDE2KSArICh1aW50OFtpICsgMV0gPDwgOCkgKyAodWludDhbaSArIDJdKVxuXHRcdFx0b3V0cHV0ICs9IHRyaXBsZXRUb0Jhc2U2NCh0ZW1wKVxuXHRcdH1cblxuXHRcdC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcblx0XHRzd2l0Y2ggKGV4dHJhQnl0ZXMpIHtcblx0XHRcdGNhc2UgMTpcblx0XHRcdFx0dGVtcCA9IHVpbnQ4W3VpbnQ4Lmxlbmd0aCAtIDFdXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUodGVtcCA+PiAyKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKCh0ZW1wIDw8IDQpICYgMHgzRilcblx0XHRcdFx0b3V0cHV0ICs9ICc9PSdcblx0XHRcdFx0YnJlYWtcblx0XHRcdGNhc2UgMjpcblx0XHRcdFx0dGVtcCA9ICh1aW50OFt1aW50OC5sZW5ndGggLSAyXSA8PCA4KSArICh1aW50OFt1aW50OC5sZW5ndGggLSAxXSlcblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSh0ZW1wID4+IDEwKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKCh0ZW1wID4+IDQpICYgMHgzRilcblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSgodGVtcCA8PCAyKSAmIDB4M0YpXG5cdFx0XHRcdG91dHB1dCArPSAnPSdcblx0XHRcdFx0YnJlYWtcblx0XHR9XG5cblx0XHRyZXR1cm4gb3V0cHV0XG5cdH1cblxuXHRleHBvcnRzLnRvQnl0ZUFycmF5ID0gYjY0VG9CeXRlQXJyYXlcblx0ZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gdWludDhUb0Jhc2U2NFxufSh0eXBlb2YgZXhwb3J0cyA9PT0gJ3VuZGVmaW5lZCcgPyAodGhpcy5iYXNlNjRqcyA9IHt9KSA6IGV4cG9ydHMpKVxuIiwiZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24oYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSxcbiAgICAgIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDEsXG4gICAgICBlTWF4ID0gKDEgPDwgZUxlbikgLSAxLFxuICAgICAgZUJpYXMgPSBlTWF4ID4+IDEsXG4gICAgICBuQml0cyA9IC03LFxuICAgICAgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwLFxuICAgICAgZCA9IGlzTEUgPyAtMSA6IDEsXG4gICAgICBzID0gYnVmZmVyW29mZnNldCArIGldO1xuXG4gIGkgKz0gZDtcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKTtcbiAgcyA+Pj0gKC1uQml0cyk7XG4gIG5CaXRzICs9IGVMZW47XG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSBlICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpO1xuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpO1xuICBlID4+PSAoLW5CaXRzKTtcbiAgbkJpdHMgKz0gbUxlbjtcbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IG0gKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCk7XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzO1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSk7XG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKTtcbiAgICBlID0gZSAtIGVCaWFzO1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pO1xufTtcblxuZXhwb3J0cy53cml0ZSA9IGZ1bmN0aW9uKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjLFxuICAgICAgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMSxcbiAgICAgIGVNYXggPSAoMSA8PCBlTGVuKSAtIDEsXG4gICAgICBlQmlhcyA9IGVNYXggPj4gMSxcbiAgICAgIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKSxcbiAgICAgIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKSxcbiAgICAgIGQgPSBpc0xFID8gMSA6IC0xLFxuICAgICAgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMDtcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKTtcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMDtcbiAgICBlID0gZU1heDtcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMik7XG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tO1xuICAgICAgYyAqPSAyO1xuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gYztcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrKztcbiAgICAgIGMgLz0gMjtcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwO1xuICAgICAgZSA9IGVNYXg7XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICh2YWx1ZSAqIGMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pO1xuICAgICAgZSA9IGUgKyBlQmlhcztcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pO1xuICAgICAgZSA9IDA7XG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCk7XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbTtcbiAgZUxlbiArPSBtTGVuO1xuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpO1xuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyODtcbn07XG4iLCIoZnVuY3Rpb24gKHByb2Nlc3Mpe1xuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIHJlc29sdmVzIC4gYW5kIC4uIGVsZW1lbnRzIGluIGEgcGF0aCBhcnJheSB3aXRoIGRpcmVjdG9yeSBuYW1lcyB0aGVyZVxuLy8gbXVzdCBiZSBubyBzbGFzaGVzLCBlbXB0eSBlbGVtZW50cywgb3IgZGV2aWNlIG5hbWVzIChjOlxcKSBpbiB0aGUgYXJyYXlcbi8vIChzbyBhbHNvIG5vIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHNsYXNoZXMgLSBpdCBkb2VzIG5vdCBkaXN0aW5ndWlzaFxuLy8gcmVsYXRpdmUgYW5kIGFic29sdXRlIHBhdGhzKVxuZnVuY3Rpb24gbm9ybWFsaXplQXJyYXkocGFydHMsIGFsbG93QWJvdmVSb290KSB7XG4gIC8vIGlmIHRoZSBwYXRoIHRyaWVzIHRvIGdvIGFib3ZlIHRoZSByb290LCBgdXBgIGVuZHMgdXAgPiAwXG4gIHZhciB1cCA9IDA7XG4gIGZvciAodmFyIGkgPSBwYXJ0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHZhciBsYXN0ID0gcGFydHNbaV07XG4gICAgaWYgKGxhc3QgPT09ICcuJykge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgIH0gZWxzZSBpZiAobGFzdCA9PT0gJy4uJykge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgICB1cC0tO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBwYXRoIGlzIGFsbG93ZWQgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIHJlc3RvcmUgbGVhZGluZyAuLnNcbiAgaWYgKGFsbG93QWJvdmVSb290KSB7XG4gICAgZm9yICg7IHVwLS07IHVwKSB7XG4gICAgICBwYXJ0cy51bnNoaWZ0KCcuLicpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYXJ0cztcbn1cblxuLy8gU3BsaXQgYSBmaWxlbmFtZSBpbnRvIFtyb290LCBkaXIsIGJhc2VuYW1lLCBleHRdLCB1bml4IHZlcnNpb25cbi8vICdyb290JyBpcyBqdXN0IGEgc2xhc2gsIG9yIG5vdGhpbmcuXG52YXIgc3BsaXRQYXRoUmUgPVxuICAgIC9eKFxcLz98KShbXFxzXFxTXSo/KSgoPzpcXC57MSwyfXxbXlxcL10rP3wpKFxcLlteLlxcL10qfCkpKD86W1xcL10qKSQvO1xudmFyIHNwbGl0UGF0aCA9IGZ1bmN0aW9uKGZpbGVuYW1lKSB7XG4gIHJldHVybiBzcGxpdFBhdGhSZS5leGVjKGZpbGVuYW1lKS5zbGljZSgxKTtcbn07XG5cbi8vIHBhdGgucmVzb2x2ZShbZnJvbSAuLi5dLCB0bylcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMucmVzb2x2ZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcmVzb2x2ZWRQYXRoID0gJycsXG4gICAgICByZXNvbHZlZEFic29sdXRlID0gZmFsc2U7XG5cbiAgZm9yICh2YXIgaSA9IGFyZ3VtZW50cy5sZW5ndGggLSAxOyBpID49IC0xICYmICFyZXNvbHZlZEFic29sdXRlOyBpLS0pIHtcbiAgICB2YXIgcGF0aCA9IChpID49IDApID8gYXJndW1lbnRzW2ldIDogcHJvY2Vzcy5jd2QoKTtcblxuICAgIC8vIFNraXAgZW1wdHkgYW5kIGludmFsaWQgZW50cmllc1xuICAgIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyB0byBwYXRoLnJlc29sdmUgbXVzdCBiZSBzdHJpbmdzJyk7XG4gICAgfSBlbHNlIGlmICghcGF0aCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgcmVzb2x2ZWRQYXRoID0gcGF0aCArICcvJyArIHJlc29sdmVkUGF0aDtcbiAgICByZXNvbHZlZEFic29sdXRlID0gcGF0aC5jaGFyQXQoMCkgPT09ICcvJztcbiAgfVxuXG4gIC8vIEF0IHRoaXMgcG9pbnQgdGhlIHBhdGggc2hvdWxkIGJlIHJlc29sdmVkIHRvIGEgZnVsbCBhYnNvbHV0ZSBwYXRoLCBidXRcbiAgLy8gaGFuZGxlIHJlbGF0aXZlIHBhdGhzIHRvIGJlIHNhZmUgKG1pZ2h0IGhhcHBlbiB3aGVuIHByb2Nlc3MuY3dkKCkgZmFpbHMpXG5cbiAgLy8gTm9ybWFsaXplIHRoZSBwYXRoXG4gIHJlc29sdmVkUGF0aCA9IG5vcm1hbGl6ZUFycmF5KGZpbHRlcihyZXNvbHZlZFBhdGguc3BsaXQoJy8nKSwgZnVuY3Rpb24ocCkge1xuICAgIHJldHVybiAhIXA7XG4gIH0pLCAhcmVzb2x2ZWRBYnNvbHV0ZSkuam9pbignLycpO1xuXG4gIHJldHVybiAoKHJlc29sdmVkQWJzb2x1dGUgPyAnLycgOiAnJykgKyByZXNvbHZlZFBhdGgpIHx8ICcuJztcbn07XG5cbi8vIHBhdGgubm9ybWFsaXplKHBhdGgpXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgdmFyIGlzQWJzb2x1dGUgPSBleHBvcnRzLmlzQWJzb2x1dGUocGF0aCksXG4gICAgICB0cmFpbGluZ1NsYXNoID0gc3Vic3RyKHBhdGgsIC0xKSA9PT0gJy8nO1xuXG4gIC8vIE5vcm1hbGl6ZSB0aGUgcGF0aFxuICBwYXRoID0gbm9ybWFsaXplQXJyYXkoZmlsdGVyKHBhdGguc3BsaXQoJy8nKSwgZnVuY3Rpb24ocCkge1xuICAgIHJldHVybiAhIXA7XG4gIH0pLCAhaXNBYnNvbHV0ZSkuam9pbignLycpO1xuXG4gIGlmICghcGF0aCAmJiAhaXNBYnNvbHV0ZSkge1xuICAgIHBhdGggPSAnLic7XG4gIH1cbiAgaWYgKHBhdGggJiYgdHJhaWxpbmdTbGFzaCkge1xuICAgIHBhdGggKz0gJy8nO1xuICB9XG5cbiAgcmV0dXJuIChpc0Fic29sdXRlID8gJy8nIDogJycpICsgcGF0aDtcbn07XG5cbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMuaXNBYnNvbHV0ZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGguY2hhckF0KDApID09PSAnLyc7XG59O1xuXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLmpvaW4gPSBmdW5jdGlvbigpIHtcbiAgdmFyIHBhdGhzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcbiAgcmV0dXJuIGV4cG9ydHMubm9ybWFsaXplKGZpbHRlcihwYXRocywgZnVuY3Rpb24ocCwgaW5kZXgpIHtcbiAgICBpZiAodHlwZW9mIHAgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgdG8gcGF0aC5qb2luIG11c3QgYmUgc3RyaW5ncycpO1xuICAgIH1cbiAgICByZXR1cm4gcDtcbiAgfSkuam9pbignLycpKTtcbn07XG5cblxuLy8gcGF0aC5yZWxhdGl2ZShmcm9tLCB0bylcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMucmVsYXRpdmUgPSBmdW5jdGlvbihmcm9tLCB0bykge1xuICBmcm9tID0gZXhwb3J0cy5yZXNvbHZlKGZyb20pLnN1YnN0cigxKTtcbiAgdG8gPSBleHBvcnRzLnJlc29sdmUodG8pLnN1YnN0cigxKTtcblxuICBmdW5jdGlvbiB0cmltKGFycikge1xuICAgIHZhciBzdGFydCA9IDA7XG4gICAgZm9yICg7IHN0YXJ0IDwgYXJyLmxlbmd0aDsgc3RhcnQrKykge1xuICAgICAgaWYgKGFycltzdGFydF0gIT09ICcnKSBicmVhaztcbiAgICB9XG5cbiAgICB2YXIgZW5kID0gYXJyLmxlbmd0aCAtIDE7XG4gICAgZm9yICg7IGVuZCA+PSAwOyBlbmQtLSkge1xuICAgICAgaWYgKGFycltlbmRdICE9PSAnJykgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKHN0YXJ0ID4gZW5kKSByZXR1cm4gW107XG4gICAgcmV0dXJuIGFyci5zbGljZShzdGFydCwgZW5kIC0gc3RhcnQgKyAxKTtcbiAgfVxuXG4gIHZhciBmcm9tUGFydHMgPSB0cmltKGZyb20uc3BsaXQoJy8nKSk7XG4gIHZhciB0b1BhcnRzID0gdHJpbSh0by5zcGxpdCgnLycpKTtcblxuICB2YXIgbGVuZ3RoID0gTWF0aC5taW4oZnJvbVBhcnRzLmxlbmd0aCwgdG9QYXJ0cy5sZW5ndGgpO1xuICB2YXIgc2FtZVBhcnRzTGVuZ3RoID0gbGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGZyb21QYXJ0c1tpXSAhPT0gdG9QYXJ0c1tpXSkge1xuICAgICAgc2FtZVBhcnRzTGVuZ3RoID0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHZhciBvdXRwdXRQYXJ0cyA9IFtdO1xuICBmb3IgKHZhciBpID0gc2FtZVBhcnRzTGVuZ3RoOyBpIDwgZnJvbVBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgb3V0cHV0UGFydHMucHVzaCgnLi4nKTtcbiAgfVxuXG4gIG91dHB1dFBhcnRzID0gb3V0cHV0UGFydHMuY29uY2F0KHRvUGFydHMuc2xpY2Uoc2FtZVBhcnRzTGVuZ3RoKSk7XG5cbiAgcmV0dXJuIG91dHB1dFBhcnRzLmpvaW4oJy8nKTtcbn07XG5cbmV4cG9ydHMuc2VwID0gJy8nO1xuZXhwb3J0cy5kZWxpbWl0ZXIgPSAnOic7XG5cbmV4cG9ydHMuZGlybmFtZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgdmFyIHJlc3VsdCA9IHNwbGl0UGF0aChwYXRoKSxcbiAgICAgIHJvb3QgPSByZXN1bHRbMF0sXG4gICAgICBkaXIgPSByZXN1bHRbMV07XG5cbiAgaWYgKCFyb290ICYmICFkaXIpIHtcbiAgICAvLyBObyBkaXJuYW1lIHdoYXRzb2V2ZXJcbiAgICByZXR1cm4gJy4nO1xuICB9XG5cbiAgaWYgKGRpcikge1xuICAgIC8vIEl0IGhhcyBhIGRpcm5hbWUsIHN0cmlwIHRyYWlsaW5nIHNsYXNoXG4gICAgZGlyID0gZGlyLnN1YnN0cigwLCBkaXIubGVuZ3RoIC0gMSk7XG4gIH1cblxuICByZXR1cm4gcm9vdCArIGRpcjtcbn07XG5cblxuZXhwb3J0cy5iYXNlbmFtZSA9IGZ1bmN0aW9uKHBhdGgsIGV4dCkge1xuICB2YXIgZiA9IHNwbGl0UGF0aChwYXRoKVsyXTtcbiAgLy8gVE9ETzogbWFrZSB0aGlzIGNvbXBhcmlzb24gY2FzZS1pbnNlbnNpdGl2ZSBvbiB3aW5kb3dzP1xuICBpZiAoZXh0ICYmIGYuc3Vic3RyKC0xICogZXh0Lmxlbmd0aCkgPT09IGV4dCkge1xuICAgIGYgPSBmLnN1YnN0cigwLCBmLmxlbmd0aCAtIGV4dC5sZW5ndGgpO1xuICB9XG4gIHJldHVybiBmO1xufTtcblxuXG5leHBvcnRzLmV4dG5hbWUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHJldHVybiBzcGxpdFBhdGgocGF0aClbM107XG59O1xuXG5mdW5jdGlvbiBmaWx0ZXIgKHhzLCBmKSB7XG4gICAgaWYgKHhzLmZpbHRlcikgcmV0dXJuIHhzLmZpbHRlcihmKTtcbiAgICB2YXIgcmVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoZih4c1tpXSwgaSwgeHMpKSByZXMucHVzaCh4c1tpXSk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5cbi8vIFN0cmluZy5wcm90b3R5cGUuc3Vic3RyIC0gbmVnYXRpdmUgaW5kZXggZG9uJ3Qgd29yayBpbiBJRThcbnZhciBzdWJzdHIgPSAnYWInLnN1YnN0cigtMSkgPT09ICdiJ1xuICAgID8gZnVuY3Rpb24gKHN0ciwgc3RhcnQsIGxlbikgeyByZXR1cm4gc3RyLnN1YnN0cihzdGFydCwgbGVuKSB9XG4gICAgOiBmdW5jdGlvbiAoc3RyLCBzdGFydCwgbGVuKSB7XG4gICAgICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gc3RyLmxlbmd0aCArIHN0YXJ0O1xuICAgICAgICByZXR1cm4gc3RyLnN1YnN0cihzdGFydCwgbGVuKTtcbiAgICB9XG47XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiSmtwUjJGXCIpKSIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxuXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbnByb2Nlc3MubmV4dFRpY2sgPSAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBjYW5TZXRJbW1lZGlhdGUgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgICYmIHdpbmRvdy5zZXRJbW1lZGlhdGU7XG4gICAgdmFyIGNhblBvc3QgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgICYmIHdpbmRvdy5wb3N0TWVzc2FnZSAmJiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lclxuICAgIDtcblxuICAgIGlmIChjYW5TZXRJbW1lZGlhdGUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChmKSB7IHJldHVybiB3aW5kb3cuc2V0SW1tZWRpYXRlKGYpIH07XG4gICAgfVxuXG4gICAgaWYgKGNhblBvc3QpIHtcbiAgICAgICAgdmFyIHF1ZXVlID0gW107XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICB2YXIgc291cmNlID0gZXYuc291cmNlO1xuICAgICAgICAgICAgaWYgKChzb3VyY2UgPT09IHdpbmRvdyB8fCBzb3VyY2UgPT09IG51bGwpICYmIGV2LmRhdGEgPT09ICdwcm9jZXNzLXRpY2snKSB7XG4gICAgICAgICAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgaWYgKHF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZuID0gcXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgZm4oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRydWUpO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBuZXh0VGljayhmbikge1xuICAgICAgICAgICAgcXVldWUucHVzaChmbik7XG4gICAgICAgICAgICB3aW5kb3cucG9zdE1lc3NhZ2UoJ3Byb2Nlc3MtdGljaycsICcqJyk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHRUaWNrKGZuKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZm4sIDApO1xuICAgIH07XG59KSgpO1xuXG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn1cblxuLy8gVE9ETyhzaHR5bG1hbilcbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuIiwiLypcclxuIENvcHlyaWdodCAyMDEzIERhbmllbCBXaXJ0eiA8ZGNvZGVAZGNvZGUuaW8+XHJcblxyXG4gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG5cclxuIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG5cclxuIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBsaWNlbnNlIFByb3RvQnVmLmpzIChjKSAyMDEzIERhbmllbCBXaXJ0eiA8ZGNvZGVAZGNvZGUuaW8+XHJcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjBcclxuICogc2VlOiBodHRwczovL2dpdGh1Yi5jb20vZGNvZGVJTy9Qcm90b0J1Zi5qcyBmb3IgZGV0YWlsc1xyXG4gKi9cclxuKGZ1bmN0aW9uKGdsb2JhbCkge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4gICAgZnVuY3Rpb24gaW5pdChCeXRlQnVmZmVyKSB7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBQcm90b0J1ZiBuYW1lc3BhY2UuXHJcbiAgICAgICAgICogQGV4cG9ydHMgUHJvdG9CdWZcclxuICAgICAgICAgKiBAbmFtZXNwYWNlXHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBQcm90b0J1ZiA9IHt9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBQcm90b0J1Zi5qcyB2ZXJzaW9uLlxyXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICAgICAgICogQGNvbnN0XHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFByb3RvQnVmLlZFUlNJT04gPSBcIjMuMi4yXCI7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFdpcmUgdHlwZXMuXHJcbiAgICAgICAgICogQHR5cGUge09iamVjdC48c3RyaW5nLG51bWJlcj59XHJcbiAgICAgICAgICogQGNvbnN0XHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFByb3RvQnVmLldJUkVfVFlQRVMgPSB7fTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVmFyaW50IHdpcmUgdHlwZS5cclxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBQcm90b0J1Zi5XSVJFX1RZUEVTLlZBUklOVCA9IDA7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEZpeGVkIDY0IGJpdHMgd2lyZSB0eXBlLlxyXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgICAgICogQGNvbnN0XHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFByb3RvQnVmLldJUkVfVFlQRVMuQklUUzY0ID0gMTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTGVuZ3RoIGRlbGltaXRlZCB3aXJlIHR5cGUuXHJcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAgICAgKiBAY29uc3RcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUHJvdG9CdWYuV0lSRV9UWVBFUy5MREVMSU0gPSAyO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTdGFydCBncm91cCB3aXJlIHR5cGUuXHJcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAgICAgKiBAY29uc3RcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUHJvdG9CdWYuV0lSRV9UWVBFUy5TVEFSVEdST1VQID0gMztcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRW5kIGdyb3VwIHdpcmUgdHlwZS5cclxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICAgICAqIEBjb25zdFxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBQcm90b0J1Zi5XSVJFX1RZUEVTLkVOREdST1VQID0gNDtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRml4ZWQgMzIgYml0cyB3aXJlIHR5cGUuXHJcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAgICAgKiBAY29uc3RcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUHJvdG9CdWYuV0lSRV9UWVBFUy5CSVRTMzIgPSA1O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBQYWNrYWJsZSB3aXJlIHR5cGVzLlxyXG4gICAgICAgICAqIEB0eXBlIHshQXJyYXkuPG51bWJlcj59XHJcbiAgICAgICAgICogQGNvbnN0XHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFByb3RvQnVmLlBBQ0tBQkxFX1dJUkVfVFlQRVMgPSBbXHJcbiAgICAgICAgICAgIFByb3RvQnVmLldJUkVfVFlQRVMuVkFSSU5ULFxyXG4gICAgICAgICAgICBQcm90b0J1Zi5XSVJFX1RZUEVTLkJJVFM2NCxcclxuICAgICAgICAgICAgUHJvdG9CdWYuV0lSRV9UWVBFUy5CSVRTMzJcclxuICAgICAgICBdO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUeXBlcy5cclxuICAgICAgICAgKiBAZGljdFxyXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZyx7bmFtZTogc3RyaW5nLCB3aXJlVHlwZTogbnVtYmVyfT59XHJcbiAgICAgICAgICogQGNvbnN0XHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFByb3RvQnVmLlRZUEVTID0ge1xyXG4gICAgICAgICAgICAvLyBBY2NvcmRpbmcgdG8gdGhlIHByb3RvYnVmIHNwZWMuXHJcbiAgICAgICAgICAgIFwiaW50MzJcIjoge1xyXG4gICAgICAgICAgICAgICAgbmFtZTogXCJpbnQzMlwiLFxyXG4gICAgICAgICAgICAgICAgd2lyZVR5cGU6IFByb3RvQnVmLldJUkVfVFlQRVMuVkFSSU5UXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIFwidWludDMyXCI6IHtcclxuICAgICAgICAgICAgICAgIG5hbWU6IFwidWludDMyXCIsXHJcbiAgICAgICAgICAgICAgICB3aXJlVHlwZTogUHJvdG9CdWYuV0lSRV9UWVBFUy5WQVJJTlRcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgXCJzaW50MzJcIjoge1xyXG4gICAgICAgICAgICAgICAgbmFtZTogXCJzaW50MzJcIixcclxuICAgICAgICAgICAgICAgIHdpcmVUeXBlOiBQcm90b0J1Zi5XSVJFX1RZUEVTLlZBUklOVFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBcImludDY0XCI6IHtcclxuICAgICAgICAgICAgICAgIG5hbWU6IFwiaW50NjRcIixcclxuICAgICAgICAgICAgICAgIHdpcmVUeXBlOiBQcm90b0J1Zi5XSVJFX1RZUEVTLlZBUklOVFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBcInVpbnQ2NFwiOiB7XHJcbiAgICAgICAgICAgICAgICBuYW1lOiBcInVpbnQ2NFwiLFxyXG4gICAgICAgICAgICAgICAgd2lyZVR5cGU6IFByb3RvQnVmLldJUkVfVFlQRVMuVkFSSU5UXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIFwic2ludDY0XCI6IHtcclxuICAgICAgICAgICAgICAgIG5hbWU6IFwic2ludDY0XCIsXHJcbiAgICAgICAgICAgICAgICB3aXJlVHlwZTogUHJvdG9CdWYuV0lSRV9UWVBFUy5WQVJJTlRcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgXCJib29sXCI6IHtcclxuICAgICAgICAgICAgICAgIG5hbWU6IFwiYm9vbFwiLFxyXG4gICAgICAgICAgICAgICAgd2lyZVR5cGU6IFByb3RvQnVmLldJUkVfVFlQRVMuVkFSSU5UXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIFwiZG91YmxlXCI6IHtcclxuICAgICAgICAgICAgICAgIG5hbWU6IFwiZG91YmxlXCIsXHJcbiAgICAgICAgICAgICAgICB3aXJlVHlwZTogUHJvdG9CdWYuV0lSRV9UWVBFUy5CSVRTNjRcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgXCJzdHJpbmdcIjoge1xyXG4gICAgICAgICAgICAgICAgbmFtZTogXCJzdHJpbmdcIixcclxuICAgICAgICAgICAgICAgIHdpcmVUeXBlOiBQcm90b0J1Zi5XSVJFX1RZUEVTLkxERUxJTVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBcImJ5dGVzXCI6IHtcclxuICAgICAgICAgICAgICAgIG5hbWU6IFwiYnl0ZXNcIixcclxuICAgICAgICAgICAgICAgIHdpcmVUeXBlOiBQcm90b0J1Zi5XSVJFX1RZUEVTLkxERUxJTVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBcImZpeGVkMzJcIjoge1xyXG4gICAgICAgICAgICAgICAgbmFtZTogXCJmaXhlZDMyXCIsXHJcbiAgICAgICAgICAgICAgICB3aXJlVHlwZTogUHJvdG9CdWYuV0lSRV9UWVBFUy5CSVRTMzJcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgXCJzZml4ZWQzMlwiOiB7XHJcbiAgICAgICAgICAgICAgICBuYW1lOiBcInNmaXhlZDMyXCIsXHJcbiAgICAgICAgICAgICAgICB3aXJlVHlwZTogUHJvdG9CdWYuV0lSRV9UWVBFUy5CSVRTMzJcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgXCJmaXhlZDY0XCI6IHtcclxuICAgICAgICAgICAgICAgIG5hbWU6IFwiZml4ZWQ2NFwiLFxyXG4gICAgICAgICAgICAgICAgd2lyZVR5cGU6IFByb3RvQnVmLldJUkVfVFlQRVMuQklUUzY0XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIFwic2ZpeGVkNjRcIjoge1xyXG4gICAgICAgICAgICAgICAgbmFtZTogXCJzZml4ZWQ2NFwiLFxyXG4gICAgICAgICAgICAgICAgd2lyZVR5cGU6IFByb3RvQnVmLldJUkVfVFlQRVMuQklUUzY0XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIFwiZmxvYXRcIjoge1xyXG4gICAgICAgICAgICAgICAgbmFtZTogXCJmbG9hdFwiLFxyXG4gICAgICAgICAgICAgICAgd2lyZVR5cGU6IFByb3RvQnVmLldJUkVfVFlQRVMuQklUUzMyXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIFwiZW51bVwiOiB7XHJcbiAgICAgICAgICAgICAgICBuYW1lOiBcImVudW1cIixcclxuICAgICAgICAgICAgICAgIHdpcmVUeXBlOiBQcm90b0J1Zi5XSVJFX1RZUEVTLlZBUklOVFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBcIm1lc3NhZ2VcIjoge1xyXG4gICAgICAgICAgICAgICAgbmFtZTogXCJtZXNzYWdlXCIsXHJcbiAgICAgICAgICAgICAgICB3aXJlVHlwZTogUHJvdG9CdWYuV0lSRV9UWVBFUy5MREVMSU1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgXCJncm91cFwiOiB7XHJcbiAgICAgICAgICAgICAgICBuYW1lOiBcImdyb3VwXCIsXHJcbiAgICAgICAgICAgICAgICB3aXJlVHlwZTogUHJvdG9CdWYuV0lSRV9UWVBFUy5TVEFSVEdST1VQXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBNaW5pbXVtIGZpZWxkIGlkLlxyXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgICAgICogQGNvbnN0XHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFByb3RvQnVmLklEX01JTiA9IDE7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIE1heGltdW0gZmllbGQgaWQuXHJcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAgICAgKiBAY29uc3RcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUHJvdG9CdWYuSURfTUFYID0gMHgxRkZGRkZGRjtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHR5cGUgeyFmdW5jdGlvbihuZXc6IEJ5dGVCdWZmZXIsIC4uLlsqXSl9XHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFByb3RvQnVmLkJ5dGVCdWZmZXIgPSBCeXRlQnVmZmVyO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAdHlwZSB7P2Z1bmN0aW9uKG5ldzogTG9uZywgLi4uWypdKX1cclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUHJvdG9CdWYuTG9uZyA9IEJ5dGVCdWZmZXIuTG9uZyB8fCBudWxsO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJZiBzZXQgdG8gYHRydWVgLCBmaWVsZCBuYW1lcyB3aWxsIGJlIGNvbnZlcnRlZCBmcm9tIHVuZGVyc2NvcmUgbm90YXRpb24gdG8gY2FtZWwgY2FzZS4gRGVmYXVsdHMgdG8gYGZhbHNlYC5cclxuICAgICAgICAgKiAgTXVzdCBiZSBzZXQgcHJpb3IgdG8gcGFyc2luZy5cclxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUHJvdG9CdWYuY29udmVydEZpZWxkc1RvQ2FtZWxDYXNlID0gZmFsc2U7XHJcblxyXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAYWxpYXMgUHJvdG9CdWYuVXRpbFxuICAgICAgICAgKiBAZXhwb3NlXG4gICAgICAgICAqL1xuICAgICAgICBQcm90b0J1Zi5VdGlsID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICAgIC8vIE9iamVjdC5jcmVhdGUgcG9seWZpbGxcbiAgICAgICAgICAgIC8vIHJlZjogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZGUvZG9jcy9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvY3JlYXRlXG4gICAgICAgICAgICBpZiAoIU9iamVjdC5jcmVhdGUpXG4gICAgICAgICAgICAgICAgLyoqIEBleHBvc2UgKi9cbiAgICAgICAgICAgICAgICBPYmplY3QuY3JlYXRlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ09iamVjdC5jcmVhdGUgcG9seWZpbGwgb25seSBhY2NlcHRzIHRoZSBmaXJzdCBwYXJhbWV0ZXIuJyk7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIEYoKSB7fVxuICAgICAgICAgICAgICAgICAgICBGLnByb3RvdHlwZSA9IG87XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRigpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUHJvdG9CdWYgdXRpbGl0aWVzLlxuICAgICAgICAgICAgICogQGV4cG9ydHMgUHJvdG9CdWYuVXRpbFxuICAgICAgICAgICAgICogQG5hbWVzcGFjZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2YXIgVXRpbCA9IHt9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEZsYWcgaWYgcnVubmluZyBpbiBub2RlIChmcyBpcyBhdmFpbGFibGUpIG9yIG5vdC5cbiAgICAgICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgICAgICogQGNvbnN0XG4gICAgICAgICAgICAgKiBAZXhwb3NlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFV0aWwuSVNfTk9ERSA9IGZhbHNlO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAvLyBUaGVyZSBpcyBubyByZWxpYWJsZSB3YXkgdG8gZGV0ZWN0IG5vZGUuanMgYXMgYW4gZW52aXJvbm1lbnQsIHNvIG91clxuICAgICAgICAgICAgICAgIC8vIGJlc3QgYmV0IGlzIHRvIGZlYXR1cmUtZGV0ZWN0IHdoYXQgd2UgYWN0dWFsbHkgbmVlZC5cbiAgICAgICAgICAgICAgICBVdGlsLklTX05PREUgPVxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgcmVxdWlyZShcImZzXCIpLnJlYWRGaWxlU3luYyA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgcmVxdWlyZShcInBhdGhcIikucmVzb2x2ZSA9PT0gJ2Z1bmN0aW9uJztcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ29uc3RydWN0cyBhIFhNTEh0dHBSZXF1ZXN0IG9iamVjdC5cbiAgICAgICAgICAgICAqIEByZXR1cm4ge1hNTEh0dHBSZXF1ZXN0fVxuICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIFhNTEh0dHBSZXF1ZXN0IGlzIG5vdCBzdXBwb3J0ZWRcbiAgICAgICAgICAgICAqIEBleHBvc2VcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgVXRpbC5YSFIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAvLyBObyBkZXBlbmRlbmNpZXMgcGxlYXNlLCByZWY6IGh0dHA6Ly93d3cucXVpcmtzbW9kZS5vcmcvanMveG1saHR0cC5odG1sXG4gICAgICAgICAgICAgICAgdmFyIFhNTEh0dHBGYWN0b3JpZXMgPSBbXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtyZXR1cm4gbmV3IFhNTEh0dHBSZXF1ZXN0KCl9LFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7cmV0dXJuIG5ldyBBY3RpdmVYT2JqZWN0KFwiTXN4bWwyLlhNTEhUVFBcIil9LFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7cmV0dXJuIG5ldyBBY3RpdmVYT2JqZWN0KFwiTXN4bWwzLlhNTEhUVFBcIil9LFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7cmV0dXJuIG5ldyBBY3RpdmVYT2JqZWN0KFwiTWljcm9zb2Z0LlhNTEhUVFBcIil9XG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAvKiogQHR5cGUgez9YTUxIdHRwUmVxdWVzdH0gKi9cbiAgICAgICAgICAgICAgICB2YXIgeGhyID0gbnVsbDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpPTA7aTxYTUxIdHRwRmFjdG9yaWVzLmxlbmd0aDtpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHsgeGhyID0gWE1MSHR0cEZhY3Rvcmllc1tpXSgpOyB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXhocilcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJYTUxIdHRwUmVxdWVzdCBpcyBub3Qgc3VwcG9ydGVkXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiB4aHI7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEZldGNoZXMgYSByZXNvdXJjZS5cbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFJlc291cmNlIHBhdGhcbiAgICAgICAgICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oP3N0cmluZyk9fSBjYWxsYmFjayBDYWxsYmFjayByZWNlaXZpbmcgdGhlIHJlc291cmNlJ3MgY29udGVudHMuIElmIG9taXR0ZWQgdGhlIHJlc291cmNlIHdpbGxcbiAgICAgICAgICAgICAqICAgYmUgZmV0Y2hlZCBzeW5jaHJvbm91c2x5LiBJZiB0aGUgcmVxdWVzdCBmYWlsZWQsIGNvbnRlbnRzIHdpbGwgYmUgbnVsbC5cbiAgICAgICAgICAgICAqIEByZXR1cm4gez9zdHJpbmd8dW5kZWZpbmVkfSBSZXNvdXJjZSBjb250ZW50cyBpZiBjYWxsYmFjayBpcyBvbWl0dGVkIChudWxsIGlmIHRoZSByZXF1ZXN0IGZhaWxlZCksIGVsc2UgdW5kZWZpbmVkLlxuICAgICAgICAgICAgICogQGV4cG9zZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBVdGlsLmZldGNoID0gZnVuY3Rpb24ocGF0aCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2sgJiYgdHlwZW9mIGNhbGxiYWNrICE9ICdmdW5jdGlvbicpXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoVXRpbC5JU19OT0RFKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZShcImZzXCIpLnJlYWRGaWxlKHBhdGgsIGZ1bmN0aW9uKGVyciwgZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soXCJcIitkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcXVpcmUoXCJmc1wiKS5yZWFkRmlsZVN5bmMocGF0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHhociA9IFV0aWwuWEhSKCk7XG4gICAgICAgICAgICAgICAgICAgIHhoci5vcGVuKCdHRVQnLCBwYXRoLCBjYWxsYmFjayA/IHRydWUgOiBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdVc2VyLUFnZW50JywgJ1hNTEhUVFAvMS4wJyk7XG4gICAgICAgICAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdBY2NlcHQnLCAndGV4dC9wbGFpbicpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHhoci5vdmVycmlkZU1pbWVUeXBlID09PSAnZnVuY3Rpb24nKSB4aHIub3ZlcnJpZGVNaW1lVHlwZSgndGV4dC9wbGFpbicpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgIT0gNCkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgvKiByZW1vdGUgKi8geGhyLnN0YXR1cyA9PSAyMDAgfHwgLyogbG9jYWwgKi8gKHhoci5zdGF0dXMgPT0gMCAmJiB0eXBlb2YgeGhyLnJlc3BvbnNlVGV4dCA9PT0gJ3N0cmluZycpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayh4aHIucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSA9PSA0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHhoci5zZW5kKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgeGhyLnNlbmQobnVsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoLyogcmVtb3RlICovIHhoci5zdGF0dXMgPT0gMjAwIHx8IC8qIGxvY2FsICovICh4aHIuc3RhdHVzID09IDAgJiYgdHlwZW9mIHhoci5yZXNwb25zZVRleHQgPT09ICdzdHJpbmcnKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geGhyLnJlc3BvbnNlVGV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUZXN0cyBpZiBhbiBvYmplY3QgaXMgYW4gYXJyYXkuXG4gICAgICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICAgICAqIEBwYXJhbSB7Kn0gb2JqIE9iamVjdCB0byB0ZXN0XG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiBpdCBpcyBhbiBhcnJheSwgZWxzZSBmYWxzZVxuICAgICAgICAgICAgICogQGV4cG9zZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBVdGlsLmlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gXCJbb2JqZWN0IEFycmF5XVwiO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmV0dXJuIFV0aWw7XG4gICAgICAgIH0pKCk7XG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBMYW5ndWFnZSBleHByZXNzaW9ucy5cclxuICAgICAgICAgKiBAZXhwb3J0cyBQcm90b0J1Zi5MYW5nXHJcbiAgICAgICAgICogQHR5cGUge09iamVjdC48c3RyaW5nLHN0cmluZ3xSZWdFeHA+fVxyXG4gICAgICAgICAqIEBuYW1lc3BhY2VcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUHJvdG9CdWYuTGFuZyA9IHtcclxuICAgICAgICAgICAgT1BFTjogXCJ7XCIsXHJcbiAgICAgICAgICAgIENMT1NFOiBcIn1cIixcclxuICAgICAgICAgICAgT1BUT1BFTjogXCJbXCIsXHJcbiAgICAgICAgICAgIE9QVENMT1NFOiBcIl1cIixcclxuICAgICAgICAgICAgT1BURU5EOiBcIixcIixcclxuICAgICAgICAgICAgRVFVQUw6IFwiPVwiLFxyXG4gICAgICAgICAgICBFTkQ6IFwiO1wiLFxyXG4gICAgICAgICAgICBTVFJJTkdPUEVOOiAnXCInLFxyXG4gICAgICAgICAgICBTVFJJTkdDTE9TRTogJ1wiJyxcclxuICAgICAgICAgICAgU1RSSU5HT1BFTl9TUTogXCInXCIsXHJcbiAgICAgICAgICAgIFNUUklOR0NMT1NFX1NROiBcIidcIixcclxuICAgICAgICAgICAgQ09QVE9QRU46ICcoJyxcclxuICAgICAgICAgICAgQ09QVENMT1NFOiAnKScsXHJcbiAgICAgICAgICAgIERFTElNOiAvW1xcc1xce1xcfT07XFxbXFxdLCdcIlxcKFxcKV0vZyxcclxuICAgICAgICAgICAgLy8gS0VZV09SRDogL14oPzpwYWNrYWdlfG9wdGlvbnxpbXBvcnR8bWVzc2FnZXxlbnVtfGV4dGVuZHxzZXJ2aWNlfHN5bnRheHxleHRlbnNpb25zfGdyb3VwKSQvLFxyXG4gICAgICAgICAgICBSVUxFOiAvXig/OnJlcXVpcmVkfG9wdGlvbmFsfHJlcGVhdGVkKSQvLFxyXG4gICAgICAgICAgICBUWVBFOiAvXig/OmRvdWJsZXxmbG9hdHxpbnQzMnx1aW50MzJ8c2ludDMyfGludDY0fHVpbnQ2NHxzaW50NjR8Zml4ZWQzMnxzZml4ZWQzMnxmaXhlZDY0fHNmaXhlZDY0fGJvb2x8c3RyaW5nfGJ5dGVzKSQvLFxyXG4gICAgICAgICAgICBOQU1FOiAvXlthLXpBLVpfXVthLXpBLVpfMC05XSokLyxcclxuICAgICAgICAgICAgVFlQRURFRjogL15bYS16QS1aXVthLXpBLVpfMC05XSokLyxcclxuICAgICAgICAgICAgVFlQRVJFRjogL14oPzpcXC4/W2EtekEtWl9dW2EtekEtWl8wLTldKikrJC8sXHJcbiAgICAgICAgICAgIEZRVFlQRVJFRjogL14oPzpcXC5bYS16QS1aXVthLXpBLVpfMC05XSopKyQvLFxyXG4gICAgICAgICAgICBOVU1CRVI6IC9eLT8oPzpbMS05XVswLTldKnwwfDB4WzAtOWEtZkEtRl0rfDBbMC03XSt8KFswLTldKlxcLlswLTldKyhbRWVdWystXT9bMC05XSspPykpJC8sXHJcbiAgICAgICAgICAgIE5VTUJFUl9ERUM6IC9eKD86WzEtOV1bMC05XSp8MCkkLyxcclxuICAgICAgICAgICAgTlVNQkVSX0hFWDogL14weFswLTlhLWZBLUZdKyQvLFxyXG4gICAgICAgICAgICBOVU1CRVJfT0NUOiAvXjBbMC03XSskLyxcclxuICAgICAgICAgICAgTlVNQkVSX0ZMVDogL15bMC05XSpcXC5bMC05XSsoW0VlXVsrLV0/WzAtOV0rKT8kLyxcclxuICAgICAgICAgICAgSUQ6IC9eKD86WzEtOV1bMC05XSp8MHwweFswLTlhLWZBLUZdK3wwWzAtN10rKSQvLFxyXG4gICAgICAgICAgICBORUdJRDogL15cXC0/KD86WzEtOV1bMC05XSp8MHwweFswLTlhLWZBLUZdK3wwWzAtN10rKSQvLFxyXG4gICAgICAgICAgICBXSElURVNQQUNFOiAvXFxzLyxcclxuICAgICAgICAgICAgU1RSSU5HOiAvWydcIl0oW14nXCJcXFxcXSooXFxcXC5bXlwiXFxcXF0qKSopWydcIl0vZyxcclxuICAgICAgICAgICAgQk9PTDogL14oPzp0cnVlfGZhbHNlKSQvaVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBhbGlhcyBQcm90b0J1Zi5Eb3RQcm90b1xyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBQcm90b0J1Zi5Eb3RQcm90byA9IChmdW5jdGlvbihQcm90b0J1ZiwgTGFuZykge1xyXG4gICAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBVdGlsaXRpZXMgdG8gcGFyc2UgLnByb3RvIGZpbGVzLlxyXG4gICAgICAgICAgICAgKiBAZXhwb3J0cyBQcm90b0J1Zi5Eb3RQcm90b1xyXG4gICAgICAgICAgICAgKiBAbmFtZXNwYWNlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB2YXIgRG90UHJvdG8gPSB7fTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IFRva2VuaXplci5cclxuICAgICAgICAgICAgICogQGV4cG9ydHMgUHJvdG9CdWYuRG90UHJvdG8uVG9rZW5pemVyXHJcbiAgICAgICAgICAgICAqIEBjbGFzcyBwcm90byB0b2tlbml6ZXJcclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3RvIFByb3RvIHRvIHRva2VuaXplXHJcbiAgICAgICAgICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdmFyIFRva2VuaXplciA9IGZ1bmN0aW9uKHByb3RvKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBTb3VyY2UgdG8gcGFyc2UuXHJcbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAgICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLnNvdXJjZSA9IFwiXCIrcHJvdG87IC8vIEluIGNhc2UgaXQncyBhIGJ1ZmZlclxyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQ3VycmVudCBpbmRleC5cclxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXggPSAwO1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQ3VycmVudCBsaW5lLlxyXG4gICAgICAgICAgICAgICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5saW5lID0gMTtcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFN0YWNrZWQgdmFsdWVzLlxyXG4gICAgICAgICAgICAgICAgICogQHR5cGUge0FycmF5fVxyXG4gICAgICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YWNrID0gW107XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBXaGV0aGVyIGN1cnJlbnRseSByZWFkaW5nIGEgc3RyaW5nIG9yIG5vdC5cclxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlYWRpbmdTdHJpbmcgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFdoYXRldmVyIGNoYXJhY3RlciBlbmRzIHRoZSBzdHJpbmcuIEVpdGhlciBhIHNpbmdsZSBvciBkb3VibGUgcXVvdGUgY2hhcmFjdGVyLlxyXG4gICAgICAgICAgICAgICAgICogQHR5cGUge3N0cmluZ31cclxuICAgICAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdHJpbmdFbmRzV2l0aCA9IExhbmcuU1RSSU5HQ0xPU0U7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUmVhZHMgYSBzdHJpbmcgYmVnaW5uaW5nIGF0IHRoZSBjdXJyZW50IGluZGV4LlxyXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBzdHJpbmdcclxuICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIGl0J3Mgbm90IGEgdmFsaWQgc3RyaW5nXHJcbiAgICAgICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBUb2tlbml6ZXIucHJvdG90eXBlLl9yZWFkU3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICBMYW5nLlNUUklORy5sYXN0SW5kZXggPSB0aGlzLmluZGV4LTE7IC8vIEluY2x1ZGUgdGhlIG9wZW4gcXVvdGVcclxuICAgICAgICAgICAgICAgIHZhciBtYXRjaDtcclxuICAgICAgICAgICAgICAgIGlmICgobWF0Y2ggPSBMYW5nLlNUUklORy5leGVjKHRoaXMuc291cmNlKSkgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcyA9IG1hdGNoWzFdO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZXggPSBMYW5nLlNUUklORy5sYXN0SW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKHRoaXMuc3RyaW5nRW5kc1dpdGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIHN0cmluZyB2YWx1ZSBhdCBsaW5lIFwiK3RoaXMubGluZStcIiwgaW5kZXggXCIrdGhpcy5pbmRleCk7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR2V0cyB0aGUgbmV4dCB0b2tlbiBhbmQgYWR2YW5jZXMgYnkgb25lLlxyXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/c3RyaW5nfSBUb2tlbiBvciBgbnVsbGAgb24gRU9GXHJcbiAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiBpdCdzIG5vdCBhIHZhbGlkIHByb3RvIGZpbGVcclxuICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgVG9rZW5pemVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGFjay5sZW5ndGggPiAwKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YWNrLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pbmRleCA+PSB0aGlzLnNvdXJjZS5sZW5ndGgpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7IC8vIE5vIG1vcmUgdG9rZW5zXHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZWFkaW5nU3RyaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkaW5nU3RyaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWRTdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciByZXBlYXQsIGxhc3Q7XHJcbiAgICAgICAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVwZWF0ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gU3RyaXAgd2hpdGUgc3BhY2VzXHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKExhbmcuV0hJVEVTUEFDRS50ZXN0KGxhc3QgPSB0aGlzLnNvdXJjZS5jaGFyQXQodGhpcy5pbmRleCkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZXgrKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3QgPT09IFwiXFxuXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxpbmUrKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaW5kZXggPT09IHRoaXMuc291cmNlLmxlbmd0aClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyBTdHJpcCBjb21tZW50c1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNvdXJjZS5jaGFyQXQodGhpcy5pbmRleCkgPT09ICcvJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zb3VyY2UuY2hhckF0KCsrdGhpcy5pbmRleCkgPT09ICcvJykgeyAvLyBTaW5nbGUgbGluZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHRoaXMuc291cmNlLmNoYXJBdCh0aGlzLmluZGV4KSAhPT0gXCJcXG5cIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZXgrKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pbmRleCA9PSB0aGlzLnNvdXJjZS5sZW5ndGgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRleCsrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5saW5lKys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXBlYXQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc291cmNlLmNoYXJBdCh0aGlzLmluZGV4KSA9PT0gJyonKSB7IC8qIEJsb2NrICovXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0ID0gJyc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAobGFzdCsobGFzdD10aGlzLnNvdXJjZS5jaGFyQXQodGhpcy5pbmRleCkpICE9PSAnKi8nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRleCsrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsYXN0ID09PSBcIlxcblwiKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxpbmUrKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pbmRleCA9PT0gdGhpcy5zb3VyY2UubGVuZ3RoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZXgrKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcGVhdCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbnZhbGlkIGNvbW1lbnQgYXQgbGluZSBcIit0aGlzLmxpbmUrXCI6IC9cIit0aGlzLnNvdXJjZS5jaGFyQXQodGhpcy5pbmRleCkrXCIgKCcvJyBvciAnKicgZXhwZWN0ZWQpXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gd2hpbGUgKHJlcGVhdCk7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pbmRleCA9PT0gdGhpcy5zb3VyY2UubGVuZ3RoKSByZXR1cm4gbnVsbDtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBSZWFkIHRoZSBuZXh0IHRva2VuXHJcbiAgICAgICAgICAgICAgICB2YXIgZW5kID0gdGhpcy5pbmRleDtcclxuICAgICAgICAgICAgICAgIExhbmcuREVMSU0ubGFzdEluZGV4ID0gMDtcclxuICAgICAgICAgICAgICAgIHZhciBkZWxpbSA9IExhbmcuREVMSU0udGVzdCh0aGlzLnNvdXJjZS5jaGFyQXQoZW5kKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWRlbGltKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgKytlbmQ7XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUoZW5kIDwgdGhpcy5zb3VyY2UubGVuZ3RoICYmICFMYW5nLkRFTElNLnRlc3QodGhpcy5zb3VyY2UuY2hhckF0KGVuZCkpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQrKztcclxuICAgICAgICAgICAgICAgIH0gZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICsrZW5kO1xyXG4gICAgICAgICAgICAgICAgdmFyIHRva2VuID0gdGhpcy5zb3VyY2Uuc3Vic3RyaW5nKHRoaXMuaW5kZXgsIHRoaXMuaW5kZXggPSBlbmQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRva2VuID09PSBMYW5nLlNUUklOR09QRU4pXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkaW5nU3RyaW5nID0gdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0cmluZ0VuZHNXaXRoID0gTGFuZy5TVFJJTkdDTE9TRTtcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRva2VuID09PSBMYW5nLlNUUklOR09QRU5fU1EpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkaW5nU3RyaW5nID0gdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0cmluZ0VuZHNXaXRoID0gTGFuZy5TVFJJTkdDTE9TRV9TUTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbjtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBQZWVrcyBmb3IgdGhlIG5leHQgdG9rZW4uXHJcbiAgICAgICAgICAgICAqIEByZXR1cm4gez9zdHJpbmd9IFRva2VuIG9yIGBudWxsYCBvbiBFT0ZcclxuICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIGl0J3Mgbm90IGEgdmFsaWQgcHJvdG8gZmlsZVxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBUb2tlbml6ZXIucHJvdG90eXBlLnBlZWsgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0b2tlbiA9IHRoaXMubmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbiA9PT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKHRva2VuKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YWNrWzBdO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBvYmplY3QuXHJcbiAgICAgICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gU3RyaW5nIHJlcHJlc2VudGF0aW9uIGFzIG9mIFwiVG9rZW5pemVyKGluZGV4L2xlbmd0aClcIlxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBUb2tlbml6ZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJUb2tlbml6ZXIoXCIrdGhpcy5pbmRleCtcIi9cIit0aGlzLnNvdXJjZS5sZW5ndGgrXCIgYXQgbGluZSBcIit0aGlzLmxpbmUrXCIpXCI7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQGFsaWFzIFByb3RvQnVmLkRvdFByb3RvLlRva2VuaXplclxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBEb3RQcm90by5Ub2tlbml6ZXIgPSBUb2tlbml6ZXI7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQ29uc3RydWN0cyBhIG5ldyBQYXJzZXIuXHJcbiAgICAgICAgICAgICAqIEBleHBvcnRzIFByb3RvQnVmLkRvdFByb3RvLlBhcnNlclxyXG4gICAgICAgICAgICAgKiBAY2xhc3MgcHJvdG8gcGFyc2VyXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm90byBQcm90b2NvbCBzb3VyY2VcclxuICAgICAgICAgICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB2YXIgUGFyc2VyID0gZnVuY3Rpb24ocHJvdG8pIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFRva2VuaXplci5cclxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtQcm90b0J1Zi5Eb3RQcm90by5Ub2tlbml6ZXJ9XHJcbiAgICAgICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMudG4gPSBuZXcgVG9rZW5pemVyKHByb3RvKTtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBSdW5zIHRoZSBwYXJzZXIuXHJcbiAgICAgICAgICAgICAqIEByZXR1cm4ge3twYWNrYWdlOiBzdHJpbmd8bnVsbCwgbWVzc2FnZXM6IEFycmF5LjxvYmplY3Q+LCBlbnVtczogQXJyYXkuPG9iamVjdD4sIGltcG9ydHM6IEFycmF5LjxzdHJpbmc+LCBvcHRpb25zOiBvYmplY3Q8c3RyaW5nLCo+fX1cclxuICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBzb3VyY2UgY2Fubm90IGJlIHBhcnNlZFxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdG9wTGV2ZWwgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiW1JPT1RdXCIsIC8vIHRlbXBvcmFyeVxyXG4gICAgICAgICAgICAgICAgICAgIFwicGFja2FnZVwiOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgIFwibWVzc2FnZXNcIjogW10sXHJcbiAgICAgICAgICAgICAgICAgICAgXCJlbnVtc1wiOiBbXSxcclxuICAgICAgICAgICAgICAgICAgICBcImltcG9ydHNcIjogW10sXHJcbiAgICAgICAgICAgICAgICAgICAgXCJvcHRpb25zXCI6IHt9LFxyXG4gICAgICAgICAgICAgICAgICAgIFwic2VydmljZXNcIjogW11cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB2YXIgdG9rZW4sIGhlYWRlciA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSh0b2tlbiA9IHRoaXMudG4ubmV4dCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh0b2tlbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdwYWNrYWdlJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaGVhZGVyIHx8IHRvcExldmVsW1wicGFja2FnZVwiXSAhPT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIklsbGVnYWwgcGFja2FnZSBhdCBsaW5lIFwiK3RoaXMudG4ubGluZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3BMZXZlbFtcInBhY2thZ2VcIl0gPSB0aGlzLl9wYXJzZVBhY2thZ2UodG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2ltcG9ydCc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWhlYWRlcilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIklsbGVnYWwgaW1wb3J0IGF0IGxpbmUgXCIrdGhpcy50bi5saW5lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcExldmVsLmltcG9ydHMucHVzaCh0aGlzLl9wYXJzZUltcG9ydCh0b2tlbikpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ21lc3NhZ2UnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFyc2VNZXNzYWdlKHRvcExldmVsLCBudWxsLCB0b2tlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXIgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdlbnVtJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhcnNlRW51bSh0b3BMZXZlbCwgdG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnb3B0aW9uJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaGVhZGVyKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCBvcHRpb24gYXQgbGluZSBcIit0aGlzLnRuLmxpbmUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFyc2VPcHRpb24odG9wTGV2ZWwsIHRva2VuKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdzZXJ2aWNlJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhcnNlU2VydmljZSh0b3BMZXZlbCwgdG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2V4dGVuZCc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYXJzZUV4dGVuZCh0b3BMZXZlbCwgdG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3N5bnRheCc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYXJzZUlnbm9yZWRTdGF0ZW1lbnQodG9wTGV2ZWwsIHRva2VuKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIHRva2VuIGF0IGxpbmUgXCIrdGhpcy50bi5saW5lK1wiOiBcIit0b2tlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZGVsZXRlIHRvcExldmVsW1wibmFtZVwiXTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0b3BMZXZlbDtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBQYXJzZXMgYSBudW1iZXIgdmFsdWUuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWwgTnVtYmVyIHZhbHVlIHRvIHBhcnNlXHJcbiAgICAgICAgICAgICAqIEByZXR1cm4ge251bWJlcn0gTnVtYmVyXHJcbiAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgbnVtYmVyIHZhbHVlIGlzIGludmFsaWRcclxuICAgICAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFBhcnNlci5wcm90b3R5cGUuX3BhcnNlTnVtYmVyID0gZnVuY3Rpb24odmFsKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2lnbiA9IDE7XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsLmNoYXJBdCgwKSA9PSAnLScpXHJcbiAgICAgICAgICAgICAgICAgICAgc2lnbiA9IC0xLFxyXG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IHZhbC5zdWJzdHJpbmcoMSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoTGFuZy5OVU1CRVJfREVDLnRlc3QodmFsKSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2lnbipwYXJzZUludCh2YWwsIDEwKTtcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKExhbmcuTlVNQkVSX0hFWC50ZXN0KHZhbCkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpZ24qcGFyc2VJbnQodmFsLnN1YnN0cmluZygyKSwgMTYpO1xyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoTGFuZy5OVU1CRVJfT0NULnRlc3QodmFsKSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2lnbipwYXJzZUludCh2YWwuc3Vic3RyaW5nKDEpLCA4KTtcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKExhbmcuTlVNQkVSX0ZMVC50ZXN0KHZhbCkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpZ24qcGFyc2VGbG9hdCh2YWwpO1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIG51bWJlciBhdCBsaW5lIFwiK3RoaXMudG4ubGluZStcIjogXCIrKHNpZ24gPCAwID8gJy0nIDogJycpK3ZhbCk7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUGFyc2VzIGFuIElEIHZhbHVlLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsIElEIHZhbHVlIHRvIHBhcnNlXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IG5lZyBXaGV0aGVyIHRoZSBJRCBtYXkgYmUgbmVnYXRpdmUsIGRlZmF1bHRzIHRvIGBmYWxzZWBcclxuICAgICAgICAgICAgICogQHJldHVybnMge251bWJlcn0gSURcclxuICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBJRCB2YWx1ZSBpcyBpbnZhbGlkXHJcbiAgICAgICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBQYXJzZXIucHJvdG90eXBlLl9wYXJzZUlkID0gZnVuY3Rpb24odmFsLCBuZWcpIHtcclxuICAgICAgICAgICAgICAgIHZhciBpZCA9IC0xO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNpZ24gPSAxO1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhbC5jaGFyQXQoMCkgPT0gJy0nKVxyXG4gICAgICAgICAgICAgICAgICAgIHNpZ24gPSAtMSxcclxuICAgICAgICAgICAgICAgICAgICB2YWwgPSB2YWwuc3Vic3RyaW5nKDEpO1xyXG4gICAgICAgICAgICAgICAgaWYgKExhbmcuTlVNQkVSX0RFQy50ZXN0KHZhbCkpXHJcbiAgICAgICAgICAgICAgICAgICAgaWQgPSBwYXJzZUludCh2YWwpO1xyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoTGFuZy5OVU1CRVJfSEVYLnRlc3QodmFsKSlcclxuICAgICAgICAgICAgICAgICAgICBpZCA9IHBhcnNlSW50KHZhbC5zdWJzdHJpbmcoMiksIDE2KTtcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKExhbmcuTlVNQkVSX09DVC50ZXN0KHZhbCkpXHJcbiAgICAgICAgICAgICAgICAgICAgaWQgPSBwYXJzZUludCh2YWwuc3Vic3RyaW5nKDEpLCA4KTtcclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIklsbGVnYWwgSUQgYXQgbGluZSBcIit0aGlzLnRuLmxpbmUrXCI6IFwiKyhzaWduIDwgMCA/ICctJyA6ICcnKSt2YWwpO1xyXG4gICAgICAgICAgICAgICAgaWQgPSAoc2lnbippZCl8MDsgLy8gRm9yY2UgdG8gMzJiaXRcclxuICAgICAgICAgICAgICAgIGlmICghbmVnICYmIGlkIDwgMClcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIklsbGVnYWwgSUQgYXQgbGluZSBcIit0aGlzLnRuLmxpbmUrXCI6IFwiKyhzaWduIDwgMCA/ICctJyA6ICcnKSt2YWwpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGlkO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFBhcnNlcyB0aGUgcGFja2FnZSBkZWZpbml0aW9uLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdG9rZW4gSW5pdGlhbCB0b2tlblxyXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFBhY2thZ2UgbmFtZVxyXG4gICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBhY2thZ2UgZGVmaW5pdGlvbiBjYW5ub3QgYmUgcGFyc2VkXHJcbiAgICAgICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBQYXJzZXIucHJvdG90eXBlLl9wYXJzZVBhY2thZ2UgPSBmdW5jdGlvbih0b2tlbikge1xyXG4gICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRuLm5leHQoKTtcclxuICAgICAgICAgICAgICAgIGlmICghTGFuZy5UWVBFUkVGLnRlc3QodG9rZW4pKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCBwYWNrYWdlIGF0IGxpbmUgXCIrdGhpcy50bi5saW5lK1wiOiBcIit0b2tlbik7XHJcbiAgICAgICAgICAgICAgICB2YXIgcGtnID0gdG9rZW47XHJcbiAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMudG4ubmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRva2VuICE9IExhbmcuRU5EKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCBlbmQgb2YgcGFja2FnZSBhdCBsaW5lIFwiK3RoaXMudG4ubGluZStcIjogXCIrdG9rZW4rXCIgKCdcIitMYW5nLkVORCtcIicgZXhwZWN0ZWQpXCIpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBrZztcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBQYXJzZXMgYW4gaW1wb3J0IGRlZmluaXRpb24uXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlbiBJbml0aWFsIHRva2VuXHJcbiAgICAgICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gSW1wb3J0IGZpbGUgbmFtZVxyXG4gICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGltcG9ydCBkZWZpbml0aW9uIGNhbm5vdCBiZSBwYXJzZWRcclxuICAgICAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFBhcnNlci5wcm90b3R5cGUuX3BhcnNlSW1wb3J0ID0gZnVuY3Rpb24odG9rZW4pIHtcclxuICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy50bi5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4gPT09IFwicHVibGljXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRuLm5leHQoKTtcclxuICAgICAgICAgICAgICAgIGlmICh0b2tlbiAhPT0gTGFuZy5TVFJJTkdPUEVOICYmIHRva2VuICE9PSBMYW5nLlNUUklOR09QRU5fU1EpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIGltcG9ydCBhdCBsaW5lIFwiK3RoaXMudG4ubGluZStcIjogXCIrdG9rZW4rXCIgKCdcIitMYW5nLlNUUklOR09QRU4rXCInIG9yICdcIitMYW5nLlNUUklOR09QRU5fU1ErXCInIGV4cGVjdGVkKVwiKTtcclxuICAgICAgICAgICAgICAgIHZhciBpbXBvcnRlZCA9IHRoaXMudG4ubmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRuLm5leHQoKTtcclxuICAgICAgICAgICAgICAgIGlmICh0b2tlbiAhPT0gdGhpcy50bi5zdHJpbmdFbmRzV2l0aClcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIklsbGVnYWwgaW1wb3J0IGF0IGxpbmUgXCIrdGhpcy50bi5saW5lK1wiOiBcIit0b2tlbitcIiAoJ1wiK3RoaXMudG4uc3RyaW5nRW5kc1dpdGgrXCInIGV4cGVjdGVkKVwiKTtcclxuICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy50bi5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4gIT09IExhbmcuRU5EKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCBpbXBvcnQgYXQgbGluZSBcIit0aGlzLnRuLmxpbmUrXCI6IFwiK3Rva2VuK1wiICgnXCIrTGFuZy5FTkQrXCInIGV4cGVjdGVkKVwiKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpbXBvcnRlZDtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBQYXJzZXMgYSBuYW1lc3BhY2Ugb3B0aW9uLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyZW50IFBhcmVudCBkZWZpbml0aW9uXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlbiBJbml0aWFsIHRva2VuXHJcbiAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgb3B0aW9uIGNhbm5vdCBiZSBwYXJzZWRcclxuICAgICAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFBhcnNlci5wcm90b3R5cGUuX3BhcnNlT3B0aW9uID0gZnVuY3Rpb24ocGFyZW50LCB0b2tlbikge1xyXG4gICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRuLm5leHQoKTtcclxuICAgICAgICAgICAgICAgIHZhciBjdXN0b20gPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGlmICh0b2tlbiA9PSBMYW5nLkNPUFRPUEVOKVxyXG4gICAgICAgICAgICAgICAgICAgIGN1c3RvbSA9IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRuLm5leHQoKTtcclxuICAgICAgICAgICAgICAgIGlmICghTGFuZy5UWVBFUkVGLnRlc3QodG9rZW4pKVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIGNhbiBhbGxvdyBvcHRpb25zIG9mIHRoZSBmb3JtIGdvb2dsZS5wcm90b2J1Zi4qIHNpbmNlIHRoZXkgd2lsbCBqdXN0IGdldCBpZ25vcmVkIGFueXdheXNcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIS9nb29nbGVcXC5wcm90b2J1ZlxcLi8udGVzdCh0b2tlbikpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCBvcHRpb24gaW4gbWVzc2FnZSBcIitwYXJlbnQubmFtZStcIiBhdCBsaW5lIFwiK3RoaXMudG4ubGluZStcIjogXCIrdG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgdmFyIG5hbWUgPSB0b2tlbjtcclxuICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy50bi5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoY3VzdG9tKSB7IC8vIChteV9tZXRob2Rfb3B0aW9uKS5mb28sIChteV9tZXRob2Rfb3B0aW9uKSwgc29tZV9tZXRob2Rfb3B0aW9uLCAoZm9vLm15X29wdGlvbikuYmFyXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuICE9PSBMYW5nLkNPUFRDTE9TRSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIG9wdGlvbiBpbiBtZXNzYWdlIFwiK3BhcmVudC5uYW1lK1wiLCBvcHRpb24gXCIrbmFtZStcIiBhdCBsaW5lIFwiK3RoaXMudG4ubGluZStcIjogXCIrdG9rZW4rXCIgKCdcIitMYW5nLkNPUFRDTE9TRStcIicgZXhwZWN0ZWQpXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPSAnKCcrbmFtZSsnKSc7XHJcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRuLm5leHQoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoTGFuZy5GUVRZUEVSRUYudGVzdCh0b2tlbikpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgKz0gdG9rZW4sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy50bi5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4gIT09IExhbmcuRVFVQUwpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIG9wdGlvbiBvcGVyYXRvciBpbiBtZXNzYWdlIFwiK3BhcmVudC5uYW1lK1wiLCBvcHRpb24gXCIrbmFtZStcIiBhdCBsaW5lIFwiK3RoaXMudG4ubGluZStcIjogXCIrdG9rZW4rXCIgKCdcIitMYW5nLkVRVUFMK1wiJyBleHBlY3RlZClcIik7XHJcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWU7XHJcbiAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMudG4ubmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRva2VuID09PSBMYW5nLlNUUklOR09QRU4gfHwgdG9rZW4gPT09IExhbmcuU1RSSU5HT1BFTl9TUSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy50bi5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRuLm5leHQoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW4gIT09IHRoaXMudG4uc3RyaW5nRW5kc1dpdGgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCBlbmQgb2Ygb3B0aW9uIHZhbHVlIGluIG1lc3NhZ2UgXCIrcGFyZW50Lm5hbWUrXCIsIG9wdGlvbiBcIituYW1lK1wiIGF0IGxpbmUgXCIrdGhpcy50bi5saW5lK1wiOiBcIit0b2tlbitcIiAoJ1wiK3RoaXMudG4uc3RyaW5nRW5kc1dpdGgrXCInIGV4cGVjdGVkKVwiKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKExhbmcuTlVNQkVSLnRlc3QodG9rZW4pKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMuX3BhcnNlTnVtYmVyKHRva2VuLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChMYW5nLkJPT0wudGVzdCh0b2tlbikpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdG9rZW4gPT09ICd0cnVlJztcclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChMYW5nLlRZUEVSRUYudGVzdCh0b2tlbikpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdG9rZW47XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIklsbGVnYWwgb3B0aW9uIHZhbHVlIGluIG1lc3NhZ2UgXCIrcGFyZW50Lm5hbWUrXCIsIG9wdGlvbiBcIituYW1lK1wiIGF0IGxpbmUgXCIrdGhpcy50bi5saW5lK1wiOiBcIit0b2tlbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMudG4ubmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRva2VuICE9PSBMYW5nLkVORClcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIklsbGVnYWwgZW5kIG9mIG9wdGlvbiBpbiBtZXNzYWdlIFwiK3BhcmVudC5uYW1lK1wiLCBvcHRpb24gXCIrbmFtZStcIiBhdCBsaW5lIFwiK3RoaXMudG4ubGluZStcIjogXCIrdG9rZW4rXCIgKCdcIitMYW5nLkVORCtcIicgZXhwZWN0ZWQpXCIpO1xyXG4gICAgICAgICAgICAgICAgcGFyZW50W1wib3B0aW9uc1wiXVtuYW1lXSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFBhcnNlcyBhbiBpZ25vcmVkIHN0YXRlbWVudCBvZiB0aGUgZm9ybSBbJ2tleXdvcmQnLCAuLi4sICc7J10uXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJlbnQgUGFyZW50IGRlZmluaXRpb25cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGtleXdvcmQgSW5pdGlhbCB0b2tlblxyXG4gICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGRpcmVjdGl2ZSBjYW5ub3QgYmUgcGFyc2VkXHJcbiAgICAgICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBQYXJzZXIucHJvdG90eXBlLl9wYXJzZUlnbm9yZWRTdGF0ZW1lbnQgPSBmdW5jdGlvbihwYXJlbnQsIGtleXdvcmQpIHtcclxuICAgICAgICAgICAgICAgIHZhciB0b2tlbjtcclxuICAgICAgICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMudG4ubmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbiA9PT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJVbmV4cGVjdGVkIEVPRiBpbiBcIitwYXJlbnQubmFtZStcIiwgXCIra2V5d29yZCtcIiAoaWdub3JlZCkgYXQgbGluZSBcIit0aGlzLnRuLmxpbmUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbiA9PT0gTGFuZy5FTkQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfSB3aGlsZSAodHJ1ZSk7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUGFyc2VzIGEgc2VydmljZSBkZWZpbml0aW9uLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyZW50IFBhcmVudCBkZWZpbml0aW9uXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlbiBJbml0aWFsIHRva2VuXHJcbiAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgc2VydmljZSBjYW5ub3QgYmUgcGFyc2VkXHJcbiAgICAgICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBQYXJzZXIucHJvdG90eXBlLl9wYXJzZVNlcnZpY2UgPSBmdW5jdGlvbihwYXJlbnQsIHRva2VuKSB7XHJcbiAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMudG4ubmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFMYW5nLk5BTUUudGVzdCh0b2tlbikpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIHNlcnZpY2UgbmFtZSBhdCBsaW5lIFwiK3RoaXMudG4ubGluZStcIjogXCIrdG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgdmFyIG5hbWUgPSB0b2tlbjtcclxuICAgICAgICAgICAgICAgIHZhciBzdmMgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgXCJuYW1lXCI6IG5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJycGNcIjoge30sXHJcbiAgICAgICAgICAgICAgICAgICAgXCJvcHRpb25zXCI6IHt9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRuLm5leHQoKTtcclxuICAgICAgICAgICAgICAgIGlmICh0b2tlbiAhPT0gTGFuZy5PUEVOKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCBPUEVOIGFmdGVyIHNlcnZpY2UgXCIrbmFtZStcIiBhdCBsaW5lIFwiK3RoaXMudG4ubGluZStcIjogXCIrdG9rZW4rXCIgKCdcIitMYW5nLk9QRU4rXCInIGV4cGVjdGVkKVwiKTtcclxuICAgICAgICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMudG4ubmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbiA9PT0gXCJvcHRpb25cIilcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFyc2VPcHRpb24oc3ZjLCB0b2tlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodG9rZW4gPT09ICdycGMnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYXJzZVNlcnZpY2VSUEMoc3ZjLCB0b2tlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodG9rZW4gIT09IExhbmcuQ0xPU0UpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCB0eXBlIGZvciBzZXJ2aWNlIFwiK25hbWUrXCIgYXQgbGluZSBcIit0aGlzLnRuLmxpbmUrXCI6IFwiK3Rva2VuKTtcclxuICAgICAgICAgICAgICAgIH0gd2hpbGUgKHRva2VuICE9PSBMYW5nLkNMT1NFKTtcclxuICAgICAgICAgICAgICAgIHBhcmVudFtcInNlcnZpY2VzXCJdLnB1c2goc3ZjKTtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBQYXJzZXMgYSBSUEMgc2VydmljZSBkZWZpbml0aW9uIG9mIHRoZSBmb3JtIFsncnBjJywgbmFtZSwgKHJlcXVlc3QpLCAncmV0dXJucycsIChyZXNwb25zZSldLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gc3ZjIFBhcmVudCBkZWZpbml0aW9uXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlbiBJbml0aWFsIHRva2VuXHJcbiAgICAgICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBQYXJzZXIucHJvdG90eXBlLl9wYXJzZVNlcnZpY2VSUEMgPSBmdW5jdGlvbihzdmMsIHRva2VuKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IHRva2VuO1xyXG4gICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRuLm5leHQoKTtcclxuICAgICAgICAgICAgICAgIGlmICghTGFuZy5OQU1FLnRlc3QodG9rZW4pKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCBSUEMgbWV0aG9kIG5hbWUgaW4gc2VydmljZSBcIitzdmNbXCJuYW1lXCJdK1wiIGF0IGxpbmUgXCIrdGhpcy50bi5saW5lK1wiOiBcIit0b2tlbik7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IHRva2VuO1xyXG4gICAgICAgICAgICAgICAgdmFyIG1ldGhvZCA9IHtcclxuICAgICAgICAgICAgICAgICAgICBcInJlcXVlc3RcIjogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICBcInJlc3BvbnNlXCI6IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJvcHRpb25zXCI6IHt9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRuLm5leHQoKTtcclxuICAgICAgICAgICAgICAgIGlmICh0b2tlbiAhPT0gTGFuZy5DT1BUT1BFTilcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIklsbGVnYWwgc3RhcnQgb2YgcmVxdWVzdCB0eXBlIGluIFJQQyBzZXJ2aWNlIFwiK3N2Y1tcIm5hbWVcIl0rXCIjXCIrbmFtZStcIiBhdCBsaW5lIFwiK3RoaXMudG4ubGluZStcIjogXCIrdG9rZW4rXCIgKCdcIitMYW5nLkNPUFRPUEVOK1wiJyBleHBlY3RlZClcIik7XHJcbiAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMudG4ubmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFMYW5nLlRZUEVSRUYudGVzdCh0b2tlbikpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIHJlcXVlc3QgdHlwZSBpbiBSUEMgc2VydmljZSBcIitzdmNbXCJuYW1lXCJdK1wiI1wiK25hbWUrXCIgYXQgbGluZSBcIit0aGlzLnRuLmxpbmUrXCI6IFwiK3Rva2VuKTtcclxuICAgICAgICAgICAgICAgIG1ldGhvZFtcInJlcXVlc3RcIl0gPSB0b2tlbjtcclxuICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy50bi5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4gIT0gTGFuZy5DT1BUQ0xPU0UpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIGVuZCBvZiByZXF1ZXN0IHR5cGUgaW4gUlBDIHNlcnZpY2UgXCIrc3ZjW1wibmFtZVwiXStcIiNcIituYW1lK1wiIGF0IGxpbmUgXCIrdGhpcy50bi5saW5lK1wiOiBcIit0b2tlbitcIiAoJ1wiK0xhbmcuQ09QVENMT1NFK1wiJyBleHBlY3RlZClcIik7XHJcbiAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMudG4ubmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRva2VuLnRvTG93ZXJDYXNlKCkgIT09IFwicmV0dXJuc1wiKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCByZXF1ZXN0L3Jlc3BvbnNlIGRlbGltaXRlciBpbiBSUEMgc2VydmljZSBcIitzdmNbXCJuYW1lXCJdK1wiI1wiK25hbWUrXCIgYXQgbGluZSBcIit0aGlzLnRuLmxpbmUrXCI6IFwiK3Rva2VuK1wiICgncmV0dXJucycgZXhwZWN0ZWQpXCIpO1xyXG4gICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRuLm5leHQoKTtcclxuICAgICAgICAgICAgICAgIGlmICh0b2tlbiAhPSBMYW5nLkNPUFRPUEVOKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCBzdGFydCBvZiByZXNwb25zZSB0eXBlIGluIFJQQyBzZXJ2aWNlIFwiK3N2Y1tcIm5hbWVcIl0rXCIjXCIrbmFtZStcIiBhdCBsaW5lIFwiK3RoaXMudG4ubGluZStcIjogXCIrdG9rZW4rXCIgKCdcIitMYW5nLkNPUFRPUEVOK1wiJyBleHBlY3RlZClcIik7XHJcbiAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMudG4ubmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgbWV0aG9kW1wicmVzcG9uc2VcIl0gPSB0b2tlbjtcclxuICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy50bi5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4gIT09IExhbmcuQ09QVENMT1NFKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCBlbmQgb2YgcmVzcG9uc2UgdHlwZSBpbiBSUEMgc2VydmljZSBcIitzdmNbXCJuYW1lXCJdK1wiI1wiK25hbWUrXCIgYXQgbGluZSBcIit0aGlzLnRuLmxpbmUrXCI6IFwiK3Rva2VuK1wiICgnXCIrTGFuZy5DT1BUQ0xPU0UrXCInIGV4cGVjdGVkKVwiKTtcclxuICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy50bi5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4gPT09IExhbmcuT1BFTikge1xyXG4gICAgICAgICAgICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRuLm5leHQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuID09PSAnb3B0aW9uJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhcnNlT3B0aW9uKG1ldGhvZCwgdG9rZW4pOyAvLyA8LSB3aWxsIGZhaWwgZm9yIHRoZSBjdXN0b20tb3B0aW9ucyBleGFtcGxlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRva2VuICE9PSBMYW5nLkNMT1NFKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIHN0YXJ0IG9mIG9wdGlvbiBpbiBSUEMgc2VydmljZSBcIitzdmNbXCJuYW1lXCJdK1wiI1wiK25hbWUrXCIgYXQgbGluZSBcIit0aGlzLnRuLmxpbmUrXCI6IFwiK3Rva2VuK1wiICgnb3B0aW9uJyBleHBlY3RlZClcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAodG9rZW4gIT09IExhbmcuQ0xPU0UpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnRuLnBlZWsoKSA9PT0gTGFuZy5FTkQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudG4ubmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0b2tlbiAhPT0gTGFuZy5FTkQpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIG1ldGhvZCBkZWxpbWl0ZXIgaW4gUlBDIHNlcnZpY2UgXCIrc3ZjW1wibmFtZVwiXStcIiNcIituYW1lK1wiIGF0IGxpbmUgXCIrdGhpcy50bi5saW5lK1wiOiBcIit0b2tlbitcIiAoJ1wiK0xhbmcuRU5EK1wiJyBvciAnXCIrTGFuZy5PUEVOK1wiJyBleHBlY3RlZClcIik7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHN2Y1t0eXBlXSA9PT0gJ3VuZGVmaW5lZCcpXHJcbiAgICAgICAgICAgICAgICAgICAgc3ZjW3R5cGVdID0ge307XHJcbiAgICAgICAgICAgICAgICBzdmNbdHlwZV1bbmFtZV0gPSBtZXRob2Q7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUGFyc2VzIGEgbWVzc2FnZSBkZWZpbml0aW9uLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyZW50IFBhcmVudCBkZWZpbml0aW9uXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBmbGQgRmllbGQgZGVmaW5pdGlvbiBpZiB0aGlzIGlzIGEgZ3JvdXAsIG90aGVyd2lzZSBgbnVsbGBcclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHRva2VuIEZpcnN0IHRva2VuXHJcbiAgICAgICAgICAgICAqIEByZXR1cm4ge09iamVjdH1cclxuICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBtZXNzYWdlIGNhbm5vdCBiZSBwYXJzZWRcclxuICAgICAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFBhcnNlci5wcm90b3R5cGUuX3BhcnNlTWVzc2FnZSA9IGZ1bmN0aW9uKHBhcmVudCwgZmxkLCB0b2tlbikge1xyXG4gICAgICAgICAgICAgICAgLyoqIEBkaWN0ICovXHJcbiAgICAgICAgICAgICAgICB2YXIgbXNnID0ge307IC8vIE5vdGU6IEF0IHNvbWUgcG9pbnQgd2UgbWlnaHQgd2FudCB0byBleGNsdWRlIHRoZSBwYXJzZXIsIHNvIHdlIG5lZWQgYSBkaWN0LlxyXG4gICAgICAgICAgICAgICAgdmFyIGlzR3JvdXAgPSB0b2tlbiA9PT0gXCJncm91cFwiO1xyXG4gICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRuLm5leHQoKTtcclxuICAgICAgICAgICAgICAgIGlmICghTGFuZy5OQU1FLnRlc3QodG9rZW4pKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCBcIisoaXNHcm91cCA/IFwiZ3JvdXBcIiA6IFwibWVzc2FnZVwiKStcIiBuYW1lXCIrKHBhcmVudCA/IFwiIGluIG1lc3NhZ2UgXCIrcGFyZW50W1wibmFtZVwiXSA6IFwiXCIpK1wiIGF0IGxpbmUgXCIrdGhpcy50bi5saW5lK1wiOiBcIit0b2tlbik7XHJcbiAgICAgICAgICAgICAgICBtc2dbXCJuYW1lXCJdID0gdG9rZW47XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNHcm91cCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy50bi5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuICE9PSBMYW5nLkVRVUFMKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIklsbGVnYWwgaWQgYXNzaWdubWVudCBhZnRlciBncm91cCBcIittc2cubmFtZStcIiBhdCBsaW5lIFwiK3RoaXMudG4ubGluZStcIjogXCIrdG9rZW4rXCIgKCdcIitMYW5nLkVRVUFMK1wiJyBleHBlY3RlZClcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRuLm5leHQoKTtcclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmbGRbXCJpZFwiXSA9IHRoaXMuX3BhcnNlSWQodG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIGZpZWxkIGlkIHZhbHVlIGZvciBncm91cCBcIittc2cubmFtZStcIiNcIitmbGQubmFtZStcIiBhdCBsaW5lIFwiK3RoaXMudG4ubGluZStcIjogXCIrdG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBtc2dbXCJpc0dyb3VwXCJdID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG1zZ1tcImZpZWxkc1wiXSA9IFtdOyAvLyBOb3RlOiBVc2luZyBhcnJheXMgdG8gc3VwcG9ydCBhbHNvIGJyb3dzZXIgdGhhdCBjYW5ub3QgcHJlc2VydmUgb3JkZXIgb2Ygb2JqZWN0IGtleXMuXHJcbiAgICAgICAgICAgICAgICBtc2dbXCJlbnVtc1wiXSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgbXNnW1wibWVzc2FnZXNcIl0gPSBbXTtcclxuICAgICAgICAgICAgICAgIG1zZ1tcIm9wdGlvbnNcIl0gPSB7fTtcclxuICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy50bi5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4gPT09IExhbmcuT1BUT1BFTiAmJiBmbGQpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFyc2VGaWVsZE9wdGlvbnMobXNnLCBmbGQsIHRva2VuKSxcclxuICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMudG4ubmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRva2VuICE9PSBMYW5nLk9QRU4pXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIE9QRU4gYWZ0ZXIgXCIrKGlzR3JvdXAgPyBcImdyb3VwXCIgOiBcIm1lc3NhZ2VcIikrXCIgXCIrbXNnLm5hbWUrXCIgYXQgbGluZSBcIit0aGlzLnRuLmxpbmUrXCI6IFwiK3Rva2VuK1wiICgnXCIrTGFuZy5PUEVOK1wiJyBleHBlY3RlZClcIik7XHJcbiAgICAgICAgICAgICAgICAvLyBtc2dbXCJleHRlbnNpb25zXCJdID0gdW5kZWZpbmVkXHJcbiAgICAgICAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRuLm5leHQoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW4gPT09IExhbmcuQ0xPU0UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRuLnBlZWsoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuID09PSBMYW5nLkVORClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudG4ubmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKExhbmcuUlVMRS50ZXN0KHRva2VuKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFyc2VNZXNzYWdlRmllbGQobXNnLCB0b2tlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodG9rZW4gPT09IFwiZW51bVwiKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYXJzZUVudW0obXNnLCB0b2tlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodG9rZW4gPT09IFwibWVzc2FnZVwiKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYXJzZU1lc3NhZ2UobXNnLCBudWxsLCB0b2tlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodG9rZW4gPT09IFwib3B0aW9uXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhcnNlT3B0aW9uKG1zZywgdG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRva2VuID09PSBcImV4dGVuc2lvbnNcIilcclxuICAgICAgICAgICAgICAgICAgICAgICAgbXNnW1wiZXh0ZW5zaW9uc1wiXSA9IHRoaXMuX3BhcnNlRXh0ZW5zaW9ucyhtc2csIHRva2VuKTtcclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0b2tlbiA9PT0gXCJleHRlbmRcIilcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFyc2VFeHRlbmQobXNnLCB0b2tlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIklsbGVnYWwgdG9rZW4gaW4gbWVzc2FnZSBcIittc2cubmFtZStcIiBhdCBsaW5lIFwiK3RoaXMudG4ubGluZStcIjogXCIrdG9rZW4rXCIgKHR5cGUgb3IgJ1wiK0xhbmcuQ0xPU0UrXCInIGV4cGVjdGVkKVwiKTtcclxuICAgICAgICAgICAgICAgIH0gd2hpbGUgKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgcGFyZW50W1wibWVzc2FnZXNcIl0ucHVzaChtc2cpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1zZztcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBQYXJzZXMgYSBtZXNzYWdlIGZpZWxkLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gbXNnIE1lc3NhZ2UgZGVmaW5pdGlvblxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdG9rZW4gSW5pdGlhbCB0b2tlblxyXG4gICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIG1lc3NhZ2UgZmllbGQgY2Fubm90IGJlIHBhcnNlZFxyXG4gICAgICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgUGFyc2VyLnByb3RvdHlwZS5fcGFyc2VNZXNzYWdlRmllbGQgPSBmdW5jdGlvbihtc2csIHRva2VuKSB7XHJcbiAgICAgICAgICAgICAgICAvKiogQGRpY3QgKi9cclxuICAgICAgICAgICAgICAgIHZhciBmbGQgPSB7fSwgZ3JwID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIGZsZFtcInJ1bGVcIl0gPSB0b2tlbjtcclxuICAgICAgICAgICAgICAgIC8qKiBAZGljdCAqL1xyXG4gICAgICAgICAgICAgICAgZmxkW1wib3B0aW9uc1wiXSA9IHt9O1xyXG4gICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRuLm5leHQoKTtcclxuICAgICAgICAgICAgICAgIGlmICh0b2tlbiA9PT0gXCJncm91cFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gXCJBIFtsZWdhY3ldIGdyb3VwIHNpbXBseSBjb21iaW5lcyBhIG5lc3RlZCBtZXNzYWdlIHR5cGUgYW5kIGEgZmllbGQgaW50byBhIHNpbmdsZSBkZWNsYXJhdGlvbi4gSW4geW91clxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvZGUsIHlvdSBjYW4gdHJlYXQgdGhpcyBtZXNzYWdlIGp1c3QgYXMgaWYgaXQgaGFkIGEgUmVzdWx0IHR5cGUgZmllbGQgY2FsbGVkIHJlc3VsdCAodGhlIGxhdHRlciBuYW1lIGlzXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gY29udmVydGVkIHRvIGxvd2VyLWNhc2Ugc28gdGhhdCBpdCBkb2VzIG5vdCBjb25mbGljdCB3aXRoIHRoZSBmb3JtZXIpLlwiXHJcbiAgICAgICAgICAgICAgICAgICAgZ3JwID0gdGhpcy5fcGFyc2VNZXNzYWdlKG1zZywgZmxkLCB0b2tlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEvXltBLVpdLy50ZXN0KGdycFtcIm5hbWVcIl0pKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcignR3JvdXAgbmFtZXMgbXVzdCBzdGFydCB3aXRoIGEgY2FwaXRhbCBsZXR0ZXInKTtcclxuICAgICAgICAgICAgICAgICAgICBmbGRbXCJ0eXBlXCJdID0gZ3JwW1wibmFtZVwiXTtcclxuICAgICAgICAgICAgICAgICAgICBmbGRbXCJuYW1lXCJdID0gZ3JwW1wibmFtZVwiXS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy50bi5wZWVrKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuID09PSBMYW5nLkVORClcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50bi5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghTGFuZy5UWVBFLnRlc3QodG9rZW4pICYmICFMYW5nLlRZUEVSRUYudGVzdCh0b2tlbikpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCBmaWVsZCB0eXBlIGluIG1lc3NhZ2UgXCIrbXNnLm5hbWUrXCIgYXQgbGluZSBcIit0aGlzLnRuLmxpbmUrXCI6IFwiK3Rva2VuKTtcclxuICAgICAgICAgICAgICAgICAgICBmbGRbXCJ0eXBlXCJdID0gdG9rZW47XHJcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRuLm5leHQoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIUxhbmcuTkFNRS50ZXN0KHRva2VuKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIGZpZWxkIG5hbWUgaW4gbWVzc2FnZSBcIittc2cubmFtZStcIiBhdCBsaW5lIFwiK3RoaXMudG4ubGluZStcIjogXCIrdG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIGZsZFtcIm5hbWVcIl0gPSB0b2tlbjtcclxuICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMudG4ubmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbiAhPT0gTGFuZy5FUVVBTClcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIGZpZWxkIGlkIGFzc2lnbm1lbnQgaW4gbWVzc2FnZSBcIittc2cubmFtZStcIiNcIitmbGQubmFtZStcIiBhdCBsaW5lIFwiK3RoaXMudG4ubGluZStcIjogXCIrdG9rZW4rXCIgKCdcIitMYW5nLkVRVUFMK1wiJyBleHBlY3RlZClcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRuLm5leHQoKTtcclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmbGRbXCJpZFwiXSA9IHRoaXMuX3BhcnNlSWQodG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIGZpZWxkIGlkIHZhbHVlIGluIG1lc3NhZ2UgXCIrbXNnLm5hbWUrXCIjXCIrZmxkLm5hbWUrXCIgYXQgbGluZSBcIit0aGlzLnRuLmxpbmUrXCI6IFwiK3Rva2VuKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRuLm5leHQoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW4gPT09IExhbmcuT1BUT1BFTilcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFyc2VGaWVsZE9wdGlvbnMobXNnLCBmbGQsIHRva2VuKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRuLm5leHQoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW4gIT09IExhbmcuRU5EKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIklsbGVnYWwgZmllbGQgZGVsaW1pdGVyIGluIG1lc3NhZ2UgXCIrbXNnLm5hbWUrXCIjXCIrZmxkLm5hbWUrXCIgYXQgbGluZSBcIit0aGlzLnRuLmxpbmUrXCI6IFwiK3Rva2VuK1wiICgnXCIrTGFuZy5FTkQrXCInIGV4cGVjdGVkKVwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG1zZ1tcImZpZWxkc1wiXS5wdXNoKGZsZCk7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUGFyc2VzIGEgc2V0IG9mIGZpZWxkIG9wdGlvbiBkZWZpbml0aW9ucy5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG1zZyBNZXNzYWdlIGRlZmluaXRpb25cclxuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGZsZCBGaWVsZCBkZWZpbml0aW9uXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlbiBJbml0aWFsIHRva2VuXHJcbiAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgbWVzc2FnZSBmaWVsZCBvcHRpb25zIGNhbm5vdCBiZSBwYXJzZWRcclxuICAgICAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFBhcnNlci5wcm90b3R5cGUuX3BhcnNlRmllbGRPcHRpb25zID0gZnVuY3Rpb24obXNnLCBmbGQsIHRva2VuKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZmlyc3QgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy50bi5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuID09PSBMYW5nLk9QVENMT1NFKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0b2tlbiA9PT0gTGFuZy5PUFRFTkQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpcnN0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIHN0YXJ0IG9mIG1lc3NhZ2UgZmllbGQgb3B0aW9ucyBpbiBtZXNzYWdlIFwiK21zZy5uYW1lK1wiI1wiK2ZsZC5uYW1lK1wiIGF0IGxpbmUgXCIrdGhpcy50bi5saW5lK1wiOiBcIit0b2tlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy50bi5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhcnNlRmllbGRPcHRpb24obXNnLCBmbGQsIHRva2VuKTtcclxuICAgICAgICAgICAgICAgICAgICBmaXJzdCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfSB3aGlsZSAodHJ1ZSk7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUGFyc2VzIGEgc2luZ2xlIGZpZWxkIG9wdGlvbi5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG1zZyBNZXNzYWdlIGRlZmluaXRpb25cclxuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGZsZCBGaWVsZCBkZWZpbml0aW9uXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlbiBJbml0aWFsIHRva2VuXHJcbiAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgbWVzYWdlIGZpZWxkIG9wdGlvbiBjYW5ub3QgYmUgcGFyc2VkXHJcbiAgICAgICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBQYXJzZXIucHJvdG90eXBlLl9wYXJzZUZpZWxkT3B0aW9uID0gZnVuY3Rpb24obXNnLCBmbGQsIHRva2VuKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY3VzdG9tID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4gPT09IExhbmcuQ09QVE9QRU4pXHJcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRuLm5leHQoKSxcclxuICAgICAgICAgICAgICAgICAgICBjdXN0b20gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFMYW5nLlRZUEVSRUYudGVzdCh0b2tlbikpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIGZpZWxkIG9wdGlvbiBpbiBtZXNzYWdlIFwiK21zZy5uYW1lK1wiI1wiK2ZsZC5uYW1lK1wiIGF0IGxpbmUgXCIrdGhpcy50bi5saW5lK1wiOiBcIit0b2tlbik7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IHRva2VuO1xyXG4gICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRuLm5leHQoKTtcclxuICAgICAgICAgICAgICAgIGlmIChjdXN0b20pIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW4gIT09IExhbmcuQ09QVENMT1NFKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIklsbGVnYWwgY3VzdG9tIGZpZWxkIG9wdGlvbiBuYW1lIGRlbGltaXRlciBpbiBtZXNzYWdlIFwiK21zZy5uYW1lK1wiI1wiK2ZsZC5uYW1lK1wiIGF0IGxpbmUgXCIrdGhpcy50bi5saW5lK1wiOiBcIit0b2tlbitcIiAoJyknIGV4cGVjdGVkKVwiKTtcclxuICAgICAgICAgICAgICAgICAgICBuYW1lID0gJygnK25hbWUrJyknO1xyXG4gICAgICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy50bi5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKExhbmcuRlFUWVBFUkVGLnRlc3QodG9rZW4pKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lICs9IHRva2VuLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMudG4ubmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHRva2VuICE9PSBMYW5nLkVRVUFMKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCBmaWVsZCBvcHRpb24gb3BlcmF0aW9uIGluIG1lc3NhZ2UgXCIrbXNnLm5hbWUrXCIjXCIrZmxkLm5hbWUrXCIgYXQgbGluZSBcIit0aGlzLnRuLmxpbmUrXCI6IFwiK3Rva2VuK1wiICgnPScgZXhwZWN0ZWQpXCIpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRuLm5leHQoKTtcclxuICAgICAgICAgICAgICAgIGlmICh0b2tlbiA9PT0gTGFuZy5TVFJJTkdPUEVOIHx8IHRva2VuID09PSBMYW5nLlNUUklOR09QRU5fU1EpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMudG4ubmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy50bi5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuICE9IHRoaXMudG4uc3RyaW5nRW5kc1dpdGgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCBlbmQgb2YgZmllbGQgdmFsdWUgaW4gbWVzc2FnZSBcIittc2cubmFtZStcIiNcIitmbGQubmFtZStcIiwgb3B0aW9uIFwiK25hbWUrXCIgYXQgbGluZSBcIit0aGlzLnRuLmxpbmUrXCI6IFwiK3Rva2VuK1wiICgnXCIrdGhpcy50bi5zdHJpbmdFbmRzV2l0aCtcIicgZXhwZWN0ZWQpXCIpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChMYW5nLk5VTUJFUi50ZXN0KHRva2VuLCB0cnVlKSlcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMuX3BhcnNlTnVtYmVyKHRva2VuLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKExhbmcuQk9PTC50ZXN0KHRva2VuKSlcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRva2VuLnRvTG93ZXJDYXNlKCkgPT09ICd0cnVlJztcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKExhbmcuVFlQRVJFRi50ZXN0KHRva2VuKSlcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRva2VuOyAvLyBUT0RPOiBSZXNvbHZlP1xyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCBmaWVsZCBvcHRpb24gdmFsdWUgaW4gbWVzc2FnZSBcIittc2cubmFtZStcIiNcIitmbGQubmFtZStcIiwgb3B0aW9uIFwiK25hbWUrXCIgYXQgbGluZSBcIit0aGlzLnRuLmxpbmUrXCI6IFwiK3Rva2VuKTtcclxuICAgICAgICAgICAgICAgIGZsZFtcIm9wdGlvbnNcIl1bbmFtZV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBQYXJzZXMgYW4gZW51bS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG1zZyBNZXNzYWdlIGRlZmluaXRpb25cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHRva2VuIEluaXRpYWwgdG9rZW5cclxuICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBlbnVtIGNhbm5vdCBiZSBwYXJzZWRcclxuICAgICAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFBhcnNlci5wcm90b3R5cGUuX3BhcnNlRW51bSA9IGZ1bmN0aW9uKG1zZywgdG9rZW4pIHtcclxuICAgICAgICAgICAgICAgIC8qKiBAZGljdCAqL1xyXG4gICAgICAgICAgICAgICAgdmFyIGVubSA9IHt9O1xyXG4gICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRuLm5leHQoKTtcclxuICAgICAgICAgICAgICAgIGlmICghTGFuZy5OQU1FLnRlc3QodG9rZW4pKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCBlbnVtIG5hbWUgaW4gbWVzc2FnZSBcIittc2cubmFtZStcIiBhdCBsaW5lIFwiK3RoaXMudG4ubGluZStcIjogXCIrdG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgZW5tW1wibmFtZVwiXSA9IHRva2VuO1xyXG4gICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRuLm5leHQoKTtcclxuICAgICAgICAgICAgICAgIGlmICh0b2tlbiAhPT0gTGFuZy5PUEVOKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCBPUEVOIGFmdGVyIGVudW0gXCIrZW5tLm5hbWUrXCIgYXQgbGluZSBcIit0aGlzLnRuLmxpbmUrXCI6IFwiK3Rva2VuKTtcclxuICAgICAgICAgICAgICAgIGVubVtcInZhbHVlc1wiXSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgZW5tW1wib3B0aW9uc1wiXSA9IHt9O1xyXG4gICAgICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy50bi5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuID09PSBMYW5nLkNMT1NFKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy50bi5wZWVrKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbiA9PT0gTGFuZy5FTkQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRuLm5leHQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbiA9PSAnb3B0aW9uJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFyc2VPcHRpb24oZW5tLCB0b2tlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghTGFuZy5OQU1FLnRlc3QodG9rZW4pKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIGVudW0gdmFsdWUgbmFtZSBpbiBlbnVtIFwiK2VubS5uYW1lK1wiIGF0IGxpbmUgXCIrdGhpcy50bi5saW5lK1wiOiBcIit0b2tlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhcnNlRW51bVZhbHVlKGVubSwgdG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gd2hpbGUgKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgbXNnW1wiZW51bXNcIl0ucHVzaChlbm0pO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFBhcnNlcyBhbiBlbnVtIHZhbHVlLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZW5tIEVudW0gZGVmaW5pdGlvblxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdG9rZW4gSW5pdGlhbCB0b2tlblxyXG4gICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGVudW0gdmFsdWUgY2Fubm90IGJlIHBhcnNlZFxyXG4gICAgICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgUGFyc2VyLnByb3RvdHlwZS5fcGFyc2VFbnVtVmFsdWUgPSBmdW5jdGlvbihlbm0sIHRva2VuKSB7XHJcbiAgICAgICAgICAgICAgICAvKiogQGRpY3QgKi9cclxuICAgICAgICAgICAgICAgIHZhciB2YWwgPSB7fTtcclxuICAgICAgICAgICAgICAgIHZhbFtcIm5hbWVcIl0gPSB0b2tlbjtcclxuICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy50bi5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4gIT09IExhbmcuRVFVQUwpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIGVudW0gdmFsdWUgb3BlcmF0b3IgaW4gZW51bSBcIitlbm0ubmFtZStcIiBhdCBsaW5lIFwiK3RoaXMudG4ubGluZStcIjogXCIrdG9rZW4rXCIgKCdcIitMYW5nLkVRVUFMK1wiJyBleHBlY3RlZClcIik7XHJcbiAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMudG4ubmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICB2YWxbXCJpZFwiXSA9IHRoaXMuX3BhcnNlSWQodG9rZW4sIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCBlbnVtIHZhbHVlIGlkIGluIGVudW0gXCIrZW5tLm5hbWUrXCIgYXQgbGluZSBcIit0aGlzLnRuLmxpbmUrXCI6IFwiK3Rva2VuKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVubVtcInZhbHVlc1wiXS5wdXNoKHZhbCk7XHJcbiAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMudG4ubmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRva2VuID09PSBMYW5nLk9QVE9QRU4pIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgb3B0ID0geyAnb3B0aW9ucycgOiB7fSB9OyAvLyBUT0RPOiBBY3R1YWxseSBleHBvc2UgdGhlbSBzb21laG93LlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhcnNlRmllbGRPcHRpb25zKGVubSwgb3B0LCB0b2tlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRuLm5leHQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0b2tlbiAhPT0gTGFuZy5FTkQpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIGVudW0gdmFsdWUgZGVsaW1pdGVyIGluIGVudW0gXCIrZW5tLm5hbWUrXCIgYXQgbGluZSBcIit0aGlzLnRuLmxpbmUrXCI6IFwiK3Rva2VuK1wiICgnXCIrTGFuZy5FTkQrXCInIGV4cGVjdGVkKVwiKTtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBQYXJzZXMgYW4gZXh0ZW5zaW9ucyBzdGF0ZW1lbnQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtc2cgTWVzc2FnZSBvYmplY3RcclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHRva2VuIEluaXRpYWwgdG9rZW5cclxuICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBleHRlbnNpb25zIHN0YXRlbWVudCBjYW5ub3QgYmUgcGFyc2VkXHJcbiAgICAgICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBQYXJzZXIucHJvdG90eXBlLl9wYXJzZUV4dGVuc2lvbnMgPSBmdW5jdGlvbihtc2csIHRva2VuKSB7XHJcbiAgICAgICAgICAgICAgICAvKiogQHR5cGUge0FycmF5LjxudW1iZXI+fSAqL1xyXG4gICAgICAgICAgICAgICAgdmFyIHJhbmdlID0gW107XHJcbiAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMudG4ubmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRva2VuID09PSBcIm1pblwiKSAvLyBGSVhNRTogRG9lcyB0aGUgb2ZmaWNpYWwgaW1wbGVtZW50YXRpb24gc3VwcG9ydCB0aGlzP1xyXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlLnB1c2goUHJvdG9CdWYuSURfTUlOKTtcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRva2VuID09PSBcIm1heFwiKVxyXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlLnB1c2goUHJvdG9CdWYuSURfTUFYKTtcclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICByYW5nZS5wdXNoKHRoaXMuX3BhcnNlTnVtYmVyKHRva2VuKSk7XHJcbiAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMudG4ubmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRva2VuICE9PSAndG8nKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCBleHRlbnNpb25zIGRlbGltaXRlciBpbiBtZXNzYWdlIFwiK21zZy5uYW1lK1wiIGF0IGxpbmUgXCIrdGhpcy50bi5saW5lK1wiICgndG8nIGV4cGVjdGVkKVwiKTtcclxuICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy50bi5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4gPT09IFwibWluXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2UucHVzaChQcm90b0J1Zi5JRF9NSU4pO1xyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodG9rZW4gPT09IFwibWF4XCIpXHJcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2UucHVzaChQcm90b0J1Zi5JRF9NQVgpO1xyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlLnB1c2godGhpcy5fcGFyc2VOdW1iZXIodG9rZW4pKTtcclxuICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy50bi5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4gIT09IExhbmcuRU5EKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCBleHRlbnNpb24gZGVsaW1pdGVyIGluIG1lc3NhZ2UgXCIrbXNnLm5hbWUrXCIgYXQgbGluZSBcIit0aGlzLnRuLmxpbmUrXCI6IFwiK3Rva2VuK1wiICgnXCIrTGFuZy5FTkQrXCInIGV4cGVjdGVkKVwiKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiByYW5nZTtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBQYXJzZXMgYW4gZXh0ZW5kIGJsb2NrLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyZW50IFBhcmVudCBvYmplY3RcclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHRva2VuIEluaXRpYWwgdG9rZW5cclxuICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBleHRlbmQgYmxvY2sgY2Fubm90IGJlIHBhcnNlZFxyXG4gICAgICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgUGFyc2VyLnByb3RvdHlwZS5fcGFyc2VFeHRlbmQgPSBmdW5jdGlvbihwYXJlbnQsIHRva2VuKSB7XHJcbiAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMudG4ubmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFMYW5nLlRZUEVSRUYudGVzdCh0b2tlbikpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIGV4dGVuZGVkIG1lc3NhZ2UgbmFtZSBhdCBsaW5lIFwiK3RoaXMudG4ubGluZStcIjogXCIrdG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgLyoqIEBkaWN0ICovXHJcbiAgICAgICAgICAgICAgICB2YXIgZXh0ID0ge307XHJcbiAgICAgICAgICAgICAgICBleHRbXCJyZWZcIl0gPSB0b2tlbjtcclxuICAgICAgICAgICAgICAgIGV4dFtcImZpZWxkc1wiXSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRuLm5leHQoKTtcclxuICAgICAgICAgICAgICAgIGlmICh0b2tlbiAhPT0gTGFuZy5PUEVOKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCBPUEVOIGluIGV4dGVuZCBcIitleHQubmFtZStcIiBhdCBsaW5lIFwiK3RoaXMudG4ubGluZStcIjogXCIrdG9rZW4rXCIgKCdcIitMYW5nLk9QRU4rXCInIGV4cGVjdGVkKVwiKTtcclxuICAgICAgICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMudG4ubmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbiA9PT0gTGFuZy5DTE9TRSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMudG4ucGVlaygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW4gPT0gTGFuZy5FTkQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRuLm5leHQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChMYW5nLlJVTEUudGVzdCh0b2tlbikpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhcnNlTWVzc2FnZUZpZWxkKGV4dCwgdG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIHRva2VuIGluIGV4dGVuZCBcIitleHQubmFtZStcIiBhdCBsaW5lIFwiK3RoaXMudG4ubGluZStcIjogXCIrdG9rZW4rXCIgKHJ1bGUgb3IgJ1wiK0xhbmcuQ0xPU0UrXCInIGV4cGVjdGVkKVwiKTtcclxuICAgICAgICAgICAgICAgIH0gd2hpbGUgKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgcGFyZW50W1wibWVzc2FnZXNcIl0ucHVzaChleHQpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4dDtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgb2JqZWN0LlxyXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBTdHJpbmcgcmVwcmVzZW50YXRpb24gYXMgb2YgXCJQYXJzZXJcIlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgUGFyc2VyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiUGFyc2VyXCI7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQGFsaWFzIFByb3RvQnVmLkRvdFByb3RvLlBhcnNlclxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBEb3RQcm90by5QYXJzZXIgPSBQYXJzZXI7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gRG90UHJvdG87XHJcblxyXG4gICAgICAgIH0pKFByb3RvQnVmLCBQcm90b0J1Zi5MYW5nKTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQGFsaWFzIFByb3RvQnVmLlJlZmxlY3RcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUHJvdG9CdWYuUmVmbGVjdCA9IChmdW5jdGlvbihQcm90b0J1Zikge1xyXG4gICAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBSZWZsZWN0aW9uIHR5cGVzLlxyXG4gICAgICAgICAgICAgKiBAZXhwb3J0cyBQcm90b0J1Zi5SZWZsZWN0XHJcbiAgICAgICAgICAgICAqIEBuYW1lc3BhY2VcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHZhciBSZWZsZWN0ID0ge307XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQ29uc3RydWN0cyBhIFJlZmxlY3QgYmFzZSBjbGFzcy5cclxuICAgICAgICAgICAgICogQGV4cG9ydHMgUHJvdG9CdWYuUmVmbGVjdC5UXHJcbiAgICAgICAgICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICAgICAgICAgKiBAYWJzdHJhY3RcclxuICAgICAgICAgICAgICogQHBhcmFtIHtQcm90b0J1Zi5SZWZsZWN0LlR9IHBhcmVudCBQYXJlbnQgb2JqZWN0XHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE9iamVjdCBuYW1lXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB2YXIgVCA9IGZ1bmN0aW9uKHBhcmVudCwgbmFtZSkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogUGFyZW50IG9iamVjdC5cclxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtQcm90b0J1Zi5SZWZsZWN0LlR8bnVsbH1cclxuICAgICAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBPYmplY3QgbmFtZSBpbiBuYW1lc3BhY2UuXHJcbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAgICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogRnVsbHkgcXVhbGlmaWVkIGNsYXNzIG5hbWVcclxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICAgICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuY2xhc3NOYW1lO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFJldHVybnMgdGhlIGZ1bGx5IHF1YWxpZmllZCBuYW1lIG9mIHRoaXMgb2JqZWN0LlxyXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBGdWxseSBxdWFsaWZpZWQgbmFtZSBhcyBvZiBcIi5QQVRILlRPLlRISVNcIlxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBULnByb3RvdHlwZS5mcW4gPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHZhciBuYW1lID0gdGhpcy5uYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgIHB0ciA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHRyID0gcHRyLnBhcmVudDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocHRyID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPSBwdHIubmFtZStcIi5cIituYW1lO1xyXG4gICAgICAgICAgICAgICAgfSB3aGlsZSAodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmFtZTtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgUmVmbGVjdCBvYmplY3QgKGl0cyBmdWxseSBxdWFsaWZpZWQgbmFtZSkuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IGluY2x1ZGVDbGFzcyBTZXQgdG8gdHJ1ZSB0byBpbmNsdWRlIHRoZSBjbGFzcyBuYW1lLiBEZWZhdWx0cyB0byBmYWxzZS5cclxuICAgICAgICAgICAgICogQHJldHVybiBTdHJpbmcgcmVwcmVzZW50YXRpb25cclxuICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgVC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbihpbmNsdWRlQ2xhc3MpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAoaW5jbHVkZUNsYXNzID8gdGhpcy5jbGFzc05hbWUgKyBcIiBcIiA6IFwiXCIpICsgdGhpcy5mcW4oKTtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBCdWlsZHMgdGhpcyB0eXBlLlxyXG4gICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhpcyB0eXBlIGNhbm5vdCBiZSBidWlsdCBkaXJlY3RseVxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBULnByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IodGhpcy50b1N0cmluZyh0cnVlKStcIiBjYW5ub3QgYmUgYnVpbHQgZGlyZWN0bHlcIik7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQGFsaWFzIFByb3RvQnVmLlJlZmxlY3QuVFxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBSZWZsZWN0LlQgPSBUO1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgTmFtZXNwYWNlLlxyXG4gICAgICAgICAgICAgKiBAZXhwb3J0cyBQcm90b0J1Zi5SZWZsZWN0Lk5hbWVzcGFjZVxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge1Byb3RvQnVmLlJlZmxlY3QuTmFtZXNwYWNlfG51bGx9IHBhcmVudCBOYW1lc3BhY2UgcGFyZW50XHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE5hbWVzcGFjZSBuYW1lXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG9wdGlvbnMgTmFtZXNwYWNlIG9wdGlvbnNcclxuICAgICAgICAgICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgICAgICAgICAqIEBleHRlbmRzIFByb3RvQnVmLlJlZmxlY3QuVFxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdmFyIE5hbWVzcGFjZSA9IGZ1bmN0aW9uKHBhcmVudCwgbmFtZSwgb3B0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgVC5jYWxsKHRoaXMsIHBhcmVudCwgbmFtZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBAb3ZlcnJpZGVcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jbGFzc05hbWUgPSBcIk5hbWVzcGFjZVwiO1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQ2hpbGRyZW4gaW5zaWRlIHRoZSBuYW1lc3BhY2UuXHJcbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPFByb3RvQnVmLlJlZmxlY3QuVD59XHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIE9wdGlvbnMuXHJcbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsICo+fVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLy8gRXh0ZW5kcyBUXHJcbiAgICAgICAgICAgIE5hbWVzcGFjZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFQucHJvdG90eXBlKTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIHRoZSBuYW1lc3BhY2UncyBjaGlsZHJlbi5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtQcm90b0J1Zi5SZWZsZWN0LlQ9fSB0eXBlIEZpbHRlciB0eXBlIChyZXR1cm5zIGluc3RhbmNlcyBvZiB0aGlzIHR5cGUgb25seSkuIERlZmF1bHRzIHRvIG51bGwgKGFsbCBjaGlsZHJlbikuXHJcbiAgICAgICAgICAgICAqIEByZXR1cm4ge0FycmF5LjxQcm90b0J1Zi5SZWZsZWN0LlQ+fVxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBOYW1lc3BhY2UucHJvdG90eXBlLmdldENoaWxkcmVuID0gZnVuY3Rpb24odHlwZSkge1xyXG4gICAgICAgICAgICAgICAgdHlwZSA9IHR5cGUgfHwgbnVsbDtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW4uc2xpY2UoKTtcclxuICAgICAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IFtdO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaT0wLCBrPXRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpPGs7ICsraSlcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jaGlsZHJlbltpXSBpbnN0YW5jZW9mIHR5cGUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGFsc28gbmVlZCB0byBkaXN0aW5ndWlzaCBiZXR3ZWVuIEZpZWxkIGFuZCBFeHRlbnNpb25GaWVsZCB3aGljaCBpcyBhbiBpbnN0YW5jZSBvZiBGaWVsZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSAhPT0gTWVzc2FnZS5GaWVsZCB8fCAhKHRoaXMuY2hpbGRyZW5baV0gaW5zdGFuY2VvZiBNZXNzYWdlLkV4dGVuc2lvbkZpZWxkKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2godGhpcy5jaGlsZHJlbltpXSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGRyZW47XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQWRkcyBhIGNoaWxkIHRvIHRoZSBuYW1lc3BhY2UuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7UHJvdG9CdWYuUmVmbGVjdC5UfSBjaGlsZCBDaGlsZFxyXG4gICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGNoaWxkIGNhbm5vdCBiZSBhZGRlZCAoZHVwbGljYXRlKVxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBOYW1lc3BhY2UucHJvdG90eXBlLmFkZENoaWxkID0gZnVuY3Rpb24oY2hpbGQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBvdGhlcjtcclxuICAgICAgICAgICAgICAgIGlmIChvdGhlciA9IHRoaXMuZ2V0Q2hpbGQoY2hpbGQubmFtZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBUcnkgdG8gcmV2ZXJ0IGNhbWVsY2FzZSB0cmFuc2Zvcm1hdGlvbiBvbiBjb2xsaXNpb25cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3RoZXIgaW5zdGFuY2VvZiBNZXNzYWdlLkZpZWxkICYmIG90aGVyLm5hbWUgIT09IG90aGVyLm9yaWdpbmFsTmFtZSAmJiAhdGhpcy5oYXNDaGlsZChvdGhlci5vcmlnaW5hbE5hbWUpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvdGhlci5uYW1lID0gb3RoZXIub3JpZ2luYWxOYW1lOyAvLyBSZXZlcnQgcHJldmlvdXMgZmlyc3QgKGVmZmVjdGl2ZWx5IGtlZXBzIGJvdGggb3JpZ2luYWxzKVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNoaWxkIGluc3RhbmNlb2YgTWVzc2FnZS5GaWVsZCAmJiBjaGlsZC5uYW1lICE9PSBjaGlsZC5vcmlnaW5hbE5hbWUgJiYgIXRoaXMuaGFzQ2hpbGQoY2hpbGQub3JpZ2luYWxOYW1lKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQubmFtZSA9IGNoaWxkLm9yaWdpbmFsTmFtZTtcclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiRHVwbGljYXRlIG5hbWUgaW4gbmFtZXNwYWNlIFwiK3RoaXMudG9TdHJpbmcodHJ1ZSkrXCI6IFwiK2NoaWxkLm5hbWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUZXN0cyBpZiB0aGlzIG5hbWVzcGFjZSBoYXMgYSBjaGlsZCB3aXRoIHRoZSBzcGVjaWZpZWQgbmFtZS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBuYW1lT3JJZCBDaGlsZCBuYW1lIG9yIGlkXHJcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoZXJlIGlzIG9uZSwgZWxzZSBmYWxzZVxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBOYW1lc3BhY2UucHJvdG90eXBlLmhhc0NoaWxkID0gZnVuY3Rpb24obmFtZU9ySWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbmRleE9mKG5hbWVPcklkKSA+IC0xO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdldHMgYSBjaGlsZCBieSBpdHMgbmFtZS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBuYW1lT3JJZCBDaGlsZCBuYW1lIG9yIGlkXHJcbiAgICAgICAgICAgICAqIEByZXR1cm4gez9Qcm90b0J1Zi5SZWZsZWN0LlR9IFRoZSBjaGlsZCBvciBudWxsIGlmIG5vdCBmb3VuZFxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBOYW1lc3BhY2UucHJvdG90eXBlLmdldENoaWxkID0gZnVuY3Rpb24obmFtZU9ySWQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMuX2luZGV4T2YobmFtZU9ySWQpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4ID4gLTEgPyB0aGlzLmNoaWxkcmVuW2luZGV4XSA6IG51bGw7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUmV0dXJucyBjaGlsZCBpbmRleCBieSBpdHMgbmFtZSBvciBpZC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBuYW1lT3JJZCBDaGlsZCBuYW1lIG9yIGlkXHJcbiAgICAgICAgICAgICAqIEByZXR1cm4ge051bWJlcn0gVGhlIGNoaWxkIGluZGV4XHJcbiAgICAgICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBOYW1lc3BhY2UucHJvdG90eXBlLl9pbmRleE9mID0gZnVuY3Rpb24obmFtZU9ySWQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBrZXkgPSB0eXBlb2YgbmFtZU9ySWQgPT09ICdudW1iZXInID8gJ2lkJyA6ICduYW1lJztcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGk9MDsgaTx0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5jaGlsZHJlbltpXVtrZXldICE9PSAndW5kZWZpbmVkJyAmJiB0aGlzLmNoaWxkcmVuW2ldW2tleV0gPT0gbmFtZU9ySWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFJlc29sdmVzIGEgcmVmbGVjdCBvYmplY3QgaW5zaWRlIG9mIHRoaXMgbmFtZXNwYWNlLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcW4gUXVhbGlmaWVkIG5hbWUgdG8gcmVzb2x2ZVxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBleGNsdWRlRmllbGRzIEV4Y2x1ZGVzIGZpZWxkcywgZGVmYXVsdHMgdG8gYGZhbHNlYFxyXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHtQcm90b0J1Zi5SZWZsZWN0Lk5hbWVzcGFjZXxudWxsfSBUaGUgcmVzb2x2ZWQgdHlwZSBvciBudWxsIGlmIG5vdCBmb3VuZFxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBOYW1lc3BhY2UucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbihxbiwgZXhjbHVkZUZpZWxkcykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBhcnQgPSBxbi5zcGxpdChcIi5cIik7XHJcbiAgICAgICAgICAgICAgICB2YXIgcHRyID0gdGhpcywgaT0wO1xyXG4gICAgICAgICAgICAgICAgaWYgKHBhcnRbaV0gPT0gXCJcIikgeyAvLyBGdWxseSBxdWFsaWZpZWQgbmFtZSwgZS5nLiBcIi5NeS5NZXNzYWdlJ1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChwdHIucGFyZW50ICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHB0ciA9IHB0ci5wYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkO1xyXG4gICAgICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQgPSBwdHIuZ2V0Q2hpbGQocGFydFtpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY2hpbGQgfHwgIShjaGlsZCBpbnN0YW5jZW9mIFJlZmxlY3QuVCkgfHwgKGV4Y2x1ZGVGaWVsZHMgJiYgY2hpbGQgaW5zdGFuY2VvZiBSZWZsZWN0Lk1lc3NhZ2UuRmllbGQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdHIgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcHRyID0gY2hpbGQ7IGkrKztcclxuICAgICAgICAgICAgICAgICAgICB9IHdoaWxlIChpIDwgcGFydC5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwdHIgIT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7IC8vIEZvdW5kXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRWxzZSBzZWFyY2ggdGhlIHBhcmVudFxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnBhcmVudCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQucmVzb2x2ZShxbiwgZXhjbHVkZUZpZWxkcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSB3aGlsZSAocHRyICE9IG51bGwpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHB0cjtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBCdWlsZHMgdGhlIG5hbWVzcGFjZSBhbmQgcmV0dXJucyB0aGUgcnVudGltZSBjb3VudGVycGFydC5cclxuICAgICAgICAgICAgICogQHJldHVybiB7T2JqZWN0LjxzdHJpbmcsRnVuY3Rpb258T2JqZWN0Pn0gUnVudGltZSBuYW1lc3BhY2VcclxuICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgTmFtZXNwYWNlLnByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgLyoqIEBkaWN0ICovXHJcbiAgICAgICAgICAgICAgICB2YXIgbnMgPSB7fTtcclxuICAgICAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuZ2V0Q2hpbGRyZW4oKSwgY2hpbGQ7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpPTAsIGs9Y2hpbGRyZW4ubGVuZ3RoOyBpPGs7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkID0gY2hpbGRyZW5baV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgTmFtZXNwYWNlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuc1tjaGlsZC5uYW1lXSA9IGNoaWxkLmJ1aWxkKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KVxyXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgXCIkb3B0aW9uc1wiLCB7IFwidmFsdWVcIjogdGhpcy5idWlsZE9wdCgpIH0pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5zO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEJ1aWxkcyB0aGUgbmFtZXNwYWNlJ3MgJyRvcHRpb25zJyBwcm9wZXJ0eS5cclxuICAgICAgICAgICAgICogQHJldHVybiB7T2JqZWN0LjxzdHJpbmcsKj59XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBOYW1lc3BhY2UucHJvdG90eXBlLmJ1aWxkT3B0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgb3B0ID0ge307XHJcbiAgICAgICAgICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHRoaXMub3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8a2V5cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSB0aGlzLm9wdGlvbnNba2V5c1tpXV07XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogT3B0aW9ucyBhcmUgbm90IHJlc29sdmVkLCB5ZXQuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgKHZhbCBpbnN0YW5jZW9mIE5hbWVzcGFjZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICBvcHRba2V5XSA9IHZhbC5idWlsZCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3B0W2tleV0gPSB2YWw7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9wdDtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBHZXRzIHRoZSB2YWx1ZSBhc3NpZ25lZCB0byB0aGUgb3B0aW9uIHdpdGggdGhlIHNwZWNpZmllZCBuYW1lLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZz19IG5hbWUgUmV0dXJucyB0aGUgb3B0aW9uIHZhbHVlIGlmIHNwZWNpZmllZCwgb3RoZXJ3aXNlIGFsbCBvcHRpb25zIGFyZSByZXR1cm5lZC5cclxuICAgICAgICAgICAgICogQHJldHVybiB7KnxPYmplY3QuPHN0cmluZywqPn1udWxsfSBPcHRpb24gdmFsdWUgb3IgTlVMTCBpZiB0aGVyZSBpcyBubyBzdWNoIG9wdGlvblxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgTmFtZXNwYWNlLnByb3RvdHlwZS5nZXRPcHRpb24gPSBmdW5jdGlvbihuYW1lKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG5hbWUgPT09ICd1bmRlZmluZWQnKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnM7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIHRoaXMub3B0aW9uc1tuYW1lXSAhPT0gJ3VuZGVmaW5lZCcgPyB0aGlzLm9wdGlvbnNbbmFtZV0gOiBudWxsO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEBhbGlhcyBQcm90b0J1Zi5SZWZsZWN0Lk5hbWVzcGFjZVxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBSZWZsZWN0Lk5hbWVzcGFjZSA9IE5hbWVzcGFjZTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IE1lc3NhZ2UuXHJcbiAgICAgICAgICAgICAqIEBleHBvcnRzIFByb3RvQnVmLlJlZmxlY3QuTWVzc2FnZVxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge1Byb3RvQnVmLlJlZmxlY3QuTmFtZXNwYWNlfSBwYXJlbnQgUGFyZW50IG1lc3NhZ2Ugb3IgbmFtZXNwYWNlXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE1lc3NhZ2UgbmFtZVxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBvcHRpb25zIE1lc3NhZ2Ugb3B0aW9uc1xyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBpc0dyb3VwIGB0cnVlYCBpZiB0aGlzIGlzIGEgbGVnYWN5IGdyb3VwXHJcbiAgICAgICAgICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICAgICAgICAgKiBAZXh0ZW5kcyBQcm90b0J1Zi5SZWZsZWN0Lk5hbWVzcGFjZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdmFyIE1lc3NhZ2UgPSBmdW5jdGlvbihwYXJlbnQsIG5hbWUsIG9wdGlvbnMsIGlzR3JvdXApIHtcclxuICAgICAgICAgICAgICAgIE5hbWVzcGFjZS5jYWxsKHRoaXMsIHBhcmVudCwgbmFtZSwgb3B0aW9ucyk7XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBAb3ZlcnJpZGVcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jbGFzc05hbWUgPSBcIk1lc3NhZ2VcIjtcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEV4dGVuc2lvbnMgcmFuZ2UuXHJcbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7IUFycmF5LjxudW1iZXI+fVxyXG4gICAgICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLmV4dGVuc2lvbnMgPSBbUHJvdG9CdWYuSURfTUlOLCBQcm90b0J1Zi5JRF9NQVhdO1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogUnVudGltZSBtZXNzYWdlIGNsYXNzLlxyXG4gICAgICAgICAgICAgICAgICogQHR5cGUgez9mdW5jdGlvbihuZXc6UHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlKX1cclxuICAgICAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jbGF6eiA9IG51bGw7XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBXaGV0aGVyIHRoaXMgaXMgYSBsZWdhY3kgZ3JvdXAgb3Igbm90LlxyXG4gICAgICAgICAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuaXNHcm91cCA9ICEhaXNHcm91cDtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8vIEV4dGVuZHMgTmFtZXNwYWNlXHJcbiAgICAgICAgICAgIE1lc3NhZ2UucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShOYW1lc3BhY2UucHJvdG90eXBlKTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBCdWlsZHMgdGhlIG1lc3NhZ2UgYW5kIHJldHVybnMgdGhlIHJ1bnRpbWUgY291bnRlcnBhcnQsIHdoaWNoIGlzIGEgZnVsbHkgZnVuY3Rpb25hbCBjbGFzcy5cclxuICAgICAgICAgICAgICogQHNlZSBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2VcclxuICAgICAgICAgICAgICogQHBhcmFtIHtib29sZWFuPX0gcmVidWlsZCBXaGV0aGVyIHRvIHJlYnVpbGQgb3Igbm90LCBkZWZhdWx0cyB0byBmYWxzZVxyXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHtQcm90b0J1Zi5SZWZsZWN0Lk1lc3NhZ2V9IE1lc3NhZ2UgY2xhc3NcclxuICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBtZXNzYWdlIGNhbm5vdCBiZSBidWlsdFxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBNZXNzYWdlLnByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uKHJlYnVpbGQpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNsYXp6ICYmICFyZWJ1aWxkKSByZXR1cm4gdGhpcy5jbGF6ejtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBXZSBuZWVkIHRvIGNyZWF0ZSBhIHByb3RvdHlwZWQgTWVzc2FnZSBjbGFzcyBpbiBhbiBpc29sYXRlZCBzY29wZVxyXG4gICAgICAgICAgICAgICAgdmFyIGNsYXp6ID0gKGZ1bmN0aW9uKFByb3RvQnVmLCBUKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBmaWVsZHMgPSBULmdldENoaWxkcmVuKFByb3RvQnVmLlJlZmxlY3QuTWVzc2FnZS5GaWVsZCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgcnVudGltZSBNZXNzYWdlLlxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBuYW1lIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZVxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBjbGFzcyBCYXJlYm9uZSBvZiBhbGwgcnVudGltZSBtZXNzYWdlcy5cclxuICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fC4uLltzdHJpbmddfSB2YWx1ZXMgUHJlc2V0IHZhbHVlc1xyXG4gICAgICAgICAgICAgICAgICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICAgICAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgbWVzc2FnZSBjYW5ub3QgYmUgY3JlYXRlZFxyXG4gICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBNZXNzYWdlID0gZnVuY3Rpb24odmFsdWVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZS5jYWxsKHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaSwgZmllbGQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDcmVhdGUgZmllbGRzIG9uIHRoZSBvYmplY3QgaXRzZWxmIHRvIGFsbG93IHNldHRpbmcgYW5kIGdldHRpbmcgdGhyb3VnaCBNZXNzYWdlI2ZpZWxkbmFtZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGk9MDsgaTxmaWVsZHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkID0gZmllbGRzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1tmaWVsZC5uYW1lXSA9IChmaWVsZC5yZXBlYXRlZCkgPyBbXSA6IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2V0IHRoZSBkZWZhdWx0IHZhbHVlc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGk9MDsgaTxmaWVsZHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkID0gZmllbGRzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmaWVsZC5vcHRpb25zWydkZWZhdWx0J10gIT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRzZXQoZmllbGQubmFtZSwgZmllbGQub3B0aW9uc1snZGVmYXVsdCddKTsgLy8gU2hvdWxkIG5vdCB0aHJvd1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJbSU5URVJOQUxdIFwiK2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTZXQgZmllbGQgdmFsdWVzIGZyb20gYSB2YWx1ZXMgb2JqZWN0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDEgJiYgdHlwZW9mIHZhbHVlcyA9PSAnb2JqZWN0JyAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogbm90IGFub3RoZXIgTWVzc2FnZSAqLyB0eXBlb2YgdmFsdWVzLmVuY29kZSAhPSAnZnVuY3Rpb24nICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBub3QgYSByZXBlYXRlZCBmaWVsZCAqLyAhUHJvdG9CdWYuVXRpbC5pc0FycmF5KHZhbHVlcykgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIG5vdCBhIEJ5dGVCdWZmZXIgKi8gISh2YWx1ZXMgaW5zdGFuY2VvZiBCeXRlQnVmZmVyKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogbm90IGFuIEFycmF5QnVmZmVyICovICEodmFsdWVzIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBub3QgYSBMb25nICovICEoUHJvdG9CdWYuTG9uZyAmJiB2YWx1ZXMgaW5zdGFuY2VvZiBQcm90b0J1Zi5Mb25nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpPTA7IGk8a2V5cy5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRzZXQoa2V5c1tpXSwgdmFsdWVzW2tleXNbaV1dKTsgLy8gTWF5IHRocm93XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFbHNlIHNldCBmaWVsZCB2YWx1ZXMgZnJvbSBhcmd1bWVudHMsIGluIGNvcnJlY3Qgb3JkZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGk9MDsgaTxhcmd1bWVudHMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGk8ZmllbGRzLmxlbmd0aClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kc2V0KGZpZWxkc1tpXS5uYW1lLCBhcmd1bWVudHNbaV0pOyAvLyBNYXkgdGhyb3dcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBFeHRlbmRzIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZVxyXG4gICAgICAgICAgICAgICAgICAgIE1lc3NhZ2UucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UucHJvdG90eXBlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICogQWRkcyBhIHZhbHVlIHRvIGEgcmVwZWF0ZWQgZmllbGQuXHJcbiAgICAgICAgICAgICAgICAgICAgICogQG5hbWUgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlI2FkZFxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgRmllbGQgbmFtZVxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgdG8gYWRkXHJcbiAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtib29sZWFuPX0gbm9Bc3NlcnQgV2hldGhlciB0byBhc3NlcnQgdGhlIHZhbHVlIG9yIG5vdCAoYXNzZXJ0cyBieSBkZWZhdWx0KVxyXG4gICAgICAgICAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgdmFsdWUgY2Fubm90IGJlIGFkZGVkXHJcbiAgICAgICAgICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgIE1lc3NhZ2UucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKGtleSwgdmFsdWUsIG5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmaWVsZCA9IFQuZ2V0Q2hpbGQoa2V5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFmaWVsZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKHRoaXMrXCIjXCIra2V5K1wiIGlzIHVuZGVmaW5lZFwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoZmllbGQgaW5zdGFuY2VvZiBQcm90b0J1Zi5SZWZsZWN0Lk1lc3NhZ2UuRmllbGQpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IodGhpcytcIiNcIitrZXkrXCIgaXMgbm90IGEgZmllbGQ6IFwiK2ZpZWxkLnRvU3RyaW5nKHRydWUpKTsgLy8gTWF5IHRocm93IGlmIGl0J3MgYW4gZW51bSBvciBlbWJlZGRlZCBtZXNzYWdlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZmllbGQucmVwZWF0ZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcih0aGlzK1wiI1wiK2tleStcIiBpcyBub3QgYSByZXBlYXRlZCBmaWVsZFwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXNbZmllbGQubmFtZV0gPT09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2ZpZWxkLm5hbWVdID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbZmllbGQubmFtZV0ucHVzaChub0Fzc2VydCA/IHZhbHVlIDogZmllbGQudmVyaWZ5VmFsdWUodmFsdWUsIHRydWUpKTtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAgICAgKiBBZGRzIGEgdmFsdWUgdG8gYSByZXBlYXRlZCBmaWVsZC4gVGhpcyBpcyBhbiBhbGlhcyBmb3Ige0BsaW5rIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZSNhZGR9LlxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBuYW1lIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZSMkYWRkXHJcbiAgICAgICAgICAgICAgICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBGaWVsZCBuYW1lXHJcbiAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byBhZGRcclxuICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBub0Fzc2VydCBXaGV0aGVyIHRvIGFzc2VydCB0aGUgdmFsdWUgb3Igbm90IChhc3NlcnRzIGJ5IGRlZmF1bHQpXHJcbiAgICAgICAgICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSB2YWx1ZSBjYW5ub3QgYmUgYWRkZWRcclxuICAgICAgICAgICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgTWVzc2FnZS5wcm90b3R5cGUuJGFkZCA9IE1lc3NhZ2UucHJvdG90eXBlLmFkZDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICogU2V0cyBhIGZpZWxkJ3MgdmFsdWUuXHJcbiAgICAgICAgICAgICAgICAgICAgICogQG5hbWUgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlI3NldFxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgS2V5XHJcbiAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byBzZXRcclxuICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBub0Fzc2VydCBXaGV0aGVyIHRvIGFzc2VydCB0aGUgdmFsdWUgb3Igbm90IChhc3NlcnRzIGJ5IGRlZmF1bHQpXHJcbiAgICAgICAgICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSB2YWx1ZSBjYW5ub3QgYmUgc2V0XHJcbiAgICAgICAgICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgIE1lc3NhZ2UucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKGtleSwgdmFsdWUsIG5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmaWVsZCA9IFQuZ2V0Q2hpbGQoa2V5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFmaWVsZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKHRoaXMrXCIjXCIra2V5K1wiIGlzIG5vdCBhIGZpZWxkOiB1bmRlZmluZWRcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGZpZWxkIGluc3RhbmNlb2YgUHJvdG9CdWYuUmVmbGVjdC5NZXNzYWdlLkZpZWxkKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKHRoaXMrXCIjXCIra2V5K1wiIGlzIG5vdCBhIGZpZWxkOiBcIitmaWVsZC50b1N0cmluZyh0cnVlKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbZmllbGQubmFtZV0gPSBub0Fzc2VydCA/IHZhbHVlIDogZmllbGQudmVyaWZ5VmFsdWUodmFsdWUpOyAvLyBNYXkgdGhyb3dcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAgICAgKiBTZXRzIGEgZmllbGQncyB2YWx1ZS4gVGhpcyBpcyBhbiBhbGlhcyBmb3IgW0BsaW5rIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZSNzZXR9LlxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBuYW1lIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZSMkc2V0XHJcbiAgICAgICAgICAgICAgICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBLZXlcclxuICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIHNldFxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IG5vQXNzZXJ0IFdoZXRoZXIgdG8gYXNzZXJ0IHRoZSB2YWx1ZSBvciBub3QgKGFzc2VydHMgYnkgZGVmYXVsdClcclxuICAgICAgICAgICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHZhbHVlIGNhbm5vdCBiZSBzZXRcclxuICAgICAgICAgICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgTWVzc2FnZS5wcm90b3R5cGUuJHNldCA9IE1lc3NhZ2UucHJvdG90eXBlLnNldDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICogR2V0cyBhIGZpZWxkJ3MgdmFsdWUuXHJcbiAgICAgICAgICAgICAgICAgICAgICogQG5hbWUgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlI2dldFxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgS2V5XHJcbiAgICAgICAgICAgICAgICAgICAgICogQHJldHVybiB7Kn0gVmFsdWVcclxuICAgICAgICAgICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlcmUgaXMgbm8gc3VjaCBmaWVsZFxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICBNZXNzYWdlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihrZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZpZWxkID0gVC5nZXRDaGlsZChrZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWZpZWxkIHx8ICEoZmllbGQgaW5zdGFuY2VvZiBQcm90b0J1Zi5SZWZsZWN0Lk1lc3NhZ2UuRmllbGQpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IodGhpcytcIiNcIitrZXkrXCIgaXMgbm90IGEgZmllbGQ6IHVuZGVmaW5lZFwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoZmllbGQgaW5zdGFuY2VvZiBQcm90b0J1Zi5SZWZsZWN0Lk1lc3NhZ2UuRmllbGQpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IodGhpcytcIiNcIitrZXkrXCIgaXMgbm90IGEgZmllbGQ6IFwiK2ZpZWxkLnRvU3RyaW5nKHRydWUpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbZmllbGQubmFtZV07XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICogR2V0cyBhIGZpZWxkJ3MgdmFsdWUuIFRoaXMgaXMgYW4gYWxpYXMgZm9yIHtAbGluayBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UjJGdldH0uXHJcbiAgICAgICAgICAgICAgICAgICAgICogQG5hbWUgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlIyRnZXRcclxuICAgICAgICAgICAgICAgICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IEtleVxyXG4gICAgICAgICAgICAgICAgICAgICAqIEByZXR1cm4geyp9IFZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZXJlIGlzIG5vIHN1Y2ggZmllbGRcclxuICAgICAgICAgICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgTWVzc2FnZS5wcm90b3R5cGUuJGdldCA9IE1lc3NhZ2UucHJvdG90eXBlLmdldDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gR2V0dGVycyBhbmQgc2V0dGVyc1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8ZmllbGRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmaWVsZCA9IGZpZWxkc1tpXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChmdW5jdGlvbihmaWVsZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2V0L2dldFtTb21lVmFsdWVdXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgTmFtZSA9IGZpZWxkLm9yaWdpbmFsTmFtZS5yZXBsYWNlKC8oX1thLXpBLVpdKS9nLCBmdW5jdGlvbihtYXRjaCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaC50b1VwcGVyQ2FzZSgpLnJlcGxhY2UoJ18nLCcnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTmFtZSA9IE5hbWUuc3Vic3RyaW5nKDAsMSkudG9VcHBlckNhc2UoKStOYW1lLnN1YnN0cmluZygxKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzZXQvZ2V0X1tzb21lX3ZhbHVlXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBmaWVsZC5vcmlnaW5hbE5hbWUucmVwbGFjZSgvKFtBLVpdKS9nLCBmdW5jdGlvbihtYXRjaCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIl9cIittYXRjaDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogU2V0cyBhIHZhbHVlLiBUaGlzIG1ldGhvZCBpcyBwcmVzZW50IGZvciBlYWNoIGZpZWxkLCBidXQgb25seSBpZiB0aGVyZSBpcyBubyBuYW1lIGNvbmZsaWN0IHdpdGhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIGFub3RoZXIgZmllbGQuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbmFtZSBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2Ujc2V0W1NvbWVGaWVsZF1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byBzZXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSB2YWx1ZSBjYW5ub3QgYmUgc2V0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghVC5oYXNDaGlsZChcInNldFwiK05hbWUpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1lc3NhZ2UucHJvdG90eXBlW1wic2V0XCIrTmFtZV0gPSBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRzZXQoZmllbGQubmFtZSwgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBTZXRzIGEgdmFsdWUuIFRoaXMgbWV0aG9kIGlzIHByZXNlbnQgZm9yIGVhY2ggZmllbGQsIGJ1dCBvbmx5IGlmIHRoZXJlIGlzIG5vIG5hbWUgY29uZmxpY3Qgd2l0aFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogYW5vdGhlciBmaWVsZC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBuYW1lIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZSNzZXRfW3NvbWVfZmllbGRdXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgdG8gc2V0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAYWJzdHJhY3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgdmFsdWUgY2Fubm90IGJlIHNldFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIVQuaGFzQ2hpbGQoXCJzZXRfXCIrbmFtZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWVzc2FnZS5wcm90b3R5cGVbXCJzZXRfXCIrbmFtZV0gPSBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRzZXQoZmllbGQubmFtZSwgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBHZXRzIGEgdmFsdWUuIFRoaXMgbWV0aG9kIGlzIHByZXNlbnQgZm9yIGVhY2ggZmllbGQsIGJ1dCBvbmx5IGlmIHRoZXJlIGlzIG5vIG5hbWUgY29uZmxpY3Qgd2l0aFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogYW5vdGhlciBmaWVsZC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBuYW1lIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZSNnZXRbU29tZUZpZWxkXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAYWJzdHJhY3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEByZXR1cm4geyp9IFRoZSB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIVQuaGFzQ2hpbGQoXCJnZXRcIitOYW1lKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNZXNzYWdlLnByb3RvdHlwZVtcImdldFwiK05hbWVdID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRnZXQoZmllbGQubmFtZSk7IC8vIERvZXMgbm90IHRocm93LCBmaWVsZCBleGlzdHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBHZXRzIGEgdmFsdWUuIFRoaXMgbWV0aG9kIGlzIHByZXNlbnQgZm9yIGVhY2ggZmllbGQsIGJ1dCBvbmx5IGlmIHRoZXJlIGlzIG5vIG5hbWUgY29uZmxpY3Qgd2l0aFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogYW5vdGhlciBmaWVsZC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBuYW1lIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZSNnZXRfW3NvbWVfZmllbGRdXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEByZXR1cm4geyp9IFRoZSB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGFic3RyYWN0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghVC5oYXNDaGlsZChcImdldF9cIituYW1lKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNZXNzYWdlLnByb3RvdHlwZVtcImdldF9cIituYW1lXSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kZ2V0KGZpZWxkLm5hbWUpOyAvLyBEb2VzIG5vdCB0aHJvdywgZmllbGQgZXhpc3RzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKGZpZWxkKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEVuLS9kZWNvZGluZ1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAgICAgKiBFbmNvZGVzIHRoZSBtZXNzYWdlLlxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBuYW1lIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZSMkZW5jb2RlXHJcbiAgICAgICAgICAgICAgICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHsoIUJ5dGVCdWZmZXJ8Ym9vbGVhbik9fSBidWZmZXIgQnl0ZUJ1ZmZlciB0byBlbmNvZGUgdG8uIFdpbGwgY3JlYXRlIGEgbmV3IG9uZSBhbmQgZmxpcCBpdCBpZiBvbWl0dGVkLlxyXG4gICAgICAgICAgICAgICAgICAgICAqIEByZXR1cm4geyFCeXRlQnVmZmVyfSBFbmNvZGVkIG1lc3NhZ2UgYXMgYSBCeXRlQnVmZmVyXHJcbiAgICAgICAgICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBtZXNzYWdlIGNhbm5vdCBiZSBlbmNvZGVkIG9yIGlmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZy4gVGhlIGxhdGVyIHN0aWxsXHJcbiAgICAgICAgICAgICAgICAgICAgICogIHJldHVybnMgdGhlIGVuY29kZWQgQnl0ZUJ1ZmZlciBpbiB0aGUgYGVuY29kZWRgIHByb3BlcnR5IG9uIHRoZSBlcnJvci5cclxuICAgICAgICAgICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAgICAgICAgICogQHNlZSBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UjZW5jb2RlNjRcclxuICAgICAgICAgICAgICAgICAgICAgKiBAc2VlIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZSNlbmNvZGVIZXhcclxuICAgICAgICAgICAgICAgICAgICAgKiBAc2VlIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZSNlbmNvZGVBQlxyXG4gICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgIE1lc3NhZ2UucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXNOZXcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFidWZmZXIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIgPSBuZXcgQnl0ZUJ1ZmZlcigpLCBpc05ldyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsZSA9IGJ1ZmZlci5saXR0bGVFbmRpYW47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBULmVuY29kZSh0aGlzLCBidWZmZXIuTEUoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGlzTmV3ID8gYnVmZmVyLmZsaXAoKSA6IGJ1ZmZlcikuTEUobGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIuTEUobGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3coZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAgICAgKiBDYWxjdWxhdGVzIHRoZSBieXRlIGxlbmd0aCBvZiB0aGUgbWVzc2FnZS5cclxuICAgICAgICAgICAgICAgICAgICAgKiBAbmFtZSBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UjY2FsY3VsYXRlXHJcbiAgICAgICAgICAgICAgICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICogQHJldHVybnMge251bWJlcn0gQnl0ZSBsZW5ndGhcclxuICAgICAgICAgICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIG1lc3NhZ2UgY2Fubm90IGJlIGNhbGN1bGF0ZWQgb3IgaWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nLlxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICBNZXNzYWdlLnByb3RvdHlwZS5jYWxjdWxhdGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFQuY2FsY3VsYXRlKHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAqIEVuY29kZXMgdGhlIHZhcmludDMyIGxlbmd0aC1kZWxpbWl0ZWQgbWVzc2FnZS5cclxuICAgICAgICAgICAgICAgICAgICAgKiBAbmFtZSBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UjZW5jb2RlRGVsaW1pdGVkXHJcbiAgICAgICAgICAgICAgICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHsoIUJ5dGVCdWZmZXJ8Ym9vbGVhbik9fSBidWZmZXIgQnl0ZUJ1ZmZlciB0byBlbmNvZGUgdG8uIFdpbGwgY3JlYXRlIGEgbmV3IG9uZSBhbmQgZmxpcCBpdCBpZiBvbWl0dGVkLlxyXG4gICAgICAgICAgICAgICAgICAgICAqIEByZXR1cm4geyFCeXRlQnVmZmVyfSBFbmNvZGVkIG1lc3NhZ2UgYXMgYSBCeXRlQnVmZmVyXHJcbiAgICAgICAgICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBtZXNzYWdlIGNhbm5vdCBiZSBlbmNvZGVkIG9yIGlmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZy4gVGhlIGxhdGVyIHN0aWxsXHJcbiAgICAgICAgICAgICAgICAgICAgICogIHJldHVybnMgdGhlIGVuY29kZWQgQnl0ZUJ1ZmZlciBpbiB0aGUgYGVuY29kZWRgIHByb3BlcnR5IG9uIHRoZSBlcnJvci5cclxuICAgICAgICAgICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgTWVzc2FnZS5wcm90b3R5cGUuZW5jb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24oYnVmZmVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpc05ldyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWJ1ZmZlcilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlciA9IG5ldyBCeXRlQnVmZmVyKCksIGlzTmV3ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVuYyA9IG5ldyBCeXRlQnVmZmVyKCkuTEUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgVC5lbmNvZGUodGhpcywgZW5jKS5mbGlwKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci53cml0ZVZhcmludDMyKGVuYy5yZW1haW5pbmcoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci5hcHBlbmQoZW5jKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzTmV3ID8gYnVmZmVyLmZsaXAoKSA6IGJ1ZmZlcjtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAgICAgKiBEaXJlY3RseSBlbmNvZGVzIHRoZSBtZXNzYWdlIHRvIGFuIEFycmF5QnVmZmVyLlxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBuYW1lIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZSNlbmNvZGVBQlxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAqIEByZXR1cm4ge0FycmF5QnVmZmVyfSBFbmNvZGVkIG1lc3NhZ2UgYXMgQXJyYXlCdWZmZXJcclxuICAgICAgICAgICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIG1lc3NhZ2UgY2Fubm90IGJlIGVuY29kZWQgb3IgaWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nLiBUaGUgbGF0ZXIgc3RpbGxcclxuICAgICAgICAgICAgICAgICAgICAgKiAgcmV0dXJucyB0aGUgZW5jb2RlZCBBcnJheUJ1ZmZlciBpbiB0aGUgYGVuY29kZWRgIHByb3BlcnR5IG9uIHRoZSBlcnJvci5cclxuICAgICAgICAgICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgTWVzc2FnZS5wcm90b3R5cGUuZW5jb2RlQUIgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVuY29kZSgpLnRvQXJyYXlCdWZmZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVbXCJlbmNvZGVkXCJdKSBlW1wiZW5jb2RlZFwiXSA9IGVbXCJlbmNvZGVkXCJdLnRvQXJyYXlCdWZmZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93KGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICogUmV0dXJucyB0aGUgbWVzc2FnZSBhcyBhbiBBcnJheUJ1ZmZlci4gVGhpcyBpcyBhbiBhbGlhcyBmb3Ige0BsaW5rIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZSNlbmNvZGVBQn0uXHJcbiAgICAgICAgICAgICAgICAgICAgICogQG5hbWUgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlI3RvQXJyYXlCdWZmZXJcclxuICAgICAgICAgICAgICAgICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIHtBcnJheUJ1ZmZlcn0gRW5jb2RlZCBtZXNzYWdlIGFzIEFycmF5QnVmZmVyXHJcbiAgICAgICAgICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBtZXNzYWdlIGNhbm5vdCBiZSBlbmNvZGVkIG9yIGlmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZy4gVGhlIGxhdGVyIHN0aWxsXHJcbiAgICAgICAgICAgICAgICAgICAgICogIHJldHVybnMgdGhlIGVuY29kZWQgQXJyYXlCdWZmZXIgaW4gdGhlIGBlbmNvZGVkYCBwcm9wZXJ0eSBvbiB0aGUgZXJyb3IuXHJcbiAgICAgICAgICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgIE1lc3NhZ2UucHJvdG90eXBlLnRvQXJyYXlCdWZmZXIgPSBNZXNzYWdlLnByb3RvdHlwZS5lbmNvZGVBQjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICogRGlyZWN0bHkgZW5jb2RlcyB0aGUgbWVzc2FnZSB0byBhIG5vZGUgQnVmZmVyLlxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBuYW1lIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZSNlbmNvZGVOQlxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAqIEByZXR1cm4geyFCdWZmZXJ9XHJcbiAgICAgICAgICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBtZXNzYWdlIGNhbm5vdCBiZSBlbmNvZGVkLCBub3QgcnVubmluZyB1bmRlciBub2RlLmpzIG9yIGlmIHJlcXVpcmVkIGZpZWxkcyBhcmVcclxuICAgICAgICAgICAgICAgICAgICAgKiAgbWlzc2luZy4gVGhlIGxhdGVyIHN0aWxsIHJldHVybnMgdGhlIGVuY29kZWQgbm9kZSBCdWZmZXIgaW4gdGhlIGBlbmNvZGVkYCBwcm9wZXJ0eSBvbiB0aGUgZXJyb3IuXHJcbiAgICAgICAgICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgIE1lc3NhZ2UucHJvdG90eXBlLmVuY29kZU5CID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGUoKS50b0J1ZmZlcigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZVtcImVuY29kZWRcIl0pIGVbXCJlbmNvZGVkXCJdID0gZVtcImVuY29kZWRcIl0udG9CdWZmZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93KGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICogUmV0dXJucyB0aGUgbWVzc2FnZSBhcyBhIG5vZGUgQnVmZmVyLiBUaGlzIGlzIGFuIGFsaWFzIGZvciB7QGxpbmsgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlI2VuY29kZU5CfS5cclxuICAgICAgICAgICAgICAgICAgICAgKiBAbmFtZSBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UjdG9CdWZmZXJcclxuICAgICAgICAgICAgICAgICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIHshQnVmZmVyfVxyXG4gICAgICAgICAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgbWVzc2FnZSBjYW5ub3QgYmUgZW5jb2RlZCBvciBpZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmcuIFRoZSBsYXRlciBzdGlsbFxyXG4gICAgICAgICAgICAgICAgICAgICAqICByZXR1cm5zIHRoZSBlbmNvZGVkIG5vZGUgQnVmZmVyIGluIHRoZSBgZW5jb2RlZGAgcHJvcGVydHkgb24gdGhlIGVycm9yLlxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICBNZXNzYWdlLnByb3RvdHlwZS50b0J1ZmZlciA9IE1lc3NhZ2UucHJvdG90eXBlLmVuY29kZU5CO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAgICAgKiBEaXJlY3RseSBlbmNvZGVzIHRoZSBtZXNzYWdlIHRvIGEgYmFzZTY0IGVuY29kZWQgc3RyaW5nLlxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBuYW1lIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZSNlbmNvZGU2NFxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gQmFzZTY0IGVuY29kZWQgc3RyaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSB1bmRlcmx5aW5nIGJ1ZmZlciBjYW5ub3QgYmUgZW5jb2RlZCBvciBpZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmcuIFRoZSBsYXRlclxyXG4gICAgICAgICAgICAgICAgICAgICAqICBzdGlsbCByZXR1cm5zIHRoZSBlbmNvZGVkIGJhc2U2NCBzdHJpbmcgaW4gdGhlIGBlbmNvZGVkYCBwcm9wZXJ0eSBvbiB0aGUgZXJyb3IuXHJcbiAgICAgICAgICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgIE1lc3NhZ2UucHJvdG90eXBlLmVuY29kZTY0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGUoKS50b0Jhc2U2NCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZVtcImVuY29kZWRcIl0pIGVbXCJlbmNvZGVkXCJdID0gZVtcImVuY29kZWRcIl0udG9CYXNlNjQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93KGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICogUmV0dXJucyB0aGUgbWVzc2FnZSBhcyBhIGJhc2U2NCBlbmNvZGVkIHN0cmluZy4gVGhpcyBpcyBhbiBhbGlhcyBmb3Ige0BsaW5rIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZSNlbmNvZGU2NH0uXHJcbiAgICAgICAgICAgICAgICAgICAgICogQG5hbWUgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlI3RvQmFzZTY0XHJcbiAgICAgICAgICAgICAgICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBCYXNlNjQgZW5jb2RlZCBzdHJpbmdcclxuICAgICAgICAgICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIG1lc3NhZ2UgY2Fubm90IGJlIGVuY29kZWQgb3IgaWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nLiBUaGUgbGF0ZXIgc3RpbGxcclxuICAgICAgICAgICAgICAgICAgICAgKiAgcmV0dXJucyB0aGUgZW5jb2RlZCBiYXNlNjQgc3RyaW5nIGluIHRoZSBgZW5jb2RlZGAgcHJvcGVydHkgb24gdGhlIGVycm9yLlxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICBNZXNzYWdlLnByb3RvdHlwZS50b0Jhc2U2NCA9IE1lc3NhZ2UucHJvdG90eXBlLmVuY29kZTY0O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAgICAgKiBEaXJlY3RseSBlbmNvZGVzIHRoZSBtZXNzYWdlIHRvIGEgaGV4IGVuY29kZWQgc3RyaW5nLlxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBuYW1lIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZSNlbmNvZGVIZXhcclxuICAgICAgICAgICAgICAgICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IEhleCBlbmNvZGVkIHN0cmluZ1xyXG4gICAgICAgICAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgdW5kZXJseWluZyBidWZmZXIgY2Fubm90IGJlIGVuY29kZWQgb3IgaWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nLiBUaGUgbGF0ZXJcclxuICAgICAgICAgICAgICAgICAgICAgKiAgc3RpbGwgcmV0dXJucyB0aGUgZW5jb2RlZCBoZXggc3RyaW5nIGluIHRoZSBgZW5jb2RlZGAgcHJvcGVydHkgb24gdGhlIGVycm9yLlxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICBNZXNzYWdlLnByb3RvdHlwZS5lbmNvZGVIZXggPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVuY29kZSgpLnRvSGV4KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlW1wiZW5jb2RlZFwiXSkgZVtcImVuY29kZWRcIl0gPSBlW1wiZW5jb2RlZFwiXS50b0hleCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3coZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAgICAgKiBSZXR1cm5zIHRoZSBtZXNzYWdlIGFzIGEgaGV4IGVuY29kZWQgc3RyaW5nLiBUaGlzIGlzIGFuIGFsaWFzIGZvciB7QGxpbmsgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlI2VuY29kZUhleH0uXHJcbiAgICAgICAgICAgICAgICAgICAgICogQG5hbWUgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlI3RvSGV4XHJcbiAgICAgICAgICAgICAgICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBIZXggZW5jb2RlZCBzdHJpbmdcclxuICAgICAgICAgICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIG1lc3NhZ2UgY2Fubm90IGJlIGVuY29kZWQgb3IgaWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nLiBUaGUgbGF0ZXIgc3RpbGxcclxuICAgICAgICAgICAgICAgICAgICAgKiAgcmV0dXJucyB0aGUgZW5jb2RlZCBoZXggc3RyaW5nIGluIHRoZSBgZW5jb2RlZGAgcHJvcGVydHkgb24gdGhlIGVycm9yLlxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICBNZXNzYWdlLnByb3RvdHlwZS50b0hleCA9IE1lc3NhZ2UucHJvdG90eXBlLmVuY29kZUhleDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICogQ2xvbmVzIGEgbWVzc2FnZSBvYmplY3QgdG8gYSByYXcgb2JqZWN0LlxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7Kn0gb2JqIE9iamVjdCB0byBjbG9uZVxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5jbHVkZUJ1ZmZlcnMgV2hldGhlciB0byBpbmNsdWRlIG5hdGl2ZSBidWZmZXIgZGF0YSBvciBub3RcclxuICAgICAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7Kn0gQ2xvbmVkIG9iamVjdFxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBpbm5lclxyXG4gICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGNsb25lUmF3KG9iaiwgaW5jbHVkZUJ1ZmZlcnMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNsb25lID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgaW4gb2JqKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvYmpbaV0gPT09IG51bGwgfHwgdHlwZW9mIG9ialtpXSAhPT0gJ29iamVjdCcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb25lW2ldID0gb2JqW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9ialtpXSBpbnN0YW5jZW9mIEJ5dGVCdWZmZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluY2x1ZGVCdWZmZXJzKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvbmVbaV0gPSBvYmoudG9CdWZmZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgLy8gaXMgYSBub24tbnVsbCBvYmplY3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvbmVbaV0gPSBjbG9uZVJhdyhvYmpbaV0sIGluY2x1ZGVCdWZmZXJzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNsb25lO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICogUmV0dXJucyB0aGUgbWVzc2FnZSdzIHJhdyBwYXlsb2FkLlxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IGluY2x1ZGVCdWZmZXJzIFdoZXRoZXIgdG8gaW5jbHVkZSBuYXRpdmUgYnVmZmVyIGRhdGEgb3Igbm90LCBkZWZhdWx0cyB0byBgZmFsc2VgXHJcbiAgICAgICAgICAgICAgICAgICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBSYXcgcGF5bG9hZFxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICBNZXNzYWdlLnByb3RvdHlwZS50b1JhdyA9IGZ1bmN0aW9uKGluY2x1ZGVCdWZmZXJzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjbG9uZVJhdyh0aGlzLCAhIWluY2x1ZGVCdWZmZXJzKTtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAgICAgKiBEZWNvZGVzIGEgbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgYnVmZmVyIG9yIHN0cmluZy5cclxuICAgICAgICAgICAgICAgICAgICAgKiBAbmFtZSBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UuZGVjb2RlXHJcbiAgICAgICAgICAgICAgICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHshQnl0ZUJ1ZmZlcnwhQXJyYXlCdWZmZXJ8IUJ1ZmZlcnxzdHJpbmd9IGJ1ZmZlciBCdWZmZXIgdG8gZGVjb2RlIGZyb21cclxuICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZz19IGVuYyBFbmNvZGluZyBpZiBidWZmZXIgaXMgYSBzdHJpbmc6IGhleCwgdXRmOCAobm90IHJlY29tbWVuZGVkKSwgZGVmYXVsdHMgdG8gYmFzZTY0XHJcbiAgICAgICAgICAgICAgICAgICAgICogQHJldHVybiB7IVByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZX0gRGVjb2RlZCBtZXNzYWdlXHJcbiAgICAgICAgICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBtZXNzYWdlIGNhbm5vdCBiZSBkZWNvZGVkIG9yIGlmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZy4gVGhlIGxhdGVyIHN0aWxsXHJcbiAgICAgICAgICAgICAgICAgICAgICogIHJldHVybnMgdGhlIGRlY29kZWQgbWVzc2FnZSB3aXRoIG1pc3NpbmcgZmllbGRzIGluIHRoZSBgZGVjb2RlZGAgcHJvcGVydHkgb24gdGhlIGVycm9yLlxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICAgICAgICAgKiBAc2VlIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZS5kZWNvZGU2NFxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBzZWUgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlLmRlY29kZUhleFxyXG4gICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgIE1lc3NhZ2UuZGVjb2RlID0gZnVuY3Rpb24oYnVmZmVyLCBlbmMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBidWZmZXIgPT09ICdzdHJpbmcnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyID0gQnl0ZUJ1ZmZlci53cmFwKGJ1ZmZlciwgZW5jID8gZW5jIDogXCJiYXNlNjRcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlciA9IGJ1ZmZlciBpbnN0YW5jZW9mIEJ5dGVCdWZmZXIgPyBidWZmZXIgOiBCeXRlQnVmZmVyLndyYXAoYnVmZmVyKTsgLy8gTWF5IHRocm93XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsZSA9IGJ1ZmZlci5saXR0bGVFbmRpYW47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbXNnID0gVC5kZWNvZGUoYnVmZmVyLkxFKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLkxFKGxlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtc2c7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci5MRShsZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyhlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAqIERlY29kZXMgYSB2YXJpbnQzMiBsZW5ndGgtZGVsaW1pdGVkIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIGJ1ZmZlciBvciBzdHJpbmcuXHJcbiAgICAgICAgICAgICAgICAgICAgICogQG5hbWUgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlLmRlY29kZURlbGltaXRlZFxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7IUJ5dGVCdWZmZXJ8IUFycmF5QnVmZmVyfCFCdWZmZXJ8c3RyaW5nfSBidWZmZXIgQnVmZmVyIHRvIGRlY29kZSBmcm9tXHJcbiAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmc9fSBlbmMgRW5jb2RpbmcgaWYgYnVmZmVyIGlzIGEgc3RyaW5nOiBoZXgsIHV0ZjggKG5vdCByZWNvbW1lbmRlZCksIGRlZmF1bHRzIHRvIGJhc2U2NFxyXG4gICAgICAgICAgICAgICAgICAgICAqIEByZXR1cm4ge1Byb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZX0gRGVjb2RlZCBtZXNzYWdlIG9yIGBudWxsYCBpZiBub3QgZW5vdWdoIGJ5dGVzIGFyZSBhdmFpbGFibGUgeWV0XHJcbiAgICAgICAgICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBtZXNzYWdlIGNhbm5vdCBiZSBkZWNvZGVkIG9yIGlmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZy4gVGhlIGxhdGVyIHN0aWxsXHJcbiAgICAgICAgICAgICAgICAgICAgICogIHJldHVybnMgdGhlIGRlY29kZWQgbWVzc2FnZSB3aXRoIG1pc3NpbmcgZmllbGRzIGluIHRoZSBgZGVjb2RlZGAgcHJvcGVydHkgb24gdGhlIGVycm9yLlxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICBNZXNzYWdlLmRlY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uKGJ1ZmZlciwgZW5jKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYnVmZmVyID09PSAnc3RyaW5nJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlciA9IEJ5dGVCdWZmZXIud3JhcChidWZmZXIsIGVuYyA/IGVuYyA6IFwiYmFzZTY0XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIgPSBidWZmZXIgaW5zdGFuY2VvZiBCeXRlQnVmZmVyID8gYnVmZmVyIDogQnl0ZUJ1ZmZlci53cmFwKGJ1ZmZlcik7IC8vIE1heSB0aHJvd1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYnVmZmVyLnJlbWFpbmluZygpIDwgMSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2ZmID0gYnVmZmVyLm9mZnNldCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlbiA9IGJ1ZmZlci5yZWFkVmFyaW50MzIoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJ1ZmZlci5yZW1haW5pbmcoKSA8IGxlbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLm9mZnNldCA9IG9mZjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbXNnID0gVC5kZWNvZGUoYnVmZmVyLnNsaWNlKGJ1ZmZlci5vZmZzZXQsIGJ1ZmZlci5vZmZzZXQgKyBsZW4pLkxFKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLm9mZnNldCArPSBsZW47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbXNnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci5vZmZzZXQgKz0gbGVuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICogRGVjb2RlcyB0aGUgbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgYmFzZTY0IGVuY29kZWQgc3RyaW5nLlxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBuYW1lIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZS5kZWNvZGU2NFxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgU3RyaW5nIHRvIGRlY29kZSBmcm9tXHJcbiAgICAgICAgICAgICAgICAgICAgICogQHJldHVybiB7IVByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZX0gRGVjb2RlZCBtZXNzYWdlXHJcbiAgICAgICAgICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBtZXNzYWdlIGNhbm5vdCBiZSBkZWNvZGVkIG9yIGlmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZy4gVGhlIGxhdGVyIHN0aWxsXHJcbiAgICAgICAgICAgICAgICAgICAgICogIHJldHVybnMgdGhlIGRlY29kZWQgbWVzc2FnZSB3aXRoIG1pc3NpbmcgZmllbGRzIGluIHRoZSBgZGVjb2RlZGAgcHJvcGVydHkgb24gdGhlIGVycm9yLlxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICBNZXNzYWdlLmRlY29kZTY0ID0gZnVuY3Rpb24oc3RyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBNZXNzYWdlLmRlY29kZShzdHIsIFwiYmFzZTY0XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAqIERlY29kZXMgdGhlIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIGhleCBlbmNvZGVkIHN0cmluZy5cclxuICAgICAgICAgICAgICAgICAgICAgKiBAbmFtZSBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UuZGVjb2RlSGV4XHJcbiAgICAgICAgICAgICAgICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciBTdHJpbmcgdG8gZGVjb2RlIGZyb21cclxuICAgICAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIHshUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlfSBEZWNvZGVkIG1lc3NhZ2VcclxuICAgICAgICAgICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIG1lc3NhZ2UgY2Fubm90IGJlIGRlY29kZWQgb3IgaWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nLiBUaGUgbGF0ZXIgc3RpbGxcclxuICAgICAgICAgICAgICAgICAgICAgKiAgcmV0dXJucyB0aGUgZGVjb2RlZCBtZXNzYWdlIHdpdGggbWlzc2luZyBmaWVsZHMgaW4gdGhlIGBkZWNvZGVkYCBwcm9wZXJ0eSBvbiB0aGUgZXJyb3IuXHJcbiAgICAgICAgICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgIE1lc3NhZ2UuZGVjb2RlSGV4ID0gZnVuY3Rpb24oc3RyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBNZXNzYWdlLmRlY29kZShzdHIsIFwiaGV4XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFV0aWxpdHlcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIE1lc3NhZ2UuXHJcbiAgICAgICAgICAgICAgICAgICAgICogQG5hbWUgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlI3RvU3RyaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBTdHJpbmcgcmVwcmVzZW50YXRpb24gYXMgb2YgXCIuRnVsbHkuUXVhbGlmaWVkLk1lc3NhZ2VOYW1lXCJcclxuICAgICAgICAgICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgTWVzc2FnZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFQudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBTdGF0aWNcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICogT3B0aW9ucy5cclxuICAgICAgICAgICAgICAgICAgICAgKiBAbmFtZSBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UuJG9wdGlvbnNcclxuICAgICAgICAgICAgICAgICAgICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsKj59XHJcbiAgICAgICAgICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciAkb3B0aW9uczsgLy8gZm9yIGNjXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZXNzYWdlLCAnJG9wdGlvbnMnLCB7IFwidmFsdWVcIjogVC5idWlsZE9wdCgpIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTWVzc2FnZTtcclxuXHJcbiAgICAgICAgICAgICAgICB9KShQcm90b0J1ZiwgdGhpcyk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gU3RhdGljIGVudW1zIGFuZCBwcm90b3R5cGVkIHN1Yi1tZXNzYWdlc1xyXG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5nZXRDaGlsZHJlbigpO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpPGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkcmVuW2ldIGluc3RhbmNlb2YgRW51bSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhenpbY2hpbGRyZW5baV1bJ25hbWUnXV0gPSBjaGlsZHJlbltpXS5idWlsZCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNoaWxkcmVuW2ldIGluc3RhbmNlb2YgTWVzc2FnZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhenpbY2hpbGRyZW5baV1bJ25hbWUnXV0gPSBjaGlsZHJlbltpXS5idWlsZCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNoaWxkcmVuW2ldIGluc3RhbmNlb2YgTWVzc2FnZS5GaWVsZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZ25vcmVcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIHJlZmxlY3QgY2hpbGQgb2YgXCIrdGhpcy50b1N0cmluZyh0cnVlKStcIjogXCIrY2hpbGRyZW5baV0udG9TdHJpbmcodHJ1ZSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xhenogPSBjbGF6ejtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBFbmNvZGVzIGEgcnVudGltZSBtZXNzYWdlJ3MgY29udGVudHMgdG8gdGhlIHNwZWNpZmllZCBidWZmZXIuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7IVByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZX0gbWVzc2FnZSBSdW50aW1lIG1lc3NhZ2UgdG8gZW5jb2RlXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7Qnl0ZUJ1ZmZlcn0gYnVmZmVyIEJ5dGVCdWZmZXIgdG8gd3JpdGUgdG9cclxuICAgICAgICAgICAgICogQHJldHVybiB7Qnl0ZUJ1ZmZlcn0gVGhlIEJ5dGVCdWZmZXIgZm9yIGNoYWluaW5nXHJcbiAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3Npbmcgb3IgdGhlIG1lc3NhZ2UgY2Fubm90IGJlIGVuY29kZWQgZm9yIGFub3RoZXIgcmVhc29uXHJcbiAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIE1lc3NhZ2UucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uKG1lc3NhZ2UsIGJ1ZmZlcikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGZpZWxkcyA9IHRoaXMuZ2V0Q2hpbGRyZW4oTWVzc2FnZS5GaWVsZCksXHJcbiAgICAgICAgICAgICAgICAgICAgZmllbGRNaXNzaW5nID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGk9MCwgdmFsOyBpPGZpZWxkcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IG1lc3NhZ2UuJGdldChmaWVsZHNbaV0ubmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpZWxkc1tpXS5yZXF1aXJlZCAmJiB2YWwgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpZWxkTWlzc2luZyA9PT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkTWlzc2luZyA9IGZpZWxkc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmllbGRzW2ldLmVuY29kZSh2YWwsIGJ1ZmZlcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoZmllbGRNaXNzaW5nICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVyciA9IEVycm9yKFwiTWlzc2luZyBhdCBsZWFzdCBvbmUgcmVxdWlyZWQgZmllbGQgZm9yIFwiK3RoaXMudG9TdHJpbmcodHJ1ZSkrXCI6IFwiK2ZpZWxkTWlzc2luZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgZXJyW1wiZW5jb2RlZFwiXSA9IGJ1ZmZlcjsgLy8gU3RpbGwgZXhwb3NlIHdoYXQgd2UgZ290XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3coZXJyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBidWZmZXI7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQ2FsY3VsYXRlcyBhIHJ1bnRpbWUgbWVzc2FnZSdzIGJ5dGUgbGVuZ3RoLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0geyFQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2V9IG1lc3NhZ2UgUnVudGltZSBtZXNzYWdlIHRvIGVuY29kZVxyXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBCeXRlIGxlbmd0aFxyXG4gICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nIG9yIHRoZSBtZXNzYWdlIGNhbm5vdCBiZSBjYWxjdWxhdGVkIGZvciBhbm90aGVyIHJlYXNvblxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBNZXNzYWdlLnByb3RvdHlwZS5jYWxjdWxhdGUgPSBmdW5jdGlvbihtZXNzYWdlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZmllbGRzID0gdGhpcy5nZXRDaGlsZHJlbihNZXNzYWdlLkZpZWxkKSxcclxuICAgICAgICAgICAgICAgICAgICBuID0gMDtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGk9MCwgdmFsOyBpPGZpZWxkcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IG1lc3NhZ2UuJGdldChmaWVsZHNbaV0ubmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpZWxkc1tpXS5yZXF1aXJlZCAmJiB2YWwgPT09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJNaXNzaW5nIGF0IGxlYXN0IG9uZSByZXF1aXJlZCBmaWVsZCBmb3IgXCIrdGhpcy50b1N0cmluZyh0cnVlKStcIjogXCIrZmllbGRzW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG4gKz0gZmllbGRzW2ldLmNhbGN1bGF0ZSh2YWwpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG47XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogU2tpcHMgYWxsIGRhdGEgdW50aWwgdGhlIGVuZCBvZiB0aGUgc3BlY2lmaWVkIGdyb3VwIGhhcyBiZWVuIHJlYWNoZWQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBleHBlY3RlZElkIEV4cGVjdGVkIEdST1VQRU5EIGlkXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7IUJ5dGVCdWZmZXJ9IGJ1ZiBCeXRlQnVmZmVyXHJcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgYSB2YWx1ZSBhcyBiZWVuIHNraXBwZWQsIGBmYWxzZWAgaWYgdGhlIGVuZCBoYXMgYmVlbiByZWFjaGVkXHJcbiAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiBpdCB3YXNuJ3QgcG9zc2libGUgdG8gZmluZCB0aGUgZW5kIG9mIHRoZSBncm91cCAoYnVmZmVyIG92ZXJydW4gb3IgZW5kIHRhZyBtaXNtYXRjaClcclxuICAgICAgICAgICAgICogQGlubmVyXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBza2lwVGlsbEdyb3VwRW5kKGV4cGVjdGVkSWQsIGJ1Zikge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRhZyA9IGJ1Zi5yZWFkVmFyaW50MzIoKSwgLy8gVGhyb3dzIG9uIE9PQlxyXG4gICAgICAgICAgICAgICAgICAgIHdpcmVUeXBlID0gdGFnICYgMHgwNyxcclxuICAgICAgICAgICAgICAgICAgICBpZCA9IHRhZyA+PiAzO1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoICh3aXJlVHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuV0lSRV9UWVBFUy5WQVJJTlQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvIHRhZyA9IGJ1Zi5yZWFkVWludDgoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCh0YWcgJiAweDgwKSA9PT0gMHg4MCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuV0lSRV9UWVBFUy5CSVRTNjQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1Zi5vZmZzZXQgKz0gODtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5XSVJFX1RZUEVTLkxERUxJTTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFnID0gYnVmLnJlYWRWYXJpbnQzMigpOyAvLyByZWFkcyB0aGUgdmFyaW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1Zi5vZmZzZXQgKz0gdGFnOyAgICAgICAgLy8gc2tpcHMgbiBieXRlc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLldJUkVfVFlQRVMuU1RBUlRHUk9VUDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2tpcFRpbGxHcm91cEVuZChpZCwgYnVmKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5XSVJFX1RZUEVTLkVOREdST1VQOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaWQgPT09IGV4cGVjdGVkSWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCBHUk9VUEVORCBhZnRlciB1bmtub3duIGdyb3VwOiBcIitpZCtcIiAoXCIrZXhwZWN0ZWRJZCtcIiBleHBlY3RlZClcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5XSVJFX1RZUEVTLkJJVFMzMjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmLm9mZnNldCArPSA0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIklsbGVnYWwgd2lyZSB0eXBlIGluIHVua25vd24gZ3JvdXAgXCIrZXhwZWN0ZWRJZCtcIjogXCIrd2lyZVR5cGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBEZWNvZGVzIGFuIGVuY29kZWQgbWVzc2FnZSBhbmQgcmV0dXJucyB0aGUgZGVjb2RlZCBtZXNzYWdlLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0J5dGVCdWZmZXJ9IGJ1ZmZlciBCeXRlQnVmZmVyIHRvIGRlY29kZSBmcm9tXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gbGVuZ3RoIE1lc3NhZ2UgbGVuZ3RoLiBEZWZhdWx0cyB0byBkZWNvZGUgYWxsIHRoZSBhdmFpbGFibGUgZGF0YS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXI9fSBleHBlY3RlZEdyb3VwRW5kSWQgRXhwZWN0ZWQgR1JPVVBFTkQgaWQgaWYgdGhpcyBpcyBhIGxlZ2FjeSBncm91cFxyXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHtQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2V9IERlY29kZWQgbWVzc2FnZVxyXG4gICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIG1lc3NhZ2UgY2Fubm90IGJlIGRlY29kZWRcclxuICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgTWVzc2FnZS5wcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24oYnVmZmVyLCBsZW5ndGgsIGV4cGVjdGVkR3JvdXBFbmRJZCkge1xyXG4gICAgICAgICAgICAgICAgbGVuZ3RoID0gdHlwZW9mIGxlbmd0aCA9PT0gJ251bWJlcicgPyBsZW5ndGggOiAtMTtcclxuICAgICAgICAgICAgICAgIHZhciBzdGFydCA9IGJ1ZmZlci5vZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgbXNnID0gbmV3ICh0aGlzLmNsYXp6KSgpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHRhZywgd2lyZVR5cGUsIGlkO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGJ1ZmZlci5vZmZzZXQgPCBzdGFydCtsZW5ndGggfHwgKGxlbmd0aCA9PSAtMSAmJiBidWZmZXIucmVtYWluaW5nKCkgPiAwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRhZyA9IGJ1ZmZlci5yZWFkVmFyaW50MzIoKTtcclxuICAgICAgICAgICAgICAgICAgICB3aXJlVHlwZSA9IHRhZyAmIDB4MDc7XHJcbiAgICAgICAgICAgICAgICAgICAgaWQgPSB0YWcgPj4gMztcclxuICAgICAgICAgICAgICAgICAgICBpZiAod2lyZVR5cGUgPT09IFByb3RvQnVmLldJUkVfVFlQRVMuRU5ER1JPVVApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlkICE9PSBleHBlY3RlZEdyb3VwRW5kSWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIklsbGVnYWwgZ3JvdXAgZW5kIGluZGljYXRvciBmb3IgXCIrdGhpcy50b1N0cmluZyh0cnVlKStcIjogXCIraWQrXCIgKFwiKyhleHBlY3RlZEdyb3VwRW5kSWQgPyBleHBlY3RlZEdyb3VwRW5kSWQrXCIgZXhwZWN0ZWRcIiA6IFwibm90IGEgZ3JvdXBcIikrXCIpXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZpZWxkID0gdGhpcy5nZXRDaGlsZChpZCk7IC8vIE1lc3NhZ2UuRmllbGQgb25seVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghZmllbGQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gXCJtZXNzYWdlcyBjcmVhdGVkIGJ5IHlvdXIgbmV3IGNvZGUgY2FuIGJlIHBhcnNlZCBieSB5b3VyIG9sZCBjb2RlOiBvbGQgYmluYXJpZXMgc2ltcGx5IGlnbm9yZSB0aGUgbmV3IGZpZWxkIHdoZW4gcGFyc2luZy5cIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHdpcmVUeXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLldJUkVfVFlQRVMuVkFSSU5UOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci5yZWFkVmFyaW50MzIoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuV0lSRV9UWVBFUy5CSVRTMzI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLm9mZnNldCArPSA0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5XSVJFX1RZUEVTLkJJVFM2NDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIub2Zmc2V0ICs9IDg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLldJUkVfVFlQRVMuTERFTElNOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsZW4gPSBidWZmZXIucmVhZFZhcmludDMyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLm9mZnNldCArPSBsZW47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLldJUkVfVFlQRVMuU1RBUlRHUk9VUDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoc2tpcFRpbGxHcm91cEVuZChpZCwgYnVmZmVyKSkge31cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIHdpcmUgdHlwZSBmb3IgdW5rbm93biBmaWVsZCBcIitpZCtcIiBpbiBcIit0aGlzLnRvU3RyaW5nKHRydWUpK1wiI2RlY29kZTogXCIrd2lyZVR5cGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoZmllbGQucmVwZWF0ZWQgJiYgIWZpZWxkLm9wdGlvbnNbXCJwYWNrZWRcIl0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1zZy4kYWRkKGZpZWxkLm5hbWUsIGZpZWxkLmRlY29kZSh3aXJlVHlwZSwgYnVmZmVyKSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtc2cuJHNldChmaWVsZC5uYW1lLCBmaWVsZC5kZWNvZGUod2lyZVR5cGUsIGJ1ZmZlciksIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIGFsbCByZXF1aXJlZCBmaWVsZHMgYXJlIHByZXNlbnRcclxuICAgICAgICAgICAgICAgIHZhciBmaWVsZHMgPSB0aGlzLmdldENoaWxkcmVuKFByb3RvQnVmLlJlZmxlY3QuRmllbGQpO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpPGZpZWxkcy5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZmllbGRzW2ldLnJlcXVpcmVkICYmIG1zZ1tmaWVsZHNbaV0ubmFtZV0gPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVyciA9IEVycm9yKFwiTWlzc2luZyBhdCBsZWFzdCBvbmUgcmVxdWlyZWQgZmllbGQgZm9yIFwiK3RoaXMudG9TdHJpbmcodHJ1ZSkrXCI6IFwiK2ZpZWxkc1tpXS5uYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyW1wiZGVjb2RlZFwiXSA9IG1zZzsgLy8gU3RpbGwgZXhwb3NlIHdoYXQgd2UgZ290XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93KGVycik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1zZztcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBAYWxpYXMgUHJvdG9CdWYuUmVmbGVjdC5NZXNzYWdlXHJcbiAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFJlZmxlY3QuTWVzc2FnZSA9IE1lc3NhZ2U7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQ29uc3RydWN0cyBhIG5ldyBNZXNzYWdlIEZpZWxkLlxyXG4gICAgICAgICAgICAgKiBAZXhwb3J0cyBQcm90b0J1Zi5SZWZsZWN0Lk1lc3NhZ2UuRmllbGRcclxuICAgICAgICAgICAgICogQHBhcmFtIHtQcm90b0J1Zi5SZWZsZWN0Lk1lc3NhZ2V9IG1lc3NhZ2UgTWVzc2FnZSByZWZlcmVuY2VcclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHJ1bGUgUnVsZSwgb25lIG9mIHJlcXVyaWVkLCBvcHRpb25hbCwgcmVwZWF0ZWRcclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgRGF0YSB0eXBlLCBlLmcuIGludDMyXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIEZpZWxkIG5hbWVcclxuICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGlkIFVuaXF1ZSBmaWVsZCBpZFxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLio+PX0gb3B0aW9ucyBPcHRpb25zXHJcbiAgICAgICAgICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICAgICAgICAgKiBAZXh0ZW5kcyBQcm90b0J1Zi5SZWZsZWN0LlRcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHZhciBGaWVsZCA9IGZ1bmN0aW9uKG1lc3NhZ2UsIHJ1bGUsIHR5cGUsIG5hbWUsIGlkLCBvcHRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICBULmNhbGwodGhpcywgbWVzc2FnZSwgbmFtZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBAb3ZlcnJpZGVcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jbGFzc05hbWUgPSBcIk1lc3NhZ2UuRmllbGRcIjtcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIE1lc3NhZ2UgZmllbGQgcmVxdWlyZWQgZmxhZy5cclxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlcXVpcmVkID0gcnVsZSA9PSBcInJlcXVpcmVkXCI7XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBNZXNzYWdlIGZpZWxkIHJlcGVhdGVkIGZsYWcuXHJcbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZXBlYXRlZCA9IHJ1bGUgPT0gXCJyZXBlYXRlZFwiO1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogTWVzc2FnZSBmaWVsZCB0eXBlLiBUeXBlIHJlZmVyZW5jZSBzdHJpbmcgaWYgdW5yZXNvbHZlZCwgcHJvdG9idWYgdHlwZSBpZiByZXNvbHZlZC5cclxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtzdHJpbmd8e25hbWU6IHN0cmluZywgd2lyZVR5cGU6IG51bWJlcn19XHJcbiAgICAgICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBSZXNvbHZlZCB0eXBlIHJlZmVyZW5jZSBpbnNpZGUgdGhlIGdsb2JhbCBuYW1lc3BhY2UuXHJcbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7UHJvdG9CdWYuUmVmbGVjdC5UfG51bGx9XHJcbiAgICAgICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMucmVzb2x2ZWRUeXBlID0gbnVsbDtcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFVuaXF1ZSBtZXNzYWdlIGZpZWxkIGlkLlxyXG4gICAgICAgICAgICAgICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pZCA9IGlkO1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogTWVzc2FnZSBmaWVsZCBvcHRpb25zLlxyXG4gICAgICAgICAgICAgICAgICogQHR5cGUgeyFPYmplY3QuPHN0cmluZywqPn1cclxuICAgICAgICAgICAgICAgICAqIEBkaWN0XHJcbiAgICAgICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBPcmlnaW5hbCBmaWVsZCBuYW1lLlxyXG4gICAgICAgICAgICAgICAgICogQHR5cGUge3N0cmluZ31cclxuICAgICAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vcmlnaW5hbE5hbWUgPSB0aGlzLm5hbWU7IC8vIFVzZWQgdG8gcmV2ZXJ0IGNhbWVsY2FzZSB0cmFuc2Zvcm1hdGlvbiBvbiBuYW1pbmcgY29sbGlzaW9uc1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgZmllbGQgbmFtZXMgdG8gY2FtZWwgY2FzZSBub3RhdGlvbiBpZiB0aGUgb3ZlcnJpZGUgaXMgc2V0XHJcbiAgICAgICAgICAgICAgICBpZiAoUHJvdG9CdWYuY29udmVydEZpZWxkc1RvQ2FtZWxDYXNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uYW1lID0gdGhpcy5uYW1lLnJlcGxhY2UoL18oW2EtekEtWl0pL2csIGZ1bmN0aW9uKCQwLCAkMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJDEudG9VcHBlckNhc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8vIEV4dGVuZHMgVFxyXG4gICAgICAgICAgICBGaWVsZC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFQucHJvdG90eXBlKTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBNYWtlcyBhIExvbmcgZnJvbSBhIHZhbHVlLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3tsb3c6IG51bWJlciwgaGlnaDogbnVtYmVyLCB1bnNpZ25lZDogYm9vbGVhbn18c3RyaW5nfG51bWJlcn0gdmFsdWUgVmFsdWVcclxuICAgICAgICAgICAgICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QsIGRlZmF1bHRzIHRvIHJldXNlIGl0IGZyb20gTG9uZy1saWtlIG9iamVjdHMgb3IgdG8gc2lnbmVkIGZvclxyXG4gICAgICAgICAgICAgKiAgc3RyaW5ncyBhbmQgbnVtYmVyc1xyXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7IUxvbmd9XHJcbiAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgdmFsdWUgY2Fubm90IGJlIGNvbnZlcnRlZCB0byBhIExvbmdcclxuICAgICAgICAgICAgICogQGlubmVyXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBta0xvbmcodmFsdWUsIHVuc2lnbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlLmxvdyA9PT0gJ251bWJlcicgJiYgdHlwZW9mIHZhbHVlLmhpZ2ggPT09ICdudW1iZXInICYmIHR5cGVvZiB2YWx1ZS51bnNpZ25lZCA9PT0gJ2Jvb2xlYW4nXHJcbiAgICAgICAgICAgICAgICAgICAgJiYgdmFsdWUubG93ID09PSB2YWx1ZS5sb3cgJiYgdmFsdWUuaGlnaCA9PT0gdmFsdWUuaGlnaClcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb3RvQnVmLkxvbmcodmFsdWUubG93LCB2YWx1ZS5oaWdoLCB0eXBlb2YgdW5zaWduZWQgPT09ICd1bmRlZmluZWQnID8gdmFsdWUudW5zaWduZWQgOiB1bnNpZ25lZCk7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJylcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvdG9CdWYuTG9uZy5mcm9tU3RyaW5nKHZhbHVlLCB1bnNpZ25lZCB8fCBmYWxzZSwgMTApO1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb3RvQnVmLkxvbmcuZnJvbU51bWJlcih2YWx1ZSwgdW5zaWduZWQgfHwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJub3QgY29udmVydGlibGUgdG8gTG9uZ1wiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gdmFsdWUgY2FuIGJlIHNldCBmb3IgdGhpcyBmaWVsZC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byBjaGVja1xyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBza2lwUmVwZWF0ZWQgV2hldGhlciB0byBza2lwIHRoZSByZXBlYXRlZCB2YWx1ZSBjaGVjayBvciBub3QuIERlZmF1bHRzIHRvIGZhbHNlLlxyXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHsqfSBWZXJpZmllZCwgbWF5YmUgYWRqdXN0ZWQsIHZhbHVlXHJcbiAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgdmFsdWUgY2Fubm90IGJlIHNldCBmb3IgdGhpcyBmaWVsZFxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBGaWVsZC5wcm90b3R5cGUudmVyaWZ5VmFsdWUgPSBmdW5jdGlvbih2YWx1ZSwgc2tpcFJlcGVhdGVkKSB7XHJcbiAgICAgICAgICAgICAgICBza2lwUmVwZWF0ZWQgPSBza2lwUmVwZWF0ZWQgfHwgZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB2YXIgZmFpbCA9IGZ1bmN0aW9uKHZhbCwgbXNnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIHZhbHVlIGZvciBcIit0aGlzLnRvU3RyaW5nKHRydWUpK1wiIG9mIHR5cGUgXCIrdGhpcy50eXBlLm5hbWUrXCI6IFwiK3ZhbCtcIiAoXCIrbXNnK1wiKVwiKTtcclxuICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKTtcclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkgeyAvLyBOVUxMIHZhbHVlcyBmb3Igb3B0aW9uYWwgZmllbGRzXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucmVxdWlyZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhaWwodHlwZW9mIHZhbHVlLCBcInJlcXVpcmVkXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZXBlYXRlZCAmJiAhc2tpcFJlcGVhdGVkKSB7IC8vIFJlcGVhdGVkIHZhbHVlcyBhcyBhcnJheXNcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIVByb3RvQnVmLlV0aWwuaXNBcnJheSh2YWx1ZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gW3ZhbHVlXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpPTA7IGk8dmFsdWUubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcy5wdXNoKHRoaXMudmVyaWZ5VmFsdWUodmFsdWVbaV0sIHRydWUpKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gQWxsIG5vbi1yZXBlYXRlZCBmaWVsZHMgZXhwZWN0IG5vIGFycmF5XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMucmVwZWF0ZWQgJiYgUHJvdG9CdWYuVXRpbC5pc0FycmF5KHZhbHVlKSlcclxuICAgICAgICAgICAgICAgICAgICBmYWlsKHR5cGVvZiB2YWx1ZSwgXCJubyBhcnJheSBleHBlY3RlZFwiKTtcclxuXHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFNpZ25lZCAzMmJpdFxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJpbnQzMlwiXTpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wic2ludDMyXCJdOlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJzZml4ZWQzMlwiXTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWNjb3VudCBmb3IgIU5hTjogdmFsdWUgPT09IHZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInIHx8ICh2YWx1ZSA9PT0gdmFsdWUgJiYgdmFsdWUgJSAxICE9PSAwKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhaWwodHlwZW9mIHZhbHVlLCBcIm5vdCBhbiBpbnRlZ2VyXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgPiA0Mjk0OTY3Mjk1ID8gdmFsdWUgfCAwIDogdmFsdWU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFVuc2lnbmVkIDMyYml0XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInVpbnQzMlwiXTpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiZml4ZWQzMlwiXTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicgfHwgKHZhbHVlID09PSB2YWx1ZSAmJiB2YWx1ZSAlIDEgIT09IDApKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFpbCh0eXBlb2YgdmFsdWUsIFwibm90IGFuIGludGVnZXJcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSA8IDAgPyB2YWx1ZSA+Pj4gMCA6IHZhbHVlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBTaWduZWQgNjRiaXRcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiaW50NjRcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInNpbnQ2NFwiXTpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wic2ZpeGVkNjRcIl06IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFByb3RvQnVmLkxvbmcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBta0xvbmcodmFsdWUsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWlsKHR5cGVvZiB2YWx1ZSwgZS5tZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFpbCh0eXBlb2YgdmFsdWUsIFwicmVxdWlyZXMgTG9uZy5qc1wiKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFVuc2lnbmVkIDY0Yml0XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInVpbnQ2NFwiXTpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiZml4ZWQ2NFwiXToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoUHJvdG9CdWYuTG9uZylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1rTG9uZyh2YWx1ZSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFpbCh0eXBlb2YgdmFsdWUsIGUubWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhaWwodHlwZW9mIHZhbHVlLCBcInJlcXVpcmVzIExvbmcuanNcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBCb29sXHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImJvb2xcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdib29sZWFuJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhaWwodHlwZW9mIHZhbHVlLCBcIm5vdCBhIGJvb2xlYW5cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRmxvYXRcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiZmxvYXRcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImRvdWJsZVwiXTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWlsKHR5cGVvZiB2YWx1ZSwgXCJub3QgYSBudW1iZXJcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTGVuZ3RoLWRlbGltaXRlZCBzdHJpbmdcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wic3RyaW5nXCJdOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJyAmJiAhKHZhbHVlICYmIHZhbHVlIGluc3RhbmNlb2YgU3RyaW5nKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhaWwodHlwZW9mIHZhbHVlLCBcIm5vdCBhIHN0cmluZ1wiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiXCIrdmFsdWU7IC8vIENvbnZlcnQgU3RyaW5nIG9iamVjdCB0byBzdHJpbmdcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTGVuZ3RoLWRlbGltaXRlZCBieXRlc1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJieXRlc1wiXTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlICYmIHZhbHVlIGluc3RhbmNlb2YgQnl0ZUJ1ZmZlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBCeXRlQnVmZmVyLndyYXAodmFsdWUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBDb25zdGFudCBlbnVtIHZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImVudW1cIl06IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlcyA9IHRoaXMucmVzb2x2ZWRUeXBlLmdldENoaWxkcmVuKEVudW0uVmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGk9MDsgaTx2YWx1ZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZXNbaV0ubmFtZSA9PSB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZXNbaV0uaWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlc1tpXS5pZCA9PSB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZXNbaV0uaWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZmFpbCh2YWx1ZSwgXCJub3QgYSB2YWxpZCBlbnVtIHZhbHVlXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyBFbWJlZGRlZCBtZXNzYWdlXHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImdyb3VwXCJdOlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJtZXNzYWdlXCJdOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdmFsdWUgfHwgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhaWwodHlwZW9mIHZhbHVlLCBcIm9iamVjdCBleHBlY3RlZFwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgdGhpcy5yZXNvbHZlZFR5cGUuY2xhenopXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVsc2UgbGV0J3MgdHJ5IHRvIGNvbnN0cnVjdCBvbmUgZnJvbSBhIGtleS12YWx1ZSBvYmplY3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyAodGhpcy5yZXNvbHZlZFR5cGUuY2xhenopKHZhbHVlKTsgLy8gTWF5IHRocm93IGZvciBhIGh1bmRyZWQgb2YgcmVhc29uc1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBXZSBzaG91bGQgbmV2ZXIgZW5kIGhlcmVcclxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiW0lOVEVSTkFMXSBJbGxlZ2FsIHZhbHVlIGZvciBcIit0aGlzLnRvU3RyaW5nKHRydWUpK1wiOiBcIit2YWx1ZStcIiAodW5kZWZpbmVkIHR5cGUgXCIrdGhpcy50eXBlK1wiKVwiKTtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgZmllbGQgdmFsdWUgdG8gdGhlIHNwZWNpZmllZCBidWZmZXIuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgRmllbGQgdmFsdWVcclxuICAgICAgICAgICAgICogQHBhcmFtIHtCeXRlQnVmZmVyfSBidWZmZXIgQnl0ZUJ1ZmZlciB0byBlbmNvZGUgdG9cclxuICAgICAgICAgICAgICogQHJldHVybiB7Qnl0ZUJ1ZmZlcn0gVGhlIEJ5dGVCdWZmZXIgZm9yIGNoYWluaW5nXHJcbiAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgZmllbGQgY2Fubm90IGJlIGVuY29kZWRcclxuICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgRmllbGQucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uKHZhbHVlLCBidWZmZXIpIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy52ZXJpZnlWYWx1ZSh2YWx1ZSk7IC8vIE1heSB0aHJvd1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gbnVsbCB8fCB0eXBlb2YgdGhpcy50eXBlICE9PSAnb2JqZWN0JylcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIltJTlRFUk5BTF0gVW5yZXNvbHZlZCB0eXBlIGluIFwiK3RoaXMudG9TdHJpbmcodHJ1ZSkrXCI6IFwiK3RoaXMudHlwZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgKHRoaXMucmVwZWF0ZWQgJiYgdmFsdWUubGVuZ3RoID09IDApKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBidWZmZXI7IC8vIE9wdGlvbmFsIG9taXR0ZWRcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucmVwZWF0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFwiT25seSByZXBlYXRlZCBmaWVsZHMgb2YgcHJpbWl0aXZlIG51bWVyaWMgdHlwZXMgKHR5cGVzIHdoaWNoIHVzZSB0aGUgdmFyaW50LCAzMi1iaXQsIG9yIDY0LWJpdCB3aXJlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHR5cGVzKSBjYW4gYmUgZGVjbGFyZWQgJ3BhY2tlZCcuXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9uc1tcInBhY2tlZFwiXSAmJiBQcm90b0J1Zi5QQUNLQUJMRV9XSVJFX1RZUEVTLmluZGV4T2YodGhpcy50eXBlLndpcmVUeXBlKSA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBcIkFsbCBvZiB0aGUgZWxlbWVudHMgb2YgdGhlIGZpZWxkIGFyZSBwYWNrZWQgaW50byBhIHNpbmdsZSBrZXktdmFsdWUgcGFpciB3aXRoIHdpcmUgdHlwZSAyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAobGVuZ3RoLWRlbGltaXRlZCkuIEVhY2ggZWxlbWVudCBpcyBlbmNvZGVkIHRoZSBzYW1lIHdheSBpdCB3b3VsZCBiZSBub3JtYWxseSwgZXhjZXB0IHdpdGhvdXQgYVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGFnIHByZWNlZGluZyBpdC5cIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLndyaXRlVmFyaW50MzIoKHRoaXMuaWQgPDwgMykgfCBQcm90b0J1Zi5XSVJFX1RZUEVTLkxERUxJTSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIuZW5zdXJlQ2FwYWNpdHkoYnVmZmVyLm9mZnNldCArPSAxKTsgLy8gV2UgZG8gbm90IGtub3cgdGhlIGxlbmd0aCB5ZXQsIHNvIGxldCdzIGFzc3VtZSBhIHZhcmludCBvZiBsZW5ndGggMVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gYnVmZmVyLm9mZnNldDsgLy8gUmVtZW1iZXIgd2hlcmUgdGhlIGNvbnRlbnRzIGJlZ2luXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGk9MDsgaTx2YWx1ZS5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVuY29kZVZhbHVlKHZhbHVlW2ldLCBidWZmZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxlbiA9IGJ1ZmZlci5vZmZzZXQtc3RhcnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFyaW50TGVuID0gQnl0ZUJ1ZmZlci5jYWxjdWxhdGVWYXJpbnQzMihsZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhcmludExlbiA+IDEpIHsgLy8gV2UgbmVlZCB0byBtb3ZlIHRoZSBjb250ZW50c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb250ZW50cyA9IGJ1ZmZlci5zbGljZShzdGFydCwgYnVmZmVyLm9mZnNldCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgKz0gdmFyaW50TGVuLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLm9mZnNldCA9IHN0YXJ0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci5hcHBlbmQoY29udGVudHMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLndyaXRlVmFyaW50MzIobGVuLCBzdGFydC12YXJpbnRMZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gXCJJZiB5b3VyIG1lc3NhZ2UgZGVmaW5pdGlvbiBoYXMgcmVwZWF0ZWQgZWxlbWVudHMgKHdpdGhvdXQgdGhlIFtwYWNrZWQ9dHJ1ZV0gb3B0aW9uKSwgdGhlIGVuY29kZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1lc3NhZ2UgaGFzIHplcm8gb3IgbW9yZSBrZXktdmFsdWUgcGFpcnMgd2l0aCB0aGUgc2FtZSB0YWcgbnVtYmVyXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaT0wOyBpPHZhbHVlLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci53cml0ZVZhcmludDMyKCh0aGlzLmlkIDw8IDMpIHwgdGhpcy50eXBlLndpcmVUeXBlKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVuY29kZVZhbHVlKHZhbHVlW2ldLCBidWZmZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci53cml0ZVZhcmludDMyKCh0aGlzLmlkIDw8IDMpIHwgdGhpcy50eXBlLndpcmVUeXBlKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbmNvZGVWYWx1ZSh2YWx1ZSwgYnVmZmVyKTtcclxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIklsbGVnYWwgdmFsdWUgZm9yIFwiK3RoaXMudG9TdHJpbmcodHJ1ZSkrXCI6IFwiK3ZhbHVlK1wiIChcIitlK1wiKVwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBidWZmZXI7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogRW5jb2RlcyBhIHZhbHVlIHRvIHRoZSBzcGVjaWZpZWQgYnVmZmVyLiBEb2VzIG5vdCBlbmNvZGUgdGhlIGtleS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBGaWVsZCB2YWx1ZVxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0J5dGVCdWZmZXJ9IGJ1ZmZlciBCeXRlQnVmZmVyIHRvIGVuY29kZSB0b1xyXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHtCeXRlQnVmZmVyfSBUaGUgQnl0ZUJ1ZmZlciBmb3IgY2hhaW5pbmdcclxuICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSB2YWx1ZSBjYW5ub3QgYmUgZW5jb2RlZFxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBGaWVsZC5wcm90b3R5cGUuZW5jb2RlVmFsdWUgPSBmdW5jdGlvbih2YWx1ZSwgYnVmZmVyKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHJldHVybiBidWZmZXI7IC8vIE5vdGhpbmcgdG8gZW5jb2RlXHJcbiAgICAgICAgICAgICAgICAvLyBUYWcgaGFzIGFscmVhZHkgYmVlbiB3cml0dGVuXHJcblxyXG4gICAgICAgICAgICAgICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyAzMmJpdCBzaWduZWQgdmFyaW50XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImludDMyXCJdOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBcIklmIHlvdSB1c2UgaW50MzIgb3IgaW50NjQgYXMgdGhlIHR5cGUgZm9yIGEgbmVnYXRpdmUgbnVtYmVyLCB0aGUgcmVzdWx0aW5nIHZhcmludCBpcyBhbHdheXMgdGVuIGJ5dGVzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxvbmcg4oCTIGl0IGlzLCBlZmZlY3RpdmVseSwgdHJlYXRlZCBsaWtlIGEgdmVyeSBsYXJnZSB1bnNpZ25lZCBpbnRlZ2VyLlwiIChzZWUgIzEyMilcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlIDwgMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci53cml0ZVZhcmludDY0KHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLndyaXRlVmFyaW50MzIodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gMzJiaXQgdW5zaWduZWQgdmFyaW50XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInVpbnQzMlwiXTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLndyaXRlVmFyaW50MzIodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gMzJiaXQgdmFyaW50IHppZy16YWdcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wic2ludDMyXCJdOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIud3JpdGVWYXJpbnQzMlppZ1phZyh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBGaXhlZCB1bnNpZ25lZCAzMmJpdFxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJmaXhlZDMyXCJdOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIud3JpdGVVaW50MzIodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRml4ZWQgc2lnbmVkIDMyYml0XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInNmaXhlZDMyXCJdOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIud3JpdGVJbnQzMih2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyA2NGJpdCB2YXJpbnQgYXMtaXNcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiaW50NjRcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInVpbnQ2NFwiXTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLndyaXRlVmFyaW50NjQodmFsdWUpOyAvLyB0aHJvd3NcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIDY0Yml0IHZhcmludCB6aWctemFnXHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInNpbnQ2NFwiXTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLndyaXRlVmFyaW50NjRaaWdaYWcodmFsdWUpOyAvLyB0aHJvd3NcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEZpeGVkIHVuc2lnbmVkIDY0Yml0XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImZpeGVkNjRcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci53cml0ZVVpbnQ2NCh2YWx1ZSk7IC8vIHRocm93c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRml4ZWQgc2lnbmVkIDY0Yml0XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInNmaXhlZDY0XCJdOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIud3JpdGVJbnQ2NCh2YWx1ZSk7IC8vIHRocm93c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQm9vbFxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJib29sXCJdOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci53cml0ZVZhcmludDMyKHZhbHVlLnRvTG93ZXJDYXNlKCkgPT09ICdmYWxzZScgPyAwIDogISF2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci53cml0ZVZhcmludDMyKHZhbHVlID8gMSA6IDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ29uc3RhbnQgZW51bSB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJlbnVtXCJdOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIud3JpdGVWYXJpbnQzMih2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyAzMmJpdCBmbG9hdFxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJmbG9hdFwiXTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLndyaXRlRmxvYXQzMih2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyA2NGJpdCBmbG9hdFxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJkb3VibGVcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci53cml0ZUZsb2F0NjQodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTGVuZ3RoLWRlbGltaXRlZCBzdHJpbmdcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wic3RyaW5nXCJdOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIud3JpdGVWU3RyaW5nKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIExlbmd0aC1kZWxpbWl0ZWQgYnl0ZXNcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiYnl0ZXNcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5yZW1haW5pbmcoKSA8IDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIklsbGVnYWwgdmFsdWUgZm9yIFwiK3RoaXMudG9TdHJpbmcodHJ1ZSkrXCI6IFwiK3ZhbHVlLnJlbWFpbmluZygpK1wiIGJ5dGVzIHJlbWFpbmluZ1wiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByZXZPZmZzZXQgPSB2YWx1ZS5vZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci53cml0ZVZhcmludDMyKHZhbHVlLnJlbWFpbmluZygpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLmFwcGVuZCh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLm9mZnNldCA9IHByZXZPZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBFbWJlZGRlZCBtZXNzYWdlXHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcIm1lc3NhZ2VcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBiYiA9IG5ldyBCeXRlQnVmZmVyKCkuTEUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNvbHZlZFR5cGUuZW5jb2RlKHZhbHVlLCBiYik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci53cml0ZVZhcmludDMyKGJiLm9mZnNldCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci5hcHBlbmQoYmIuZmxpcCgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIExlZ2FjeSBncm91cFxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJncm91cFwiXTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNvbHZlZFR5cGUuZW5jb2RlKHZhbHVlLCBidWZmZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIud3JpdGVWYXJpbnQzMigodGhpcy5pZCA8PCAzKSB8IFByb3RvQnVmLldJUkVfVFlQRVMuRU5ER1JPVVApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2Ugc2hvdWxkIG5ldmVyIGVuZCBoZXJlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiW0lOVEVSTkFMXSBJbGxlZ2FsIHZhbHVlIHRvIGVuY29kZSBpbiBcIit0aGlzLnRvU3RyaW5nKHRydWUpK1wiOiBcIit2YWx1ZStcIiAodW5rbm93biB0eXBlKVwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBidWZmZXI7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQ2FsY3VsYXRlcyB0aGUgbGVuZ3RoIG9mIHRoaXMgZmllbGQncyB2YWx1ZSBvbiB0aGUgbmV0d29yayBsZXZlbC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBGaWVsZCB2YWx1ZVxyXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBCeXRlIGxlbmd0aFxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBGaWVsZC5wcm90b3R5cGUuY2FsY3VsYXRlID0gZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy52ZXJpZnlWYWx1ZSh2YWx1ZSk7IC8vIE1heSB0aHJvd1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gbnVsbCB8fCB0eXBlb2YgdGhpcy50eXBlICE9PSAnb2JqZWN0JylcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIltJTlRFUk5BTF0gVW5yZXNvbHZlZCB0eXBlIGluIFwiK3RoaXMudG9TdHJpbmcodHJ1ZSkrXCI6IFwiK3RoaXMudHlwZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgKHRoaXMucmVwZWF0ZWQgJiYgdmFsdWUubGVuZ3RoID09IDApKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwOyAvLyBPcHRpb25hbCBvbWl0dGVkXHJcbiAgICAgICAgICAgICAgICB2YXIgbiA9IDA7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlcGVhdGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpLCBuaTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9uc1tcInBhY2tlZFwiXSAmJiBQcm90b0J1Zi5QQUNLQUJMRV9XSVJFX1RZUEVTLmluZGV4T2YodGhpcy50eXBlLndpcmVUeXBlKSA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuICs9IEJ5dGVCdWZmZXIuY2FsY3VsYXRlVmFyaW50MzIoKHRoaXMuaWQgPDwgMykgfCBQcm90b0J1Zi5XSVJFX1RZUEVTLkxERUxJTSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuaSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGk9MDsgaTx2YWx1ZS5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuaSArPSB0aGlzLmNhbGN1bGF0ZVZhbHVlKHZhbHVlW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG4gKz0gQnl0ZUJ1ZmZlci5jYWxjdWxhdGVWYXJpbnQzMihuaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuICs9IG5pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpPTA7IGk8dmFsdWUubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbiArPSBCeXRlQnVmZmVyLmNhbGN1bGF0ZVZhcmludDMyKCh0aGlzLmlkIDw8IDMpIHwgdGhpcy50eXBlLndpcmVUeXBlKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuICs9IHRoaXMuY2FsY3VsYXRlVmFsdWUodmFsdWVbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbiArPSBCeXRlQnVmZmVyLmNhbGN1bGF0ZVZhcmludDMyKCh0aGlzLmlkIDw8IDMpIHwgdGhpcy50eXBlLndpcmVUeXBlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbiArPSB0aGlzLmNhbGN1bGF0ZVZhbHVlKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIHZhbHVlIGZvciBcIit0aGlzLnRvU3RyaW5nKHRydWUpK1wiOiBcIit2YWx1ZStcIiAoXCIrZStcIilcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbjtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBDYWxjdWxhdGVzIHRoZSBieXRlIGxlbmd0aCBvZiBhIHZhbHVlLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0geyp9IHZhbHVlIEZpZWxkIHZhbHVlXHJcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IEJ5dGUgbGVuZ3RoXHJcbiAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgdmFsdWUgY2Fubm90IGJlIGNhbGN1bGF0ZWRcclxuICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgRmllbGQucHJvdG90eXBlLmNhbGN1bGF0ZVZhbHVlID0gZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkgcmV0dXJuIDA7IC8vIE5vdGhpbmcgdG8gZW5jb2RlXHJcbiAgICAgICAgICAgICAgICAvLyBUYWcgaGFzIGFscmVhZHkgYmVlbiB3cml0dGVuXHJcbiAgICAgICAgICAgICAgICB2YXIgbjtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImludDMyXCJdOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgPCAwID8gQnl0ZUJ1ZmZlci5jYWxjdWxhdGVWYXJpbnQ2NCh2YWx1ZSkgOiBCeXRlQnVmZmVyLmNhbGN1bGF0ZVZhcmludDMyKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1widWludDMyXCJdOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gQnl0ZUJ1ZmZlci5jYWxjdWxhdGVWYXJpbnQzMih2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInNpbnQzMlwiXTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJ5dGVCdWZmZXIuY2FsY3VsYXRlVmFyaW50MzIoQnl0ZUJ1ZmZlci56aWdaYWdFbmNvZGUzMih2YWx1ZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJmaXhlZDMyXCJdOlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJzZml4ZWQzMlwiXTpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiZmxvYXRcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiA0O1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJpbnQ2NFwiXTpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1widWludDY0XCJdOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gQnl0ZUJ1ZmZlci5jYWxjdWxhdGVWYXJpbnQ2NCh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInNpbnQ2NFwiXTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJ5dGVCdWZmZXIuY2FsY3VsYXRlVmFyaW50NjQoQnl0ZUJ1ZmZlci56aWdaYWdFbmNvZGU2NCh2YWx1ZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJmaXhlZDY0XCJdOlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJzZml4ZWQ2NFwiXTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDg7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImJvb2xcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJlbnVtXCJdOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gQnl0ZUJ1ZmZlci5jYWxjdWxhdGVWYXJpbnQzMih2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImRvdWJsZVwiXTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDg7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInN0cmluZ1wiXTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgbiA9IEJ5dGVCdWZmZXIuY2FsY3VsYXRlVVRGOEJ5dGVzKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJ5dGVCdWZmZXIuY2FsY3VsYXRlVmFyaW50MzIobikgKyBuO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJieXRlc1wiXTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlLnJlbWFpbmluZygpIDwgMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCB2YWx1ZSBmb3IgXCIrdGhpcy50b1N0cmluZyh0cnVlKStcIjogXCIrdmFsdWUucmVtYWluaW5nKCkrXCIgYnl0ZXMgcmVtYWluaW5nXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gQnl0ZUJ1ZmZlci5jYWxjdWxhdGVWYXJpbnQzMih2YWx1ZS5yZW1haW5pbmcoKSkgKyB2YWx1ZS5yZW1haW5pbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wibWVzc2FnZVwiXTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgbiA9IHRoaXMucmVzb2x2ZWRUeXBlLmNhbGN1bGF0ZSh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBCeXRlQnVmZmVyLmNhbGN1bGF0ZVZhcmludDMyKG4pICsgbjtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiZ3JvdXBcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG4gPSB0aGlzLnJlc29sdmVkVHlwZS5jYWxjdWxhdGUodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbiArIEJ5dGVCdWZmZXIuY2FsY3VsYXRlVmFyaW50MzIoKHRoaXMuaWQgPDwgMykgfCBQcm90b0J1Zi5XSVJFX1RZUEVTLkVOREdST1VQKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIFdlIHNob3VsZCBuZXZlciBlbmQgaGVyZVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJbSU5URVJOQUxdIElsbGVnYWwgdmFsdWUgdG8gZW5jb2RlIGluIFwiK3RoaXMudG9TdHJpbmcodHJ1ZSkrXCI6IFwiK3ZhbHVlK1wiICh1bmtub3duIHR5cGUpXCIpO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIERlY29kZSB0aGUgZmllbGQgdmFsdWUgZnJvbSB0aGUgc3BlY2lmaWVkIGJ1ZmZlci5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHdpcmVUeXBlIExlYWRpbmcgd2lyZSB0eXBlXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7Qnl0ZUJ1ZmZlcn0gYnVmZmVyIEJ5dGVCdWZmZXIgdG8gZGVjb2RlIGZyb21cclxuICAgICAgICAgICAgICogQHBhcmFtIHtib29sZWFuPX0gc2tpcFJlcGVhdGVkIFdoZXRoZXIgdG8gc2tpcCB0aGUgcmVwZWF0ZWQgY2hlY2sgb3Igbm90LiBEZWZhdWx0cyB0byBmYWxzZS5cclxuICAgICAgICAgICAgICogQHJldHVybiB7Kn0gRGVjb2RlZCB2YWx1ZVxyXG4gICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGZpZWxkIGNhbm5vdCBiZSBkZWNvZGVkXHJcbiAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEZpZWxkLnByb3RvdHlwZS5kZWNvZGUgPSBmdW5jdGlvbih3aXJlVHlwZSwgYnVmZmVyLCBza2lwUmVwZWF0ZWQpIHtcclxuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSwgbkJ5dGVzO1xyXG4gICAgICAgICAgICAgICAgaWYgKHdpcmVUeXBlICE9IHRoaXMudHlwZS53aXJlVHlwZSAmJiAoc2tpcFJlcGVhdGVkIHx8ICh3aXJlVHlwZSAhPSBQcm90b0J1Zi5XSVJFX1RZUEVTLkxERUxJTSB8fCAhdGhpcy5yZXBlYXRlZCkpKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCB3aXJlIHR5cGUgZm9yIGZpZWxkIFwiK3RoaXMudG9TdHJpbmcodHJ1ZSkrXCI6IFwiK3dpcmVUeXBlK1wiIChcIit0aGlzLnR5cGUud2lyZVR5cGUrXCIgZXhwZWN0ZWQpXCIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHdpcmVUeXBlID09IFByb3RvQnVmLldJUkVfVFlQRVMuTERFTElNICYmIHRoaXMucmVwZWF0ZWQgJiYgdGhpcy5vcHRpb25zW1wicGFja2VkXCJdICYmIFByb3RvQnVmLlBBQ0tBQkxFX1dJUkVfVFlQRVMuaW5kZXhPZih0aGlzLnR5cGUud2lyZVR5cGUpID49IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXNraXBSZXBlYXRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuQnl0ZXMgPSBidWZmZXIucmVhZFZhcmludDMyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5CeXRlcyA9IGJ1ZmZlci5vZmZzZXQgKyBuQnl0ZXM7IC8vIExpbWl0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZXMgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGJ1ZmZlci5vZmZzZXQgPCBuQnl0ZXMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaCh0aGlzLmRlY29kZSh0aGlzLnR5cGUud2lyZVR5cGUsIGJ1ZmZlciwgdHJ1ZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVzO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyBSZWFkIHRoZSBuZXh0IHZhbHVlIG90aGVyd2lzZS4uLlxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyAzMmJpdCBzaWduZWQgdmFyaW50XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImludDMyXCJdOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYnVmZmVyLnJlYWRWYXJpbnQzMigpIHwgMDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gMzJiaXQgdW5zaWduZWQgdmFyaW50XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInVpbnQzMlwiXTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlci5yZWFkVmFyaW50MzIoKSA+Pj4gMDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gMzJiaXQgc2lnbmVkIHZhcmludCB6aWctemFnXHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInNpbnQzMlwiXTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlci5yZWFkVmFyaW50MzJaaWdaYWcoKSB8IDA7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEZpeGVkIDMyYml0IHVuc2lnbmVkXHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImZpeGVkMzJcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBidWZmZXIucmVhZFVpbnQzMigpID4+PiAwO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wic2ZpeGVkMzJcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBidWZmZXIucmVhZEludDMyKCkgfCAwO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyA2NGJpdCBzaWduZWQgdmFyaW50XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImludDY0XCJdOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYnVmZmVyLnJlYWRWYXJpbnQ2NCgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyA2NGJpdCB1bnNpZ25lZCB2YXJpbnRcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1widWludDY0XCJdOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYnVmZmVyLnJlYWRWYXJpbnQ2NCgpLnRvVW5zaWduZWQoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gNjRiaXQgc2lnbmVkIHZhcmludCB6aWctemFnXHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInNpbnQ2NFwiXTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlci5yZWFkVmFyaW50NjRaaWdaYWcoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRml4ZWQgNjRiaXQgdW5zaWduZWRcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiZml4ZWQ2NFwiXTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlci5yZWFkVWludDY0KCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEZpeGVkIDY0Yml0IHNpZ25lZFxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJzZml4ZWQ2NFwiXTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlci5yZWFkSW50NjQoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQm9vbCB2YXJpbnRcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiYm9vbFwiXTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICEhYnVmZmVyLnJlYWRWYXJpbnQzMigpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBDb25zdGFudCBlbnVtIHZhbHVlICh2YXJpbnQpXHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImVudW1cIl06XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBmb2xsb3dpbmcgQnVpbGRlci5NZXNzYWdlI3NldCB3aWxsIGFscmVhZHkgdGhyb3dcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlci5yZWFkVmFyaW50MzIoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gMzJiaXQgZmxvYXRcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiZmxvYXRcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBidWZmZXIucmVhZEZsb2F0KCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIDY0Yml0IGZsb2F0XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImRvdWJsZVwiXTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlci5yZWFkRG91YmxlKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIExlbmd0aC1kZWxpbWl0ZWQgc3RyaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInN0cmluZ1wiXTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlci5yZWFkVlN0cmluZygpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBMZW5ndGgtZGVsaW1pdGVkIGJ5dGVzXHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImJ5dGVzXCJdOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5CeXRlcyA9IGJ1ZmZlci5yZWFkVmFyaW50MzIoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJ1ZmZlci5yZW1haW5pbmcoKSA8IG5CeXRlcylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCBudW1iZXIgb2YgYnl0ZXMgZm9yIFwiK3RoaXMudG9TdHJpbmcodHJ1ZSkrXCI6IFwiK25CeXRlcytcIiByZXF1aXJlZCBidXQgZ290IG9ubHkgXCIrYnVmZmVyLnJlbWFpbmluZygpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBidWZmZXIuY2xvbmUoKTsgLy8gT2Zmc2V0IGFscmVhZHkgc2V0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLmxpbWl0ID0gdmFsdWUub2Zmc2V0K25CeXRlcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLm9mZnNldCArPSBuQnl0ZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIExlbmd0aC1kZWxpbWl0ZWQgZW1iZWRkZWQgbWVzc2FnZVxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJtZXNzYWdlXCJdOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5CeXRlcyA9IGJ1ZmZlci5yZWFkVmFyaW50MzIoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzb2x2ZWRUeXBlLmRlY29kZShidWZmZXIsIG5CeXRlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBMZWdhY3kgZ3JvdXBcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiZ3JvdXBcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc29sdmVkVHlwZS5kZWNvZGUoYnVmZmVyLCAtMSwgdGhpcy5pZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gV2Ugc2hvdWxkIG5ldmVyIGVuZCBoZXJlXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIltJTlRFUk5BTF0gSWxsZWdhbCB3aXJlIHR5cGUgZm9yIFwiK3RoaXMudG9TdHJpbmcodHJ1ZSkrXCI6IFwiK3dpcmVUeXBlKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEBhbGlhcyBQcm90b0J1Zi5SZWZsZWN0Lk1lc3NhZ2UuRmllbGRcclxuICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgUmVmbGVjdC5NZXNzYWdlLkZpZWxkID0gRmllbGQ7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQ29uc3RydWN0cyBhIG5ldyBNZXNzYWdlIEV4dGVuc2lvbkZpZWxkLlxyXG4gICAgICAgICAgICAgKiBAZXhwb3J0cyBQcm90b0J1Zi5SZWZsZWN0Lk1lc3NhZ2UuRXh0ZW5zaW9uRmllbGRcclxuICAgICAgICAgICAgICogQHBhcmFtIHtQcm90b0J1Zi5SZWZsZWN0Lk1lc3NhZ2V9IG1lc3NhZ2UgTWVzc2FnZSByZWZlcmVuY2VcclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHJ1bGUgUnVsZSwgb25lIG9mIHJlcXVyaWVkLCBvcHRpb25hbCwgcmVwZWF0ZWRcclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgRGF0YSB0eXBlLCBlLmcuIGludDMyXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIEZpZWxkIG5hbWVcclxuICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGlkIFVuaXF1ZSBmaWVsZCBpZFxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLio+PX0gb3B0aW9ucyBPcHRpb25zXHJcbiAgICAgICAgICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICAgICAgICAgKiBAZXh0ZW5kcyBQcm90b0J1Zi5SZWZsZWN0Lk1lc3NhZ2UuRmllbGRcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHZhciBFeHRlbnNpb25GaWVsZCA9IGZ1bmN0aW9uKG1lc3NhZ2UsIHJ1bGUsIHR5cGUsIG5hbWUsIGlkLCBvcHRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICBGaWVsZC5jYWxsKHRoaXMsIG1lc3NhZ2UsIHJ1bGUsIHR5cGUsIG5hbWUsIGlkLCBvcHRpb25zKTtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8vIEV4dGVuZHMgRmllbGRcclxuICAgICAgICAgICAgRXh0ZW5zaW9uRmllbGQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShGaWVsZC5wcm90b3R5cGUpO1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEBhbGlhcyBQcm90b0J1Zi5SZWZsZWN0Lk1lc3NhZ2UuRXh0ZW5zaW9uRmllbGRcclxuICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgUmVmbGVjdC5NZXNzYWdlLkV4dGVuc2lvbkZpZWxkID0gRXh0ZW5zaW9uRmllbGQ7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQ29uc3RydWN0cyBhIG5ldyBFbnVtLlxyXG4gICAgICAgICAgICAgKiBAZXhwb3J0cyBQcm90b0J1Zi5SZWZsZWN0LkVudW1cclxuICAgICAgICAgICAgICogQHBhcmFtIHshUHJvdG9CdWYuUmVmbGVjdC5UfSBwYXJlbnQgUGFyZW50IFJlZmxlY3Qgb2JqZWN0XHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIEVudW0gbmFtZVxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLio+PX0gb3B0aW9ucyBFbnVtIG9wdGlvbnNcclxuICAgICAgICAgICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgICAgICAgICAqIEBleHRlbmRzIFByb3RvQnVmLlJlZmxlY3QuTmFtZXNwYWNlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB2YXIgRW51bSA9IGZ1bmN0aW9uKHBhcmVudCwgbmFtZSwgb3B0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgTmFtZXNwYWNlLmNhbGwodGhpcywgcGFyZW50LCBuYW1lLCBvcHRpb25zKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEBvdmVycmlkZVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLmNsYXNzTmFtZSA9IFwiRW51bVwiO1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogUnVudGltZSBlbnVtIG9iamVjdC5cclxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZyxudW1iZXI+fG51bGx9XHJcbiAgICAgICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMub2JqZWN0ID0gbnVsbDtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8vIEV4dGVuZHMgTmFtZXNwYWNlXHJcbiAgICAgICAgICAgIEVudW0ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShOYW1lc3BhY2UucHJvdG90eXBlKTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBCdWlsZHMgdGhpcyBlbnVtIGFuZCByZXR1cm5zIHRoZSBydW50aW1lIGNvdW50ZXJwYXJ0LlxyXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3Q8c3RyaW5nLCo+fVxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBFbnVtLnByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGVubSA9IHt9O1xyXG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlcyA9IHRoaXMuZ2V0Q2hpbGRyZW4oRW51bS5WYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8dmFsdWVzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgIGVubVt2YWx1ZXNbaV1bJ25hbWUnXV0gPSB2YWx1ZXNbaV1bJ2lkJ107XHJcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KVxyXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbm0sICckb3B0aW9ucycsIHsgXCJ2YWx1ZVwiOiB0aGlzLmJ1aWxkT3B0KCkgfSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vYmplY3QgPSBlbm07XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQGFsaWFzIFByb3RvQnVmLlJlZmxlY3QuRW51bVxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBSZWZsZWN0LkVudW0gPSBFbnVtO1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgRW51bSBWYWx1ZS5cclxuICAgICAgICAgICAgICogQGV4cG9ydHMgUHJvdG9CdWYuUmVmbGVjdC5FbnVtLlZhbHVlXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7IVByb3RvQnVmLlJlZmxlY3QuRW51bX0gZW5tIEVudW0gcmVmZXJlbmNlXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIEZpZWxkIG5hbWVcclxuICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGlkIFVuaXF1ZSBmaWVsZCBpZFxyXG4gICAgICAgICAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAgICAgICAgICogQGV4dGVuZHMgUHJvdG9CdWYuUmVmbGVjdC5UXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB2YXIgVmFsdWUgPSBmdW5jdGlvbihlbm0sIG5hbWUsIGlkKSB7XHJcbiAgICAgICAgICAgICAgICBULmNhbGwodGhpcywgZW5tLCBuYW1lKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEBvdmVycmlkZVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLmNsYXNzTmFtZSA9IFwiRW51bS5WYWx1ZVwiO1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogVW5pcXVlIGVudW0gdmFsdWUgaWQuXHJcbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLmlkID0gaWQ7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvLyBFeHRlbmRzIFRcclxuICAgICAgICAgICAgVmFsdWUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShULnByb3RvdHlwZSk7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQGFsaWFzIFByb3RvQnVmLlJlZmxlY3QuRW51bS5WYWx1ZVxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBSZWZsZWN0LkVudW0uVmFsdWUgPSBWYWx1ZTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IFNlcnZpY2UuXHJcbiAgICAgICAgICAgICAqIEBleHBvcnRzIFByb3RvQnVmLlJlZmxlY3QuU2VydmljZVxyXG4gICAgICAgICAgICAgKiBAcGFyYW0geyFQcm90b0J1Zi5SZWZsZWN0Lk5hbWVzcGFjZX0gcm9vdCBSb290XHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFNlcnZpY2UgbmFtZVxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+PX0gb3B0aW9ucyBPcHRpb25zXHJcbiAgICAgICAgICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICAgICAgICAgKiBAZXh0ZW5kcyBQcm90b0J1Zi5SZWZsZWN0Lk5hbWVzcGFjZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdmFyIFNlcnZpY2UgPSBmdW5jdGlvbihyb290LCBuYW1lLCBvcHRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICBOYW1lc3BhY2UuY2FsbCh0aGlzLCByb290LCBuYW1lLCBvcHRpb25zKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEBvdmVycmlkZVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLmNsYXNzTmFtZSA9IFwiU2VydmljZVwiO1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQnVpbHQgcnVudGltZSBzZXJ2aWNlIGNsYXNzLlxyXG4gICAgICAgICAgICAgICAgICogQHR5cGUgez9mdW5jdGlvbihuZXc6UHJvdG9CdWYuQnVpbGRlci5TZXJ2aWNlKX1cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jbGF6eiA9IG51bGw7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvLyBFeHRlbmRzIE5hbWVzcGFjZVxyXG4gICAgICAgICAgICBTZXJ2aWNlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTmFtZXNwYWNlLnByb3RvdHlwZSk7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQnVpbGRzIHRoZSBzZXJ2aWNlIGFuZCByZXR1cm5zIHRoZSBydW50aW1lIGNvdW50ZXJwYXJ0LCB3aGljaCBpcyBhIGZ1bGx5IGZ1bmN0aW9uYWwgY2xhc3MuXHJcbiAgICAgICAgICAgICAqIEBzZWUgUHJvdG9CdWYuQnVpbGRlci5TZXJ2aWNlXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IHJlYnVpbGQgV2hldGhlciB0byByZWJ1aWxkIG9yIG5vdFxyXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gU2VydmljZSBjbGFzc1xyXG4gICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIG1lc3NhZ2UgY2Fubm90IGJlIGJ1aWx0XHJcbiAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFNlcnZpY2UucHJvdG90eXBlLmJ1aWxkID0gZnVuY3Rpb24ocmVidWlsZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2xhenogJiYgIXJlYnVpbGQpIHJldHVybiB0aGlzLmNsYXp6O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xhenogPSAoZnVuY3Rpb24oUHJvdG9CdWYsIFQpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICogQ29uc3RydWN0cyBhIG5ldyBydW50aW1lIFNlcnZpY2UuXHJcbiAgICAgICAgICAgICAgICAgICAgICogQG5hbWUgUHJvdG9CdWYuQnVpbGRlci5TZXJ2aWNlXHJcbiAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtmdW5jdGlvbihzdHJpbmcsIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZSwgZnVuY3Rpb24oRXJyb3IsIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZT0pKT19IHJwY0ltcGwgUlBDIGltcGxlbWVudGF0aW9uIHJlY2VpdmluZyB0aGUgbWV0aG9kIG5hbWUgYW5kIHRoZSBtZXNzYWdlXHJcbiAgICAgICAgICAgICAgICAgICAgICogQGNsYXNzIEJhcmVib25lIG9mIGFsbCBydW50aW1lIHNlcnZpY2VzLlxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICAgICAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgc2VydmljZSBjYW5ub3QgYmUgY3JlYXRlZFxyXG4gICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBTZXJ2aWNlID0gZnVuY3Rpb24ocnBjSW1wbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBQcm90b0J1Zi5CdWlsZGVyLlNlcnZpY2UuY2FsbCh0aGlzKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBTZXJ2aWNlIGltcGxlbWVudGF0aW9uLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAbmFtZSBQcm90b0J1Zi5CdWlsZGVyLlNlcnZpY2UjcnBjSW1wbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAdHlwZSB7IWZ1bmN0aW9uKHN0cmluZywgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlLCBmdW5jdGlvbihFcnJvciwgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlPSkpfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJwY0ltcGwgPSBycGNJbXBsIHx8IGZ1bmN0aW9uKG5hbWUsIG1zZywgY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgd2hhdCBhIHVzZXIgaGFzIHRvIGltcGxlbWVudDogQSBmdW5jdGlvbiByZWNlaXZpbmcgdGhlIG1ldGhvZCBuYW1lLCB0aGUgYWN0dWFsIG1lc3NhZ2UgdG9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNlbmQgKHR5cGUgY2hlY2tlZCkgYW5kIHRoZSBjYWxsYmFjayB0aGF0J3MgZWl0aGVyIHByb3ZpZGVkIHdpdGggdGhlIGVycm9yIGFzIGl0cyBmaXJzdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXJndW1lbnQgb3IgbnVsbCBhbmQgdGhlIGFjdHVhbCByZXNwb25zZSBtZXNzYWdlLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChjYWxsYmFjay5iaW5kKHRoaXMsIEVycm9yKFwiTm90IGltcGxlbWVudGVkLCBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9kY29kZUlPL1Byb3RvQnVmLmpzL3dpa2kvU2VydmljZXNcIikpLCAwKTsgLy8gTXVzdCBiZSBhc3luYyFcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBFeHRlbmRzIFByb3RvQnVmLkJ1aWxkZXIuU2VydmljZVxyXG4gICAgICAgICAgICAgICAgICAgIFNlcnZpY2UucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShQcm90b0J1Zi5CdWlsZGVyLlNlcnZpY2UucHJvdG90eXBlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNlcnZpY2UsIFwiJG9wdGlvbnNcIiwgeyBcInZhbHVlXCI6IFQuYnVpbGRPcHQoKSB9KSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNlcnZpY2UucHJvdG90eXBlLCBcIiRvcHRpb25zXCIsIHsgXCJ2YWx1ZVwiOiBTZXJ2aWNlW1wiJG9wdGlvbnNcIl0gfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAqIEFzeW5jaHJvbm91c2x5IHBlcmZvcm1zIGFuIFJQQyBjYWxsIHVzaW5nIHRoZSBnaXZlbiBSUEMgaW1wbGVtZW50YXRpb24uXHJcbiAgICAgICAgICAgICAgICAgICAgICogQG5hbWUgUHJvdG9CdWYuQnVpbGRlci5TZXJ2aWNlLltNZXRob2RdXHJcbiAgICAgICAgICAgICAgICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHshZnVuY3Rpb24oc3RyaW5nLCBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UsIGZ1bmN0aW9uKEVycm9yLCBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2U9KSl9IHJwY0ltcGwgUlBDIGltcGxlbWVudGF0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2V9IHJlcSBSZXF1ZXN0XHJcbiAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtmdW5jdGlvbihFcnJvciwgKFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZXxCeXRlQnVmZmVyfEJ1ZmZlcnxzdHJpbmcpPSl9IGNhbGxiYWNrIENhbGxiYWNrIHJlY2VpdmluZ1xyXG4gICAgICAgICAgICAgICAgICAgICAqICB0aGUgZXJyb3IgaWYgYW55IGFuZCB0aGUgcmVzcG9uc2UgZWl0aGVyIGFzIGEgcHJlLXBhcnNlZCBtZXNzYWdlIG9yIGFzIGl0cyByYXcgYnl0ZXNcclxuICAgICAgICAgICAgICAgICAgICAgKiBAYWJzdHJhY3RcclxuICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICogQXN5bmNocm9ub3VzbHkgcGVyZm9ybXMgYW4gUlBDIGNhbGwgdXNpbmcgdGhlIGluc3RhbmNlJ3MgUlBDIGltcGxlbWVudGF0aW9uLlxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBuYW1lIFByb3RvQnVmLkJ1aWxkZXIuU2VydmljZSNbTWV0aG9kXVxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7UHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlfSByZXEgUmVxdWVzdFxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIChQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2V8Qnl0ZUJ1ZmZlcnxCdWZmZXJ8c3RyaW5nKT0pfSBjYWxsYmFjayBDYWxsYmFjayByZWNlaXZpbmdcclxuICAgICAgICAgICAgICAgICAgICAgKiAgdGhlIGVycm9yIGlmIGFueSBhbmQgdGhlIHJlc3BvbnNlIGVpdGhlciBhcyBhIHByZS1wYXJzZWQgbWVzc2FnZSBvciBhcyBpdHMgcmF3IGJ5dGVzXHJcbiAgICAgICAgICAgICAgICAgICAgICogQGFic3RyYWN0XHJcbiAgICAgICAgICAgICAgICAgICAgICovXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBycGMgPSBULmdldENoaWxkcmVuKFByb3RvQnVmLlJlZmxlY3QuU2VydmljZS5SUENNZXRob2QpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGk9MDsgaTxycGMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgKGZ1bmN0aW9uKG1ldGhvZCkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNlcnZpY2UjTWV0aG9kKG1lc3NhZ2UsIGNhbGxiYWNrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgU2VydmljZS5wcm90b3R5cGVbbWV0aG9kLm5hbWVdID0gZnVuY3Rpb24ocmVxLCBjYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcmVxIHx8ICEocmVxIGluc3RhbmNlb2YgbWV0aG9kLnJlc29sdmVkUmVxdWVzdFR5cGUuY2xhenopKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGNhbGxiYWNrLmJpbmQodGhpcywgRXJyb3IoXCJJbGxlZ2FsIHJlcXVlc3QgdHlwZSBwcm92aWRlZCB0byBzZXJ2aWNlIG1ldGhvZCBcIitULm5hbWUrXCIjXCIrbWV0aG9kLm5hbWUpKSwgMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ycGNJbXBsKG1ldGhvZC5mcW4oKSwgcmVxLCBmdW5jdGlvbihlcnIsIHJlcykgeyAvLyBBc3N1bWVzIHRoYXQgdGhpcyBpcyBwcm9wZXJseSBhc3luY1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHsgcmVzID0gbWV0aG9kLnJlc29sdmVkUmVzcG9uc2VUeXBlLmNsYXp6LmRlY29kZShyZXMpOyB9IGNhdGNoIChub3RBQnVmZmVyKSB7fVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXMgfHwgIShyZXMgaW5zdGFuY2VvZiBtZXRob2QucmVzb2x2ZWRSZXNwb25zZVR5cGUuY2xhenopKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soRXJyb3IoXCJJbGxlZ2FsIHJlc3BvbnNlIHR5cGUgcmVjZWl2ZWQgaW4gc2VydmljZSBtZXRob2QgXCIrIFQubmFtZStcIiNcIittZXRob2QubmFtZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHJlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGNhbGxiYWNrLmJpbmQodGhpcywgZXJyKSwgMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTZXJ2aWNlLk1ldGhvZChycGNJbXBsLCBtZXNzYWdlLCBjYWxsYmFjaylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNlcnZpY2VbbWV0aG9kLm5hbWVdID0gZnVuY3Rpb24ocnBjSW1wbCwgcmVxLCBjYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBTZXJ2aWNlKHJwY0ltcGwpW21ldGhvZC5uYW1lXShyZXEsIGNhbGxiYWNrKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2VydmljZVttZXRob2QubmFtZV0sIFwiJG9wdGlvbnNcIiwgeyBcInZhbHVlXCI6IG1ldGhvZC5idWlsZE9wdCgpIH0pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTZXJ2aWNlLnByb3RvdHlwZVttZXRob2QubmFtZV0sIFwiJG9wdGlvbnNcIiwgeyBcInZhbHVlXCI6IFNlcnZpY2VbbWV0aG9kLm5hbWVdW1wiJG9wdGlvbnNcIl0gfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKHJwY1tpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gU2VydmljZTtcclxuXHJcbiAgICAgICAgICAgICAgICB9KShQcm90b0J1ZiwgdGhpcyk7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQGFsaWFzIFByb3RvQnVmLlJlZmxlY3QuU2VydmljZVxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBSZWZsZWN0LlNlcnZpY2UgPSBTZXJ2aWNlO1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEFic3RyYWN0IHNlcnZpY2UgbWV0aG9kLlxyXG4gICAgICAgICAgICAgKiBAZXhwb3J0cyBQcm90b0J1Zi5SZWZsZWN0LlNlcnZpY2UuTWV0aG9kXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7IVByb3RvQnVmLlJlZmxlY3QuU2VydmljZX0gc3ZjIFNlcnZpY2VcclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgTWV0aG9kIG5hbWVcclxuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPj19IG9wdGlvbnMgT3B0aW9uc1xyXG4gICAgICAgICAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAgICAgICAgICogQGV4dGVuZHMgUHJvdG9CdWYuUmVmbGVjdC5UXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB2YXIgTWV0aG9kID0gZnVuY3Rpb24oc3ZjLCBuYW1lLCBvcHRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICBULmNhbGwodGhpcywgc3ZjLCBuYW1lKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEBvdmVycmlkZVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLmNsYXNzTmFtZSA9IFwiU2VydmljZS5NZXRob2RcIjtcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIE9wdGlvbnMuXHJcbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsICo+fVxyXG4gICAgICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLy8gRXh0ZW5kcyBUXHJcbiAgICAgICAgICAgIE1ldGhvZC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFQucHJvdG90eXBlKTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBCdWlsZHMgdGhlIG1ldGhvZCdzICckb3B0aW9ucycgcHJvcGVydHkuXHJcbiAgICAgICAgICAgICAqIEBuYW1lIFByb3RvQnVmLlJlZmxlY3QuU2VydmljZS5NZXRob2QjYnVpbGRPcHRcclxuICAgICAgICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAqIEByZXR1cm4ge09iamVjdC48c3RyaW5nLCo+fVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgTWV0aG9kLnByb3RvdHlwZS5idWlsZE9wdCA9IE5hbWVzcGFjZS5wcm90b3R5cGUuYnVpbGRPcHQ7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQGFsaWFzIFByb3RvQnVmLlJlZmxlY3QuU2VydmljZS5NZXRob2RcclxuICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgUmVmbGVjdC5TZXJ2aWNlLk1ldGhvZCA9IE1ldGhvZDtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBSUEMgc2VydmljZSBtZXRob2QuXHJcbiAgICAgICAgICAgICAqIEBleHBvcnRzIFByb3RvQnVmLlJlZmxlY3QuU2VydmljZS5SUENNZXRob2RcclxuICAgICAgICAgICAgICogQHBhcmFtIHshUHJvdG9CdWYuUmVmbGVjdC5TZXJ2aWNlfSBzdmMgU2VydmljZVxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBNZXRob2QgbmFtZVxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcmVxdWVzdCBSZXF1ZXN0IG1lc3NhZ2UgbmFtZVxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcmVzcG9uc2UgUmVzcG9uc2UgbWVzc2FnZSBuYW1lXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj49fSBvcHRpb25zIE9wdGlvbnNcclxuICAgICAgICAgICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgICAgICAgICAqIEBleHRlbmRzIFByb3RvQnVmLlJlZmxlY3QuU2VydmljZS5NZXRob2RcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHZhciBSUENNZXRob2QgPSBmdW5jdGlvbihzdmMsIG5hbWUsIHJlcXVlc3QsIHJlc3BvbnNlLCBvcHRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICBNZXRob2QuY2FsbCh0aGlzLCBzdmMsIG5hbWUsIG9wdGlvbnMpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQG92ZXJyaWRlXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuY2xhc3NOYW1lID0gXCJTZXJ2aWNlLlJQQ01ldGhvZFwiO1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogUmVxdWVzdCBtZXNzYWdlIG5hbWUuXHJcbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAgICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlcXVlc3ROYW1lID0gcmVxdWVzdDtcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFJlc3BvbnNlIG1lc3NhZ2UgbmFtZS5cclxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICAgICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMucmVzcG9uc2VOYW1lID0gcmVzcG9uc2U7XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBSZXNvbHZlZCByZXF1ZXN0IG1lc3NhZ2UgdHlwZS5cclxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtQcm90b0J1Zi5SZWZsZWN0Lk1lc3NhZ2V9XHJcbiAgICAgICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMucmVzb2x2ZWRSZXF1ZXN0VHlwZSA9IG51bGw7XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBSZXNvbHZlZCByZXNwb25zZSBtZXNzYWdlIHR5cGUuXHJcbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7UHJvdG9CdWYuUmVmbGVjdC5NZXNzYWdlfVxyXG4gICAgICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlc29sdmVkUmVzcG9uc2VUeXBlID0gbnVsbDtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8vIEV4dGVuZHMgTWV0aG9kXHJcbiAgICAgICAgICAgIFJQQ01ldGhvZC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKE1ldGhvZC5wcm90b3R5cGUpO1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEBhbGlhcyBQcm90b0J1Zi5SZWZsZWN0LlNlcnZpY2UuUlBDTWV0aG9kXHJcbiAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFJlZmxlY3QuU2VydmljZS5SUENNZXRob2QgPSBSUENNZXRob2Q7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gUmVmbGVjdDtcclxuICAgICAgICB9KShQcm90b0J1Zik7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBhbGlhcyBQcm90b0J1Zi5CdWlsZGVyXHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFByb3RvQnVmLkJ1aWxkZXIgPSAoZnVuY3Rpb24oUHJvdG9CdWYsIExhbmcsIFJlZmxlY3QpIHtcclxuICAgICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQ29uc3RydWN0cyBhIG5ldyBCdWlsZGVyLlxyXG4gICAgICAgICAgICAgKiBAZXhwb3J0cyBQcm90b0J1Zi5CdWlsZGVyXHJcbiAgICAgICAgICAgICAqIEBjbGFzcyBQcm92aWRlcyB0aGUgZnVuY3Rpb25hbGl0eSB0byBidWlsZCBwcm90b2NvbCBtZXNzYWdlcy5cclxuICAgICAgICAgICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB2YXIgQnVpbGRlciA9IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogTmFtZXNwYWNlLlxyXG4gICAgICAgICAgICAgICAgICogQHR5cGUge1Byb3RvQnVmLlJlZmxlY3QuTmFtZXNwYWNlfVxyXG4gICAgICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLm5zID0gbmV3IFJlZmxlY3QuTmFtZXNwYWNlKG51bGwsIFwiXCIpOyAvLyBHbG9iYWwgbmFtZXNwYWNlXHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBOYW1lc3BhY2UgcG9pbnRlci5cclxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtQcm90b0J1Zi5SZWZsZWN0LlR9XHJcbiAgICAgICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMucHRyID0gdGhpcy5ucztcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFJlc29sdmVkIGZsYWcuXHJcbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZXNvbHZlZCA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogVGhlIGN1cnJlbnQgYnVpbGRpbmcgcmVzdWx0LlxyXG4gICAgICAgICAgICAgICAgICogQHR5cGUge09iamVjdC48c3RyaW5nLFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZXxPYmplY3Q+fG51bGx9XHJcbiAgICAgICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMucmVzdWx0ID0gbnVsbDtcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEltcG9ydGVkIGZpbGVzLlxyXG4gICAgICAgICAgICAgICAgICogQHR5cGUge0FycmF5LjxzdHJpbmc+fVxyXG4gICAgICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLmZpbGVzID0ge307XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBJbXBvcnQgcm9vdCBvdmVycmlkZS5cclxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHs/c3RyaW5nfVxyXG4gICAgICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLmltcG9ydFJvb3QgPSBudWxsO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFJlc2V0cyB0aGUgcG9pbnRlciB0byB0aGUgcm9vdCBuYW1lc3BhY2UuXHJcbiAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEJ1aWxkZXIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnB0ciA9IHRoaXMubnM7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogRGVmaW5lcyBhIHBhY2thZ2Ugb24gdG9wIG9mIHRoZSBjdXJyZW50IHBvaW50ZXIgcG9zaXRpb24gYW5kIHBsYWNlcyB0aGUgcG9pbnRlciBvbiBpdC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHBrZ1xyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+PX0gb3B0aW9uc1xyXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHtQcm90b0J1Zi5CdWlsZGVyfSB0aGlzXHJcbiAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGFja2FnZSBuYW1lIGlzIGludmFsaWRcclxuICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQnVpbGRlci5wcm90b3R5cGUuZGVmaW5lID0gZnVuY3Rpb24ocGtnLCBvcHRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHBrZyAhPT0gJ3N0cmluZycgfHwgIUxhbmcuVFlQRVJFRi50ZXN0KHBrZykpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIHBhY2thZ2U6IFwiK3BrZyk7XHJcbiAgICAgICAgICAgICAgICB2YXIgcGFydCA9IHBrZy5zcGxpdChcIi5cIiksIGk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGk9MDsgaTxwYXJ0Lmxlbmd0aDsgaSsrKSAvLyBUbyBiZSBhYnNvbHV0ZWx5IHN1cmVcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIUxhbmcuTkFNRS50ZXN0KHBhcnRbaV0pKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIklsbGVnYWwgcGFja2FnZTogXCIrcGFydFtpXSk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGk9MDsgaTxwYXJ0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnB0ci5oYXNDaGlsZChwYXJ0W2ldKSkgLy8gS2VlcCBleGlzdGluZyBuYW1lc3BhY2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wdHIuYWRkQ2hpbGQobmV3IFJlZmxlY3QuTmFtZXNwYWNlKHRoaXMucHRyLCBwYXJ0W2ldLCBvcHRpb25zKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wdHIgPSB0aGlzLnB0ci5nZXRDaGlsZChwYXJ0W2ldKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRlc3RzIGlmIGEgZGVmaW5pdGlvbiBpcyBhIHZhbGlkIG1lc3NhZ2UgZGVmaW5pdGlvbi5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gZGVmIERlZmluaXRpb25cclxuICAgICAgICAgICAgICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiB2YWxpZCwgZWxzZSBmYWxzZVxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBCdWlsZGVyLmlzVmFsaWRNZXNzYWdlID0gZnVuY3Rpb24oZGVmKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBNZXNzYWdlcyByZXF1aXJlIGEgc3RyaW5nIG5hbWVcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZGVmW1wibmFtZVwiXSAhPT0gJ3N0cmluZycgfHwgIUxhbmcuTkFNRS50ZXN0KGRlZltcIm5hbWVcIl0pKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIC8vIE1lc3NhZ2VzIG11c3Qgbm90IGNvbnRhaW4gdmFsdWVzICh0aGF0J2QgYmUgYW4gZW51bSkgb3IgbWV0aG9kcyAodGhhdCdkIGJlIGEgc2VydmljZSlcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZGVmW1widmFsdWVzXCJdICE9PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgZGVmW1wicnBjXCJdICE9PSAndW5kZWZpbmVkJylcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAvLyBGaWVsZHMsIGVudW1zIGFuZCBtZXNzYWdlcyBhcmUgYXJyYXlzIGlmIHByb3ZpZGVkXHJcbiAgICAgICAgICAgICAgICB2YXIgaTtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZGVmW1wiZmllbGRzXCJdICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghUHJvdG9CdWYuVXRpbC5pc0FycmF5KGRlZltcImZpZWxkc1wiXSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaWRzID0gW10sIGlkOyAvLyBJRHMgbXVzdCBiZSB1bmlxdWVcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGk9MDsgaTxkZWZbXCJmaWVsZHNcIl0ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFCdWlsZGVyLmlzVmFsaWRNZXNzYWdlRmllbGQoZGVmW1wiZmllbGRzXCJdW2ldKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWQgPSBwYXJzZUludChkZWZbXCJmaWVsZHNcIl1baV1bXCJpZFwiXSwgMTApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaWRzLmluZGV4T2YoaWQpID49IDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkcy5wdXNoKGlkKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWRzID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZGVmW1wiZW51bXNcIl0gIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFQcm90b0J1Zi5VdGlsLmlzQXJyYXkoZGVmW1wiZW51bXNcIl0pKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpPTA7IGk8ZGVmW1wiZW51bXNcIl0ubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghQnVpbGRlci5pc1ZhbGlkRW51bShkZWZbXCJlbnVtc1wiXVtpXSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGRlZltcIm1lc3NhZ2VzXCJdICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghUHJvdG9CdWYuVXRpbC5pc0FycmF5KGRlZltcIm1lc3NhZ2VzXCJdKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaT0wOyBpPGRlZltcIm1lc3NhZ2VzXCJdLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIUJ1aWxkZXIuaXNWYWxpZE1lc3NhZ2UoZGVmW1wibWVzc2FnZXNcIl1baV0pICYmICFCdWlsZGVyLmlzVmFsaWRFeHRlbmQoZGVmW1wibWVzc2FnZXNcIl1baV0pKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkZWZbXCJleHRlbnNpb25zXCJdICE9PSAndW5kZWZpbmVkJylcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIVByb3RvQnVmLlV0aWwuaXNBcnJheShkZWZbXCJleHRlbnNpb25zXCJdKSB8fCBkZWZbXCJleHRlbnNpb25zXCJdLmxlbmd0aCAhPT0gMiB8fCB0eXBlb2YgZGVmW1wiZXh0ZW5zaW9uc1wiXVswXSAhPT0gJ251bWJlcicgfHwgdHlwZW9mIGRlZltcImV4dGVuc2lvbnNcIl1bMV0gIT09ICdudW1iZXInKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUZXN0cyBpZiBhIGRlZmluaXRpb24gaXMgYSB2YWxpZCBtZXNzYWdlIGZpZWxkIGRlZmluaXRpb24uXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkZWYgRGVmaW5pdGlvblxyXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIHZhbGlkLCBlbHNlIGZhbHNlXHJcbiAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEJ1aWxkZXIuaXNWYWxpZE1lc3NhZ2VGaWVsZCA9IGZ1bmN0aW9uKGRlZikge1xyXG4gICAgICAgICAgICAgICAgLy8gTWVzc2FnZSBmaWVsZHMgcmVxdWlyZSBhIHN0cmluZyBydWxlLCBuYW1lIGFuZCB0eXBlIGFuZCBhbiBpZFxyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkZWZbXCJydWxlXCJdICE9PSAnc3RyaW5nJyB8fCB0eXBlb2YgZGVmW1wibmFtZVwiXSAhPT0gJ3N0cmluZycgfHwgdHlwZW9mIGRlZltcInR5cGVcIl0gIT09ICdzdHJpbmcnIHx8IHR5cGVvZiBkZWZbXCJpZFwiXSA9PT0gJ3VuZGVmaW5lZCcpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFMYW5nLlJVTEUudGVzdChkZWZbXCJydWxlXCJdKSB8fCAhTGFuZy5OQU1FLnRlc3QoZGVmW1wibmFtZVwiXSkgfHwgIUxhbmcuVFlQRVJFRi50ZXN0KGRlZltcInR5cGVcIl0pIHx8ICFMYW5nLklELnRlc3QoXCJcIitkZWZbXCJpZFwiXSkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkZWZbXCJvcHRpb25zXCJdICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIE9wdGlvbnMgYXJlIG9iamVjdHNcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGRlZltcIm9wdGlvbnNcIl0gIT09ICdvYmplY3QnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gT3B0aW9ucyBhcmUgPHN0cmluZyxzdHJpbmd8bnVtYmVyfGJvb2xlYW4+XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhkZWZbXCJvcHRpb25zXCJdKTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpPTAsIGtleTsgaTxrZXlzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChrZXkgPSBrZXlzW2ldKSAhPT0gJ3N0cmluZycgfHwgKHR5cGVvZiBkZWZbXCJvcHRpb25zXCJdW2tleV0gIT09ICdzdHJpbmcnICYmIHR5cGVvZiBkZWZbXCJvcHRpb25zXCJdW2tleV0gIT09ICdudW1iZXInICYmIHR5cGVvZiBkZWZbXCJvcHRpb25zXCJdW2tleV0gIT09ICdib29sZWFuJykpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUZXN0cyBpZiBhIGRlZmluaXRpb24gaXMgYSB2YWxpZCBlbnVtIGRlZmluaXRpb24uXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkZWYgRGVmaW5pdGlvblxyXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIHZhbGlkLCBlbHNlIGZhbHNlXHJcbiAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEJ1aWxkZXIuaXNWYWxpZEVudW0gPSBmdW5jdGlvbihkZWYpIHtcclxuICAgICAgICAgICAgICAgIC8vIEVudW1zIHJlcXVpcmUgYSBzdHJpbmcgbmFtZVxyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkZWZbXCJuYW1lXCJdICE9PSAnc3RyaW5nJyB8fCAhTGFuZy5OQU1FLnRlc3QoZGVmW1wibmFtZVwiXSkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgLy8gRW51bXMgcmVxdWlyZSBhdCBsZWFzdCBvbmUgdmFsdWVcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZGVmW1widmFsdWVzXCJdID09PSAndW5kZWZpbmVkJyB8fCAhUHJvdG9CdWYuVXRpbC5pc0FycmF5KGRlZltcInZhbHVlc1wiXSkgfHwgZGVmW1widmFsdWVzXCJdLmxlbmd0aCA9PSAwKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGk9MDsgaTxkZWZbXCJ2YWx1ZXNcIl0ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBWYWx1ZXMgYXJlIG9iamVjdHNcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGRlZltcInZhbHVlc1wiXVtpXSAhPSBcIm9iamVjdFwiKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVmFsdWVzIHJlcXVpcmUgYSBzdHJpbmcgbmFtZSBhbmQgYW4gaWRcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGRlZltcInZhbHVlc1wiXVtpXVtcIm5hbWVcIl0gIT09ICdzdHJpbmcnIHx8IHR5cGVvZiBkZWZbXCJ2YWx1ZXNcIl1baV1bXCJpZFwiXSA9PT0gJ3VuZGVmaW5lZCcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIUxhbmcuTkFNRS50ZXN0KGRlZltcInZhbHVlc1wiXVtpXVtcIm5hbWVcIl0pIHx8ICFMYW5nLk5FR0lELnRlc3QoXCJcIitkZWZbXCJ2YWx1ZXNcIl1baV1bXCJpZFwiXSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIEl0J3Mgbm90IGltcG9ydGFudCBpZiB0aGVyZSBhcmUgb3RoZXIgZmllbGRzIGJlY2F1c2UgW1widmFsdWVzXCJdIGlzIGFscmVhZHkgdW5pcXVlXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBDcmVhdGVzIHRocyBzcGVjaWZpZWQgcHJvdG9jb2wgdHlwZXMgYXQgdGhlIGN1cnJlbnQgcG9pbnRlciBwb3NpdGlvbi5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtBcnJheS48T2JqZWN0LjxzdHJpbmcsKj4+fSBkZWZzIE1lc3NhZ2VzLCBlbnVtcyBvciBzZXJ2aWNlcyB0byBjcmVhdGVcclxuICAgICAgICAgICAgICogQHJldHVybiB7UHJvdG9CdWYuQnVpbGRlcn0gdGhpc1xyXG4gICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgYSBtZXNzYWdlIGRlZmluaXRpb24gaXMgaW52YWxpZFxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBCdWlsZGVyLnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbihkZWZzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWRlZnMpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7IC8vIE5vdGhpbmcgdG8gY3JlYXRlXHJcbiAgICAgICAgICAgICAgICBpZiAoIVByb3RvQnVmLlV0aWwuaXNBcnJheShkZWZzKSlcclxuICAgICAgICAgICAgICAgICAgICBkZWZzID0gW2RlZnNdO1xyXG4gICAgICAgICAgICAgICAgaWYgKGRlZnMubGVuZ3RoID09IDApXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSXQncyBxdWl0ZSBoYXJkIHRvIGtlZXAgdHJhY2sgb2Ygc2NvcGVzIGFuZCBtZW1vcnkgaGVyZSwgc28gbGV0J3MgZG8gdGhpcyBpdGVyYXRpdmVseS5cclxuICAgICAgICAgICAgICAgIHZhciBzdGFjayA9IFtdLCBkZWYsIG9iaiwgc3ViT2JqLCBpLCBqO1xyXG4gICAgICAgICAgICAgICAgc3RhY2sucHVzaChkZWZzKTsgLy8gT25lIGxldmVsIFthLCBiLCBjXVxyXG4gICAgICAgICAgICAgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWZzID0gc3RhY2sucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKFByb3RvQnVmLlV0aWwuaXNBcnJheShkZWZzKSkgeyAvLyBTdGFjayBhbHdheXMgY29udGFpbnMgZW50aXJlIG5hbWVzcGFjZXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGRlZnMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmID0gZGVmcy5zaGlmdCgpOyAvLyBOYW1lc3BhY2UgYWx3YXlzIGNvbnRhaW5zIGFuIGFycmF5IG9mIG1lc3NhZ2VzLCBlbnVtcyBhbmQgc2VydmljZXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChCdWlsZGVyLmlzVmFsaWRNZXNzYWdlKGRlZikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmogPSBuZXcgUmVmbGVjdC5NZXNzYWdlKHRoaXMucHRyLCBkZWZbXCJuYW1lXCJdLCBkZWZbXCJvcHRpb25zXCJdLCBkZWZbXCJpc0dyb3VwXCJdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDcmVhdGUgZmllbGRzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlZltcImZpZWxkc1wiXSAmJiBkZWZbXCJmaWVsZHNcIl0ubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGk9MDsgaTxkZWZbXCJmaWVsZHNcIl0ubGVuZ3RoOyBpKyspIHsgLy8gaT1GaWVsZHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvYmouaGFzQ2hpbGQoZGVmWydmaWVsZHMnXVtpXVsnaWQnXSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJEdXBsaWNhdGUgZmllbGQgaWQgaW4gbWVzc2FnZSBcIitvYmoubmFtZStcIjogXCIrZGVmWydmaWVsZHMnXVtpXVsnaWQnXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVmW1wiZmllbGRzXCJdW2ldW1wib3B0aW9uc1wiXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Yk9iaiA9IE9iamVjdC5rZXlzKGRlZltcImZpZWxkc1wiXVtpXVtcIm9wdGlvbnNcIl0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaj0wOyBqPHN1Yk9iai5sZW5ndGg7IGorKykgeyAvLyBqPU9wdGlvbiBuYW1lc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHN1Yk9ialtqXSAhPT0gJ3N0cmluZycpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIklsbGVnYWwgZmllbGQgb3B0aW9uIG5hbWUgaW4gbWVzc2FnZSBcIitvYmoubmFtZStcIiNcIitkZWZbXCJmaWVsZHNcIl1baV1bXCJuYW1lXCJdK1wiOiBcIitzdWJPYmpbal0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGRlZltcImZpZWxkc1wiXVtpXVtcIm9wdGlvbnNcIl1bc3ViT2JqW2pdXSAhPT0gJ3N0cmluZycgJiYgdHlwZW9mIGRlZltcImZpZWxkc1wiXVtpXVtcIm9wdGlvbnNcIl1bc3ViT2JqW2pdXSAhPT0gJ251bWJlcicgJiYgdHlwZW9mIGRlZltcImZpZWxkc1wiXVtpXVtcIm9wdGlvbnNcIl1bc3ViT2JqW2pdXSAhPT0gJ2Jvb2xlYW4nKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIGZpZWxkIG9wdGlvbiB2YWx1ZSBpbiBtZXNzYWdlIFwiK29iai5uYW1lK1wiI1wiK2RlZltcImZpZWxkc1wiXVtpXVtcIm5hbWVcIl0rXCIjXCIrc3ViT2JqW2pdK1wiOiBcIitkZWZbXCJmaWVsZHNcIl1baV1bXCJvcHRpb25zXCJdW3N1Yk9ialtqXV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJPYmogPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqLmFkZENoaWxkKG5ldyBSZWZsZWN0Lk1lc3NhZ2UuRmllbGQob2JqLCBkZWZbXCJmaWVsZHNcIl1baV1bXCJydWxlXCJdLCBkZWZbXCJmaWVsZHNcIl1baV1bXCJ0eXBlXCJdLCBkZWZbXCJmaWVsZHNcIl1baV1bXCJuYW1lXCJdLCBkZWZbXCJmaWVsZHNcIl1baV1bXCJpZFwiXSwgZGVmW1wiZmllbGRzXCJdW2ldW1wib3B0aW9uc1wiXSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFB1c2ggZW51bXMgYW5kIG1lc3NhZ2VzIHRvIHN0YWNrXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViT2JqID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkZWZbXCJlbnVtc1wiXSAhPT0gJ3VuZGVmaW5lZCcgJiYgZGVmWydlbnVtcyddLmxlbmd0aCA+IDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaT0wOyBpPGRlZltcImVudW1zXCJdLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViT2JqLnB1c2goZGVmW1wiZW51bXNcIl1baV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWZbXCJtZXNzYWdlc1wiXSAmJiBkZWZbXCJtZXNzYWdlc1wiXS5sZW5ndGggPiAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGk9MDsgaTxkZWZbXCJtZXNzYWdlc1wiXS5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Yk9iai5wdXNoKGRlZltcIm1lc3NhZ2VzXCJdW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTZXQgZXh0ZW5zaW9uIHJhbmdlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlZltcImV4dGVuc2lvbnNcIl0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqLmV4dGVuc2lvbnMgPSBkZWZbXCJleHRlbnNpb25zXCJdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob2JqLmV4dGVuc2lvbnNbMF0gPCBQcm90b0J1Zi5JRF9NSU4pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmouZXh0ZW5zaW9uc1swXSA9IFByb3RvQnVmLklEX01JTjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9iai5leHRlbnNpb25zWzFdID4gUHJvdG9CdWYuSURfTUFYKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqLmV4dGVuc2lvbnNbMV0gPSBQcm90b0J1Zi5JRF9NQVg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHRyLmFkZENoaWxkKG9iaik7IC8vIEFkZCB0byBjdXJyZW50IG5hbWVzcGFjZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdWJPYmoubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKGRlZnMpOyAvLyBQdXNoIHRoZSBjdXJyZW50IGxldmVsIGJhY2tcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmcyA9IHN1Yk9iajsgLy8gQ29udGludWUgcHJvY2Vzc2luZyBzdWIgbGV2ZWxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViT2JqID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wdHIgPSBvYmo7IC8vIEFuZCBtb3ZlIHRoZSBwb2ludGVyIHRvIHRoaXMgbmFtZXNwYWNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iaiA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJPYmogPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iaiA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKEJ1aWxkZXIuaXNWYWxpZEVudW0oZGVmKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iaiA9IG5ldyBSZWZsZWN0LkVudW0odGhpcy5wdHIsIGRlZltcIm5hbWVcIl0sIGRlZltcIm9wdGlvbnNcIl0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaT0wOyBpPGRlZltcInZhbHVlc1wiXS5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqLmFkZENoaWxkKG5ldyBSZWZsZWN0LkVudW0uVmFsdWUob2JqLCBkZWZbXCJ2YWx1ZXNcIl1baV1bXCJuYW1lXCJdLCBkZWZbXCJ2YWx1ZXNcIl1baV1bXCJpZFwiXSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHRyLmFkZENoaWxkKG9iaik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoQnVpbGRlci5pc1ZhbGlkU2VydmljZShkZWYpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqID0gbmV3IFJlZmxlY3QuU2VydmljZSh0aGlzLnB0ciwgZGVmW1wibmFtZVwiXSwgZGVmW1wib3B0aW9uc1wiXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpIGluIGRlZltcInJwY1wiXSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlZltcInJwY1wiXS5oYXNPd25Qcm9wZXJ0eShpKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iai5hZGRDaGlsZChuZXcgUmVmbGVjdC5TZXJ2aWNlLlJQQ01ldGhvZChvYmosIGksIGRlZltcInJwY1wiXVtpXVtcInJlcXVlc3RcIl0sIGRlZltcInJwY1wiXVtpXVtcInJlc3BvbnNlXCJdLCBkZWZbXCJycGNcIl1baV1bXCJvcHRpb25zXCJdKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wdHIuYWRkQ2hpbGQob2JqKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmogPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChCdWlsZGVyLmlzVmFsaWRFeHRlbmQoZGVmKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iaiA9IHRoaXMucHRyLnJlc29sdmUoZGVmW1wicmVmXCJdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob2JqKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaT0wOyBpPGRlZltcImZpZWxkc1wiXS5sZW5ndGg7IGkrKykgeyAvLyBpPUZpZWxkc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9iai5oYXNDaGlsZChkZWZbJ2ZpZWxkcyddW2ldWydpZCddKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIkR1cGxpY2F0ZSBleHRlbmRlZCBmaWVsZCBpZCBpbiBtZXNzYWdlIFwiK29iai5uYW1lK1wiOiBcIitkZWZbJ2ZpZWxkcyddW2ldWydpZCddKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWZbJ2ZpZWxkcyddW2ldWydpZCddIDwgb2JqLmV4dGVuc2lvbnNbMF0gfHwgZGVmWydmaWVsZHMnXVtpXVsnaWQnXSA+IG9iai5leHRlbnNpb25zWzFdKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCBleHRlbmRlZCBmaWVsZCBpZCBpbiBtZXNzYWdlIFwiK29iai5uYW1lK1wiOiBcIitkZWZbJ2ZpZWxkcyddW2ldWydpZCddK1wiIChcIitvYmouZXh0ZW5zaW9ucy5qb2luKCcgdG8gJykrXCIgZXhwZWN0ZWQpXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogU2VlICMxNjFcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIHN1Yk9iaiA9IG5ldyAodGhpcy5wdHIgaW5zdGFuY2VvZiBSZWZsZWN0Lk1lc3NhZ2UgPyBSZWZsZWN0Lk1lc3NhZ2UuRXh0ZW5zaW9uRmllbGQgOiBSZWZsZWN0Lk1lc3NhZ2UuRmllbGQpKG9iaiwgZGVmW1wiZmllbGRzXCJdW2ldW1wicnVsZVwiXSwgZGVmW1wiZmllbGRzXCJdW2ldW1widHlwZVwiXSwgZGVmW1wiZmllbGRzXCJdW2ldW1wibmFtZVwiXSwgZGVmW1wiZmllbGRzXCJdW2ldW1wiaWRcIl0sIGRlZltcImZpZWxkc1wiXVtpXVtcIm9wdGlvbnNcIl0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucHRyIGluc3RhbmNlb2YgUmVmbGVjdC5NZXNzYWdlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHRyLmFkZENoaWxkKHN1Yk9iaik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqLmFkZENoaWxkKHN1Yk9iaik7ICovXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmouYWRkQ2hpbGQobmV3IFJlZmxlY3QuTWVzc2FnZS5GaWVsZChvYmosIGRlZltcImZpZWxkc1wiXVtpXVtcInJ1bGVcIl0sIGRlZltcImZpZWxkc1wiXVtpXVtcInR5cGVcIl0sIGRlZltcImZpZWxkc1wiXVtpXVtcIm5hbWVcIl0sIGRlZltcImZpZWxkc1wiXVtpXVtcImlkXCJdLCBkZWZbXCJmaWVsZHNcIl1baV1bXCJvcHRpb25zXCJdKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCEvXFwuP2dvb2dsZVxcLnByb3RvYnVmXFwuLy50ZXN0KGRlZltcInJlZlwiXSkpIC8vIFNpbGVudGx5IHNraXAgaW50ZXJuYWwgZXh0ZW5zaW9uc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIkV4dGVuZGVkIG1lc3NhZ2UgXCIrZGVmW1wicmVmXCJdK1wiIGlzIG5vdCBkZWZpbmVkXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJOb3QgYSB2YWxpZCBkZWZpbml0aW9uOiBcIitKU09OLnN0cmluZ2lmeShkZWYpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZiA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQnJlYWsgZ29lcyBoZXJlXHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiTm90IGEgdmFsaWQgbmFtZXNwYWNlOiBcIitKU09OLnN0cmluZ2lmeShkZWZzKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmcyA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wdHIgPSB0aGlzLnB0ci5wYXJlbnQ7IC8vIFRoaXMgbmFtZXNwYWNlIGlzIHMgZG9uZVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5yZXNvbHZlZCA9IGZhbHNlOyAvLyBSZXF1aXJlIHJlLXJlc29sdmVcclxuICAgICAgICAgICAgICAgIHRoaXMucmVzdWx0ID0gbnVsbDsgLy8gUmVxdWlyZSByZS1idWlsZFxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogSW1wb3J0cyBhbm90aGVyIGRlZmluaXRpb24gaW50byB0aGlzIGJ1aWxkZXIuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IGpzb24gUGFyc2VkIGltcG9ydFxyXG4gICAgICAgICAgICAgKiBAcGFyYW0geyhzdHJpbmd8e3Jvb3Q6IHN0cmluZywgZmlsZTogc3RyaW5nfSk9fSBmaWxlbmFtZSBJbXBvcnRlZCBmaWxlIG5hbWVcclxuICAgICAgICAgICAgICogQHJldHVybiB7UHJvdG9CdWYuQnVpbGRlcn0gdGhpc1xyXG4gICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGRlZmluaXRpb24gb3IgZmlsZSBjYW5ub3QgYmUgaW1wb3J0ZWRcclxuICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQnVpbGRlci5wcm90b3R5cGVbXCJpbXBvcnRcIl0gPSBmdW5jdGlvbihqc29uLCBmaWxlbmFtZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmaWxlbmFtZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoUHJvdG9CdWYuVXRpbC5JU19OT0RFKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxlbmFtZSA9IHJlcXVpcmUoXCJwYXRoXCIpWydyZXNvbHZlJ10oZmlsZW5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmZpbGVzW2ZpbGVuYW1lXSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc2V0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzOyAvLyBTa2lwIGR1cGxpY2F0ZSBpbXBvcnRzXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlsZXNbZmlsZW5hbWVdID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICghIWpzb25bJ2ltcG9ydHMnXSAmJiBqc29uWydpbXBvcnRzJ10ubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbXBvcnRSb290LCBkZWxpbSA9ICcvJywgcmVzZXRSb290ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmaWxlbmFtZSA9PT0gJ29iamVjdCcpIHsgLy8gSWYgYW4gaW1wb3J0IHJvb3QgaXMgc3BlY2lmaWVkLCBvdmVycmlkZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmltcG9ydFJvb3QgPSBmaWxlbmFtZVtcInJvb3RcIl07IHJlc2V0Um9vdCA9IHRydWU7IC8vIC4uLiBhbmQgcmVzZXQgYWZ0ZXJ3YXJkc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbXBvcnRSb290ID0gdGhpcy5pbXBvcnRSb290O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxlbmFtZSA9IGZpbGVuYW1lW1wiZmlsZVwiXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGltcG9ydFJvb3QuaW5kZXhPZihcIlxcXFxcIikgPj0gMCB8fCBmaWxlbmFtZS5pbmRleE9mKFwiXFxcXFwiKSA+PSAwKSBkZWxpbSA9ICdcXFxcJztcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBmaWxlbmFtZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaW1wb3J0Um9vdCkgLy8gSWYgaW1wb3J0IHJvb3QgaXMgb3ZlcnJpZGRlbiwgdXNlIGl0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbXBvcnRSb290ID0gdGhpcy5pbXBvcnRSb290O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHsgLy8gT3RoZXJ3aXNlIGNvbXB1dGUgZnJvbSBmaWxlbmFtZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpbGVuYW1lLmluZGV4T2YoXCIvXCIpID49IDApIHsgLy8gVW5peFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltcG9ydFJvb3QgPSBmaWxlbmFtZS5yZXBsYWNlKC9cXC9bXlxcL10qJC8sIFwiXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgvKiAvZmlsZS5wcm90byAqLyBpbXBvcnRSb290ID09PSBcIlwiKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbXBvcnRSb290ID0gXCIvXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGZpbGVuYW1lLmluZGV4T2YoXCJcXFxcXCIpID49IDApIHsgLy8gV2luZG93c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltcG9ydFJvb3QgPSBmaWxlbmFtZS5yZXBsYWNlKC9cXFxcW15cXFxcXSokLywgXCJcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsaW0gPSAnXFxcXCc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbXBvcnRSb290ID0gXCIuXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW1wb3J0Um9vdCA9IG51bGw7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGk9MDsgaTxqc29uWydpbXBvcnRzJ10ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBqc29uWydpbXBvcnRzJ11baV0gPT09ICdzdHJpbmcnKSB7IC8vIEltcG9ydCBmaWxlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWltcG9ydFJvb3QpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJDYW5ub3QgZGV0ZXJtaW5lIGltcG9ydCByb290OiBGaWxlIG5hbWUgaXMgdW5rbm93blwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbXBvcnRGaWxlbmFtZSA9IGpzb25bJ2ltcG9ydHMnXVtpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgvXmdvb2dsZVxcL3Byb3RvYnVmXFwvLy50ZXN0KGltcG9ydEZpbGVuYW1lKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTsgLy8gTm90IG5lZWRlZCBhbmQgdGhlcmVmb3JlIG5vdCB1c2VkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbXBvcnRGaWxlbmFtZSA9IGltcG9ydFJvb3QrZGVsaW0raW1wb3J0RmlsZW5hbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5maWxlc1tpbXBvcnRGaWxlbmFtZV0gPT09IHRydWUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7IC8vIEFscmVhZHkgaW1wb3J0ZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgvXFwucHJvdG8kL2kudGVzdChpbXBvcnRGaWxlbmFtZSkgJiYgIVByb3RvQnVmLkRvdFByb3RvKSAgICAgLy8gSWYgdGhpcyBpcyBhIE5PUEFSU0UgYnVpbGRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbXBvcnRGaWxlbmFtZSA9IGltcG9ydEZpbGVuYW1lLnJlcGxhY2UoL1xcLnByb3RvJC8sIFwiLmpzb25cIik7IC8vIGFsd2F5cyBsb2FkIHRoZSBKU09OIGZpbGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb250ZW50cyA9IFByb3RvQnVmLlV0aWwuZmV0Y2goaW1wb3J0RmlsZW5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRlbnRzID09PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiRmFpbGVkIHRvIGltcG9ydCAnXCIraW1wb3J0RmlsZW5hbWUrXCInIGluICdcIitmaWxlbmFtZStcIic6IEZpbGUgbm90IGZvdW5kXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKC9cXC5qc29uJC9pLnRlc3QoaW1wb3J0RmlsZW5hbWUpKSAvLyBBbHdheXMgcG9zc2libGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW1wiaW1wb3J0XCJdKEpTT04ucGFyc2UoY29udGVudHMrXCJcIiksIGltcG9ydEZpbGVuYW1lKTsgLy8gTWF5IHRocm93XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1tcImltcG9ydFwiXSgobmV3IFByb3RvQnVmLkRvdFByb3RvLlBhcnNlcihjb250ZW50cytcIlwiKSkucGFyc2UoKSwgaW1wb3J0RmlsZW5hbWUpOyAvLyBNYXkgdGhyb3dcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIC8vIEltcG9ydCBzdHJ1Y3R1cmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZmlsZW5hbWUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1tcImltcG9ydFwiXShqc29uWydpbXBvcnRzJ11baV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoL1xcLihcXHcrKSQvLnRlc3QoZmlsZW5hbWUpKSAvLyBXaXRoIGV4dGVuc2lvbjogQXBwZW5kIF9pbXBvcnROIHRvIHRoZSBuYW1lIHBvcnRpb24gdG8gbWFrZSBpdCB1bmlxdWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW1wiaW1wb3J0XCJdKGpzb25bJ2ltcG9ydHMnXVtpXSwgZmlsZW5hbWUucmVwbGFjZSgvXiguKylcXC4oXFx3KykkLywgZnVuY3Rpb24oJDAsICQxLCAkMikgeyByZXR1cm4gJDErXCJfaW1wb3J0XCIraStcIi5cIiskMjsgfSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSAvLyBXaXRob3V0IGV4dGVuc2lvbjogQXBwZW5kIF9pbXBvcnROIHRvIG1ha2UgaXQgdW5pcXVlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1tcImltcG9ydFwiXShqc29uWydpbXBvcnRzJ11baV0sIGZpbGVuYW1lK1wiX2ltcG9ydFwiK2kpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzZXRSb290KSAvLyBSZXNldCBpbXBvcnQgcm9vdCBvdmVycmlkZSB3aGVuIGFsbCBpbXBvcnRzIGFyZSBkb25lXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW1wb3J0Um9vdCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoanNvblsnbWVzc2FnZXMnXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChqc29uWydwYWNrYWdlJ10pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVmaW5lKGpzb25bJ3BhY2thZ2UnXSwganNvbltcIm9wdGlvbnNcIl0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlKGpzb25bJ21lc3NhZ2VzJ10pO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChqc29uWydlbnVtcyddKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGpzb25bJ3BhY2thZ2UnXSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWZpbmUoanNvblsncGFja2FnZSddLCBqc29uW1wib3B0aW9uc1wiXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jcmVhdGUoanNvblsnZW51bXMnXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGpzb25bJ3NlcnZpY2VzJ10pIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoanNvblsncGFja2FnZSddKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRlZmluZShqc29uWydwYWNrYWdlJ10sIGpzb25bXCJvcHRpb25zXCJdKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZShqc29uWydzZXJ2aWNlcyddKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc2V0KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoanNvblsnZXh0ZW5kcyddKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGpzb25bJ3BhY2thZ2UnXSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWZpbmUoanNvblsncGFja2FnZSddLCBqc29uW1wib3B0aW9uc1wiXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jcmVhdGUoanNvblsnZXh0ZW5kcyddKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc2V0KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUZXN0cyBpZiBhIGRlZmluaXRpb24gaXMgYSB2YWxpZCBzZXJ2aWNlIGRlZmluaXRpb24uXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkZWYgRGVmaW5pdGlvblxyXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIHZhbGlkLCBlbHNlIGZhbHNlXHJcbiAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEJ1aWxkZXIuaXNWYWxpZFNlcnZpY2UgPSBmdW5jdGlvbihkZWYpIHtcclxuICAgICAgICAgICAgICAgIC8vIFNlcnZpY2VzIHJlcXVpcmUgYSBzdHJpbmcgbmFtZSBhbmQgYW4gcnBjIG9iamVjdFxyXG4gICAgICAgICAgICAgICAgcmV0dXJuICEodHlwZW9mIGRlZltcIm5hbWVcIl0gIT09ICdzdHJpbmcnIHx8ICFMYW5nLk5BTUUudGVzdChkZWZbXCJuYW1lXCJdKSB8fCB0eXBlb2YgZGVmW1wicnBjXCJdICE9PSAnb2JqZWN0Jyk7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGVzdHMgaWYgYSBkZWZpbml0aW9uIGlzIGEgdmFsaWQgZXh0ZW5zaW9uLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZGVmIERlZmluaXRpb25cclxuICAgICAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdmFsaWQsIGVsc2UgZmFsc2VcclxuICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBCdWlsZGVyLmlzVmFsaWRFeHRlbmQgPSBmdW5jdGlvbihkZWYpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZGVmW1wicmVmXCJdICE9PSAnc3RyaW5nJyB8fCAhTGFuZy5UWVBFUkVGLnRlc3QoZGVmW1wicmVmXCJdKSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB2YXIgaTtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZGVmW1wiZmllbGRzXCJdICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghUHJvdG9CdWYuVXRpbC5pc0FycmF5KGRlZltcImZpZWxkc1wiXSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaWRzID0gW10sIGlkOyAvLyBJRHMgbXVzdCBiZSB1bmlxdWUgKGRvZXMgbm90IHlldCB0ZXN0IGZvciB0aGUgZXh0ZW5kZWQgbWVzc2FnZSdzIGlkcylcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGk9MDsgaTxkZWZbXCJmaWVsZHNcIl0ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFCdWlsZGVyLmlzVmFsaWRNZXNzYWdlRmllbGQoZGVmW1wiZmllbGRzXCJdW2ldKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWQgPSBwYXJzZUludChkZWZbXCJpZFwiXSwgMTApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaWRzLmluZGV4T2YoaWQpID49IDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkcy5wdXNoKGlkKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWRzID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFJlc29sdmVzIGFsbCBuYW1lc3BhY2Ugb2JqZWN0cy5cclxuICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIGEgdHlwZSBjYW5ub3QgYmUgcmVzb2x2ZWRcclxuICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQnVpbGRlci5wcm90b3R5cGUucmVzb2x2ZUFsbCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgLy8gUmVzb2x2ZSBhbGwgcmVmbGVjdGVkIG9iamVjdHNcclxuICAgICAgICAgICAgICAgIHZhciByZXM7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wdHIgPT0gbnVsbCB8fCB0eXBlb2YgdGhpcy5wdHIudHlwZSA9PT0gJ29iamVjdCcpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBEb25lIChhbHJlYWR5IHJlc29sdmVkKVxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucHRyIGluc3RhbmNlb2YgUmVmbGVjdC5OYW1lc3BhY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBCdWlsZCBhbGwgY2hpbGRyZW5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLnB0ci5nZXRDaGlsZHJlbigpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGk9MDsgaTxjaGlsZHJlbi5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wdHIgPSBjaGlsZHJlbltpXSwgdGhpcy5yZXNvbHZlQWxsKCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMucHRyIGluc3RhbmNlb2YgUmVmbGVjdC5NZXNzYWdlLkZpZWxkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFMYW5nLlRZUEUudGVzdCh0aGlzLnB0ci50eXBlKSkgeyAvLyBSZXNvbHZlIHR5cGUuLi5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFMYW5nLlRZUEVSRUYudGVzdCh0aGlzLnB0ci50eXBlKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCB0eXBlIHJlZmVyZW5jZSBpbiBcIit0aGlzLnB0ci50b1N0cmluZyh0cnVlKStcIjogXCIrdGhpcy5wdHIudHlwZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcyA9IHRoaXMucHRyLnBhcmVudC5yZXNvbHZlKHRoaXMucHRyLnR5cGUsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJlcylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiVW5yZXNvbHZhYmxlIHR5cGUgcmVmZXJlbmNlIGluIFwiK3RoaXMucHRyLnRvU3RyaW5nKHRydWUpK1wiOiBcIit0aGlzLnB0ci50eXBlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wdHIucmVzb2x2ZWRUeXBlID0gcmVzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzIGluc3RhbmNlb2YgUmVmbGVjdC5FbnVtKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wdHIudHlwZSA9IFByb3RvQnVmLlRZUEVTW1wiZW51bVwiXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocmVzIGluc3RhbmNlb2YgUmVmbGVjdC5NZXNzYWdlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wdHIudHlwZSA9IHJlcy5pc0dyb3VwID8gUHJvdG9CdWYuVFlQRVNbXCJncm91cFwiXSA6IFByb3RvQnVmLlRZUEVTW1wibWVzc2FnZVwiXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIHR5cGUgcmVmZXJlbmNlIGluIFwiK3RoaXMucHRyLnRvU3RyaW5nKHRydWUpK1wiOiBcIit0aGlzLnB0ci50eXBlKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wdHIudHlwZSA9IFByb3RvQnVmLlRZUEVTW3RoaXMucHRyLnR5cGVdO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnB0ciBpbnN0YW5jZW9mIFByb3RvQnVmLlJlZmxlY3QuRW51bS5WYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIE5vIG5lZWQgdG8gYnVpbGQgZW51bSB2YWx1ZXMgKGJ1aWx0IGluIGVudW0pXHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMucHRyIGluc3RhbmNlb2YgUHJvdG9CdWYuUmVmbGVjdC5TZXJ2aWNlLk1ldGhvZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnB0ciBpbnN0YW5jZW9mIFByb3RvQnVmLlJlZmxlY3QuU2VydmljZS5SUENNZXRob2QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzID0gdGhpcy5wdHIucGFyZW50LnJlc29sdmUodGhpcy5wdHIucmVxdWVzdE5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJlcyB8fCAhKHJlcyBpbnN0YW5jZW9mIFByb3RvQnVmLlJlZmxlY3QuTWVzc2FnZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIklsbGVnYWwgdHlwZSByZWZlcmVuY2UgaW4gXCIrdGhpcy5wdHIudG9TdHJpbmcodHJ1ZSkrXCI6IFwiK3RoaXMucHRyLnJlcXVlc3ROYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wdHIucmVzb2x2ZWRSZXF1ZXN0VHlwZSA9IHJlcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzID0gdGhpcy5wdHIucGFyZW50LnJlc29sdmUodGhpcy5wdHIucmVzcG9uc2VOYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXMgfHwgIShyZXMgaW5zdGFuY2VvZiBQcm90b0J1Zi5SZWZsZWN0Lk1lc3NhZ2UpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIHR5cGUgcmVmZXJlbmNlIGluIFwiK3RoaXMucHRyLnRvU3RyaW5nKHRydWUpK1wiOiBcIit0aGlzLnB0ci5yZXNwb25zZU5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnB0ci5yZXNvbHZlZFJlc3BvbnNlVHlwZSA9IHJlcztcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTaG91bGQgbm90IGhhcHBlbiBhcyBub3RoaW5nIGVsc2UgaXMgaW1wbGVtZW50ZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIHNlcnZpY2UgdHlwZSBpbiBcIit0aGlzLnB0ci50b1N0cmluZyh0cnVlKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIG9iamVjdCBpbiBuYW1lc3BhY2U6IFwiK3R5cGVvZih0aGlzLnB0cikrXCI6XCIrdGhpcy5wdHIpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEJ1aWxkcyB0aGUgcHJvdG9jb2wuIFRoaXMgd2lsbCBmaXJzdCB0cnkgdG8gcmVzb2x2ZSBhbGwgZGVmaW5pdGlvbnMgYW5kLCBpZiB0aGlzIGhhcyBiZWVuIHN1Y2Nlc3NmdWwsXHJcbiAgICAgICAgICAgICAqIHJldHVybiB0aGUgYnVpbHQgcGFja2FnZS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmc9fSBwYXRoIFNwZWNpZmllcyB3aGF0IHRvIHJldHVybi4gSWYgb21pdHRlZCwgdGhlIGVudGlyZSBuYW1lc3BhY2Ugd2lsbCBiZSByZXR1cm5lZC5cclxuICAgICAgICAgICAgICogQHJldHVybiB7UHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlfE9iamVjdC48c3RyaW5nLCo+fVxyXG4gICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgYSB0eXBlIGNvdWxkIG5vdCBiZSByZXNvbHZlZFxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBCdWlsZGVyLnByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uKHBhdGgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5yZXNvbHZlZClcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc29sdmVBbGwoKSxcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc29sdmVkID0gdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdCA9IG51bGw7IC8vIFJlcXVpcmUgcmUtYnVpbGRcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlc3VsdCA9PSBudWxsKSAvLyAoUmUtKUJ1aWxkXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXN1bHQgPSB0aGlzLm5zLmJ1aWxkKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXBhdGgpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcnQgPSBwYXRoLnNwbGl0KFwiLlwiKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcHRyID0gdGhpcy5yZXN1bHQ7IC8vIEJ1aWxkIG5hbWVzcGFjZSBwb2ludGVyIChubyBoYXNDaGlsZCBldGMuKVxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGk9MDsgaTxwYXJ0Lmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHRyW3BhcnRbaV1dKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHRyID0gcHRyW3BhcnRbaV1dO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB0ciA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwdHI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogU2ltaWxhciB0byB7QGxpbmsgUHJvdG9CdWYuQnVpbGRlciNidWlsZH0sIGJ1dCBsb29rcyB1cCB0aGUgaW50ZXJuYWwgcmVmbGVjdGlvbiBkZXNjcmlwdG9yLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZz19IHBhdGggU3BlY2lmaWVzIHdoYXQgdG8gcmV0dXJuLiBJZiBvbWl0dGVkLCB0aGUgZW50aXJlIG5hbWVzcGFjZSB3aWlsIGJlIHJldHVybmVkLlxyXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHtQcm90b0J1Zi5SZWZsZWN0LlR9IFJlZmxlY3Rpb24gZGVzY3JpcHRvciBvciBgbnVsbGAgaWYgbm90IGZvdW5kXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBCdWlsZGVyLnByb3RvdHlwZS5sb29rdXAgPSBmdW5jdGlvbihwYXRoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcGF0aCA/IHRoaXMubnMucmVzb2x2ZShwYXRoKSA6IHRoaXMubnM7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG9iamVjdC5cclxuICAgICAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBTdHJpbmcgcmVwcmVzZW50YXRpb24gYXMgb2YgXCJCdWlsZGVyXCJcclxuICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQnVpbGRlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBcIkJ1aWxkZXJcIjtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8vIFBzZXVkbyB0eXBlcyBkb2N1bWVudGVkIGluIFJlZmxlY3QuanMuXHJcbiAgICAgICAgICAgIC8vIEV4aXN0IGZvciB0aGUgc29sZSBwdXJwb3NlIG9mIGJlaW5nIGFibGUgdG8gXCIuLi4gaW5zdGFuY2VvZiBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2VcIiBldGMuXHJcbiAgICAgICAgICAgIEJ1aWxkZXIuTWVzc2FnZSA9IGZ1bmN0aW9uKCkge307XHJcbiAgICAgICAgICAgIEJ1aWxkZXIuU2VydmljZSA9IGZ1bmN0aW9uKCkge307XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gQnVpbGRlcjtcclxuXHJcbiAgICAgICAgfSkoUHJvdG9CdWYsIFByb3RvQnVmLkxhbmcsIFByb3RvQnVmLlJlZmxlY3QpO1xyXG5cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTG9hZHMgYSAucHJvdG8gc3RyaW5nIGFuZCByZXR1cm5zIHRoZSBCdWlsZGVyLlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm90byAucHJvdG8gZmlsZSBjb250ZW50c1xyXG4gICAgICAgICAqIEBwYXJhbSB7KFByb3RvQnVmLkJ1aWxkZXJ8c3RyaW5nfHtyb290OiBzdHJpbmcsIGZpbGU6IHN0cmluZ30pPX0gYnVpbGRlciBCdWlsZGVyIHRvIGFwcGVuZCB0by4gV2lsbCBjcmVhdGUgYSBuZXcgb25lIGlmIG9taXR0ZWQuXHJcbiAgICAgICAgICogQHBhcmFtIHsoc3RyaW5nfHtyb290OiBzdHJpbmcsIGZpbGU6IHN0cmluZ30pPX0gZmlsZW5hbWUgVGhlIGNvcnJlc3BvbmRpbmcgZmlsZSBuYW1lIGlmIGtub3duLiBNdXN0IGJlIHNwZWNpZmllZCBmb3IgaW1wb3J0cy5cclxuICAgICAgICAgKiBAcmV0dXJuIHtQcm90b0J1Zi5CdWlsZGVyfSBCdWlsZGVyIHRvIGNyZWF0ZSBuZXcgbWVzc2FnZXNcclxuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGRlZmluaXRpb24gY2Fubm90IGJlIHBhcnNlZCBvciBidWlsdFxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBQcm90b0J1Zi5sb2FkUHJvdG8gPSBmdW5jdGlvbihwcm90bywgYnVpbGRlciwgZmlsZW5hbWUpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBidWlsZGVyID09PSAnc3RyaW5nJyB8fCAoYnVpbGRlciAmJiB0eXBlb2YgYnVpbGRlcltcImZpbGVcIl0gPT09ICdzdHJpbmcnICYmIHR5cGVvZiBidWlsZGVyW1wicm9vdFwiXSA9PT0gJ3N0cmluZycpKSB7XHJcbiAgICAgICAgICAgICAgICBmaWxlbmFtZSA9IGJ1aWxkZXI7XHJcbiAgICAgICAgICAgICAgICBidWlsZGVyID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gUHJvdG9CdWYubG9hZEpzb24oKG5ldyBQcm90b0J1Zi5Eb3RQcm90by5QYXJzZXIocHJvdG8pKS5wYXJzZSgpLCBidWlsZGVyLCBmaWxlbmFtZSk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTG9hZHMgYSAucHJvdG8gc3RyaW5nIGFuZCByZXR1cm5zIHRoZSBCdWlsZGVyLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBQcm90b0J1Zi5sb2FkUHJvdG99LlxyXG4gICAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm90byAucHJvdG8gZmlsZSBjb250ZW50c1xyXG4gICAgICAgICAqIEBwYXJhbSB7KFByb3RvQnVmLkJ1aWxkZXJ8c3RyaW5nKT19IGJ1aWxkZXIgQnVpbGRlciB0byBhcHBlbmQgdG8uIFdpbGwgY3JlYXRlIGEgbmV3IG9uZSBpZiBvbWl0dGVkLlxyXG4gICAgICAgICAqIEBwYXJhbSB7KHN0cmluZ3x7cm9vdDogc3RyaW5nLCBmaWxlOiBzdHJpbmd9KT19IGZpbGVuYW1lIFRoZSBjb3JyZXNwb25kaW5nIGZpbGUgbmFtZSBpZiBrbm93bi4gTXVzdCBiZSBzcGVjaWZpZWQgZm9yIGltcG9ydHMuXHJcbiAgICAgICAgICogQHJldHVybiB7UHJvdG9CdWYuQnVpbGRlcn0gQnVpbGRlciB0byBjcmVhdGUgbmV3IG1lc3NhZ2VzXHJcbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBkZWZpbml0aW9uIGNhbm5vdCBiZSBwYXJzZWQgb3IgYnVpbHRcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUHJvdG9CdWYucHJvdG9Gcm9tU3RyaW5nID0gUHJvdG9CdWYubG9hZFByb3RvOyAvLyBMZWdhY3lcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTG9hZHMgYSAucHJvdG8gZmlsZSBhbmQgcmV0dXJucyB0aGUgQnVpbGRlci5cclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ3x7cm9vdDogc3RyaW5nLCBmaWxlOiBzdHJpbmd9fSBmaWxlbmFtZSBQYXRoIHRvIHByb3RvIGZpbGUgb3IgYW4gb2JqZWN0IHNwZWNpZnlpbmcgJ2ZpbGUnIHdpdGhcclxuICAgICAgICAgKiAgYW4gb3ZlcnJpZGRlbiAncm9vdCcgcGF0aCBmb3IgYWxsIGltcG9ydGVkIGZpbGVzLlxyXG4gICAgICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oP0Vycm9yLCAhUHJvdG9CdWYuQnVpbGRlcj0pPX0gY2FsbGJhY2sgQ2FsbGJhY2sgdGhhdCB3aWxsIHJlY2VpdmUgYG51bGxgIGFzIHRoZSBmaXJzdCBhbmRcclxuICAgICAgICAgKiAgdGhlIEJ1aWxkZXIgYXMgaXRzIHNlY29uZCBhcmd1bWVudCBvbiBzdWNjZXNzLCBvdGhlcndpc2UgdGhlIGVycm9yIGFzIGl0cyBmaXJzdCBhcmd1bWVudC4gSWYgb21pdHRlZCwgdGhlXHJcbiAgICAgICAgICogIGZpbGUgd2lsbCBiZSByZWFkIHN5bmNocm9ub3VzbHkgYW5kIHRoaXMgZnVuY3Rpb24gd2lsbCByZXR1cm4gdGhlIEJ1aWxkZXIuXHJcbiAgICAgICAgICogQHBhcmFtIHtQcm90b0J1Zi5CdWlsZGVyPX0gYnVpbGRlciBCdWlsZGVyIHRvIGFwcGVuZCB0by4gV2lsbCBjcmVhdGUgYSBuZXcgb25lIGlmIG9taXR0ZWQuXHJcbiAgICAgICAgICogQHJldHVybiB7P1Byb3RvQnVmLkJ1aWxkZXJ8dW5kZWZpbmVkfSBUaGUgQnVpbGRlciBpZiBzeW5jaHJvbm91cyAobm8gY2FsbGJhY2sgc3BlY2lmaWVkLCB3aWxsIGJlIE5VTEwgaWYgdGhlXHJcbiAgICAgICAgICogICByZXF1ZXN0IGhhcyBmYWlsZWQpLCBlbHNlIHVuZGVmaW5lZFxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBQcm90b0J1Zi5sb2FkUHJvdG9GaWxlID0gZnVuY3Rpb24oZmlsZW5hbWUsIGNhbGxiYWNrLCBidWlsZGVyKSB7XHJcbiAgICAgICAgICAgIGlmIChjYWxsYmFjayAmJiB0eXBlb2YgY2FsbGJhY2sgPT09ICdvYmplY3QnKVxyXG4gICAgICAgICAgICAgICAgYnVpbGRlciA9IGNhbGxiYWNrLFxyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBudWxsO1xyXG4gICAgICAgICAgICBlbHNlIGlmICghY2FsbGJhY2sgfHwgdHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKVxyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBudWxsO1xyXG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvdG9CdWYuVXRpbC5mZXRjaCh0eXBlb2YgZmlsZW5hbWUgPT09ICdzdHJpbmcnID8gZmlsZW5hbWUgOiBmaWxlbmFtZVtcInJvb3RcIl0rXCIvXCIrZmlsZW5hbWVbXCJmaWxlXCJdLCBmdW5jdGlvbihjb250ZW50cykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250ZW50cyA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhFcnJvcihcIkZhaWxlZCB0byBmZXRjaCBmaWxlXCIpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCBQcm90b0J1Zi5sb2FkUHJvdG8oY29udGVudHMsIGJ1aWxkZXIsIGZpbGVuYW1lKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdmFyIGNvbnRlbnRzID0gUHJvdG9CdWYuVXRpbC5mZXRjaCh0eXBlb2YgZmlsZW5hbWUgPT09ICdvYmplY3QnID8gZmlsZW5hbWVbXCJyb290XCJdK1wiL1wiK2ZpbGVuYW1lW1wiZmlsZVwiXSA6IGZpbGVuYW1lKTtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnRzID09PSBudWxsID8gbnVsbCA6IFByb3RvQnVmLmxvYWRQcm90byhjb250ZW50cywgYnVpbGRlciwgZmlsZW5hbWUpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIExvYWRzIGEgLnByb3RvIGZpbGUgYW5kIHJldHVybnMgdGhlIEJ1aWxkZXIuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIFByb3RvQnVmLmxvYWRQcm90b0ZpbGV9LlxyXG4gICAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfHtyb290OiBzdHJpbmcsIGZpbGU6IHN0cmluZ319IGZpbGVuYW1lIFBhdGggdG8gcHJvdG8gZmlsZSBvciBhbiBvYmplY3Qgc3BlY2lmeWluZyAnZmlsZScgd2l0aFxyXG4gICAgICAgICAqICBhbiBvdmVycmlkZGVuICdyb290JyBwYXRoIGZvciBhbGwgaW1wb3J0ZWQgZmlsZXMuXHJcbiAgICAgICAgICogQHBhcmFtIHtmdW5jdGlvbig/RXJyb3IsICFQcm90b0J1Zi5CdWlsZGVyPSk9fSBjYWxsYmFjayBDYWxsYmFjayB0aGF0IHdpbGwgcmVjZWl2ZSBgbnVsbGAgYXMgdGhlIGZpcnN0IGFuZFxyXG4gICAgICAgICAqICB0aGUgQnVpbGRlciBhcyBpdHMgc2Vjb25kIGFyZ3VtZW50IG9uIHN1Y2Nlc3MsIG90aGVyd2lzZSB0aGUgZXJyb3IgYXMgaXRzIGZpcnN0IGFyZ3VtZW50LiBJZiBvbWl0dGVkLCB0aGVcclxuICAgICAgICAgKiAgZmlsZSB3aWxsIGJlIHJlYWQgc3luY2hyb25vdXNseSBhbmQgdGhpcyBmdW5jdGlvbiB3aWxsIHJldHVybiB0aGUgQnVpbGRlci5cclxuICAgICAgICAgKiBAcGFyYW0ge1Byb3RvQnVmLkJ1aWxkZXI9fSBidWlsZGVyIEJ1aWxkZXIgdG8gYXBwZW5kIHRvLiBXaWxsIGNyZWF0ZSBhIG5ldyBvbmUgaWYgb21pdHRlZC5cclxuICAgICAgICAgKiBAcmV0dXJuIHshUHJvdG9CdWYuQnVpbGRlcnx1bmRlZmluZWR9IFRoZSBCdWlsZGVyIGlmIHN5bmNocm9ub3VzIChubyBjYWxsYmFjayBzcGVjaWZpZWQsIHdpbGwgYmUgTlVMTCBpZiB0aGVcclxuICAgICAgICAgKiAgIHJlcXVlc3QgaGFzIGZhaWxlZCksIGVsc2UgdW5kZWZpbmVkXHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFByb3RvQnVmLnByb3RvRnJvbUZpbGUgPSBQcm90b0J1Zi5sb2FkUHJvdG9GaWxlOyAvLyBMZWdhY3lcclxuXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgQnVpbGRlciB3aXRoIHRoZSBzcGVjaWZpZWQgcGFja2FnZSBkZWZpbmVkLlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nPX0gcGtnIFBhY2thZ2UgbmFtZSBhcyBmdWxseSBxdWFsaWZpZWQgbmFtZSwgZS5nLiBcIk15LkdhbWVcIi4gSWYgbm8gcGFja2FnZSBpcyBzcGVjaWZpZWQsIHRoZVxyXG4gICAgICAgICAqIGJ1aWxkZXIgd2lsbCBvbmx5IGNvbnRhaW4gYSBnbG9iYWwgbmFtZXNwYWNlLlxyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj49fSBvcHRpb25zIFRvcCBsZXZlbCBvcHRpb25zXHJcbiAgICAgICAgICogQHJldHVybiB7UHJvdG9CdWYuQnVpbGRlcn0gTmV3IEJ1aWxkZXJcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUHJvdG9CdWYubmV3QnVpbGRlciA9IGZ1bmN0aW9uKHBrZywgb3B0aW9ucykge1xyXG4gICAgICAgICAgICB2YXIgYnVpbGRlciA9IG5ldyBQcm90b0J1Zi5CdWlsZGVyKCk7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGtnICE9PSAndW5kZWZpbmVkJyAmJiBwa2cgIT09IG51bGwpXHJcbiAgICAgICAgICAgICAgICBidWlsZGVyLmRlZmluZShwa2csIG9wdGlvbnMpO1xyXG4gICAgICAgICAgICByZXR1cm4gYnVpbGRlcjtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBMb2FkcyBhIC5qc29uIGRlZmluaXRpb24gYW5kIHJldHVybnMgdGhlIEJ1aWxkZXIuXHJcbiAgICAgICAgICogQHBhcmFtIHshKnxzdHJpbmd9IGpzb24gSlNPTiBkZWZpbml0aW9uXHJcbiAgICAgICAgICogQHBhcmFtIHsoUHJvdG9CdWYuQnVpbGRlcnxzdHJpbmd8e3Jvb3Q6IHN0cmluZywgZmlsZTogc3RyaW5nfSk9fSBidWlsZGVyIEJ1aWxkZXIgdG8gYXBwZW5kIHRvLiBXaWxsIGNyZWF0ZSBhIG5ldyBvbmUgaWYgb21pdHRlZC5cclxuICAgICAgICAgKiBAcGFyYW0geyhzdHJpbmd8e3Jvb3Q6IHN0cmluZywgZmlsZTogc3RyaW5nfSk9fSBmaWxlbmFtZSBUaGUgY29ycmVzcG9uZGluZyBmaWxlIG5hbWUgaWYga25vd24uIE11c3QgYmUgc3BlY2lmaWVkIGZvciBpbXBvcnRzLlxyXG4gICAgICAgICAqIEByZXR1cm4ge1Byb3RvQnVmLkJ1aWxkZXJ9IEJ1aWxkZXIgdG8gY3JlYXRlIG5ldyBtZXNzYWdlc1xyXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgZGVmaW5pdGlvbiBjYW5ub3QgYmUgcGFyc2VkIG9yIGJ1aWx0XHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFByb3RvQnVmLmxvYWRKc29uID0gZnVuY3Rpb24oanNvbiwgYnVpbGRlciwgZmlsZW5hbWUpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBidWlsZGVyID09PSAnc3RyaW5nJyB8fCAoYnVpbGRlciAmJiB0eXBlb2YgYnVpbGRlcltcImZpbGVcIl0gPT09ICdzdHJpbmcnICYmIHR5cGVvZiBidWlsZGVyW1wicm9vdFwiXSA9PT0gJ3N0cmluZycpKVxyXG4gICAgICAgICAgICAgICAgZmlsZW5hbWUgPSBidWlsZGVyLFxyXG4gICAgICAgICAgICAgICAgYnVpbGRlciA9IG51bGw7XHJcbiAgICAgICAgICAgIGlmICghYnVpbGRlciB8fCB0eXBlb2YgYnVpbGRlciAhPT0gJ29iamVjdCcpXHJcbiAgICAgICAgICAgICAgICBidWlsZGVyID0gUHJvdG9CdWYubmV3QnVpbGRlcigpO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGpzb24gPT09ICdzdHJpbmcnKVxyXG4gICAgICAgICAgICAgICAganNvbiA9IEpTT04ucGFyc2UoanNvbik7XHJcbiAgICAgICAgICAgIGJ1aWxkZXJbXCJpbXBvcnRcIl0oanNvbiwgZmlsZW5hbWUpO1xyXG4gICAgICAgICAgICBidWlsZGVyLnJlc29sdmVBbGwoKTtcclxuICAgICAgICAgICAgYnVpbGRlci5idWlsZCgpO1xyXG4gICAgICAgICAgICByZXR1cm4gYnVpbGRlcjtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBMb2FkcyBhIC5qc29uIGZpbGUgYW5kIHJldHVybnMgdGhlIEJ1aWxkZXIuXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd8IXtyb290OiBzdHJpbmcsIGZpbGU6IHN0cmluZ319IGZpbGVuYW1lIFBhdGggdG8ganNvbiBmaWxlIG9yIGFuIG9iamVjdCBzcGVjaWZ5aW5nICdmaWxlJyB3aXRoXHJcbiAgICAgICAgICogIGFuIG92ZXJyaWRkZW4gJ3Jvb3QnIHBhdGggZm9yIGFsbCBpbXBvcnRlZCBmaWxlcy5cclxuICAgICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKD9FcnJvciwgIVByb3RvQnVmLkJ1aWxkZXI9KT19IGNhbGxiYWNrIENhbGxiYWNrIHRoYXQgd2lsbCByZWNlaXZlIGBudWxsYCBhcyB0aGUgZmlyc3QgYW5kXHJcbiAgICAgICAgICogIHRoZSBCdWlsZGVyIGFzIGl0cyBzZWNvbmQgYXJndW1lbnQgb24gc3VjY2Vzcywgb3RoZXJ3aXNlIHRoZSBlcnJvciBhcyBpdHMgZmlyc3QgYXJndW1lbnQuIElmIG9taXR0ZWQsIHRoZVxyXG4gICAgICAgICAqICBmaWxlIHdpbGwgYmUgcmVhZCBzeW5jaHJvbm91c2x5IGFuZCB0aGlzIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIHRoZSBCdWlsZGVyLlxyXG4gICAgICAgICAqIEBwYXJhbSB7UHJvdG9CdWYuQnVpbGRlcj19IGJ1aWxkZXIgQnVpbGRlciB0byBhcHBlbmQgdG8uIFdpbGwgY3JlYXRlIGEgbmV3IG9uZSBpZiBvbWl0dGVkLlxyXG4gICAgICAgICAqIEByZXR1cm4gez9Qcm90b0J1Zi5CdWlsZGVyfHVuZGVmaW5lZH0gVGhlIEJ1aWxkZXIgaWYgc3luY2hyb25vdXMgKG5vIGNhbGxiYWNrIHNwZWNpZmllZCwgd2lsbCBiZSBOVUxMIGlmIHRoZVxyXG4gICAgICAgICAqICAgcmVxdWVzdCBoYXMgZmFpbGVkKSwgZWxzZSB1bmRlZmluZWRcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUHJvdG9CdWYubG9hZEpzb25GaWxlID0gZnVuY3Rpb24oZmlsZW5hbWUsIGNhbGxiYWNrLCBidWlsZGVyKSB7XHJcbiAgICAgICAgICAgIGlmIChjYWxsYmFjayAmJiB0eXBlb2YgY2FsbGJhY2sgPT09ICdvYmplY3QnKVxyXG4gICAgICAgICAgICAgICAgYnVpbGRlciA9IGNhbGxiYWNrLFxyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBudWxsO1xyXG4gICAgICAgICAgICBlbHNlIGlmICghY2FsbGJhY2sgfHwgdHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKVxyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBudWxsO1xyXG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvdG9CdWYuVXRpbC5mZXRjaCh0eXBlb2YgZmlsZW5hbWUgPT09ICdzdHJpbmcnID8gZmlsZW5hbWUgOiBmaWxlbmFtZVtcInJvb3RcIl0rXCIvXCIrZmlsZW5hbWVbXCJmaWxlXCJdLCBmdW5jdGlvbihjb250ZW50cykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250ZW50cyA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhFcnJvcihcIkZhaWxlZCB0byBmZXRjaCBmaWxlXCIpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCBQcm90b0J1Zi5sb2FkSnNvbihKU09OLnBhcnNlKGNvbnRlbnRzKSwgYnVpbGRlciwgZmlsZW5hbWUpKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB2YXIgY29udGVudHMgPSBQcm90b0J1Zi5VdGlsLmZldGNoKHR5cGVvZiBmaWxlbmFtZSA9PT0gJ29iamVjdCcgPyBmaWxlbmFtZVtcInJvb3RcIl0rXCIvXCIrZmlsZW5hbWVbXCJmaWxlXCJdIDogZmlsZW5hbWUpO1xyXG4gICAgICAgICAgICByZXR1cm4gY29udGVudHMgPT09IG51bGwgPyBudWxsIDogUHJvdG9CdWYubG9hZEpzb24oSlNPTi5wYXJzZShjb250ZW50cyksIGJ1aWxkZXIsIGZpbGVuYW1lKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICByZXR1cm4gUHJvdG9CdWY7XHJcbiAgICB9XHJcblxyXG4gICAgLyogQ29tbW9uSlMgKi8gaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZVtcImV4cG9ydHNcIl0pXHJcbiAgICAgICAgbW9kdWxlW1wiZXhwb3J0c1wiXSA9IGluaXQocmVxdWlyZShcImJ5dGVidWZmZXJcIikpO1xyXG4gICAgLyogQU1EICovIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lW1wiYW1kXCJdKVxyXG4gICAgICAgIGRlZmluZShbXCJCeXRlQnVmZmVyXCJdLCBpbml0KTtcclxuICAgIC8qIEdsb2JhbCAqLyBlbHNlXHJcbiAgICAgICAgKGdsb2JhbFtcImRjb2RlSU9cIl0gPSBnbG9iYWxbXCJkY29kZUlPXCJdIHx8IHt9KVtcIlByb3RvQnVmXCJdID0gaW5pdChnbG9iYWxbXCJkY29kZUlPXCJdW1wiQnl0ZUJ1ZmZlclwiXSk7XHJcblxyXG59KSh0aGlzKTtcclxuIiwiLypcclxuIENvcHlyaWdodCAyMDEzIERhbmllbCBXaXJ0eiA8ZGNvZGVAZGNvZGUuaW8+XHJcblxyXG4gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG5cclxuIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG5cclxuIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG52YXIgUHJvdG9CdWYgPSByZXF1aXJlKFwiLi9kaXN0L1Byb3RvQnVmLmpzXCIpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBQcm90b0J1ZjtcclxuIiwiLypcbiBCeXRlQnVmZmVyLmpzIChjKSAyMDEzLTIwMTQgRGFuaWVsIFdpcnR6IDxkY29kZUBkY29kZS5pbz5cbiBUaGlzIHZlcnNpb24gb2YgQnl0ZUJ1ZmZlci5qcyB1c2VzIGFuIEFycmF5QnVmZmVyIChBQikgYXMgaXRzIGJhY2tpbmcgYnVmZmVyIGFuZCBpcyBjb21wYXRpYmxlIHdpdGggbW9kZXJuIGJyb3dzZXJzLlxuIFJlbGVhc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjBcbiBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9kY29kZUlPL0J5dGVCdWZmZXIuanMgZm9yIGRldGFpbHNcbiovXG4oZnVuY3Rpb24ocil7ZnVuY3Rpb24gcyhsKXtmdW5jdGlvbiBkKGEsYixjKXtcInVuZGVmaW5lZFwiPT09dHlwZW9mIGEmJihhPWQuREVGQVVMVF9DQVBBQ0lUWSk7XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBiJiYoYj1kLkRFRkFVTFRfRU5ESUFOKTtcInVuZGVmaW5lZFwiPT09dHlwZW9mIGMmJihjPWQuREVGQVVMVF9OT0FTU0VSVCk7aWYoIWMpe2F8PTA7aWYoMD5hKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSWxsZWdhbCBjYXBhY2l0eTogMCA8PSBcIithKTtpZihcImJvb2xlYW5cIiE9PXR5cGVvZiBiKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGxpdHRsZUVuZGlhbjogTm90IGEgYm9vbGVhblwiKTtpZihcImJvb2xlYW5cIiE9PXR5cGVvZiBjKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG5vQXNzZXJ0OiBOb3QgYSBib29sZWFuXCIpO310aGlzLmJ1ZmZlcj0wPT09YT9yOm5ldyBBcnJheUJ1ZmZlcihhKTt0aGlzLnZpZXc9MD09PWE/bnVsbDpuZXcgRGF0YVZpZXcodGhpcy5idWZmZXIpO1xudGhpcy5vZmZzZXQ9MDt0aGlzLm1hcmtlZE9mZnNldD0tMTt0aGlzLmxpbWl0PWE7dGhpcy5saXR0bGVFbmRpYW49XCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBiPyEhYjohMTt0aGlzLm5vQXNzZXJ0PSEhY31kLlZFUlNJT049XCIzLjEuMFwiO2QuTElUVExFX0VORElBTj0hMDtkLkJJR19FTkRJQU49ITE7ZC5ERUZBVUxUX0NBUEFDSVRZPTE2O2QuREVGQVVMVF9FTkRJQU49ZC5CSUdfRU5ESUFOO2QuREVGQVVMVF9OT0FTU0VSVD0hMTtkLkxvbmc9bHx8bnVsbDt2YXIgcj1uZXcgQXJyYXlCdWZmZXIoMCk7ZC5hbGxvY2F0ZT1mdW5jdGlvbihhLGIsYyl7cmV0dXJuIG5ldyBkKGEsYixjKX07ZC5jb25jYXQ9ZnVuY3Rpb24oYSxiLGMsZSl7aWYoXCJib29sZWFuXCI9PT10eXBlb2YgYnx8XCJzdHJpbmdcIiE9PXR5cGVvZiBiKWU9YyxjPWIsYj12b2lkIDA7Zm9yKHZhciBoPTAsZj0wLGc9YS5sZW5ndGgsbjtmPGc7KytmKWQuaXNCeXRlQnVmZmVyKGFbZl0pfHwoYVtmXT1kLndyYXAoYVtmXSxiKSksbj1cbmFbZl0ubGltaXQtYVtmXS5vZmZzZXQsMDxuJiYoaCs9bik7aWYoMD09PWgpcmV0dXJuIG5ldyBkKDAsYyxlKTtiPW5ldyBkKGgsYyxlKTtlPW5ldyBVaW50OEFycmF5KGIuYnVmZmVyKTtmb3IoZj0wO2Y8ZzspYz1hW2YrK10sbj1jLmxpbWl0LWMub2Zmc2V0LDA+PW58fChlLnNldCgobmV3IFVpbnQ4QXJyYXkoYy5idWZmZXIpKS5zdWJhcnJheShjLm9mZnNldCxjLmxpbWl0KSxiLm9mZnNldCksYi5vZmZzZXQrPW4pO2IubGltaXQ9Yi5vZmZzZXQ7Yi5vZmZzZXQ9MDtyZXR1cm4gYn07ZC5pc0J5dGVCdWZmZXI9ZnVuY3Rpb24oYSl7cmV0dXJuIGEmJmEgaW5zdGFuY2VvZiBkfTtkLnR5cGU9ZnVuY3Rpb24oKXtyZXR1cm4gQXJyYXlCdWZmZXJ9O2Qud3JhcD1mdW5jdGlvbihhLGIsYyxlKXtcInN0cmluZ1wiIT09dHlwZW9mIGImJihlPWMsYz1iLGI9dm9pZCAwKTtpZihcInN0cmluZ1wiPT09dHlwZW9mIGEpc3dpdGNoKFwidW5kZWZpbmVkXCI9PT10eXBlb2YgYiYmKGI9XCJ1dGY4XCIpLGIpe2Nhc2UgXCJiYXNlNjRcIjpyZXR1cm4gZC5mcm9tQmFzZTY0KGEsXG5jKTtjYXNlIFwiaGV4XCI6cmV0dXJuIGQuZnJvbUhleChhLGMpO2Nhc2UgXCJiaW5hcnlcIjpyZXR1cm4gZC5mcm9tQmluYXJ5KGEsYyk7Y2FzZSBcInV0ZjhcIjpyZXR1cm4gZC5mcm9tVVRGOChhLGMpO2Nhc2UgXCJkZWJ1Z1wiOnJldHVybiBkLmZyb21EZWJ1ZyhhLGMpO2RlZmF1bHQ6dGhyb3cgbmV3IFR5cGVFcnJvcihcIlVuc3VwcG9ydGVkIGVuY29kaW5nOiBcIitiKTt9aWYobnVsbD09PWF8fFwib2JqZWN0XCIhPT10eXBlb2YgYSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBidWZmZXI6IG51bGwgb3Igbm9uLW9iamVjdFwiKTtpZihkLmlzQnl0ZUJ1ZmZlcihhKSlyZXR1cm4gYj1kLnByb3RvdHlwZS5jbG9uZS5jYWxsKGEpLGIubWFya2VkT2Zmc2V0PS0xLGI7aWYoYSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpYj1uZXcgZCgwLGMsZSksMDxhLmxlbmd0aCYmKGIuYnVmZmVyPWEuYnVmZmVyLGIub2Zmc2V0PWEuYnl0ZU9mZnNldCxiLmxpbWl0PWEuYnl0ZU9mZnNldCthLmxlbmd0aCxiLnZpZXc9XG4wPGEubGVuZ3RoP25ldyBEYXRhVmlldyhhLmJ1ZmZlcik6bnVsbCk7ZWxzZSBpZihhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpYj1uZXcgZCgwLGMsZSksMDxhLmJ5dGVMZW5ndGgmJihiLmJ1ZmZlcj1hLGIub2Zmc2V0PTAsYi5saW1pdD1hLmJ5dGVMZW5ndGgsYi52aWV3PTA8YS5ieXRlTGVuZ3RoP25ldyBEYXRhVmlldyhhKTpudWxsKTtlbHNlIGlmKFwiW29iamVjdCBBcnJheV1cIj09PU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhKSlmb3IoYj1uZXcgZChhLmxlbmd0aCxjLGUpLGIubGltaXQ9YS5sZW5ndGgsaT0wO2k8YS5sZW5ndGg7KytpKWIudmlldy5zZXRVaW50OChpLGFbaV0pO2Vsc2UgdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgYnVmZmVyXCIpO3JldHVybiBifTtkLnByb3RvdHlwZS53cml0ZUludDg9ZnVuY3Rpb24oYSxiKXt2YXIgYz1cInVuZGVmaW5lZFwiPT09dHlwZW9mIGI7YyYmKGI9dGhpcy5vZmZzZXQpO2lmKCF0aGlzLm5vQXNzZXJ0KXtpZihcIm51bWJlclwiIT09XG50eXBlb2YgYXx8MCE9PWElMSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCB2YWx1ZTogXCIrYStcIiAobm90IGFuIGludGVnZXIpXCIpO2F8PTA7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBifHwwIT09YiUxKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrYitcIiAobm90IGFuIGludGVnZXIpXCIpO2I+Pj49MDtpZigwPmJ8fGIrMD50aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrYitcIiAoKzApIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO31iKz0xO3ZhciBlPXRoaXMuYnVmZmVyLmJ5dGVMZW5ndGg7Yj5lJiZ0aGlzLnJlc2l6ZSgoZSo9Mik+Yj9lOmIpO3RoaXMudmlldy5zZXRJbnQ4KGItMSxhKTtjJiYodGhpcy5vZmZzZXQrPTEpO3JldHVybiB0aGlzfTtkLnByb3RvdHlwZS53cml0ZUJ5dGU9ZC5wcm90b3R5cGUud3JpdGVJbnQ4O2QucHJvdG90eXBlLnJlYWRJbnQ4PWZ1bmN0aW9uKGEpe3ZhciBiPVxuXCJ1bmRlZmluZWRcIj09PXR5cGVvZiBhO2ImJihhPXRoaXMub2Zmc2V0KTtpZighdGhpcy5ub0Fzc2VydCl7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBhfHwwIT09YSUxKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrYStcIiAobm90IGFuIGludGVnZXIpXCIpO2E+Pj49MDtpZigwPmF8fGErMT50aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrYStcIiAoKzEpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO31hPXRoaXMudmlldy5nZXRJbnQ4KGEpO2ImJih0aGlzLm9mZnNldCs9MSk7cmV0dXJuIGF9O2QucHJvdG90eXBlLnJlYWRCeXRlPWQucHJvdG90eXBlLnJlYWRJbnQ4O2QucHJvdG90eXBlLndyaXRlVWludDg9ZnVuY3Rpb24oYSxiKXt2YXIgYz1cInVuZGVmaW5lZFwiPT09dHlwZW9mIGI7YyYmKGI9dGhpcy5vZmZzZXQpO2lmKCF0aGlzLm5vQXNzZXJ0KXtpZihcIm51bWJlclwiIT09dHlwZW9mIGF8fFxuMCE9PWElMSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCB2YWx1ZTogXCIrYStcIiAobm90IGFuIGludGVnZXIpXCIpO2E+Pj49MDtpZihcIm51bWJlclwiIT09dHlwZW9mIGJ8fDAhPT1iJTEpdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitiK1wiIChub3QgYW4gaW50ZWdlcilcIik7Yj4+Pj0wO2lmKDA+Ynx8YiswPnRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitiK1wiICgrMCkgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7fWIrPTE7dmFyIGU9dGhpcy5idWZmZXIuYnl0ZUxlbmd0aDtiPmUmJnRoaXMucmVzaXplKChlKj0yKT5iP2U6Yik7dGhpcy52aWV3LnNldFVpbnQ4KGItMSxhKTtjJiYodGhpcy5vZmZzZXQrPTEpO3JldHVybiB0aGlzfTtkLnByb3RvdHlwZS5yZWFkVWludDg9ZnVuY3Rpb24oYSl7dmFyIGI9XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBhO2ImJihhPXRoaXMub2Zmc2V0KTtcbmlmKCF0aGlzLm5vQXNzZXJ0KXtpZihcIm51bWJlclwiIT09dHlwZW9mIGF8fDAhPT1hJTEpdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIithK1wiIChub3QgYW4gaW50ZWdlcilcIik7YT4+Pj0wO2lmKDA+YXx8YSsxPnRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIithK1wiICgrMSkgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7fWE9dGhpcy52aWV3LmdldFVpbnQ4KGEpO2ImJih0aGlzLm9mZnNldCs9MSk7cmV0dXJuIGF9O2QucHJvdG90eXBlLndyaXRlSW50MTY9ZnVuY3Rpb24oYSxiKXt2YXIgYz1cInVuZGVmaW5lZFwiPT09dHlwZW9mIGI7YyYmKGI9dGhpcy5vZmZzZXQpO2lmKCF0aGlzLm5vQXNzZXJ0KXtpZihcIm51bWJlclwiIT09dHlwZW9mIGF8fDAhPT1hJTEpdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgdmFsdWU6IFwiK2ErXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTthfD0wO2lmKFwibnVtYmVyXCIhPT1cbnR5cGVvZiBifHwwIT09YiUxKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrYitcIiAobm90IGFuIGludGVnZXIpXCIpO2I+Pj49MDtpZigwPmJ8fGIrMD50aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrYitcIiAoKzApIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO31iKz0yO3ZhciBlPXRoaXMuYnVmZmVyLmJ5dGVMZW5ndGg7Yj5lJiZ0aGlzLnJlc2l6ZSgoZSo9Mik+Yj9lOmIpO3RoaXMudmlldy5zZXRJbnQxNihiLTIsYSx0aGlzLmxpdHRsZUVuZGlhbik7YyYmKHRoaXMub2Zmc2V0Kz0yKTtyZXR1cm4gdGhpc307ZC5wcm90b3R5cGUud3JpdGVTaG9ydD1kLnByb3RvdHlwZS53cml0ZUludDE2O2QucHJvdG90eXBlLnJlYWRJbnQxNj1mdW5jdGlvbihhKXt2YXIgYj1cInVuZGVmaW5lZFwiPT09dHlwZW9mIGE7YiYmKGE9dGhpcy5vZmZzZXQpO2lmKCF0aGlzLm5vQXNzZXJ0KXtpZihcIm51bWJlclwiIT09XG50eXBlb2YgYXx8MCE9PWElMSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK2ErXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTthPj4+PTA7aWYoMD5hfHxhKzI+dGhpcy5idWZmZXIuYnl0ZUxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK2ErXCIgKCsyKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTt9YT10aGlzLnZpZXcuZ2V0SW50MTYoYSx0aGlzLmxpdHRsZUVuZGlhbik7YiYmKHRoaXMub2Zmc2V0Kz0yKTtyZXR1cm4gYX07ZC5wcm90b3R5cGUucmVhZFNob3J0PWQucHJvdG90eXBlLnJlYWRJbnQxNjtkLnByb3RvdHlwZS53cml0ZVVpbnQxNj1mdW5jdGlvbihhLGIpe3ZhciBjPVwidW5kZWZpbmVkXCI9PT10eXBlb2YgYjtjJiYoYj10aGlzLm9mZnNldCk7aWYoIXRoaXMubm9Bc3NlcnQpe2lmKFwibnVtYmVyXCIhPT10eXBlb2YgYXx8MCE9PWElMSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCB2YWx1ZTogXCIrYStcIiAobm90IGFuIGludGVnZXIpXCIpO1xuYT4+Pj0wO2lmKFwibnVtYmVyXCIhPT10eXBlb2YgYnx8MCE9PWIlMSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK2IrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtiPj4+PTA7aWYoMD5ifHxiKzA+dGhpcy5idWZmZXIuYnl0ZUxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK2IrXCIgKCswKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTt9Yis9Mjt2YXIgZT10aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoO2I+ZSYmdGhpcy5yZXNpemUoKGUqPTIpPmI/ZTpiKTt0aGlzLnZpZXcuc2V0VWludDE2KGItMixhLHRoaXMubGl0dGxlRW5kaWFuKTtjJiYodGhpcy5vZmZzZXQrPTIpO3JldHVybiB0aGlzfTtkLnByb3RvdHlwZS5yZWFkVWludDE2PWZ1bmN0aW9uKGEpe3ZhciBiPVwidW5kZWZpbmVkXCI9PT10eXBlb2YgYTtiJiYoYT10aGlzLm9mZnNldCk7aWYoIXRoaXMubm9Bc3NlcnQpe2lmKFwibnVtYmVyXCIhPT10eXBlb2YgYXx8MCE9PWElXG4xKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrYStcIiAobm90IGFuIGludGVnZXIpXCIpO2E+Pj49MDtpZigwPmF8fGErMj50aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrYStcIiAoKzIpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO31hPXRoaXMudmlldy5nZXRVaW50MTYoYSx0aGlzLmxpdHRsZUVuZGlhbik7YiYmKHRoaXMub2Zmc2V0Kz0yKTtyZXR1cm4gYX07ZC5wcm90b3R5cGUud3JpdGVJbnQzMj1mdW5jdGlvbihhLGIpe3ZhciBjPVwidW5kZWZpbmVkXCI9PT10eXBlb2YgYjtjJiYoYj10aGlzLm9mZnNldCk7aWYoIXRoaXMubm9Bc3NlcnQpe2lmKFwibnVtYmVyXCIhPT10eXBlb2YgYXx8MCE9PWElMSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCB2YWx1ZTogXCIrYStcIiAobm90IGFuIGludGVnZXIpXCIpO2F8PTA7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBifHwwIT09YiUxKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrXG5iK1wiIChub3QgYW4gaW50ZWdlcilcIik7Yj4+Pj0wO2lmKDA+Ynx8YiswPnRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitiK1wiICgrMCkgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7fWIrPTQ7dmFyIGU9dGhpcy5idWZmZXIuYnl0ZUxlbmd0aDtiPmUmJnRoaXMucmVzaXplKChlKj0yKT5iP2U6Yik7dGhpcy52aWV3LnNldEludDMyKGItNCxhLHRoaXMubGl0dGxlRW5kaWFuKTtjJiYodGhpcy5vZmZzZXQrPTQpO3JldHVybiB0aGlzfTtkLnByb3RvdHlwZS53cml0ZUludD1kLnByb3RvdHlwZS53cml0ZUludDMyO2QucHJvdG90eXBlLnJlYWRJbnQzMj1mdW5jdGlvbihhKXt2YXIgYj1cInVuZGVmaW5lZFwiPT09dHlwZW9mIGE7YiYmKGE9dGhpcy5vZmZzZXQpO2lmKCF0aGlzLm5vQXNzZXJ0KXtpZihcIm51bWJlclwiIT09dHlwZW9mIGF8fDAhPT1hJTEpdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitcbmErXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTthPj4+PTA7aWYoMD5hfHxhKzQ+dGhpcy5idWZmZXIuYnl0ZUxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK2ErXCIgKCs0KSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTt9YT10aGlzLnZpZXcuZ2V0SW50MzIoYSx0aGlzLmxpdHRsZUVuZGlhbik7YiYmKHRoaXMub2Zmc2V0Kz00KTtyZXR1cm4gYX07ZC5wcm90b3R5cGUucmVhZEludD1kLnByb3RvdHlwZS5yZWFkSW50MzI7ZC5wcm90b3R5cGUud3JpdGVVaW50MzI9ZnVuY3Rpb24oYSxiKXt2YXIgYz1cInVuZGVmaW5lZFwiPT09dHlwZW9mIGI7YyYmKGI9dGhpcy5vZmZzZXQpO2lmKCF0aGlzLm5vQXNzZXJ0KXtpZihcIm51bWJlclwiIT09dHlwZW9mIGF8fDAhPT1hJTEpdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgdmFsdWU6IFwiK2ErXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTthPj4+PTA7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBifHwwIT09YiUxKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrXG5iK1wiIChub3QgYW4gaW50ZWdlcilcIik7Yj4+Pj0wO2lmKDA+Ynx8YiswPnRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitiK1wiICgrMCkgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7fWIrPTQ7dmFyIGU9dGhpcy5idWZmZXIuYnl0ZUxlbmd0aDtiPmUmJnRoaXMucmVzaXplKChlKj0yKT5iP2U6Yik7dGhpcy52aWV3LnNldFVpbnQzMihiLTQsYSx0aGlzLmxpdHRsZUVuZGlhbik7YyYmKHRoaXMub2Zmc2V0Kz00KTtyZXR1cm4gdGhpc307ZC5wcm90b3R5cGUucmVhZFVpbnQzMj1mdW5jdGlvbihhKXt2YXIgYj1cInVuZGVmaW5lZFwiPT09dHlwZW9mIGE7YiYmKGE9dGhpcy5vZmZzZXQpO2lmKCF0aGlzLm5vQXNzZXJ0KXtpZihcIm51bWJlclwiIT09dHlwZW9mIGF8fDAhPT1hJTEpdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIithK1wiIChub3QgYW4gaW50ZWdlcilcIik7YT4+Pj0wO2lmKDA+YXx8XG5hKzQ+dGhpcy5idWZmZXIuYnl0ZUxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK2ErXCIgKCs0KSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTt9YT10aGlzLnZpZXcuZ2V0VWludDMyKGEsdGhpcy5saXR0bGVFbmRpYW4pO2ImJih0aGlzLm9mZnNldCs9NCk7cmV0dXJuIGF9O2wmJihkLnByb3RvdHlwZS53cml0ZUludDY0PWZ1bmN0aW9uKGEsYil7dmFyIGM9XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBiO2MmJihiPXRoaXMub2Zmc2V0KTtpZighdGhpcy5ub0Fzc2VydCl7aWYoXCJudW1iZXJcIj09PXR5cGVvZiBhKWE9bC5mcm9tTnVtYmVyKGEpO2Vsc2UgaWYoIShhJiZhIGluc3RhbmNlb2YgbCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgdmFsdWU6IFwiK2ErXCIgKG5vdCBhbiBpbnRlZ2VyIG9yIExvbmcpXCIpO2lmKFwibnVtYmVyXCIhPT10eXBlb2YgYnx8MCE9PWIlMSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK1xuYitcIiAobm90IGFuIGludGVnZXIpXCIpO2I+Pj49MDtpZigwPmJ8fGIrMD50aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrYitcIiAoKzApIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO31cIm51bWJlclwiPT09dHlwZW9mIGEmJihhPWwuZnJvbU51bWJlcihhKSk7Yis9ODt2YXIgZT10aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoO2I+ZSYmdGhpcy5yZXNpemUoKGUqPTIpPmI/ZTpiKTtiLT04O3RoaXMubGl0dGxlRW5kaWFuPyh0aGlzLnZpZXcuc2V0SW50MzIoYixhLmxvdywhMCksdGhpcy52aWV3LnNldEludDMyKGIrNCxhLmhpZ2gsITApKToodGhpcy52aWV3LnNldEludDMyKGIsYS5oaWdoLCExKSx0aGlzLnZpZXcuc2V0SW50MzIoYis0LGEubG93LCExKSk7YyYmKHRoaXMub2Zmc2V0Kz04KTtyZXR1cm4gdGhpc30sZC5wcm90b3R5cGUud3JpdGVMb25nPWQucHJvdG90eXBlLndyaXRlSW50NjQsZC5wcm90b3R5cGUucmVhZEludDY0PVxuZnVuY3Rpb24oYSl7dmFyIGI9XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBhO2ImJihhPXRoaXMub2Zmc2V0KTtpZighdGhpcy5ub0Fzc2VydCl7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBhfHwwIT09YSUxKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrYStcIiAobm90IGFuIGludGVnZXIpXCIpO2E+Pj49MDtpZigwPmF8fGErOD50aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrYStcIiAoKzgpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO31hPXRoaXMubGl0dGxlRW5kaWFuP25ldyBsKHRoaXMudmlldy5nZXRJbnQzMihhLCEwKSx0aGlzLnZpZXcuZ2V0SW50MzIoYSs0LCEwKSwhMSk6bmV3IGwodGhpcy52aWV3LmdldEludDMyKGErNCwhMSksdGhpcy52aWV3LmdldEludDMyKGEsITEpLCExKTtiJiYodGhpcy5vZmZzZXQrPTgpO3JldHVybiBhfSxkLnByb3RvdHlwZS5yZWFkTG9uZz1kLnByb3RvdHlwZS5yZWFkSW50NjQsXG5kLnByb3RvdHlwZS53cml0ZVVpbnQ2ND1mdW5jdGlvbihhLGIpe3ZhciBjPVwidW5kZWZpbmVkXCI9PT10eXBlb2YgYjtjJiYoYj10aGlzLm9mZnNldCk7aWYoIXRoaXMubm9Bc3NlcnQpe2lmKFwibnVtYmVyXCI9PT10eXBlb2YgYSlhPWwuZnJvbU51bWJlcihhKTtlbHNlIGlmKCEoYSYmYSBpbnN0YW5jZW9mIGwpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIHZhbHVlOiBcIithK1wiIChub3QgYW4gaW50ZWdlciBvciBMb25nKVwiKTtpZihcIm51bWJlclwiIT09dHlwZW9mIGJ8fDAhPT1iJTEpdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitiK1wiIChub3QgYW4gaW50ZWdlcilcIik7Yj4+Pj0wO2lmKDA+Ynx8YiswPnRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitiK1wiICgrMCkgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7fVwibnVtYmVyXCI9PT10eXBlb2YgYSYmKGE9bC5mcm9tTnVtYmVyKGEpKTtcbmIrPTg7dmFyIGU9dGhpcy5idWZmZXIuYnl0ZUxlbmd0aDtiPmUmJnRoaXMucmVzaXplKChlKj0yKT5iP2U6Yik7Yi09ODt0aGlzLmxpdHRsZUVuZGlhbj8odGhpcy52aWV3LnNldEludDMyKGIsYS5sb3csITApLHRoaXMudmlldy5zZXRJbnQzMihiKzQsYS5oaWdoLCEwKSk6KHRoaXMudmlldy5zZXRJbnQzMihiLGEuaGlnaCwhMSksdGhpcy52aWV3LnNldEludDMyKGIrNCxhLmxvdywhMSkpO2MmJih0aGlzLm9mZnNldCs9OCk7cmV0dXJuIHRoaXN9LGQucHJvdG90eXBlLnJlYWRVaW50NjQ9ZnVuY3Rpb24oYSl7dmFyIGI9XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBhO2ImJihhPXRoaXMub2Zmc2V0KTtpZighdGhpcy5ub0Fzc2VydCl7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBhfHwwIT09YSUxKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrYStcIiAobm90IGFuIGludGVnZXIpXCIpO2E+Pj49MDtpZigwPmF8fGErOD50aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrXG5hK1wiICgrOCkgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7fWE9dGhpcy5saXR0bGVFbmRpYW4/bmV3IGwodGhpcy52aWV3LmdldEludDMyKGEsITApLHRoaXMudmlldy5nZXRJbnQzMihhKzQsITApLCEwKTpuZXcgbCh0aGlzLnZpZXcuZ2V0SW50MzIoYSs0LCExKSx0aGlzLnZpZXcuZ2V0SW50MzIoYSwhMSksITApO2ImJih0aGlzLm9mZnNldCs9OCk7cmV0dXJuIGF9KTtkLnByb3RvdHlwZS53cml0ZUZsb2F0MzI9ZnVuY3Rpb24oYSxiKXt2YXIgYz1cInVuZGVmaW5lZFwiPT09dHlwZW9mIGI7YyYmKGI9dGhpcy5vZmZzZXQpO2lmKCF0aGlzLm5vQXNzZXJ0KXtpZihcIm51bWJlclwiIT09dHlwZW9mIGEpdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgdmFsdWU6IFwiK2ErXCIgKG5vdCBhIG51bWJlcilcIik7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBifHwwIT09YiUxKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrYitcIiAobm90IGFuIGludGVnZXIpXCIpO2I+Pj49XG4wO2lmKDA+Ynx8YiswPnRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitiK1wiICgrMCkgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7fWIrPTQ7dmFyIGU9dGhpcy5idWZmZXIuYnl0ZUxlbmd0aDtiPmUmJnRoaXMucmVzaXplKChlKj0yKT5iP2U6Yik7dGhpcy52aWV3LnNldEZsb2F0MzIoYi00LGEsdGhpcy5saXR0bGVFbmRpYW4pO2MmJih0aGlzLm9mZnNldCs9NCk7cmV0dXJuIHRoaXN9O2QucHJvdG90eXBlLndyaXRlRmxvYXQ9ZC5wcm90b3R5cGUud3JpdGVGbG9hdDMyO2QucHJvdG90eXBlLnJlYWRGbG9hdDMyPWZ1bmN0aW9uKGEpe3ZhciBiPVwidW5kZWZpbmVkXCI9PT10eXBlb2YgYTtiJiYoYT10aGlzLm9mZnNldCk7aWYoIXRoaXMubm9Bc3NlcnQpe2lmKFwibnVtYmVyXCIhPT10eXBlb2YgYXx8MCE9PWElMSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK2ErXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbmE+Pj49MDtpZigwPmF8fGErND50aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrYStcIiAoKzQpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO31hPXRoaXMudmlldy5nZXRGbG9hdDMyKGEsdGhpcy5saXR0bGVFbmRpYW4pO2ImJih0aGlzLm9mZnNldCs9NCk7cmV0dXJuIGF9O2QucHJvdG90eXBlLnJlYWRGbG9hdD1kLnByb3RvdHlwZS5yZWFkRmxvYXQzMjtkLnByb3RvdHlwZS53cml0ZUZsb2F0NjQ9ZnVuY3Rpb24oYSxiKXt2YXIgYz1cInVuZGVmaW5lZFwiPT09dHlwZW9mIGI7YyYmKGI9dGhpcy5vZmZzZXQpO2lmKCF0aGlzLm5vQXNzZXJ0KXtpZihcIm51bWJlclwiIT09dHlwZW9mIGEpdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgdmFsdWU6IFwiK2ErXCIgKG5vdCBhIG51bWJlcilcIik7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBifHwwIT09YiUxKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrXG5iK1wiIChub3QgYW4gaW50ZWdlcilcIik7Yj4+Pj0wO2lmKDA+Ynx8YiswPnRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitiK1wiICgrMCkgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7fWIrPTg7dmFyIGU9dGhpcy5idWZmZXIuYnl0ZUxlbmd0aDtiPmUmJnRoaXMucmVzaXplKChlKj0yKT5iP2U6Yik7dGhpcy52aWV3LnNldEZsb2F0NjQoYi04LGEsdGhpcy5saXR0bGVFbmRpYW4pO2MmJih0aGlzLm9mZnNldCs9OCk7cmV0dXJuIHRoaXN9O2QucHJvdG90eXBlLndyaXRlRG91YmxlPWQucHJvdG90eXBlLndyaXRlRmxvYXQ2NDtkLnByb3RvdHlwZS5yZWFkRmxvYXQ2ND1mdW5jdGlvbihhKXt2YXIgYj1cInVuZGVmaW5lZFwiPT09dHlwZW9mIGE7YiYmKGE9dGhpcy5vZmZzZXQpO2lmKCF0aGlzLm5vQXNzZXJ0KXtpZihcIm51bWJlclwiIT09dHlwZW9mIGF8fDAhPT1hJTEpdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitcbmErXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTthPj4+PTA7aWYoMD5hfHxhKzg+dGhpcy5idWZmZXIuYnl0ZUxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK2ErXCIgKCs4KSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTt9YT10aGlzLnZpZXcuZ2V0RmxvYXQ2NChhLHRoaXMubGl0dGxlRW5kaWFuKTtiJiYodGhpcy5vZmZzZXQrPTgpO3JldHVybiBhfTtkLnByb3RvdHlwZS5yZWFkRG91YmxlPWQucHJvdG90eXBlLnJlYWRGbG9hdDY0O2QuTUFYX1ZBUklOVDMyX0JZVEVTPTU7ZC5jYWxjdWxhdGVWYXJpbnQzMj1mdW5jdGlvbihhKXthPj4+PTA7cmV0dXJuIDEyOD5hPzE6MTYzODQ+YT8yOjIwOTcxNTI+YT8zOjI2ODQzNTQ1Nj5hPzQ6NX07ZC56aWdaYWdFbmNvZGUzMj1mdW5jdGlvbihhKXtyZXR1cm4oKGF8PTApPDwxXmE+PjMxKT4+PjB9O2QuemlnWmFnRGVjb2RlMzI9ZnVuY3Rpb24oYSl7cmV0dXJuIGE+Pj4xXi0oYSYxKXwwfTtkLnByb3RvdHlwZS53cml0ZVZhcmludDMyPVxuZnVuY3Rpb24oYSxiKXt2YXIgYz1cInVuZGVmaW5lZFwiPT09dHlwZW9mIGI7YyYmKGI9dGhpcy5vZmZzZXQpO2lmKCF0aGlzLm5vQXNzZXJ0KXtpZihcIm51bWJlclwiIT09dHlwZW9mIGF8fDAhPT1hJTEpdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgdmFsdWU6IFwiK2ErXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTthfD0wO2lmKFwibnVtYmVyXCIhPT10eXBlb2YgYnx8MCE9PWIlMSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK2IrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtiPj4+PTA7aWYoMD5ifHxiKzA+dGhpcy5idWZmZXIuYnl0ZUxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK2IrXCIgKCswKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTt9dmFyIGU9ZC5jYWxjdWxhdGVWYXJpbnQzMihhKTtiKz1lO3ZhciBoPXRoaXMuYnVmZmVyLmJ5dGVMZW5ndGg7Yj5oJiZ0aGlzLnJlc2l6ZSgoaCo9Mik+Yj9oOmIpO2ItPWU7dGhpcy52aWV3LnNldFVpbnQ4KGIsXG5lPWF8MTI4KTthPj4+PTA7MTI4PD1hPyhlPWE+Pjd8MTI4LHRoaXMudmlldy5zZXRVaW50OChiKzEsZSksMTYzODQ8PWE/KGU9YT4+MTR8MTI4LHRoaXMudmlldy5zZXRVaW50OChiKzIsZSksMjA5NzE1Mjw9YT8oZT1hPj4yMXwxMjgsdGhpcy52aWV3LnNldFVpbnQ4KGIrMyxlKSwyNjg0MzU0NTY8PWE/KHRoaXMudmlldy5zZXRVaW50OChiKzQsYT4+MjgmMTUpLGU9NSk6KHRoaXMudmlldy5zZXRVaW50OChiKzMsZSYxMjcpLGU9NCkpOih0aGlzLnZpZXcuc2V0VWludDgoYisyLGUmMTI3KSxlPTMpKToodGhpcy52aWV3LnNldFVpbnQ4KGIrMSxlJjEyNyksZT0yKSk6KHRoaXMudmlldy5zZXRVaW50OChiLGUmMTI3KSxlPTEpO3JldHVybiBjPyh0aGlzLm9mZnNldCs9ZSx0aGlzKTplfTtkLnByb3RvdHlwZS53cml0ZVZhcmludDMyWmlnWmFnPWZ1bmN0aW9uKGEsYil7cmV0dXJuIHRoaXMud3JpdGVWYXJpbnQzMihkLnppZ1phZ0VuY29kZTMyKGEpLGIpfTtkLnByb3RvdHlwZS5yZWFkVmFyaW50MzI9XG5mdW5jdGlvbihhKXt2YXIgYj1cInVuZGVmaW5lZFwiPT09dHlwZW9mIGE7YiYmKGE9dGhpcy5vZmZzZXQpO2lmKCF0aGlzLm5vQXNzZXJ0KXtpZihcIm51bWJlclwiIT09dHlwZW9mIGF8fDAhPT1hJTEpdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIithK1wiIChub3QgYW4gaW50ZWdlcilcIik7YT4+Pj0wO2lmKDA+YXx8YSsxPnRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIithK1wiICgrMSkgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7fXZhciBjPTAsZT0wLGQ7ZG8gZD10aGlzLnZpZXcuZ2V0VWludDgoYStjKSw1PmMmJihlfD0oZCYxMjcpPDw3KmM+Pj4wKSwrK2M7d2hpbGUoMTI4PT09KGQmMTI4KSk7ZXw9MDtyZXR1cm4gYj8odGhpcy5vZmZzZXQrPWMsZSk6e3ZhbHVlOmUsbGVuZ3RoOmN9fTtkLnByb3RvdHlwZS5yZWFkVmFyaW50MzJaaWdaYWc9ZnVuY3Rpb24oYSl7YT10aGlzLnJlYWRWYXJpbnQzMihhKTtcblwib2JqZWN0XCI9PT10eXBlb2YgYT9hLnZhbHVlPWQuemlnWmFnRGVjb2RlMzIoYS52YWx1ZSk6YT1kLnppZ1phZ0RlY29kZTMyKGEpO3JldHVybiBhfTtsJiYoZC5NQVhfVkFSSU5UNjRfQllURVM9MTAsZC5jYWxjdWxhdGVWYXJpbnQ2ND1mdW5jdGlvbihhKXtcIm51bWJlclwiPT09dHlwZW9mIGEmJihhPWwuZnJvbU51bWJlcihhKSk7dmFyIGI9YS50b0ludCgpPj4+MCxjPWEuc2hpZnRSaWdodFVuc2lnbmVkKDI4KS50b0ludCgpPj4+MDthPWEuc2hpZnRSaWdodFVuc2lnbmVkKDU2KS50b0ludCgpPj4+MDtyZXR1cm4gMD09YT8wPT1jPzE2Mzg0PmI/MTI4PmI/MToyOjIwOTcxNTI+Yj8zOjQ6MTYzODQ+Yz8xMjg+Yz81OjY6MjA5NzE1Mj5jPzc6ODoxMjg+YT85OjEwfSxkLnppZ1phZ0VuY29kZTY0PWZ1bmN0aW9uKGEpe1wibnVtYmVyXCI9PT10eXBlb2YgYT9hPWwuZnJvbU51bWJlcihhLCExKTohMSE9PWEudW5zaWduZWQmJihhPWEudG9TaWduZWQoKSk7cmV0dXJuIGEuc2hpZnRMZWZ0KDEpLnhvcihhLnNoaWZ0UmlnaHQoNjMpKS50b1Vuc2lnbmVkKCl9LFxuZC56aWdaYWdEZWNvZGU2ND1mdW5jdGlvbihhKXtcIm51bWJlclwiPT09dHlwZW9mIGE/YT1sLmZyb21OdW1iZXIoYSwhMSk6ITEhPT1hLnVuc2lnbmVkJiYoYT1hLnRvU2lnbmVkKCkpO3JldHVybiBhLnNoaWZ0UmlnaHRVbnNpZ25lZCgxKS54b3IoYS5hbmQobC5PTkUpLnRvU2lnbmVkKCkubmVnYXRlKCkpLnRvU2lnbmVkKCl9LGQucHJvdG90eXBlLndyaXRlVmFyaW50NjQ9ZnVuY3Rpb24oYSxiKXt2YXIgYz1cInVuZGVmaW5lZFwiPT09dHlwZW9mIGI7YyYmKGI9dGhpcy5vZmZzZXQpO2lmKCF0aGlzLm5vQXNzZXJ0KXtpZihcIm51bWJlclwiPT09dHlwZW9mIGEpYT1sLmZyb21OdW1iZXIoYSk7ZWxzZSBpZighKGEmJmEgaW5zdGFuY2VvZiBsKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCB2YWx1ZTogXCIrYStcIiAobm90IGFuIGludGVnZXIgb3IgTG9uZylcIik7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBifHwwIT09YiUxKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrXG5iK1wiIChub3QgYW4gaW50ZWdlcilcIik7Yj4+Pj0wO2lmKDA+Ynx8YiswPnRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitiK1wiICgrMCkgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7fVwibnVtYmVyXCI9PT10eXBlb2YgYT9hPWwuZnJvbU51bWJlcihhLCExKTohMSE9PWEudW5zaWduZWQmJihhPWEudG9TaWduZWQoKSk7dmFyIGU9ZC5jYWxjdWxhdGVWYXJpbnQ2NChhKSxoPWEudG9JbnQoKT4+PjAsZj1hLnNoaWZ0UmlnaHRVbnNpZ25lZCgyOCkudG9JbnQoKT4+PjAsZz1hLnNoaWZ0UmlnaHRVbnNpZ25lZCg1NikudG9JbnQoKT4+PjA7Yis9ZTt2YXIgbj10aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoO2I+biYmdGhpcy5yZXNpemUoKG4qPTIpPmI/bjpiKTtiLT1lO3N3aXRjaChlKXtjYXNlIDEwOnRoaXMudmlldy5zZXRVaW50OChiKzksZz4+PjcmMSk7Y2FzZSA5OnRoaXMudmlldy5zZXRVaW50OChiKzgsOSE9PVxuZT9nfDEyODpnJjEyNyk7Y2FzZSA4OnRoaXMudmlldy5zZXRVaW50OChiKzcsOCE9PWU/Zj4+PjIxfDEyODpmPj4+MjEmMTI3KTtjYXNlIDc6dGhpcy52aWV3LnNldFVpbnQ4KGIrNiw3IT09ZT9mPj4+MTR8MTI4OmY+Pj4xNCYxMjcpO2Nhc2UgNjp0aGlzLnZpZXcuc2V0VWludDgoYis1LDYhPT1lP2Y+Pj43fDEyODpmPj4+NyYxMjcpO2Nhc2UgNTp0aGlzLnZpZXcuc2V0VWludDgoYis0LDUhPT1lP2Z8MTI4OmYmMTI3KTtjYXNlIDQ6dGhpcy52aWV3LnNldFVpbnQ4KGIrMyw0IT09ZT9oPj4+MjF8MTI4Omg+Pj4yMSYxMjcpO2Nhc2UgMzp0aGlzLnZpZXcuc2V0VWludDgoYisyLDMhPT1lP2g+Pj4xNHwxMjg6aD4+PjE0JjEyNyk7Y2FzZSAyOnRoaXMudmlldy5zZXRVaW50OChiKzEsMiE9PWU/aD4+Pjd8MTI4Omg+Pj43JjEyNyk7Y2FzZSAxOnRoaXMudmlldy5zZXRVaW50OChiLDEhPT1lP2h8MTI4OmgmMTI3KX1yZXR1cm4gYz8odGhpcy5vZmZzZXQrPWUsdGhpcyk6ZX0sZC5wcm90b3R5cGUud3JpdGVWYXJpbnQ2NFppZ1phZz1cbmZ1bmN0aW9uKGEsYil7cmV0dXJuIHRoaXMud3JpdGVWYXJpbnQ2NChkLnppZ1phZ0VuY29kZTY0KGEpLGIpfSxkLnByb3RvdHlwZS5yZWFkVmFyaW50NjQ9ZnVuY3Rpb24oYSl7dmFyIGI9XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBhO2ImJihhPXRoaXMub2Zmc2V0KTtpZighdGhpcy5ub0Fzc2VydCl7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBhfHwwIT09YSUxKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrYStcIiAobm90IGFuIGludGVnZXIpXCIpO2E+Pj49MDtpZigwPmF8fGErMT50aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrYStcIiAoKzEpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO312YXIgYz1hLGU9MCxkPTAsZj0wLGc9MCxnPXRoaXMudmlldy5nZXRVaW50OChhKyspLGU9ZyYxMjc7aWYoZyYxMjgmJihnPXRoaXMudmlldy5nZXRVaW50OChhKyspLGV8PShnJjEyNyk8PDcsZyYxMjgmJlxuKGc9dGhpcy52aWV3LmdldFVpbnQ4KGErKyksZXw9KGcmMTI3KTw8MTQsZyYxMjgmJihnPXRoaXMudmlldy5nZXRVaW50OChhKyspLGV8PShnJjEyNyk8PDIxLGcmMTI4JiYoZz10aGlzLnZpZXcuZ2V0VWludDgoYSsrKSxkPWcmMTI3LGcmMTI4JiYoZz10aGlzLnZpZXcuZ2V0VWludDgoYSsrKSxkfD0oZyYxMjcpPDw3LGcmMTI4JiYoZz10aGlzLnZpZXcuZ2V0VWludDgoYSsrKSxkfD0oZyYxMjcpPDwxNCxnJjEyOCYmKGc9dGhpcy52aWV3LmdldFVpbnQ4KGErKyksZHw9KGcmMTI3KTw8MjEsZyYxMjgmJihnPXRoaXMudmlldy5nZXRVaW50OChhKyspLGY9ZyYxMjcsZyYxMjgmJihnPXRoaXMudmlldy5nZXRVaW50OChhKyspLGZ8PShnJjEyNyk8PDcsZyYxMjgpKSkpKSkpKSkpdGhyb3cgRXJyb3IoXCJEYXRhIG11c3QgYmUgY29ycnVwdDogQnVmZmVyIG92ZXJydW5cIik7ZT1sLmZyb20yOEJpdHMoZSxkLGYsITEpO3JldHVybiBiPyh0aGlzLm9mZnNldD1hLGUpOnt2YWx1ZTplLGxlbmd0aDphLVxuY319LGQucHJvdG90eXBlLnJlYWRWYXJpbnQ2NFppZ1phZz1mdW5jdGlvbihhKXsoYT10aGlzLnJlYWRWYXJpbnQ2NChhKSkmJmEudmFsdWUgaW5zdGFuY2VvZiBsP2EudmFsdWU9ZC56aWdaYWdEZWNvZGU2NChhLnZhbHVlKTphPWQuemlnWmFnRGVjb2RlNjQoYSk7cmV0dXJuIGF9KTtkLnByb3RvdHlwZS53cml0ZUNTdHJpbmc9ZnVuY3Rpb24oYSxiKXt2YXIgYz1cInVuZGVmaW5lZFwiPT09dHlwZW9mIGI7YyYmKGI9dGhpcy5vZmZzZXQpO3ZhciBlLGQ9YS5sZW5ndGg7aWYoIXRoaXMubm9Bc3NlcnQpe2lmKFwic3RyaW5nXCIhPT10eXBlb2YgYSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBzdHI6IE5vdCBhIHN0cmluZ1wiKTtmb3IoZT0wO2U8ZDsrK2UpaWYoMD09PWEuY2hhckNvZGVBdChlKSl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIklsbGVnYWwgc3RyOiBDb250YWlucyBOVUxMLWNoYXJhY3RlcnNcIik7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBifHwwIT09YiUxKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrXG5iK1wiIChub3QgYW4gaW50ZWdlcilcIik7Yj4+Pj0wO2lmKDA+Ynx8YiswPnRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitiK1wiICgrMCkgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7fWU9YjtkPWsuYihrLmEoYSkpWzFdO2IrPWQrMTt2YXIgZj10aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoO2I+ZiYmdGhpcy5yZXNpemUoKGYqPTIpPmI/ZjpiKTtiLT1kKzE7ay5lKGsuYShhKSxmdW5jdGlvbihhKXt0aGlzLnZpZXcuc2V0VWludDgoYisrLGEpfS5iaW5kKHRoaXMpKTt0aGlzLnZpZXcuc2V0VWludDgoYisrLDApO3JldHVybiBjPyh0aGlzLm9mZnNldD1iLWUsdGhpcyk6ZH07ZC5wcm90b3R5cGUucmVhZENTdHJpbmc9ZnVuY3Rpb24oYSl7dmFyIGI9XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBhO2ImJihhPXRoaXMub2Zmc2V0KTtpZighdGhpcy5ub0Fzc2VydCl7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBhfHwwIT09YSUxKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrXG5hK1wiIChub3QgYW4gaW50ZWdlcilcIik7YT4+Pj0wO2lmKDA+YXx8YSsxPnRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIithK1wiICgrMSkgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7fXZhciBjPWEsZSxkPS0xO2suZChmdW5jdGlvbigpe2lmKDA9PT1kKXJldHVybiBudWxsO2lmKGE+PXRoaXMubGltaXQpdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgcmFuZ2U6IFRydW5jYXRlZCBkYXRhLCBcIithK1wiIDwgXCIrdGhpcy5saW1pdCk7cmV0dXJuIDA9PT0oZD10aGlzLnZpZXcuZ2V0VWludDgoYSsrKSk/bnVsbDpkfS5iaW5kKHRoaXMpLGU9ay5jKCksITApO3JldHVybiBiPyh0aGlzLm9mZnNldD1hLGUoKSk6e3N0cmluZzplKCksbGVuZ3RoOmEtY319O2QucHJvdG90eXBlLndyaXRlSVN0cmluZz1mdW5jdGlvbihhLGIpe3ZhciBjPVwidW5kZWZpbmVkXCI9PT10eXBlb2YgYjtjJiYoYj10aGlzLm9mZnNldCk7aWYoIXRoaXMubm9Bc3NlcnQpe2lmKFwic3RyaW5nXCIhPT1cbnR5cGVvZiBhKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIHN0cjogTm90IGEgc3RyaW5nXCIpO2lmKFwibnVtYmVyXCIhPT10eXBlb2YgYnx8MCE9PWIlMSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK2IrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtiPj4+PTA7aWYoMD5ifHxiKzA+dGhpcy5idWZmZXIuYnl0ZUxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK2IrXCIgKCswKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTt9dmFyIGU9YixkO2Q9ay5iKGsuYShhKSx0aGlzLm5vQXNzZXJ0KVsxXTtiKz00K2Q7dmFyIGY9dGhpcy5idWZmZXIuYnl0ZUxlbmd0aDtiPmYmJnRoaXMucmVzaXplKChmKj0yKT5iP2Y6Yik7Yi09NCtkO3RoaXMudmlldy5zZXRVaW50MzIoYixkLHRoaXMubGl0dGxlRW5kaWFuKTtiKz00O2suZShrLmEoYSksZnVuY3Rpb24oYSl7dGhpcy52aWV3LnNldFVpbnQ4KGIrKyxhKX0uYmluZCh0aGlzKSk7XG5pZihiIT09ZSs0K2QpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIHJhbmdlOiBUcnVuY2F0ZWQgZGF0YSwgXCIrYitcIiA9PSBcIisoYis0K2QpKTtyZXR1cm4gYz8odGhpcy5vZmZzZXQ9Yix0aGlzKTpiLWV9O2QucHJvdG90eXBlLnJlYWRJU3RyaW5nPWZ1bmN0aW9uKGEpe3ZhciBiPVwidW5kZWZpbmVkXCI9PT10eXBlb2YgYTtiJiYoYT10aGlzLm9mZnNldCk7aWYoIXRoaXMubm9Bc3NlcnQpe2lmKFwibnVtYmVyXCIhPT10eXBlb2YgYXx8MCE9PWElMSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK2ErXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTthPj4+PTA7aWYoMD5hfHxhKzQ+dGhpcy5idWZmZXIuYnl0ZUxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK2ErXCIgKCs0KSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTt9dmFyIGM9MCxlPWEsYz10aGlzLnZpZXcuZ2V0VWludDMyKGEsdGhpcy5saXR0bGVFbmRpYW4pO2ErPVxuNDt2YXIgZD1hK2M7ay5kKGZ1bmN0aW9uKCl7cmV0dXJuIGE8ZD90aGlzLnZpZXcuZ2V0VWludDgoYSsrKTpudWxsfS5iaW5kKHRoaXMpLGM9ay5jKCksdGhpcy5ub0Fzc2VydCk7Yz1jKCk7cmV0dXJuIGI/KHRoaXMub2Zmc2V0PWEsYyk6e3N0cmluZzpjLGxlbmd0aDphLWV9fTtkLk1FVFJJQ1NfQ0hBUlM9XCJjXCI7ZC5NRVRSSUNTX0JZVEVTPVwiYlwiO2QucHJvdG90eXBlLndyaXRlVVRGOFN0cmluZz1mdW5jdGlvbihhLGIpe3ZhciBjPVwidW5kZWZpbmVkXCI9PT10eXBlb2YgYjtjJiYoYj10aGlzLm9mZnNldCk7aWYoIXRoaXMubm9Bc3NlcnQpe2lmKFwibnVtYmVyXCIhPT10eXBlb2YgYnx8MCE9PWIlMSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK2IrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtiPj4+PTA7aWYoMD5ifHxiKzA+dGhpcy5idWZmZXIuYnl0ZUxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK2IrXCIgKCswKSA8PSBcIitcbnRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO312YXIgZSxkPWI7ZT1rLmIoay5hKGEpKVsxXTtiKz1lO3ZhciBmPXRoaXMuYnVmZmVyLmJ5dGVMZW5ndGg7Yj5mJiZ0aGlzLnJlc2l6ZSgoZio9Mik+Yj9mOmIpO2ItPWU7ay5lKGsuYShhKSxmdW5jdGlvbihhKXt0aGlzLnZpZXcuc2V0VWludDgoYisrLGEpfS5iaW5kKHRoaXMpKTtyZXR1cm4gYz8odGhpcy5vZmZzZXQ9Yix0aGlzKTpiLWR9O2QucHJvdG90eXBlLndyaXRlU3RyaW5nPWQucHJvdG90eXBlLndyaXRlVVRGOFN0cmluZztkLmNhbGN1bGF0ZVVURjhDaGFycz1mdW5jdGlvbihhKXtyZXR1cm4gay5iKGsuYShhKSlbMF19O2QuY2FsY3VsYXRlVVRGOEJ5dGVzPWZ1bmN0aW9uKGEpe3JldHVybiBrLmIoay5hKGEpKVsxXX07ZC5wcm90b3R5cGUucmVhZFVURjhTdHJpbmc9ZnVuY3Rpb24oYSxiLGMpe1wibnVtYmVyXCI9PT10eXBlb2YgYiYmKGM9YixiPXZvaWQgMCk7dmFyIGU9XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBjO2UmJihjPXRoaXMub2Zmc2V0KTtcblwidW5kZWZpbmVkXCI9PT10eXBlb2YgYiYmKGI9ZC5NRVRSSUNTX0NIQVJTKTtpZighdGhpcy5ub0Fzc2VydCl7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBhfHwwIT09YSUxKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGxlbmd0aDogXCIrYStcIiAobm90IGFuIGludGVnZXIpXCIpO2F8PTA7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBjfHwwIT09YyUxKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrYytcIiAobm90IGFuIGludGVnZXIpXCIpO2M+Pj49MDtpZigwPmN8fGMrMD50aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrYytcIiAoKzApIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO312YXIgaD0wLGY9YyxnO2lmKGI9PT1kLk1FVFJJQ1NfQ0hBUlMpe2c9ay5jKCk7ay5pKGZ1bmN0aW9uKCl7cmV0dXJuIGg8YSYmYzx0aGlzLmxpbWl0P3RoaXMudmlldy5nZXRVaW50OChjKyspOm51bGx9LmJpbmQodGhpcyksXG5mdW5jdGlvbihhKXsrK2g7ay5nKGEsZyl9LmJpbmQodGhpcykpO2lmKGghPT1hKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSWxsZWdhbCByYW5nZTogVHJ1bmNhdGVkIGRhdGEsIFwiK2grXCIgPT0gXCIrYSk7cmV0dXJuIGU/KHRoaXMub2Zmc2V0PWMsZygpKTp7c3RyaW5nOmcoKSxsZW5ndGg6Yy1mfX1pZihiPT09ZC5NRVRSSUNTX0JZVEVTKXtpZighdGhpcy5ub0Fzc2VydCl7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBjfHwwIT09YyUxKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrYytcIiAobm90IGFuIGludGVnZXIpXCIpO2M+Pj49MDtpZigwPmN8fGMrYT50aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrYytcIiAoK1wiK2ErXCIpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO312YXIgbj1jK2E7ay5kKGZ1bmN0aW9uKCl7cmV0dXJuIGM8bj90aGlzLnZpZXcuZ2V0VWludDgoYysrKTpudWxsfS5iaW5kKHRoaXMpLFxuZz1rLmMoKSx0aGlzLm5vQXNzZXJ0KTtpZihjIT09bil0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIklsbGVnYWwgcmFuZ2U6IFRydW5jYXRlZCBkYXRhLCBcIitjK1wiID09IFwiK24pO3JldHVybiBlPyh0aGlzLm9mZnNldD1jLGcoKSk6e3N0cmluZzpnKCksbGVuZ3RoOmMtZn19dGhyb3cgbmV3IFR5cGVFcnJvcihcIlVuc3VwcG9ydGVkIG1ldHJpY3M6IFwiK2IpO307ZC5wcm90b3R5cGUucmVhZFN0cmluZz1kLnByb3RvdHlwZS5yZWFkVVRGOFN0cmluZztkLnByb3RvdHlwZS53cml0ZVZTdHJpbmc9ZnVuY3Rpb24oYSxiKXt2YXIgYz1cInVuZGVmaW5lZFwiPT09dHlwZW9mIGI7YyYmKGI9dGhpcy5vZmZzZXQpO2lmKCF0aGlzLm5vQXNzZXJ0KXtpZihcInN0cmluZ1wiIT09dHlwZW9mIGEpdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgc3RyOiBOb3QgYSBzdHJpbmdcIik7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBifHwwIT09YiUxKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrYitcblwiIChub3QgYW4gaW50ZWdlcilcIik7Yj4+Pj0wO2lmKDA+Ynx8YiswPnRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitiK1wiICgrMCkgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7fXZhciBlPWIsaCxmO2g9ay5iKGsuYShhKSx0aGlzLm5vQXNzZXJ0KVsxXTtmPWQuY2FsY3VsYXRlVmFyaW50MzIoaCk7Yis9ZitoO3ZhciBnPXRoaXMuYnVmZmVyLmJ5dGVMZW5ndGg7Yj5nJiZ0aGlzLnJlc2l6ZSgoZyo9Mik+Yj9nOmIpO2ItPWYraDtiKz10aGlzLndyaXRlVmFyaW50MzIoaCxiKTtrLmUoay5hKGEpLGZ1bmN0aW9uKGEpe3RoaXMudmlldy5zZXRVaW50OChiKyssYSl9LmJpbmQodGhpcykpO2lmKGIhPT1lK2grZil0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIklsbGVnYWwgcmFuZ2U6IFRydW5jYXRlZCBkYXRhLCBcIitiK1wiID09IFwiKyhiK2grZikpO3JldHVybiBjPyh0aGlzLm9mZnNldD1iLHRoaXMpOmItZX07ZC5wcm90b3R5cGUucmVhZFZTdHJpbmc9XG5mdW5jdGlvbihhKXt2YXIgYj1cInVuZGVmaW5lZFwiPT09dHlwZW9mIGE7YiYmKGE9dGhpcy5vZmZzZXQpO2lmKCF0aGlzLm5vQXNzZXJ0KXtpZihcIm51bWJlclwiIT09dHlwZW9mIGF8fDAhPT1hJTEpdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIithK1wiIChub3QgYW4gaW50ZWdlcilcIik7YT4+Pj0wO2lmKDA+YXx8YSsxPnRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIithK1wiICgrMSkgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7fXZhciBjPXRoaXMucmVhZFZhcmludDMyKGEpLGU9YTthKz1jLmxlbmd0aDt2YXIgYz1jLnZhbHVlLGQ9YStjLGM9ay5jKCk7ay5kKGZ1bmN0aW9uKCl7cmV0dXJuIGE8ZD90aGlzLnZpZXcuZ2V0VWludDgoYSsrKTpudWxsfS5iaW5kKHRoaXMpLGMsdGhpcy5ub0Fzc2VydCk7Yz1jKCk7cmV0dXJuIGI/KHRoaXMub2Zmc2V0PWEsYyk6e3N0cmluZzpjLGxlbmd0aDphLVxuZX19O2QucHJvdG90eXBlLmFwcGVuZD1mdW5jdGlvbihhLGIsYyl7aWYoXCJudW1iZXJcIj09PXR5cGVvZiBifHxcInN0cmluZ1wiIT09dHlwZW9mIGIpYz1iLGI9dm9pZCAwO3ZhciBlPVwidW5kZWZpbmVkXCI9PT10eXBlb2YgYztlJiYoYz10aGlzLm9mZnNldCk7aWYoIXRoaXMubm9Bc3NlcnQpe2lmKFwibnVtYmVyXCIhPT10eXBlb2YgY3x8MCE9PWMlMSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK2MrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtjPj4+PTA7aWYoMD5jfHxjKzA+dGhpcy5idWZmZXIuYnl0ZUxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK2MrXCIgKCswKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTt9YSBpbnN0YW5jZW9mIGR8fChhPWQud3JhcChhLGIpKTtiPWEubGltaXQtYS5vZmZzZXQ7aWYoMD49YilyZXR1cm4gdGhpcztjKz1iO3ZhciBoPXRoaXMuYnVmZmVyLmJ5dGVMZW5ndGg7Yz5oJiZ0aGlzLnJlc2l6ZSgoaCo9XG4yKT5jP2g6Yyk7KG5ldyBVaW50OEFycmF5KHRoaXMuYnVmZmVyLGMtYikpLnNldCgobmV3IFVpbnQ4QXJyYXkoYS5idWZmZXIpKS5zdWJhcnJheShhLm9mZnNldCxhLmxpbWl0KSk7YS5vZmZzZXQrPWI7ZSYmKHRoaXMub2Zmc2V0Kz1iKTtyZXR1cm4gdGhpc307ZC5wcm90b3R5cGUuYXBwZW5kVG89ZnVuY3Rpb24oYSxiKXthLmFwcGVuZCh0aGlzLGIpO3JldHVybiB0aGlzfTtkLnByb3RvdHlwZS5hc3NlcnQ9ZnVuY3Rpb24oYSl7dGhpcy5ub0Fzc2VydD0hYTtyZXR1cm4gdGhpc307ZC5wcm90b3R5cGUuY2FwYWNpdHk9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aH07ZC5wcm90b3R5cGUuY2xlYXI9ZnVuY3Rpb24oKXt0aGlzLm9mZnNldD0wO3RoaXMubGltaXQ9dGhpcy5idWZmZXIuYnl0ZUxlbmd0aDt0aGlzLm1hcmtlZE9mZnNldD0tMTtyZXR1cm4gdGhpc307ZC5wcm90b3R5cGUuY2xvbmU9ZnVuY3Rpb24oYSl7dmFyIGI9bmV3IGQoMCx0aGlzLmxpdHRsZUVuZGlhbixcbnRoaXMubm9Bc3NlcnQpO2E/KGE9bmV3IEFycmF5QnVmZmVyKHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpLChuZXcgVWludDhBcnJheShhKSkuc2V0KHRoaXMuYnVmZmVyKSxiLmJ1ZmZlcj1hLGIudmlldz1uZXcgRGF0YVZpZXcoYSkpOihiLmJ1ZmZlcj10aGlzLmJ1ZmZlcixiLnZpZXc9dGhpcy52aWV3KTtiLm9mZnNldD10aGlzLm9mZnNldDtiLm1hcmtlZE9mZnNldD10aGlzLm1hcmtlZE9mZnNldDtiLmxpbWl0PXRoaXMubGltaXQ7cmV0dXJuIGJ9O2QucHJvdG90eXBlLmNvbXBhY3Q9ZnVuY3Rpb24oYSxiKXtcInVuZGVmaW5lZFwiPT09dHlwZW9mIGEmJihhPXRoaXMub2Zmc2V0KTtcInVuZGVmaW5lZFwiPT09dHlwZW9mIGImJihiPXRoaXMubGltaXQpO2lmKCF0aGlzLm5vQXNzZXJ0KXtpZihcIm51bWJlclwiIT09dHlwZW9mIGF8fDAhPT1hJTEpdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgYmVnaW46IE5vdCBhbiBpbnRlZ2VyXCIpO2E+Pj49MDtpZihcIm51bWJlclwiIT09dHlwZW9mIGJ8fFxuMCE9PWIlMSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBlbmQ6IE5vdCBhbiBpbnRlZ2VyXCIpO2I+Pj49MDtpZigwPmF8fGE+Ynx8Yj50aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSWxsZWdhbCByYW5nZTogMCA8PSBcIithK1wiIDw9IFwiK2IrXCIgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7fWlmKDA9PT1hJiZiPT09dGhpcy5idWZmZXIuYnl0ZUxlbmd0aClyZXR1cm4gdGhpczt2YXIgYz1iLWE7aWYoMD09PWMpcmV0dXJuIHRoaXMuYnVmZmVyPXIsdGhpcy52aWV3PW51bGwsMDw9dGhpcy5tYXJrZWRPZmZzZXQmJih0aGlzLm1hcmtlZE9mZnNldC09YSksdGhpcy5saW1pdD10aGlzLm9mZnNldD0wLHRoaXM7dmFyIGU9bmV3IEFycmF5QnVmZmVyKGMpOyhuZXcgVWludDhBcnJheShlKSkuc2V0KChuZXcgVWludDhBcnJheSh0aGlzLmJ1ZmZlcikpLnN1YmFycmF5KGEsYikpO3RoaXMuYnVmZmVyPWU7dGhpcy52aWV3PW5ldyBEYXRhVmlldyhlKTtcbjA8PXRoaXMubWFya2VkT2Zmc2V0JiYodGhpcy5tYXJrZWRPZmZzZXQtPWEpO3RoaXMub2Zmc2V0PTA7dGhpcy5saW1pdD1jO3JldHVybiB0aGlzfTtkLnByb3RvdHlwZS5jb3B5PWZ1bmN0aW9uKGEsYil7XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBhJiYoYT10aGlzLm9mZnNldCk7XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBiJiYoYj10aGlzLmxpbWl0KTtpZighdGhpcy5ub0Fzc2VydCl7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBhfHwwIT09YSUxKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGJlZ2luOiBOb3QgYW4gaW50ZWdlclwiKTthPj4+PTA7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBifHwwIT09YiUxKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGVuZDogTm90IGFuIGludGVnZXJcIik7Yj4+Pj0wO2lmKDA+YXx8YT5ifHxiPnRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIHJhbmdlOiAwIDw9IFwiK2ErXCIgPD0gXCIrYitcIiA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbn1pZihhPT09YilyZXR1cm4gbmV3IGQoMCx0aGlzLmxpdHRsZUVuZGlhbix0aGlzLm5vQXNzZXJ0KTt2YXIgYz1iLWEsZT1uZXcgZChjLHRoaXMubGl0dGxlRW5kaWFuLHRoaXMubm9Bc3NlcnQpO2Uub2Zmc2V0PTA7ZS5saW1pdD1jOzA8PWUubWFya2VkT2Zmc2V0JiYoZS5tYXJrZWRPZmZzZXQtPWEpO3RoaXMuY29weVRvKGUsMCxhLGIpO3JldHVybiBlfTtkLnByb3RvdHlwZS5jb3B5VG89ZnVuY3Rpb24oYSxiLGMsZSl7dmFyIGgsZjtpZighdGhpcy5ub0Fzc2VydCYmIWQuaXNCeXRlQnVmZmVyKGEpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIHRhcmdldDogTm90IGEgQnl0ZUJ1ZmZlclwiKTtiPShmPVwidW5kZWZpbmVkXCI9PT10eXBlb2YgYik/YS5vZmZzZXQ6YnwwO2M9KGg9XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBjKT90aGlzLm9mZnNldDpjfDA7ZT1cInVuZGVmaW5lZFwiPT09dHlwZW9mIGU/dGhpcy5saW1pdDplfDA7aWYoMD5ifHxiPmEuYnVmZmVyLmJ5dGVMZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIHRhcmdldCByYW5nZTogMCA8PSBcIitcbmIrXCIgPD0gXCIrYS5idWZmZXIuYnl0ZUxlbmd0aCk7aWYoMD5jfHxlPnRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIHNvdXJjZSByYW5nZTogMCA8PSBcIitjK1wiIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO3ZhciBnPWUtYztpZigwPT09ZylyZXR1cm4gYTthLmVuc3VyZUNhcGFjaXR5KGIrZyk7KG5ldyBVaW50OEFycmF5KGEuYnVmZmVyKSkuc2V0KChuZXcgVWludDhBcnJheSh0aGlzLmJ1ZmZlcikpLnN1YmFycmF5KGMsZSksYik7aCYmKHRoaXMub2Zmc2V0Kz1nKTtmJiYoYS5vZmZzZXQrPWcpO3JldHVybiB0aGlzfTtkLnByb3RvdHlwZS5lbnN1cmVDYXBhY2l0eT1mdW5jdGlvbihhKXt2YXIgYj10aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoO3JldHVybiBiPGE/dGhpcy5yZXNpemUoKGIqPTIpPmE/YjphKTp0aGlzfTtkLnByb3RvdHlwZS5maWxsPWZ1bmN0aW9uKGEsYixjKXt2YXIgZT1cInVuZGVmaW5lZFwiPT09dHlwZW9mIGI7ZSYmXG4oYj10aGlzLm9mZnNldCk7XCJzdHJpbmdcIj09PXR5cGVvZiBhJiYwPGEubGVuZ3RoJiYoYT1hLmNoYXJDb2RlQXQoMCkpO1widW5kZWZpbmVkXCI9PT10eXBlb2YgYiYmKGI9dGhpcy5vZmZzZXQpO1widW5kZWZpbmVkXCI9PT10eXBlb2YgYyYmKGM9dGhpcy5saW1pdCk7aWYoIXRoaXMubm9Bc3NlcnQpe2lmKFwibnVtYmVyXCIhPT10eXBlb2YgYXx8MCE9PWElMSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCB2YWx1ZTogXCIrYStcIiAobm90IGFuIGludGVnZXIpXCIpO2F8PTA7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBifHwwIT09YiUxKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGJlZ2luOiBOb3QgYW4gaW50ZWdlclwiKTtiPj4+PTA7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBjfHwwIT09YyUxKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGVuZDogTm90IGFuIGludGVnZXJcIik7Yz4+Pj0wO2lmKDA+Ynx8Yj5jfHxjPnRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIHJhbmdlOiAwIDw9IFwiK1xuYitcIiA8PSBcIitjK1wiIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO31pZihiPj1jKXJldHVybiB0aGlzO2Zvcig7YjxjOyl0aGlzLnZpZXcuc2V0VWludDgoYisrLGEpO2UmJih0aGlzLm9mZnNldD1iKTtyZXR1cm4gdGhpc307ZC5wcm90b3R5cGUuZmxpcD1mdW5jdGlvbigpe3RoaXMubGltaXQ9dGhpcy5vZmZzZXQ7dGhpcy5vZmZzZXQ9MDtyZXR1cm4gdGhpc307ZC5wcm90b3R5cGUubWFyaz1mdW5jdGlvbihhKXthPVwidW5kZWZpbmVkXCI9PT10eXBlb2YgYT90aGlzLm9mZnNldDphO2lmKCF0aGlzLm5vQXNzZXJ0KXtpZihcIm51bWJlclwiIT09dHlwZW9mIGF8fDAhPT1hJTEpdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIithK1wiIChub3QgYW4gaW50ZWdlcilcIik7YT4+Pj0wO2lmKDA+YXx8YSswPnRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIithK1wiICgrMCkgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG59dGhpcy5tYXJrZWRPZmZzZXQ9YTtyZXR1cm4gdGhpc307ZC5wcm90b3R5cGUub3JkZXI9ZnVuY3Rpb24oYSl7aWYoIXRoaXMubm9Bc3NlcnQmJlwiYm9vbGVhblwiIT09dHlwZW9mIGEpdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgbGl0dGxlRW5kaWFuOiBOb3QgYSBib29sZWFuXCIpO3RoaXMubGl0dGxlRW5kaWFuPSEhYTtyZXR1cm4gdGhpc307ZC5wcm90b3R5cGUuTEU9ZnVuY3Rpb24oYSl7dGhpcy5saXR0bGVFbmRpYW49XCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBhPyEhYTohMDtyZXR1cm4gdGhpc307ZC5wcm90b3R5cGUuQkU9ZnVuY3Rpb24oYSl7dGhpcy5saXR0bGVFbmRpYW49XCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBhPyFhOiExO3JldHVybiB0aGlzfTtkLnByb3RvdHlwZS5wcmVwZW5kPWZ1bmN0aW9uKGEsYixjKXtpZihcIm51bWJlclwiPT09dHlwZW9mIGJ8fFwic3RyaW5nXCIhPT10eXBlb2YgYiljPWIsYj12b2lkIDA7dmFyIGU9XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBjO2UmJihjPVxudGhpcy5vZmZzZXQpO2lmKCF0aGlzLm5vQXNzZXJ0KXtpZihcIm51bWJlclwiIT09dHlwZW9mIGN8fDAhPT1jJTEpdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitjK1wiIChub3QgYW4gaW50ZWdlcilcIik7Yz4+Pj0wO2lmKDA+Y3x8YyswPnRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitjK1wiICgrMCkgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7fWEgaW5zdGFuY2VvZiBkfHwoYT1kLndyYXAoYSxiKSk7Yj1hLmxpbWl0LWEub2Zmc2V0O2lmKDA+PWIpcmV0dXJuIHRoaXM7dmFyIGg9Yi1jLGY7aWYoMDxoKXt2YXIgZz1uZXcgQXJyYXlCdWZmZXIodGhpcy5idWZmZXIuYnl0ZUxlbmd0aCtoKTtmPW5ldyBVaW50OEFycmF5KGcpO2Yuc2V0KChuZXcgVWludDhBcnJheSh0aGlzLmJ1ZmZlcikpLnN1YmFycmF5KGMsdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCksYik7dGhpcy5idWZmZXI9Zzt0aGlzLnZpZXc9XG5uZXcgRGF0YVZpZXcoZyk7dGhpcy5vZmZzZXQrPWg7MDw9dGhpcy5tYXJrZWRPZmZzZXQmJih0aGlzLm1hcmtlZE9mZnNldCs9aCk7dGhpcy5saW1pdCs9aDtjKz1ofWVsc2UgZj1uZXcgVWludDhBcnJheSh0aGlzLmJ1ZmZlcik7Zi5zZXQoKG5ldyBVaW50OEFycmF5KGEuYnVmZmVyKSkuc3ViYXJyYXkoYS5vZmZzZXQsYS5saW1pdCksYy1iKTthLm9mZnNldD1hLmxpbWl0O2UmJih0aGlzLm9mZnNldC09Yik7cmV0dXJuIHRoaXN9O2QucHJvdG90eXBlLnByZXBlbmRUbz1mdW5jdGlvbihhLGIpe2EucHJlcGVuZCh0aGlzLGIpO3JldHVybiB0aGlzfTtkLnByb3RvdHlwZS5wcmludERlYnVnPWZ1bmN0aW9uKGEpe1wiZnVuY3Rpb25cIiE9PXR5cGVvZiBhJiYoYT1jb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpKTthKHRoaXMudG9TdHJpbmcoKStcIlxcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG5cIit0aGlzLnRvRGVidWcoITApKX07XG5kLnByb3RvdHlwZS5yZW1haW5pbmc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5saW1pdC10aGlzLm9mZnNldH07ZC5wcm90b3R5cGUucmVzZXQ9ZnVuY3Rpb24oKXswPD10aGlzLm1hcmtlZE9mZnNldD8odGhpcy5vZmZzZXQ9dGhpcy5tYXJrZWRPZmZzZXQsdGhpcy5tYXJrZWRPZmZzZXQ9LTEpOnRoaXMub2Zmc2V0PTA7cmV0dXJuIHRoaXN9O2QucHJvdG90eXBlLnJlc2l6ZT1mdW5jdGlvbihhKXtpZighdGhpcy5ub0Fzc2VydCl7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBhfHwwIT09YSUxKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGNhcGFjaXR5OiBcIithK1wiIChub3QgYW4gaW50ZWdlcilcIik7YXw9MDtpZigwPmEpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIGNhcGFjaXR5OiAwIDw9IFwiK2EpO310aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoPGEmJihhPW5ldyBBcnJheUJ1ZmZlcihhKSwobmV3IFVpbnQ4QXJyYXkoYSkpLnNldChuZXcgVWludDhBcnJheSh0aGlzLmJ1ZmZlcikpLFxudGhpcy5idWZmZXI9YSx0aGlzLnZpZXc9bmV3IERhdGFWaWV3KGEpKTtyZXR1cm4gdGhpc307ZC5wcm90b3R5cGUucmV2ZXJzZT1mdW5jdGlvbihhLGIpe1widW5kZWZpbmVkXCI9PT10eXBlb2YgYSYmKGE9dGhpcy5vZmZzZXQpO1widW5kZWZpbmVkXCI9PT10eXBlb2YgYiYmKGI9dGhpcy5saW1pdCk7aWYoIXRoaXMubm9Bc3NlcnQpe2lmKFwibnVtYmVyXCIhPT10eXBlb2YgYXx8MCE9PWElMSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBiZWdpbjogTm90IGFuIGludGVnZXJcIik7YT4+Pj0wO2lmKFwibnVtYmVyXCIhPT10eXBlb2YgYnx8MCE9PWIlMSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBlbmQ6IE5vdCBhbiBpbnRlZ2VyXCIpO2I+Pj49MDtpZigwPmF8fGE+Ynx8Yj50aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSWxsZWdhbCByYW5nZTogMCA8PSBcIithK1wiIDw9IFwiK2IrXCIgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7fWlmKGE9PT1iKXJldHVybiB0aGlzO1xuQXJyYXkucHJvdG90eXBlLnJldmVyc2UuY2FsbCgobmV3IFVpbnQ4QXJyYXkodGhpcy5idWZmZXIpKS5zdWJhcnJheShhLGIpKTt0aGlzLnZpZXc9bmV3IERhdGFWaWV3KHRoaXMuYnVmZmVyKTtyZXR1cm4gdGhpc307ZC5wcm90b3R5cGUuc2tpcD1mdW5jdGlvbihhKXtpZighdGhpcy5ub0Fzc2VydCl7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBhfHwwIT09YSUxKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGxlbmd0aDogXCIrYStcIiAobm90IGFuIGludGVnZXIpXCIpO2F8PTB9dmFyIGI9dGhpcy5vZmZzZXQrYTtpZighdGhpcy5ub0Fzc2VydCYmKDA+Ynx8Yj50aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKSl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIklsbGVnYWwgbGVuZ3RoOiAwIDw9IFwiK3RoaXMub2Zmc2V0K1wiICsgXCIrYStcIiA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTt0aGlzLm9mZnNldD1iO3JldHVybiB0aGlzfTtkLnByb3RvdHlwZS5zbGljZT1mdW5jdGlvbihhLGIpe1widW5kZWZpbmVkXCI9PT1cbnR5cGVvZiBhJiYoYT10aGlzLm9mZnNldCk7XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBiJiYoYj10aGlzLmxpbWl0KTtpZighdGhpcy5ub0Fzc2VydCl7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBhfHwwIT09YSUxKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGJlZ2luOiBOb3QgYW4gaW50ZWdlclwiKTthPj4+PTA7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBifHwwIT09YiUxKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGVuZDogTm90IGFuIGludGVnZXJcIik7Yj4+Pj0wO2lmKDA+YXx8YT5ifHxiPnRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIHJhbmdlOiAwIDw9IFwiK2ErXCIgPD0gXCIrYitcIiA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTt9dmFyIGM9dGhpcy5jbG9uZSgpO2Mub2Zmc2V0PWE7Yy5saW1pdD1iO3JldHVybiBjfTtkLnByb3RvdHlwZS50b0J1ZmZlcj1mdW5jdGlvbihhKXt2YXIgYj10aGlzLm9mZnNldCxjPXRoaXMubGltaXQ7XG5pZihiPmMpdmFyIGU9YixiPWMsYz1lO2lmKCF0aGlzLm5vQXNzZXJ0KXtpZihcIm51bWJlclwiIT09dHlwZW9mIGJ8fDAhPT1iJTEpdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBOb3QgYW4gaW50ZWdlclwiKTtiPj4+PTA7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBjfHwwIT09YyUxKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGxpbWl0OiBOb3QgYW4gaW50ZWdlclwiKTtjPj4+PTA7aWYoMD5ifHxiPmN8fGM+dGhpcy5idWZmZXIuYnl0ZUxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIklsbGVnYWwgcmFuZ2U6IDAgPD0gXCIrYitcIiA8PSBcIitjK1wiIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO31pZighYSYmMD09PWImJmM9PT10aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKXJldHVybiB0aGlzLmJ1ZmZlcjtpZihiPT09YylyZXR1cm4gcjthPW5ldyBBcnJheUJ1ZmZlcihjLWIpOyhuZXcgVWludDhBcnJheShhKSkuc2V0KChuZXcgVWludDhBcnJheSh0aGlzLmJ1ZmZlcikpLnN1YmFycmF5KGIsXG5jKSwwKTtyZXR1cm4gYX07ZC5wcm90b3R5cGUudG9BcnJheUJ1ZmZlcj1kLnByb3RvdHlwZS50b0J1ZmZlcjtkLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbihhKXtpZihcInVuZGVmaW5lZFwiPT09dHlwZW9mIGEpcmV0dXJuXCJCeXRlQnVmZmVyQUIob2Zmc2V0PVwiK3RoaXMub2Zmc2V0K1wiLG1hcmtlZE9mZnNldD1cIit0aGlzLm1hcmtlZE9mZnNldCtcIixsaW1pdD1cIit0aGlzLmxpbWl0K1wiLGNhcGFjaXR5PVwiK3RoaXMuY2FwYWNpdHkoKStcIilcIjtzd2l0Y2goYSl7Y2FzZSBcInV0ZjhcIjpyZXR1cm4gdGhpcy50b1VURjgoKTtjYXNlIFwiYmFzZTY0XCI6cmV0dXJuIHRoaXMudG9CYXNlNjQoKTtjYXNlIFwiaGV4XCI6cmV0dXJuIHRoaXMudG9IZXgoKTtjYXNlIFwiYmluYXJ5XCI6cmV0dXJuIHRoaXMudG9CaW5hcnkoKTtjYXNlIFwiZGVidWdcIjpyZXR1cm4gdGhpcy50b0RlYnVnKCk7Y2FzZSBcImNvbHVtbnNcIjpyZXR1cm4gdGhpcy5vKCk7ZGVmYXVsdDp0aHJvdyBFcnJvcihcIlVuc3VwcG9ydGVkIGVuY29kaW5nOiBcIitcbmEpO319O3ZhciBtPVwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz1cIixtPW0rXCJcIjtkLnByb3RvdHlwZS50b0Jhc2U2ND1mdW5jdGlvbihhLGIpe1widW5kZWZpbmVkXCI9PT10eXBlb2YgYSYmKGE9dGhpcy5vZmZzZXQpO1widW5kZWZpbmVkXCI9PT10eXBlb2YgYiYmKGI9dGhpcy5saW1pdCk7aWYoIXRoaXMubm9Bc3NlcnQpe2lmKFwibnVtYmVyXCIhPT10eXBlb2YgYXx8MCE9PWElMSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBiZWdpbjogTm90IGFuIGludGVnZXJcIik7YT4+Pj0wO2lmKFwibnVtYmVyXCIhPT10eXBlb2YgYnx8MCE9PWIlMSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBlbmQ6IE5vdCBhbiBpbnRlZ2VyXCIpO2I+Pj49MDtpZigwPmF8fGE+Ynx8Yj50aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSWxsZWdhbCByYW5nZTogMCA8PSBcIithK1wiIDw9IFwiK2IrXCIgPD0gXCIrXG50aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTt9aWYoYT09PWIpcmV0dXJuXCJcIjtmb3IodmFyIGMsZSxkLGYsZyxrLGw9XCJcIjthPGI7KWM9dGhpcy52aWV3LmdldFVpbnQ4KGErKyksZT0oZj1hPGIpP3RoaXMudmlldy5nZXRVaW50OChhKyspOjAsZD0oZz1hPGIpP3RoaXMudmlldy5nZXRVaW50OChhKyspOjAsaz1jPj4yLGM9KGMmMyk8PDR8ZT4+NCxlPShlJjE1KTw8MnxkPj42LGQmPTYzLGd8fChkPTY0LGZ8fChlPTY0KSksbCs9bS5jaGFyQXQoaykrbS5jaGFyQXQoYykrbS5jaGFyQXQoZSkrbS5jaGFyQXQoZCk7cmV0dXJuIGx9O2QuZnJvbUJhc2U2ND1mdW5jdGlvbihhLGIsYyl7aWYoIWMpe2lmKFwic3RyaW5nXCIhPT10eXBlb2YgYSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBzdHI6IE5vdCBhIHN0cmluZ1wiKTtpZigwIT09YS5sZW5ndGglNCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBzdHI6IExlbmd0aCBub3QgYSBtdWx0aXBsZSBvZiA0XCIpO312YXIgZT1hLmxlbmd0aCxcbmg9MCxmO2ZvcihmPWEubGVuZ3RoLTE7MDw9ZjstLWYpaWYoXCI9XCI9PT1hLmNoYXJBdChmKSloKys7ZWxzZSBicmVhaztpZigyPGgpdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgc3RyOiBTdWZmaXggaXMgdG9vIGxhcmdlXCIpO2lmKDA9PT1lKXJldHVybiBuZXcgZCgwLGIsYyk7dmFyIGcsayxsLHA9bmV3IGQoZS80KjMtaCxiLGMpO2ZvcihiPWY9MDtmPGU7KXtoPW0uaW5kZXhPZihhLmNoYXJBdChmKyspKTtnPWY8ZT9tLmluZGV4T2YoYS5jaGFyQXQoZisrKSk6MDtrPWY8ZT9tLmluZGV4T2YoYS5jaGFyQXQoZisrKSk6MDtsPWY8ZT9tLmluZGV4T2YoYS5jaGFyQXQoZisrKSk6MDtpZighYyYmKDA+aHx8MD5nfHwwPmt8fDA+bCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgc3RyOiBDb250YWlucyBub24tYmFzZTY0IGNoYXJhY3RlcnNcIik7cC52aWV3LnNldFVpbnQ4KGIrKyxoPDwyfGc+PjQpOzY0IT09ayYmKHAudmlldy5zZXRVaW50OChiKyssZzw8NCYyNDB8az4+MixcbmIpLDY0IT09bCYmcC52aWV3LnNldFVpbnQ4KGIrKyxrPDw2JjE5MnxsKSl9cC5saW1pdD1iO3JldHVybiBwfTtkLmJ0b2E9ZnVuY3Rpb24oYSl7cmV0dXJuIGQuZnJvbUJpbmFyeShhKS50b0Jhc2U2NCgpfTtkLmF0b2I9ZnVuY3Rpb24oYSl7cmV0dXJuIGQuZnJvbUJhc2U2NChhKS50b0JpbmFyeSgpfTtkLnByb3RvdHlwZS50b0JpbmFyeT1mdW5jdGlvbihhLGIpe2E9XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBhP3RoaXMub2Zmc2V0OmE7Yj1cInVuZGVmaW5lZFwiPT09dHlwZW9mIGI/dGhpcy5saW1pdDpiO2lmKCF0aGlzLm5vQXNzZXJ0KXtpZihcIm51bWJlclwiIT09dHlwZW9mIGF8fDAhPT1hJTEpdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgYmVnaW46IE5vdCBhbiBpbnRlZ2VyXCIpO2E+Pj49MDtpZihcIm51bWJlclwiIT09dHlwZW9mIGJ8fDAhPT1iJTEpdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgZW5kOiBOb3QgYW4gaW50ZWdlclwiKTtiPj4+PTA7aWYoMD5hfHxhPmJ8fGI+dGhpcy5idWZmZXIuYnl0ZUxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIklsbGVnYWwgcmFuZ2U6IDAgPD0gXCIrXG5hK1wiIDw9IFwiK2IrXCIgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7fWlmKGE9PT1iKXJldHVyblwiXCI7Zm9yKHZhciBjPVtdO2E8YjspYy5wdXNoKHRoaXMudmlldy5nZXRVaW50OChhKyspKTtyZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsYyl9O2QuZnJvbUJpbmFyeT1mdW5jdGlvbihhLGIsYyl7aWYoIWMmJlwic3RyaW5nXCIhPT10eXBlb2YgYSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBzdHI6IE5vdCBhIHN0cmluZ1wiKTtmb3IodmFyIGU9MCxoPWEubGVuZ3RoLGY9bmV3IGQoaCxiLGMpO2U8aDspe2I9YS5jaGFyQ29kZUF0KGUpO2lmKCFjJiYyNTU8Yil0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBjaGFyQ29kZSBhdCBcIitlK1wiOiAwIDw9IFwiK2IrXCIgPD0gMjU1XCIpO2Yudmlldy5zZXRVaW50OChlKyssYil9Zi5saW1pdD1oO3JldHVybiBmfTtkLnByb3RvdHlwZS50b0RlYnVnPWZ1bmN0aW9uKGEpe2Zvcih2YXIgYj0tMSxjPXRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgsXG5lLGQ9XCJcIixmPVwiXCIsZz1cIlwiO2I8Yzspey0xIT09YiYmKGU9dGhpcy52aWV3LmdldFVpbnQ4KGIpLGQ9MTY+ZT9kKyhcIjBcIitlLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpKTpkK2UudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCksYSYmKGYrPTMyPGUmJjEyNz5lP1N0cmluZy5mcm9tQ2hhckNvZGUoZSk6XCIuXCIpKTsrK2I7aWYoYSYmMDxiJiYwPT09YiUxNiYmYiE9PWMpe2Zvcig7NTE+ZC5sZW5ndGg7KWQrPVwiIFwiO2crPWQrZitcIlxcblwiO2Q9Zj1cIlwifWQ9Yj09PXRoaXMub2Zmc2V0JiZiPT09dGhpcy5saW1pdD9kKyhiPT09dGhpcy5tYXJrZWRPZmZzZXQ/XCIhXCI6XCJ8XCIpOmI9PT10aGlzLm9mZnNldD9kKyhiPT09dGhpcy5tYXJrZWRPZmZzZXQ/XCJbXCI6XCI8XCIpOmI9PT10aGlzLmxpbWl0P2QrKGI9PT10aGlzLm1hcmtlZE9mZnNldD9cIl1cIjpcIj5cIik6ZCsoYj09PXRoaXMubWFya2VkT2Zmc2V0P1wiJ1wiOmF8fDAhPT1iJiZiIT09Yz9cIiBcIjpcIlwiKX1pZihhJiZcIiBcIiE9PWQpe2Zvcig7NTE+ZC5sZW5ndGg7KWQrPVxuXCIgXCI7Zys9ZCtmK1wiXFxuXCJ9cmV0dXJuIGE/ZzpkfTtkLmZyb21EZWJ1Zz1mdW5jdGlvbihhLGIsYyl7dmFyIGU9YS5sZW5ndGg7Yj1uZXcgZCgoZSsxKS8zfDAsYixjKTtmb3IodmFyIGg9MCxmPTAsZyxrPSExLGw9ITEscD0hMSxtPSExLHE9ITE7aDxlOyl7c3dpdGNoKGc9YS5jaGFyQXQoaCsrKSl7Y2FzZSBcIiFcIjppZighYyl7aWYobHx8cHx8bSl7cT0hMDticmVha31sPXA9bT0hMH1iLm9mZnNldD1iLm1hcmtlZE9mZnNldD1iLmxpbWl0PWY7az0hMTticmVhaztjYXNlIFwifFwiOmlmKCFjKXtpZihsfHxtKXtxPSEwO2JyZWFrfWw9bT0hMH1iLm9mZnNldD1iLmxpbWl0PWY7az0hMTticmVhaztjYXNlIFwiW1wiOmlmKCFjKXtpZihsfHxwKXtxPSEwO2JyZWFrfWw9cD0hMH1iLm9mZnNldD1iLm1hcmtlZE9mZnNldD1mO2s9ITE7YnJlYWs7Y2FzZSBcIjxcIjppZighYyl7aWYobCl7cT0hMDticmVha31sPSEwfWIub2Zmc2V0PWY7az0hMTticmVhaztjYXNlIFwiXVwiOmlmKCFjKXtpZihtfHxwKXtxPVxuITA7YnJlYWt9bT1wPSEwfWIubGltaXQ9Yi5tYXJrZWRPZmZzZXQ9ZjtrPSExO2JyZWFrO2Nhc2UgXCI+XCI6aWYoIWMpe2lmKG0pe3E9ITA7YnJlYWt9bT0hMH1iLmxpbWl0PWY7az0hMTticmVhaztjYXNlIFwiJ1wiOmlmKCFjKXtpZihwKXtxPSEwO2JyZWFrfXA9ITB9Yi5tYXJrZWRPZmZzZXQ9ZjtrPSExO2JyZWFrO2Nhc2UgXCIgXCI6az0hMTticmVhaztkZWZhdWx0OmlmKCFjJiZrKXtxPSEwO2JyZWFrfWc9cGFyc2VJbnQoZythLmNoYXJBdChoKyspLDE2KTtpZighYyYmKGlzTmFOKGcpfHwwPmd8fDI1NTxnKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBzdHI6IE5vdCBhIGRlYnVnIGVuY29kZWQgc3RyaW5nXCIpO2Iudmlldy5zZXRVaW50OChmKyssZyk7az0hMH1pZihxKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIHN0cjogSW52YWxpZCBzeW1ib2wgYXQgXCIraCk7fWlmKCFjKXtpZighbHx8IW0pdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgc3RyOiBNaXNzaW5nIG9mZnNldCBvciBsaW1pdFwiKTtcbmlmKGY8Yi5idWZmZXIuYnl0ZUxlbmd0aCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBzdHI6IE5vdCBhIGRlYnVnIGVuY29kZWQgc3RyaW5nIChpcyBpdCBoZXg/KSBcIitmK1wiIDwgXCIrZSk7fXJldHVybiBifTtkLnByb3RvdHlwZS50b0hleD1mdW5jdGlvbihhLGIpe2E9XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBhP3RoaXMub2Zmc2V0OmE7Yj1cInVuZGVmaW5lZFwiPT09dHlwZW9mIGI/dGhpcy5saW1pdDpiO2lmKCF0aGlzLm5vQXNzZXJ0KXtpZihcIm51bWJlclwiIT09dHlwZW9mIGF8fDAhPT1hJTEpdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgYmVnaW46IE5vdCBhbiBpbnRlZ2VyXCIpO2E+Pj49MDtpZihcIm51bWJlclwiIT09dHlwZW9mIGJ8fDAhPT1iJTEpdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgZW5kOiBOb3QgYW4gaW50ZWdlclwiKTtiPj4+PTA7aWYoMD5hfHxhPmJ8fGI+dGhpcy5idWZmZXIuYnl0ZUxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIklsbGVnYWwgcmFuZ2U6IDAgPD0gXCIrXG5hK1wiIDw9IFwiK2IrXCIgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7fWZvcih2YXIgYz1BcnJheShiLWEpLGU7YTxiOyllPXRoaXMudmlldy5nZXRVaW50OChhKyspLDE2PmU/Yy5wdXNoKFwiMFwiLGUudG9TdHJpbmcoMTYpKTpjLnB1c2goZS50b1N0cmluZygxNikpO3JldHVybiBjLmpvaW4oXCJcIil9O2QuZnJvbUhleD1mdW5jdGlvbihhLGIsYyl7aWYoIWMpe2lmKFwic3RyaW5nXCIhPT10eXBlb2YgYSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBzdHI6IE5vdCBhIHN0cmluZ1wiKTtpZigwIT09YS5sZW5ndGglMil0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBzdHI6IExlbmd0aCBub3QgYSBtdWx0aXBsZSBvZiAyXCIpO312YXIgZT1hLmxlbmd0aDtiPW5ldyBkKGUvMnwwLGIpO2Zvcih2YXIgaCxmPTAsZz0wO2Y8ZTtmKz0yKXtoPXBhcnNlSW50KGEuc3Vic3RyaW5nKGYsZisyKSwxNik7aWYoIWMmJighaXNGaW5pdGUoaCl8fDA+aHx8MjU1PGgpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIHN0cjogQ29udGFpbnMgbm9uLWhleCBjaGFyYWN0ZXJzXCIpO1xuYi52aWV3LnNldFVpbnQ4KGcrKyxoKX1iLmxpbWl0PWc7cmV0dXJuIGJ9O3ZhciBrPWZ1bmN0aW9uKCl7dmFyIGE9e2o6ZnVuY3Rpb24oYSxjKXt2YXIgZT1udWxsO1wibnVtYmVyXCI9PT10eXBlb2YgYSYmKGU9YSxhPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGx9KTtmb3IoO251bGwhPT1lfHxudWxsIT09KGU9YSgpKTspMTI4PmU/YyhlJjEyNyk6KDIwNDg+ZT9jKGU+PjYmMzF8MTkyKTooNjU1MzY+ZT9jKGU+PjEyJjE1fDIyNCk6KGMoZT4+MTgmN3wyNDApLGMoZT4+MTImNjN8MTI4KSksYyhlPj42JjYzfDEyOCkpLGMoZSY2M3wxMjgpKSxlPW51bGx9LGk6ZnVuY3Rpb24oYSxjKXtmdW5jdGlvbiBlKGEpe2E9YS5zbGljZSgwLGEuaW5kZXhPZihudWxsKSk7dmFyIGI9RXJyb3IoYS50b1N0cmluZygpKTtiLm5hbWU9XCJUcnVuY2F0ZWRFcnJvclwiO2IuYnl0ZXM9YTt0aHJvdyBiO31mb3IodmFyIGQsZixnLGs7bnVsbCE9PShkPWEoKSk7KWlmKDA9PT0oZCYxMjgpKWMoZCk7ZWxzZSBpZigxOTI9PT1cbihkJjIyNCkpbnVsbD09PShmPWEoKSkmJmUoW2QsZl0pLGMoKGQmMzEpPDw2fGYmNjMpO2Vsc2UgaWYoMjI0PT09KGQmMjQwKSludWxsIT09KGY9YSgpKSYmbnVsbCE9PShnPWEoKSl8fGUoW2QsZixnXSksYygoZCYxNSk8PDEyfChmJjYzKTw8NnxnJjYzKTtlbHNlIGlmKDI0MD09PShkJjI0OCkpbnVsbCE9PShmPWEoKSkmJm51bGwhPT0oZz1hKCkpJiZudWxsIT09KGs9YSgpKXx8ZShbZCxmLGcsa10pLGMoKGQmNyk8PDE4fChmJjYzKTw8MTJ8KGcmNjMpPDw2fGsmNjMpO2Vsc2UgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgc3RhcnRpbmcgYnl0ZTogXCIrZCk7fSxmOmZ1bmN0aW9uKGEsYyl7Zm9yKHZhciBlLGQ9bnVsbDtudWxsIT09KGU9bnVsbCE9PWQ/ZDphKCkpOyk1NTI5Njw9ZSYmNTczNDM+PWUmJm51bGwhPT0oZD1hKCkpJiY1NjMyMDw9ZCYmNTczNDM+PWQ/KGMoMTAyNCooZS01NTI5NikrZC01NjMyMCs2NTUzNiksZD1udWxsKTpjKGUpO251bGwhPT1kJiZjKGQpfSxnOmZ1bmN0aW9uKGEsXG5jKXt2YXIgZT1udWxsO1wibnVtYmVyXCI9PT10eXBlb2YgYSYmKGU9YSxhPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGx9KTtmb3IoO251bGwhPT1lfHxudWxsIT09KGU9YSgpKTspNjU1MzU+PWU/YyhlKTooZS09NjU1MzYsYygoZT4+MTApKzU1Mjk2KSxjKGUlMTAyNCs1NjMyMCkpLGU9bnVsbH0sZTpmdW5jdGlvbihiLGMpe2EuZihiLGZ1bmN0aW9uKGIpe2EuaihiLGMpfSl9LGQ6ZnVuY3Rpb24oYixjKXthLmkoYixmdW5jdGlvbihiKXthLmcoYixjKX0pfSxrOmZ1bmN0aW9uKGEpe2lmKFwibnVtYmVyXCIhPT10eXBlb2YgYXx8YSE9PWEpdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBieXRlOiBcIit0eXBlb2YgYSk7aWYoLTEyOD5hfHwyNTU8YSl0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBieXRlOiBcIithKTtyZXR1cm4gYX0sbDpmdW5jdGlvbihhKXtpZihcIm51bWJlclwiIT09dHlwZW9mIGF8fGEhPT1hKXRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgY2hhciBjb2RlOiBcIit0eXBlb2YgYSk7aWYoMD5cbmF8fDY1NTM1PGEpdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgY2hhciBjb2RlOiBcIithKTtyZXR1cm4gYX0sbTpmdW5jdGlvbihhKXtpZihcIm51bWJlclwiIT09dHlwZW9mIGF8fGEhPT1hKXRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgY29kZSBwb2ludDogXCIrdHlwZW9mIGEpO2lmKDA+YXx8MTExNDExMTxhKXRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIGNvZGUgcG9pbnQ6IFwiK2EpO3JldHVybiBhfSxoOmZ1bmN0aW9uKGEpe3JldHVybiAxMjg+YT8xOjIwNDg+YT8yOjY1NTM2PmE/Mzo0fSxuOmZ1bmN0aW9uKGIpe2Zvcih2YXIgYyxkPTA7bnVsbCE9PShjPWIoKSk7KWQrPWEuaChjKTtyZXR1cm4gZH0sYjpmdW5jdGlvbihiKXt2YXIgYz0wLGQ9MDthLmYoYixmdW5jdGlvbihiKXsrK2M7ZCs9YS5oKGIpfSk7cmV0dXJuW2MsZF19fTtyZXR1cm4gYX0oKSxzPVN0cmluZy5mcm9tQ2hhckNvZGU7ay5hPWZ1bmN0aW9uKGEpe3ZhciBiPTA7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIGI8XG5hLmxlbmd0aD9hLmNoYXJDb2RlQXQoYisrKTpudWxsfX07ay5jPWZ1bmN0aW9uKCl7dmFyIGE9W10sYj1bXTtyZXR1cm4gZnVuY3Rpb24oKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gYi5qb2luKFwiXCIpK3MuYXBwbHkoU3RyaW5nLGEpOzEwMjQ8YS5sZW5ndGgrYXJndW1lbnRzLmxlbmd0aCYmKGIucHVzaChzLmFwcGx5KFN0cmluZyxhKSksYS5sZW5ndGg9MCk7QXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoYSxhcmd1bWVudHMpfX07ZC5wcm90b3R5cGUudG9VVEY4PWZ1bmN0aW9uKGEsYil7XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBhJiYoYT10aGlzLm9mZnNldCk7XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBiJiYoYj10aGlzLmxpbWl0KTtpZighdGhpcy5ub0Fzc2VydCl7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBhfHwwIT09YSUxKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGJlZ2luOiBOb3QgYW4gaW50ZWdlclwiKTthPj4+PTA7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBifHxcbjAhPT1iJTEpdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgZW5kOiBOb3QgYW4gaW50ZWdlclwiKTtiPj4+PTA7aWYoMD5hfHxhPmJ8fGI+dGhpcy5idWZmZXIuYnl0ZUxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIklsbGVnYWwgcmFuZ2U6IDAgPD0gXCIrYStcIiA8PSBcIitiK1wiIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO312YXIgYz10aGlzLGQ7dHJ5e2suZChmdW5jdGlvbigpe3JldHVybiBhPGI/Yy52aWV3LmdldFVpbnQ4KGErKyk6bnVsbH0sZD1rLmMoKSl9Y2F0Y2goaCl7aWYoYSE9PWIpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIHJhbmdlOiBUcnVuY2F0ZWQgZGF0YSwgXCIrYStcIiAhPSBcIitiKTt9cmV0dXJuIGQoKX07ZC5mcm9tVVRGOD1mdW5jdGlvbihhLGIsYyl7aWYoIWMmJlwic3RyaW5nXCIhPT10eXBlb2YgYSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBzdHI6IE5vdCBhIHN0cmluZ1wiKTt2YXIgZT1uZXcgZChrLmIoay5hKGEpLCEwKVsxXSxcbmIsYyksaD0wO2suZShrLmEoYSksZnVuY3Rpb24oYSl7ZS52aWV3LnNldFVpbnQ4KGgrKyxhKX0pO2UubGltaXQ9aDtyZXR1cm4gZX07cmV0dXJuIGR9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIG1vZHVsZSYmbW9kdWxlLmV4cG9ydHM/bW9kdWxlLmV4cG9ydHM9cyhyZXF1aXJlKFwibG9uZ1wiKSk6XCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFwiQnl0ZUJ1ZmZlclwiLFtcIk1hdGgvTG9uZ1wiXSxmdW5jdGlvbihsKXtyZXR1cm4gcyhsKX0pOihyLmRjb2RlSU98fChyLmRjb2RlSU89e30pLHIuZGNvZGVJTy5CeXRlQnVmZmVyPXMoci5kY29kZUlPLkxvbmcpKX0pKHRoaXMpO1xuIiwiLypcclxuIENvcHlyaWdodCAyMDEzIERhbmllbCBXaXJ0eiA8ZGNvZGVAZGNvZGUuaW8+XHJcbiBDb3B5cmlnaHQgMjAwOSBUaGUgQ2xvc3VyZSBMaWJyYXJ5IEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXHJcblxyXG4gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG5cclxuIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG5cclxuIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMtSVNcIiBCQVNJUyxcclxuIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQGxpY2Vuc2UgTG9uZy5qcyAoYykgMjAxMyBEYW5pZWwgV2lydHogPGRjb2RlQGRjb2RlLmlvPlxyXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wXHJcbiAqIERlcml2ZWQgZnJvbSBnb29nLm1hdGguTG9uZyBmcm9tIHRoZSBDbG9zdXJlIExpYnJhcnlcclxuICogc2VlOiBodHRwczovL2dpdGh1Yi5jb20vZGNvZGVJTy9Mb25nLmpzIGZvciBkZXRhaWxzXHJcbiAqL1xyXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnN0cnVjdHMgYSA2NC1iaXQgdHdvJ3MtY29tcGxlbWVudCBpbnRlZ2VyLCBnaXZlbiBpdHMgbG93IGFuZCBoaWdoIDMyLWJpdFxyXG4gICAgICogdmFsdWVzIGFzICpzaWduZWQqIGludGVnZXJzLiAgU2VlIHRoZSBmcm9tKiBmdW5jdGlvbnMgYmVsb3cgZm9yIG1vcmVcclxuICAgICAqIGNvbnZlbmllbnQgd2F5cyBvZiBjb25zdHJ1Y3RpbmcgTG9uZ3MuXHJcbiAgICAgKlxyXG4gICAgICogVGhlIGludGVybmFsIHJlcHJlc2VudGF0aW9uIG9mIGEgbG9uZyBpcyB0aGUgdHdvIGdpdmVuIHNpZ25lZCwgMzItYml0IHZhbHVlcy5cclxuICAgICAqIFdlIHVzZSAzMi1iaXQgcGllY2VzIGJlY2F1c2UgdGhlc2UgYXJlIHRoZSBzaXplIG9mIGludGVnZXJzIG9uIHdoaWNoXHJcbiAgICAgKiBKYXZhc2NyaXB0IHBlcmZvcm1zIGJpdC1vcGVyYXRpb25zLiAgRm9yIG9wZXJhdGlvbnMgbGlrZSBhZGRpdGlvbiBhbmRcclxuICAgICAqIG11bHRpcGxpY2F0aW9uLCB3ZSBzcGxpdCBlYWNoIG51bWJlciBpbnRvIDE2LWJpdCBwaWVjZXMsIHdoaWNoIGNhbiBlYXNpbHkgYmVcclxuICAgICAqIG11bHRpcGxpZWQgd2l0aGluIEphdmFzY3JpcHQncyBmbG9hdGluZy1wb2ludCByZXByZXNlbnRhdGlvbiB3aXRob3V0IG92ZXJmbG93XHJcbiAgICAgKiBvciBjaGFuZ2UgaW4gc2lnbi5cclxuICAgICAqXHJcbiAgICAgKiBJbiB0aGUgYWxnb3JpdGhtcyBiZWxvdywgd2UgZnJlcXVlbnRseSByZWR1Y2UgdGhlIG5lZ2F0aXZlIGNhc2UgdG8gdGhlXHJcbiAgICAgKiBwb3NpdGl2ZSBjYXNlIGJ5IG5lZ2F0aW5nIHRoZSBpbnB1dChzKSBhbmQgdGhlbiBwb3N0LXByb2Nlc3NpbmcgdGhlIHJlc3VsdC5cclxuICAgICAqIE5vdGUgdGhhdCB3ZSBtdXN0IEFMV0FZUyBjaGVjayBzcGVjaWFsbHkgd2hldGhlciB0aG9zZSB2YWx1ZXMgYXJlIE1JTl9WQUxVRVxyXG4gICAgICogKC0yXjYzKSBiZWNhdXNlIC1NSU5fVkFMVUUgPT0gTUlOX1ZBTFVFIChzaW5jZSAyXjYzIGNhbm5vdCBiZSByZXByZXNlbnRlZCBhc1xyXG4gICAgICogYSBwb3NpdGl2ZSBudW1iZXIsIGl0IG92ZXJmbG93cyBiYWNrIGludG8gYSBuZWdhdGl2ZSkuICBOb3QgaGFuZGxpbmcgdGhpc1xyXG4gICAgICogY2FzZSB3b3VsZCBvZnRlbiByZXN1bHQgaW4gaW5maW5pdGUgcmVjdXJzaW9uLlxyXG4gICAgICogXHJcbiAgICAgKiBAZXhwb3J0cyBMb25nXHJcbiAgICAgKiBAY2xhc3MgQSBMb25nIGNsYXNzIGZvciByZXByZXNlbnRpbmcgYSA2NC1iaXQgdHdvJ3MtY29tcGxlbWVudCBpbnRlZ2VyIHZhbHVlLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ8IXtsb3c6IG51bWJlciwgaGlnaDogbnVtYmVyLCB1bnNpZ25lZDogYm9vbGVhbn19IGxvdyBUaGUgbG93IChzaWduZWQpIDMyIGJpdHMgb2YgdGhlIGxvbmcuXHJcbiAgICAgKiAgT3B0aW9uYWxseSBhY2NlcHRzIGEgTG9uZy1saWtlIG9iamVjdCBhcyB0aGUgZmlyc3QgcGFyYW1ldGVyLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBoaWdoIFRoZSBoaWdoIChzaWduZWQpIDMyIGJpdHMgb2YgdGhlIGxvbmcuXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdC4gRGVmYXVsdHMgdG8gYGZhbHNlYCAoc2lnbmVkKS5cclxuICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICovXHJcbiAgICB2YXIgTG9uZyA9IGZ1bmN0aW9uKGxvdywgaGlnaCwgdW5zaWduZWQpIHtcclxuICAgICAgICBpZiAobG93ICYmIHR5cGVvZiBsb3cgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgIGhpZ2ggPSBsb3cuaGlnaDtcclxuICAgICAgICAgICAgdW5zaWduZWQgPSBsb3cudW5zaWduZWQ7XHJcbiAgICAgICAgICAgIGxvdyA9IGxvdy5sb3c7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBsb3cgMzIgYml0cyBhcyBhIHNpZ25lZCB2YWx1ZS5cclxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmxvdyA9IGxvdyB8IDA7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBoaWdoIDMyIGJpdHMgYXMgYSBzaWduZWQgdmFsdWUuXHJcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5oaWdoID0gaGlnaCB8IDA7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LlxyXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnVuc2lnbmVkID0gISF1bnNpZ25lZDtcclxuICAgIH07XHJcblxyXG4gICAgLy8gTk9URTogQ29tbW9uIGNvbnN0YW50IHZhbHVlcyBaRVJPLCBPTkUsIE5FR19PTkUsIGV0Yy4gYXJlIGRlZmluZWQgYmVsb3cgdGhlIGZyb20qIG1ldGhvZHMgb24gd2hpY2ggdGhleSBkZXBlbmQuXHJcblxyXG4gICAgLy8gTk9URTogVGhlIGZvbGxvd2luZyBjYWNoZSB2YXJpYWJsZXMgYXJlIHVzZWQgaW50ZXJuYWxseSBvbmx5IGFuZCBhcmUgdGhlcmVmb3JlIG5vdCBleHBvc2VkIGFzIHByb3BlcnRpZXMgb2YgdGhlXHJcbiAgICAvLyBMb25nIGNsYXNzLlxyXG4gICAgXHJcbiAgICAvKipcclxuICAgICAqIEEgY2FjaGUgb2YgdGhlIExvbmcgcmVwcmVzZW50YXRpb25zIG9mIHNtYWxsIGludGVnZXIgdmFsdWVzLlxyXG4gICAgICogQHR5cGUgeyFPYmplY3R9XHJcbiAgICAgKi9cclxuICAgIHZhciBJTlRfQ0FDSEUgPSB7fTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgY2FjaGUgb2YgdGhlIExvbmcgcmVwcmVzZW50YXRpb25zIG9mIHNtYWxsIHVuc2lnbmVkIGludGVnZXIgdmFsdWVzLlxyXG4gICAgICogQHR5cGUgeyFPYmplY3R9XHJcbiAgICAgKi9cclxuICAgIHZhciBVSU5UX0NBQ0hFID0ge307XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgTG9uZyByZXByZXNlbnRpbmcgdGhlIGdpdmVuICgzMi1iaXQpIGludGVnZXIgdmFsdWUuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVGhlIDMyLWJpdCBpbnRlZ2VyIGluIHF1ZXN0aW9uLlxyXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QuIERlZmF1bHRzIHRvIGZhbHNlIChzaWduZWQpLlxyXG4gICAgICogQHJldHVybiB7IUxvbmd9IFRoZSBjb3JyZXNwb25kaW5nIExvbmcgdmFsdWUuXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIExvbmcuZnJvbUludCA9IGZ1bmN0aW9uKHZhbHVlLCB1bnNpZ25lZCkge1xyXG4gICAgICAgIHZhciBvYmosIGNhY2hlZE9iajtcclxuICAgICAgICBpZiAoIXVuc2lnbmVkKSB7XHJcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgfCAwO1xyXG4gICAgICAgICAgICBpZiAoLTEyOCA8PSB2YWx1ZSAmJiB2YWx1ZSA8IDEyOCkge1xyXG4gICAgICAgICAgICAgICAgY2FjaGVkT2JqID0gSU5UX0NBQ0hFW3ZhbHVlXTtcclxuICAgICAgICAgICAgICAgIGlmIChjYWNoZWRPYmopIHJldHVybiBjYWNoZWRPYmo7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb2JqID0gbmV3IExvbmcodmFsdWUsIHZhbHVlIDwgMCA/IC0xIDogMCwgZmFsc2UpO1xyXG4gICAgICAgICAgICBpZiAoLTEyOCA8PSB2YWx1ZSAmJiB2YWx1ZSA8IDEyOCkge1xyXG4gICAgICAgICAgICAgICAgSU5UX0NBQ0hFW3ZhbHVlXSA9IG9iajtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gb2JqO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgPj4+IDA7XHJcbiAgICAgICAgICAgIGlmICgwIDw9IHZhbHVlICYmIHZhbHVlIDwgMjU2KSB7XHJcbiAgICAgICAgICAgICAgICBjYWNoZWRPYmogPSBVSU5UX0NBQ0hFW3ZhbHVlXTtcclxuICAgICAgICAgICAgICAgIGlmIChjYWNoZWRPYmopIHJldHVybiBjYWNoZWRPYmo7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb2JqID0gbmV3IExvbmcodmFsdWUsICh2YWx1ZSB8IDApIDwgMCA/IC0xIDogMCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIGlmICgwIDw9IHZhbHVlICYmIHZhbHVlIDwgMjU2KSB7XHJcbiAgICAgICAgICAgICAgICBVSU5UX0NBQ0hFW3ZhbHVlXSA9IG9iajtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gb2JqO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgTG9uZyByZXByZXNlbnRpbmcgdGhlIGdpdmVuIHZhbHVlLCBwcm92aWRlZCB0aGF0IGl0IGlzIGEgZmluaXRlXHJcbiAgICAgKiBudW1iZXIuICBPdGhlcndpc2UsIHplcm8gaXMgcmV0dXJuZWQuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVGhlIG51bWJlciBpbiBxdWVzdGlvbi5cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LiBEZWZhdWx0cyB0byBmYWxzZSAoc2lnbmVkKS5cclxuICAgICAqIEByZXR1cm4geyFMb25nfSBUaGUgY29ycmVzcG9uZGluZyBMb25nIHZhbHVlLlxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBMb25nLmZyb21OdW1iZXIgPSBmdW5jdGlvbih2YWx1ZSwgdW5zaWduZWQpIHtcclxuICAgICAgICB1bnNpZ25lZCA9ICEhdW5zaWduZWQ7XHJcbiAgICAgICAgaWYgKGlzTmFOKHZhbHVlKSB8fCAhaXNGaW5pdGUodmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBMb25nLlpFUk87XHJcbiAgICAgICAgfSBlbHNlIGlmICghdW5zaWduZWQgJiYgdmFsdWUgPD0gLVRXT19QV1JfNjNfREJMKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBMb25nLk1JTl9TSUdORURfVkFMVUU7XHJcbiAgICAgICAgfSBlbHNlIGlmICh1bnNpZ25lZCAmJiB2YWx1ZSA8PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBMb25nLk1JTl9VTlNJR05FRF9WQUxVRTtcclxuICAgICAgICB9IGVsc2UgaWYgKCF1bnNpZ25lZCAmJiB2YWx1ZSArIDEgPj0gVFdPX1BXUl82M19EQkwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIExvbmcuTUFYX1NJR05FRF9WQUxVRTtcclxuICAgICAgICB9IGVsc2UgaWYgKHVuc2lnbmVkICYmIHZhbHVlID49IFRXT19QV1JfNjRfREJMKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBMb25nLk1BWF9VTlNJR05FRF9WQUxVRTtcclxuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlIDwgMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gTG9uZy5mcm9tTnVtYmVyKC12YWx1ZSwgZmFsc2UpLm5lZ2F0ZSgpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgTG9uZygodmFsdWUgJSBUV09fUFdSXzMyX0RCTCkgfCAwLCAodmFsdWUgLyBUV09fUFdSXzMyX0RCTCkgfCAwLCB1bnNpZ25lZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBMb25nIHJlcHJlc2VudGluZyB0aGUgNjRiaXQgaW50ZWdlciB0aGF0IGNvbWVzIGJ5IGNvbmNhdGVuYXRpbmcgdGhlIGdpdmVuIGxvdyBhbmQgaGlnaCBiaXRzLiBFYWNoIGlzXHJcbiAgICAgKiAgYXNzdW1lZCB0byB1c2UgMzIgYml0cy5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsb3dCaXRzIFRoZSBsb3cgMzIgYml0cy5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoaWdoQml0cyBUaGUgaGlnaCAzMiBiaXRzLlxyXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QuIERlZmF1bHRzIHRvIGZhbHNlIChzaWduZWQpLlxyXG4gICAgICogQHJldHVybiB7IUxvbmd9IFRoZSBjb3JyZXNwb25kaW5nIExvbmcgdmFsdWUuXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIExvbmcuZnJvbUJpdHMgPSBmdW5jdGlvbihsb3dCaXRzLCBoaWdoQml0cywgdW5zaWduZWQpIHtcclxuICAgICAgICByZXR1cm4gbmV3IExvbmcobG93Qml0cywgaGlnaEJpdHMsIHVuc2lnbmVkKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgTG9uZyByZXByZXNlbnRpbmcgdGhlIDY0Yml0IGludGVnZXIgdGhhdCBjb21lcyBieSBjb25jYXRlbmF0aW5nIHRoZSBnaXZlbiBsb3csIG1pZGRsZSBhbmQgaGlnaCBiaXRzLlxyXG4gICAgICogIEVhY2ggaXMgYXNzdW1lZCB0byB1c2UgMjggYml0cy5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwYXJ0MCBUaGUgbG93IDI4IGJpdHNcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwYXJ0MSBUaGUgbWlkZGxlIDI4IGJpdHNcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwYXJ0MiBUaGUgaGlnaCAyOCAoOCkgYml0c1xyXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QuIERlZmF1bHRzIHRvIGZhbHNlIChzaWduZWQpLlxyXG4gICAgICogQHJldHVybiB7IUxvbmd9XHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIExvbmcuZnJvbTI4Qml0cyA9IGZ1bmN0aW9uKHBhcnQwLCBwYXJ0MSwgcGFydDIsIHVuc2lnbmVkKSB7XHJcbiAgICAgICAgLy8gMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDExMTEgMTExMTExMTExMTExMTExMTExMTExMTExMjIyMjIyMjIgMjIyMjIyMjIyMjIyMlxyXG4gICAgICAgIC8vIExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMIEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhIXHJcbiAgICAgICAgcmV0dXJuIExvbmcuZnJvbUJpdHMocGFydDAgfCAocGFydDEgPDwgMjgpLCAocGFydDEgPj4+IDQpIHwgKHBhcnQyKSA8PCAyNCwgdW5zaWduZWQpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBMb25nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBzdHJpbmcsIHdyaXR0ZW4gdXNpbmcgdGhlIGdpdmVuXHJcbiAgICAgKiByYWRpeC5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgVGhlIHRleHR1YWwgcmVwcmVzZW50YXRpb24gb2YgdGhlIExvbmcuXHJcbiAgICAgKiBAcGFyYW0geyhib29sZWFufG51bWJlcik9fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdC4gRGVmYXVsdHMgdG8gZmFsc2UgKHNpZ25lZCkuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IHJhZGl4IFRoZSByYWRpeCBpbiB3aGljaCB0aGUgdGV4dCBpcyB3cml0dGVuLlxyXG4gICAgICogQHJldHVybiB7IUxvbmd9IFRoZSBjb3JyZXNwb25kaW5nIExvbmcgdmFsdWUuXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIExvbmcuZnJvbVN0cmluZyA9IGZ1bmN0aW9uKHN0ciwgdW5zaWduZWQsIHJhZGl4KSB7XHJcbiAgICAgICAgaWYgKHN0ci5sZW5ndGggPT0gMCkge1xyXG4gICAgICAgICAgICB0aHJvdyhuZXcgRXJyb3IoJ251bWJlciBmb3JtYXQgZXJyb3I6IGVtcHR5IHN0cmluZycpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHN0ciA9PT0gXCJOYU5cIiB8fCBzdHIgPT09IFwiSW5maW5pdHlcIiB8fCBzdHIgPT09IFwiK0luZmluaXR5XCIgfHwgc3RyID09PSBcIi1JbmZpbml0eVwiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBMb25nLlpFUk87XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2YgdW5zaWduZWQgPT09ICdudW1iZXInKSB7IC8vIEZvciBnb29nLm1hdGguTG9uZyBjb21wYXRpYmlsaXR5XHJcbiAgICAgICAgICAgIHJhZGl4ID0gdW5zaWduZWQ7XHJcbiAgICAgICAgICAgIHVuc2lnbmVkID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJhZGl4ID0gcmFkaXggfHwgMTA7XHJcbiAgICAgICAgaWYgKHJhZGl4IDwgMiB8fCAzNiA8IHJhZGl4KSB7XHJcbiAgICAgICAgICAgIHRocm93KG5ldyBFcnJvcigncmFkaXggb3V0IG9mIHJhbmdlOiAnICsgcmFkaXgpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChzdHIuY2hhckF0KDApID09ICctJykge1xyXG4gICAgICAgICAgICByZXR1cm4gTG9uZy5mcm9tU3RyaW5nKHN0ci5zdWJzdHJpbmcoMSksIHVuc2lnbmVkLCByYWRpeCkubmVnYXRlKCk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChzdHIuaW5kZXhPZignLScpID49IDApIHtcclxuICAgICAgICAgICAgdGhyb3cobmV3IEVycm9yKCdudW1iZXIgZm9ybWF0IGVycm9yOiBpbnRlcmlvciBcIi1cIiBjaGFyYWN0ZXI6ICcgKyBzdHIpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIERvIHNldmVyYWwgKDgpIGRpZ2l0cyBlYWNoIHRpbWUgdGhyb3VnaCB0aGUgbG9vcCwgc28gYXMgdG9cclxuICAgICAgICAvLyBtaW5pbWl6ZSB0aGUgY2FsbHMgdG8gdGhlIHZlcnkgZXhwZW5zaXZlIGVtdWxhdGVkIGRpdi5cclxuICAgICAgICB2YXIgcmFkaXhUb1Bvd2VyID0gTG9uZy5mcm9tTnVtYmVyKE1hdGgucG93KHJhZGl4LCA4KSk7XHJcblxyXG4gICAgICAgIHZhciByZXN1bHQgPSBMb25nLlpFUk87XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpICs9IDgpIHtcclxuICAgICAgICAgICAgdmFyIHNpemUgPSBNYXRoLm1pbig4LCBzdHIubGVuZ3RoIC0gaSk7XHJcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHBhcnNlSW50KHN0ci5zdWJzdHJpbmcoaSwgaSArIHNpemUpLCByYWRpeCk7XHJcbiAgICAgICAgICAgIGlmIChzaXplIDwgOCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBvd2VyID0gTG9uZy5mcm9tTnVtYmVyKE1hdGgucG93KHJhZGl4LCBzaXplKSk7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQubXVsdGlwbHkocG93ZXIpLmFkZChMb25nLmZyb21OdW1iZXIodmFsdWUpKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5tdWx0aXBseShyYWRpeFRvUG93ZXIpO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmFkZChMb25nLmZyb21OdW1iZXIodmFsdWUpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXN1bHQudW5zaWduZWQgPSB1bnNpZ25lZDtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBOT1RFOiB0aGUgY29tcGlsZXIgc2hvdWxkIGlubGluZSB0aGVzZSBjb25zdGFudCB2YWx1ZXMgYmVsb3cgYW5kIHRoZW4gcmVtb3ZlIHRoZXNlIHZhcmlhYmxlcywgc28gdGhlcmUgc2hvdWxkIGJlXHJcbiAgICAvLyBubyBydW50aW1lIHBlbmFsdHkgZm9yIHRoZXNlLlxyXG4gICAgXHJcbiAgICAvLyBOT1RFOiBUaGUgZm9sbG93aW5nIGNvbnN0YW50IHZhbHVlcyBhcmUgdXNlZCBpbnRlcm5hbGx5IG9ubHkgYW5kIGFyZSB0aGVyZWZvcmUgbm90IGV4cG9zZWQgYXMgcHJvcGVydGllcyBvZiB0aGVcclxuICAgIC8vIExvbmcgY2xhc3MuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB2YXIgVFdPX1BXUl8xNl9EQkwgPSAxIDw8IDE2O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgdmFyIFRXT19QV1JfMjRfREJMID0gMSA8PCAyNDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHZhciBUV09fUFdSXzMyX0RCTCA9IFRXT19QV1JfMTZfREJMICogVFdPX1BXUl8xNl9EQkw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB2YXIgVFdPX1BXUl8zMV9EQkwgPSBUV09fUFdSXzMyX0RCTCAvIDI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB2YXIgVFdPX1BXUl80OF9EQkwgPSBUV09fUFdSXzMyX0RCTCAqIFRXT19QV1JfMTZfREJMO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgdmFyIFRXT19QV1JfNjRfREJMID0gVFdPX1BXUl8zMl9EQkwgKiBUV09fUFdSXzMyX0RCTDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHZhciBUV09fUFdSXzYzX0RCTCA9IFRXT19QV1JfNjRfREJMIC8gMjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHshTG9uZ31cclxuICAgICAqL1xyXG4gICAgdmFyIFRXT19QV1JfMjQgPSBMb25nLmZyb21JbnQoMSA8PCAyNCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAdHlwZSB7IUxvbmd9XHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIExvbmcuWkVSTyA9IExvbmcuZnJvbUludCgwKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHshTG9uZ31cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgTG9uZy5VWkVSTyA9IExvbmcuZnJvbUludCgwLCB0cnVlKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHshTG9uZ31cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgTG9uZy5PTkUgPSBMb25nLmZyb21JbnQoMSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAdHlwZSB7IUxvbmd9XHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIExvbmcuVU9ORSA9IExvbmcuZnJvbUludCgxLCB0cnVlKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHshTG9uZ31cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgTG9uZy5ORUdfT05FID0gTG9uZy5mcm9tSW50KC0xKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHshTG9uZ31cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgTG9uZy5NQVhfU0lHTkVEX1ZBTFVFID0gTG9uZy5mcm9tQml0cygweEZGRkZGRkZGIHwgMCwgMHg3RkZGRkZGRiB8IDAsIGZhbHNlKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHshTG9uZ31cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgTG9uZy5NQVhfVU5TSUdORURfVkFMVUUgPSBMb25nLmZyb21CaXRzKDB4RkZGRkZGRkYgfCAwLCAweEZGRkZGRkZGIHwgMCwgdHJ1ZSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBbGlhcyBvZiB7QGxpbmsgTG9uZy5NQVhfU0lHTkVEX1ZBTFVFfSBmb3IgZ29vZy5tYXRoLkxvbmcgY29tcGF0aWJpbGl0eS5cclxuICAgICAqIEB0eXBlIHshTG9uZ31cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgTG9uZy5NQVhfVkFMVUUgPSBMb25nLk1BWF9TSUdORURfVkFMVUU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAdHlwZSB7IUxvbmd9XHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIExvbmcuTUlOX1NJR05FRF9WQUxVRSA9IExvbmcuZnJvbUJpdHMoMCwgMHg4MDAwMDAwMCB8IDAsIGZhbHNlKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHshTG9uZ31cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgTG9uZy5NSU5fVU5TSUdORURfVkFMVUUgPSBMb25nLmZyb21CaXRzKDAsIDAsIHRydWUpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWxpYXMgb2Yge0BsaW5rIExvbmcuTUlOX1NJR05FRF9WQUxVRX0gIGZvciBnb29nLm1hdGguTG9uZyBjb21wYXRpYmlsaXR5LlxyXG4gICAgICogQHR5cGUgeyFMb25nfVxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBMb25nLk1JTl9WQUxVRSA9IExvbmcuTUlOX1NJR05FRF9WQUxVRTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4ge251bWJlcn0gVGhlIHZhbHVlLCBhc3N1bWluZyBpdCBpcyBhIDMyLWJpdCBpbnRlZ2VyLlxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBMb25nLnByb3RvdHlwZS50b0ludCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnVuc2lnbmVkID8gdGhpcy5sb3cgPj4+IDAgOiB0aGlzLmxvdztcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBjbG9zZXN0IGZsb2F0aW5nLXBvaW50IHJlcHJlc2VudGF0aW9uIHRvIHRoaXMgdmFsdWUuXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIExvbmcucHJvdG90eXBlLnRvTnVtYmVyID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKHRoaXMudW5zaWduZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuICgodGhpcy5oaWdoID4+PiAwKSAqIFRXT19QV1JfMzJfREJMKSArICh0aGlzLmxvdyA+Pj4gMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmhpZ2ggKiBUV09fUFdSXzMyX0RCTCArICh0aGlzLmxvdyA+Pj4gMCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSByYWRpeCBUaGUgcmFkaXggaW4gd2hpY2ggdGhlIHRleHQgc2hvdWxkIGJlIHdyaXR0ZW4uXHJcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSB0ZXh0dWFsIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgdmFsdWUuXHJcbiAgICAgKiBAb3ZlcnJpZGVcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgTG9uZy5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbihyYWRpeCkge1xyXG4gICAgICAgIHJhZGl4ID0gcmFkaXggfHwgMTA7XHJcbiAgICAgICAgaWYgKHJhZGl4IDwgMiB8fCAzNiA8IHJhZGl4KSB7XHJcbiAgICAgICAgICAgIHRocm93KG5ldyBFcnJvcigncmFkaXggb3V0IG9mIHJhbmdlOiAnICsgcmFkaXgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuaXNaZXJvKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuICcwJztcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHJlbTtcclxuICAgICAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpIHsgLy8gVW5zaWduZWQgTG9uZ3MgYXJlIG5ldmVyIG5lZ2F0aXZlXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmVxdWFscyhMb25nLk1JTl9TSUdORURfVkFMVUUpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBXZSBuZWVkIHRvIGNoYW5nZSB0aGUgTG9uZyB2YWx1ZSBiZWZvcmUgaXQgY2FuIGJlIG5lZ2F0ZWQsIHNvIHdlIHJlbW92ZVxyXG4gICAgICAgICAgICAgICAgLy8gdGhlIGJvdHRvbS1tb3N0IGRpZ2l0IGluIHRoaXMgYmFzZSBhbmQgdGhlbiByZWN1cnNlIHRvIGRvIHRoZSByZXN0LlxyXG4gICAgICAgICAgICAgICAgdmFyIHJhZGl4TG9uZyA9IExvbmcuZnJvbU51bWJlcihyYWRpeCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGl2ID0gdGhpcy5kaXYocmFkaXhMb25nKTtcclxuICAgICAgICAgICAgICAgIHJlbSA9IGRpdi5tdWx0aXBseShyYWRpeExvbmcpLnN1YnRyYWN0KHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRpdi50b1N0cmluZyhyYWRpeCkgKyByZW0udG9JbnQoKS50b1N0cmluZyhyYWRpeCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJy0nICsgdGhpcy5uZWdhdGUoKS50b1N0cmluZyhyYWRpeCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIERvIHNldmVyYWwgKDYpIGRpZ2l0cyBlYWNoIHRpbWUgdGhyb3VnaCB0aGUgbG9vcCwgc28gYXMgdG9cclxuICAgICAgICAvLyBtaW5pbWl6ZSB0aGUgY2FsbHMgdG8gdGhlIHZlcnkgZXhwZW5zaXZlIGVtdWxhdGVkIGRpdi5cclxuICAgICAgICB2YXIgcmFkaXhUb1Bvd2VyID0gTG9uZy5mcm9tTnVtYmVyKE1hdGgucG93KHJhZGl4LCA2KSk7XHJcbiAgICAgICAgcmVtID0gdGhpcztcclxuICAgICAgICB2YXIgcmVzdWx0ID0gJyc7XHJcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICAgICAgdmFyIHJlbURpdiA9IHJlbS5kaXYocmFkaXhUb1Bvd2VyKTtcclxuICAgICAgICAgICAgdmFyIGludHZhbCA9IHJlbS5zdWJ0cmFjdChyZW1EaXYubXVsdGlwbHkocmFkaXhUb1Bvd2VyKSkudG9JbnQoKTtcclxuICAgICAgICAgICAgdmFyIGRpZ2l0cyA9IGludHZhbC50b1N0cmluZyhyYWRpeCk7XHJcbiAgICAgICAgICAgIHJlbSA9IHJlbURpdjtcclxuICAgICAgICAgICAgaWYgKHJlbS5pc1plcm8oKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRpZ2l0cyArIHJlc3VsdDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChkaWdpdHMubGVuZ3RoIDwgNikge1xyXG4gICAgICAgICAgICAgICAgICAgIGRpZ2l0cyA9ICcwJyArIGRpZ2l0cztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9ICcnICsgZGlnaXRzICsgcmVzdWx0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4ge251bWJlcn0gVGhlIGhpZ2ggMzIgYml0cyBhcyBhIHNpZ25lZCB2YWx1ZS5cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgTG9uZy5wcm90b3R5cGUuZ2V0SGlnaEJpdHMgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5oaWdoO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4ge251bWJlcn0gVGhlIGhpZ2ggMzIgYml0cyBhcyBhbiB1bnNpZ25lZCB2YWx1ZS5cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgTG9uZy5wcm90b3R5cGUuZ2V0SGlnaEJpdHNVbnNpZ25lZCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmhpZ2ggPj4+IDA7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgbG93IDMyIGJpdHMgYXMgYSBzaWduZWQgdmFsdWUuXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIExvbmcucHJvdG90eXBlLmdldExvd0JpdHMgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5sb3c7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgbG93IDMyIGJpdHMgYXMgYW4gdW5zaWduZWQgdmFsdWUuXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIExvbmcucHJvdG90eXBlLmdldExvd0JpdHNVbnNpZ25lZCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxvdyA+Pj4gMDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFJldHVybnMgdGhlIG51bWJlciBvZiBiaXRzIG5lZWRlZCB0byByZXByZXNlbnQgdGhlIGFic29sdXRlXHJcbiAgICAgKiAgICAgdmFsdWUgb2YgdGhpcyBMb25nLlxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBMb25nLnByb3RvdHlwZS5nZXROdW1CaXRzQWJzID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpKSB7IC8vIFVuc2lnbmVkIExvbmdzIGFyZSBuZXZlciBuZWdhdGl2ZVxyXG4gICAgICAgICAgICBpZiAodGhpcy5lcXVhbHMoTG9uZy5NSU5fU0lHTkVEX1ZBTFVFKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDY0O1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubmVnYXRlKCkuZ2V0TnVtQml0c0FicygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIHZhbCA9IHRoaXMuaGlnaCAhPSAwID8gdGhpcy5oaWdoIDogdGhpcy5sb3c7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGJpdCA9IDMxOyBiaXQgPiAwOyBiaXQtLSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCh2YWwgJiAoMSA8PCBiaXQpKSAhPSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGlnaCAhPSAwID8gYml0ICsgMzMgOiBiaXQgKyAxO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoaXMgdmFsdWUgaXMgemVyby5cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgTG9uZy5wcm90b3R5cGUuaXNaZXJvID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaGlnaCA9PSAwICYmIHRoaXMubG93ID09IDA7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGlzIHZhbHVlIGlzIG5lZ2F0aXZlLlxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBMb25nLnByb3RvdHlwZS5pc05lZ2F0aXZlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuICF0aGlzLnVuc2lnbmVkICYmIHRoaXMuaGlnaCA8IDA7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGlzIHZhbHVlIGlzIG9kZC5cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgTG9uZy5wcm90b3R5cGUuaXNPZGQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMubG93ICYgMSkgPT0gMTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoaXMgdmFsdWUgaXMgZXZlbi5cclxuICAgICAqL1xyXG4gICAgTG9uZy5wcm90b3R5cGUuaXNFdmVuID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLmxvdyAmIDEpID09IDA7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHtMb25nfSBvdGhlciBMb25nIHRvIGNvbXBhcmUgYWdhaW5zdC5cclxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhpcyBMb25nIGVxdWFscyB0aGUgb3RoZXIuXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIExvbmcucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uKG90aGVyKSB7XHJcbiAgICAgICAgaWYgKHRoaXMudW5zaWduZWQgIT0gb3RoZXIudW5zaWduZWQgJiYgKHRoaXMuaGlnaCA+Pj4gMzEpICE9IChvdGhlci5oaWdoID4+PiAzMSkpIHJldHVybiBmYWxzZTtcclxuICAgICAgICByZXR1cm4gKHRoaXMuaGlnaCA9PSBvdGhlci5oaWdoKSAmJiAodGhpcy5sb3cgPT0gb3RoZXIubG93KTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge0xvbmd9IG90aGVyIExvbmcgdG8gY29tcGFyZSBhZ2FpbnN0LlxyXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGlzIExvbmcgZG9lcyBub3QgZXF1YWwgdGhlIG90aGVyLlxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBMb25nLnByb3RvdHlwZS5ub3RFcXVhbHMgPSBmdW5jdGlvbihvdGhlcikge1xyXG4gICAgICAgIHJldHVybiAhdGhpcy5lcXVhbHMob3RoZXIpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7TG9uZ30gb3RoZXIgTG9uZyB0byBjb21wYXJlIGFnYWluc3QuXHJcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoaXMgTG9uZyBpcyBsZXNzIHRoYW4gdGhlIG90aGVyLlxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBMb25nLnByb3RvdHlwZS5sZXNzVGhhbiA9IGZ1bmN0aW9uKG90aGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGFyZShvdGhlcikgPCAwO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7TG9uZ30gb3RoZXIgTG9uZyB0byBjb21wYXJlIGFnYWluc3QuXHJcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoaXMgTG9uZyBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIG90aGVyLlxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBMb25nLnByb3RvdHlwZS5sZXNzVGhhbk9yRXF1YWwgPSBmdW5jdGlvbihvdGhlcikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBhcmUob3RoZXIpIDw9IDA7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHtMb25nfSBvdGhlciBMb25nIHRvIGNvbXBhcmUgYWdhaW5zdC5cclxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhpcyBMb25nIGlzIGdyZWF0ZXIgdGhhbiB0aGUgb3RoZXIuXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIExvbmcucHJvdG90eXBlLmdyZWF0ZXJUaGFuID0gZnVuY3Rpb24ob3RoZXIpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb21wYXJlKG90aGVyKSA+IDA7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHtMb25nfSBvdGhlciBMb25nIHRvIGNvbXBhcmUgYWdhaW5zdC5cclxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhpcyBMb25nIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB0aGUgb3RoZXIuXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIExvbmcucHJvdG90eXBlLmdyZWF0ZXJUaGFuT3JFcXVhbCA9IGZ1bmN0aW9uKG90aGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGFyZShvdGhlcikgPj0gMDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb21wYXJlcyB0aGlzIExvbmcgd2l0aCB0aGUgZ2l2ZW4gb25lLlxyXG4gICAgICogQHBhcmFtIHtMb25nfSBvdGhlciBMb25nIHRvIGNvbXBhcmUgYWdhaW5zdC5cclxuICAgICAqIEByZXR1cm4ge251bWJlcn0gMCBpZiB0aGV5IGFyZSB0aGUgc2FtZSwgMSBpZiB0aGUgdGhpcyBpcyBncmVhdGVyLCBhbmQgLTFcclxuICAgICAqICAgICBpZiB0aGUgZ2l2ZW4gb25lIGlzIGdyZWF0ZXIuXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIExvbmcucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbihvdGhlcikge1xyXG4gICAgICAgIGlmICh0aGlzLmVxdWFscyhvdGhlcikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB0aGlzTmVnID0gdGhpcy5pc05lZ2F0aXZlKCk7XHJcbiAgICAgICAgdmFyIG90aGVyTmVnID0gb3RoZXIuaXNOZWdhdGl2ZSgpO1xyXG4gICAgICAgIGlmICh0aGlzTmVnICYmICFvdGhlck5lZykgcmV0dXJuIC0xO1xyXG4gICAgICAgIGlmICghdGhpc05lZyAmJiBvdGhlck5lZykgcmV0dXJuIDE7XHJcbiAgICAgICAgaWYgKCF0aGlzLnVuc2lnbmVkKSB7XHJcbiAgICAgICAgICAgIC8vIEF0IHRoaXMgcG9pbnQgdGhlIHNpZ25zIGFyZSB0aGUgc2FtZVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdWJ0cmFjdChvdGhlcikuaXNOZWdhdGl2ZSgpID8gLTEgOiAxO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIEJvdGggYXJlIHBvc2l0aXZlIGlmIGF0IGxlYXN0IG9uZSBpcyB1bnNpZ25lZFxyXG4gICAgICAgICAgICByZXR1cm4gKG90aGVyLmhpZ2ggPj4+IDApID4gKHRoaXMuaGlnaCA+Pj4gMCkgfHwgKG90aGVyLmhpZ2ggPT0gdGhpcy5oaWdoICYmIChvdGhlci5sb3cgPj4+IDApID4gKHRoaXMubG93ID4+PiAwKSkgPyAtMSA6IDE7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4geyFMb25nfSBUaGUgbmVnYXRpb24gb2YgdGhpcyB2YWx1ZS5cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgTG9uZy5wcm90b3R5cGUubmVnYXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLnVuc2lnbmVkICYmIHRoaXMuZXF1YWxzKExvbmcuTUlOX1NJR05FRF9WQUxVRSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIExvbmcuTUlOX1NJR05FRF9WQUxVRTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubm90KCkuYWRkKExvbmcuT05FKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBzdW0gb2YgdGhpcyBhbmQgdGhlIGdpdmVuIExvbmcuXHJcbiAgICAgKiBAcGFyYW0ge0xvbmd9IG90aGVyIExvbmcgdG8gYWRkIHRvIHRoaXMgb25lLlxyXG4gICAgICogQHJldHVybiB7IUxvbmd9IFRoZSBzdW0gb2YgdGhpcyBhbmQgdGhlIGdpdmVuIExvbmcuXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIExvbmcucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKG90aGVyKSB7XHJcbiAgICAgICAgLy8gRGl2aWRlIGVhY2ggbnVtYmVyIGludG8gNCBjaHVua3Mgb2YgMTYgYml0cywgYW5kIHRoZW4gc3VtIHRoZSBjaHVua3MuXHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIGE0OCA9IHRoaXMuaGlnaCA+Pj4gMTY7XHJcbiAgICAgICAgdmFyIGEzMiA9IHRoaXMuaGlnaCAmIDB4RkZGRjtcclxuICAgICAgICB2YXIgYTE2ID0gdGhpcy5sb3cgPj4+IDE2O1xyXG4gICAgICAgIHZhciBhMDAgPSB0aGlzLmxvdyAmIDB4RkZGRjtcclxuXHJcbiAgICAgICAgdmFyIGI0OCA9IG90aGVyLmhpZ2ggPj4+IDE2O1xyXG4gICAgICAgIHZhciBiMzIgPSBvdGhlci5oaWdoICYgMHhGRkZGO1xyXG4gICAgICAgIHZhciBiMTYgPSBvdGhlci5sb3cgPj4+IDE2O1xyXG4gICAgICAgIHZhciBiMDAgPSBvdGhlci5sb3cgJiAweEZGRkY7XHJcblxyXG4gICAgICAgIHZhciBjNDggPSAwLCBjMzIgPSAwLCBjMTYgPSAwLCBjMDAgPSAwO1xyXG4gICAgICAgIGMwMCArPSBhMDAgKyBiMDA7XHJcbiAgICAgICAgYzE2ICs9IGMwMCA+Pj4gMTY7XHJcbiAgICAgICAgYzAwICY9IDB4RkZGRjtcclxuICAgICAgICBjMTYgKz0gYTE2ICsgYjE2O1xyXG4gICAgICAgIGMzMiArPSBjMTYgPj4+IDE2O1xyXG4gICAgICAgIGMxNiAmPSAweEZGRkY7XHJcbiAgICAgICAgYzMyICs9IGEzMiArIGIzMjtcclxuICAgICAgICBjNDggKz0gYzMyID4+PiAxNjtcclxuICAgICAgICBjMzIgJj0gMHhGRkZGO1xyXG4gICAgICAgIGM0OCArPSBhNDggKyBiNDg7XHJcbiAgICAgICAgYzQ4ICY9IDB4RkZGRjtcclxuICAgICAgICByZXR1cm4gTG9uZy5mcm9tQml0cygoYzE2IDw8IDE2KSB8IGMwMCwgKGM0OCA8PCAxNikgfCBjMzIsIHRoaXMudW5zaWduZWQpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGRpZmZlcmVuY2Ugb2YgdGhpcyBhbmQgdGhlIGdpdmVuIExvbmcuXHJcbiAgICAgKiBAcGFyYW0ge0xvbmd9IG90aGVyIExvbmcgdG8gc3VidHJhY3QgZnJvbSB0aGlzLlxyXG4gICAgICogQHJldHVybiB7IUxvbmd9IFRoZSBkaWZmZXJlbmNlIG9mIHRoaXMgYW5kIHRoZSBnaXZlbiBMb25nLlxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBMb25nLnByb3RvdHlwZS5zdWJ0cmFjdCA9IGZ1bmN0aW9uKG90aGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkKG90aGVyLm5lZ2F0ZSgpKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBwcm9kdWN0IG9mIHRoaXMgYW5kIHRoZSBnaXZlbiBsb25nLlxyXG4gICAgICogQHBhcmFtIHtMb25nfSBvdGhlciBMb25nIHRvIG11bHRpcGx5IHdpdGggdGhpcy5cclxuICAgICAqIEByZXR1cm4geyFMb25nfSBUaGUgcHJvZHVjdCBvZiB0aGlzIGFuZCB0aGUgb3RoZXIuXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIExvbmcucHJvdG90eXBlLm11bHRpcGx5ID0gZnVuY3Rpb24ob3RoZXIpIHtcclxuICAgICAgICBpZiAodGhpcy5pc1plcm8oKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gTG9uZy5aRVJPO1xyXG4gICAgICAgIH0gZWxzZSBpZiAob3RoZXIuaXNaZXJvKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIExvbmcuWkVSTztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmVxdWFscyhMb25nLk1JTl9WQUxVRSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG90aGVyLmlzT2RkKCkgPyBMb25nLk1JTl9WQUxVRSA6IExvbmcuWkVSTztcclxuICAgICAgICB9IGVsc2UgaWYgKG90aGVyLmVxdWFscyhMb25nLk1JTl9WQUxVRSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNPZGQoKSA/IExvbmcuTUlOX1ZBTFVFIDogTG9uZy5aRVJPO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpKSB7XHJcbiAgICAgICAgICAgIGlmIChvdGhlci5pc05lZ2F0aXZlKCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm5lZ2F0ZSgpLm11bHRpcGx5KG90aGVyLm5lZ2F0ZSgpKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm5lZ2F0ZSgpLm11bHRpcGx5KG90aGVyKS5uZWdhdGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAob3RoZXIuaXNOZWdhdGl2ZSgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm11bHRpcGx5KG90aGVyLm5lZ2F0ZSgpKS5uZWdhdGUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gSWYgYm90aCBsb25ncyBhcmUgc21hbGwsIHVzZSBmbG9hdCBtdWx0aXBsaWNhdGlvblxyXG4gICAgICAgIGlmICh0aGlzLmxlc3NUaGFuKFRXT19QV1JfMjQpICYmXHJcbiAgICAgICAgICAgIG90aGVyLmxlc3NUaGFuKFRXT19QV1JfMjQpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBMb25nLmZyb21OdW1iZXIodGhpcy50b051bWJlcigpICogb3RoZXIudG9OdW1iZXIoKSwgdGhpcy51bnNpZ25lZCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBEaXZpZGUgZWFjaCBsb25nIGludG8gNCBjaHVua3Mgb2YgMTYgYml0cywgYW5kIHRoZW4gYWRkIHVwIDR4NCBwcm9kdWN0cy5cclxuICAgICAgICAvLyBXZSBjYW4gc2tpcCBwcm9kdWN0cyB0aGF0IHdvdWxkIG92ZXJmbG93LlxyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBhNDggPSB0aGlzLmhpZ2ggPj4+IDE2O1xyXG4gICAgICAgIHZhciBhMzIgPSB0aGlzLmhpZ2ggJiAweEZGRkY7XHJcbiAgICAgICAgdmFyIGExNiA9IHRoaXMubG93ID4+PiAxNjtcclxuICAgICAgICB2YXIgYTAwID0gdGhpcy5sb3cgJiAweEZGRkY7XHJcblxyXG4gICAgICAgIHZhciBiNDggPSBvdGhlci5oaWdoID4+PiAxNjtcclxuICAgICAgICB2YXIgYjMyID0gb3RoZXIuaGlnaCAmIDB4RkZGRjtcclxuICAgICAgICB2YXIgYjE2ID0gb3RoZXIubG93ID4+PiAxNjtcclxuICAgICAgICB2YXIgYjAwID0gb3RoZXIubG93ICYgMHhGRkZGO1xyXG5cclxuICAgICAgICB2YXIgYzQ4ID0gMCwgYzMyID0gMCwgYzE2ID0gMCwgYzAwID0gMDtcclxuICAgICAgICBjMDAgKz0gYTAwICogYjAwO1xyXG4gICAgICAgIGMxNiArPSBjMDAgPj4+IDE2O1xyXG4gICAgICAgIGMwMCAmPSAweEZGRkY7XHJcbiAgICAgICAgYzE2ICs9IGExNiAqIGIwMDtcclxuICAgICAgICBjMzIgKz0gYzE2ID4+PiAxNjtcclxuICAgICAgICBjMTYgJj0gMHhGRkZGO1xyXG4gICAgICAgIGMxNiArPSBhMDAgKiBiMTY7XHJcbiAgICAgICAgYzMyICs9IGMxNiA+Pj4gMTY7XHJcbiAgICAgICAgYzE2ICY9IDB4RkZGRjtcclxuICAgICAgICBjMzIgKz0gYTMyICogYjAwO1xyXG4gICAgICAgIGM0OCArPSBjMzIgPj4+IDE2O1xyXG4gICAgICAgIGMzMiAmPSAweEZGRkY7XHJcbiAgICAgICAgYzMyICs9IGExNiAqIGIxNjtcclxuICAgICAgICBjNDggKz0gYzMyID4+PiAxNjtcclxuICAgICAgICBjMzIgJj0gMHhGRkZGO1xyXG4gICAgICAgIGMzMiArPSBhMDAgKiBiMzI7XHJcbiAgICAgICAgYzQ4ICs9IGMzMiA+Pj4gMTY7XHJcbiAgICAgICAgYzMyICY9IDB4RkZGRjtcclxuICAgICAgICBjNDggKz0gYTQ4ICogYjAwICsgYTMyICogYjE2ICsgYTE2ICogYjMyICsgYTAwICogYjQ4O1xyXG4gICAgICAgIGM0OCAmPSAweEZGRkY7XHJcbiAgICAgICAgcmV0dXJuIExvbmcuZnJvbUJpdHMoKGMxNiA8PCAxNikgfCBjMDAsIChjNDggPDwgMTYpIHwgYzMyLCB0aGlzLnVuc2lnbmVkKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoaXMgTG9uZyBkaXZpZGVkIGJ5IHRoZSBnaXZlbiBvbmUuXHJcbiAgICAgKiBAcGFyYW0ge0xvbmd9IG90aGVyIExvbmcgYnkgd2hpY2ggdG8gZGl2aWRlLlxyXG4gICAgICogQHJldHVybiB7IUxvbmd9IFRoaXMgTG9uZyBkaXZpZGVkIGJ5IHRoZSBnaXZlbiBvbmUuXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIExvbmcucHJvdG90eXBlLmRpdiA9IGZ1bmN0aW9uKG90aGVyKSB7XHJcbiAgICAgICAgaWYgKG90aGVyLmlzWmVybygpKSB7XHJcbiAgICAgICAgICAgIHRocm93KG5ldyBFcnJvcignZGl2aXNpb24gYnkgemVybycpKTtcclxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaXNaZXJvKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudW5zaWduZWQgPyBMb25nLlVaRVJPIDogTG9uZy5aRVJPO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgYXBwcm94LCByZW0sIHJlcztcclxuICAgICAgICBpZiAodGhpcy5lcXVhbHMoTG9uZy5NSU5fU0lHTkVEX1ZBTFVFKSkge1xyXG4gICAgICAgICAgICBpZiAob3RoZXIuZXF1YWxzKExvbmcuT05FKSB8fCBvdGhlci5lcXVhbHMoTG9uZy5ORUdfT05FKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIExvbmcuTUlOX1NJR05FRF9WQUxVRTsgIC8vIHJlY2FsbCB0aGF0IC1NSU5fVkFMVUUgPT0gTUlOX1ZBTFVFXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAob3RoZXIuZXF1YWxzKExvbmcuTUlOX1NJR05FRF9WQUxVRSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBMb25nLk9ORTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIEF0IHRoaXMgcG9pbnQsIHdlIGhhdmUgfG90aGVyfCA+PSAyLCBzbyB8dGhpcy9vdGhlcnwgPCB8TUlOX1ZBTFVFfC5cclxuICAgICAgICAgICAgICAgIHZhciBoYWxmVGhpcyA9IHRoaXMuc2hpZnRSaWdodCgxKTtcclxuICAgICAgICAgICAgICAgIGFwcHJveCA9IGhhbGZUaGlzLmRpdihvdGhlcikuc2hpZnRMZWZ0KDEpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGFwcHJveC5lcXVhbHMoTG9uZy5aRVJPKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvdGhlci5pc05lZ2F0aXZlKCkgPyBMb25nLk9ORSA6IExvbmcuTkVHX09ORTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVtID0gdGhpcy5zdWJ0cmFjdChvdGhlci5tdWx0aXBseShhcHByb3gpKTtcclxuICAgICAgICAgICAgICAgICAgICByZXMgPSBhcHByb3guYWRkKHJlbS5kaXYob3RoZXIpKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmIChvdGhlci5lcXVhbHMoTG9uZy5NSU5fU0lHTkVEX1ZBTFVFKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy51bnNpZ25lZCA/IExvbmcuVVpFUk8gOiBMb25nLlpFUk87XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSkge1xyXG4gICAgICAgICAgICBpZiAob3RoZXIuaXNOZWdhdGl2ZSgpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5uZWdhdGUoKS5kaXYob3RoZXIubmVnYXRlKCkpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubmVnYXRlKCkuZGl2KG90aGVyKS5uZWdhdGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAob3RoZXIuaXNOZWdhdGl2ZSgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRpdihvdGhlci5uZWdhdGUoKSkubmVnYXRlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIFJlcGVhdCB0aGUgZm9sbG93aW5nIHVudGlsIHRoZSByZW1haW5kZXIgaXMgbGVzcyB0aGFuIG90aGVyOiAgZmluZCBhXHJcbiAgICAgICAgLy8gZmxvYXRpbmctcG9pbnQgdGhhdCBhcHByb3hpbWF0ZXMgcmVtYWluZGVyIC8gb3RoZXIgKmZyb20gYmVsb3cqLCBhZGQgdGhpc1xyXG4gICAgICAgIC8vIGludG8gdGhlIHJlc3VsdCwgYW5kIHN1YnRyYWN0IGl0IGZyb20gdGhlIHJlbWFpbmRlci4gIEl0IGlzIGNyaXRpY2FsIHRoYXRcclxuICAgICAgICAvLyB0aGUgYXBwcm94aW1hdGUgdmFsdWUgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSByZWFsIHZhbHVlIHNvIHRoYXQgdGhlXHJcbiAgICAgICAgLy8gcmVtYWluZGVyIG5ldmVyIGJlY29tZXMgbmVnYXRpdmUuXHJcbiAgICAgICAgcmVzID0gTG9uZy5aRVJPO1xyXG4gICAgICAgIHJlbSA9IHRoaXM7XHJcbiAgICAgICAgd2hpbGUgKHJlbS5ncmVhdGVyVGhhbk9yRXF1YWwob3RoZXIpKSB7XHJcbiAgICAgICAgICAgIC8vIEFwcHJveGltYXRlIHRoZSByZXN1bHQgb2YgZGl2aXNpb24uIFRoaXMgbWF5IGJlIGEgbGl0dGxlIGdyZWF0ZXIgb3JcclxuICAgICAgICAgICAgLy8gc21hbGxlciB0aGFuIHRoZSBhY3R1YWwgdmFsdWUuXHJcbiAgICAgICAgICAgIGFwcHJveCA9IE1hdGgubWF4KDEsIE1hdGguZmxvb3IocmVtLnRvTnVtYmVyKCkgLyBvdGhlci50b051bWJlcigpKSk7XHJcblxyXG4gICAgICAgICAgICAvLyBXZSB3aWxsIHR3ZWFrIHRoZSBhcHByb3hpbWF0ZSByZXN1bHQgYnkgY2hhbmdpbmcgaXQgaW4gdGhlIDQ4LXRoIGRpZ2l0IG9yXHJcbiAgICAgICAgICAgIC8vIHRoZSBzbWFsbGVzdCBub24tZnJhY3Rpb25hbCBkaWdpdCwgd2hpY2hldmVyIGlzIGxhcmdlci5cclxuICAgICAgICAgICAgdmFyIGxvZzIgPSBNYXRoLmNlaWwoTWF0aC5sb2coYXBwcm94KSAvIE1hdGguTE4yKTtcclxuICAgICAgICAgICAgdmFyIGRlbHRhID0gKGxvZzIgPD0gNDgpID8gMSA6IE1hdGgucG93KDIsIGxvZzIgLSA0OCk7XHJcblxyXG4gICAgICAgICAgICAvLyBEZWNyZWFzZSB0aGUgYXBwcm94aW1hdGlvbiB1bnRpbCBpdCBpcyBzbWFsbGVyIHRoYW4gdGhlIHJlbWFpbmRlci4gIE5vdGVcclxuICAgICAgICAgICAgLy8gdGhhdCBpZiBpdCBpcyB0b28gbGFyZ2UsIHRoZSBwcm9kdWN0IG92ZXJmbG93cyBhbmQgaXMgbmVnYXRpdmUuXHJcbiAgICAgICAgICAgIHZhciBhcHByb3hSZXMgPSBMb25nLmZyb21OdW1iZXIoYXBwcm94LCB0aGlzLnVuc2lnbmVkKTtcclxuICAgICAgICAgICAgdmFyIGFwcHJveFJlbSA9IGFwcHJveFJlcy5tdWx0aXBseShvdGhlcik7XHJcbiAgICAgICAgICAgIHdoaWxlIChhcHByb3hSZW0uaXNOZWdhdGl2ZSgpIHx8IGFwcHJveFJlbS5ncmVhdGVyVGhhbihyZW0pKSB7XHJcbiAgICAgICAgICAgICAgICBhcHByb3ggLT0gZGVsdGE7XHJcbiAgICAgICAgICAgICAgICBhcHByb3hSZXMgPSBMb25nLmZyb21OdW1iZXIoYXBwcm94LCB0aGlzLnVuc2lnbmVkKTtcclxuICAgICAgICAgICAgICAgIGFwcHJveFJlbSA9IGFwcHJveFJlcy5tdWx0aXBseShvdGhlcik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFdlIGtub3cgdGhlIGFuc3dlciBjYW4ndCBiZSB6ZXJvLi4uIGFuZCBhY3R1YWxseSwgemVybyB3b3VsZCBjYXVzZVxyXG4gICAgICAgICAgICAvLyBpbmZpbml0ZSByZWN1cnNpb24gc2luY2Ugd2Ugd291bGQgbWFrZSBubyBwcm9ncmVzcy5cclxuICAgICAgICAgICAgaWYgKGFwcHJveFJlcy5pc1plcm8oKSkge1xyXG4gICAgICAgICAgICAgICAgYXBwcm94UmVzID0gTG9uZy5PTkU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJlcyA9IHJlcy5hZGQoYXBwcm94UmVzKTtcclxuICAgICAgICAgICAgcmVtID0gcmVtLnN1YnRyYWN0KGFwcHJveFJlbSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGlzIExvbmcgbW9kdWxvIHRoZSBnaXZlbiBvbmUuXHJcbiAgICAgKiBAcGFyYW0ge0xvbmd9IG90aGVyIExvbmcgYnkgd2hpY2ggdG8gbW9kLlxyXG4gICAgICogQHJldHVybiB7IUxvbmd9IFRoaXMgTG9uZyBtb2R1bG8gdGhlIGdpdmVuIG9uZS5cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgTG9uZy5wcm90b3R5cGUubW9kdWxvID0gZnVuY3Rpb24ob3RoZXIpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zdWJ0cmFjdCh0aGlzLmRpdihvdGhlcikubXVsdGlwbHkob3RoZXIpKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIHshTG9uZ30gVGhlIGJpdHdpc2UtTk9UIG9mIHRoaXMgdmFsdWUuXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIExvbmcucHJvdG90eXBlLm5vdCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBMb25nLmZyb21CaXRzKH50aGlzLmxvdywgfnRoaXMuaGlnaCwgdGhpcy51bnNpZ25lZCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgYml0d2lzZS1BTkQgb2YgdGhpcyBMb25nIGFuZCB0aGUgZ2l2ZW4gb25lLlxyXG4gICAgICogQHBhcmFtIHtMb25nfSBvdGhlciBUaGUgTG9uZyB3aXRoIHdoaWNoIHRvIEFORC5cclxuICAgICAqIEByZXR1cm4geyFMb25nfSBUaGUgYml0d2lzZS1BTkQgb2YgdGhpcyBhbmQgdGhlIG90aGVyLlxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBMb25nLnByb3RvdHlwZS5hbmQgPSBmdW5jdGlvbihvdGhlcikge1xyXG4gICAgICAgIHJldHVybiBMb25nLmZyb21CaXRzKHRoaXMubG93ICYgb3RoZXIubG93LCB0aGlzLmhpZ2ggJiBvdGhlci5oaWdoLCB0aGlzLnVuc2lnbmVkKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBiaXR3aXNlLU9SIG9mIHRoaXMgTG9uZyBhbmQgdGhlIGdpdmVuIG9uZS5cclxuICAgICAqIEBwYXJhbSB7TG9uZ30gb3RoZXIgVGhlIExvbmcgd2l0aCB3aGljaCB0byBPUi5cclxuICAgICAqIEByZXR1cm4geyFMb25nfSBUaGUgYml0d2lzZS1PUiBvZiB0aGlzIGFuZCB0aGUgb3RoZXIuXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIExvbmcucHJvdG90eXBlLm9yID0gZnVuY3Rpb24ob3RoZXIpIHtcclxuICAgICAgICByZXR1cm4gTG9uZy5mcm9tQml0cyh0aGlzLmxvdyB8IG90aGVyLmxvdywgdGhpcy5oaWdoIHwgb3RoZXIuaGlnaCwgdGhpcy51bnNpZ25lZCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgYml0d2lzZS1YT1Igb2YgdGhpcyBMb25nIGFuZCB0aGUgZ2l2ZW4gb25lLlxyXG4gICAgICogQHBhcmFtIHtMb25nfSBvdGhlciBUaGUgTG9uZyB3aXRoIHdoaWNoIHRvIFhPUi5cclxuICAgICAqIEByZXR1cm4geyFMb25nfSBUaGUgYml0d2lzZS1YT1Igb2YgdGhpcyBhbmQgdGhlIG90aGVyLlxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBMb25nLnByb3RvdHlwZS54b3IgPSBmdW5jdGlvbihvdGhlcikge1xyXG4gICAgICAgIHJldHVybiBMb25nLmZyb21CaXRzKHRoaXMubG93IF4gb3RoZXIubG93LCB0aGlzLmhpZ2ggXiBvdGhlci5oaWdoLCB0aGlzLnVuc2lnbmVkKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgc2hpZnRlZCB0byB0aGUgbGVmdCBieSB0aGUgZ2l2ZW4gYW1vdW50LlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG51bUJpdHMgVGhlIG51bWJlciBvZiBiaXRzIGJ5IHdoaWNoIHRvIHNoaWZ0LlxyXG4gICAgICogQHJldHVybiB7IUxvbmd9IFRoaXMgc2hpZnRlZCB0byB0aGUgbGVmdCBieSB0aGUgZ2l2ZW4gYW1vdW50LlxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBMb25nLnByb3RvdHlwZS5zaGlmdExlZnQgPSBmdW5jdGlvbihudW1CaXRzKSB7XHJcbiAgICAgICAgbnVtQml0cyAmPSA2MztcclxuICAgICAgICBpZiAobnVtQml0cyA9PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBsb3cgPSB0aGlzLmxvdztcclxuICAgICAgICAgICAgaWYgKG51bUJpdHMgPCAzMikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGhpZ2ggPSB0aGlzLmhpZ2g7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gTG9uZy5mcm9tQml0cyhsb3cgPDwgbnVtQml0cywgKGhpZ2ggPDwgbnVtQml0cykgfCAobG93ID4+PiAoMzIgLSBudW1CaXRzKSksIHRoaXMudW5zaWduZWQpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIExvbmcuZnJvbUJpdHMoMCwgbG93IDw8IChudW1CaXRzIC0gMzIpLCB0aGlzLnVuc2lnbmVkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgc2hpZnRlZCB0byB0aGUgcmlnaHQgYnkgdGhlIGdpdmVuIGFtb3VudC5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1CaXRzIFRoZSBudW1iZXIgb2YgYml0cyBieSB3aGljaCB0byBzaGlmdC5cclxuICAgICAqIEByZXR1cm4geyFMb25nfSBUaGlzIHNoaWZ0ZWQgdG8gdGhlIHJpZ2h0IGJ5IHRoZSBnaXZlbiBhbW91bnQuXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIExvbmcucHJvdG90eXBlLnNoaWZ0UmlnaHQgPSBmdW5jdGlvbihudW1CaXRzKSB7XHJcbiAgICAgICAgbnVtQml0cyAmPSA2MztcclxuICAgICAgICBpZiAobnVtQml0cyA9PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBoaWdoID0gdGhpcy5oaWdoO1xyXG4gICAgICAgICAgICBpZiAobnVtQml0cyA8IDMyKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbG93ID0gdGhpcy5sb3c7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gTG9uZy5mcm9tQml0cygobG93ID4+PiBudW1CaXRzKSB8IChoaWdoIDw8ICgzMiAtIG51bUJpdHMpKSwgaGlnaCA+PiBudW1CaXRzLCB0aGlzLnVuc2lnbmVkKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBMb25nLmZyb21CaXRzKGhpZ2ggPj4gKG51bUJpdHMgLSAzMiksIGhpZ2ggPj0gMCA/IDAgOiAtMSwgdGhpcy51bnNpZ25lZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGlzIExvbmcgd2l0aCBiaXRzIHNoaWZ0ZWQgdG8gdGhlIHJpZ2h0IGJ5IHRoZSBnaXZlbiBhbW91bnQsIHdpdGhcclxuICAgICAqIHRoZSBuZXcgdG9wIGJpdHMgbWF0Y2hpbmcgdGhlIGN1cnJlbnQgc2lnbiBiaXQuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtQml0cyBUaGUgbnVtYmVyIG9mIGJpdHMgYnkgd2hpY2ggdG8gc2hpZnQuXHJcbiAgICAgKiBAcmV0dXJuIHshTG9uZ30gVGhpcyBzaGlmdGVkIHRvIHRoZSByaWdodCBieSB0aGUgZ2l2ZW4gYW1vdW50LCB3aXRoXHJcbiAgICAgKiAgICAgemVyb3MgcGxhY2VkIGludG8gdGhlIG5ldyBsZWFkaW5nIGJpdHMuXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIExvbmcucHJvdG90eXBlLnNoaWZ0UmlnaHRVbnNpZ25lZCA9IGZ1bmN0aW9uKG51bUJpdHMpIHtcclxuICAgICAgICBudW1CaXRzICY9IDYzO1xyXG4gICAgICAgIGlmIChudW1CaXRzID09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIGhpZ2ggPSB0aGlzLmhpZ2g7XHJcbiAgICAgICAgICAgIGlmIChudW1CaXRzIDwgMzIpIHtcclxuICAgICAgICAgICAgICAgIHZhciBsb3cgPSB0aGlzLmxvdztcclxuICAgICAgICAgICAgICAgIHJldHVybiBMb25nLmZyb21CaXRzKChsb3cgPj4+IG51bUJpdHMpIHwgKGhpZ2ggPDwgKDMyIC0gbnVtQml0cykpLCBoaWdoID4+PiBudW1CaXRzLCB0aGlzLnVuc2lnbmVkKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChudW1CaXRzID09IDMyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gTG9uZy5mcm9tQml0cyhoaWdoLCAwLCB0aGlzLnVuc2lnbmVkKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBMb25nLmZyb21CaXRzKGhpZ2ggPj4+IChudW1CaXRzIC0gMzIpLCAwLCB0aGlzLnVuc2lnbmVkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIHshTG9uZ30gU2lnbmVkIGxvbmdcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgTG9uZy5wcm90b3R5cGUudG9TaWduZWQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgbCA9IHRoaXMuY2xvbmUoKTtcclxuICAgICAgICBsLnVuc2lnbmVkID0gZmFsc2U7XHJcbiAgICAgICAgcmV0dXJuIGw7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiB7IUxvbmd9IFVuc2lnbmVkIGxvbmdcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgTG9uZy5wcm90b3R5cGUudG9VbnNpZ25lZCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBsID0gdGhpcy5jbG9uZSgpO1xyXG4gICAgICAgIGwudW5zaWduZWQgPSB0cnVlO1xyXG4gICAgICAgIHJldHVybiBsO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIHtMb25nfSBDbG9uZWQgaW5zdGFuY2Ugd2l0aCB0aGUgc2FtZSBsb3cvaGlnaCBiaXRzIGFuZCB1bnNpZ25lZCBmbGFnLlxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBMb25nLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgTG9uZyh0aGlzLmxvdywgdGhpcy5oaWdoLCB0aGlzLnVuc2lnbmVkKTtcclxuICAgIH07XHJcblxyXG4gICAgLy8gRW5hYmxlIG1vZHVsZSBsb2FkaW5nIGlmIGF2YWlsYWJsZVxyXG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgIT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlW1wiZXhwb3J0c1wiXSkgeyAvLyBDb21tb25KU1xyXG4gICAgICAgIG1vZHVsZVtcImV4cG9ydHNcIl0gPSBMb25nO1xyXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lICE9ICd1bmRlZmluZWQnICYmIGRlZmluZVtcImFtZFwiXSkgeyAvLyBBTURcclxuICAgICAgICBkZWZpbmUoXCJNYXRoL0xvbmdcIiwgW10sIGZ1bmN0aW9uKCkgeyByZXR1cm4gTG9uZzsgfSk7XHJcbiAgICB9IGVsc2UgeyAvLyBTaGltXHJcbiAgICAgICAgaWYgKCFnbG9iYWxbXCJkY29kZUlPXCJdKSB7XHJcbiAgICAgICAgICAgIGdsb2JhbFtcImRjb2RlSU9cIl0gPSB7fTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZ2xvYmFsW1wiZGNvZGVJT1wiXVtcIkxvbmdcIl0gPSBMb25nO1xyXG4gICAgfVxyXG5cclxufSkodGhpcyk7XHJcbiIsIi8qXHJcbiBDb3B5cmlnaHQgMjAxMyBEYW5pZWwgV2lydHogPGRjb2RlQGRjb2RlLmlvPlxyXG4gQ29weXJpZ2h0IDIwMDkgVGhlIENsb3N1cmUgTGlicmFyeSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG5cclxuIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuXHJcbiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcbiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTLUlTXCIgQkFTSVMsXHJcbiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vZGlzdC9Mb25nLmpzXCIpO1xyXG4iLCJ2YXIgZnVyaW91cyA9IHJlcXVpcmUoXCIuLi9saWIvZnVyaW91cy5qc1wiKTtcbnZhciBleHBlY3QgPSByZXF1aXJlKFwiY2hhaVwiKS5leHBlY3Q7XG5cbnZhciBjb250ZXh0ID0gbnVsbDtcbmJlZm9yZShmdW5jdGlvbihkb25lKSB7XG5cdGZ1cmlvdXMuaW5pdChmdW5jdGlvbihjdHgpIHtcblx0XHRjb250ZXh0ID0gY3R4O1xuXHRcdGRvbmUoKTtcblx0fSk7XG59KTtcblxuZGVzY3JpYmUoXCJDb250ZXh0XCIsIGZ1bmN0aW9uKCl7XG5cdGRlc2NyaWJlKFwiYmFycmllclwiLCBmdW5jdGlvbigpIHtcblx0XHRpdChcIkNhbGxzIHRoZSBjYWxsYmFja1wiLCBmdW5jdGlvbihkb25lKSB7XG5cdFx0XHRjb250ZXh0LmJhcnJpZXIoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRkb25lKCk7XG5cdFx0XHR9KTtcblx0XHR9KTtcblx0XHRpdChcIkV4ZWN1dGVzIGFmdGVyIHByZWNlZWRpbmcgY29tbWFuZHMgaGF2ZSBmaW5pc2hlZFwiLCBmdW5jdGlvbihkb25lKSB7XG5cdFx0XHR2YXIgeCA9IGNvbnRleHQuemVyb3MoWzMsIDNdKTtcblx0XHRcdHZhciBnZXRIYXNGaW5pc2hlZCA9IGZhbHNlO1xuXHRcdFx0eC5nZXQoZnVuY3Rpb24oZGF0YSkge1xuXHRcdFx0XHRnZXRIYXNGaW5pc2hlZCA9IHRydWU7XG5cdFx0XHR9KTtcblx0XHRcdGNvbnRleHQuYmFycmllcihmdW5jdGlvbiAoKXtcblx0XHRcdFx0ZXhwZWN0KGdldEhhc0ZpbmlzaGVkKS50by5iZS50cnVlO1xuXHRcdFx0XHRkb25lKCk7XG5cdFx0XHR9KTtcblx0XHR9KTtcblx0XHRpdChcIkV4ZWN1dGVzIGJlZm9yZSBzdWJzZXF1ZW50IGNvbW1hbmRzIGhhdmUgc3RhcnRlZFwiLCBmdW5jdGlvbihkb25lKSB7XG5cdFx0XHR2YXIgeCA9IGNvbnRleHQuemVyb3MoWzMsIDNdKTtcblx0XHRcdHZhciBiYXJyaWVySGFzRmluaXNoZWQgPSBmYWxzZTtcblx0XHRcdGNvbnRleHQuYmFycmllcihmdW5jdGlvbiAoKXtcblx0XHRcdFx0YmFycmllckhhc0ZpbmlzaGVkID0gdHJ1ZTtcblx0XHRcdH0pO1xuXHRcdFx0eC5nZXQoZnVuY3Rpb24oeCkge1xuXHRcdFx0XHRleHBlY3QoYmFycmllckhhc0ZpbmlzaGVkKS50by5iZS50cnVlO1xuXHRcdFx0XHRkb25lKCk7XG5cdFx0XHR9KTtcblx0XHR9KTtcblx0fSk7XG5cdGRlc2NyaWJlKFwiZW1wdHlcIiwgZnVuY3Rpb24oKXtcblx0XHRpdChcIkNyZWF0ZXMgYXJyYXkgd2l0aCBzcGVjaWZpZWQgc2hhcGVcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgeCA9IGNvbnRleHQuZW1wdHkoNDIpO1xuXHRcdFx0dmFyIHkgPSBjb250ZXh0LmVtcHR5KFs0Ml0pO1xuXHRcdFx0dmFyIHogPSBjb250ZXh0LmVtcHR5KFs0LCAyXSk7XG5cdFx0XHRleHBlY3QoeC5zaGFwZSkudG8uZGVlcC5lcXVhbChbNDJdKTtcblx0XHRcdGV4cGVjdCh5LnNoYXBlKS50by5kZWVwLmVxdWFsKFs0Ml0pO1xuXHRcdFx0ZXhwZWN0KHouc2hhcGUpLnRvLmRlZXAuZXF1YWwoWzQsIDJdKTtcblx0XHRcdHguaW52YWxpZGF0ZSgpO1xuXHRcdFx0eS5pbnZhbGlkYXRlKCk7XG5cdFx0XHR6LmludmFsaWRhdGUoKTtcblx0XHR9KTtcblx0XHRpdChcIkNyZWF0ZXMgYXJyYXkgd2l0aCBzcGVjaWZpZWQgZGF0YSB0eXBlIChmNjQgYnkgZGVmYXVsdClcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgeCA9IGNvbnRleHQuZW1wdHkoWzQsIDJdKTtcblx0XHRcdHZhciB5ID0gY29udGV4dC5lbXB0eShbNCwgMl0sIG5ldyBmdXJpb3VzLkRhdGFUeXBlKFwiZjY0XCIpKTtcblx0XHRcdHZhciB6ID0gY29udGV4dC5lbXB0eShbNCwgMl0sIG5ldyBmdXJpb3VzLkRhdGFUeXBlKFwiZjMyXCIpKTtcblx0XHRcdGV4cGVjdCh4LmRhdGFUeXBlLmVxdWFscyhuZXcgZnVyaW91cy5EYXRhVHlwZShcImY2NFwiKSkpLnRvLmJlLnRydWU7XG5cdFx0XHRleHBlY3QoeS5kYXRhVHlwZS5lcXVhbHMobmV3IGZ1cmlvdXMuRGF0YVR5cGUoXCJmNjRcIikpKS50by5iZS50cnVlO1xuXHRcdFx0ZXhwZWN0KHouZGF0YVR5cGUuZXF1YWxzKG5ldyBmdXJpb3VzLkRhdGFUeXBlKFwiZjMyXCIpKSkudG8uYmUudHJ1ZTtcblx0XHRcdHguaW52YWxpZGF0ZSgpO1xuXHRcdFx0eS5pbnZhbGlkYXRlKCk7XG5cdFx0XHR6LmludmFsaWRhdGUoKTtcblx0XHR9KTtcblx0fSk7XG5cdGRlc2NyaWJlKFwiemVyb3NcIiwgZnVuY3Rpb24oKXtcblx0XHRpdChcIkNyZWF0ZXMgYXJyYXkgd2l0aCBzcGVjaWZpZWQgc2hhcGVcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgeCA9IGNvbnRleHQuemVyb3MoNDIpO1xuXHRcdFx0dmFyIHkgPSBjb250ZXh0Lnplcm9zKFs0Ml0pO1xuXHRcdFx0dmFyIHogPSBjb250ZXh0Lnplcm9zKFs0LCAyXSk7XG5cdFx0XHRleHBlY3QoeC5zaGFwZSkudG8uZGVlcC5lcXVhbChbNDJdKTtcblx0XHRcdGV4cGVjdCh5LnNoYXBlKS50by5kZWVwLmVxdWFsKFs0Ml0pO1xuXHRcdFx0ZXhwZWN0KHouc2hhcGUpLnRvLmRlZXAuZXF1YWwoWzQsIDJdKTtcblx0XHRcdHguaW52YWxpZGF0ZSgpO1xuXHRcdFx0eS5pbnZhbGlkYXRlKCk7XG5cdFx0XHR6LmludmFsaWRhdGUoKTtcblx0XHR9KTtcblx0XHRpdChcIkNyZWF0ZXMgYXJyYXkgd2l0aCBzcGVjaWZpZWQgZGF0YSB0eXBlIChmNjQgYnkgZGVmYXVsdClcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgeCA9IGNvbnRleHQuemVyb3MoWzQsIDJdKTtcblx0XHRcdHZhciB5ID0gY29udGV4dC56ZXJvcyhbNCwgMl0sIG5ldyBmdXJpb3VzLkRhdGFUeXBlKFwiZjY0XCIpKTtcblx0XHRcdHZhciB6ID0gY29udGV4dC56ZXJvcyhbNCwgMl0sIG5ldyBmdXJpb3VzLkRhdGFUeXBlKFwiZjMyXCIpKTtcblx0XHRcdGV4cGVjdCh4LmRhdGFUeXBlLmVxdWFscyhuZXcgZnVyaW91cy5EYXRhVHlwZShcImY2NFwiKSkpLnRvLmJlLnRydWU7XG5cdFx0XHRleHBlY3QoeS5kYXRhVHlwZS5lcXVhbHMobmV3IGZ1cmlvdXMuRGF0YVR5cGUoXCJmNjRcIikpKS50by5iZS50cnVlO1xuXHRcdFx0ZXhwZWN0KHouZGF0YVR5cGUuZXF1YWxzKG5ldyBmdXJpb3VzLkRhdGFUeXBlKFwiZjMyXCIpKSkudG8uYmUudHJ1ZTtcblx0XHRcdHguaW52YWxpZGF0ZSgpO1xuXHRcdFx0eS5pbnZhbGlkYXRlKCk7XG5cdFx0XHR6LmludmFsaWRhdGUoKTtcblx0XHR9KTtcblx0XHRpdChcIkNyZWF0ZXMgYXJyYXkgd2l0aCBhbGwgZWxlbWVudHMgaW5pdGlhbGl6ZWQgdG8gemVyb1wiLCBmdW5jdGlvbihkb25lKSB7XG5cdFx0XHR2YXIgeCA9IGNvbnRleHQuemVyb3MoWzMsIDJdLCBuZXcgZnVyaW91cy5EYXRhVHlwZShcImY2NFwiKSk7XG5cdFx0XHR2YXIgeSA9IGNvbnRleHQuemVyb3MoWzIsIDNdLCBuZXcgZnVyaW91cy5EYXRhVHlwZShcImYzMlwiKSk7XG5cdFx0XHRjb250ZXh0LmdldCh4LCB5LCBmdW5jdGlvbih4LCB5KSB7XG5cdFx0XHRcdGV4cGVjdCh4KS50by5kZWVwLmVxdWFsKFtbMC4wLCAwLjBdLFxuXHRcdFx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgWzAuMCwgMC4wXSxcblx0XHRcdFx0ICAgICAgICAgICAgICAgICAgICAgICAgIFswLjAsIDAuMF1dKTtcblx0XHRcdFx0ZXhwZWN0KHkpLnRvLmRlZXAuZXF1YWwoW1swLjAsIDAuMCwgMC4wXSxcblx0XHRcdFx0ICAgICAgICAgICAgICAgICAgICAgICAgIFswLjAsIDAuMCwgMC4wXV0pO1xuXHRcdFx0XHRkb25lKCk7XG5cdFx0XHR9KTtcblx0XHR9KTtcblx0fSk7XG5cdGRlc2NyaWJlKFwib25lc1wiLCBmdW5jdGlvbigpe1xuXHRcdGl0KFwiQ3JlYXRlcyBhcnJheSB3aXRoIHNwZWNpZmllZCBzaGFwZVwiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciB4ID0gY29udGV4dC5vbmVzKDQyKTtcblx0XHRcdHZhciB5ID0gY29udGV4dC5vbmVzKFs0Ml0pO1xuXHRcdFx0dmFyIHogPSBjb250ZXh0Lm9uZXMoWzQsIDJdKTtcblx0XHRcdGV4cGVjdCh4LnNoYXBlKS50by5kZWVwLmVxdWFsKFs0Ml0pO1xuXHRcdFx0ZXhwZWN0KHkuc2hhcGUpLnRvLmRlZXAuZXF1YWwoWzQyXSk7XG5cdFx0XHRleHBlY3Qoei5zaGFwZSkudG8uZGVlcC5lcXVhbChbNCwgMl0pO1xuXHRcdFx0eC5pbnZhbGlkYXRlKCk7XG5cdFx0XHR5LmludmFsaWRhdGUoKTtcblx0XHRcdHouaW52YWxpZGF0ZSgpO1xuXHRcdH0pO1xuXHRcdGl0KFwiQ3JlYXRlcyBhcnJheSB3aXRoIHNwZWNpZmllZCBkYXRhIHR5cGUgKGY2NCBieSBkZWZhdWx0KVwiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciB4ID0gY29udGV4dC5vbmVzKFs0LCAyXSk7XG5cdFx0XHR2YXIgeSA9IGNvbnRleHQub25lcyhbNCwgMl0sIG5ldyBmdXJpb3VzLkRhdGFUeXBlKFwiZjY0XCIpKTtcblx0XHRcdHZhciB6ID0gY29udGV4dC5vbmVzKFs0LCAyXSwgbmV3IGZ1cmlvdXMuRGF0YVR5cGUoXCJmMzJcIikpO1xuXHRcdFx0ZXhwZWN0KHguZGF0YVR5cGUuZXF1YWxzKG5ldyBmdXJpb3VzLkRhdGFUeXBlKFwiZjY0XCIpKSkudG8uYmUudHJ1ZTtcblx0XHRcdGV4cGVjdCh5LmRhdGFUeXBlLmVxdWFscyhuZXcgZnVyaW91cy5EYXRhVHlwZShcImY2NFwiKSkpLnRvLmJlLnRydWU7XG5cdFx0XHRleHBlY3Qoei5kYXRhVHlwZS5lcXVhbHMobmV3IGZ1cmlvdXMuRGF0YVR5cGUoXCJmMzJcIikpKS50by5iZS50cnVlO1xuXHRcdFx0eC5pbnZhbGlkYXRlKCk7XG5cdFx0XHR5LmludmFsaWRhdGUoKTtcblx0XHRcdHouaW52YWxpZGF0ZSgpO1xuXHRcdH0pO1xuXHRcdGl0KFwiQ3JlYXRlcyBhcnJheSB3aXRoIGFsbCBlbGVtZW50cyBpbml0aWFsaXplZCB0byBvbmVcIiwgZnVuY3Rpb24oZG9uZSkge1xuXHRcdFx0dmFyIHggPSBjb250ZXh0Lm9uZXMoWzMsIDJdLCBuZXcgZnVyaW91cy5EYXRhVHlwZShcImY2NFwiKSk7XG5cdFx0XHR2YXIgeSA9IGNvbnRleHQub25lcyhbMiwgM10sIG5ldyBmdXJpb3VzLkRhdGFUeXBlKFwiZjMyXCIpKTtcblx0XHRcdGNvbnRleHQuZ2V0KHgsIHksIGZ1bmN0aW9uKHgsIHkpIHtcblx0XHRcdFx0ZXhwZWN0KHgpLnRvLmRlZXAuZXF1YWwoW1sxLjAsIDEuMF0sXG5cdFx0XHRcdCAgICAgICAgICAgICAgICAgICAgICAgICBbMS4wLCAxLjBdLFxuXHRcdFx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgWzEuMCwgMS4wXV0pO1xuXHRcdFx0XHRleHBlY3QoeSkudG8uZGVlcC5lcXVhbChbWzEuMCwgMS4wLCAxLjBdLFxuXHRcdFx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgWzEuMCwgMS4wLCAxLjBdXSk7XG5cdFx0XHRcdGRvbmUoKTtcblx0XHRcdH0pO1xuXHRcdH0pO1xuXHR9KTtcblx0ZGVzY3JpYmUoXCJhcnJheVwiLCBmdW5jdGlvbigpe1xuXHRcdGl0KFwiQ3JlYXRlcyBhcnJheSBvZiB0aGUgc2FtZSBsZW5ndGggYXMgdGhlIHByb3ZpZGVkIGFycmF5XCIsIGZ1bmN0aW9uKCl7XG5cdFx0XHR2YXIgeCA9IGNvbnRleHQuYXJyYXkoWzAsIDFdKTtcblx0XHRcdHZhciB5ID0gY29udGV4dC5hcnJheShbWzAsIDFdLFxuXHRcdFx0ICAgICAgICAgICAgICAgICAgICAgICBbMiwgM10sXG5cdFx0XHQgICAgICAgICAgICAgICAgICAgICAgIFszLCA0XV0pO1xuXHRcdFx0ZXhwZWN0KHgubGVuZ3RoKS50by5lcXVhbCgyKTtcblx0XHRcdGV4cGVjdCh5Lmxlbmd0aCkudG8uZXF1YWwoNik7XG5cdFx0XHR4LmludmFsaWRhdGUoKTtcblx0XHRcdHkuaW52YWxpZGF0ZSgpO1xuXHRcdH0pO1xuXHRcdGl0KFwiQ3JlYXRlcyBhcnJheSBvZiB0aGUgc2FtZSBzaGFwZSBhcyB0aGUgcHJvdmlkZWQgYXJyYXlcIiwgZnVuY3Rpb24oKXtcblx0XHRcdHZhciB4ID0gY29udGV4dC5hcnJheShbMCwgMV0pO1xuXHRcdFx0dmFyIHkgPSBjb250ZXh0LmFycmF5KFtbMCwgMV0sXG5cdFx0XHQgICAgICAgICAgICAgICAgICAgICAgIFsyLCAzXSxcblx0XHRcdCAgICAgICAgICAgICAgICAgICAgICAgWzMsIDRdXSk7XG5cdFx0XHR2YXIgeiA9IGNvbnRleHQuYXJyYXkoW1tbMSwgMiwgM10sIFsgNCwgIDUsICA2XV0sXG5cdFx0XHQgICAgICAgICAgICAgICAgICAgICAgIFtbNywgOCwgOV0sIFsxMCwgMTEsIDEyXV1dKTtcblx0XHRcdGV4cGVjdCh4LnNoYXBlKS50by5kZWVwLmVxdWFsKFsyXSk7XG5cdFx0XHRleHBlY3QoeS5zaGFwZSkudG8uZGVlcC5lcXVhbChbMywgMl0pO1xuXHRcdFx0ZXhwZWN0KHouc2hhcGUpLnRvLmRlZXAuZXF1YWwoWzIsIDIsIDNdKTtcblx0XHRcdHguaW52YWxpZGF0ZSgpO1xuXHRcdFx0eS5pbnZhbGlkYXRlKCk7XG5cdFx0XHR6LmludmFsaWRhdGUoKTtcblx0XHR9KTtcblx0XHRpdChcIkNyZWF0ZXMgYXJyYXkgd2l0aCB0aGUgc2FtZSBkYXRhIGFzIHRoZSBwcm92aWRlZCBhcnJheVwiLCBmdW5jdGlvbihkb25lKXtcblx0XHRcdHZhciBhcnJheSA9IFtbWzEsIDIsIDNdLCBbIDQsICA1LCAgNl1dLFxuXHRcdFx0ICAgICAgICAgICAgIFtbNywgOCwgOV0sIFsxMCwgMTEsIDEyXV1dO1xuXHRcdFx0dmFyIHggPSBjb250ZXh0LmFycmF5KGFycmF5LCBuZXcgZnVyaW91cy5EYXRhVHlwZShcImY2NFwiKSk7XG5cdFx0XHR2YXIgeSA9IGNvbnRleHQuYXJyYXkoYXJyYXksIG5ldyBmdXJpb3VzLkRhdGFUeXBlKFwiZjMyXCIpKTtcblx0XHRcdGNvbnRleHQuZ2V0KHgsIHksIGZ1bmN0aW9uKHgsIHkpIHtcblx0XHRcdFx0ZXhwZWN0KHgpLnRvLmRlZXAuZXF1YWwoYXJyYXkpO1xuXHRcdFx0XHRleHBlY3QoeSkudG8uZGVlcC5lcXVhbChhcnJheSk7XG5cdFx0XHRcdGRvbmUoKTtcblx0XHRcdH0pO1xuXHRcdH0pO1xuXHR9KTtcblx0ZGVzY3JpYmUoXCJsaW5zcGFjZVwiLCBmdW5jdGlvbigpe1xuXHRcdGl0KFwiSGFzIGxlbmd0aCBvZiA1MCB3aXRoIGRlZmF1bHQgYXJndW1lbnRzXCIsIGZ1bmN0aW9uKCl7XG5cdFx0XHRleHBlY3QoKGNvbnRleHQubGluc3BhY2UoMCwgMSkpLmxlbmd0aCkudG8uZXF1YWwoNTApO1xuXHRcdH0pO1xuXHRcdGl0KFwiSGFzIHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIHNhbXBsZXNcIiwgZnVuY3Rpb24oKXtcblx0XHRcdGV4cGVjdCgoY29udGV4dC5saW5zcGFjZSgwLCAxLCAyNDMpKS5sZW5ndGgpLnRvLmVxdWFsKDI0Myk7XG5cdFx0fSk7XG5cdFx0aXQoXCJIYXMgZXhwZWN0ZWQgdmFsdWVzXCIsIGZ1bmN0aW9uKGRvbmUpe1xuXHRcdFx0dmFyIHN0YXJ0ID0gNTA7XG5cdFx0XHR2YXIgc3RvcCA9IDk5O1xuXHRcdFx0dmFyIHggPSBjb250ZXh0LmxpbnNwYWNlKHN0YXJ0LCBzdG9wKTtcblx0XHRcdHguZ2V0KGZ1bmN0aW9uKHJlc3VsdCkge1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHJlc3VsdC5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdGV4cGVjdChyZXN1bHRbaV0pLnRvLmVxdWFsKHN0YXJ0K2kpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRvbmUoKTtcblx0XHRcdH0pO1xuXHRcdH0pO1xuXHRcdGRlc2NyaWJlKFwid2l0aCBpbmNsdWRlU3RvcCA9PT0gZmFsc2VcIiwgZnVuY3Rpb24oKXtcblx0XHRcdGl0KFwiSGFzIHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIHNhbXBsZXNcIiwgZnVuY3Rpb24oKXtcblx0XHRcdFx0ZXhwZWN0KChjb250ZXh0LmxpbnNwYWNlKDAsIDEsIDI0MywgZmFsc2UpKS5sZW5ndGgpLnRvLmVxdWFsKDI0Myk7XG5cdFx0XHR9KTtcblx0XHRcdGl0KFwiRG9lcyBub3QgY29udGFpbiB0aGUgcmlnaHQgZW5kcG9pbnRcIiwgZnVuY3Rpb24oZG9uZSl7XG5cdFx0XHRcdHZhciB4ID0gY29udGV4dC5saW5zcGFjZSgtMSwgMSwgMTAwMCwgZmFsc2UpO1xuXHRcdFx0XHR4LmdldChmdW5jdGlvbihyZXN1bHQpIHtcblx0XHRcdFx0XHRleHBlY3QocmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXSkudG8ubm90LmVxdWFsKDEpO1xuXHRcdFx0XHRcdGRvbmUoKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9KTtcblx0XHR9KTtcblx0fSk7XG5cdGRlc2NyaWJlKFwibmVnXCIsIGZ1bmN0aW9uKCkge1xuXHRcdHZhciB4UmVmID0gWyAxLCAtNy41LCAgMCwgLTE1XTtcblx0XHR2YXIgeVJlZiA9IFstMSwgIDcuNSwgLTAsICAxNV07XG5cdFx0dmFyIGRhdGFUeXBlcyA9IFtcImYzMlwiLCBcImY2NFwiXTtcblxuXHRcdGRlc2NyaWJlKFwiV2l0aCBubyBvdXRwdXQgYXJyYXkgc3VwcGxpZWRcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHRpdChcIkNyZWF0ZXMgYW4gb3V0cHV0IGFycmF5IHdpdGggdGhlIHNhbWUgc2hhcGUgYXMgaW5wdXQgYXJyYXlcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciB4ID0gY29udGV4dC5vbmVzKFsyLCAzLCA0XSk7XG5cdFx0XHRcdHZhciB5ID0gY29udGV4dC5uZWcoeCk7XG5cdFx0XHRcdGV4cGVjdCh5LnNoYXBlKS50by5kZWVwLmVxdWFsKFsyLCAzLCA0XSk7XG5cdFx0XHRcdHkuaW52YWxpZGF0ZSgpO1xuXHRcdFx0fSk7XG5cblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YVR5cGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdChmdW5jdGlvbihkYXRhVHlwZSkge1xuXHRcdFx0XHRcdGl0KFwiQ3JlYXRlcyBhbiBvdXRwdXQgYXJyYXkgd2l0aCB0aGUgc2FtZSBkYXRhIHR5cGUgYXMgaW5wdXQgYXJyYXkgKFwiICsgZGF0YVR5cGUgKyBcIiBkYXRhIHR5cGUpXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0dmFyIHggPSBjb250ZXh0LmFycmF5KHhSZWYsIG5ldyBmdXJpb3VzLkRhdGFUeXBlKGRhdGFUeXBlKSk7XG5cdFx0XHRcdFx0XHR2YXIgeSA9IGNvbnRleHQubmVnKHgpO1xuXHRcdFx0XHRcdFx0ZXhwZWN0KHkuZGF0YVR5cGUuZXF1YWxzKG5ldyBmdXJpb3VzLkRhdGFUeXBlKGRhdGFUeXBlKSkpLnRvLmJlLnRydWU7XG5cdFx0XHRcdFx0XHR5LmludmFsaWRhdGUoKTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSkoZGF0YVR5cGVzW2ldKTtcblx0XHRcdH1cblxuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhVHlwZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0KGZ1bmN0aW9uKGRhdGFUeXBlKSB7XG5cdFx0XHRcdFx0aXQoXCJDcmVhdGVzIGFuIG91dHB1dCBhcnJheSB3aXRoIG5lZ2F0ZWQgZWxlbWVudHMgKFwiICsgZGF0YVR5cGUgKyBcIiBkYXRhIHR5cGUpXCIsIGZ1bmN0aW9uKGRvbmUpIHtcblx0XHRcdFx0XHRcdHZhciB4ID0gY29udGV4dC5hcnJheSh4UmVmLCBuZXcgZnVyaW91cy5EYXRhVHlwZShkYXRhVHlwZSkpO1xuXHRcdFx0XHRcdFx0dmFyIHkgPSBjb250ZXh0Lm5lZyh4KTtcblx0XHRcdFx0XHRcdHkuZ2V0KGZ1bmN0aW9uKHkpIHtcblx0XHRcdFx0XHRcdFx0ZXhwZWN0KHkpLnRvLmRlZXAuZXF1YWwoeVJlZik7XG5cdFx0XHRcdFx0XHRcdGRvbmUoKTtcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9KShkYXRhVHlwZXNbaV0pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdGRlc2NyaWJlKFwiV2l0aCBhbiBvdXRwdXQgYXJyYXlcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGRhdGFUeXBlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHQoZnVuY3Rpb24oZGF0YVR5cGUpIHtcblx0XHRcdFx0XHRpdChcIlBvcHVsYXRlcyB0aGUgb3V0cHV0IGFycmF5IHdpdGggbmVnYXRlZCBlbGVtZW50cyAoXCIgKyBkYXRhVHlwZSArIFwiIGRhdGEgdHlwZSlcIiwgZnVuY3Rpb24oZG9uZSkge1xuXHRcdFx0XHRcdFx0dmFyIHggPSBjb250ZXh0LmFycmF5KHhSZWYsIG5ldyBmdXJpb3VzLkRhdGFUeXBlKGRhdGFUeXBlKSk7XG5cdFx0XHRcdFx0XHR2YXIgeSA9IGNvbnRleHQub25lcyh4LnNoYXBlLCB4LmRhdGFUeXBlKTtcblx0XHRcdFx0XHRcdGNvbnRleHQubmVnKHgsIHkpO1xuXHRcdFx0XHRcdFx0eS5nZXQoZnVuY3Rpb24oeSkge1xuXHRcdFx0XHRcdFx0XHRleHBlY3QoeSkudG8uZGVlcC5lcXVhbCh5UmVmKTtcblx0XHRcdFx0XHRcdFx0ZG9uZSgpO1xuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH0pKGRhdGFUeXBlc1tpXSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0pO1xuXHRkZXNjcmliZShcImFic1wiLCBmdW5jdGlvbigpIHtcblx0XHR2YXIgeFJlZiA9IFsxLCAtNy41LCAwLCAtMTVdO1xuXHRcdHZhciB5UmVmID0gWzEsICA3LjUsIDAsICAxNV07XG5cdFx0dmFyIGRhdGFUeXBlcyA9IFtcImYzMlwiLCBcImY2NFwiXTtcblxuXHRcdGRlc2NyaWJlKFwiV2l0aCBubyBvdXRwdXQgYXJyYXkgc3VwcGxpZWRcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHRpdChcIkNyZWF0ZXMgYW4gb3V0cHV0IGFycmF5IHdpdGggdGhlIHNhbWUgc2hhcGUgYXMgaW5wdXQgYXJyYXlcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciB4ID0gY29udGV4dC5vbmVzKFsyLCAzLCA0XSk7XG5cdFx0XHRcdHZhciB5ID0gY29udGV4dC5hYnMoeCk7XG5cdFx0XHRcdGV4cGVjdCh5LnNoYXBlKS50by5kZWVwLmVxdWFsKFsyLCAzLCA0XSk7XG5cdFx0XHRcdHkuaW52YWxpZGF0ZSgpO1xuXHRcdFx0fSk7XG5cblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YVR5cGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdChmdW5jdGlvbihkYXRhVHlwZSkge1xuXHRcdFx0XHRcdGl0KFwiQ3JlYXRlcyBhbiBvdXRwdXQgYXJyYXkgd2l0aCB0aGUgc2FtZSBkYXRhIHR5cGUgYXMgaW5wdXQgYXJyYXkgKFwiICsgZGF0YVR5cGUgKyBcIiBkYXRhIHR5cGUpXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0dmFyIHggPSBjb250ZXh0LmFycmF5KHhSZWYsIG5ldyBmdXJpb3VzLkRhdGFUeXBlKGRhdGFUeXBlKSk7XG5cdFx0XHRcdFx0XHR2YXIgeSA9IGNvbnRleHQuYWJzKHgpO1xuXHRcdFx0XHRcdFx0ZXhwZWN0KHkuZGF0YVR5cGUuZXF1YWxzKG5ldyBmdXJpb3VzLkRhdGFUeXBlKGRhdGFUeXBlKSkpLnRvLmJlLnRydWU7XG5cdFx0XHRcdFx0XHR5LmludmFsaWRhdGUoKTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSkoZGF0YVR5cGVzW2ldKTtcblx0XHRcdH1cblxuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhVHlwZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0KGZ1bmN0aW9uKGRhdGFUeXBlKSB7XG5cdFx0XHRcdFx0aXQoXCJDcmVhdGVzIGFuIG91dHB1dCBhcnJheSB3aXRoIGFic29sdXRlIHZhbHVlcyBvZiBlbGVtZW50cyAoXCIgKyBkYXRhVHlwZSArIFwiIGRhdGEgdHlwZSlcIiwgZnVuY3Rpb24oZG9uZSkge1xuXHRcdFx0XHRcdFx0dmFyIHggPSBjb250ZXh0LmFycmF5KHhSZWYsIG5ldyBmdXJpb3VzLkRhdGFUeXBlKGRhdGFUeXBlKSk7XG5cdFx0XHRcdFx0XHR2YXIgeSA9IGNvbnRleHQuYWJzKHgpO1xuXHRcdFx0XHRcdFx0eS5nZXQoZnVuY3Rpb24oeSkge1xuXHRcdFx0XHRcdFx0XHRleHBlY3QoeSkudG8uZGVlcC5lcXVhbCh5UmVmKTtcblx0XHRcdFx0XHRcdFx0ZG9uZSgpO1xuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH0pKGRhdGFUeXBlc1tpXSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0ZGVzY3JpYmUoXCJXaXRoIGFuIG91dHB1dCBhcnJheVwiLCBmdW5jdGlvbigpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YVR5cGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdChmdW5jdGlvbihkYXRhVHlwZSkge1xuXHRcdFx0XHRcdGl0KFwiUG9wdWxhdGVzIHRoZSBvdXRwdXQgYXJyYXkgd2l0aCBhYnNvbHV0ZSB2YWx1ZXMgb2YgZWxlbWVudHMgKFwiICsgZGF0YVR5cGUgKyBcIiBkYXRhIHR5cGUpXCIsIGZ1bmN0aW9uKGRvbmUpIHtcblx0XHRcdFx0XHRcdHZhciB4ID0gY29udGV4dC5hcnJheSh4UmVmLCBuZXcgZnVyaW91cy5EYXRhVHlwZShkYXRhVHlwZSkpO1xuXHRcdFx0XHRcdFx0dmFyIHkgPSBjb250ZXh0Lm9uZXMoeC5zaGFwZSwgeC5kYXRhVHlwZSk7XG5cdFx0XHRcdFx0XHRjb250ZXh0LmFicyh4LCB5KTtcblx0XHRcdFx0XHRcdHkuZ2V0KGZ1bmN0aW9uKHkpIHtcblx0XHRcdFx0XHRcdFx0ZXhwZWN0KHkpLnRvLmRlZXAuZXF1YWwoeVJlZik7XG5cdFx0XHRcdFx0XHRcdGRvbmUoKTtcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9KShkYXRhVHlwZXNbaV0pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9KTtcblx0ZGVzY3JpYmUoXCJleHBcIiwgZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHhSZWYgPSBbMSwgLTEsIDBdO1xuXHRcdHZhciBkYXRhVHlwZXMgPSBbXCJmMzJcIiwgXCJmNjRcIl07XG5cblx0XHRkZXNjcmliZShcIldpdGggbm8gb3V0cHV0IGFycmF5IHN1cHBsaWVkXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0aXQoXCJDcmVhdGVzIGFuIG91dHB1dCBhcnJheSB3aXRoIHRoZSBzYW1lIHNoYXBlIGFzIGlucHV0IGFycmF5XCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgeCA9IGNvbnRleHQub25lcyhbMiwgMywgNF0pO1xuXHRcdFx0XHR2YXIgeSA9IGNvbnRleHQuZXhwKHgpO1xuXHRcdFx0XHRleHBlY3QoeS5zaGFwZSkudG8uZGVlcC5lcXVhbChbMiwgMywgNF0pO1xuXHRcdFx0XHR5LmludmFsaWRhdGUoKTtcblx0XHRcdH0pO1xuXG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGRhdGFUeXBlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHQoZnVuY3Rpb24oZGF0YVR5cGUpIHtcblx0XHRcdFx0XHRpdChcIkNyZWF0ZXMgYW4gb3V0cHV0IGFycmF5IHdpdGggdGhlIHNhbWUgZGF0YSB0eXBlIGFzIGlucHV0IGFycmF5IChcIiArIGRhdGFUeXBlICsgXCIgZGF0YSB0eXBlKVwiLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHZhciB4ID0gY29udGV4dC5hcnJheSh4UmVmLCBuZXcgZnVyaW91cy5EYXRhVHlwZShkYXRhVHlwZSkpO1xuXHRcdFx0XHRcdFx0dmFyIHkgPSBjb250ZXh0LmV4cCh4KTtcblx0XHRcdFx0XHRcdGV4cGVjdCh5LmRhdGFUeXBlLmVxdWFscyhuZXcgZnVyaW91cy5EYXRhVHlwZShkYXRhVHlwZSkpKS50by5iZS50cnVlO1xuXHRcdFx0XHRcdFx0eS5pbnZhbGlkYXRlKCk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH0pKGRhdGFUeXBlc1tpXSk7XG5cdFx0XHR9XG5cblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YVR5cGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdChmdW5jdGlvbihkYXRhVHlwZSkge1xuXHRcdFx0XHRcdGl0KFwiQ3JlYXRlcyBhbiBvdXRwdXQgYXJyYXkgd2l0aCBhYnNvbHV0ZSB2YWx1ZXMgb2YgZWxlbWVudHMgKFwiICsgZGF0YVR5cGUgKyBcIiBkYXRhIHR5cGUpXCIsIGZ1bmN0aW9uKGRvbmUpIHtcblx0XHRcdFx0XHRcdHZhciB4ID0gY29udGV4dC5hcnJheSh4UmVmLCBuZXcgZnVyaW91cy5EYXRhVHlwZShkYXRhVHlwZSkpO1xuXHRcdFx0XHRcdFx0dmFyIHkgPSBjb250ZXh0LmV4cCh4KTtcblx0XHRcdFx0XHRcdHkuZ2V0KGZ1bmN0aW9uKHkpIHtcblx0XHRcdFx0XHRcdFx0Zm9yICh2YXIgayA9IDA7IGsgPCB5Lmxlbmd0aDsgaysrKSB7XG5cdFx0XHRcdFx0XHRcdFx0ZXhwZWN0KHlba10pLnRvLmJlLmNsb3NlVG8oTWF0aC5leHAoeFJlZltrXSksIE1hdGguZXhwKHhSZWZba10pICogMyAqIHguZGF0YVR5cGUuZXBzaWxvbik7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0ZG9uZSgpO1xuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH0pKGRhdGFUeXBlc1tpXSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0ZGVzY3JpYmUoXCJXaXRoIGFuIG91dHB1dCBhcnJheVwiLCBmdW5jdGlvbigpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YVR5cGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdChmdW5jdGlvbihkYXRhVHlwZSkge1xuXHRcdFx0XHRcdGl0KFwiUG9wdWxhdGVzIHRoZSBvdXRwdXQgYXJyYXkgd2l0aCBhYnNvbHV0ZSB2YWx1ZXMgb2YgZWxlbWVudHMgKFwiICsgZGF0YVR5cGUgKyBcIiBkYXRhIHR5cGUpXCIsIGZ1bmN0aW9uKGRvbmUpIHtcblx0XHRcdFx0XHRcdHZhciB4ID0gY29udGV4dC5hcnJheSh4UmVmLCBuZXcgZnVyaW91cy5EYXRhVHlwZShkYXRhVHlwZSkpO1xuXHRcdFx0XHRcdFx0dmFyIHkgPSBjb250ZXh0Lm9uZXMoeC5zaGFwZSwgeC5kYXRhVHlwZSk7XG5cdFx0XHRcdFx0XHRjb250ZXh0LmV4cCh4LCB5KTtcblx0XHRcdFx0XHRcdHkuZ2V0KGZ1bmN0aW9uKHkpIHtcblx0XHRcdFx0XHRcdFx0Zm9yICh2YXIgayA9IDA7IGsgPCB5Lmxlbmd0aDsgaysrKSB7XG5cdFx0XHRcdFx0XHRcdFx0ZXhwZWN0KHlba10pLnRvLmJlLmNsb3NlVG8oTWF0aC5leHAoeFJlZltrXSksIE1hdGguZXhwKHhSZWZba10pICogMyAqIHguZGF0YVR5cGUuZXBzaWxvbik7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0ZG9uZSgpO1xuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH0pKGRhdGFUeXBlc1tpXSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0pO1xuXHRkZXNjcmliZShcImxvZ1wiLCBmdW5jdGlvbigpIHtcblx0XHR2YXIgeFJlZiA9IFsxLCAzLCAxMF07XG5cdFx0dmFyIGRhdGFUeXBlcyA9IFtcImYzMlwiLCBcImY2NFwiXTtcblxuXHRcdGRlc2NyaWJlKFwiV2l0aCBubyBvdXRwdXQgYXJyYXkgc3VwcGxpZWRcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHRpdChcIkNyZWF0ZXMgYW4gb3V0cHV0IGFycmF5IHdpdGggdGhlIHNhbWUgc2hhcGUgYXMgaW5wdXQgYXJyYXlcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciB4ID0gY29udGV4dC5vbmVzKFsyLCAzLCA0XSk7XG5cdFx0XHRcdHZhciB5ID0gY29udGV4dC5sb2coeCk7XG5cdFx0XHRcdGV4cGVjdCh5LnNoYXBlKS50by5kZWVwLmVxdWFsKFsyLCAzLCA0XSk7XG5cdFx0XHRcdHkuaW52YWxpZGF0ZSgpO1xuXHRcdFx0fSk7XG5cblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YVR5cGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdChmdW5jdGlvbihkYXRhVHlwZSkge1xuXHRcdFx0XHRcdGl0KFwiQ3JlYXRlcyBhbiBvdXRwdXQgYXJyYXkgd2l0aCB0aGUgc2FtZSBkYXRhIHR5cGUgYXMgaW5wdXQgYXJyYXkgKFwiICsgZGF0YVR5cGUgKyBcIiBkYXRhIHR5cGUpXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0dmFyIHggPSBjb250ZXh0LmFycmF5KHhSZWYsIG5ldyBmdXJpb3VzLkRhdGFUeXBlKGRhdGFUeXBlKSk7XG5cdFx0XHRcdFx0XHR2YXIgeSA9IGNvbnRleHQubG9nKHgpO1xuXHRcdFx0XHRcdFx0ZXhwZWN0KHkuZGF0YVR5cGUuZXF1YWxzKG5ldyBmdXJpb3VzLkRhdGFUeXBlKGRhdGFUeXBlKSkpLnRvLmJlLnRydWU7XG5cdFx0XHRcdFx0XHR5LmludmFsaWRhdGUoKTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSkoZGF0YVR5cGVzW2ldKTtcblx0XHRcdH1cblxuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhVHlwZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0KGZ1bmN0aW9uKGRhdGFUeXBlKSB7XG5cdFx0XHRcdFx0aXQoXCJDcmVhdGVzIGFuIG91dHB1dCBhcnJheSB3aXRoIGFic29sdXRlIHZhbHVlcyBvZiBlbGVtZW50cyAoXCIgKyBkYXRhVHlwZSArIFwiIGRhdGEgdHlwZSlcIiwgZnVuY3Rpb24oZG9uZSkge1xuXHRcdFx0XHRcdFx0dmFyIHggPSBjb250ZXh0LmFycmF5KHhSZWYsIG5ldyBmdXJpb3VzLkRhdGFUeXBlKGRhdGFUeXBlKSk7XG5cdFx0XHRcdFx0XHR2YXIgeSA9IGNvbnRleHQubG9nKHgpO1xuXHRcdFx0XHRcdFx0eS5nZXQoZnVuY3Rpb24oeSkge1xuXHRcdFx0XHRcdFx0XHRmb3IgKHZhciBrID0gMDsgayA8IHkubGVuZ3RoOyBrKyspIHtcblx0XHRcdFx0XHRcdFx0XHRleHBlY3QoeVtrXSkudG8uYmUuY2xvc2VUbyhNYXRoLmxvZyh4UmVmW2tdKSwgTWF0aC5sb2coeFJlZltrXSkgKiAzICogeC5kYXRhVHlwZS5lcHNpbG9uKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRkb25lKCk7XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSkoZGF0YVR5cGVzW2ldKTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRkZXNjcmliZShcIldpdGggYW4gb3V0cHV0IGFycmF5XCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhVHlwZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0KGZ1bmN0aW9uKGRhdGFUeXBlKSB7XG5cdFx0XHRcdFx0aXQoXCJQb3B1bGF0ZXMgdGhlIG91dHB1dCBhcnJheSB3aXRoIGFic29sdXRlIHZhbHVlcyBvZiBlbGVtZW50cyAoXCIgKyBkYXRhVHlwZSArIFwiIGRhdGEgdHlwZSlcIiwgZnVuY3Rpb24oZG9uZSkge1xuXHRcdFx0XHRcdFx0dmFyIHggPSBjb250ZXh0LmFycmF5KHhSZWYsIG5ldyBmdXJpb3VzLkRhdGFUeXBlKGRhdGFUeXBlKSk7XG5cdFx0XHRcdFx0XHR2YXIgeSA9IGNvbnRleHQub25lcyh4LnNoYXBlLCB4LmRhdGFUeXBlKTtcblx0XHRcdFx0XHRcdGNvbnRleHQubG9nKHgsIHkpO1xuXHRcdFx0XHRcdFx0eS5nZXQoZnVuY3Rpb24oeSkge1xuXHRcdFx0XHRcdFx0XHRmb3IgKHZhciBrID0gMDsgayA8IHkubGVuZ3RoOyBrKyspIHtcblx0XHRcdFx0XHRcdFx0XHRleHBlY3QoeVtrXSkudG8uYmUuY2xvc2VUbyhNYXRoLmxvZyh4UmVmW2tdKSwgTWF0aC5sb2coeFJlZltrXSkgKiAzICogeC5kYXRhVHlwZS5lcHNpbG9uKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRkb25lKCk7XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSkoZGF0YVR5cGVzW2ldKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fSk7XG5cdGRlc2NyaWJlKFwic3FydFwiLCBmdW5jdGlvbigpIHtcblx0XHR2YXIgeFJlZiA9IFswLCAwLjI1LCAxLCA5LCAxMF07XG5cdFx0dmFyIGRhdGFUeXBlcyA9IFtcImYzMlwiLCBcImY2NFwiXTtcblxuXHRcdGRlc2NyaWJlKFwiV2l0aCBubyBvdXRwdXQgYXJyYXkgc3VwcGxpZWRcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHRpdChcIkNyZWF0ZXMgYW4gb3V0cHV0IGFycmF5IHdpdGggdGhlIHNhbWUgc2hhcGUgYXMgaW5wdXQgYXJyYXlcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciB4ID0gY29udGV4dC5vbmVzKFsyLCAzLCA0XSk7XG5cdFx0XHRcdHZhciB5ID0gY29udGV4dC5zcXJ0KHgpO1xuXHRcdFx0XHRleHBlY3QoeS5zaGFwZSkudG8uZGVlcC5lcXVhbChbMiwgMywgNF0pO1xuXHRcdFx0XHR5LmludmFsaWRhdGUoKTtcblx0XHRcdH0pO1xuXG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGRhdGFUeXBlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHQoZnVuY3Rpb24oZGF0YVR5cGUpIHtcblx0XHRcdFx0XHRpdChcIkNyZWF0ZXMgYW4gb3V0cHV0IGFycmF5IHdpdGggdGhlIHNhbWUgZGF0YSB0eXBlIGFzIGlucHV0IGFycmF5IChcIiArIGRhdGFUeXBlICsgXCIgZGF0YSB0eXBlKVwiLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHZhciB4ID0gY29udGV4dC5hcnJheSh4UmVmLCBuZXcgZnVyaW91cy5EYXRhVHlwZShkYXRhVHlwZSkpO1xuXHRcdFx0XHRcdFx0dmFyIHkgPSBjb250ZXh0LnNxcnQoeCk7XG5cdFx0XHRcdFx0XHRleHBlY3QoeS5kYXRhVHlwZS5lcXVhbHMobmV3IGZ1cmlvdXMuRGF0YVR5cGUoZGF0YVR5cGUpKSkudG8uYmUudHJ1ZTtcblx0XHRcdFx0XHRcdHkuaW52YWxpZGF0ZSgpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9KShkYXRhVHlwZXNbaV0pO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGRhdGFUeXBlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHQoZnVuY3Rpb24oZGF0YVR5cGUpIHtcblx0XHRcdFx0XHRpdChcIkNyZWF0ZXMgYW4gb3V0cHV0IGFycmF5IHdpdGggYWJzb2x1dGUgdmFsdWVzIG9mIGVsZW1lbnRzIChcIiArIGRhdGFUeXBlICsgXCIgZGF0YSB0eXBlKVwiLCBmdW5jdGlvbihkb25lKSB7XG5cdFx0XHRcdFx0XHR2YXIgeCA9IGNvbnRleHQuYXJyYXkoeFJlZiwgbmV3IGZ1cmlvdXMuRGF0YVR5cGUoZGF0YVR5cGUpKTtcblx0XHRcdFx0XHRcdHZhciB5ID0gY29udGV4dC5zcXJ0KHgpO1xuXHRcdFx0XHRcdFx0eS5nZXQoZnVuY3Rpb24oeSkge1xuXHRcdFx0XHRcdFx0XHRmb3IgKHZhciBrID0gMDsgayA8IHkubGVuZ3RoOyBrKyspIHtcblx0XHRcdFx0XHRcdFx0XHRleHBlY3QoeVtrXSkudG8uYmUuY2xvc2VUbyhNYXRoLnNxcnQoeFJlZltrXSksIE1hdGguc3FydCh4UmVmW2tdKSAqIDMgKiB4LmRhdGFUeXBlLmVwc2lsb24pO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGRvbmUoKTtcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9KShkYXRhVHlwZXNbaV0pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdGRlc2NyaWJlKFwiV2l0aCBhbiBvdXRwdXQgYXJyYXlcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGRhdGFUeXBlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHQoZnVuY3Rpb24oZGF0YVR5cGUpIHtcblx0XHRcdFx0XHRpdChcIlBvcHVsYXRlcyB0aGUgb3V0cHV0IGFycmF5IHdpdGggYWJzb2x1dGUgdmFsdWVzIG9mIGVsZW1lbnRzIChcIiArIGRhdGFUeXBlICsgXCIgZGF0YSB0eXBlKVwiLCBmdW5jdGlvbihkb25lKSB7XG5cdFx0XHRcdFx0XHR2YXIgeCA9IGNvbnRleHQuYXJyYXkoeFJlZiwgbmV3IGZ1cmlvdXMuRGF0YVR5cGUoZGF0YVR5cGUpKTtcblx0XHRcdFx0XHRcdHZhciB5ID0gY29udGV4dC5vbmVzKHguc2hhcGUsIHguZGF0YVR5cGUpO1xuXHRcdFx0XHRcdFx0Y29udGV4dC5zcXJ0KHgsIHkpO1xuXHRcdFx0XHRcdFx0eS5nZXQoZnVuY3Rpb24oeSkge1xuXHRcdFx0XHRcdFx0XHRmb3IgKHZhciBrID0gMDsgayA8IHkubGVuZ3RoOyBrKyspIHtcblx0XHRcdFx0XHRcdFx0XHRleHBlY3QoeVtrXSkudG8uYmUuY2xvc2VUbyhNYXRoLnNxcnQoeFJlZltrXSksIE1hdGguc3FydCh4UmVmW2tdKSAqIDMgKiB4LmRhdGFUeXBlLmVwc2lsb24pO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGRvbmUoKTtcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9KShkYXRhVHlwZXNbaV0pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9KTtcblx0ZGVzY3JpYmUoXCJzcXVhcmVcIiwgZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHhSZWYgPSBbLTIsIDAsIDAuNSwgMSwgM107XG5cdFx0dmFyIGRhdGFUeXBlcyA9IFtcImYzMlwiLCBcImY2NFwiXTtcblxuXHRcdGRlc2NyaWJlKFwiV2l0aCBubyBvdXRwdXQgYXJyYXkgc3VwcGxpZWRcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHRpdChcIkNyZWF0ZXMgYW4gb3V0cHV0IGFycmF5IHdpdGggdGhlIHNhbWUgc2hhcGUgYXMgaW5wdXQgYXJyYXlcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciB4ID0gY29udGV4dC5vbmVzKFsyLCAzLCA0XSk7XG5cdFx0XHRcdHZhciB5ID0gY29udGV4dC5zcXVhcmUoeCk7XG5cdFx0XHRcdGV4cGVjdCh5LnNoYXBlKS50by5kZWVwLmVxdWFsKFsyLCAzLCA0XSk7XG5cdFx0XHRcdHkuaW52YWxpZGF0ZSgpO1xuXHRcdFx0fSk7XG5cblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YVR5cGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdChmdW5jdGlvbihkYXRhVHlwZSkge1xuXHRcdFx0XHRcdGl0KFwiQ3JlYXRlcyBhbiBvdXRwdXQgYXJyYXkgd2l0aCB0aGUgc2FtZSBkYXRhIHR5cGUgYXMgaW5wdXQgYXJyYXkgKFwiICsgZGF0YVR5cGUgKyBcIiBkYXRhIHR5cGUpXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0dmFyIHggPSBjb250ZXh0LmFycmF5KHhSZWYsIG5ldyBmdXJpb3VzLkRhdGFUeXBlKGRhdGFUeXBlKSk7XG5cdFx0XHRcdFx0XHR2YXIgeSA9IGNvbnRleHQuc3F1YXJlKHgpO1xuXHRcdFx0XHRcdFx0ZXhwZWN0KHkuZGF0YVR5cGUuZXF1YWxzKG5ldyBmdXJpb3VzLkRhdGFUeXBlKGRhdGFUeXBlKSkpLnRvLmJlLnRydWU7XG5cdFx0XHRcdFx0XHR5LmludmFsaWRhdGUoKTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSkoZGF0YVR5cGVzW2ldKTtcblx0XHRcdH1cblxuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhVHlwZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0KGZ1bmN0aW9uKGRhdGFUeXBlKSB7XG5cdFx0XHRcdFx0aXQoXCJDcmVhdGVzIGFuIG91dHB1dCBhcnJheSB3aXRoIGFic29sdXRlIHZhbHVlcyBvZiBlbGVtZW50cyAoXCIgKyBkYXRhVHlwZSArIFwiIGRhdGEgdHlwZSlcIiwgZnVuY3Rpb24oZG9uZSkge1xuXHRcdFx0XHRcdFx0dmFyIHggPSBjb250ZXh0LmFycmF5KHhSZWYsIG5ldyBmdXJpb3VzLkRhdGFUeXBlKGRhdGFUeXBlKSk7XG5cdFx0XHRcdFx0XHR2YXIgeSA9IGNvbnRleHQuc3F1YXJlKHgpO1xuXHRcdFx0XHRcdFx0eS5nZXQoZnVuY3Rpb24oeSkge1xuXHRcdFx0XHRcdFx0XHRmb3IgKHZhciBrID0gMDsgayA8IHkubGVuZ3RoOyBrKyspIHtcblx0XHRcdFx0XHRcdFx0XHRleHBlY3QoeVtrXSkudG8uYmUuY2xvc2VUbyh4UmVmW2tdICogeFJlZltrXSwgeFJlZltrXSAqIHhSZWZba10gKiB4LmRhdGFUeXBlLmVwc2lsb24pO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGRvbmUoKTtcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9KShkYXRhVHlwZXNbaV0pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdGRlc2NyaWJlKFwiV2l0aCBhbiBvdXRwdXQgYXJyYXlcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGRhdGFUeXBlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHQoZnVuY3Rpb24oZGF0YVR5cGUpIHtcblx0XHRcdFx0XHRpdChcIlBvcHVsYXRlcyB0aGUgb3V0cHV0IGFycmF5IHdpdGggYWJzb2x1dGUgdmFsdWVzIG9mIGVsZW1lbnRzIChcIiArIGRhdGFUeXBlICsgXCIgZGF0YSB0eXBlKVwiLCBmdW5jdGlvbihkb25lKSB7XG5cdFx0XHRcdFx0XHR2YXIgeCA9IGNvbnRleHQuYXJyYXkoeFJlZiwgbmV3IGZ1cmlvdXMuRGF0YVR5cGUoZGF0YVR5cGUpKTtcblx0XHRcdFx0XHRcdHZhciB5ID0gY29udGV4dC5vbmVzKHguc2hhcGUsIHguZGF0YVR5cGUpO1xuXHRcdFx0XHRcdFx0Y29udGV4dC5zcXVhcmUoeCwgeSk7XG5cdFx0XHRcdFx0XHR5LmdldChmdW5jdGlvbih5KSB7XG5cdFx0XHRcdFx0XHRcdGZvciAodmFyIGsgPSAwOyBrIDwgeS5sZW5ndGg7IGsrKykge1xuXHRcdFx0XHRcdFx0XHRcdGV4cGVjdCh5W2tdKS50by5iZS5jbG9zZVRvKHhSZWZba10gKiB4UmVmW2tdLCB4UmVmW2tdICogeFJlZltrXSAqIHguZGF0YVR5cGUuZXBzaWxvbik7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0ZG9uZSgpO1xuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH0pKGRhdGFUeXBlc1tpXSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0pO1xufSk7XG4iLCJ2YXIgZnVyaW91cyA9IHJlcXVpcmUoXCIuLi9saWIvZnVyaW91cy5qc1wiKTtcbnZhciBleHBlY3QgPSByZXF1aXJlKFwiY2hhaVwiKS5leHBlY3Q7XG5cbmRlc2NyaWJlKFwiRGF0YVR5cGVcIiwgZnVuY3Rpb24oKXtcblx0ZGVzY3JpYmUoXCJmMzJcIiwgZnVuY3Rpb24oKXtcblx0XHRpdChcInNob3VsZCBoYXZlIHNpemUgNFwiLCBmdW5jdGlvbigpe1xuXHRcdFx0dmFyIGR0eXBlID0gbmV3IGZ1cmlvdXMuRGF0YVR5cGUoXCJmMzJcIik7XG5cdFx0XHRleHBlY3QoZHR5cGUuc2l6ZSkudG8uZXF1YWwoNCk7XG5cdFx0fSk7XG5cblx0XHRpdChcInNob3VsZCBoYXZlIHR5cGUgXFxcImYzMlxcXCJcIiwgZnVuY3Rpb24oKXtcblx0XHRcdHZhciBkdHlwZSA9IG5ldyBmdXJpb3VzLkRhdGFUeXBlKFwiZjMyXCIpO1xuXHRcdFx0ZXhwZWN0KGR0eXBlLnR5cGUpLnRvLmVxdWFsKFwiZjMyXCIpO1xuXHRcdH0pO1xuXHR9KTtcblx0ZGVzY3JpYmUoXCJmNjRcIiwgZnVuY3Rpb24oKXtcblx0XHRpdChcInNob3VsZCBoYXZlIHNpemUgOFwiLCBmdW5jdGlvbigpe1xuXHRcdFx0dmFyIGR0eXBlID0gbmV3IGZ1cmlvdXMuRGF0YVR5cGUoXCJmNjRcIik7XG5cdFx0XHRleHBlY3QoZHR5cGUuc2l6ZSkudG8uZXF1YWwoOCk7XG5cdFx0fSk7XG5cblx0XHRpdChcInNob3VsZCBoYXZlIHR5cGUgXFxcImY2NFxcXCJcIiwgZnVuY3Rpb24oKXtcblx0XHRcdHZhciBkdHlwZSA9IG5ldyBmdXJpb3VzLkRhdGFUeXBlKFwiZjY0XCIpO1xuXHRcdFx0ZXhwZWN0KGR0eXBlLnR5cGUpLnRvLmVxdWFsKFwiZjY0XCIpO1xuXHRcdH0pO1xuXHR9KTtcbn0pO1xuIiwidmFyIGZ1cmlvdXMgPSByZXF1aXJlKFwiLi4vbGliL2Z1cmlvdXMuanNcIik7XG52YXIgZXhwZWN0ID0gcmVxdWlyZShcImNoYWlcIikuZXhwZWN0O1xuXG52YXIgY29udGV4dCA9IG51bGw7XG5iZWZvcmUoZnVuY3Rpb24oZG9uZSkge1xuXHRmdXJpb3VzLmluaXQoZnVuY3Rpb24oY3R4KSB7XG5cdFx0Y29udGV4dCA9IGN0eDtcblx0XHRkb25lKCk7XG5cdH0pO1xufSk7XG5cbmRlc2NyaWJlKFwiTkRBcnJheVwiLCBmdW5jdGlvbigpIHtcblx0ZGVzY3JpYmUoXCJsZW5ndGhcIiwgZnVuY3Rpb24oKSB7XG5cdFx0aXQoXCJFcXVhbHMgdG8gdGhlIG51bWJlciBwYXNzZWQgaW4gY29uc3RydWN0b3JcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgeCA9IGNvbnRleHQuZW1wdHkoNDIpO1xuXHRcdFx0ZXhwZWN0KHgubGVuZ3RoKS50by5lcXVhbCg0Mik7XG5cdFx0XHR4LmludmFsaWRhdGUoKTtcblx0XHR9KTtcblx0XHRpdChcIkVxdWFscyB0byB0aGUgbnVtYmVyIHBhc3NlZCBpbiBjb25zdHJ1Y3RvciBhcyBhbiBhcnJheVwiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciB4ID0gY29udGV4dC5lbXB0eShbNDJdKTtcblx0XHRcdGV4cGVjdCh4Lmxlbmd0aCkudG8uZXF1YWwoNDIpO1xuXHRcdFx0eC5pbnZhbGlkYXRlKCk7XG5cdFx0fSk7XG5cdFx0aXQoXCJFcXVhbHMgdG8gdGhlIHByb2R1Y3Qgb2YgZGltZW5zaW9uc1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciB4ID0gY29udGV4dC5lbXB0eShbMiwgNSwgM10pO1xuXHRcdFx0ZXhwZWN0KHgubGVuZ3RoKS50by5lcXVhbCgzMCk7XG5cdFx0XHR4LmludmFsaWRhdGUoKTtcblx0XHR9KTtcblx0fSk7XG5cdGRlc2NyaWJlKFwicmVzaGFwZVwiLCBmdW5jdGlvbigpIHtcblx0XHRpdChcIlByZXNlcnZlcyBsZW5ndGhcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgeCA9IGNvbnRleHQuZW1wdHkoWzcsNSwzXSk7XG5cdFx0XHR2YXIgeSA9IHgucmVzaGFwZShbMjEsNV0pO1xuXHRcdFx0ZXhwZWN0KHkubGVuZ3RoKS50by5lcXVhbCh4Lmxlbmd0aCk7XG5cdFx0XHR5LmludmFsaWRhdGUoKTtcblx0XHR9KTtcblx0XHRpdChcIkNoYW5nZXMgc2hhcGVcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgeCA9IGNvbnRleHQuZW1wdHkoWzcsNSwzXSk7XG5cdFx0XHR2YXIgeSA9IHgucmVzaGFwZShbMjEsNV0pO1xuXHRcdFx0ZXhwZWN0KHkuc2hhcGUpLnRvLmRlZXAuZXF1YWwoWzIxLDVdKTtcblx0XHRcdHkuaW52YWxpZGF0ZSgpO1xuXHRcdH0pO1xuXHRcdGl0KFwiUmVhcnJhbmdlcyBkYXRhXCIsIGZ1bmN0aW9uKGRvbmUpIHtcblx0XHRcdHZhciB4ID0gY29udGV4dC5saW5zcGFjZSgxLCA4LCA4KS5yZXNoYXBlKFsyLCAyLCAyXSk7XG5cdFx0XHR4LmdldChmdW5jdGlvbihyZXN1bHQpIHtcblx0XHRcdFx0ZXhwZWN0KHJlc3VsdCkudG8uZGVlcC5lcXVhbChbW1sgMSwgIDJdLCBbIDMsICA0XV0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0ICBbWyA1LCAgNl0sIFsgNywgIDhdXV0pO1xuXHRcdFx0XHRkb25lKCk7XG5cdFx0XHR9KTtcblx0XHR9KTtcblx0fSk7XG5cdGRlc2NyaWJlKFwicmVwZWF0XCIsIGZ1bmN0aW9uKCkge1xuXHRcdGl0KFwiUmVwZWF0cyBhcnJheSBlbGVtZW50cyBhbG9uZyBheGlzIDBcIiwgZnVuY3Rpb24oZG9uZSkge1xuXHRcdFx0dmFyIHggPSBjb250ZXh0LmFycmF5KFtbOCwgMSwgNl0sXG5cdFx0XHQgICAgICAgICAgICAgICAgICAgICAgIFszLCA1LCA3XSxcblx0XHRcdCAgICAgICAgICAgICAgICAgICAgICAgWzQsIDksIDJdXSk7XG5cdFx0XHR4LnJlcGVhdCgyLCAwKS5nZXQoZnVuY3Rpb24oeSkge1xuXHRcdFx0XHRleHBlY3QoeSkudG8uZGVlcC5lcXVhbChbWzgsIDEsIDZdLFxuXHRcdFx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgWzgsIDEsIDZdLFxuXHRcdFx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgWzMsIDUsIDddLFxuXHRcdFx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgWzMsIDUsIDddLFxuXHRcdFx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgWzQsIDksIDJdLFxuXHRcdFx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgWzQsIDksIDJdXSk7XG5cdFx0XHRcdGRvbmUoKTtcblx0XHRcdH0pO1xuXHRcdH0pO1xuXHRcdGl0KFwiUmVwZWF0cyBhcnJheSBlbGVtZW50cyBhbG9uZyBheGlzIDFcIiwgZnVuY3Rpb24oZG9uZSkge1xuXHRcdFx0dmFyIHggPSBjb250ZXh0LmFycmF5KFtbOCwgMSwgNl0sXG5cdFx0XHQgICAgICAgICAgICAgICAgICAgICAgIFszLCA1LCA3XSxcblx0XHRcdCAgICAgICAgICAgICAgICAgICAgICAgWzQsIDksIDJdXSk7XG5cdFx0XHR4LnJlcGVhdCgyLCAxKS5nZXQoZnVuY3Rpb24oeSkge1xuXHRcdFx0XHRleHBlY3QoeSkudG8uZGVlcC5lcXVhbChbWzgsIDgsIDEsIDEsIDYsIDZdLFxuXHRcdFx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgWzMsIDMsIDUsIDUsIDcsIDddLFxuXHRcdFx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgWzQsIDQsIDksIDksIDIsIDJdXSk7XG5cdFx0XHRcdGRvbmUoKTtcblx0XHRcdH0pO1xuXHRcdH0pO1xuXHR9KTtcblx0ZGVzY3JpYmUoXCJnZXRcIiwgZnVuY3Rpb24oKXtcblx0XHRpdChcIldvcmtzIHdpdGggMS1kaW1lbnNpb25hbCBhcnJheVwiLCBmdW5jdGlvbihkb25lKSB7XG5cdFx0XHR2YXIgeCA9IGNvbnRleHQuYXJyYXkoWzQyLCAxMF0pO1xuXHRcdFx0eC5nZXQoZnVuY3Rpb24oeSkge1xuXHRcdFx0XHRleHBlY3QoeSkudG8uZGVlcC5lcXVhbChbNDIsIDEwXSk7XG5cdFx0XHRcdGRvbmUoKTtcblx0XHRcdH0pO1xuXHRcdH0pO1xuXHRcdGl0KFwiV29ya3Mgd2l0aCAyLWRpbWVuc2lvbmFsIGFycmF5XCIsIGZ1bmN0aW9uKGRvbmUpIHtcblx0XHRcdHZhciBhcnJheSA9IFtbMTYsICAyLCAgMywgMTMsICA1XSxcblx0XHRcdFx0XHRcdCBbMTEsIDEwLCAgOCwgIDksICA3XSxcblx0XHRcdFx0XHRcdCBbIDYsIDEyLCAgNCwgMTQsIDE1XV07XG5cdFx0XHR2YXIgeCA9IGNvbnRleHQuYXJyYXkoYXJyYXkpO1xuXHRcdFx0eC5nZXQoZnVuY3Rpb24oeSkge1xuXHRcdFx0XHRleHBlY3QoeSkudG8uZGVlcC5lcXVhbChhcnJheSk7XG5cdFx0XHRcdGRvbmUoKTtcblx0XHRcdH0pO1xuXHRcdH0pO1xuXHR9KTtcblx0ZGVzY3JpYmUoXCJhZGRcIiwgZnVuY3Rpb24oKSB7XG5cdFx0ZGVzY3JpYmUoXCJBZGQgYXJyYXlcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHRpdChcIkNvcnJlY3QgcmVzdWx0IGZvciAxLWRpbWVuc2lvbmFsIGFycmF5c1wiLCBmdW5jdGlvbihkb25lKSB7XG5cdFx0XHRcdHZhciB4ID0gY29udGV4dC5hcnJheShbMSwgNCwgOV0pO1xuXHRcdFx0XHR2YXIgeSA9IGNvbnRleHQuYXJyYXkoWzgsIC0xLCAxMF0pO1xuXHRcdFx0XHR2YXIgeiA9IHguYWRkKHkpO1xuXHRcdFx0XHR6LmdldChmdW5jdGlvbih6KSB7XG5cdFx0XHRcdFx0ZXhwZWN0KHopLnRvLmRlZXAuZXF1YWwoWzksIDMsIDE5XSk7XG5cdFx0XHRcdFx0ZG9uZSgpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH0pO1xuXHRcdFx0aXQoXCJDb3JyZWN0IHJlc3VsdCBmb3IgMi1kaW1lbnNpb25hbCBhcnJheXNcIiwgZnVuY3Rpb24oZG9uZSkge1xuXHRcdFx0XHR2YXIgeCA9IGNvbnRleHQuYXJyYXkoW1sxLCA0XSwgWzksIC0xN11dKTtcblx0XHRcdFx0dmFyIHkgPSBjb250ZXh0LmFycmF5KFtbOCwgLTFdLCBbMTAsIC0yMV1dKTtcblx0XHRcdFx0dmFyIHogPSB4LmFkZCh5KTtcblx0XHRcdFx0ei5nZXQoZnVuY3Rpb24ocmVzdWx0KSB7XG5cdFx0XHRcdFx0ZXhwZWN0KHJlc3VsdCkudG8uZGVlcC5lcXVhbChbWzksIDNdLCBbMTksIC0zOF1dKTtcblx0XHRcdFx0XHRkb25lKCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSk7XG5cdFx0fSk7XG5cdFx0ZGVzY3JpYmUoXCJBZGQgc2NhbGFyXCIsIGZ1bmN0aW9uKCl7XG5cdFx0XHRpdChcIkNvcnJlY3QgcmVzdWx0IGZvciAxLWRpbWVuc2lvbmFsIGFycmF5c1wiLCBmdW5jdGlvbihkb25lKSB7XG5cdFx0XHRcdHZhciB4ID0gY29udGV4dC5hcnJheShbMSwgNCwgOV0pO1xuXHRcdFx0XHR2YXIgeiA9IHguYWRkKC03KTtcblx0XHRcdFx0ei5nZXQoZnVuY3Rpb24oeikge1xuXHRcdFx0XHRcdGV4cGVjdCh6KS50by5kZWVwLmVxdWFsKFstNiwgLTMsIDJdKTtcblx0XHRcdFx0XHRkb25lKCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSk7XG5cdFx0XHRpdChcIkNvcnJlY3QgcmVzdWx0IGZvciAyLWRpbWVuc2lvbmFsIGFycmF5c1wiLCBmdW5jdGlvbihkb25lKSB7XG5cdFx0XHRcdHZhciB4ID0gY29udGV4dC5hcnJheShbWzEsIDRdLCBbOSwgLTE3XV0pO1xuXHRcdFx0XHR2YXIgeiA9IHguYWRkKDQyKTtcblx0XHRcdFx0ei5nZXQoZnVuY3Rpb24oeikge1xuXHRcdFx0XHRcdGV4cGVjdCh6KS50by5kZWVwLmVxdWFsKFtbNDMsIDQ2XSwgWzUxLCAyNV1dKTtcblx0XHRcdFx0XHRkb25lKCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSk7XG5cdFx0fSk7XG5cdH0pO1xuXHRkZXNjcmliZShcInN1YlwiLCBmdW5jdGlvbigpIHtcblx0XHRkZXNjcmliZShcIlN1YnRyYWN0IGFycmF5XCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0aXQoXCJDb3JyZWN0IHJlc3VsdCBmb3IgMS1kaW1lbnNpb25hbCBhcnJheXNcIiwgZnVuY3Rpb24oZG9uZSkge1xuXHRcdFx0XHR2YXIgeCA9IGNvbnRleHQuYXJyYXkoWzEsIDQsIDldKTtcblx0XHRcdFx0dmFyIHkgPSBjb250ZXh0LmFycmF5KFs4LCAtMSwgMTBdKTtcblx0XHRcdFx0dmFyIHogPSB4LnN1Yih5KTtcblx0XHRcdFx0ei5nZXQoZnVuY3Rpb24ocmVzdWx0KSB7XG5cdFx0XHRcdFx0ZXhwZWN0KHJlc3VsdCkudG8uZGVlcC5lcXVhbChbLTcsIDUsIC0xXSk7XG5cdFx0XHRcdFx0ZG9uZSgpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH0pO1xuXHRcdFx0aXQoXCJDb3JyZWN0IHJlc3VsdCBmb3IgMi1kaW1lbnNpb25hbCBhcnJheXNcIiwgZnVuY3Rpb24oZG9uZSkge1xuXHRcdFx0XHR2YXIgeCA9IGNvbnRleHQuYXJyYXkoW1sxLCA0XSwgWzksIC0xN11dKTtcblx0XHRcdFx0dmFyIHkgPSBjb250ZXh0LmFycmF5KFtbOCwgLTFdLCBbMTAsIC0yMV1dKTtcblx0XHRcdFx0dmFyIHogPSB4LnN1Yih5KTtcblx0XHRcdFx0ei5nZXQoZnVuY3Rpb24ocmVzdWx0KSB7XG5cdFx0XHRcdFx0ZXhwZWN0KHJlc3VsdCkudG8uZGVlcC5lcXVhbChbWy03LCA1XSwgWy0xLCA0XV0pO1xuXHRcdFx0XHRcdGRvbmUoKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9KTtcblx0XHR9KTtcblx0XHRkZXNjcmliZShcIlN1YnRyYWN0IHNjYWxhclwiLCBmdW5jdGlvbigpIHtcblx0XHRcdGl0KFwiQ29ycmVjdCByZXN1bHQgZm9yIDEtZGltZW5zaW9uYWwgYXJyYXlzXCIsIGZ1bmN0aW9uKGRvbmUpIHtcblx0XHRcdFx0dmFyIHggPSBjb250ZXh0LmFycmF5KFsxLCA0LCA5XSk7XG5cdFx0XHRcdHZhciB5ID0geC5zdWIoLTcpO1xuXHRcdFx0XHR5LmdldChmdW5jdGlvbih5KSB7XG5cdFx0XHRcdFx0ZXhwZWN0KHkpLnRvLmRlZXAuZXF1YWwoWzgsIDExLCAxNl0pO1xuXHRcdFx0XHRcdGRvbmUoKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9KTtcblx0XHRcdGl0KFwiQ29ycmVjdCByZXN1bHQgZm9yIDItZGltZW5zaW9uYWwgYXJyYXlzXCIsIGZ1bmN0aW9uKGRvbmUpIHtcblx0XHRcdFx0dmFyIHggPSBjb250ZXh0LmFycmF5KFtbMSwgNF0sIFs5LCAtMTddXSk7XG5cdFx0XHRcdHZhciB5ID0geC5zdWIoNDIpO1xuXHRcdFx0XHR5LmdldChmdW5jdGlvbih5KSB7XG5cdFx0XHRcdFx0ZXhwZWN0KHkpLnRvLmRlZXAuZXF1YWwoW1stNDEsIC0zOF0sIFstMzMsIC01OV1dKTtcblx0XHRcdFx0XHRkb25lKCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSk7XG5cdFx0fSk7XG5cdH0pO1xuXHRkZXNjcmliZShcIm11bFwiLCBmdW5jdGlvbigpIHtcblx0XHRkZXNjcmliZShcIk11bHRpcGx5IGJ5IGFycmF5XCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0aXQoXCJDb3JyZWN0IHJlc3VsdCBmb3IgMS1kaW1lbnNpb25hbCBhcnJheXNcIiwgZnVuY3Rpb24oZG9uZSkge1xuXHRcdFx0XHR2YXIgeCA9IGNvbnRleHQuYXJyYXkoWzEsIDQsIDldKTtcblx0XHRcdFx0dmFyIHkgPSBjb250ZXh0LmFycmF5KFs4LCAtMSwgMTBdKTtcblx0XHRcdFx0dmFyIHogPSB4Lm11bCh5KTtcblx0XHRcdFx0ei5nZXQoZnVuY3Rpb24oeikge1xuXHRcdFx0XHRcdGV4cGVjdCh6KS50by5kZWVwLmVxdWFsKFs4LCAtNCwgOTBdKTtcblx0XHRcdFx0XHRkb25lKCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSk7XG5cdFx0XHRpdChcIkNvcnJlY3QgcmVzdWx0IGZvciAyLWRpbWVuc2lvbmFsIGFycmF5c1wiLCBmdW5jdGlvbihkb25lKSB7XG5cdFx0XHRcdHZhciB4ID0gY29udGV4dC5hcnJheShbWzEsIDRdLCBbOSwgLTE3XV0pO1xuXHRcdFx0XHR2YXIgeSA9IGNvbnRleHQuYXJyYXkoW1s4LCAtMV0sIFsxMCwgLTIxXV0pO1xuXHRcdFx0XHR2YXIgeiA9IHgubXVsKHkpO1xuXHRcdFx0XHR6LmdldChmdW5jdGlvbih6KSB7XG5cdFx0XHRcdFx0ZXhwZWN0KHopLnRvLmRlZXAuZXF1YWwoW1s4LCAtNF0sIFs5MCwgMzU3XV0pO1xuXHRcdFx0XHRcdGRvbmUoKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9KTtcblx0XHR9KTtcblx0XHRkZXNjcmliZShcIk11bHRpcGx5IGJ5IHNjYWxhclwiLCBmdW5jdGlvbigpIHtcblx0XHRcdGl0KFwiQ29ycmVjdCByZXN1bHQgZm9yIDEtZGltZW5zaW9uYWwgYXJyYXlzXCIsIGZ1bmN0aW9uKGRvbmUpIHtcblx0XHRcdFx0dmFyIHggPSBjb250ZXh0LmFycmF5KFsxLCA0LCA5XSk7XG5cdFx0XHRcdHZhciB5ID0geC5tdWwoLTEwKTtcblx0XHRcdFx0eS5nZXQoZnVuY3Rpb24oeSkge1xuXHRcdFx0XHRcdGV4cGVjdCh5KS50by5kZWVwLmVxdWFsKFstMTAsIC00MCwgLTkwXSk7XG5cdFx0XHRcdFx0ZG9uZSgpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH0pO1xuXHRcdFx0aXQoXCJDb3JyZWN0IHJlc3VsdCBmb3IgMi1kaW1lbnNpb25hbCBhcnJheXNcIiwgZnVuY3Rpb24oZG9uZSkge1xuXHRcdFx0XHR2YXIgeCA9IGNvbnRleHQuYXJyYXkoW1sxLCA0XSwgWzksIC0xN11dKTtcblx0XHRcdFx0dmFyIHkgPSB4Lm11bCgxMCk7XG5cdFx0XHRcdHkuZ2V0KGZ1bmN0aW9uKHkpIHtcblx0XHRcdFx0XHRleHBlY3QoeSkudG8uZGVlcC5lcXVhbChbWzEwLCA0MF0sIFs5MCwgLTE3MF1dKTtcblx0XHRcdFx0XHRkb25lKCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSk7XG5cdFx0fSk7XG5cdH0pO1xuXHRkZXNjcmliZShcImRpdlwiLCBmdW5jdGlvbigpe1xuXHRcdGRlc2NyaWJlKFwiRGl2aWRlIGJ5IGFycmF5XCIsIGZ1bmN0aW9uKCl7XG5cdFx0XHRpdChcIkNvcnJlY3QgcmVzdWx0IGZvciAxLWRpbWVuc2lvbmFsIGFycmF5c1wiLCBmdW5jdGlvbihkb25lKSB7XG5cdFx0XHRcdHZhciB4ID0gY29udGV4dC5hcnJheShbMSwgNCwgOV0pO1xuXHRcdFx0XHR2YXIgeSA9IGNvbnRleHQuYXJyYXkoWzIsIC00LCA4XSk7XG5cdFx0XHRcdHZhciB6ID0geC5kaXYoeSk7XG5cdFx0XHRcdHouZ2V0KGZ1bmN0aW9uKHopIHtcblx0XHRcdFx0XHRleHBlY3QoeikudG8uZGVlcC5lcXVhbChbMC41LCAtMSwgMS4xMjVdKTtcblx0XHRcdFx0XHRkb25lKCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSk7XG5cdFx0XHRpdChcIkNvcnJlY3QgcmVzdWx0IGZvciAyLWRpbWVuc2lvbmFsIGFycmF5c1wiLCBmdW5jdGlvbihkb25lKSB7XG5cdFx0XHRcdHZhciB4ID0gY29udGV4dC5hcnJheShbWzEsIDRdLCBbOSwgLTE3XV0pO1xuXHRcdFx0XHR2YXIgeSA9IGNvbnRleHQuYXJyYXkoW1stMiwgNF0sIFstOCwgMTZdXSk7XG5cdFx0XHRcdHZhciB6ID0geC5kaXYoeSk7XG5cdFx0XHRcdHouZ2V0KGZ1bmN0aW9uKHopIHtcblx0XHRcdFx0XHRleHBlY3QoeikudG8uZGVlcC5lcXVhbChbWy0wLjUsIDFdLCBbLTEuMTI1LCAtMS4wNjI1XV0pO1xuXHRcdFx0XHRcdGRvbmUoKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9KTtcblx0XHR9KTtcblx0XHRkZXNjcmliZShcIkRpdmlkZSBieSBzY2FsYXJcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHRpdChcIkNvcnJlY3QgcmVzdWx0IGZvciAxLWRpbWVuc2lvbmFsIGFycmF5c1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHggPSBjb250ZXh0LmFycmF5KFsxLCA0LCA5XSk7XG5cdFx0XHRcdHZhciB5ID0geC5kaXYoLTIpO1xuXHRcdFx0XHR5LmdldChmdW5jdGlvbih5KSB7XG5cdFx0XHRcdFx0ZXhwZWN0KHkpLnRvLmRlZXAuZXF1YWwoWy0wLjUsIC0yLCAtNC41XSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSk7XG5cdFx0XHRpdChcIkNvcnJlY3QgcmVzdWx0IGZvciAyLWRpbWVuc2lvbmFsIGFycmF5c1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHggPSBjb250ZXh0LmFycmF5KFtbMSwgNF0sIFs5LCAtMTddXSk7XG5cdFx0XHRcdHZhciB5ID0geC5kaXYoLTQpO1xuXHRcdFx0XHR5LmdldChmdW5jdGlvbih5KSB7XG5cdFx0XHRcdFx0ZXhwZWN0KHkpLnRvLmRlZXAuZXF1YWwoW1stMC4yNSwgLTFdLCBbLTIuMjUsIDQuMjVdXSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSk7XG5cdFx0fSk7XG5cdH0pO1xuXHRkZXNjcmliZShcIm1pblwiLCBmdW5jdGlvbigpe1xuXHRcdGRlc2NyaWJlKFwiQWxsIGVsZW1lbnRzXCIsIGZ1bmN0aW9uKCl7XG5cdFx0XHRpdChcIlJldHVybnMgemVyby1kaW1lbnNpb25hbCBhcnJheSBvZiBsZW5ndGggb25lXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgeCA9IGNvbnRleHQuemVyb3MoWzIwLCAzMF0pO1xuXHRcdFx0XHR2YXIgeSA9IHgubWluKCk7XG5cdFx0XHRcdGV4cGVjdCh5LnNoYXBlKS50by5kZWVwLmVxdWFsKFtdKTtcblx0XHRcdFx0ZXhwZWN0KHkubGVuZ3RoKS50by5lcXVhbCgxKTtcblx0XHRcdFx0eS5pbnZhbGlkYXRlKCk7XG5cdFx0XHR9KTtcblx0XHRcdGl0KFwiQ29tcHV0ZXMgdGhlIG1pbmltdW0gb2YgYWxsIGVsZW1lbnRzIGluIGFuIGFycmF5XCIsIGZ1bmN0aW9uKGRvbmUpIHtcblx0XHRcdFx0dmFyIHggPSBjb250ZXh0LmxpbnNwYWNlKC01MCwgMTAwLCAxMDAwMDApLnJlc2hhcGUoWzIwMCwgNTAwXSk7XG5cdFx0XHRcdHgubWluKCkuZ2V0KGZ1bmN0aW9uKHkpIHtcblx0XHRcdFx0XHRleHBlY3QoeSkudG8uZXF1YWwoLTUwKTtcblx0XHRcdFx0XHRkb25lKCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSk7XG5cdFx0fSk7XG5cdFx0ZGVzY3JpYmUoXCJBbG9uZyBhbiBheGlzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0aXQoXCJDb3JyZWN0IHNoYXBlIGZvciAzLWRpbWVuc2lvbmFsIGFycmF5c1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHggPSBjb250ZXh0LmxpbnNwYWNlKDEsIDI0LCAyNCkucmVzaGFwZShbMiwgMywgNF0pLmxvY2soKTtcblx0XHRcdFx0ZXhwZWN0KHgubWluKDApLnNoYXBlKS50by5kZWVwLmVxdWFsKFszLCA0XSk7XG5cdFx0XHRcdGV4cGVjdCh4Lm1pbigxKS5zaGFwZSkudG8uZGVlcC5lcXVhbChbMiwgNF0pO1xuXHRcdFx0XHRleHBlY3QoeC5taW4oMikuc2hhcGUpLnRvLmRlZXAuZXF1YWwoWzIsIDNdKTtcblx0XHRcdFx0eC5pbnZhbGlkYXRlKCk7XG5cdFx0XHR9KTtcblx0XHRcdGl0KFwiQ29ycmVjdCByZXN1bHQgZm9yIDMtZGltZW5zaW9uYWwgYXJyYXlzLCBheGlzIDBcIiwgZnVuY3Rpb24oZG9uZSkge1xuXHRcdFx0XHR2YXIgeCA9IGNvbnRleHQubGluc3BhY2UoMSwgMjQsIDI0KS5yZXNoYXBlKFsyLCAzLCA0XSk7XG5cdFx0XHRcdHgubWluKDApLmdldChmdW5jdGlvbih5KSB7XG5cdFx0XHRcdFx0ZXhwZWN0KHkpLnRvLmRlZXAuZXF1YWwoW1sgMSwgIDIsICAzLCAgNF0sXG5cdFx0XHRcdFx0ICAgICAgICAgICAgICAgICAgICAgICAgIFsgNSwgIDYsICA3LCAgOF0sXG5cdFx0XHRcdFx0ICAgICAgICAgICAgICAgICAgICAgICAgIFsgOSwgMTAsIDExLCAxMl1dKTtcblx0XHRcdFx0XHRkb25lKCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSk7XG5cdFx0XHRpdChcIkNvcnJlY3QgcmVzdWx0IGZvciAzLWRpbWVuc2lvbmFsIGFycmF5cywgYXhpcyAxXCIsIGZ1bmN0aW9uKGRvbmUpIHtcblx0XHRcdFx0dmFyIHggPSBjb250ZXh0LmxpbnNwYWNlKDEsIDI0LCAyNCkucmVzaGFwZShbMiwgMywgNF0pO1xuXHRcdFx0XHR4Lm1pbigxKS5nZXQoZnVuY3Rpb24oeSkge1xuXHRcdFx0XHRcdGV4cGVjdCh5KS50by5kZWVwLmVxdWFsKFtbICAxLCAgMiwgIDMsICA0XSxcblx0XHRcdFx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgWyAxMywgMTQsIDE1LCAxNl1dKTtcblx0XHRcdFx0XHRkb25lKCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSk7XG5cdFx0XHRpdChcIkNvcnJlY3QgcmVzdWx0IGZvciAzLWRpbWVuc2lvbmFsIGFycmF5cywgYXhpcyAyXCIsIGZ1bmN0aW9uKGRvbmUpIHtcblx0XHRcdFx0dmFyIHggPSBjb250ZXh0LmxpbnNwYWNlKDEsIDI0LCAyNCkucmVzaGFwZShbMiwgMywgNF0pO1xuXHRcdFx0XHR4Lm1pbigyKS5nZXQoZnVuY3Rpb24oeSkge1xuXHRcdFx0XHRcdGV4cGVjdCh5KS50by5kZWVwLmVxdWFsKFtbICAxLCAgNSwgIDldLFxuXHRcdFx0XHRcdCAgICAgICAgICAgICAgICAgICAgICAgICBbIDEzLCAxNywgMjFdXSk7XG5cdFx0XHRcdFx0ZG9uZSgpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH0pO1xuXHRcdH0pO1xuXHR9KTtcblx0ZGVzY3JpYmUoXCJtYXhcIiwgZnVuY3Rpb24oKSB7XG5cdFx0ZGVzY3JpYmUoXCJBbGwgZWxlbWVudHNcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHRpdChcIlJldHVybnMgemVyby1kaW1lbnNpb25hbCBhcnJheSBvZiBsZW5ndGggb25lXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgeCA9IGNvbnRleHQuemVyb3MoWzIwLCAzMF0pO1xuXHRcdFx0XHR2YXIgeSA9IHgubWF4KCk7XG5cdFx0XHRcdGV4cGVjdCh5LnNoYXBlKS50by5kZWVwLmVxdWFsKFtdKTtcblx0XHRcdFx0ZXhwZWN0KHkubGVuZ3RoKS50by5lcXVhbCgxKTtcblx0XHRcdFx0eS5pbnZhbGlkYXRlKCk7XG5cdFx0XHR9KTtcblx0XHRcdGl0KFwiQ29tcHV0ZXMgdGhlIG1heGltdW0gb2YgYWxsIGVsZW1lbnRzIGluIGFuIGFycmF5XCIsIGZ1bmN0aW9uKGRvbmUpIHtcblx0XHRcdFx0dmFyIHggPSBjb250ZXh0LmxpbnNwYWNlKC01MCwgMTAwLCAxMDAwMDApLnJlc2hhcGUoWzIwMCwgNTAwXSk7XG5cdFx0XHRcdHgubWF4KCkuZ2V0KGZ1bmN0aW9uKHkpIHtcblx0XHRcdFx0XHRleHBlY3QoeSkudG8uZXF1YWwoMTAwKTtcblx0XHRcdFx0XHRkb25lKCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSk7XG5cdFx0fSk7XG5cdFx0ZGVzY3JpYmUoXCJBbG9uZyBhbiBheGlzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0aXQoXCJDb3JyZWN0IHNoYXBlIGZvciAzLWRpbWVuc2lvbmFsIGFycmF5c1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHggPSBjb250ZXh0LmxpbnNwYWNlKDEsIDI0LCAyNCkucmVzaGFwZShbMiwgMywgNF0pLmxvY2soKTtcblx0XHRcdFx0ZXhwZWN0KHgubWF4KDApLnNoYXBlKS50by5kZWVwLmVxdWFsKFszLCA0XSk7XG5cdFx0XHRcdGV4cGVjdCh4Lm1heCgxKS5zaGFwZSkudG8uZGVlcC5lcXVhbChbMiwgNF0pO1xuXHRcdFx0XHRleHBlY3QoeC5tYXgoMikuc2hhcGUpLnRvLmRlZXAuZXF1YWwoWzIsIDNdKTtcblx0XHRcdFx0eC5pbnZhbGlkYXRlKCk7XG5cdFx0XHR9KTtcblx0XHRcdGl0KFwiQ29ycmVjdCByZXN1bHQgZm9yIDMtZGltZW5zaW9uYWwgYXJyYXlzLCBheGlzIDBcIiwgZnVuY3Rpb24oZG9uZSkge1xuXHRcdFx0XHR2YXIgeCA9IGNvbnRleHQubGluc3BhY2UoMSwgMjQsIDI0KS5yZXNoYXBlKFsyLCAzLCA0XSk7XG5cdFx0XHRcdHgubWF4KDApLmdldChmdW5jdGlvbih5KSB7XG5cdFx0XHRcdFx0ZXhwZWN0KHkpLnRvLmRlZXAuZXF1YWwoW1sgMTMsIDE0LCAxNSwgMTZdLFxuXHRcdFx0XHRcdCAgICAgICAgICAgICAgICAgICAgICAgICBbIDE3LCAxOCwgMTksIDIwXSxcblx0XHRcdFx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgWyAyMSwgMjIsIDIzLCAyNF1dKTtcblx0XHRcdFx0XHRkb25lKCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSk7XG5cdFx0XHRpdChcIkNvcnJlY3QgcmVzdWx0IGZvciAzLWRpbWVuc2lvbmFsIGFycmF5cywgYXhpcyAxXCIsIGZ1bmN0aW9uKGRvbmUpIHtcblx0XHRcdFx0dmFyIHggPSBjb250ZXh0LmxpbnNwYWNlKDEsIDI0LCAyNCkucmVzaGFwZShbMiwgMywgNF0pO1xuXHRcdFx0XHR4Lm1heCgxKS5nZXQoZnVuY3Rpb24oeSkge1xuXHRcdFx0XHRcdGV4cGVjdCh5KS50by5kZWVwLmVxdWFsKFtbICA5LCAxMCwgMTEsIDEyXSxcblx0XHRcdFx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgWyAyMSwgMjIsIDIzLCAyNF1dKTtcblx0XHRcdFx0XHRkb25lKCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSk7XG5cdFx0XHRpdChcIkNvcnJlY3QgcmVzdWx0IGZvciAzLWRpbWVuc2lvbmFsIGFycmF5cywgYXhpcyAyXCIsIGZ1bmN0aW9uKGRvbmUpIHtcblx0XHRcdFx0dmFyIHggPSBjb250ZXh0LmxpbnNwYWNlKDEsIDI0LCAyNCkucmVzaGFwZShbMiwgMywgNF0pO1xuXHRcdFx0XHR4Lm1heCgyKS5nZXQoZnVuY3Rpb24oeSkge1xuXHRcdFx0XHRcdGV4cGVjdCh5KS50by5kZWVwLmVxdWFsKFtbICA0LCAgOCwgMTJdLFxuXHRcdFx0XHRcdCAgICAgICAgICAgICAgICAgICAgICAgICBbIDE2LCAyMCwgMjRdXSk7XG5cdFx0XHRcdFx0ZG9uZSgpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH0pO1xuXHRcdH0pO1xuXHR9KTtcblx0ZGVzY3JpYmUoXCJzdW1cIiwgZnVuY3Rpb24oKSB7XG5cdFx0ZGVzY3JpYmUoXCJBbGwgZWxlbWVudHNcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHRpdChcIlJldHVybnMgemVyby1kaW1lbnNpb25hbCBhcnJheSBvZiBsZW5ndGggb25lXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgeCA9IGNvbnRleHQuemVyb3MoWzIwLCAzMF0pO1xuXHRcdFx0XHR2YXIgeSA9IHguc3VtKCk7XG5cdFx0XHRcdGV4cGVjdCh5LnNoYXBlKS50by5kZWVwLmVxdWFsKFtdKTtcblx0XHRcdFx0ZXhwZWN0KHkubGVuZ3RoKS50by5lcXVhbCgxKTtcblx0XHRcdFx0eS5pbnZhbGlkYXRlKCk7XG5cdFx0XHR9KTtcblx0XHRcdGl0KFwiQ29tcHV0ZXMgdGhlIHN1bSBvZiBhbGwgZWxlbWVudHMgaW4gYW4gYXJyYXlcIiwgZnVuY3Rpb24oZG9uZSkge1xuXHRcdFx0XHR2YXIgeCA9IGNvbnRleHQubGluc3BhY2UoMSwgMTAwMDAwLCAxMDAwMDApLnJlc2hhcGUoWzIwMCwgNTAwXSk7XG5cdFx0XHRcdHguc3VtKCkuZ2V0KGZ1bmN0aW9uKHkpIHtcblx0XHRcdFx0XHRleHBlY3QoeSkudG8uZXF1YWwoNTAwMDA1MDAwMCk7XG5cdFx0XHRcdFx0ZG9uZSgpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH0pO1xuXHRcdH0pO1xuXHRcdGRlc2NyaWJlKFwiQWxvbmcgYW4gYXhpc1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdGl0KFwiQ29ycmVjdCBzaGFwZSBmb3IgMy1kaW1lbnNpb25hbCBhcnJheXNcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciB4ID0gY29udGV4dC5saW5zcGFjZSgxLCAyNCwgMjQpLnJlc2hhcGUoWzIsIDMsIDRdKS5sb2NrKCk7XG5cdFx0XHRcdGV4cGVjdCh4LnN1bSgwKS5zaGFwZSkudG8uZGVlcC5lcXVhbChbMywgNF0pO1xuXHRcdFx0XHRleHBlY3QoeC5zdW0oMSkuc2hhcGUpLnRvLmRlZXAuZXF1YWwoWzIsIDRdKTtcblx0XHRcdFx0ZXhwZWN0KHguc3VtKDIpLnNoYXBlKS50by5kZWVwLmVxdWFsKFsyLCAzXSk7XG5cdFx0XHRcdHguaW52YWxpZGF0ZSgpO1xuXHRcdFx0fSk7XG5cdFx0XHRpdChcIkNvcnJlY3QgcmVzdWx0IGZvciAzLWRpbWVuc2lvbmFsIGFycmF5cywgYXhpcyAwXCIsIGZ1bmN0aW9uKGRvbmUpIHtcblx0XHRcdFx0dmFyIHggPSBjb250ZXh0LmxpbnNwYWNlKDEsIDI0LCAyNCkucmVzaGFwZShbMiwgMywgNF0pO1xuXHRcdFx0XHR4LnN1bSgwKS5nZXQoZnVuY3Rpb24oeSkge1xuXHRcdFx0XHRcdGV4cGVjdCh5KS50by5kZWVwLmVxdWFsKFtbIDE0LCAxNiwgMTgsIDIwXSxcblx0XHRcdFx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgWyAyMiwgMjQsIDI2LCAyOF0sXG5cdFx0XHRcdFx0ICAgICAgICAgICAgICAgICAgICAgICAgIFsgMzAsIDMyLCAzNCwgMzZdXSk7XG5cdFx0XHRcdFx0ZG9uZSgpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH0pO1xuXHRcdFx0aXQoXCJDb3JyZWN0IHJlc3VsdCBmb3IgMy1kaW1lbnNpb25hbCBhcnJheXMsIGF4aXMgMVwiLCBmdW5jdGlvbihkb25lKSB7XG5cdFx0XHRcdHZhciB4ID0gY29udGV4dC5saW5zcGFjZSgxLCAyNCwgMjQpLnJlc2hhcGUoWzIsIDMsIDRdKTtcblx0XHRcdFx0eC5zdW0oMSkuZ2V0KGZ1bmN0aW9uKHkpIHtcblx0XHRcdFx0XHRleHBlY3QoeSkudG8uZGVlcC5lcXVhbChbWyAxNSwgIDE4LCAgMjEsICAyNF0sXG5cdFx0XHRcdFx0ICAgICAgICAgICAgICAgICAgICAgICAgIFsgNTEsICA1NCwgIDU3LCAgNjBdXSk7XG5cdFx0XHRcdFx0ZG9uZSgpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH0pO1xuXHRcdFx0aXQoXCJDb3JyZWN0IHJlc3VsdCBmb3IgMy1kaW1lbnNpb25hbCBhcnJheXMsIGF4aXMgMlwiLCBmdW5jdGlvbihkb25lKSB7XG5cdFx0XHRcdHZhciB4ID0gY29udGV4dC5saW5zcGFjZSgxLCAyNCwgMjQpLnJlc2hhcGUoWzIsIDMsIDRdKTtcblx0XHRcdFx0eC5zdW0oMikuZ2V0KGZ1bmN0aW9uKHkpIHtcblx0XHRcdFx0XHRleHBlY3QoeSkudG8uZGVlcC5lcXVhbChbWyAxMCwgIDI2LCAgNDJdLFxuXHRcdFx0XHRcdCAgICAgICAgICAgICAgICAgICAgICAgICBbIDU4LCAgNzQsICA5MF1dKTtcblx0XHRcdFx0XHRkb25lKCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSk7XG5cdFx0fSk7XG5cdH0pO1xuXHRkZXNjcmliZShcImRvdFwiLCBmdW5jdGlvbigpIHtcblx0XHRpdChcIkNvcnJlY3Qgc2hhcGUgZm9yIDItZGltZW5zaW9uYWwgYXJyYXlzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHggPSBjb250ZXh0LmVtcHR5KFsyLCA1XSk7XG5cdFx0XHR2YXIgeSA9IGNvbnRleHQuZW1wdHkoWzUsIDExXSk7XG5cdFx0XHR2YXIgeiA9IGNvbnRleHQuZG90KHgsIHkpO1xuXHRcdFx0ZXhwZWN0KHouc2hhcGUpLnRvLmRlZXAuZXF1YWwoWzIsIDExXSk7XG5cdFx0XHR6LmludmFsaWRhdGUoKTtcblx0XHR9KTtcblx0XHRpdChcIkNvcnJlY3Qgc2hhcGUgZm9yIDMtZGltZW5zaW9uYWwgYXJyYXlzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHggPSBjb250ZXh0LmVtcHR5KFsyLCAzLCA0XSk7XG5cdFx0XHR2YXIgeSA9IGNvbnRleHQuZW1wdHkoWzcsIDQsIDhdKTtcblx0XHRcdHZhciB6ID0gY29udGV4dC5kb3QoeCwgeSk7XG5cdFx0XHRleHBlY3Qoei5zaGFwZSkudG8uZGVlcC5lcXVhbChbMiwgMywgNywgOF0pO1xuXHRcdFx0ei5pbnZhbGlkYXRlKCk7XG5cdFx0fSk7XG5cdFx0aXQoXCJDb3JyZWN0IHNoYXBlIGZvciA0LWRpbWVuc2lvbmFsIGFycmF5c1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciB4ID0gY29udGV4dC5lbXB0eShbMiwgMywgNCwgNV0pO1xuXHRcdFx0dmFyIHkgPSBjb250ZXh0LmVtcHR5KFs2LCA3LCA1LCA4XSk7XG5cdFx0XHR2YXIgeiA9IGNvbnRleHQuZG90KHgsIHkpO1xuXHRcdFx0ZXhwZWN0KHouc2hhcGUpLnRvLmRlZXAuZXF1YWwoWzIsIDMsIDQsIDYsIDcsIDhdKTtcblx0XHRcdHouaW52YWxpZGF0ZSgpO1xuXHRcdH0pO1xuXHRcdGl0KFwiQ29ycmVjdCB2YWx1ZSBmb3IgMS1kaW1lbnNpb25hbCBhcnJheXNcIiwgZnVuY3Rpb24oZG9uZSkge1xuXHRcdFx0dmFyIHggPSBjb250ZXh0LmFycmF5KFsyLCA1XSk7XG5cdFx0XHR2YXIgeSA9IGNvbnRleHQuYXJyYXkoWzUsIDExXSk7XG5cdFx0XHRjb250ZXh0LmRvdCh4LCB5KS5nZXQoZnVuY3Rpb24oeikge1xuXHRcdFx0XHRleHBlY3QoeikudG8uZGVlcC5lcXVhbCg2NSk7XG5cdFx0XHRcdGRvbmUoKTtcblx0XHRcdH0pO1xuXHRcdH0pO1xuXHRcdGl0KFwiQ29ycmVjdCB2YWx1ZSBmb3IgMi1kaW1lbnNpb25hbCBhcnJheXNcIiwgZnVuY3Rpb24oZG9uZSkge1xuXHRcdFx0dmFyIHggPSBjb250ZXh0LmFycmF5KFtbNjQsICAyLCAgM10sXG5cdFx0XHQgICAgICAgICAgICAgICAgICAgICAgIFs2MSwgNjAsICA2XV0pO1xuXHRcdFx0dmFyIHkgPSBjb250ZXh0LmFycmF5KFtbOTIsIDk5LCAgMSwgIDgsIDE1XSxcblx0XHRcdCAgICAgICAgICAgICAgICAgICAgICAgWzY3LCA3NCwgNTEsIDU4LCA0MF0sXG5cdFx0XHQgICAgICAgICAgICAgICAgICAgICAgIFs5OCwgODAsICA3LCAxNCwgMTZdXSk7XG5cdFx0XHR2YXIgeiA9IGNvbnRleHQuZG90KHgsIHkpO1xuXHRcdFx0ei5nZXQoZnVuY3Rpb24ocmVzdWx0KSB7XG5cdFx0XHRcdGV4cGVjdChyZXN1bHQpLnRvLmRlZXAuZXF1YWwoW1sgIDYzMTYsICA2NzI0LCAgMTg3LCAgNjcwLCAxMDg4XSxcblx0XHRcdFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgWyAxMDIyMCwgMTA5NTksIDMxNjMsIDQwNTIsIDM0MTFdXSk7XG5cdFx0XHRcdGRvbmUoKTtcblx0XHRcdH0pO1xuXHRcdH0pO1xuXHR9KTtcbn0pO1xuIl19
