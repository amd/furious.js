(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
"use strict";

/**
 * A numerical data type object.
 *
 * @class DataType
 * @constructor
 * @param {String} type - the abbreviated name of the data type. The following names are supported:
 *
 *     <table>
 *         <tr>
 *             <th>Abbreviated Name</th>
 *             <th>Interpretation</th>
 *         </tr>
 *         <tr>
 *             <td>"f32"</td>
 *             <td>Single-precision (32-bit) IEEE-754 floating-point type.</td>
 *         </tr>
 *         <tr>
 *             <td>"f64"</td>
 *             <td>Double-precision (64-bit) IEEE-754 floating-point type.</td>
 *         </tr>
 *     </table>
 *
 */
function DataType(type) {
	if (["f32", "f64"].indexOf(type) >= 0) {
		this.type = type;
		this.size = {"f32": 4, "f64": 8}[type];
		this.epsilon = {"f32": 1.1920928955078125e-7, "f64": 2.2204460492503131e-16}[type];
		this.arrayType = {"f32": Float32Array, "f64": Float64Array}[type];
	} else {
		throw new RangeError("Type " + type + " is not supported");
	}
}

/**
 * Compares two data type objects for equality.
 *
 * @method equals
 * @param {any} other - an object to compare to.
 */
DataType.prototype.equals = function(other) {
	return (other instanceof DataType) && (this.arrayType === other.arrayType);
};

module.exports = DataType;

},{}],2:[function(require,module,exports){
"use strict";

var util = require("./util");
var DataType = require("./DataType");

/**
 * An opaque N-dimensional array object.
 *
 * @class NDArray
 */

/**
 * Constructs an NDArray object without data.
 * Normally this constructor is called from array construction methods of computational contexts.
 * The calling function is responsible for initializing the data for the array.
 *
 * @constructor
 * @private
 */
function NDArray(shape, dataType, context) {
	if (typeof context === "undefined") {
		throw new Error("Context not defined");
	}
	if (!util.isPositiveIntArray(shape) && !util.isPositiveInt(shape)) {
		throw new TypeError(shape + " is not a valid array shape");
	}
	if (typeof dataType === "undefined") {
		dataType = new DataType("f64");
	} else if (!(dataType instanceof DataType)) {
		throw new TypeError(dataType + " is not an instance of DataType");
	}
	this.shape = shape;
	this.dataType = dataType;
	this._context = context;
	this.length = util.computeLength(this.shape);
	this._lockCount = 0;
	this._refCount = 1;
	this._isValid = true;
}

/**
 * Locks the array reference counter.
 * While the array is locked, functions and methods that operate on this array do not decrease its reference count.
 * The array can be locked multiple times, and would need just as many unlock calls to lift the lock.
 * If the array is not valid, this operation will fail with an error.
 *
 * @method lock
 * @chainable
 */
NDArray.prototype.lock = function() {
	if (!this.isValid()) {
		throw new Error("Attempted to lock an invalidated array");
	}
	this._lockCount++;
	return this;
};

/**
 * Unlocks the array reference counter.
 * Once the array is unlocked, functions and methods that operate on this array decrease its reference count and, if the reference count reaches zero, invalidate the array.
 * If the array was locked multiple times, it would need just as many unlock calls to lift the lock.
 * If the array is not locked, this operation will fail with an error.
 *
 * @method unlock
 * @chainable
 */
NDArray.prototype.unlock = function() {
	if (!this.isLocked()) {
		throw new Error("Attempted to lock a unlocked array");
	}
	this._lockCount--;
	return this;
};

/**
 * Checkes if the array is in the locked state.
 * If the array is not valid, this method return false.
 *
 * @method isLocked
 *
 * @return {Boolean} - true is the array is locked and false otherwise
 */
NDArray.prototype.isLocked = function() {
	return this._lockCount > 0;
};

/**
 * Increments the array reference count.
 * If the array is invalid or locked, this operation will fail with an error.
 *
 * @method retain
 * @chainable
 */
NDArray.prototype.retain = function() {
	if (!this.isValid()) {
		throw new Error("Attempted to release an invalidated array");
	}
	if (this.isLocked()) {
		throw new Error("Attempted to retain a locked array");
	}
	this._refCount++;
	return this;
};

/**
 * Decrements the array reference count. If the reference count turns zero, the array becomes invalid and its data buffer is deallocated.
 * If the array is invalid or locked, this operation will fail with an error.
 *
 * @method release
 * @chainable
 */
NDArray.prototype.release = function() {
	if (!this.isValid()) {
		throw new Error("Attempted to release an invalidated array");
	}
	if (this.isLocked()) {
		throw new Error("Attempted to release a locked array");
	}
	if (--this._refCount === 0) {
		this._context._invalidate(this);
	}
	return this;
};

/**
 * For a non-locked array, decrements the array reference count. If the reference count turns zero, the array becomes invalid and its data buffer is deallocated.
 * If the array is invalid, this operation will fail with an error.
 *
 * @method tryRelease
 * @chainable
 */
NDArray.prototype.tryRelease = function() {
	if (!this.isValid()) {
		throw new Error("Attempted to release an invalidated array");
	}
	if (!this.isLocked()) {
		if (--this._refCount === 0) {
			this._context._invalidate(this);
		}
	}
	return this;
};

/**
 * For a non-locked array, decrements the array reference count. If the reference count turns zero, the array becomes invalid and its data buffer is deallocated.
 * The array must be valid to perform this operation.
 *
 * @private
 * @method _tryRelease
 * @chainable
 */
NDArray.prototype._tryRelease = function() {
	if (!this.isLocked()) {
		if (--this._refCount === 0) {
			this._context._invalidate(this);
		}
	}
	return this;
};

/**
 * Invalidates the array and deallocates its data buffer, regardless of locks and reference count.
 * Calling this method on an invalidated array has no effect.
 *
 * @method invalidate
 * @chainable
 */
NDArray.prototype.invalidate = function() {
	if (this.isValid()) {
		this._context._invalidate(this);
		this._isValid = false;
		this._refCount = 0;
		this._lockCount = 0;
	}
	return this;
};

/**
 * Checkes if the array is in a valid state.
 * If the array is not in a valid state, its data buffer was deallocated, and any operations on the array will throw an error.
 *
 * @method isValid
 *
 * @return {Boolean} - true is the array is valid and false otherwise
 */
NDArray.prototype.isValid = function() {
	return this._isValid;
};

/**
 * Decrements the array reference count if the array is not locked.
 * This function does not invalidate the array when the reference count reach zero.
 * The caller is responsible for invalidating array if its reference count is zero after the operation.
 *
 * For a locked array the method has no effect and always returns true.
 *
 * @private
 * @method _decRef
 * @param {NDArray} array - the array to decrement the reference count for. Must be valid before the call.
 * @return {Boolean} - true if the reference count is non-zero after the operation and false otherwise.
 */
NDArray.prototype._decRef = function(array) {
	if (this._lockCount === 0) {
		--this._refCount;
	}
	return this._refCount !== 0;
};

/**
 * Increments the array reference count if the array is not locked.
 * For a locked array the method has no effect.
 *
 * @private
 * @method _incRef
 * @chainable
 * @param {NDArray} array - the array to increment the reference count for. Must be valid before the call, but may have zero reference count.
 */
NDArray.prototype._incRef = function(array) {
	if (this._lockCount === 0) {
		++this._refCount;
	}
	return this;
};

/**
 * Checks if the array is locked or has any references.
 *
 * @private
 * @method _hasRefs
 * @param {NDArray} array - the array to check. Must be valid before the call, but may have zero reference count.
 * @return {Boolean} - true if the array is locked or has references and false otherwise.
 */
NDArray.prototype._hasRefs = function(array) {
	return (this._lockCount !== 0) || (this._refCount !== 0);
};

/**
 * Invalidates the array if it valid, not locked, and has zero reference count.
 * Has no effect in all other cases.
 *
 * @private
 * @method _tryInvalidate
 * @param {NDArray} array - the array to try to invalidate. Can be invalid.
 * @return {Boolean} - true if the array was invalidated by this call and false otherwise.
 */
NDArray.prototype._tryInvalidate = function(array) {
	if (this.isValid() && !this._hasRefs()) {
		this._context._invalidate(this);
		this._isValid = false;
		return true;
	} else {
		return false;
	}
};

/**
 * Adds another array or a number to this array.
 *
 * @method add
 * @param {(NDArray|Number)} other - the array or scalar to be added.
 * @return {NDArray}
 */
NDArray.prototype.add = function(other) {
	return this._context.add(this, other);
};

/**
 * Subtracts another array or a number from this array.
 *
 * @method sub
 * @param {(NDArray|Number)} other - the array or scalar to be subtracted.
 * @return {NDArray}
 */
NDArray.prototype.sub = function(other) {
	return this._context.sub(this, other);
};

/**
 * Multiplies array elements by another array or by a number.
 *
 * @method mul
 * @param {(NDArray|Number)} other - the array or scalar to multiply elements by.
 * @return {NDArray}
 */
NDArray.prototype.mul = function(other) {
	return this._context.mul(this, other);
};

/**
 * Divides array elements by another array or by a number.
 *
 * @method div
 * @param {(NDArray|Number)} other - the array or scalar to divide elements by.
 * @return {NDArray}
 */
NDArray.prototype.div = function(other) {
	return this._context.div(this, other);
};

/**
 * Reduces array elements using minimum operation.
 * If the axis argument is provided, the method computes minimum of elements along the specified axis.
 * Otherwise, the method computes an all-array minimum of the elements and returns them as a 1-element array.
 *
 * @method min
 * @param {Number} [axis] - the axis along which the minimum is computed.
 * @return {NDArray}
 */
NDArray.prototype.min = function(axis) {
	return this._context.min(this, axis);
};

/**
 * Reduces array elements using maximum operation.
 * If the axis argument is provided, the method computes maximum of elements along the specified axis.
 * Otherwise, the method computes an all-array maximum of the elements and returns them as a 1-element array.
 *
 * @method min
 * @param {Number} [axis] - the axis along which the maximum is computed.
 * @return {NDArray}
 */
NDArray.prototype.max = function(axis) {
	return this._context.max(this, axis);
};

/**
 * Reduces array elements using sum operation.
 * If the axis argument is provided, the method computes sum of elements along the specified axis.
 * Otherwise, the method computes an all-array sum of the elements and returns them as a 1-element array.
 *
 * @method min
 * @param {Number} [axis] - the axis along which the sum is computed.
 * @return {NDArray}
 */
NDArray.prototype.sum = function(axis) {
	return this._context.sum(this, axis);
};

/**
 * Creates another array with the same data, but different dimensions.
 *
 * @method reshape
 * @param {(NDArray|Number)} other - dimensions of the new array.
 * @return {NDArray}
 */
NDArray.prototype.reshape = function(newShape) {
	return this._context.reshape(this, newShape);
};

/**
 * Duplicates array elements along the specified axis.
 *
 * @method repeat
 * @param {Number} repeats - the number of times to repeat each element.
 * @param {Number} axis - the axis along which the elements will be duplicated.
 * @return {NDArray}
 */
NDArray.prototype.repeat = function(repeats, axis) {
	return this._context.repeat(this, repeats, axis);
};

/**
 * Converts the data to a JavaScript Array.
 *
 * @method get
 * @async
 */
NDArray.prototype.get = function(callback) {
	this._context.get(this, callback);
};

module.exports = NDArray;

},{"./DataType":1,"./util":12}],3:[function(require,module,exports){
"use strict";

var NDArray = require("./NDArray");
var DataType = require("./DataType");
var allocator = require("./allocator");
var util = require("./util");
var requests = require("./requests.pb");
var Request = requests.Request;
var EmptyArrayRequest = requests.EmptyArrayRequest;
var DataArrayRequest = requests.DataArrayRequest;
var ConstArrayRequest = requests.ConstArrayRequest;
var LinspaceRequest = requests.LinspaceRequest;
var ReshapeRequest = requests.ReshapeRequest;
var RepeatRequest = requests.RepeatRequest;
var DeallocateRequest = requests.DeallocateRequest;
var FetchRequest = requests.FetchRequest;
var BinaryOperationRequest = requests.BinaryOperationRequest;
var BinaryConstOperationRequest = requests.BinaryConstOperationRequest;
var UnaryOperationRequest = requests.UnaryOperationRequest;
var ReductionRequest = requests.ReductionRequest;
var AxisReductionRequest = requests.AxisReductionRequest;
var DotOperationRequest = requests.DotOperationRequest;
var Response = require("./responses.pb").Response;

var dataTypeMap = {
	"f32": requests.DataType.FLOAT32,
	"f64": requests.DataType.FLOAT64
};

function PBContext(options, postMessage, callback) {
	var context = this;
	this._postMessage = postMessage;
	this._callbacks = {};
	this._callbacks[0] = function(limits) {
		callback(context, limits);
	};
}

PBContext.prototype._onMessage = function(message) {
	var response = Response.decode(message.data);
	var id = response.id;
	var callback = this._callbacks[id];
	delete this._callbacks[id];
	switch (response.type) {
		case Response.Type.INIT:
			var limits = {};
			var initResponse = response.initResponse;
			if (initResponse.concurrency !== null) {
				limits.concurrency = initResponse.concurrency;
			}
			callback(limits);
			break;
		case Response.Type.BARRIER:
			callback();
			break;
		case Response.Type.FETCH:
			callback(response.fetchResponse.dataBuffer.toArrayBuffer());
			break;
		case Response.Type.ERROR:
			break;
		case Response.Type.INFO:
			break;
	}
};

PBContext.prototype.empty = function(shape, dataType) {
	shape = util.checkShape(shape);
	if (typeof dataType === "undefined") {
		dataType = new DataType("f64");
	} else if (!(dataType instanceof DataType)) {
		throw new TypeError(dataType + " is not an instance of DataType");
	}
	var array = new NDArray(shape, dataType, this);
	array._id = allocator.newArrayId();

	var request = new Request();
	request.id = allocator.newMessageId();
	request.type = Request.Type.EMPTY_ARRAY;
	var emptyArrayRequest = new EmptyArrayRequest();
	emptyArrayRequest.idOut = array._id;
	emptyArrayRequest.shape = shape;
	emptyArrayRequest.dataType = dataTypeMap[dataType.type];
	request.emptyArrayRequest = emptyArrayRequest;
	this._postMessage(request.encodeAB());

	return array;
};

PBContext.prototype.zeros = function(shape, dataType) {
	shape = util.checkShape(shape);
	if (typeof dataType === "undefined") {
		dataType = new DataType("f64");
	} else if (!(dataType instanceof DataType)) {
		throw new TypeError(dataType + " is not an instance of DataType");
	}
	var array = new NDArray(shape, dataType, this);
	array._id = allocator.newArrayId();

	var request = new Request();
	request.id = allocator.newMessageId();
	request.type = Request.Type.CONST_ARRAY;
	var constArrayRequest = new ConstArrayRequest();
	constArrayRequest.idOut = array._id;
	constArrayRequest.shape = shape;
	constArrayRequest.dataType = dataTypeMap[dataType.type];
	constArrayRequest.fillValue = 0.0;
	request.constArrayRequest = constArrayRequest;
	this._postMessage(request.encodeAB());

	return array;
};

PBContext.prototype.ones = function(shape, dataType) {
	shape = util.checkShape(shape);
	if (typeof dataType === "undefined") {
		dataType = new DataType("f64");
	} else if (!(dataType instanceof DataType)) {
		throw new TypeError(dataType + " is not an instance of DataType");
	}
	var array = new NDArray(shape, dataType, this);
	array._id = allocator.newArrayId();

	var request = new Request();
	request.id = allocator.newMessageId();
	request.type = Request.Type.CONST_ARRAY;
	var constArrayRequest = new ConstArrayRequest();
	constArrayRequest.idOut = array._id;
	constArrayRequest.shape = shape;
	constArrayRequest.dataType = dataTypeMap[dataType.type];
	constArrayRequest.fillValue = 1.0;
	request.constArrayRequest = constArrayRequest;
	this._postMessage(request.encodeAB());

	return array;
};

PBContext.prototype.array = function(data, dataType) {
	var shape = [];
	util.discoverArrayShapeRecursive(data, shape, 0);
	if (typeof dataType === "undefined") {
		dataType = new DataType("f64");
	} else if (!(dataType instanceof DataType)) {
		throw new TypeError(dataType + " is not an instance of DataType");
	}
	var array = new NDArray(shape, dataType, this);
	array._id = allocator.newArrayId();
	var arrayBuffer = new dataType.arrayType(array.length);
	util.copyArrayDataRecursive(arrayBuffer, data, shape, 0, 0);

	var request = new Request();
	request.id = allocator.newMessageId();
	request.type = Request.Type.DATA_ARRAY;
	var dataArrayRequest = new DataArrayRequest();
	dataArrayRequest.idOut = array._id;
	dataArrayRequest.shape = shape;
	dataArrayRequest.dataType = dataTypeMap[dataType.type];
	dataArrayRequest.dataBuffer = arrayBuffer.buffer;
	request.dataArrayRequest = dataArrayRequest;
	this._postMessage(request.encodeAB());

	return array;
};

PBContext.prototype.linspace = function(start, stop, samples, includeStop) {
	if (!util.isReal(start)) {
		throw new TypeError(start + " is not a real number");
	}
	if (!util.isReal(stop)) {
		throw new TypeError(stop + " is not a real number");
	}
	if (typeof samples === "undefined") {
		/* Default value in NumPy */
		samples = 50;
	} else if (!util.isInt(samples)) {
		throw new TypeError(samples + " is not an integer");
	} else if (samples <= 0) {
		throw new RangeError("The number of samples must be positive");
	}
	if (typeof includeStop === "undefined") {
		includeStop = true;
	}
	if (includeStop && (samples === 1)) {
		throw new RangeError("The number of samples must be a least 2 (for start and end points)");
	}
	var dataType = new DataType("f64");
	var array = new NDArray([samples], dataType, this);
	array._id = allocator.newArrayId();

	var request = new Request();
	request.id = allocator.newMessageId();
	request.type = Request.Type.LINSPACE;
	var linspaceRequest = new LinspaceRequest();
	linspaceRequest.idOut = array._id;
	linspaceRequest.start = start;
	linspaceRequest.stop = stop;
	linspaceRequest.samples = samples;
	linspaceRequest.closed = includeStop;
	linspaceRequest.dataType = dataTypeMap[dataType.type];
	request.linspaceRequest = linspaceRequest;
	this._postMessage(request.encodeAB());

	return array;
};

PBContext.prototype.reshape = function(a, shape) {
	util.checkNDArray(a, "a");
	shape = util.checkShape(shape);
	if (util.computeLength(shape) !== a.length) {
		throw new RangeError("The shape is not compatible with the array");
	}
	var idA = a._id;
	var releaseA = !a._decRef();
	var out = new NDArray(shape, a.dataType, this);
	if (releaseA) {
		out._id = idA;
		a._id = 0;
		releaseA = false;
	} else {
		out._id = allocator.newArrayId();
	}

	var request = new Request();
	request.id = allocator.newMessageId();
	request.type = Request.Type.RESHAPE;
	var reshapeRequest = new ReshapeRequest();
	reshapeRequest.idA = idA;
	reshapeRequest.idOut = out._id;
	reshapeRequest.shapeOut = shape;
	request.reshapeRequest = reshapeRequest;
	this._postMessage(request.encodeAB());

	a._tryInvalidate();
	return out;
};

PBContext.prototype.repeat = function(a, repeats, axis, out) {
	util.checkNDArray(a, "a");
	repeats = util.checkRepeats(repeats);
	axis = util.checkAxis(axis, a.shape.length);
	var shapeA = a.shape;
	var shapeOut = shapeA.slice(0);
	shapeOut[axis] *= repeats;
	if (typeof out === "undefined") {
		out = new NDArray(shapeOut, a.dataType, this);
		out._id = allocator.newArrayId();
	} else {
		util.checkNDArray(out, "out");
		util.checkShapesCompatibility(out.shape, shapeOut);
		util.checkDataTypesCompatibility(a.dataType, out.dataType);
		out._incRef();
	}
	var idA = a._id;
	if (!a._decRef()) {
		idA = -idA;
		a._id = 0;
	}

	var request = new Request();
	request.id = allocator.newMessageId();
	request.type = Request.Type.REPEAT;
	var repeatRequest = new RepeatRequest();
	repeatRequest.idA = idA;
	repeatRequest.idOut = out._id;
	repeatRequest.axis = axis;
	repeatRequest.repeats = repeats;
	request.repeatRequest = repeatRequest;
	this._postMessage(request.encodeAB());

	a._tryInvalidate();
	return out;
};

PBContext.prototype._invalidate = function(array) {
	if (array._id !== 0) {
		var request = new Request();
		request.id = allocator.newMessageId();
		request.type = Request.Type.DEALLOCATE;
		var deallocateRequest = new DeallocateRequest();
		deallocateRequest.idA = array._id;
		request.deallocateRequest = deallocateRequest;
		this._postMessage(request.encodeAB());
	}
};

PBContext.prototype.fetch = function() {
	if (arguments.length === 0) {
		throw new Error("Callback argument missing");
	}
	var callback = arguments[arguments.length - 1];
	/* Validate arguments */
	if (arguments.length === 1) {
		throw new Error("At least one NDArray argument expected");
	}
	for (var i = 0; i < arguments.length - 1; ++i) {
		util.checkNDArray(arguments[i], "argument " + i);
	}
	var release = new Array(arguments.length - 1);
	for (var i = 0; i < arguments.length - 1; ++i) {
		release[i] = !arguments[i]._decRef();
	}
	var callbackWaitArguments = arguments.length - 1;
	var callbackArguments = new Array(callbackWaitArguments);
	for (var i = 0; i < callbackWaitArguments; i++) {
		var array = arguments[i];
		var messageId = allocator.newMessageId();
		this._callbacks[messageId] = (function(i, ArrayType) {
			return function(buffer) {
				callbackArguments[i] = new ArrayType(buffer);
				if (--callbackWaitArguments === 0) {
					callback.apply(null, callbackArguments);
				}
			};
		})(i, array.dataType.arrayType);
		var arrayId = array._id;
		if (release[i]) {
			array._id = 0;
			arrayId = -arrayId;
			array._tryInvalidate();
		}

		var request = new Request();
		request.id = messageId;
		request.type = Request.Type.FETCH;
		var fetchRequest = new FetchRequest();
		fetchRequest.idA = arrayId;
		request.fetchRequest = fetchRequest;
		this._postMessage(request.encodeAB());
	}
};

PBContext.prototype.get = function() {
	if (arguments.length === 0) {
		throw new Error("Callback argument missing");
	}
	var callback = arguments[arguments.length - 1];
	/* Validate arguments */
	if (arguments.length === 1) {
		throw new Error("At least one NDArray argument expected");
	}
	for (var i = 0; i < arguments.length - 1; ++i) {
		util.checkNDArray(arguments[i], "argument " + i);
	}
	var release = new Array(arguments.length - 1);
	for (var i = 0; i < arguments.length - 1; ++i) {
		release[i] = !arguments[i]._decRef();
	}
	var callbackWaitArguments = arguments.length - 1;
	var callbackArguments = new Array(callbackWaitArguments);
	for (var i = 0; i < callbackWaitArguments; i++) {
		var array = arguments[i];
		var messageId = allocator.newMessageId();
		if (array.shape.length === 0) {
			this._callbacks[messageId] = (function(i, ArrayType) {
				return function(buffer) {
					var typedArray = new ArrayType(buffer);
					callbackArguments[i] = typedArray[0];
					if (--callbackWaitArguments === 0) {
						callback.apply(null, callbackArguments);
					}
				};
			})(i, array.dataType.arrayType);
		} else {
			this._callbacks[messageId] = (function(i, ArrayType, shape) {
				return function(buffer) {
					var jsarray = new Array(shape[0]);
					util.createArrayRecursive(new ArrayType(buffer), jsarray, shape, 0, 0);
					callbackArguments[i] = jsarray;
					if (--callbackWaitArguments === 0) {
						callback.apply(null, callbackArguments);
					}
				};
			})(i, array.dataType.arrayType, array.shape);
		}
		var arrayId = array._id;
		if (release[i]) {
			array._id = 0;
			arrayId = -arrayId;
			array._tryInvalidate();
		}

		var request = new Request();
		request.id = messageId;
		request.type = Request.Type.FETCH;
		var fetchRequest = new FetchRequest();
		fetchRequest.idA = arrayId;
		request.fetchRequest = fetchRequest;
		this._postMessage(request.encodeAB());
	}
};

PBContext.prototype.info = function(callback) {
	throw new Error("Not implemented");
/*	var messageId = allocator.newMessageId();
	messageCallbacks[messageId] = callback;
	this._pnaclObject.postMessage({
		"id": messageId,
		"command": "info"
	});*/
};

PBContext.prototype.barrier = function(callback) {
	var messageId = allocator.newMessageId();
	this._callbacks[messageId] = callback;

	var request = new Request();
	request.id = messageId;
	request.type = Request.Type.BARRIER;
	this._postMessage(request.encodeAB());
};

var binaryArithOp = function(a, b, out, context, operation, constOperation, revConstOperation) {
	var shapeOut = null, dataTypeOut = null, releaseIdA = false, releaseIdB = false, idA = 0, idB = 0;
	if (a instanceof NDArray) {
		idA = a._id;
		shapeOut = a.shape;
		dataTypeOut = a.dataType;
		if (b instanceof NDArray) {
			idB = b._id;
			util.checkShapesCompatibility(a.shape, b.shape);
			util.checkDataTypesCompatibility(a.dataType, b.dataType);
		} else if (!util.isNumber(b)) {
			throw new TypeError("Unsupported type of b");
		}
	} else if (util.isNumber(a)) {
		idB = b._id;
		shapeOut = b.shape;
		dataTypeOut = b.dataType;
		util.checkNDArray(b, "b");
	} else {
		throw new TypeError("Unsupported type of a");
	}
	/* The IDs of a and b must be invalidated before we assign ID to out because a/b and out may be the same arrays */
	if (idA !== 0) {
		releaseIdA = !a._decRef();
		if (releaseIdA) {
			a._id = 0;
		}
	}
	if (idB !== 0) {
		releaseIdB = !b._decRef();
		if (releaseIdB) {
			b._id = 0;
		}
	}
	try {
		if (typeof out === "undefined") {
			out = new NDArray(shapeOut, dataTypeOut, context);
			if (releaseIdA) {
				out._id = idA;
				releaseIdA = false;
			} else if (releaseIdB) {
				out._id = idB;
				releaseIdB = false;
			} else {
				out._id = allocator.newArrayId();
			}
		} else {
			util.checkNDArray(out, "out");
			util.checkShapesCompatibility(shapeOut, out.shape);
			util.checkDataTypesCompatibility(dataTypeOut, out.dataType);
			out._incRef();
		}
		var request = new Request();
		request.id = allocator.newMessageId();
		if (idA !== 0) {
			if (idB !== 0) {
				request.type = Request.Type.BINARY_OPERATION;
				var binaryOperationRequest = new BinaryOperationRequest();
				binaryOperationRequest.type = operation;
				binaryOperationRequest.idA = (releaseIdA ? -idA : idA);
				binaryOperationRequest.idB = (releaseIdB ? -idB : idB);
				binaryOperationRequest.idOut = out._id;
				request.binaryOperationRequest = binaryOperationRequest;
				context._postMessage(request.encodeAB());
			} else {
				request.type = Request.Type.BINARY_CONST_OPERATION;
				var binaryConstOperationRequest = new BinaryConstOperationRequest();
				binaryConstOperationRequest.type = constOperation;
				binaryConstOperationRequest.idA = (releaseIdA ? -idA : idA);
				binaryConstOperationRequest.valueB = b;
				binaryConstOperationRequest.idOut = out._id;
				request.binaryConstOperationRequest = binaryConstOperationRequest;
				context._postMessage(request.encodeAB());
			}
		} else {
			request.type = Request.Type.BINARY_CONST_OPERATION;
			var binaryConstOperationRequest = new BinaryConstOperationRequest();
			binaryConstOperationRequest.type = revConstOperation;
			binaryConstOperationRequest.idA = (releaseIdB ? -idB : idB);
			binaryConstOperationRequest.valueB = a;
			binaryConstOperationRequest.idOut = out._id;
			request.binaryConstOperationRequest = binaryConstOperationRequest;
			context._postMessage(request.encodeAB());
		}
	} catch (e) {
		/* Restore the previous state */
		if (idA !== 0) {
			a._id = idA;
			a._incRef();
		}
		if (idB !== 0) {
			b._id = idB;
			b._incRef();
		}
		throw e;
	}
	/*
	 * If a or b are arrays, invalidate them as needed.
	 * If a/b and out are the same, their ref count is non-zero at this point, so they will stay valid.
	 */
	if (idA !== 0) {
		a._tryInvalidate();
	}
	if (idB !== 0) {
		b._tryInvalidate();
	}
	return out;
};

var unaryArithOp = function(a, out, context, operation) {
	util.checkNDArray(a, "a");
	var idA = a._id;
	var releaseIdA = !a._decRef();
	/* The ID of a must be invalidated before we assign ID to out because a and out may be the same arrays */
	if (releaseIdA) {
		a._id = 0;
	}
	try {
		if (typeof out === "undefined") {
			out = new NDArray(a.shape, a.dataType, context);
			if (releaseIdA) {
				out._id = idA;
				releaseIdA = false;
			} else {
				out._id = allocator.newArrayId();
			}
		} else {
			util.checkNDArray(out, "out");
			util.checkShapesCompatibility(a.shape, out.shape);
			util.checkDataTypesCompatibility(a.dataType, out.dataType);
			out._incRef();
		}
	} catch (e) {
		/* Restore the previous state */
		a._id = idA;
		a._incRef();
		throw e;
	}

	var request = new Request();
	request.id = allocator.newMessageId();
	request.type = Request.Type.UNARY_OPERATION;
	var unaryOperationRequest = new UnaryOperationRequest();
	unaryOperationRequest.type = operation;
	unaryOperationRequest.idA = (releaseIdA ? -idA : idA);
	unaryOperationRequest.idOut = out._id;
	request.unaryOperationRequest = unaryOperationRequest;
	context._postMessage(request.encodeAB());

	/* If a and out are the same, their ref count is non-zero at this point, so they will stay valid. */
	a._tryInvalidate();
	return out;
};

var reduceArithOp = function(a, out, context, operation) {
	util.checkNDArray(a, "a");
	var idA = a._id;
	var releaseIdA = !a._decRef();
	if (releaseIdA) {
		a._id = 0;
	}
	try {
		if (typeof out === "undefined") {
			out = new NDArray([], a.dataType, context);
			out._id = allocator.newArrayId();
		} else {
			util.checkNDArray(out, "out");
			util.checkShapesCompatibility(out.shape, []);
			util.checkDataTypesCompatibility(a.dataType, out.dataType);
			out._incRef();
		}
	} catch (e) {
		/* Restore the previous state */
		a._id = idA;
		a._incRef();
		throw e;
	}

	var request = new Request();
	request.id = allocator.newMessageId();
	request.type = Request.Type.REDUCTION_OPERATION;
	var reductionRequest = new ReductionRequest();
	reductionRequest.type = operation;
	reductionRequest.idA = (releaseIdA ? -idA : idA);
	reductionRequest.idOut = out._id;
	request.reductionRequest = reductionRequest;
	context._postMessage(request.encodeAB());

	a._tryInvalidate();
	return out;
};

var axisReduceArithOp = function(a, axis, out, context, operation) {
	util.checkNDArray(a, "a");
	var idA = a._id;
	var releaseIdA = !a._decRef();
	if (releaseIdA) {
		a._id = 0;
	}
	try {
		util.checkAxis(axis);
		if (typeof out === "undefined") {
			out = new NDArray(util.computeAxisReductionOutShape(a.shape, axis), a.dataType, context);
			out._id = allocator.newArrayId();
		} else {
			util.checkNDArray(out, "out");
			util.checkShapesCompatibility(out.shape, []);
			util.checkDataTypesCompatibility(a.dataType, out.dataType);
			out._incRef();
		}
	} catch (e) {
		/* Restore the previous state */
		a._id = idA;
		a._incRef();
		throw e;
	}

	var request = new Request();
	request.id = allocator.newMessageId();
	request.type = Request.Type.AXIS_REDUCTION_OPERATION;
	var axisReductionRequest = new AxisReductionRequest();
	axisReductionRequest.type = operation;
	axisReductionRequest.idA = (releaseIdA ? -idA : idA);
	axisReductionRequest.axis = axis;
	axisReductionRequest.idOut = out._id;
	request.axisReductionRequest = axisReductionRequest;
	context._postMessage(request.encodeAB());

	a._tryInvalidate();
	return out;
};

var dotArithOp = function(a, b, out, context) {
	util.checkNDArray(a, "a");
	util.checkNDArray(b, "b");
	util.checkDataTypesCompatibility(a.dataType, b.dataType);
	var idA = a._id;
	var releaseIdA = !a._decRef();
	if (releaseIdA) {
		a._id = 0;
	}
	var idB = b._id;
	var releaseIdB = !b._decRef();
	if (releaseIdB) {
		b._id = 0;
	}
	try {
		if (typeof out === "undefined") {
			var shapeA = a.shape;
			var shapeB = b.shape;
			var axisA = Math.max(shapeA.length - 1, 0);
			var axisB = Math.max(shapeB.length - 2, 0);
			if (shapeA[axisA] != shapeB[axisB]) {
				throw new TypeError("Mismatch in reduction dimensions");
			}
			var shapeOut = [];
			for (var i = 0; i < axisA; i++) {
				shapeOut.push(shapeA[i]);
			}
			if (shapeB.length > 1) {
				for (var i = 0; i < axisB; i++) {
					shapeOut.push(shapeB[i]);
				}
				shapeOut.push(shapeB[shapeB.length - 1]);
			}
			out = new NDArray(shapeOut, a.dataType, context);
			out._id = allocator.newArrayId();
		} else if (out instanceof NDArray) {
			util.checkNDArray(out, "out");
			util.checkDataTypesCompatibility(a.dataType, out.dataType);
			throw new Error("Not implemented");
		}
	} catch (e) {
		/* Restore the previous state */
		a._id = idA;
		a._incRef();
		b._id = idB;
		b._incRef();
		throw e;
	}

	var request = new Request();
	request.id = allocator.newMessageId();
	request.type = Request.Type.DOT_OPERATION;
	var dotOperationRequest = new DotOperationRequest();
	dotOperationRequest.idA = (releaseIdA ? -idA : idA);
	dotOperationRequest.idB = (releaseIdB ? -idB : idB);
	dotOperationRequest.idOut = out._id;
	request.dotOperationRequest = dotOperationRequest;
	context._postMessage(request.encodeAB());

	a._tryInvalidate();
	b._tryInvalidate();
	return out;
};

PBContext.prototype.add = function(a, b, out) {
	return binaryArithOp(a, b, out, this,
		BinaryOperationRequest.Type.ADD,
		BinaryConstOperationRequest.Type.ADDC,
		BinaryConstOperationRequest.Type.ADDC);
};

PBContext.prototype.sub = function(a, b, out) {
	return binaryArithOp(a, b, out, this,
		BinaryOperationRequest.Type.SUB,
		BinaryConstOperationRequest.Type.SUBC,
		BinaryConstOperationRequest.Type.SUBRC);
};

PBContext.prototype.mul = function(a, b, out) {
	return binaryArithOp(a, b, out, this,
		BinaryOperationRequest.Type.MUL,
		BinaryConstOperationRequest.Type.MULC,
		BinaryConstOperationRequest.Type.MULC);
};

PBContext.prototype.div = function(a, b, out) {
	return binaryArithOp(a, b, out, this,
		BinaryOperationRequest.Type.DIV,
		BinaryConstOperationRequest.Type.DIVC,
		BinaryConstOperationRequest.Type.DIVRC);
};

PBContext.prototype.neg = function(a, out) {
	return unaryArithOp(a, out, this,
		UnaryOperationRequest.Type.NEG);
};

PBContext.prototype.abs = function(a, out) {
	return unaryArithOp(a, out, this,
		UnaryOperationRequest.Type.ABS);
};

PBContext.prototype.exp = function(a, out) {
	return unaryArithOp(a, out, this,
		UnaryOperationRequest.Type.EXP);
};

PBContext.prototype.log = function(a, out) {
	return unaryArithOp(a, out, this,
		UnaryOperationRequest.Type.LOG);
};

PBContext.prototype.sqrt = function(a, out) {
	return unaryArithOp(a, out, this,
		UnaryOperationRequest.Type.SQRT);
};

PBContext.prototype.square = function(a, out) {
	return unaryArithOp(a, out, this,
		UnaryOperationRequest.Type.SQUARE);
};

PBContext.prototype.min = function(a, axis) {
	if (typeof axis === "undefined") {
		return reduceArithOp(a, undefined, this,
			ReductionRequest.Type.MIN);
	} else if (util.isInt(axis)) {
		return axisReduceArithOp(a, axis, undefined, this,
			AxisReductionRequest.Type.MIN);
	} else {
		throw new TypeError("Unsupported axis type");
	}
};

PBContext.prototype.max = function(a, axis) {
	if (typeof axis === "undefined") {
		return reduceArithOp(a, undefined, this,
			ReductionRequest.Type.MAX);
	} else if (util.isInt(axis)) {
		return axisReduceArithOp(a, axis, undefined, this,
			AxisReductionRequest.Type.MAX);
	} else {
		throw new TypeError("Unsupported axis type");
	}
};

PBContext.prototype.sum = function(a, axis) {
	if (typeof axis === "undefined") {
		return reduceArithOp(a, undefined, this,
			ReductionRequest.Type.SUM);
	} else if (util.isInt(axis)) {
		return axisReduceArithOp(a, axis, undefined, this,
			AxisReductionRequest.Type.SUM);
	} else {
		throw new TypeError("Unsupported axis type");
	}
};

PBContext.prototype.dot = function(a, b, out) {
	return dotArithOp(a, b, out, this);
};

module.exports = PBContext;

},{"./DataType":1,"./NDArray":2,"./allocator":5,"./requests.pb":10,"./responses.pb":11,"./util":12}],4:[function(require,module,exports){
"use strict";

var PBContext = require("./PBContext");

function PNaClContext(options, callback) {
	var self = this;
	this._pnaclObject = document.createElement("object");
	this._pnaclObject.width = 0;
	this._pnaclObject.height = 0;
	this._pnaclObject.data = PNaClContext.getDefaultManifestURL(options.baseUrl);
	this._pnaclObject.type = "application/x-pnacl";
	this._pnaclObject.addEventListener("message", function(e) {
		self._messagingContext._onMessage(e);
	}, true);
	this._messagingContext = new PBContext(options, function(message) {
		self._pnaclObject.postMessage(message);
	}, callback);
	document.body.appendChild(this._pnaclObject);
}

PNaClContext.isSupported = function() {
	try {
		return (typeof navigator.mimeTypes["application/x-pnacl"]) !== "undefined";
	} catch (e) {
	}
	return false;
};

PNaClContext.getManifestURL = function(baseUrl) {
	if (baseUrl) {
		return baseUrl + "furious.nmf";
	} else {
		return "furious.nmf";
	}
};

PNaClContext.prototype.empty = function(shape, dataType) {
	return this._messagingContext.empty(shape, dataType);
};

PNaClContext.prototype.zeros = function(shape, dataType) {
	return this._messagingContext.zeros(shape, dataType);
};

PNaClContext.prototype.ones = function(shape, dataType) {
	return this._messagingContext.ones(shape, dataType);
};

PNaClContext.prototype.array = function(data, dataType) {
	return this._messagingContext.array(data, dataType);
};

PNaClContext.prototype.linspace = function(start, stop, samples, closed) {
	return this._messagingContext.linspace(start, stop, samples, closed);
};

PNaClContext.prototype.reshape = function(a, shape) {
	return this._messagingContext.reshape(a, shape);
};

PNaClContext.prototype.repeat = function(a, repeats, axis, out) {
	return this._messagingContext.repeat(a, repeats, axis, out);
};

PNaClContext.prototype._invalidate = function(array) {
	return this._messagingContext._invalidate(array);
};

PNaClContext.prototype.fetch = function() {
	this._messagingContext.fetch.apply(this._messagingContext, arguments);
};

PNaClContext.prototype.get = function() {
	this._messagingContext.get.apply(this._messagingContext, arguments);
};

PNaClContext.prototype.info = function(callback) {
	this._messagingContext.info(callback);
};

PNaClContext.prototype.barrier = function(callback) {
	this._messagingContext.barrier(callback);
};

PNaClContext.prototype.add = function(a, b, out) {
	return this._messagingContext.add(a, b, out);
};

PNaClContext.prototype.sub = function(a, b, out) {
	return this._messagingContext.sub(a, b, out);
};

PNaClContext.prototype.mul = function(a, b, out) {
	return this._messagingContext.mul(a, b, out);
};

PNaClContext.prototype.div = function(a, b, out) {
	return this._messagingContext.div(a, b, out);
};

PNaClContext.prototype.neg = function(a, out) {
	return this._messagingContext.neg(a, out);
};

PNaClContext.prototype.abs = function(a, out) {
	return this._messagingContext.abs(a, out);
};

PNaClContext.prototype.exp = function(a, out) {
	return this._messagingContext.exp(a, out);
};

PNaClContext.prototype.log = function(a, out) {
	return this._messagingContext.log(a, out);
};

PNaClContext.prototype.sqrt = function(a, out) {
	return this._messagingContext.sqrt(a, out);
};

PNaClContext.prototype.square = function(a, out) {
	return this._messagingContext.square(a, out);
};

PNaClContext.prototype.min = function(a, axis) {
	return this._messagingContext.min(a, axis);
};

PNaClContext.prototype.max = function(a, axis) {
	return this._messagingContext.max(a, axis);
};

PNaClContext.prototype.sum = function(a, axis) {
	return this._messagingContext.sum(a, axis);
};

PNaClContext.prototype.dot = function(a, b, out) {
	return this._messagingContext.dot(a, b, out);
};

module.exports = PNaClContext;

},{"./PBContext":3}],5:[function(require,module,exports){
"use strict";

var messageId = 1;
var arrayId = 1;

exports.newMessageId = function() {
	var id = messageId;
	messageId = (messageId+1)|0;
	return id;
};

exports.newArrayId = function () {
	var id = arrayId;
	arrayId = (arrayId+1)|0;
	return id;
};

},{}],6:[function(require,module,exports){
"use strict";

/**
 * Provides information and support functions
 *
 * @class furious
 */

var DataType = require("./DataType");
var JSContext = require("./js/JSContext");
var WebWorkerContext = require("./js/WebWorkerContext");
var PNaClContext = require("./PNaClContext");
var WebCLContext = require("./webcl/WebCLContext");

var currentScriptUri = null;
try {
	currentScriptUri = document.currentScript.src;
} catch (e) {
	try {
		var scripts = document.getElementsByTagName("script");
		currentScriptUri = scripts[scripts.length - 1].src;
	} catch (e) {
	}
}
var currentScriptDir = null;
if (currentScriptUri !== null) {
	var separatorPos = currentScriptUri.lastIndexOf("/");
	var currentScriptDir = currentScriptUri.substr(0, separatorPos + 1);
}

/**
 * Initializes a computational context.
 *
 * @static
 * @method init
 * @async
 *
 * @param {String} [backend] - A string identifier for the backend to use. The following values are supported:
 *
 *     <table>
 *         <tr>
 *             <th>Backend Identifier</th>
 *             <th>Interpretation</th>
 *         </tr>
 *         <tr>
 *             <td>"javascript"</td>
 *             <td>JavaScript backend. Works in all browsers and Node.js, but can not deliver optimal performance.</td>
 *         </tr>
 *         <tr>
 *             <td>"pnacl"</td>
 *             <td>Portable Native Client (PNaCl) backend. Works in Chromium-based browsers. Can accelerate computations through the use of advanced CPU optimization technologies, such as multi-threading and SIMD instructions.</td>
 *         </tr>
 *         <tr>
 *             <td>"webcl"</td>
 *             <td>WebCL backend. Works in browsers and Node.js when a WebCL plugin is available. Can use full power of CPUs and GPUs to accelerate computations.</td>
 *         </tr>
 *     </table>
 *
 * @param {Object} options - Backend-specific options.
 * @param {Function} callback - A callback function that is called when the backend finish initialization.
 * @param {Context} callback.context - A ready to use computational context.
 */
var init = function(backend, options, callback) {
	if (typeof callback === "undefined") {
		if (typeof options === "undefined") {
			/* Called with one parameter: callback */
			callback = backend;
			options = undefined;
			backend = undefined;
		} else {
			/* Called with two parameters: backend and callback */
			callback = options;
			options = undefined;
		}
	}
	if (typeof backend === "undefined") {
		backend = getDefaultBackend();
	}
	if (typeof options === "undefined") {
		options = {};
	}
	if (backend === "javascript") {
		var async = options.async;
		if (typeof async === "undefined") {
			async = WebWorkerContext.isSupported();
		}
		if (async) {
			options.baseUrl = currentScriptDir;
			return new WebWorkerContext(options, callback);
		} else {
			return new JSContext(options, callback);
		}
	} else if (backend === "pnacl") {
		options.baseUrl = currentScriptDir;
		return new PNaClContext(options, callback);
	} else if (backend === "webcl") {
		return new WebCLContext(options, callback);
	} else {
		throw new Error("Unsupported backend: " + backend);
	}
};

/**
 * Detects the optimal backend supported by the browser or JavaScript engine.
 *
 * @static
 * @method getDefaultBackend
 *
 * @return {String} - Default backend identifier from the following table:
 *
 *     <table>
 *         <tr>
 *             <th>Backend Identifier</th>
 *             <th>Interpretation</th>
 *         </tr>
 *         <tr>
 *             <td>"javascript"</td>
 *             <td>JavaScript backend. Works in all browsers and Node.js, but can not deliver optimal performance.</td>
 *         </tr>
 *         <tr>
 *             <td>"asmjs"</td>
 *             <td>Asm.js backend. Works in Firefox 29 and later. Can accelerate computations with a limited use of native CPU instructions.</td>
 *         </tr>
 *         <tr>
 *             <td>"pnacl"</td>
 *             <td>Portable Native Client (PNaCl) backend. Works in Chromium-based browsers. Can accelerate computations through the use of advanced CPU optimization technologies, such as multi-threading and SIMD instructions.</td>
 *         </tr>
 *         <tr>
 *             <td>"webcl"</td>
 *             <td>WebCL backend. Works in browsers and Node.js when a WebCL plugin is available. Can use full power of CPUs and GPUs to accelerate computations.</td>
 *         </tr>
 *     </table>
 */
var getDefaultBackend = function() {
	if (WebCLContext.isUsable()) {
		return "webcl";
	} else if (PNaClContext.isSupported()) {
		return "pnacl";
	} else {
		return "javascript";
	}
};

/**
 * Detects which backends are supported by the system.
 *
 * @static
 * @method getSupportedBackends
 *
 * @return {String[]} - An array of supported backend identifiers in priority order (prioritized backends first). The following identifiers could be present:
 *
 *     <table>
 *         <tr>
 *             <th>Backend Identifier</th>
 *             <th>Interpretation</th>
 *         </tr>
 *         <tr>
 *             <td>"javascript"</td>
 *             <td>JavaScript backend. Works in all browsers and Node.js, but can not deliver optimal performance.</td>
 *         </tr>
 *         <tr>
 *             <td>"asmjs"</td>
 *             <td>Asm.js backend. Works in Firefox 29 and later. Can accelerate computations with a limited use of native CPU instructions.</td>
 *         </tr>
 *         <tr>
 *             <td>"pnacl"</td>
 *             <td>Portable Native Client (PNaCl) backend. Works in Chromium-based browsers. Can accelerate computations through the use of advanced CPU optimization technologies, such as multi-threading and SIMD instructions.</td>
 *         </tr>
 *         <tr>
 *             <td>"webcl"</td>
 *             <td>WebCL backend. Works in browsers and Node.js when a WebCL plugin is available. Can use full power of CPUs and GPUs to accelerate computations.</td>
 *         </tr>
 *     </table>
 */
var getSupportedBackends = function() {
	var backends = [];
	if (WebCLContext.isUsable()) {
		backends.push("webcl");
	}
	if (PNaClContext.isSupported()) {
		backends.push("pnacl");
	}
	if (hasFeature("asm.js")) {
		backends.push("asm.js");
	}
	backends.push("javascript");
	return backends;
};

/**
 * Queries possible backend options available on this platform.
 *
 * @param {String} backend - name of the backend to query options for.
 *
 * @static
 * @method getBackendOptions
 *
 * @return {Object} - An object that describes available options.
 * The names of object's properties correspond to backend option names.
 * Object's properties have array values with possible option values.
 * Below are the backend options for the built-in backends:
 *
 *     <table>
 *         <caption>Options of "javascript" and "asmjs" backends</caption>
 *         <tr>
 *             <th>Option name</th>
 *             <th>Option values</th>
 *             <th>Default value</th>
 *         </tr>
 *         <tr>
 *             <td>"async"</td>
 *             <td>[true, false]</td>
 *             <td>true</td>
 *         </tr>
 *     </table>
 *
 *     <table>
 *         <caption>Options of "pnacl" backend</caption>
 *         <tr>
 *             <th>Option name</th>
 *             <th>Option values</th>
 *             <th>Default value</th>
 *         </tr>
 *         <tr>
 *             <td>"manifest"</td>
 *             <td>undefined</td>
 *             <td>URL of "furious.nmf" file in the same directory as "furious.js" library</td>
 *         </tr>
 *     </table>
 *
 *     <table>
 *         <caption>Options of "webcl" backend</caption>
 *         <tr>
 *             <th>Option name</th>
 *             <th>Option values</th>
 *             <th>Default value</th>
 *         </tr>
 *         <tr>
 *             <td>"device"</td>
 *             <td>Depends on the platform</td>
 *             <td>Discrete GPU device, if available. Otherwise integrated GPU device, if available. Otherwise CPU device.</td>
 *         </tr>
 *     </table>
 */
var getBackendOptions = function(backend) {
	if (backend === "javascript") {
		if (WebWorkerContext.isSupported()) {
			return {
				"async": [true, false]
			};
		} else {
			return {};
		}
	} else if (backend === "pnacl") {
		return {};
	} else if (backend === "webcl") {
		return {
			"device": WebCLContext.getAvailableDevices()
		};
	} else {
		throw new Error("Unsupported backend: " + backend);
	}
};

/**
 * Queries default backend options on this platform.
 *
 * @param {String} backend - name of the backend to query options for.
 *
 * @static
 * @method getBackendOptions
 *
 * @return {Object} - An object that describes available options.
 * The names of object's properties correspond to backend option names.
 * The values of object's properties correspond to default option values.
 */
var getDefaultBackendOptions = function(backend) {
	if (backend === "javascript") {
		return {
			"async": true
		};
	} else if (backend === "pnacl") {
		if (PNaClContext.isSupported()) {
			return {
				"manifest": PNaClContext.getDefaultManifestURL()
			};
		} else {
			return {};
		}
	} else if (backend === "webcl") {
		return {
			"device": WebCLContext.getDefaultDevice()
		};
	} else {
		throw new Error("Unsupported backend: " + backend);
	}
};

/**
 * Detects whether the requested computing feature is available
 *
 * @static
 * @method hasFeature
 *
 * @param {String} name - an identifier of the optional feature to detect. The following identifiers are supported:
 *
 *     <table>
 *         <tr>
 *             <th>Feature Identifier</th>
 *             <th>Interpretation</th>
 *         </tr>
 *         <tr>
 *             <td>"webworkers"</td>
 *             <td>Detect if the JavaScript engine can spawn dedicated Web Workers.</td>
 *         </tr>
 *         <tr>
 *             <td>"asm.js"</td>
 *             <td>Detect if the JavaScript engine recognizes Asm.js directive.</td>
 *         </tr>
 *         <tr>
 *             <td>"simd.js"</td>
 *             <td>Detect if the JavaScript engine provide SIMD.float32x4, SIMD.int32x4, Float32x4Array, and Int32x4Array of SIMD.js</td>
 *         </tr>
 *         <tr>
 *             <td>"webgl"</td>
 *             <td>Detect if the environment supports WebGL (either experimental or stable implementation)</td>
 *         </tr>
 *         <tr>
 *             <td>"webcl"</td>
 *             <td>Detect if the environment supports WebCL</td>
 *         </tr>
 *         <tr>
 *             <td>"pnacl"</td>
 *             <td>Detect if Portable Native Client (PNaCl) is supported and enabled</td>
 *         </tr>
 *         <tr>
 *             <td>"nacl"</td>
 *             <td>Detect if Native Client (NaCl) is supported and enabled</td>
 *         </tr>
 *     </table>
 *
 * @return {Boolean} - true if the feature is supported, false otherwise
 */
var hasFeature = function(name) {
	switch (name) {
		case "asm.js":
			try {
				var userAgent = window.navigator.userAgent;
				var userAgentComponents = userAgent.split(/\s+/);
				var firefoxRegexp = /[Ff]irefox\/(\d+)/g;
				for (var i = 0; i < userAgentComponents.length; ++i) {
					var component = userAgentComponents[i];
					var match = firefoxRegexp.exec(component);
					if (match !== null) {
						var firefoxVersion = parseInt(match[1]);
						return firefoxVersion >= 29;
					}
				}
				return false;
			} catch (e) {
			}
			return false;
		case "simd.js":
			return (typeof SIMD !== "undefined") &&
				(typeof Float32x4Array !== "undefined") &&
				(typeof Int32x4Array !== "undefined");
		case "webworkers":
			return (typeof Worker !== "undefined");
		case "webgl":
			try {
				var canvas = document.createElement("canvas");
				try {
					if (canvas.getContext("webgl") !== null) {
						return true;
					}
				} catch (e) {
				}
				try {
					if (canvas.getContext("experimental-webgl") !== null) {
						return true;
					}
				} catch (e) {
				}
			} catch (e) {
			}
			return false;
		case "webcl":
			return WebCLContext.isSupported();
		case "pnacl":
			return PNaClContext.isSupported();
		case "nacl":
			try {
				return (typeof navigator.mimeTypes["application/x-nacl"]) !== "undefined";
			} catch (e) {
			}
			return false;
		default:
			throw new Error("Unknown feature: " + name);
	}
};

exports.init = init;
exports.hasFeature = hasFeature;
exports.getDefaultBackend = getDefaultBackend;
exports.getSupportedBackends = getSupportedBackends;
exports.getBackendOptions = getBackendOptions;
exports.getDefaultBackendOptions = getDefaultBackendOptions;
exports.DataType = DataType;

},{"./DataType":1,"./PNaClContext":4,"./js/JSContext":7,"./js/WebWorkerContext":8,"./webcl/WebCLContext":13}],7:[function(require,module,exports){
"use strict";

var NDArray = require("./../NDArray");
var DataType = require("./../DataType");
var util = require("./../util");
var jsmath = require("./jsmath");

/**
 * Provides methods for creation, manipulation, and destruction of N-dimensional arrays.
 * Arithmetic operations are possible only on arrays that belong to the same context.
 *
 * @class Context
 * @constructor
 */
function JSContext(options, callback) {
	callback(this);
}

/**
 * Constructs an uninialized N-dimensional array.
 *
 * @method empty
 * @param {Number} shape - the dimensions of the array
 * @param {DataType} dataType - the type of elements in the array.
 */
JSContext.prototype.empty = function(shape, dataType) {
	/* The is no way to create uninitialized typed array in JavaScript */
	return this.zeros(shape, dataType);
};

/**
 * Constructs an N-dimensional array with elements initialized to zero.
 *
 * @method zeros
 * @param {Number} shape - the dimensions of the array
 * @param {DataType} dataType - the type of elements in the array.
 */
JSContext.prototype.zeros = function(shape, dataType) {
	shape = util.checkShape(shape);
	if (typeof dataType === "undefined") {
		dataType = new DataType("f64");
	} else {
		dataType = util.checkDataType(dataType);
	}
	var array = new NDArray(shape, dataType, this);
	array._data = new dataType.arrayType(array.length);
	return array;
};

/**
 * Constructs an N-dimensional array with elements initialized to one.
 *
 * @method ones
 * @param {Number} shape - the dimensions of the array
 * @param {DataType} dataType - the type of elements in the array.
 */
JSContext.prototype.ones = function(shape, dataType) {
	/* The is no way to create uninitialized typed array in JavaScript */
	var array = this.zeros(shape, dataType);
	jsmath.fill(array._data, 1.0);
	return array;
};

/**
 * Constructs an N-dimensional array object with the provided data.
 *
 * @method array
 * @param {Number[]} data - the array data
 * @param {DataType} dataType - the type of elements in the array.
 */
JSContext.prototype.array = function(data, dataType) {
	if (typeof dataType === "undefined") {
		dataType = new DataType("f64");
	} else {
		dataType = util.checkDataType(dataType);
	}
	var shape = [];
	util.discoverArrayShapeRecursive(data, shape, 0);
	var array = this.empty(shape, dataType);
	util.copyArrayDataRecursive(array._data, data, shape, 0, 0);
	return array;
};

/**
 * De-allocates data associated with the array.
 *
 * @method _invalidate
 * @private
 *
 * @param {NDArray} array - the n-dimensional array object with data to be de-allocated.
 */
JSContext.prototype._invalidate = function(array) {
	util.checkNDArray(array, "array");
	array._data = null;
};

/**
 * Fetches NDArray data and asynchronously returns it as JavaScript typed arrays.
 *
 * @method fetch
 * @async
 *
 * @param {NDArray} arrays* - NDArrays to fetch.
 * @param {Function} callback - A callback to be called with the data when it is available.
 * @param {ArrayBufferView} callback.arrays* - typed arrays with the data. The element type of the typed array matches the data type of the NDArray. For zero-dimensional arrays the output is returned as a typed array with a single element. Multi-dimensional arrays are returned in row-major storage format.
 */
JSContext.prototype.fetch = function() {
	if (arguments.length === 0) {
		throw new Error("Callback argument missing");
	}
	var callback = arguments[arguments.length - 1];
	/* Validate arguments */
	if (arguments.length === 1) {
		throw new Error("At least one NDArray argument expected");
	}
	for (var i = 0; i < arguments.length - 1; ++i) {
		util.checkNDArray(arguments[i], "argument " + i);
	}
	for (var i = 0; i < arguments.length - 1; ++i) {
		arguments[i]._decRef();
	}
	var callbackArguments = new Array(arguments.length - 1);
	for (var i = 0; i < callbackArguments.length; ++i) {
		var array = arguments[i];
		callbackArguments[i] = new array.dataType.arrayType(array._data);
	}
	for (var i = 0; i < arguments.length - 1; ++i) {
		arguments[i]._tryInvalidate();
	}
	callback.apply(null, callbackArguments);
};

/**
 * Fetches NDArray data and asynchronously returns it as JavaScript arrays or numbers.
 *
 * @method get
 * @async
 *
 * @param {NDArray} arrays* - NDArrays to fetch.
 * @param {Function} callback - A callback to be called with the data when it is available.
 * @param {Number|Number[]} callback.arrays* - JavaScript numbers or multidimensional arrays with the data. The number and order of arguments matches the NDArrays passed to the method call.
 */
JSContext.prototype.get = function() {
	if (arguments.length === 0) {
		throw new Error("Callback argument missing");
	}
	var callback = arguments[arguments.length - 1];
	/* Validate arguments */
	if (arguments.length === 1) {
		throw new Error("At least one NDArray argument expected");
	}
	for (var i = 0; i < arguments.length - 1; ++i) {
		util.checkNDArray(arguments[i], "argument " + i);
	}
	for (var i = 0; i < arguments.length - 1; ++i) {
		arguments[i]._decRef();
	}
	var callbackArguments = new Array(arguments.length - 1);
	for (var i = 0; i < callbackArguments.length; ++i) {
		var array = arguments[i];
		if (array.shape.length === 0) {
			callbackArguments[i] = array._data[0];
		} else {
			var jsarray = new Array(array.shape[0]);
			util.createArrayRecursive(array._data, jsarray, array.shape, 0, 0);
			callbackArguments[i] = jsarray;
		}
	}
	for (var i = 0; i < arguments.length - 1; ++i) {
		arguments[i]._tryInvalidate();
	}
	callback.apply(null, callbackArguments);
};

/**
 * Waits until previous commands finished execution and calls the callback.
 *
 * @method barrier
 * @async
 *
 * @param {Function} callback - A callback to be called after the previous commands retire.
 */
JSContext.prototype.barrier = function(callback) {
	callback();
};

/**
 * Creates another array with the same data, but different dimensions.
 *
 * @method reshape
 * @param {(NDArray|Number)} shape - dimensions of the new array.
 */
JSContext.prototype.reshape = function(array, shape) {
	shape = util.checkShape(shape);
	if (util.computeLength(shape) !== array.length) {
		throw new RangeError("The shape is not compatible with the array");
	}
	var out = new NDArray(shape, array.dataType, this);
	if (array._decRef()) {
		out._data = new out.dataType.arrayType(out.length);
		out._data.set(array._data);
	} else {
		out._data = array._data;
		array._tryInvalidate();
	}
	return out;
};

/**
 * Duplicates array elements along the specified axis.
 *
 * @method repeat
 * @param {NDArray} a - the input array.
 * @param {Number} repeats - the number of times to repeat each element.
 * @param {Number} axis - the axis along which the elements will be duplicated.
 * @param {NDArray} [out] - an output array to store the result.
 * @return {NDArray} - an N-dimensional array with repeated elements of array **a**.
 */
JSContext.prototype.repeat = function(a, repeats, axis, out) {
	util.checkNDArray(a, "a");
	repeats = util.checkRepeats(repeats);
	axis = util.checkAxis(axis, a.shape.length);
	var shapeA = a.shape;
	var shapeOut = shapeA.slice(0);
	shapeOut[axis] *= repeats;
	a._decRef();
	try {
		if (typeof out === "undefined") {
			out = this.empty(shapeOut, a.dataType);
		} else {
			util.checkNDArray(out, "out");
			util.checkShapesCompatibility(out.shape, shapeOut);
			util.checkDataTypesCompatibility(a.dataType, out.dataType);
			out._incRef();
		}
		var outerStride = util.computeOuterStride(shapeA, axis);
		var innerStride = util.computeInnerStride(shapeA, axis);
		jsmath.repeat(a._data, out._data, outerStride, innerStride, shapeA[axis], repeats);
	} catch (e) {
		a._incRef();
		throw e;
	}
	a._tryInvalidate();
	return out;
};

var binaryArithOp = function(a, b, out, context, operation, operationConst, operationRevConst) {
	var shapeOut = null, dataTypeOut = null;
	if (a instanceof NDArray) {
		shapeOut = a.shape;
		dataTypeOut = a.dataType;
		if (b instanceof NDArray) {
			util.checkShapesCompatibility(a.shape, b.shape);
			util.checkDataTypesCompatibility(a.dataType, b.dataType);
		} else if (!util.isNumber(b)) {
			throw new TypeError("Unsupported type of b");
		}
	} else if (util.isNumber(a)) {
		shapeOut = b.shape;
		dataTypeOut = b.dataType;
		util.checkNDArray(b, "b");
	} else {
		throw new TypeError("Unsupported type of a");
	}
	if (a instanceof NDArray) {
		a._decRef();
	}
	if (b instanceof NDArray) {
		b._decRef();
	}
	try {
		if (typeof out === "undefined") {
			out = new NDArray(shapeOut, dataTypeOut, context);
			if ((a instanceof NDArray) && !a._hasRefs()) {
				out._data = a._data;
			} else if ((b instanceof NDArray) && !b._hasRefs()) {
				out._data = b._data;
			} else {
				out._data = new dataTypeOut.arrayType(out.length);
			}
		} else {
			util.checkNDArray(out, "out");
			util.checkShapesCompatibility(shapeOut, out.shape);
			util.checkDataTypesCompatibility(dataTypeOut, out.dataType);
			out._incRef();
		}
		if (a instanceof NDArray) {
			if (b instanceof NDArray) {
				operation(a._data, b._data, out._data);
			} else {
				operationConst(a._data, +b, out._data);
			}
		} else {
			operationRevConst(b._data, +a, out._data);
		}
	} catch (e) {
		/* Restore the previous state */
		if (a instanceof NDArray) {
			a._incRef();
		}
		if (b instanceof NDArray) {
			b._incRef();
		}
		throw e;
	}
	if (a instanceof NDArray) {
		a._tryInvalidate();
	}
	if (b instanceof NDArray) {
		b._tryInvalidate();
	}
	return out;
};

var unaryArithOp = function(a, out, context, operation) {
	util.checkNDArray(a, "a");
	a._decRef();
	try {
		if (typeof out === "undefined") {
			out = new NDArray(a.shape, a.dataType, context);
			if ((a instanceof NDArray) && !a._hasRefs()) {
				out._data = a._data;
			} else {
				out._data = new a.dataType.arrayType(out.length);
			}
		} else {
			util.checkNDArray(out, "out");
			util.checkShapesCompatibility(a.shape, out.shape);
			util.checkDataTypesCompatibility(a.dataType, out.dataType);
			out._incRef();
		}
		operation(a._data, out._data);
	} catch (e) {
		/* Restore the previous state */
		a._incRef();
		throw e;
	}
	a._tryInvalidate();
	return out;
};

var axisReduceOp = function(a, axis, out, context, operation, axisOperation) {
	util.checkNDArray(a, "a");
	if (typeof axis === "undefined") {
		if (typeof out === "undefined") {
			out = context.empty([], a.dataType);
		} else {
			util.checkNDArray(out, "out");
			util.checkShapesCompatibility([], out.shape);
			util.checkDataTypesCompatibility(a.dataType, out.dataType);
			out._incRef();
		}
		operation(a._data, out._data);
		a._tryRelease();
		return out;
	} else {
		axis = util.checkAxis(axis, a.shape.length);
		var shapeOut = util.computeAxisReductionOutShape(a.shape, axis);
		if (typeof out === "undefined") {
			out = context.empty(shapeOut, a.dataType);
		} else {
			util.checkNDArray(out, "out");
			util.checkShapesCompatibility([], out.shape);
			util.checkDataTypesCompatibility(a.dataType, out.dataType);
			out._incRef();
		}
		axisOperation(a._data, out._data,
			util.computeOuterStride(a.shape, axis),
			util.computeInnerStride(a.shape, axis),
			a.shape[axis]);
		a._tryRelease();
		return out;
	}
};

/**
 * Adds one number or array with another number or array.
 * Addition is performed element-by-element.
 *
 * @method add
 * @param {(NDArray|Number)} a - one number or array to add. If **b** is a *Number*, **a** must be an *NDArray*.
 * @param {(NDArray|Number)} b - another number or array to add. If **a** is a *Number*, **b** must be an *NDArray*.
 * @param {NDArray} [out] - the array where the result is to be stored. If provided, must match the shape and data type of input arrays.
 * @return {NDArray} - the result of element-wise addition of **a** and **b**.
 */
JSContext.prototype.add = function(a, b, out) {
	return binaryArithOp(a, b, out, this, jsmath.add, jsmath.addConst, jsmath.addConst);
};

/**
 * Subtracts one number or array from another number or array.
 * Subtraction is performed element-by-element.
 *
 * @method sub
 * @param {(NDArray|Number)} a - the number or array to subtract from. If **b** is a *Number*, **a** must be an *NDArray*.
 * @param {(NDArray|Number)} b - the number or array to subtract. If **a** is a *Number*, **b** must be an *NDArray*.
 * @param {NDArray} [out] - the array where the result is to be stored. If provided, must match the shape and data type of input arrays.
 * @return {NDArray} - the result of element-wise subtraction of **b** from **a**.
 */
JSContext.prototype.sub = function(a, b, out) {
	return binaryArithOp(a, b, out, this, jsmath.sub, jsmath.subConst, jsmath.subRevConst);
};

/**
 * Multiplies one number or array by another number or array.
 * Multiplication is performed element-by-element.
 *
 * @method mul
 * @param {(NDArray|Number)} a - one number or array to multiply. If **b** is a *Number*, **a** must be an *NDArray*.
 * @param {(NDArray|Number)} b - another number or array to multiply. If **a** is a *Number*, **b** must be an *NDArray*.
 * @param {NDArray} [out] - the array where the result is to be stored. If provided, must match the shape and data type of input arrays.
 * @return {NDArray} - the result of element-wise multiplication of **a** and **b**.
 */
JSContext.prototype.mul = function(a, b, out) {
	return binaryArithOp(a, b, out, this, jsmath.mul, jsmath.mulConst, jsmath.mulConst);
};

/**
 * Divides one number or array by another number or array.
 * Division is performed element-by-element.
 *
 * @method div
 * @param {(NDArray|Number)} a - the number or array to divide. If **b** is a *Number*, **a** must be an *NDArray*.
 * @param {(NDArray|Number)} b - the number or array to divide by. If **a** is a *Number*, **b** must be an *NDArray*.
 * @param {NDArray} [out] - the array where the result is to be stored. If provided, must match the shape and data type of input arrays.
 * @return {NDArray} - the result of element-wise division of **a** by **b**.
 */
JSContext.prototype.div = function(a, b, out) {
	return binaryArithOp(a, b, out, this, jsmath.div, jsmath.divConst, jsmath.divRevConst);
};

JSContext.prototype.min = function(a, axis, out) {
	return axisReduceOp(a, axis, out, this, jsmath.min, jsmath.axisMin);
};

JSContext.prototype.max = function(a, axis, out) {
	return axisReduceOp(a, axis, out, this, jsmath.max, jsmath.axisMax);
};

JSContext.prototype.sum = function(a, axis, out) {
	return axisReduceOp(a, axis, out, this, jsmath.sum, jsmath.axisSum);
};

/**
 * Negates array elements.
 *
 * @method neg
 * @param {NDArray} a - the array of elements to be negated.
 * @param {NDArray} [out] - the array for negated elements. If supplied, must match the dimensions and data type of the **a** array.
 */
JSContext.prototype.neg = function(a, out) {
	return unaryArithOp(a, out, this, jsmath.neg);
};

/**
 * Computes absolute value of array elements.
 *
 * @method abs
 * @param {NDArray} a - the array of input elements.
 * @param {NDArray} [out] - the array for computed absolute values. If supplied, must match the dimensions and data type of the **a** array.
 */
JSContext.prototype.abs = function(a, out) {
	return unaryArithOp(a, out, this, jsmath.abs);
};

/**
 * Exponentiates array elements.
 *
 * @method exp
 * @param {NDArray} a - the array of elements to be exponentiated.
 * @param {NDArray} [out] - the array for exponentiated elements. If supplied, must match the dimensions and data type of the **a** array.
 */
JSContext.prototype.exp = function(a, out) {
	return unaryArithOp(a, out, this, jsmath.exp);
};

/**
 * Computes logarithm of array elements.
 *
 * @method log
 * @param {NDArray} a - the array of input elements.
 * @param {NDArray} [out] - the array for computed logarithm values. If supplied, must match the dimensions and data type of the **a** array.
 */
JSContext.prototype.log = function(a, out) {
	return unaryArithOp(a, out, this, jsmath.log);
};

/**
 * Computes square root of array elements.
 *
 * @method sqrt
 * @param {NDArray} a - the array of input elements.
 * @param {NDArray} [out] - the array for computed square root values. If supplied, must match the dimensions and data type of the **a** array.
 */
JSContext.prototype.sqrt = function(a, out) {
	return unaryArithOp(a, out, this, jsmath.sqrt);
};

/**
 * Squares array elements.
 *
 * @method square
 * @param {NDArray} a - the array of elements to be squared.
 * @param {NDArray} [out] - the array for squared elements. If supplied, must match the dimensions and data type of the **a** array.
 */
JSContext.prototype.square = function(a, out) {
	return unaryArithOp(a, out, this, jsmath.square);
};

/**
 * Computes the dot product of two N-dimensional arrays.
 *
 * @method dot
 * @param {NDArray} a - the first input array.
 * @param {NDArray} b - the second input array.
 * @param {NDArray} [out] - the output array. If supplied, must match the data type of **a** and **b** arrays and have the expected shape. Can not be the same array as **a** or **b**.
 * @return {NDArray} - the array with the dot product of **a** and **b**.
 */
JSContext.prototype.dot = function(a, b, out) {
	util.checkNDArray(a, "a");
	util.checkNDArray(b, "b");
	util.checkDataTypesCompatibility(a.dataType, b.dataType);

	/* The axis of b used in reduction: axis 0 for 1D array, second-to-last axis for ND array */
	var aAxis = Math.max(a.shape.length - 1, 0);
	var bAxis = Math.max(b.shape.length - 2, 0);
	var reductionDim = a.shape[aAxis];
	if (reductionDim !== b.shape[bAxis]) {
		throw new RangeError("Arrays have incompatible reduction dimensions");
	}
	var shapeOut = [], strideA = 1, outerStrideB = 1, innerStrideB = 1;
	for (var i = 0; i < aAxis; i++) {
		shapeOut.push(a.shape[i]);
		strideA *= a.shape[i];
	}
	for (var i = 0; i < b.shape.length; i++) {
		var dim = b.shape[i];
		if (i < bAxis) {
			outerStrideB *= dim;
			shapeOut.push(dim);
		} else if (i > bAxis) {
			innerStrideB *= dim;
			shapeOut.push(dim);
		}
	}
	if (typeof out === "undefined") {
		out = this.empty(shapeOut, a.dataType);
	} else if (out instanceof NDArray) {
		util.checkNDArray(out, "out");
		util.checkShapesCompatibility(out.shape, shapeOut);
		util.checkDataTypesCompatibility(out.dataType, a.dataType);
		util.checkDifferentNDArrays(a, out, "a", "out");
		util.checkDifferentNDArrays(b, out, "b", "out");
		out._incRef();
	}
	jsmath.dot(a._data, b._data, out._data, strideA, outerStrideB, innerStrideB, reductionDim);
	a._tryRelease();
	b._tryRelease();
	return out;
};

/**
 * Creates an arithmetic sequence.
 *
 * @method linspace
 * @param {Number} start - the starting endpoint of the sequence. Must be a finite number.
 * @param {Number} stop - the final endpoint of the sequence. Must be a finite number.
 * @param {Number} [samples=50] - the number of samples in the sequency. Must be a positive integer.
 * @param {Boolean} [closed=true] - an indicator of whether the final endpoint (`stop` argument) should be included in the sequence.
 */
JSContext.prototype.linspace = function(start, stop, samples, closed) {
	if (!util.isReal(start)) {
		throw new TypeError(start + " is not a real number");
	}
	if (!util.isReal(stop)) {
		throw new TypeError(stop + " is not a real number");
	}
	if (typeof samples === "undefined") {
		/* Default value in NumPy */
		samples = 50;
	} else if (!util.isInt(samples)) {
		throw new TypeError(samples + " is not an integer");
	} else if (samples <= 0) {
		throw new RangeError("The number of samples must be positive");
	}
	if (typeof closed === "undefined") {
		closed = true;
	}
	if (closed && (samples === 1)) {
		throw new RangeError("The number of samples must be a least 2 (for start and end points)");
	}
	var array = this.empty(samples, new DataType("f64"));
	var data = array._data;
	var range = stop - start;
	var n = (closed) ? samples - 1 : samples;
	var step = range / n;
	for (var i = 0; i < samples; i++) {
		data[i] = start + step * i;
	}
	return array;
};

module.exports = JSContext;

},{"./../DataType":1,"./../NDArray":2,"./../util":12,"./jsmath":9}],8:[function(require,module,exports){
"use strict";

var PBContext = require("./../PBContext.js");

function WebWorkerContext(options, callback) {
	var self = this;
	this._worker = new Worker(WebWorkerContext.getWorkerURL(options.baseUrl));
	this._worker.addEventListener("message", function(e) {
		self._messagingContext._onMessage(e);
	}, true);
	this._messagingContext = new PBContext(options, function(message) {
		self._worker.postMessage(message, [message]);
	}, callback);
}

WebWorkerContext.isSupported = function() {
	return typeof Worker !== "undefined";
};

WebWorkerContext.getWorkerURL = function(baseUrl) {
	if (baseUrl) {
		return baseUrl + "furious-worker.min.js";
	} else {
		return "furious-worker.min.js";
	}
};

WebWorkerContext.prototype.empty = function(shape, dataType) {
	return this._messagingContext.empty(shape, dataType);
};

WebWorkerContext.prototype.zeros = function(shape, dataType) {
	return this._messagingContext.zeros(shape, dataType);
};

WebWorkerContext.prototype.ones = function(shape, dataType) {
	return this._messagingContext.ones(shape, dataType);
};

WebWorkerContext.prototype.array = function(data, dataType) {
	return this._messagingContext.array(data, dataType);
};

WebWorkerContext.prototype.linspace = function(start, stop, samples, closed) {
	return this._messagingContext.linspace(start, stop, samples, closed);
};

WebWorkerContext.prototype.reshape = function(a, shape) {
	return this._messagingContext.reshape(a, shape);
};

WebWorkerContext.prototype.repeat = function(a, repeats, axis, out) {
	return this._messagingContext.repeat(a, repeats, axis, out);
};

WebWorkerContext.prototype._invalidate = function(array) {
	return this._messagingContext._invalidate(array);
};

WebWorkerContext.prototype.fetch = function() {
	this._messagingContext.fetch.apply(this._messagingContext, arguments);
};

WebWorkerContext.prototype.get = function() {
	this._messagingContext.get.apply(this._messagingContext, arguments);
};

WebWorkerContext.prototype.info = function(callback) {
	this._messagingContext.info(callback);
};

WebWorkerContext.prototype.barrier = function(callback) {
	this._messagingContext.barrier(callback);
};

WebWorkerContext.prototype.add = function(a, b, out) {
	return this._messagingContext.add(a, b, out);
};

WebWorkerContext.prototype.sub = function(a, b, out) {
	return this._messagingContext.sub(a, b, out);
};

WebWorkerContext.prototype.mul = function(a, b, out) {
	return this._messagingContext.mul(a, b, out);
};

WebWorkerContext.prototype.div = function(a, b, out) {
	return this._messagingContext.div(a, b, out);
};

WebWorkerContext.prototype.neg = function(a, out) {
	return this._messagingContext.neg(a, out);
};

WebWorkerContext.prototype.abs = function(a, out) {
	return this._messagingContext.abs(a, out);
};

WebWorkerContext.prototype.exp = function(a, out) {
	return this._messagingContext.exp(a, out);
};

WebWorkerContext.prototype.log = function(a, out) {
	return this._messagingContext.log(a, out);
};

WebWorkerContext.prototype.sqrt = function(a, out) {
	return this._messagingContext.sqrt(a, out);
};

WebWorkerContext.prototype.square = function(a, out) {
	return this._messagingContext.square(a, out);
};

WebWorkerContext.prototype.min = function(a, axis) {
	return this._messagingContext.min(a, axis);
};

WebWorkerContext.prototype.max = function(a, axis) {
	return this._messagingContext.max(a, axis);
};

WebWorkerContext.prototype.sum = function(a, axis) {
	return this._messagingContext.sum(a, axis);
};

WebWorkerContext.prototype.dot = function(a, b, out) {
	return this._messagingContext.dot(a, b, out);
};

module.exports = WebWorkerContext;

},{"./../PBContext.js":3}],9:[function(require,module,exports){
"use strict";

/**
 * JavaScript implementation of computational methods
 *
 * @private
 * @class JSMath
 */

/**
 * Sets all array elements to the specified value.
 *
 * @param {ArrayBufferView} data - the array data buffer.
 * @param {Number} value - the constant to fill the buffer with.
 *
 * @private
 * @static
 * @method fill
 */
exports.fill = function(data, value) {
	var n = data.length;
	for (var i = 0; i < n; ++i) {
		data[i] = value;
	}
};

/**
 * Adds two arrays.
 *
 * @param {ArrayBufferView} dataA - the input augend array.
 * @param {ArrayBufferView} dataB - the input addend array.
 * @param {ArrayBufferView} dataOut - the output sum array.
 *
 * @private
 * @static
 * @method add
 */
exports.add = function(dataA, dataB, dataOut) {
	var n = dataOut.length;
	for (var i = 0; i < n; ++i) {
		dataOut[i] = dataA[i] + dataB[i];
	}
};

/**
 * Adds a constant to an array.
 *
 * @param {ArrayBufferView} dataA - the input augend array.
 * @param {Number} valueB - the addend constant.
 * @param {ArrayBufferView} dataOut - the output sum array.
 *
 * @private
 * @static
 * @method addConst
 */
exports.addConst = function(dataA, valueB, dataOut) {
	var n = dataOut.length;
	for (var i = 0; i < n; ++i) {
		dataOut[i] = dataA[i] + valueB;
	}
};

/**
 * Subtracts two arrays.
 *
 * @param {ArrayBufferView} dataA - the input minuend array.
 * @param {ArrayBufferView} dataB - the input subtrahend array.
 * @param {ArrayBufferView} dataOut - the output difference array.
 *
 * @private
 * @static
 * @method sub
 */
exports.sub = function(dataA, dataB, dataOut) {
	var n = dataOut.length;
	for (var i = 0; i < n; ++i) {
		dataOut[i] = dataA[i] - dataB[i];
	}
};

/**
 * Subtracts a constant from an array.
 *
 * @param {ArrayBufferView} dataA - the input minuend array.
 * @param {Number} valueB - the subtrahend constant.
 * @param {ArrayBufferView} dataOut - the output difference array.
 *
 * @private
 * @static
 * @method subConst
 */
exports.subConst = function(dataA, valueB, dataOut) {
	var n = dataOut.length;
	for (var i = 0; i < n; ++i) {
		dataOut[i] = dataA[i] - valueB;
	}
};

/**
 * Subtracts an array from a constant.
 *
 * @param {ArrayBufferView} dataA - the input subtrahend array.
 * @param {Number} valueB - the minuend constant.
 * @param {ArrayBufferView} dataOut - the output difference array.
 *
 * @private
 * @static
 * @method subRevConst
 */
exports.subRevConst = function(dataA, valueB, dataOut) {
	var n = dataOut.length;
	for (var i = 0; i < n; ++i) {
		dataOut[i] = valueB - dataA[i];
	}
};

/**
 * Multiplies two arrays.
 *
 * @param {ArrayBufferView} dataA - the input multiplicand array.
 * @param {ArrayBufferView} dataB - the input multiplier array.
 * @param {ArrayBufferView} dataOut - the output product array.
 *
 * @private
 * @static
 * @method mul
 */
exports.mul = function(dataA, dataB, dataOut) {
	var n = dataOut.length;
	for (var i = 0; i < n; ++i) {
		dataOut[i] = dataA[i] * dataB[i];
	}
};

/**
 * Multiplies an array by a constant.
 *
 * @param {ArrayBufferView} dataA - the input multiplicand array.
 * @param {Number} valueB - the multiplier constant.
 * @param {ArrayBufferView} dataOut - the output product array.
 *
 * @private
 * @static
 * @method mulConst
 */
exports.mulConst = function(dataA, valueB, dataOut) {
	var n = dataOut.length;
	for (var i = 0; i < n; ++i) {
		dataOut[i] = dataA[i] * valueB;
	}
};

/**
 * Divides two arrays.
 *
 * @param {ArrayBufferView} dataA - the input dividend array.
 * @param {ArrayBufferView} dataB - the input divisor array.
 * @param {ArrayBufferView} dataOut - the output quotient array.
 *
 * @private
 * @static
 * @method div
 */
exports.div = function(dataA, dataB, dataOut) {
	var n = dataOut.length;
	for (var i = 0; i < n; ++i) {
		dataOut[i] = dataA[i] / dataB[i];
	}
};

/**
 * Divides an array by a constant.
 *
 * @param {ArrayBufferView} dataA - the input dividend array.
 * @param {Number} valueB - the divisor constant.
 * @param {ArrayBufferView} dataOut - the output quotient array.
 *
 * @private
 * @static
 * @method divConst
 */
exports.divConst = function(dataA, valueB, dataOut) {
	var n = dataOut.length;
	for (var i = 0; i < n; ++i) {
		dataOut[i] = dataA[i] / valueB;
	}
};

/**
 * Divides a constant by an array.
 *
 * @param {ArrayBufferView} dataA - the input divisor array.
 * @param {Number} valueB - the dividend constant.
 * @param {ArrayBufferView} dataOut - the output quotient array.
 *
 * @private
 * @static
 * @method divRevConst
 */
exports.divRevConst = function(dataA, valueB, dataOut) {
	var n = dataOut.length;
	for (var i = 0; i < n; ++i) {
		dataOut[i] = valueB / dataA[i];
	}
};

/**
 * Negates an array.
 *
 * @param {ArrayBufferView} dataA - the input array.
 * @param {ArrayBufferView} dataOut - the output array.
 *
 * @private
 * @static
 * @method neg
 */
exports.neg = function(dataA, dataOut) {
	var n = dataOut.length;
	for (var i = 0; i < n; ++i) {
		dataOut[i] = -dataA[i];
	}
};

/**
 * Computes absolute value of array elements.
 *
 * @param {ArrayBufferView} dataA - the input array.
 * @param {ArrayBufferView} dataOut - the output array.
 *
 * @private
 * @static
 * @method abs
 */
exports.abs = function(dataA, dataOut) {
	var n = dataOut.length;
	for (var i = 0; i < n; ++i) {
		dataOut[i] = Math.abs(dataA[i]);
	}
};

/**
 * Exponentiates array elements.
 *
 * @param {ArrayBufferView} dataA - the input array.
 * @param {ArrayBufferView} dataOut - the output array.
 *
 * @private
 * @static
 * @method exp
 */
exports.exp = function(dataA, dataOut) {
	var n = dataOut.length;
	for (var i = 0; i < n; ++i) {
		dataOut[i] = Math.exp(dataA[i]);
	}
};

/**
 * Computes logarithm of array elements.
 *
 * @param {ArrayBufferView} dataA - the input array.
 * @param {ArrayBufferView} dataOut - the output array.
 *
 * @private
 * @static
 * @method log
 */
exports.log = function(dataA, dataOut) {
	var n = dataOut.length;
	for (var i = 0; i < n; ++i) {
		dataOut[i] = Math.log(dataA[i]);
	}
};

/**
 * Computes square root of array elements.
 *
 * @param {ArrayBufferView} dataA - the input array.
 * @param {ArrayBufferView} dataOut - the output array.
 *
 * @private
 * @static
 * @method sqrt
 */
exports.sqrt = function(dataA, dataOut) {
	var n = dataOut.length;
	for (var i = 0; i < n; ++i) {
		dataOut[i] = Math.sqrt(dataA[i]);
	}
};

/**
 * Squares array elements.
 *
 * @param {ArrayBufferView} dataA - the input array.
 * @param {ArrayBufferView} dataOut - the output array.
 *
 * @private
 * @static
 * @method square
 */
exports.square = function(dataA, dataOut) {
	var n = dataOut.length;
	for (var i = 0; i < n; ++i) {
		var a = dataA[i];
		dataOut[i] = a * a;
	}
};

/**
 * Computes the minimum value of elements in an array.
 *
 * @param {ArrayBufferView} dataA - the input array to compute minimum on.
 * @param {ArrayBufferView} dataOut - the output array to store the minimum at.
 *
 * @private
 * @static
 * @method min
 */
exports.min = function(dataA, dataOut) {
	/* Computation of all-array min */
	var lengthA = dataA.length;
	var result = dataA[0];
	for (var i = 1; i < lengthA; ++i) {
		result = Math.min(result, dataA[i]);
	}
	dataOut[0] = result;
};

/**
 * Computes the maximum value of elements in an array.
 *
 * @param {ArrayBufferView} dataA - the input array to compute maximum on.
 * @param {ArrayBufferView} dataOut - the output array to store the maximum at.
 *
 * @private
 * @static
 * @method max
 */
exports.max = function(dataA, dataOut) {
	/* Computation of all-array min */
	var lengthA = dataA.length;
	var result = dataA[0];
	for (var i = 1; i < lengthA; ++i) {
		result = Math.max(result, dataA[i]);
	}
	dataOut[0] = result;
};

/**
 * Computes the sum of elements in an array.
 *
 * @param {ArrayBufferView} dataA - the input array with elements to sum up.
 * @param {ArrayBufferView} dataOut - the output array to store the sum at.
 *
 * @private
 * @static
 * @method min
 */
exports.sum = function(dataA, dataOut) {
	var lengthA = dataA.length;
	var result = 0.0;
	for (var i = 0; i < lengthA; ++i) {
		result += dataA[i];
	}
	dataOut[0] = result;
};

/**
 * Computes the minimum value of elements along an axis.
 *
 * @param {ArrayBufferView} dataA - the input array to compute minima on.
 * @param {ArrayBufferView} dataOut - the output array to store the minima at.
 * @param {Number} outerStride - the product of input array dimensions preceeding the reduction dimension.
 * @param {Number} innerStride - the product of input array dimensions following the reduction dimension.
 * @param {Number} reductionDim - the length of input array along the reduction dimension.
 *
 * @private
 * @static
 * @method axisMin
 */
exports.axisMin = function(dataA, dataOut, outerStride, innerStride, reductionDim) {
	for (var i = 0; i < outerStride; ++i) {
		for (var k = 0; k < innerStride; ++k) {
			var offset = i * reductionDim * innerStride + k;
			var currentMin = dataA[offset];
			for (var j = 1; j < reductionDim; ++j) {
				offset += innerStride;
				currentMin = Math.min(currentMin, dataA[offset]);
			}
			dataOut[i * innerStride + k] = currentMin;
		}
	}
};

/**
 * Computes the maximum value of elements along an axis.
 *
 * @param {ArrayBufferView} dataA - the input array to compute maxima on.
 * @param {ArrayBufferView} dataOut - the output array to store the maxima at.
 * @param {Number} outerStride - the product of input array dimensions preceeding the reduction dimension.
 * @param {Number} innerStride - the product of input array dimensions following the reduction dimension.
 * @param {Number} reductionDim - the length of input array along the reduction dimension.
 *
 * @private
 * @static
 * @method axisMax
 */
exports.axisMax = function(dataA, dataOut, outerStride, innerStride, reductionDim) {
	for (var i = 0; i < outerStride; ++i) {
		for (var k = 0; k < innerStride; ++k) {
			var offset = i * reductionDim * innerStride + k;
			var currentMax = dataA[offset];
			for (var j = 1; j < reductionDim; ++j) {
				offset += innerStride;
				currentMax = Math.max(currentMax, dataA[offset]);
			}
			dataOut[i * innerStride + k] = currentMax;
		}
	}
};

/**
 * Computes the sum of elements along an axis.
 *
 * @param {ArrayBufferView} dataA - the input array to sum up.
 * @param {ArrayBufferView} dataOut - the output array to store the sums at.
 * @param {Number} outerStride - the product of input array dimensions preceeding the reduction dimension.
 * @param {Number} innerStride - the product of input array dimensions following the reduction dimension.
 * @param {Number} reductionDim - the length of input array along the reduction dimension.
 *
 * @private
 * @static
 * @method axisSum
 */
exports.axisSum = function(dataA, dataOut, outerStride, innerStride, reductionDim) {
	for (var i = 0; i < outerStride; ++i) {
		for (var k = 0; k < innerStride; ++k) {
			var offset = i * reductionDim * innerStride + k;
			var currentSum = dataA[offset];
			for (var j = 1; j < reductionDim; ++j) {
				offset += innerStride;
				currentSum += dataA[offset];
			}
			dataOut[i * innerStride + k] = currentSum;
		}
	}
};

/**
 * Computes the dot product of two N-dimensional arrays.
 *
 * @param {ArrayBufferView} dataA - an input multiplicand array.
 * @param {ArrayBufferView} dataB - an input multiplier array.
 * @param {ArrayBufferView} dataOut - the output product array.
 * @param {Number} strideA - the product of the the multiplicand dimensions preceeding the reduction dimension.
 * @param {Number} outerStrideB - the product of the multiplier dimensions preceeding the reduction dimension.
 * @param {Number} innerStrideB - the product of the multiplier dimensions following the reduction dimension.
 * @param {Number} reductionDim - the length of inputs arrays along the reduction dimension.
 *
 * @private
 * @static
 * @method dot
 */
exports.dot = function(dataA, dataB, dataOut, strideA, outerStrideB, innerStrideB, reductionDim) {
	for (var i = 0; i < strideA; ++i) {
		for (var j = 0; j < reductionDim; ++j) {
			for (var k = 0; k < outerStrideB; ++k) {
				for (var l = 0; l < innerStrideB; ++l) {
					dataOut[(i*outerStrideB + k) * innerStrideB + l] += dataA[i*reductionDim+j] * dataB[(k*reductionDim+j)*innerStrideB+l];
				}
			}
		}
	}
};

/**
 * Replicates array elements along an axis.
 *
 * @param {ArrayBufferView} dataA - the input array.
 * @param {ArrayBufferView} dataOut - the output array for repeated elements.
 * @param {Number} outerStride - the product of input array dimensions preceeding the expansion dimension.
 * @param {Number} innerStride - the product of input array dimensions following the expansion dimension.
 * @param {Number} expansionDim - the length of input array along the expansion dimension.
 * @param {Number} repeats - the number of times each element will be replicated.
 *
 * @private
 * @static
 * @method repeat
 */
exports.repeat = function(dataA, dataOut, outerStride, innerStride, expansionDim, repeats) {
	if (innerStride < repeats) {
		for (var i = 0; i < outerStride; ++i) {
			for (var j = 0; j < expansionDim; ++j) {
				for (var k = 0; k < innerStride; ++k) {
					var valueA = dataA[(i * expansionDim + j) * innerStride + k];
					for (var c = 0; c < repeats; ++c) {
						dataOut[((i * expansionDim + j) * repeats + c) * innerStride + k] = valueA;
					}
				}
			}
		}
	} else {
		for (var i = 0; i < outerStride; ++i) {
			for (var j = 0; j < expansionDim; ++j) {
				var rowA = dataA.subarray((i * expansionDim + j) * innerStride, (i * expansionDim + j + 1) * innerStride);
				for (var c = 0; c < repeats; ++c) {
					dataOut.set(rowA, ((i * expansionDim + j) * repeats + c) * innerStride);
				}
			}
		}
	}
};

},{}],10:[function(require,module,exports){

var protobufjs = require("protobufjs");
protobufjs.convertFieldsToCamelCase = true;
var requestsProto = "package furious;\r\n\r\noption optimize_for = LITE_RUNTIME;\r\n\r\nenum DataType {\r\n\tFLOAT64 = 0;\r\n\tFLOAT32 = 1;\r\n}\r\n\r\nmessage Request {\r\n\tenum Type {\r\n\t\tEMPTY_ARRAY              =  0;\r\n\t\tDATA_ARRAY               =  1;\r\n\t\tCONST_ARRAY              =  2;\r\n\t\tLINSPACE                 =  3;\r\n\t\tRESHAPE                  =  4;\r\n\t\tREPEAT                   =  5;\r\n\t\tDEALLOCATE               =  6;\r\n\t\tFETCH                    =  7;\r\n\t\tBARRIER                  =  8;\r\n\t\tINFO                     =  9;\r\n\t\tBINARY_OPERATION         = 10;\r\n\t\tBINARY_CONST_OPERATION   = 11;\r\n\t\tUNARY_OPERATION          = 12;\r\n\t\tREDUCTION_OPERATION      = 13;\r\n\t\tAXIS_REDUCTION_OPERATION = 14;\r\n\t\tDOT_OPERATION            = 15;\r\n\t}\r\n\trequired fixed32                     id                             =  1;\r\n\trequired Type                        type                           =  2;\r\n\r\n\toptional EmptyArrayRequest           empty_array_request            =  3;\r\n\toptional DataArrayRequest            data_array_request             =  4;\r\n\toptional ConstArrayRequest           const_array_request            =  5;\r\n\toptional LinspaceRequest             linspace_request               =  6;\r\n\toptional ReshapeRequest              reshape_request                =  7;\r\n\toptional RepeatRequest               repeat_request                 =  8;\r\n\toptional DeallocateRequest           deallocate_request             =  9;\r\n\toptional FetchRequest                fetch_request                  = 10;\r\n\toptional BinaryOperationRequest      binary_operation_request       = 11;\r\n\toptional BinaryConstOperationRequest binary_const_operation_request = 12;\r\n\toptional UnaryOperationRequest       unary_operation_request        = 13;\r\n\toptional ReductionRequest            reduction_request              = 14;\r\n\toptional AxisReductionRequest        axis_reduction_request         = 15;\r\n\toptional DotOperationRequest         dot_operation_request          = 16;\r\n}\r\n\r\nmessage EmptyArrayRequest {\r\n\trequired fixed32  id_out      = 1;\r\n\trepeated uint32   shape       = 2 [packed=true];\r\n\trequired DataType data_type   = 3;\r\n}\r\n\r\nmessage DataArrayRequest {\r\n\trequired fixed32  id_out      = 1;\r\n\trepeated uint32   shape       = 2 [packed=true];\r\n\trequired DataType data_type   = 3;\r\n\trequired bytes    data_buffer = 4;\r\n}\r\n\r\nmessage ConstArrayRequest {\r\n\trequired fixed32  id_out      = 1;\r\n\trepeated uint32   shape       = 2 [packed=true];\r\n\trequired DataType data_type   = 3;\r\n\trequired double   fill_value  = 4;\r\n}\r\n\r\nmessage LinspaceRequest {\r\n\trequired sfixed32  id_out     = 1;\r\n\trequired double    start      = 2;\r\n\trequired double    stop       = 3;\r\n\trequired uint32    samples    = 4;\r\n\trequired bool      closed     = 5;\r\n\trequired DataType  data_type  = 6;\r\n}\r\n\r\nmessage ReshapeRequest {\r\n\trequired sfixed32  id_a      = 1;\r\n\trequired fixed32   id_out    = 2;\r\n\trepeated uint32    shape_out = 3 [packed=true];\r\n}\r\n\r\nmessage RepeatRequest {\r\n\trequired sfixed32 id_a    = 1;\r\n\trequired fixed32  id_out  = 2;\r\n\trequired uint32   axis    = 3;\r\n\trequired uint32   repeats = 4;\r\n}\r\n\r\nmessage DeallocateRequest {\r\n\trequired fixed32 id_a = 1;\r\n}\r\n\r\nmessage FetchRequest {\r\n\trequired sfixed32 id_a = 1;\r\n}\r\n\r\nmessage BinaryOperationRequest {\r\n\tenum Type {\r\n\t\tADD = 0;\r\n\t\tSUB = 1;\r\n\t\tMUL = 2;\r\n\t\tDIV = 3;\r\n\t}\r\n\trequired Type     type   = 1;\r\n\trequired sfixed32 id_a   = 2;\r\n\trequired sfixed32 id_b   = 3;\r\n\trequired fixed32  id_out = 4;\r\n}\r\n\r\nmessage BinaryConstOperationRequest {\r\n\tenum Type {\r\n\t\tADDC  = 0;\r\n\t\tSUBC  = 1;\r\n\t\tSUBRC = 2;\r\n\t\tMULC  = 3;\r\n\t\tDIVC  = 4;\r\n\t\tDIVRC = 5;\r\n\t}\r\n\trequired Type     type    = 1;\r\n\trequired sfixed32 id_a    = 2;\r\n\trequired double   value_b = 3;\r\n\trequired fixed32  id_out  = 4;\r\n}\r\n\r\nmessage UnaryOperationRequest {\r\n\tenum Type {\r\n\t\tNEG    = 0;\r\n\t\tABS    = 1;\r\n\t\tEXP    = 2;\r\n\t\tLOG    = 3;\r\n\t\tSQRT   = 4;\r\n\t\tSQUARE = 5;\r\n\t}\r\n\trequired Type     type   = 1;\r\n\trequired sfixed32 id_a   = 2;\r\n\trequired fixed32  id_out = 3;\r\n}\r\n\r\nmessage ReductionRequest {\r\n\tenum Type {\r\n\t\tSUM = 0;\r\n\t\tMIN = 1;\r\n\t\tMAX = 2;\r\n\t}\r\n\trequired Type     type   = 1;\r\n\trequired sfixed32 id_a   = 2;\r\n\trequired fixed32  id_out = 3;\r\n}\r\n\r\nmessage AxisReductionRequest {\r\n\tenum Type {\r\n\t\tSUM = 0;\r\n\t\tMIN = 1;\r\n\t\tMAX = 2;\r\n\t}\r\n\trequired Type     type   = 1;\r\n\trequired sfixed32 id_a   = 2;\r\n\trequired uint32   axis   = 3;\r\n\trequired fixed32  id_out = 4;\r\n}\r\n\r\nmessage DotOperationRequest {\r\n\trequired sfixed32 id_a   = 1;\r\n\trequired sfixed32 id_b   = 2;\r\n\trequired fixed32  id_out = 3;\r\n}\r\n";
module.exports = protobufjs.loadProto(requestsProto).build("furious");

},{"protobufjs":53}],11:[function(require,module,exports){

var protobufjs = require("protobufjs");
protobufjs.convertFieldsToCamelCase = true;
var responsesProto = "package furious;\r\n\r\noption optimize_for = LITE_RUNTIME;\r\n\r\nmessage Response {\r\n\tenum Type {\r\n\t\tFETCH   = 0;\r\n\t\tERROR   = 1;\r\n\t\tINIT    = 2;\r\n\t\tBARRIER = 3;\r\n\t\tINFO    = 4;\r\n\t}\r\n\trequired fixed32         id               = 1;\r\n\trequired Type            type             = 2;\r\n\r\n\toptional FetchResponse   fetch_response   = 3;\r\n\toptional ErrorResponse   error_response   = 4;\r\n\toptional InitResponse    init_response    = 5;\r\n\toptional InfoResponse    info_response    = 7;\r\n}\r\n\r\nmessage FetchResponse {\r\n\trequired bytes data_buffer = 1;\r\n}\r\n\r\nmessage ErrorResponse {\r\n\tenum Type {\r\n\t\tRUNTIME  = 0;\r\n\t\tARGUMENT = 1;\r\n\t\tPARSE    = 2;\r\n\t}\r\n\trequired Type   type        = 1;\r\n\toptional string description = 2;\r\n}\r\n\r\nmessage InitResponse {\r\n\toptional uint32 concurrency = 1;\r\n}\r\n\r\nmessage InfoResponse {\r\n}\r\n";
module.exports = protobufjs.loadProto(responsesProto).build("furious");

},{"protobufjs":53}],12:[function(require,module,exports){
"use strict";

/**
 * Provides helper functions
 *
 * @private
 * @class util
 */

var isNumber = function(n) {
	return n === +n;
};
exports.isNumber = isNumber;

var isReal = function(n) {
	return (n === +n) && (isFinite(n));
};
exports.isReal = isReal;

var isInt = function(n) {
	return n === (n|0);
};
exports.isInt = isInt;

exports.isPositiveInt = function(n) {
	return (n === +n) && (n === (n|0)) && (n > 0);
};

exports.isNonNegativeInt = function(n) {
	return (n === +n) && (n === (n|0)) && (n >= 0);
};

var isArray = function(list) {
	return list instanceof Array;
};
exports.isArray = isArray;

exports.isIntArray = function(list) {
	if (exports.isArray(list)) {
		for (var i = 0; i < list.length; i++) {
			if (!exports.isInt(list[i])) {
				return false;
			}
		}
		return true;
	} else {
		return false;
	}
};

exports.isPositiveIntArray = function(list) {
	if (exports.isArray(list)) {
		for (var i = 0; i < list.length; i++) {
			if (!exports.isPositiveInt(list[i])) {
				return false;
			}
		}
		return true;
	} else {
		return false;
	}
};

exports.asIntArray = function (list) {
	if (exports.isInt(list)) {
		return [list];
	} else if (exports.isIntArray(list)) {
		return list;
	} else {
		throw new TypeError(list + " can not be converted to integer array");
	}
};

/**
 * Compares for equality two arrays of primitive types.
 *
 * @param {Number[]} arrayA - the first array to compare.
 * @param {Number[]} arrayB - the second array to compare.
 *
 * @example
 *     if (!util.arrayEquals(a.shape, b.shape)) {
 *	       throw new Error("a and b have incompatible shapes");
 *     }
 *
 * @private
 * @static
 * @method arrayEquals
 */
exports.arrayEquals = function(arrayA, arrayB) {
	if (arrayA === arrayB) {
		return true;
	}
	if (arrayA.length !== arrayB.length) {
		return false;
	}
	var n = arrayA.length;
	for (var i = 0; i < n; ++i) {
		if (arrayA[i] !== arrayB[i]) {
			return false;
		}
	}
	return true;
};

exports.roundUp = function (number, multiple) {
	return Math.ceil(number / multiple) * multiple;
};

/**
 * Validate the shape argument.
 * Throws an error if the argument represents a valid shape.
 * Returns the shape as an integer array.
 *
 * @param {(Number|Number[])} shape - the shape argument to validate.
 *
 * @example
 *     shape = util.checkShape(shape);
 *
 * @private
 * @static
 * @method checkShape
 */
var checkShape = function(shape) {
	if (isNumber(shape)) {
		return checkShape([shape]);
	} else if (isArray(shape)) {
		var n = shape.length;
		var outShape = new Array(n);
		for (var i = 0; i < n; i++) {
			if (!isNumber(shape[i])) {
				throw new Error("Shape has non-numeric dimensions");
			}
			if (!isInt(shape[i])) {
				throw new Error("Shape must have integer dimensions");
			}
			if (shape[i] < 1) {
				throw new Error("Degenerate shape");
			}
			outShape[i] = shape[i]|0;
		}
		return outShape;
	} else {
		throw new Error("Shape must be an integer or integer array");
	}
};
exports.checkShape = checkShape;

/**
 * Checks that the two shapes are similar.
 * Throws an error if the two shapes are different.
 * If the data types are compatible, the function does nothing.
 *
 * @param {Number[]} shapeA - one valid shape to compare.
 * @param {Number[]} shapeB - another valid shape to compare.
 *
 * @example
 *     util.checkShapesCompatibility(a.shape, b.shape);
 *
 * @private
 * @static
 * @method checkShapesCompatibility
 */
exports.checkShapesCompatibility = function(shapeA, shapeB) {
	if (shapeA.length != shapeB.length) {
		throw new Error("The shapes have different dimensions");
	}
	var n = shapeA.length;
	for (var i = 0; i < n; i++) {
		if (shapeA[i] != shapeB[i]) {
			throw new Error("The shapes are different");
		}
	}
};

/**
 * Computes array length from its shape.
 *
 * @param {Number[]} shape - an array shape.  The shape must be valid w.r.t. **checkShape** function.
 *
 * @example
 *     var length = util.computeLength(shape);
 *
 * @private
 * @static
 * @method computeLength
 */
exports.computeLength = function(shape) {
	var length = 1;
	for (var i = 0; i < shape.length; ++i) {
		length *= shape[i];
	}
	return length;
};

/**
 * Checks the the argument represents a data type.
 * Throws an error if the argument is not of DataType type.
 * If the argument is a DataType object, the function does nothing.
 *
 * @param {DataType} dataType - the expectedly data type object to validate.
 * @return {DataType} - a data type object equivalent to the argument.
 *
 * @example
 *     dataType = util.checkDataType(dataType);
 *
 * @private
 * @static
 * @method checkDataType
 */
exports.checkDataType = function(dataType) {
	var DataType = require("./DataType");
	if (!(dataType instanceof DataType)) {
		throw new TypeError("dataType is not an instance of DataType");
	}
	return dataType;
};

/**
 * Checks that the two data types are compatible.
 * Throws an error if the data types do not match.
 * If the data types are compatible, the function does nothing.
 *
 * @param {DataType} dataTypeA - the first data type.
 * @param {DataType} dataTypeB - the second data type.
 *
 * @example
 *     util.checkDataTypesCompatibility(a.dataType, b.dataType);
 *
 * @private
 * @static
 * @method checkDataTypesCompatibility
 */
exports.checkDataTypesCompatibility = function(dataTypeA, dataTypeB) {
	if (!dataTypeA.equals(dataTypeB)) {
		throw new Error("The data types are not compatible");
	}
};

/**
 * Validates an NDArray parameter.
 * Throws an error if the expected NDArray argument has other type or if it has been invalidated.
 * If the argument is a valid NDArray, the function does nothing.
 *
 * @param {NDArray} array - the expectedly NDArray argument to be validated.
 * @param {String} vaname - the name of the NDArray argument to be used in error messages.
 *
 * @example
 *     util.checkNDArray(out, "out");
 *
 * @private
 * @static
 * @method checkNDArray
 */
exports.checkNDArray = function(array, varname) {
	var NDArray = require("./NDArray");
	if (!(array instanceof NDArray)) {
		throw new TypeError(varname + " is not an NDArray");
	}
	if (!array.isValid()) {
		throw new Error(varname + " is an invalidated array");
	}
};

/**
 * Checks that the two arrays are different.
 * Throws an error if they refer to the same object.
 * If the arrays are different, the function does nothing.
 *
 * @param {NDArray} a - the first array to check. Must be an NDArray object.
 * @param {NDArray} b - the second array to check. Must be an NDArray object.
 * @param {String} varnameA - name of the first array variable. This name may be used in an error message.
 * @param {String} varnameB - name of the second array variable. This name may be used in an error message.
 *
 * @example
 *     util.checkDifferentNDArrays(a, out, "a", "out");
 *
 * @private
 * @static
 * @method checkDifferentNDArrays
 */
exports.checkDifferentNDArrays = function(a, b, varnameA, varnameB) {
	if (a === b) {
		throw new Error("The arrays " + varnameA + " and " + varnameB + " must be different");
	}
};

/**
 * Validates **repeats** parameter for repeatition/tiling of array along an axis.
 * Throws an error if **repeats** is not an integer or if **repeats** is smaller than 2.
 * If **repeats** is valid, the function does nothing.
 *
 * @param {Number} repeats - the repeats argument to be verified.
 * @return {Number} - **repeats** casted to integer.
 *
 * @example
 *     repeats = util.checkRepeats(repeats);
 *
 * @private
 * @static
 * @method checkRepeats
 */
exports.checkRepeats = function(repeats) {
	if (!isInt(repeats)) {
		throw new TypeError("Repeats is not an integer");
	}
	if (repeats <= 1) {
		throw new RangeError("Repeats should be greater than 1");
	}
	return repeats|0;
};

/**
 * Validates axis parameter for reductions along an axis.
 * Throws an error if axis is not an integer, if axis is negative, or axis exceeds the number of dimensions.
 * If axis is valid, the function does nothing.
 *
 * @param {Number} axis - the axis argument to be verified.
 * @param {Number} numDimensions - the number of dimensions in the array being reduced.
 * @return {Number} - axis casted to integer.
 *
 * @example
 *     axis = util.checkAxis(axis, ndarray.shape.length);
 *
 * @private
 * @static
 * @method
 */
exports.checkAxis = function(axis, numDimensions) {
	if (!isInt(axis)) {
		throw new TypeError("Axis is not an integer");
	}
	if (axis < 0) {
		throw new RangeError("Axis is negative");
	}
	/* E.g. 3-dimensional array has axes 0, 1, 2 (but not 3!) */
	if (axis >= numDimensions) {
		throw new RangeError("Axis out of range");
	}
	return axis|0;
};

/**
 * Validates the shape of output array for reductions along an axis.
 * Throws an error if the shape of the output array does match the shape of input array after reduction along the axis.
 *
 * @param {Number[]} inShape - the shape of the input array.
 * @param {Number[]} outShape - the shape of the output array to be validated.
 * @param {Number} axis - the axis for reduction of input array. Must be valid w.r.t. inShape.
 *
 * @example
 *     util.checkAxisReductionOutShape(inArray.shape, outArray.shape, axis);
 *
 * @private
 * @static
 * @method
 */
exports.checkAxisReductionOutShape = function(inShape, outShape, axis) {
	if (inShape.length !== outShape.length + 1) {
		throw new Error("Output array has invalid number of dimensions for this operation");
	}
	for (var i = 0; i < axis; ++i) {
		if (inShape[i] !== outShape[i]) {
			throw new Error("Output array has invalid shape for this operation");
		}
	}
	for (var i = axis + 1; i < inShape.length; ++i) {
		if (inShape[i] !== outShape[i-1]) {
			throw new Error("Output array has invalid shape for this operation");
		}
	}
};

/**
 * Computes the shape of an array after reduction along an axis.
 *
 * @param {Number[]} inShape - the shape of the input array.
 * @param {Number} axis - the axis for reduction of input array. Must be valid w.r.t. inShape.
 * @return {Number[]} - the shape of the output array.
 *
 * @example
 *     var outShape = util.getAxisReductionOutShape(inArray.shape, axis);
 *     var outArray = new NDArray(outShape, inArray.dataType, context);
 *
 * @private
 * @static
 * @method
 */
exports.computeAxisReductionOutShape = function(inShape, axis) {
	var outShape = [];
	for (var i = 0; i < inShape.length; ++i) {
		if (i !== axis) {
			outShape.push(inShape[i]);
		}
	}
	return outShape;
};

/**
 * Computes the product of array dimensions before the axis.
 *
 * @param {Number[]} shape - the shape of the array.
 * @param {Number} axis - the axis used in an operation. Must be valid w.r.t. shape.
 * @return {Number} - the product of array dimensions before axis.
 *
 * @example
 *     // 5-dimensional array
 *     var ndarray = context.empty([2, 3, 4, 5, 6]);
 *     // Returns 6 = 2*3
 *     var outerStride = computeOuterStride(ndarray, 2);
 *
 * @private
 * @static
 * @method
 */
exports.computeOuterStride = function(shape, axis) {
	var outerStride = 1;
	for (var i = 0; i < axis; ++i) {
		outerStride *= shape[i];
	}
	return outerStride;
};

/**
 * Computes the product of array dimensions after the axis.
 *
 * @param {Number[]} shape - the shape of the array.
 * @param {Number} axis - the axis used in an operation. Must be valid w.r.t. shape.
 * @return {Number} - the product of array dimensions after axis.
 *
 * @example
 *     // 5-dimensional array
 *     var ndarray = context.empty([2, 3, 4, 5, 6]);
 *     // Returns 6 = 2*3
 *     var innerStride = computeInnerStride(ndarray, 2);
 *
 * @private
 * @static
 * @method
 */
exports.computeInnerStride = function(shape, axis) {
	var innerStride = 1;
	for (var i = axis + 1; i < shape.length; ++i) {
		innerStride *= shape[i];
	}
	return innerStride;
};

var discoverArrayShapeRecursive = function(data, shape, level) {
	if (isArray(data)) {
		if (shape.length <= level) {
			/* Discovered a new level of sub-arrays. Record its dimension. */
			shape.push(data.length);
		} else {
			/* Only check dimension */
			if (shape[level] != data.length) {
				throw new RangeError("Sub-array " + data + " does not match the expected dimension of " + shape[level]);
			}
		}
		for (var i = 0; i < data.length; i++) {
			discoverArrayShapeRecursive(data[i], shape, level + 1);
		}
	} else {
		if (level != shape.length) {
			throw new RangeError("Sub-array [" + data + "] does not match the expected dimension of " + shape[level]);
		}
		if (!isNumber(data)) {
			throw new TypeError("Non-numeric element: " + data);
		}
	}
};
exports.discoverArrayShapeRecursive = discoverArrayShapeRecursive;

var copyArrayDataRecursive = function(dataBuffer, dataArray, shape, level, offset) {
	var n = shape[level];
	if (level === shape.length - 1) {
		dataBuffer.set(dataArray, offset * n);
	} else {
		for (var i = 0; i < n; i++) {
			copyArrayDataRecursive(dataBuffer, dataArray[i], shape, level + 1, offset * n  + i);
		}
	}
};
exports.copyArrayDataRecursive = copyArrayDataRecursive;

var createArrayRecursive = function(dataBuffer, dataArray, shape, level, offset) {
	var n = shape[level];
	if (level === shape.length - 1) {
		for (var i = 0; i < n; i++) {
			dataArray[i] = dataBuffer[offset * n + i];
		}
	} else {
		for (var i = 0; i < n; i++) {
			dataArray[i] = new Array(shape[level + 1]);
			createArrayRecursive(dataBuffer, dataArray[i], shape, level + 1, offset * n  + i);
		}
	}
};
exports.createArrayRecursive = createArrayRecursive;

},{"./DataType":1,"./NDArray":2}],13:[function(require,module,exports){
"use strict";

var NDArray = require("../NDArray");
var DataType = require("../DataType");
var util = require("../util");


/* Buggy in Chromium-WebCL */
var useBufferCreationWithInit = false;

var isNodeWebCL = false;
var cl = void 0;
var availableDevices = null;
var availableDevicesDescriptions = null;
var defaultDeviceIndex = -1;

/**
 * If the global cl variable is undefined, this method would initialize it with a WebCL instance.
 * Works for both browser and Node.js
 *
 * @private
 * @static
 * @method initWebCL
 * @return {WebCL} - an instance of WebCL object from WebCL specification. If WebCL is not supported, return null.
 */
var initWebCL = function() {
	if (typeof cl === "undefined") {
		if (typeof window === "object") {
			cl = (typeof window.webcl !== "undefined") ? window.webcl : null;
		} else {
			try {
				cl = require("node-webcl");
				isNodeWebCL = true;
			} catch (e) {
				cl = null;
			}
		}
	}
	return cl;
};

/**
 * Creates an empty WebCLEvent.
 * Works for both browser and Node.js
 *
 * @private
 * @static
 * @method createEvent
 * @return {WebCLEvent} - an empty instance of WebCLEvent.
 */
var createEvent = function() {
	if (isNodeWebCL) {
		return new cl.WebCLEvent();
	} else {
		return new WebCLEvent();
	}
};

/**
 * Tries to release a WebCL resource and ignores any errors in the process.
 *
 * @private
 * @method tryRlease
 * @param {Object} webclObject - a WebCL object.
 * @return {Boolean} - true if the object was successfully released and false otherwise.
 */
var tryRelease = function(webclResource) {
	if (webclResource !== null) {
		try {
			webclResource.release();
			return true;
		} catch (e) {
			/* Silently ignore */
		}
	}
	return false;
};

/**
 * Checks if a WebCL device supports KHR_fp64 extension.
 *
 * @private
 * @method isFP64Capable
 * @param {WebCLDevice} device - the device to check for KHR_fp64 support.
 * @return {Boolean} - true if the device supports KHR_fp64 and false otherwise.
 */
var isFP64Capable = function(device) {
	var extensions = device.getSupportedExtensions();
	if (extensions.indexOf("KHR_fp64") === -1) {
		return false;
	}
	/*
	 * Due to a bug WebKit-WebCL may report KHR_fp64 even if it is not supported by the underlying OpenCL device.
	 * See bug https://github.com/SRA-SiliconValley/webkit-webcl/issues/536
	 */
	var testSource = "kernel void foo(global double* bar) { }";
	var context = null, program = null;
	try {
		context = cl.createContext(device);
		program = context.createProgram(testSource);
		program.build();
		return true;
	} catch (e) {
		return false;
	} finally {
		tryRelease(program);
		tryRelease(context);
	}
};

/**
 * Initialises and returns a list of WebCL devices suitable for computation.
 *
 * @private
 * @static
 * @method getAvailableDevices
 * @return {WebCLDevice[]} - a list of GPU and CPU WebCL devices that support KHR_FP64 (may be empty).
 */
var getAvailableDevices = function() {
	if (availableDevices === null) {
		availableDevices = [];
		var webcl = initWebCL();
		if (webcl !== null) {
			var platforms = cl.getPlatforms();
			for (var i = 0; i < platforms.length; ++i) {
				var platform = platforms[i];
				var devices = platform.getDevices(cl.DEVICE_TYPE_ALL);
				for (var j = 0; j < devices.length; ++j) {
					var device = devices[j];
					if (isFP64Capable(device)) {
						availableDevices.push(device);
					}
				}
			}
		}
		generateAvailableDevicesDescriptions();
	}
	return availableDevices;
};

var generateAvailableDevicesDescriptions = function() {
	availableDevicesDescriptions = [];
	/* If devices names are available, use them */
	var haveNames = true;
	for (var i = 0; i < availableDevices.length; ++i) {
		var device = availableDevices[i];
		var name = device.getInfo(cl.DEVICE_NAME);
		if ((name === null) || (name === "")) {
			haveNames = false;
			break;
		}
		availableDevicesDescriptions[i] = name;
	}
	if (!haveNames) {
		/* At least some names are not available: try to assign names based on classification (e.g. "CPU", "dGPU", "iGPU") */
		var cpuCount = 0, igpuCount = 0, dgpuCount = 0;
		for (var i = 0; i < availableDevices.length; ++i) {
			var device = availableDevices[i];
			var classification = classifyDevice(device);
			if (classification === "cpu") {
				++cpuCount;
				availableDevicesDescriptions[i] = "CPU";
			} else if (classification === "igpu") {
				++igpuCount;
				availableDevicesDescriptions[i] = "iGPU";
			} else if (classification === "dgpu") {
				++dgpuCount;
				availableDevicesDescriptions[i] = "dGPU";
			} else {
				throw new Error("Impossible device classification: " + classification);
			}
		}
		if ((cpuCount > 1) || (igpuCount > 1) || (dgpuCount > 1)) {
			/* We have multiple devices of the same type. Need to use more complicated naming scheme */
			var cpuIndex = 0, igpuIndex = 0, dgpuIndex = 0;
			for (var i = 0; i < availableDevices.length; ++i) {
				var device = availableDevices[i];
				var classification = classifyDevice(device);
				if (classification === "cpu") {
					if (cpuCount > 1) {
						++cpuIndex;
						availableDevicesDescriptions[i] = "CPU #" + cpuIndex;
					}
				} else if (classification === "igpu") {
					if (igpuCount > 1) {
						++igpuIndex;
						availableDevicesDescriptions[i] = "iGPU #" + igpuIndex;
					}
				} else if (classification === "dgpu") {
					if (dgpuCount > 1) {
						++dgpuCount;
						availableDevicesDescriptions[i] = "dGPU #" + dgpuIndex;
					}
				} else {
					throw new Error("Impossible device classification: " + classification);
				}
			}
		}
	}
};

/**
 * Classifies WebCL device to one of four categories:
 * - "cpu" for CPU devices.
 * - "igpu" for GPUs integrated with CPU package or chipset.
 * - "dgpu" for discrete GPUs.
 * - "unknown" for other types of devices (e.g. FPGAs)
 *
 * @private
 * @method classifyDevice
 * @param {WebCLDevice} device - the WebCL device to classify.
 * @return {String} - one of the strings described above.
 */
var classifyDevice = function(device) {
	try {
		var deviceType = device.getInfo(cl.DEVICE_TYPE);
		if (deviceType === cl.DEVICE_TYPE_CPU) {
			return "cpu";
		} else if (deviceType === cl.DEVICE_TYPE_GPU) {
			var isHostUnifiedMemory = device.getInfo(cl.DEVICE_HOST_UNIFIED_MEMORY);
			return (isHostUnifiedMemory ? "igpu" : "dgpu");
		}
	} catch (e) {
	}
	return "unknown";
};

/**
 * Selects the optimal WebCL device among the available devices.
 * The priority of devices: "dgpu" > "igpu" > "cpu"
 *
 * @private
 * @method getDefaultDeviceIndex
 * @return {WebCLDevice} - the selected device from the list.
 */
var getDefaultDeviceIndex = function() {
	if (defaultDeviceIndex === -1) {
		var availableDevices = getAvailableDevices();
		if (availableDevices.length === 0) {
			defaultDeviceIndex = -2;
			return defaultDeviceIndex;
		}
		var deviceClassifications = [];
		/* Search for "dgpu" */
		for (var i = 0; i < availableDevices.length; ++i) {
			var device = availableDevices[i];
			var deviceClass = classifyDevice(device);
			if (deviceClass === "dgpu") {
				defaultDeviceIndex = i;
				return i;
			}
			deviceClassifications.push(deviceClass);
		}
		/* Search for "igpu" */
		for (var i = 0; i < availableDevices.length; ++i) {
			if (deviceClassifications[i] === "igpu") {
				defaultDeviceIndex = i;
				return i;
			}
		}
		/* Search for "cpu" */
		for (var i = 0; i < availableDevices.length; ++i) {
			if (deviceClassifications[i] === "cpu") {
				defaultDeviceIndex = i;
				return i;
			}
		}
	}
	return defaultDeviceIndex;
};

var createKernels = function(program) {
	var kernels = {
		set: {
			f32: program.createKernel("set_f32"),
			f64: program.createKernel("set_f64")
		},
		linspace: {
			f32: program.createKernel("linspace_f32"),
			f64: program.createKernel("linspace_f64")
		},
		repeat: {
			f32: program.createKernel("repeat_f32"),
			f64: program.createKernel("repeat_f64")
		},
		add: {
			f32: program.createKernel("add_f32"),
			f64: program.createKernel("add_f64")
		},
		sub: {
			f32: program.createKernel("sub_f32"),
			f64: program.createKernel("sub_f64")
		},
		mul: {
			f32: program.createKernel("mul_f32"),
			f64: program.createKernel("mul_f64")
		},
		div: {
			f32: program.createKernel("div_f32"),
			f64: program.createKernel("div_f64")
		},
		addc: {
			f32: program.createKernel("addc_f32"),
			f64: program.createKernel("addc_f64")
		},
		subc: {
			f32: program.createKernel("subc_f32"),
			f64: program.createKernel("subc_f64")
		},
		subrc: {
			f32: program.createKernel("subrc_f32"),
			f64: program.createKernel("subrc_f64")
		},
		mulc: {
			f32: program.createKernel("mulc_f32"),
			f64: program.createKernel("mulc_f64")
		},
		divc: {
			f32: program.createKernel("divc_f32"),
			f64: program.createKernel("divc_f64")
		},
		divrc: {
			f32: program.createKernel("divrc_f32"),
			f64: program.createKernel("divrc_f64")
		},
		neg: {
			f32: program.createKernel("neg_f32"),
			f64: program.createKernel("neg_f64")
		},
		abs: {
			f32: program.createKernel("abs_f32"),
			f64: program.createKernel("abs_f64")
		},
		exp: {
			f32: program.createKernel("exp_f32"),
			f64: program.createKernel("exp_f64")
		},
		log: {
			f32: program.createKernel("log_f32"),
			f64: program.createKernel("log_f64")
		},
		sqrt: {
			f32: program.createKernel("sqrt_f32"),
			f64: program.createKernel("sqrt_f64")
		},
		square: {
			f32: program.createKernel("square_f32"),
			f64: program.createKernel("square_f64")
		},
		sum: {
			f32: program.createKernel("sum_f32_gpu"),
			f64: program.createKernel("sum_f64_gpu")
		},
		min: {
			f32: program.createKernel("min_f32_gpu"),
			f64: program.createKernel("min_f64_gpu")
		},
		max: {
			f32: program.createKernel("max_f32_gpu"),
			f64: program.createKernel("max_f64_gpu")
		},
		asum: {
			f32: program.createKernel("asum_f32"),
			f64: program.createKernel("asum_f64")
		},
		amin: {
			f32: program.createKernel("amin_f32"),
			f64: program.createKernel("amin_f64")
		},
		amax: {
			f32: program.createKernel("amax_f32"),
			f64: program.createKernel("amax_f64")
		},
		dot: {
			f32: program.createKernel("dot_f32"),
			f64: program.createKernel("dot_f64")
		}
	};
	return kernels;
};

function WebCLContext(options, callback) {
	initWebCL();
	var binaryKernelsSource = "kernel void add_f32(\r\n\tuint length,\r\n\tglobal float* a,\r\n\tglobal float* b,\r\n\tglobal float* out)\r\n{\r\n\tconst uint id = get_global_id(0);\r\n\tif (id < length) {\r\n\t\tout[id] = a[id] + b[id];\r\n\t}\r\n}\r\nkernel void add_f64(\r\n\tuint length,\r\n\tglobal double* a,\r\n\tglobal double* b,\r\n\tglobal double* out)\r\n{\r\n\tconst uint id = get_global_id(0);\r\n\tif (id < length) {\r\n\t\tout[id] = a[id] + b[id];\r\n\t}\r\n}\r\nkernel void sub_f32(\r\n\tuint length,\r\n\tglobal float* a,\r\n\tglobal float* b,\r\n\tglobal float* out)\r\n{\r\n\tconst uint id = get_global_id(0);\r\n\tif (id < length) {\r\n\t\tout[id] = a[id] - b[id];\r\n\t}\r\n}\r\nkernel void sub_f64(\r\n\tuint length,\r\n\tglobal double* a,\r\n\tglobal double* b,\r\n\tglobal double* out)\r\n{\r\n\tconst uint id = get_global_id(0);\r\n\tif (id < length) {\r\n\t\tout[id] = a[id] - b[id];\r\n\t}\r\n}\r\nkernel void mul_f32(\r\n\tuint length,\r\n\tglobal float* a,\r\n\tglobal float* b,\r\n\tglobal float* out)\r\n{\r\n\tconst uint id = get_global_id(0);\r\n\tif (id < length) {\r\n\t\tout[id] = a[id] * b[id];\r\n\t}\r\n}\r\nkernel void mul_f64(\r\n\tuint length,\r\n\tglobal double* a,\r\n\tglobal double* b,\r\n\tglobal double* out)\r\n{\r\n\tconst uint id = get_global_id(0);\r\n\tif (id < length) {\r\n\t\tout[id] = a[id] * b[id];\r\n\t}\r\n}\r\nkernel void div_f32(\r\n\tuint length,\r\n\tglobal float* a,\r\n\tglobal float* b,\r\n\tglobal float* out)\r\n{\r\n\tconst uint id = get_global_id(0);\r\n\tif (id < length) {\r\n\t\tout[id] = a[id] / b[id];\r\n\t}\r\n}\r\nkernel void div_f64(\r\n\tuint length,\r\n\tglobal double* a,\r\n\tglobal double* b,\r\n\tglobal double* out)\r\n{\r\n\tconst uint id = get_global_id(0);\r\n\tif (id < length) {\r\n\t\tout[id] = a[id] / b[id];\r\n\t}\r\n}\r\nkernel void addc_f32(\r\n\tuint length,\r\n\tglobal float* a,\r\n\tfloat b,\r\n\tglobal float* out)\r\n{\r\n\tconst uint id = get_global_id(0);\r\n\tif (id < length) {\r\n\t\tout[id] = a[id] + b;\r\n\t}\r\n}\r\nkernel void addc_f64(\r\n\tuint length,\r\n\tglobal double* a,\r\n\tdouble b,\r\n\tglobal double* out)\r\n{\r\n\tconst uint id = get_global_id(0);\r\n\tif (id < length) {\r\n\t\tout[id] = a[id] + b;\r\n\t}\r\n}\r\nkernel void subc_f32(\r\n\tuint length,\r\n\tglobal float* a,\r\n\tfloat b,\r\n\tglobal float* out)\r\n{\r\n\tconst uint id = get_global_id(0);\r\n\tif (id < length) {\r\n\t\tout[id] = a[id] - b;\r\n\t}\r\n}\r\nkernel void subc_f64(\r\n\tuint length,\r\n\tglobal double* a,\r\n\tdouble b,\r\n\tglobal double* out)\r\n{\r\n\tconst uint id = get_global_id(0);\r\n\tif (id < length) {\r\n\t\tout[id] = a[id] - b;\r\n\t}\r\n}\r\nkernel void subrc_f32(\r\n\tuint length,\r\n\tglobal float* a,\r\n\tfloat b,\r\n\tglobal float* out)\r\n{\r\n\tconst uint id = get_global_id(0);\r\n\tif (id < length) {\r\n\t\tout[id] = b / a[id];\r\n\t}\r\n}\r\nkernel void subrc_f64(\r\n\tuint length,\r\n\tglobal double* a,\r\n\tdouble b,\r\n\tglobal double* out)\r\n{\r\n\tconst uint id = get_global_id(0);\r\n\tif (id < length) {\r\n\t\tout[id] = b / a[id];\r\n\t}\r\n}\r\nkernel void mulc_f32(\r\n\tuint length,\r\n\tglobal float* a,\r\n\tfloat b,\r\n\tglobal float* out)\r\n{\r\n\tconst uint id = get_global_id(0);\r\n\tif (id < length) {\r\n\t\tout[id] = a[id] * b;\r\n\t}\r\n}\r\nkernel void mulc_f64(\r\n\tuint length,\r\n\tglobal double* a,\r\n\tdouble b,\r\n\tglobal double* out)\r\n{\r\n\tconst uint id = get_global_id(0);\r\n\tif (id < length) {\r\n\t\tout[id] = a[id] * b;\r\n\t}\r\n}\r\nkernel void divc_f32(\r\n\tuint length,\r\n\tglobal float* a,\r\n\tfloat b,\r\n\tglobal float* out)\r\n{\r\n\tconst uint id = get_global_id(0);\r\n\tif (id < length) {\r\n\t\tout[id] = a[id] / b;\r\n\t}\r\n}\r\nkernel void divc_f64(\r\n\tuint length,\r\n\tglobal double* a,\r\n\tdouble b,\r\n\tglobal double* out)\r\n{\r\n\tconst uint id = get_global_id(0);\r\n\tif (id < length) {\r\n\t\tout[id] = a[id] / b;\r\n\t}\r\n}\r\nkernel void divrc_f32(\r\n\tuint length,\r\n\tglobal float* a,\r\n\tfloat b,\r\n\tglobal float* out)\r\n{\r\n\tconst uint id = get_global_id(0);\r\n\tif (id < length) {\r\n\t\tout[id] = b / a[id];\r\n\t}\r\n}\r\nkernel void divrc_f64(\r\n\tuint length,\r\n\tglobal double* a,\r\n\tdouble b,\r\n\tglobal double* out)\r\n{\r\n\tconst uint id = get_global_id(0);\r\n\tif (id < length) {\r\n\t\tout[id] = b / a[id];\r\n\t}\r\n}\r\n";
	var unaryKernelsSource = "kernel void neg_f32(\r\n\tuint length,\r\n\tglobal float* a,\r\n\tglobal float* out)\r\n{\r\n\tconst uint id = get_global_id(0);\r\n\tif (id < length) {\r\n\t\tout[id] = -a[id];\r\n\t}\r\n}\r\nkernel void neg_f64(\r\n\tuint length,\r\n\tglobal double* a,\r\n\tglobal double* out)\r\n{\r\n\tconst uint id = get_global_id(0);\r\n\tif (id < length) {\r\n\t\tout[id] = -a[id];\r\n\t}\r\n}\r\nkernel void abs_f32(\r\n\tuint length,\r\n\tglobal float* a,\r\n\tglobal float* out)\r\n{\r\n\tconst uint id = get_global_id(0);\r\n\tif (id < length) {\r\n\t\tout[id] = fabs(a[id]);\r\n\t}\r\n}\r\nkernel void abs_f64(\r\n\tuint length,\r\n\tglobal double* a,\r\n\tglobal double* out)\r\n{\r\n\tconst uint id = get_global_id(0);\r\n\tif (id < length) {\r\n\t\tout[id] = fabs(a[id]);\r\n\t}\r\n}\r\nkernel void exp_f32(\r\n\tuint length,\r\n\tglobal float* a,\r\n\tglobal float* out)\r\n{\r\n\tconst uint id = get_global_id(0);\r\n\tif (id < length) {\r\n\t\tout[id] = exp(a[id]);\r\n\t}\r\n}\r\nkernel void exp_f64(\r\n\tuint length,\r\n\tglobal double* a,\r\n\tglobal double* out)\r\n{\r\n\tconst uint id = get_global_id(0);\r\n\tif (id < length) {\r\n\t\tout[id] = exp(a[id]);\r\n\t}\r\n}\r\nkernel void log_f32(\r\n\tuint length,\r\n\tglobal float* a,\r\n\tglobal float* out)\r\n{\r\n\tconst uint id = get_global_id(0);\r\n\tif (id < length) {\r\n\t\tout[id] = log(a[id]);\r\n\t}\r\n}\r\nkernel void log_f64(\r\n\tuint length,\r\n\tglobal double* a,\r\n\tglobal double* out)\r\n{\r\n\tconst uint id = get_global_id(0);\r\n\tif (id < length) {\r\n\t\tout[id] = log(a[id]);\r\n\t}\r\n}\r\nkernel void sqrt_f32(\r\n\tuint length,\r\n\tglobal float* a,\r\n\tglobal float* out)\r\n{\r\n\tconst uint id = get_global_id(0);\r\n\tif (id < length) {\r\n\t\tout[id] = sqrt(a[id]);\r\n\t}\r\n}\r\nkernel void sqrt_f64(\r\n\tuint length,\r\n\tglobal double* a,\r\n\tglobal double* out)\r\n{\r\n\tconst uint id = get_global_id(0);\r\n\tif (id < length) {\r\n\t\tout[id] = sqrt(a[id]);\r\n\t}\r\n}\r\nkernel void square_f32(\r\n\tuint length,\r\n\tglobal float* a,\r\n\tglobal float* out)\r\n{\r\n\tconst uint id = get_global_id(0);\r\n\tif (id < length) {\r\n\t\tconst float aVal = a[id]; \r\n\t\tout[id] = aVal * aVal;\r\n\t}\r\n}\r\nkernel void square_f64(\r\n\tuint length,\r\n\tglobal double* a,\r\n\tglobal double* out)\r\n{\r\n\tconst uint id = get_global_id(0);\r\n\tif (id < length) {\r\n\t\tconst double aVal = a[id];\r\n\t\tout[id] = aVal * aVal;\r\n\t}\r\n}\r\n";
	var reductionKernelsSource = "kernel void sum_f32_gpu(\r\n\tuint length,\r\n\tglobal float* a,\r\n\tlocal float* scratch,\r\n\tglobal float* out)\r\n{\r\n\tconst uint globalSize = get_global_size(0);\r\n\tuint globalIndex = get_global_id(0);\r\n\tfloat accumulator = 0.0f;\r\n\twhile (globalIndex < length) {\r\n\t\taccumulator += a[globalIndex];\r\n\t\tglobalIndex += globalSize;\r\n\t}\r\n\r\n\tuint localIndex = get_local_id(0);\r\n\tscratch[localIndex] = accumulator;\r\n\tbarrier(CLK_LOCAL_MEM_FENCE);\r\n\tfor (uint offset = get_local_size(0) / 2; offset != 0; offset >>= 1) {\r\n\t\tif (localIndex < offset) {\r\n\t\t\tscratch[localIndex] += scratch[localIndex + offset];\r\n\t\t}\r\n\t\tbarrier(CLK_LOCAL_MEM_FENCE);\r\n\t}\r\n\tif (localIndex == 0) {\r\n\t\tout[get_group_id(0)] = scratch[0];\r\n\t}\r\n}\r\n\r\nkernel void sum_f64_gpu(\r\n\tuint length,\r\n\tglobal double* a,\r\n\tlocal double* scratch,\r\n\tglobal double* out)\r\n{\r\n\tconst uint globalSize = get_global_size(0);\r\n\tuint globalIndex = get_global_id(0);\r\n\tdouble accumulator = 0.0;\r\n\twhile (globalIndex < length) {\r\n\t\taccumulator += a[globalIndex];\r\n\t\tglobalIndex += globalSize;\r\n\t}\r\n\r\n\tuint localIndex = get_local_id(0);\r\n\tscratch[localIndex] = accumulator;\r\n\tbarrier(CLK_LOCAL_MEM_FENCE);\r\n\tfor (uint offset = get_local_size(0) / 2; offset != 0; offset >>= 1) {\r\n\t\tif (localIndex < offset) {\r\n\t\t\tscratch[localIndex] += scratch[localIndex + offset];\r\n\t\t}\r\n\t\tbarrier(CLK_LOCAL_MEM_FENCE);\r\n\t}\r\n\tif (localIndex == 0) {\r\n\t\tout[get_group_id(0)] = scratch[0];\r\n\t}\r\n}\r\n\r\nkernel void min_f32_gpu(\r\n\tuint length,\r\n\tglobal float* a,\r\n\tlocal float* scratch,\r\n\tglobal float* out)\r\n{\r\n\tconst uint globalSize = get_global_size(0);\r\n\tuint globalIndex = get_global_id(0);\r\n\tfloat accumulator = INFINITY;\r\n\twhile (globalIndex < length) {\r\n\t\taccumulator = min(accumulator, a[globalIndex]);\r\n\t\tglobalIndex += globalSize;\r\n\t}\r\n\r\n\tuint localIndex = get_local_id(0);\r\n\tscratch[localIndex] = accumulator;\r\n\tbarrier(CLK_LOCAL_MEM_FENCE);\r\n\tfor (uint offset = get_local_size(0) / 2; offset != 0; offset >>= 1) {\r\n\t\tif (localIndex < offset) {\r\n\t\t\tscratch[localIndex] = min(scratch[localIndex], scratch[localIndex + offset]);\r\n\t\t}\r\n\t\tbarrier(CLK_LOCAL_MEM_FENCE);\r\n\t}\r\n\tif (localIndex == 0) {\r\n\t\tout[get_group_id(0)] = scratch[0];\r\n\t}\r\n}\r\n\r\nkernel void min_f64_gpu(\r\n\tuint length,\r\n\tglobal double* a,\r\n\tlocal double* scratch,\r\n\tglobal double* out)\r\n{\r\n\tconst uint globalSize = get_global_size(0);\r\n\tuint globalIndex = get_global_id(0);\r\n\tdouble accumulator = INFINITY;\r\n\twhile (globalIndex < length) {\r\n\t\taccumulator = min(accumulator, a[globalIndex]);\r\n\t\tglobalIndex += globalSize;\r\n\t}\r\n\r\n\tuint localIndex = get_local_id(0);\r\n\tscratch[localIndex] = accumulator;\r\n\tbarrier(CLK_LOCAL_MEM_FENCE);\r\n\tfor (uint offset = get_local_size(0) / 2; offset != 0; offset >>= 1) {\r\n\t\tif (localIndex < offset) {\r\n\t\t\tscratch[localIndex] = min(scratch[localIndex], scratch[localIndex + offset]);\r\n\t\t}\r\n\t\tbarrier(CLK_LOCAL_MEM_FENCE);\r\n\t}\r\n\tif (localIndex == 0) {\r\n\t\tout[get_group_id(0)] = scratch[0];\r\n\t}\r\n}\r\n\r\nkernel void max_f32_gpu(\r\n\tuint length,\r\n\tglobal float* a,\r\n\tlocal float* scratch,\r\n\tglobal float* out)\r\n{\r\n\tconst uint globalSize = get_global_size(0);\r\n\tuint globalIndex = get_global_id(0);\r\n\tfloat accumulator = -INFINITY;\r\n\twhile (globalIndex < length) {\r\n\t\taccumulator = max(accumulator, a[globalIndex]);\r\n\t\tglobalIndex += globalSize;\r\n\t}\r\n\r\n\tuint localIndex = get_local_id(0);\r\n\tscratch[localIndex] = accumulator;\r\n\tbarrier(CLK_LOCAL_MEM_FENCE);\r\n\tfor (uint offset = get_local_size(0) / 2; offset != 0; offset >>= 1) {\r\n\t\tif (localIndex < offset) {\r\n\t\t\tscratch[localIndex] = max(scratch[localIndex], scratch[localIndex + offset]);\r\n\t\t}\r\n\t\tbarrier(CLK_LOCAL_MEM_FENCE);\r\n\t}\r\n\tif (localIndex == 0) {\r\n\t\tout[get_group_id(0)] = scratch[0];\r\n\t}\r\n}\r\n\r\nkernel void max_f64_gpu(\r\n\tuint length,\r\n\tglobal double* a,\r\n\tlocal double* scratch,\r\n\tglobal double* out)\r\n{\r\n\tconst uint globalSize = get_global_size(0);\r\n\tuint globalIndex = get_global_id(0);\r\n\tdouble accumulator = -INFINITY;\r\n\twhile (globalIndex < length) {\r\n\t\taccumulator = max(accumulator, a[globalIndex]);\r\n\t\tglobalIndex += globalSize;\r\n\t}\r\n\r\n\tuint localIndex = get_local_id(0);\r\n\tscratch[localIndex] = accumulator;\r\n\tbarrier(CLK_LOCAL_MEM_FENCE);\r\n\tfor (uint offset = get_local_size(0) / 2; offset != 0; offset >>= 1) {\r\n\t\tif (localIndex < offset) {\r\n\t\t\tscratch[localIndex] = max(scratch[localIndex], scratch[localIndex + offset]);\r\n\t\t}\r\n\t\tbarrier(CLK_LOCAL_MEM_FENCE);\r\n\t}\r\n\tif (localIndex == 0) {\r\n\t\tout[get_group_id(0)] = scratch[0];\r\n\t}\r\n}\r\n";
	var axisReductionKernelsSource = "kernel void asum_f32(\r\n\tuint reductionDim,\r\n\tglobal float* a,\r\n\tglobal float* out)\r\n{\r\n\tconst uint innerStride = get_global_size(1);\r\n\tconst uint i = get_global_id(0);\r\n\tconst uint k = get_global_id(1);\r\n\ta += i * reductionDim * innerStride + k;\r\n\tfloat accumulator = *a;\r\n\twhile (--reductionDim) {\r\n\t\ta += innerStride;\r\n\t\taccumulator += *a;\r\n\t}\r\n\tout[i * innerStride + k] = accumulator;\r\n}\r\n\r\nkernel void asum_f64(\r\n\tuint reductionDim,\r\n\tglobal double* a,\r\n\tglobal double* out)\r\n{\r\n\tconst uint innerStride = get_global_size(1);\r\n\tconst uint i = get_global_id(0);\r\n\tconst uint k = get_global_id(1);\r\n\ta += i * reductionDim * innerStride + k;\r\n\tdouble accumulator = *a;\r\n\twhile (--reductionDim) {\r\n\t\ta += innerStride;\r\n\t\taccumulator += *a;\r\n\t}\r\n\tout[i * innerStride + k] = accumulator;\r\n}\r\n\r\nkernel void amin_f32(\r\n\tuint reductionDim,\r\n\tglobal float* a,\r\n\tglobal float* out)\r\n{\r\n\tconst uint innerStride = get_global_size(1);\r\n\tconst uint i = get_global_id(0);\r\n\tconst uint k = get_global_id(1);\r\n\ta += i * reductionDim * innerStride + k;\r\n\tfloat accumulator = *a;\r\n\twhile (--reductionDim) {\r\n\t\ta += innerStride;\r\n\t\taccumulator = min(accumulator, *a);\r\n\t}\r\n\tout[i * innerStride + k] = accumulator;\r\n}\r\n\r\nkernel void amin_f64(\r\n\tuint reductionDim,\r\n\tglobal double* a,\r\n\tglobal double* out)\r\n{\r\n\tconst uint innerStride = get_global_size(1);\r\n\tconst uint i = get_global_id(0);\r\n\tconst uint k = get_global_id(1);\r\n\ta += i * reductionDim * innerStride + k;\r\n\tdouble accumulator = *a;\r\n\twhile (--reductionDim) {\r\n\t\ta += innerStride;\r\n\t\taccumulator = min(accumulator, *a);\r\n\t}\r\n\tout[i * innerStride + k] = accumulator;\r\n}\r\n\r\nkernel void amax_f32(\r\n\tuint reductionDim,\r\n\tglobal float* a,\r\n\tglobal float* out)\r\n{\r\n\tconst uint innerStride = get_global_size(1);\r\n\tconst uint i = get_global_id(0);\r\n\tconst uint k = get_global_id(1);\r\n\ta += i * reductionDim * innerStride + k;\r\n\tfloat accumulator = *a;\r\n\twhile (--reductionDim) {\r\n\t\ta += innerStride;\r\n\t\taccumulator = max(accumulator, *a);\r\n\t}\r\n\tout[i * innerStride + k] = accumulator;\r\n}\r\n\r\nkernel void amax_f64(\r\n\tuint reductionDim,\r\n\tglobal double* a,\r\n\tglobal double* out)\r\n{\r\n\tconst uint innerStride = get_global_size(1);\r\n\tconst uint i = get_global_id(0);\r\n\tconst uint k = get_global_id(1);\r\n\ta += i * reductionDim * innerStride + k;\r\n\tdouble accumulator = *a;\r\n\twhile (--reductionDim) {\r\n\t\ta += innerStride;\r\n\t\taccumulator = max(accumulator, *a);\r\n\t}\r\n\tout[i * innerStride + k] = accumulator;\r\n}\r\n";
	var productKernelsSource = "kernel void dot_f32(\r\n\tuint reductionDim,\r\n\tglobal float* a,\r\n\tglobal float* b,\r\n\tglobal float* out)\r\n{\r\n\tconst uint i = get_global_id(0);\r\n\tconst uint k = get_global_id(1);\r\n\tconst uint l = get_global_id(2);\r\n\tconst uint outerStrideB = get_global_size(1);\r\n\tconst uint innerStrideB = get_global_size(2);\r\n\r\n\tfloat accumulator = 0.0f;\r\n\tfor (uint j = 0; j < reductionDim; ++j) {\r\n\t\taccumulator += a[i*reductionDim+j] * b[(k*reductionDim+j)*innerStrideB+l];\r\n\t}\r\n\tout[(i*outerStrideB + k) * innerStrideB + l] = accumulator;\r\n}\r\n\r\nkernel void dot_f64(\r\n\tuint reductionDim,\r\n\tglobal double* a,\r\n\tglobal double* b,\r\n\tglobal double* out)\r\n{\r\n\tconst uint i = get_global_id(0);\r\n\tconst uint k = get_global_id(1);\r\n\tconst uint l = get_global_id(2);\r\n\tconst uint outerStrideB = get_global_size(1);\r\n\tconst uint innerStrideB = get_global_size(2);\r\n\r\n\tdouble accumulator = 0.0;\r\n\tfor (uint j = 0; j < reductionDim; ++j) {\r\n\t\taccumulator += a[i*reductionDim+j] * b[(k*reductionDim+j)*innerStrideB+l];\r\n\t}\r\n\tout[(i*outerStrideB + k) * innerStrideB + l] = accumulator;\r\n}\r\n";
	var utilKernelsSource = "kernel void set_f32(\r\n\tuint length,\r\n\tglobal float* out,\r\n\tfloat value)\r\n{\r\n\tconst uint id = get_global_id(0);\r\n\tif (id < length) {\r\n\t\tout[id] = value;\r\n\t}\r\n}\r\nkernel void set_f64(\r\n\tuint length,\r\n\tglobal double* out,\r\n\tdouble value)\r\n{\r\n\tconst uint id = get_global_id(0);\r\n\tif (id < length) {\r\n\t\tout[id] = value;\r\n\t}\r\n}\r\n\r\nkernel void linspace_f32(\r\n\tuint length,\r\n\tglobal float* out,\r\n\tfloat start,\r\n\tfloat step)\r\n{\r\n\tconst uint id = get_global_id(0);\r\n\tif (id < length) {\r\n\t\tout[id] = start + step * ((float) id);\r\n\t}\r\n}\r\nkernel void linspace_f64(\r\n\tuint length,\r\n\tglobal double* out,\r\n\tdouble start,\r\n\tdouble step)\r\n{\r\n\tconst uint id = get_global_id(0);\r\n\tif (id < length) {\r\n\t\tout[id] = start + step * ((double) id);\r\n\t}\r\n}\r\n\r\nkernel void repeat_f32(\r\n\tuint expansionDim,\r\n\tuint innerStride,\r\n\tuint repeats,\r\n\tglobal float *restrict a,\r\n\tglobal float *restrict out)\r\n{\r\n\tconst uint i = get_global_id(0);\r\n\tconst uint j = get_global_id(1);\r\n\tconst uint k = get_global_id(2);\r\n\tconst float value = a[(i * expansionDim + j) * innerStride + k];\r\n\tuint offsetOut = (i * expansionDim + j) * repeats * innerStride + k;\r\n\tfor (uint c = 0; c < repeats; ++c) {\r\n\t\tout[offsetOut] = value;\r\n\t\toffsetOut += innerStride;\r\n\t}\r\n}\r\nkernel void repeat_f64(\r\n\tuint expansionDim,\r\n\tuint innerStride,\r\n\tuint repeats,\r\n\tglobal double *restrict a,\r\n\tglobal double *restrict out)\r\n{\r\n\tconst uint i = get_global_id(0);\r\n\tconst uint j = get_global_id(1);\r\n\tconst uint k = get_global_id(2);\r\n\tconst double value = a[(i * expansionDim + j) * innerStride + k];\r\n\tuint offsetOut = (i * expansionDim + j) * repeats * innerStride + k;\r\n\tfor (uint c = 0; c < repeats; ++c) {\r\n\t\tout[offsetOut] = value;\r\n\t\toffsetOut += innerStride;\r\n\t}\r\n}\r\n";
	var source = binaryKernelsSource + unaryKernelsSource + 
		reductionKernelsSource + axisReductionKernelsSource + 
		productKernelsSource + utilKernelsSource;

	var asyncCallbacks = options.asyncCallbacks;
	if (typeof asyncCallbacks === "undefined") {
		/* Currently only Node-WebCL supports asynchronous callbacks */
		this.asyncCallbacks = isNodeWebCL;
	} else {
		this.asyncCallbacks = !!asyncCallbacks;
	}
	var deviceName = options.device;
	if (deviceName) {
		var deviceIndex = availableDevicesDescriptions.indexOf(deviceName);
		if (deviceIndex === -1) {
			throw new Error("Invalid WebCL device name: " + deviceName);
		}
		this.device = availableDevices[deviceIndex];
	} else {
		var deviceIndex = getDefaultDeviceIndex();
		if (deviceIndex < 0) {
			throw new Error("No suitable WebCL device found");
		}
		this.device = availableDevices[deviceIndex];
	}
	this.device.enableExtension("KHR_fp64");
	this.deviceInfo = {
		deviceClass: classifyDevice(this.device),
		localMemorySize: this.device.getInfo(cl.DEVICE_LOCAL_MEM_SIZE),
		maxComputeUnits: this.device.getInfo(cl.DEVICE_MAX_COMPUTE_UNITS),
		maxWorkGroupSize: this.device.getInfo(cl.DEVICE_MAX_WORK_GROUP_SIZE),
		maxWorkItemSizes: this.device.getInfo(cl.DEVICE_MAX_WORK_ITEM_SIZES)
	};
	this.context = cl.createContext(this.device);
	this.queue = this.context.createCommandQueue(this.device);
	this.program = this.context.createProgram(source);
	try {
		/* Chromium-WebCL requires a list of devices */
		this.program.build([this.device]);
	} catch (e) {
		if (e.name === "INVALID_DEVICE") {
			/* Nokia-WebCL only works with no arguments to WebCLProgram.build */
			this.program.build();
		} else {
			throw e;
		}
	}
	this.kernels = createKernels(this.program);
	/* Context is ready for computations */
	callback(this);
}

/**
 * Returns the names of devices that can be used for computation.
 * Any of these names can be passed as a "device" option when creating a WebCL context.
 *
 * @static
 * @method getAvailableDevices
 * @return {String[]} - a possibly empty list of available device names.
 */
WebCLContext.getAvailableDevices = function() {
	if (WebCLContext.isUsable()) {
		return availableDevicesDescriptions;
	} else {
		return [];
	}
};

/**
 * Returns the name of the default device used for computation.
 *
 * @static
 * @method getDefaultDevice
 * @return {String} - the name of the default WebCL device or null if no suitable device available.
 */
WebCLContext.getDefaultDevice = function() {
	var deviceIndex = getDefaultDeviceIndex();
	if (deviceIndex < 0) {
		return null;
	} else {
		return availableDevicesDescriptions[deviceIndex];
	}
};

/**
 * Checks if WebCL is supported by the environment.
 *
 * @static
 * @method isSupported
 * @return {Boolean} - true if WebCL is supported on this system and false otherwise.
 */
WebCLContext.isSupported = function() {
	return initWebCL() !== null;
};

/**
 * Checks if WebCL can be used for computation.
 * WebCL is usable for computations if it is supported by JS engine (or Node.js) and there is at least one CPU or GPU device with KHR_fp64 extension.
 *
 * @static
 * @method isUsable
 * @return {Boolean} - true if WebCL is usable on this system and false otherwise.
 */
WebCLContext.isUsable = function() {
	var webcl = initWebCL();
	if (webcl === null) {
		return false;
	}
	var availableDevices = getAvailableDevices();
	return availableDevices.length !== 0;
};

WebCLContext.prototype.empty = function(shape, dataType) {
	shape = util.checkShape(shape);
	if (typeof dataType === "undefined") {
		dataType = new DataType("f64");
	} else if (!(dataType instanceof DataType)) {
		throw new TypeError(dataType + " is not an instance of DataType");
	}
	var array = new NDArray(shape, dataType, this);
	array._buffer = this.context.createBuffer(cl.MEM_READ_WRITE, array.length * dataType.size);
	return array;
};

WebCLContext.prototype.zeros = function(shape, dataType) {
	shape = util.checkShape(shape);
	if (typeof dataType === "undefined") {
		dataType = new DataType("f64");
	} else if (!(dataType instanceof DataType)) {
		throw new TypeError(dataType + " is not an instance of DataType");
	}
	var array = new NDArray(shape, dataType, this);
	array._buffer = this.context.createBuffer(cl.MEM_READ_WRITE, array.length * dataType.size);
	var kernel = this.kernels.set[dataType.type];
	kernel.setArg(0, new Uint32Array([array.length]));
	kernel.setArg(1, array._buffer);
	kernel.setArg(2, new dataType.arrayType([0.0]));
	this.queue.enqueueNDRangeKernel(kernel, 1, null, [array.length]);
	return array;
};

WebCLContext.prototype.ones = function(shape, dataType) {
	shape = util.checkShape(shape);
	if (typeof dataType === "undefined") {
		dataType = new DataType("f64");
	} else if (!(dataType instanceof DataType)) {
		throw new TypeError(dataType + " is not an instance of DataType");
	}
	var array = new NDArray(shape, dataType, this);
	array._buffer = this.context.createBuffer(cl.MEM_READ_WRITE, array.length * dataType.size);
	var kernel = this.kernels.set[dataType.type];
	kernel.setArg(0, new Uint32Array([array.length]));
	kernel.setArg(1, array._buffer);
	kernel.setArg(2, new dataType.arrayType([1.0]));
	this.queue.enqueueNDRangeKernel(kernel, 1, null, [array.length]);
	return array;
};

WebCLContext.prototype.array = function(data, dataType) {
	if (typeof dataType === "undefined") {
		dataType = new DataType("f64");
	} else {
		dataType = util.checkDataType(dataType);
	}
	var shape = [];
	util.discoverArrayShapeRecursive(data, shape, 0);
	var array = new NDArray(shape, dataType, this);
	var buffer = new dataType.arrayType(array.length);
	util.copyArrayDataRecursive(buffer, data, shape, 0, 0);
	if (useBufferCreationWithInit) {
		array._buffer = this.context.createBuffer(cl.MEM_READ_WRITE, buffer.byteLength, buffer);
	} else {
		array._buffer = this.context.createBuffer(cl.MEM_READ_WRITE, buffer.byteLength);
		this.queue.enqueueWriteBuffer(array._buffer, false, 0, buffer.byteLength, buffer);
	}
	return array;
};

WebCLContext.prototype.linspace = function(start, stop, samples, closed) {
	if (!util.isReal(start)) {
		throw new TypeError(start + " is not a real number");
	}
	if (!util.isReal(stop)) {
		throw new TypeError(stop + " is not a real number");
	}
	if (typeof samples === "undefined") {
		/* Default value in NumPy */
		samples = 50;
	} else if (!util.isInt(samples)) {
		throw new TypeError(samples + " is not an integer");
	} else if (samples <= 0) {
		throw new RangeError("The number of samples must be positive");
	}
	if (typeof closed === "undefined") {
		closed = true;
	}
	if (closed && (samples === 1)) {
		throw new RangeError("The number of samples must be a least 2 (for start and end points)");
	}

	var dataType = new DataType("f64");
	var array = new NDArray(samples, dataType, this);
	array._buffer = this.context.createBuffer(cl.MEM_READ_WRITE, samples * dataType.size);

	var range = stop - start;
	var n = (closed) ? samples - 1 : samples;
	var step = range / n;

	var kernel = this.kernels.linspace[dataType.type];
	kernel.setArg(0, new Uint32Array([array.length]));
	kernel.setArg(1, array._buffer);
	kernel.setArg(2, new dataType.arrayType([start]));
	kernel.setArg(3, new dataType.arrayType([step]));
	this.queue.enqueueNDRangeKernel(kernel, 1, null, [array.length]);

	return array;
};

WebCLContext.prototype._invalidate = function(array) {
	if (array._buffer !== null) {
		/* Work-around for Chromium-WebCL that currently lacks WebCLMemObject.release method */
		if (typeof array._buffer.release !== "undefined") {
			array._buffer.release();
		}
		array._buffer = null;
	}
};

WebCLContext.prototype.fetch = function() {
	if (arguments.length === 0) {
		throw new Error("Callback argument missing");
	}
	var callback = arguments[arguments.length - 1];
	/* Validate arguments */
	if (arguments.length === 1) {
		throw new Error("At least one NDArray argument expected");
	}
	for (var i = 0; i < arguments.length - 1; i++) {
		if (!(arguments[i] instanceof NDArray)) {
			throw new TypeError("Argument " + i + " is not an NDArray");
		}
	}
	var callbackWaitArguments = arguments.length - 1;
	var callbackArguments = new Array(callbackWaitArguments);
	if (this.asyncCallbacks) {
		var asyncEvents = [];
		for (var i = 0; i < callbackWaitArguments; i++) {
			var array = arguments[i];
			(function(queue, i, shape, ArrayType) {
				var buffer = new ArrayType(array.length);
				var readFinishEvent = createEvent();
				asyncEvents.push(readFinishEvent);
				queue.enqueueReadBuffer(array._buffer, false, 0, buffer.byteLength, buffer, null, readFinishEvent);
				readFinishEvent.setCallback(cl.COMPLETE, function() {
					readFinishEvent.release();
					callbackArguments[i] = buffer;
					if (--callbackWaitArguments === 0) {
						callback.apply(null, callbackArguments);
						/* OpenCL standard: commands enqueued in a callback won't start until clFlush */
						queue.flush();
					}
				});
			})(this.queue, i, array.shape, array.dataType.arrayType);
			/* This line mostly serializes execution. Unfortunately, without it nothing works */
			cl.waitForEvents(asyncEvents);
		}
	} else {
		for (var i = 0; i < callbackWaitArguments; i++) {
			var array = arguments[i];
			var buffer = new array.dataType.arrayType(array.length);
			this.queue.enqueueReadBuffer(array._buffer, true, 0, buffer.byteLength, buffer);
			callbackArguments[i] = buffer;
		}
		callback.apply(null, callbackArguments);
	}
};

WebCLContext.prototype.get = function() {
	if (arguments.length === 0) {
		throw new Error("Callback argument missing");
	}
	var callback = arguments[arguments.length - 1];
	/* Validate arguments */
	if (arguments.length === 1) {
		throw new Error("At least one NDArray argument expected");
	}
	for (var i = 0; i < arguments.length - 1; i++) {
		if (!(arguments[i] instanceof NDArray)) {
			throw new TypeError("Argument " + i + " is not an NDArray");
		}
	}
	var callbackWaitArguments = arguments.length - 1;
	var callbackArguments = new Array(callbackWaitArguments);
	if (this.asyncCallbacks) {
		var asyncEvents = [];
		for (var i = 0; i < callbackWaitArguments; i++) {
			var array = arguments[i];
			(function(queue, i, shape, ArrayType) {
				var buffer = new ArrayType(array.length);
				var readFinishEvent = createEvent();
				asyncEvents.push(readFinishEvent);
				queue.enqueueReadBuffer(array._buffer, false, 0, buffer.byteLength, buffer, null, readFinishEvent);
				if (shape.length === 0) {
					readFinishEvent.setCallback(cl.COMPLETE, function() {
						readFinishEvent.release();
						callbackArguments[i] = buffer[0];
						if (--callbackWaitArguments === 0) {
							callback.apply(null, callbackArguments);
							/* OpenCL standard: commands enqueued in a callback won't start until clFlush */
							queue.flush();
						}
					});
				} else {
					readFinishEvent.setCallback(cl.COMPLETE, function() {
						readFinishEvent.release();
						var jsarray = new Array(shape[0]);
						util.createArrayRecursive(new ArrayType(buffer), jsarray, shape, 0, 0);
						callbackArguments[i] = jsarray;
						if (--callbackWaitArguments === 0) {
							callback.apply(null, callbackArguments);
							/* OpenCL standard: commands enqueued in a callback won't start until clFlush */
							queue.flush();
						}
					});
				}
			})(this.queue, i, array.shape, array.dataType.arrayType);
			/* This line mostly serializes execution. Unfortunately, without it nothing works */
			cl.waitForEvents(asyncEvents);
		}
	} else {
		for (var i = 0; i < callbackWaitArguments; i++) {
			var array = arguments[i];
			var buffer = new array.dataType.arrayType(array.length);
			this.queue.enqueueReadBuffer(array._buffer, true, 0, buffer.byteLength, buffer);
			if (array.shape.length === 0) {
				callbackArguments[i] = buffer[0];
			} else {
				var jsarray = new Array(array.shape[0]);
				util.createArrayRecursive(new array.dataType.arrayType(buffer), jsarray, array.shape, 0, 0);
				callbackArguments[i] = jsarray;
			}
		}
		callback.apply(null, callbackArguments);
	}
};

WebCLContext.prototype.barrier = function(callback) {
	var barrierEvent = createEvent();
	this.queue.enqueueMarker(barrierEvent);
	if (this.asyncCallbacks) {
		var queue = this.queue;
		barrierEvent.setCallback(cl.COMPLETE, function() {
			barrierEvent.release();
			callback();
			/* OpenCL standard: commands enqueued in a callback won't start until clFlush */
			queue.flush();
		});
		cl.waitForEvents([barrierEvent]);
	} else {
		cl.waitForEvents([barrierEvent]);
		callback();
	}
};

WebCLContext.prototype.reshape = function(a, shape) {
	shape = util.checkShape(shape);
	if (util.computeLength(shape) !== a.length) {
		throw new RangeError("The shape is not compatible with the array");
	}
	var out = new NDArray(shape, a.dataType, this);
	if (a._decRef()) {
		out._buffer = this.context.createBuffer(webcl.MEM_READ_WRITE, out.length * out.dataType.size);
		this.queue.enqueueCopyBuffer(a._buffer, out._buffer, 0, 0, out.length * out.dataType.size);
	} else {
		out._buffer = a._buffer;
		a._buffer = null;
	}
	return out;
};

WebCLContext.prototype.repeat = function(a, repeats, axis, out) {
	util.checkNDArray(a, "a");
	repeats = util.checkRepeats(repeats);
	axis = util.checkAxis(axis, a.shape.length);
	var shapeA = a.shape;
	var shapeOut = shapeA.slice(0);
	shapeOut[axis] *= repeats;
	a._decRef();
	try {
		if (typeof out === "undefined") {
			out = new NDArray(shapeOut, a.dataType, this);
			out._buffer = this.context.createBuffer(cl.MEM_READ_WRITE, out.length * out.dataType.size);
		} else {
			util.checkNDArray(out, "out");
			util.checkShapesCompatibility(out.shape, shapeOut);
			util.checkDataTypesCompatibility(a.dataType, out.dataType);
			out._incRef();
		}
		var outerStride = util.computeOuterStride(shapeA, axis);
		var expansionDim = shapeA[axis];
		var innerStride = util.computeInnerStride(shapeA, axis);
		var kernel = this.kernels.repeat[a.dataType.type];
		kernel.setArg(0, new Uint32Array([expansionDim]));
		kernel.setArg(1, new Uint32Array([innerStride]));
		kernel.setArg(2, new Uint32Array([repeats]));
		kernel.setArg(3, a._buffer);
		kernel.setArg(4, out._buffer);
		this.queue.enqueueNDRangeKernel(kernel, 3, null, [outerStride, expansionDim, innerStride]);
	} catch (e) {
		a._incRef();
		throw e;
	}
	a._tryInvalidate();
	return out;
};

var binaryArithOp = function(a, b, out, furiousContext, binaryOpKernels, binaryConstOpKernels, binaryRevConstKernels) {
	var shapeOut = null, dataTypeOut = null;
	var bufferA = null, bufferB = null;
	if (a instanceof NDArray) {
		bufferA = a._buffer;
		shapeOut = a.shape;
		dataTypeOut = a.dataType;
		if (b instanceof NDArray) {
			bufferB = b._buffer;
			util.checkShapesCompatibility(a.shape, b.shape);
			util.checkDataTypesCompatibility(a.dataType, b.dataType);
		} else if (!util.isNumber(b)) {
			throw new TypeError("Unsupported type of b");
		}
	} else if (util.isNumber(a)) {
		util.checkNDArray(b, "b");
		bufferB = b._buffer;
		shapeOut = b.shape;
		dataTypeOut = b.dataType;
	} else {
		throw new TypeError("Unsupported type of a");
	}
	if (a instanceof NDArray) {
		a._decRef();
	}
	if (b instanceof NDArray) {
		b._decRef();
	}
	try {
		if (typeof out === "undefined") {
			out = new NDArray(shapeOut, dataTypeOut, furiousContext);
			if ((a instanceof NDArray) && !a._hasRefs()) {
				out._buffer = a._buffer;
				a._buffer = null;
			} else if ((b instanceof NDArray) && !b._hasRefs()) {
				out._buffer = b._buffer;
				b._buffer = null;
			} else {
				out._buffer = furiousContext.context.createBuffer(cl.MEM_READ_WRITE, out.length * out.dataType.size);
			}
		} else {
			util.checkNDArray(out, "out");
			util.checkShapesCompatibility(shapeOut, out.shape);
			util.checkDataTypesCompatibility(dataTypeOut, out.dataType);
			out._incRef();
		}
		if (a instanceof NDArray) {
			if (b instanceof NDArray) {
				var kernel = binaryOpKernels[dataTypeOut.type];
				kernel.setArg(0, new Uint32Array([out.length]));
				kernel.setArg(1, bufferA);
				kernel.setArg(2, bufferB);
				kernel.setArg(3, out._buffer);
				furiousContext.queue.enqueueNDRangeKernel(kernel, 1, null, [out.length]);
			} else {
				var kernel = binaryConstOpKernels[dataTypeOut.type];
				kernel.setArg(0, new Uint32Array([out.length]));
				kernel.setArg(1, bufferA);
				kernel.setArg(2, new dataTypeOut.arrayType([b]));
				kernel.setArg(3, out._buffer);
				furiousContext.queue.enqueueNDRangeKernel(kernel, 1, null, [out.length]);
			}
		} else {
			var kernel = binaryRevConstKernels[dataTypeOut.type];
			kernel.setArg(0, new Uint32Array([out.length]));
			kernel.setArg(1, bufferB);
			kernel.setArg(2, new dataTypeOut.arrayType([a]));
			kernel.setArg(3, out._buffer);
			furiousContext.queue.enqueueNDRangeKernel(kernel, 1, null, [out.length]);
		}
	} catch (e) {
		/* Restore the previous state */
		if (a instanceof NDArray) {
			a._incRef();
		}
		if (b instanceof NDArray) {
			b._incRef();
		}
		throw e;
	}
	if (a instanceof NDArray) {
		a._tryInvalidate();
	}
	if (b instanceof NDArray) {
		b._tryInvalidate();
	}
	return out;
};

var unaryArithOp = function(a, out, furiousContext, unaryOpKernels) {
	util.checkNDArray(a, "a");
	a._decRef();
	var bufferA = a._buffer;
	try {
		if (typeof out === "undefined") {
			out = new NDArray(a.shape, a.dataType, furiousContext);
			if ((a instanceof NDArray) && !a._hasRefs()) {
				out._buffer = a._buffer;
				a._buffer = null;
			} else {
				out._buffer = furiousContext.context.createBuffer(cl.MEM_READ_WRITE, out.length * out.dataType.size);
			}
		} else {
			util.checkNDArray(out, "out");
			util.checkShapesCompatibility(a.shape, out.shape);
			util.checkDataTypesCompatibility(a.dataType, out.dataType);
			out._incRef();
		}
		var kernel = unaryOpKernels[a.dataType.type];
		kernel.setArg(0, new Uint32Array([out.length]));
		kernel.setArg(1, bufferA);
		kernel.setArg(2, out._buffer);
		furiousContext.queue.enqueueNDRangeKernel(kernel, 1, null, [out.length]);
	} catch (e) {
		/* Restore the previous state */
		a._incRef();
		throw e;
	}
	a._tryInvalidate();
	return out;
};

var axisReduceOp = function(a, axis, out, furiousContext, reduceKernels, axisReduceKernels) {
	util.checkNDArray(a, "a");
	if (typeof axis === "undefined") {
		if (typeof out === "undefined") {
			out = new NDArray([], a.dataType, furiousContext);
			out._buffer = furiousContext.context.createBuffer(cl.MEM_READ_WRITE, a.dataType.size);
		} else {
			util.checkNDArray(out, "out");
			util.checkShapesCompatibility([], out.shape);
			util.checkDataTypesCompatibility(a.dataType, out.dataType);
			out._incRef();
		}
		var lengthA = a.length;
		var maxWorkItemsPerCU = Math.min(
			Math.min(furiousContext.deviceInfo.maxWorkGroupSize,
				furiousContext.deviceInfo.maxWorkItemSizes[0]), 
			furiousContext.deviceInfo.localMemorySize / a.dataType.size);
		/* The minimal ammount of parallelism that justifies switching to two-pass reduction */
		var parallelisationThreshold = 16;
		var kernel = reduceKernels[a.dataType.type];
		if (lengthA < maxWorkItemsPerCU * parallelisationThreshold) {
			/* One reduction is enough */
			kernel.setArg(0, new Uint32Array([lengthA]));
			kernel.setArg(1, a._buffer);
			kernel.setArg(2, new Uint32Array([maxWorkItemsPerCU * a.dataType.size]));
			kernel.setArg(3, out._buffer);
			/* Important: use only one work group */
			furiousContext.queue.enqueueNDRangeKernel(kernel, 1, null, [maxWorkItemsPerCU], [maxWorkItemsPerCU]);
		} else {
			/* Two-step reduction */
			var maxComputeUnits = furiousContext.deviceInfo.maxComputeUnits;
			var workGroupSizeMultiple = kernel.getWorkGroupInfo(furiousContext.device, cl.KERNEL_PREFERRED_WORK_GROUP_SIZE_MULTIPLE);
			var tempBuffer = furiousContext.context.createBuffer(cl.MEM_READ_WRITE, maxComputeUnits * a.dataType.size);

			kernel.setArg(0, new Uint32Array([lengthA]));
			kernel.setArg(1, a._buffer);
			kernel.setArg(2, new Uint32Array([maxWorkItemsPerCU * a.dataType.size]));
			kernel.setArg(3, tempBuffer);
			furiousContext.queue.enqueueNDRangeKernel(kernel, 1, null,
				[maxWorkItemsPerCU * maxComputeUnits],
				[maxWorkItemsPerCU]);

			var workGroupSize = Math.min(maxWorkItemsPerCU,
				util.roundUp(maxComputeUnits, workGroupSizeMultiple));
			kernel.setArg(0, new Uint32Array([maxComputeUnits]));
			kernel.setArg(1, tempBuffer);
			kernel.setArg(2, new Uint32Array([workGroupSize * a.dataType.size]));
			kernel.setArg(3, out._buffer);
			/* Important: use only one work group */
			furiousContext.queue.enqueueNDRangeKernel(kernel, 1, null,
				[workGroupSize],
				[workGroupSize]);

			tempBuffer.release();
		}
		a._tryRelease();
		return out;
	} else {
		axis = util.checkAxis(axis, a.shape.length);
		var shapeOut = util.computeAxisReductionOutShape(a.shape, axis);
		if (typeof out === "undefined") {
			out = new NDArray(shapeOut, a.dataType, furiousContext);
			out._buffer = furiousContext.context.createBuffer(cl.MEM_READ_WRITE, a.dataType.size * out.length);
		} else {
			util.checkNDArray(out, "out");
			util.checkShapesCompatibility([], out.shape);
			util.checkDataTypesCompatibility(a.dataType, out.dataType);
			out._incRef();
		}
		var outerStride = util.computeOuterStride(a.shape, axis);
		var reductionDim = a.shape[axis];
		var innerStride = util.computeInnerStride(a.shape, axis);
		var kernel = axisReduceKernels[a.dataType.type];
		kernel.setArg(0, new Uint32Array([reductionDim]));
		kernel.setArg(1, a._buffer);
		kernel.setArg(2, out._buffer);
		furiousContext.queue.enqueueNDRangeKernel(kernel, 2, null,
			[outerStride, innerStride]);
		a._tryRelease();
		return out;
	}
};


WebCLContext.prototype.add = function(a, b, out) {
	return binaryArithOp(a, b, out, this, this.kernels.add, this.kernels.addc, this.kernels.addc);
};

WebCLContext.prototype.sub = function(a, b, out) {
	return binaryArithOp(a, b, out, this, this.kernels.sub, this.kernels.subc, this.kernels.subrc);
};

WebCLContext.prototype.mul = function(a, b, out) {
	return binaryArithOp(a, b, out, this, this.kernels.mul, this.kernels.mulc, this.kernels.mulc);
};

WebCLContext.prototype.div = function(a, b, out) {
	return binaryArithOp(a, b, out, this, this.kernels.div, this.kernels.divc, this.kernels.divrc);
};

WebCLContext.prototype.neg = function(a, out) {
	return unaryArithOp(a, out, this, this.kernels.neg);
};

WebCLContext.prototype.abs = function(a, out) {
	return unaryArithOp(a, out, this, this.kernels.abs);
};

WebCLContext.prototype.exp = function(a, out) {
	return unaryArithOp(a, out, this, this.kernels.exp);
};

WebCLContext.prototype.log = function(a, out) {
	return unaryArithOp(a, out, this, this.kernels.log);
};

WebCLContext.prototype.sqrt = function(a, out) {
	return unaryArithOp(a, out, this, this.kernels.sqrt);
};

WebCLContext.prototype.square = function(a, out) {
	return unaryArithOp(a, out, this, this.kernels.square);
};

WebCLContext.prototype.min = function(a, axis, out) {
	return axisReduceOp(a, axis, out, this, this.kernels.min, this.kernels.amin);
};

WebCLContext.prototype.max = function(a, axis, out) {
	return axisReduceOp(a, axis, out, this, this.kernels.max, this.kernels.amax);
};

WebCLContext.prototype.sum = function(a, axis, out) {
	return axisReduceOp(a, axis, out, this, this.kernels.sum, this.kernels.asum);
};

WebCLContext.prototype.dot = function(a, b, out) {
	util.checkNDArray(a, "a");
	util.checkNDArray(b, "b");
	util.checkDataTypesCompatibility(a.dataType, b.dataType);

	/* The axis of b used in reduction: axis 0 for 1D array, second-to-last axis for ND array */
	var aAxis = Math.max(a.shape.length - 1, 0);
	var bAxis = Math.max(b.shape.length - 2, 0);
	var reductionDim = a.shape[aAxis];
	if (reductionDim !== b.shape[bAxis]) {
		throw new RangeError("Arrays have incompatible reduction dimensions");
	}
	var shapeOut = [], strideA = 1, outerStrideB = 1, innerStrideB = 1;
	for (var i = 0; i < aAxis; i++) {
		shapeOut.push(a.shape[i]);
		strideA *= a.shape[i];
	}
	for (var i = 0; i < b.shape.length; i++) {
		var dim = b.shape[i];
		if (i < bAxis) {
			outerStrideB *= dim;
			shapeOut.push(dim);
		} else if (i > bAxis) {
			innerStrideB *= dim;
			shapeOut.push(dim);
		}
	}
	if (typeof out === "undefined") {
		out = this.empty(shapeOut, a.dataType);
	} else if (out instanceof NDArray) {
		util.checkNDArray(out, "out");
		util.checkShapesCompatibility(out.shape, shapeOut);
		util.checkDataTypesCompatibility(out.dataType, a.dataType);
		util.checkDifferentNDArrays(a, out, "a", "out");
		util.checkDifferentNDArrays(b, out, "b", "out");
		out._incRef();
	}
	var kernel = this.kernels.dot[out.dataType.type];
	kernel.setArg(0, new Uint32Array([reductionDim]));
	kernel.setArg(1, a._buffer);
	kernel.setArg(2, b._buffer);
	kernel.setArg(3, out._buffer);
	this.queue.enqueueNDRangeKernel(kernel, 3, null,
		[strideA, outerStrideB, innerStrideB]);
	a._tryRelease();
	b._tryRelease();
	return out;
};

module.exports = WebCLContext;

},{"../DataType":1,"../NDArray":2,"../util":12}],14:[function(require,module,exports){
module.exports = require('./lib/chai');

},{"./lib/chai":15}],15:[function(require,module,exports){
/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

var used = []
  , exports = module.exports = {};

/*!
 * Chai version
 */

exports.version = '1.9.1';

/*!
 * Assertion Error
 */

exports.AssertionError = require('assertion-error');

/*!
 * Utils for plugins (not exported)
 */

var util = require('./chai/utils');

/**
 * # .use(function)
 *
 * Provides a way to extend the internals of Chai
 *
 * @param {Function}
 * @returns {this} for chaining
 * @api public
 */

exports.use = function (fn) {
  if (!~used.indexOf(fn)) {
    fn(this, util);
    used.push(fn);
  }

  return this;
};

/*!
 * Configuration
 */

var config = require('./chai/config');
exports.config = config;

/*!
 * Primary `Assertion` prototype
 */

var assertion = require('./chai/assertion');
exports.use(assertion);

/*!
 * Core Assertions
 */

var core = require('./chai/core/assertions');
exports.use(core);

/*!
 * Expect interface
 */

var expect = require('./chai/interface/expect');
exports.use(expect);

/*!
 * Should interface
 */

var should = require('./chai/interface/should');
exports.use(should);

/*!
 * Assert interface
 */

var assert = require('./chai/interface/assert');
exports.use(assert);

},{"./chai/assertion":16,"./chai/config":17,"./chai/core/assertions":18,"./chai/interface/assert":19,"./chai/interface/expect":20,"./chai/interface/should":21,"./chai/utils":32,"assertion-error":41}],16:[function(require,module,exports){
/*!
 * chai
 * http://chaijs.com
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

var config = require('./config');

module.exports = function (_chai, util) {
  /*!
   * Module dependencies.
   */

  var AssertionError = _chai.AssertionError
    , flag = util.flag;

  /*!
   * Module export.
   */

  _chai.Assertion = Assertion;

  /*!
   * Assertion Constructor
   *
   * Creates object for chaining.
   *
   * @api private
   */

  function Assertion (obj, msg, stack) {
    flag(this, 'ssfi', stack || arguments.callee);
    flag(this, 'object', obj);
    flag(this, 'message', msg);
  }

  Object.defineProperty(Assertion, 'includeStack', {
    get: function() {
      console.warn('Assertion.includeStack is deprecated, use chai.config.includeStack instead.');
      return config.includeStack;
    },
    set: function(value) {
      console.warn('Assertion.includeStack is deprecated, use chai.config.includeStack instead.');
      config.includeStack = value;
    }
  });

  Object.defineProperty(Assertion, 'showDiff', {
    get: function() {
      console.warn('Assertion.showDiff is deprecated, use chai.config.showDiff instead.');
      return config.showDiff;
    },
    set: function(value) {
      console.warn('Assertion.showDiff is deprecated, use chai.config.showDiff instead.');
      config.showDiff = value;
    }
  });

  Assertion.addProperty = function (name, fn) {
    util.addProperty(this.prototype, name, fn);
  };

  Assertion.addMethod = function (name, fn) {
    util.addMethod(this.prototype, name, fn);
  };

  Assertion.addChainableMethod = function (name, fn, chainingBehavior) {
    util.addChainableMethod(this.prototype, name, fn, chainingBehavior);
  };

  Assertion.overwriteProperty = function (name, fn) {
    util.overwriteProperty(this.prototype, name, fn);
  };

  Assertion.overwriteMethod = function (name, fn) {
    util.overwriteMethod(this.prototype, name, fn);
  };

  Assertion.overwriteChainableMethod = function (name, fn, chainingBehavior) {
    util.overwriteChainableMethod(this.prototype, name, fn, chainingBehavior);
  };

  /*!
   * ### .assert(expression, message, negateMessage, expected, actual)
   *
   * Executes an expression and check expectations. Throws AssertionError for reporting if test doesn't pass.
   *
   * @name assert
   * @param {Philosophical} expression to be tested
   * @param {String} message to display if fails
   * @param {String} negatedMessage to display if negated expression fails
   * @param {Mixed} expected value (remember to check for negation)
   * @param {Mixed} actual (optional) will default to `this.obj`
   * @api private
   */

  Assertion.prototype.assert = function (expr, msg, negateMsg, expected, _actual, showDiff) {
    var ok = util.test(this, arguments);
    if (true !== showDiff) showDiff = false;
    if (true !== config.showDiff) showDiff = false;

    if (!ok) {
      var msg = util.getMessage(this, arguments)
        , actual = util.getActual(this, arguments);
      throw new AssertionError(msg, {
          actual: actual
        , expected: expected
        , showDiff: showDiff
      }, (config.includeStack) ? this.assert : flag(this, 'ssfi'));
    }
  };

  /*!
   * ### ._obj
   *
   * Quick reference to stored `actual` value for plugin developers.
   *
   * @api private
   */

  Object.defineProperty(Assertion.prototype, '_obj',
    { get: function () {
        return flag(this, 'object');
      }
    , set: function (val) {
        flag(this, 'object', val);
      }
  });
};

},{"./config":17}],17:[function(require,module,exports){
module.exports = {

  /**
   * ### config.includeStack
   *
   * User configurable property, influences whether stack trace
   * is included in Assertion error message. Default of false
   * suppresses stack trace in the error message.
   *
   *     chai.config.includeStack = true;  // enable stack on error
   *
   * @param {Boolean}
   * @api public
   */

   includeStack: false,

  /**
   * ### config.showDiff
   *
   * User configurable property, influences whether or not
   * the `showDiff` flag should be included in the thrown
   * AssertionErrors. `false` will always be `false`; `true`
   * will be true when the assertion has requested a diff
   * be shown.
   *
   * @param {Boolean}
   * @api public
   */

  showDiff: true,

  /**
   * ### config.truncateThreshold
   *
   * User configurable property, sets length threshold for actual and
   * expected values in assertion errors. If this threshold is exceeded,
   * the value is truncated.
   *
   * Set it to zero if you want to disable truncating altogether.
   *
   *     chai.config.truncateThreshold = 0;  // disable truncating
   *
   * @param {Number}
   * @api public
   */

  truncateThreshold: 40

};

},{}],18:[function(require,module,exports){
/*!
 * chai
 * http://chaijs.com
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

module.exports = function (chai, _) {
  var Assertion = chai.Assertion
    , toString = Object.prototype.toString
    , flag = _.flag;

  /**
   * ### Language Chains
   *
   * The following are provided as chainable getters to
   * improve the readability of your assertions. They
   * do not provide testing capabilities unless they
   * have been overwritten by a plugin.
   *
   * **Chains**
   *
   * - to
   * - be
   * - been
   * - is
   * - that
   * - and
   * - has
   * - have
   * - with
   * - at
   * - of
   * - same
   *
   * @name language chains
   * @api public
   */

  [ 'to', 'be', 'been'
  , 'is', 'and', 'has', 'have'
  , 'with', 'that', 'at'
  , 'of', 'same' ].forEach(function (chain) {
    Assertion.addProperty(chain, function () {
      return this;
    });
  });

  /**
   * ### .not
   *
   * Negates any of assertions following in the chain.
   *
   *     expect(foo).to.not.equal('bar');
   *     expect(goodFn).to.not.throw(Error);
   *     expect({ foo: 'baz' }).to.have.property('foo')
   *       .and.not.equal('bar');
   *
   * @name not
   * @api public
   */

  Assertion.addProperty('not', function () {
    flag(this, 'negate', true);
  });

  /**
   * ### .deep
   *
   * Sets the `deep` flag, later used by the `equal` and
   * `property` assertions.
   *
   *     expect(foo).to.deep.equal({ bar: 'baz' });
   *     expect({ foo: { bar: { baz: 'quux' } } })
   *       .to.have.deep.property('foo.bar.baz', 'quux');
   *
   * @name deep
   * @api public
   */

  Assertion.addProperty('deep', function () {
    flag(this, 'deep', true);
  });

  /**
   * ### .a(type)
   *
   * The `a` and `an` assertions are aliases that can be
   * used either as language chains or to assert a value's
   * type.
   *
   *     // typeof
   *     expect('test').to.be.a('string');
   *     expect({ foo: 'bar' }).to.be.an('object');
   *     expect(null).to.be.a('null');
   *     expect(undefined).to.be.an('undefined');
   *
   *     // language chain
   *     expect(foo).to.be.an.instanceof(Foo);
   *
   * @name a
   * @alias an
   * @param {String} type
   * @param {String} message _optional_
   * @api public
   */

  function an (type, msg) {
    if (msg) flag(this, 'message', msg);
    type = type.toLowerCase();
    var obj = flag(this, 'object')
      , article = ~[ 'a', 'e', 'i', 'o', 'u' ].indexOf(type.charAt(0)) ? 'an ' : 'a ';

    this.assert(
        type === _.type(obj)
      , 'expected #{this} to be ' + article + type
      , 'expected #{this} not to be ' + article + type
    );
  }

  Assertion.addChainableMethod('an', an);
  Assertion.addChainableMethod('a', an);

  /**
   * ### .include(value)
   *
   * The `include` and `contain` assertions can be used as either property
   * based language chains or as methods to assert the inclusion of an object
   * in an array or a substring in a string. When used as language chains,
   * they toggle the `contain` flag for the `keys` assertion.
   *
   *     expect([1,2,3]).to.include(2);
   *     expect('foobar').to.contain('foo');
   *     expect({ foo: 'bar', hello: 'universe' }).to.include.keys('foo');
   *
   * @name include
   * @alias contain
   * @param {Object|String|Number} obj
   * @param {String} message _optional_
   * @api public
   */

  function includeChainingBehavior () {
    flag(this, 'contains', true);
  }

  function include (val, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    var expected = false;
    if (_.type(obj) === 'array' && _.type(val) === 'object') {
      for (var i in obj) {
        if (_.eql(obj[i], val)) {
          expected = true;
          break;
        }
      }
    } else if (_.type(val) === 'object') {
      if (!flag(this, 'negate')) {
        for (var k in val) new Assertion(obj).property(k, val[k]);
        return;
      }
      var subset = {}
      for (var k in val) subset[k] = obj[k]
      expected = _.eql(subset, val);
    } else {
      expected = obj && ~obj.indexOf(val)
    }
    this.assert(
        expected
      , 'expected #{this} to include ' + _.inspect(val)
      , 'expected #{this} to not include ' + _.inspect(val));
  }

  Assertion.addChainableMethod('include', include, includeChainingBehavior);
  Assertion.addChainableMethod('contain', include, includeChainingBehavior);

  /**
   * ### .ok
   *
   * Asserts that the target is truthy.
   *
   *     expect('everthing').to.be.ok;
   *     expect(1).to.be.ok;
   *     expect(false).to.not.be.ok;
   *     expect(undefined).to.not.be.ok;
   *     expect(null).to.not.be.ok;
   *
   * @name ok
   * @api public
   */

  Assertion.addProperty('ok', function () {
    this.assert(
        flag(this, 'object')
      , 'expected #{this} to be truthy'
      , 'expected #{this} to be falsy');
  });

  /**
   * ### .true
   *
   * Asserts that the target is `true`.
   *
   *     expect(true).to.be.true;
   *     expect(1).to.not.be.true;
   *
   * @name true
   * @api public
   */

  Assertion.addProperty('true', function () {
    this.assert(
        true === flag(this, 'object')
      , 'expected #{this} to be true'
      , 'expected #{this} to be false'
      , this.negate ? false : true
    );
  });

  /**
   * ### .false
   *
   * Asserts that the target is `false`.
   *
   *     expect(false).to.be.false;
   *     expect(0).to.not.be.false;
   *
   * @name false
   * @api public
   */

  Assertion.addProperty('false', function () {
    this.assert(
        false === flag(this, 'object')
      , 'expected #{this} to be false'
      , 'expected #{this} to be true'
      , this.negate ? true : false
    );
  });

  /**
   * ### .null
   *
   * Asserts that the target is `null`.
   *
   *     expect(null).to.be.null;
   *     expect(undefined).not.to.be.null;
   *
   * @name null
   * @api public
   */

  Assertion.addProperty('null', function () {
    this.assert(
        null === flag(this, 'object')
      , 'expected #{this} to be null'
      , 'expected #{this} not to be null'
    );
  });

  /**
   * ### .undefined
   *
   * Asserts that the target is `undefined`.
   *
   *     expect(undefined).to.be.undefined;
   *     expect(null).to.not.be.undefined;
   *
   * @name undefined
   * @api public
   */

  Assertion.addProperty('undefined', function () {
    this.assert(
        undefined === flag(this, 'object')
      , 'expected #{this} to be undefined'
      , 'expected #{this} not to be undefined'
    );
  });

  /**
   * ### .exist
   *
   * Asserts that the target is neither `null` nor `undefined`.
   *
   *     var foo = 'hi'
   *       , bar = null
   *       , baz;
   *
   *     expect(foo).to.exist;
   *     expect(bar).to.not.exist;
   *     expect(baz).to.not.exist;
   *
   * @name exist
   * @api public
   */

  Assertion.addProperty('exist', function () {
    this.assert(
        null != flag(this, 'object')
      , 'expected #{this} to exist'
      , 'expected #{this} to not exist'
    );
  });


  /**
   * ### .empty
   *
   * Asserts that the target's length is `0`. For arrays, it checks
   * the `length` property. For objects, it gets the count of
   * enumerable keys.
   *
   *     expect([]).to.be.empty;
   *     expect('').to.be.empty;
   *     expect({}).to.be.empty;
   *
   * @name empty
   * @api public
   */

  Assertion.addProperty('empty', function () {
    var obj = flag(this, 'object')
      , expected = obj;

    if (Array.isArray(obj) || 'string' === typeof object) {
      expected = obj.length;
    } else if (typeof obj === 'object') {
      expected = Object.keys(obj).length;
    }

    this.assert(
        !expected
      , 'expected #{this} to be empty'
      , 'expected #{this} not to be empty'
    );
  });

  /**
   * ### .arguments
   *
   * Asserts that the target is an arguments object.
   *
   *     function test () {
   *       expect(arguments).to.be.arguments;
   *     }
   *
   * @name arguments
   * @alias Arguments
   * @api public
   */

  function checkArguments () {
    var obj = flag(this, 'object')
      , type = Object.prototype.toString.call(obj);
    this.assert(
        '[object Arguments]' === type
      , 'expected #{this} to be arguments but got ' + type
      , 'expected #{this} to not be arguments'
    );
  }

  Assertion.addProperty('arguments', checkArguments);
  Assertion.addProperty('Arguments', checkArguments);

  /**
   * ### .equal(value)
   *
   * Asserts that the target is strictly equal (`===`) to `value`.
   * Alternately, if the `deep` flag is set, asserts that
   * the target is deeply equal to `value`.
   *
   *     expect('hello').to.equal('hello');
   *     expect(42).to.equal(42);
   *     expect(1).to.not.equal(true);
   *     expect({ foo: 'bar' }).to.not.equal({ foo: 'bar' });
   *     expect({ foo: 'bar' }).to.deep.equal({ foo: 'bar' });
   *
   * @name equal
   * @alias equals
   * @alias eq
   * @alias deep.equal
   * @param {Mixed} value
   * @param {String} message _optional_
   * @api public
   */

  function assertEqual (val, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    if (flag(this, 'deep')) {
      return this.eql(val);
    } else {
      this.assert(
          val === obj
        , 'expected #{this} to equal #{exp}'
        , 'expected #{this} to not equal #{exp}'
        , val
        , this._obj
        , true
      );
    }
  }

  Assertion.addMethod('equal', assertEqual);
  Assertion.addMethod('equals', assertEqual);
  Assertion.addMethod('eq', assertEqual);

  /**
   * ### .eql(value)
   *
   * Asserts that the target is deeply equal to `value`.
   *
   *     expect({ foo: 'bar' }).to.eql({ foo: 'bar' });
   *     expect([ 1, 2, 3 ]).to.eql([ 1, 2, 3 ]);
   *
   * @name eql
   * @alias eqls
   * @param {Mixed} value
   * @param {String} message _optional_
   * @api public
   */

  function assertEql(obj, msg) {
    if (msg) flag(this, 'message', msg);
    this.assert(
        _.eql(obj, flag(this, 'object'))
      , 'expected #{this} to deeply equal #{exp}'
      , 'expected #{this} to not deeply equal #{exp}'
      , obj
      , this._obj
      , true
    );
  }

  Assertion.addMethod('eql', assertEql);
  Assertion.addMethod('eqls', assertEql);

  /**
   * ### .above(value)
   *
   * Asserts that the target is greater than `value`.
   *
   *     expect(10).to.be.above(5);
   *
   * Can also be used in conjunction with `length` to
   * assert a minimum length. The benefit being a
   * more informative error message than if the length
   * was supplied directly.
   *
   *     expect('foo').to.have.length.above(2);
   *     expect([ 1, 2, 3 ]).to.have.length.above(2);
   *
   * @name above
   * @alias gt
   * @alias greaterThan
   * @param {Number} value
   * @param {String} message _optional_
   * @api public
   */

  function assertAbove (n, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    if (flag(this, 'doLength')) {
      new Assertion(obj, msg).to.have.property('length');
      var len = obj.length;
      this.assert(
          len > n
        , 'expected #{this} to have a length above #{exp} but got #{act}'
        , 'expected #{this} to not have a length above #{exp}'
        , n
        , len
      );
    } else {
      this.assert(
          obj > n
        , 'expected #{this} to be above ' + n
        , 'expected #{this} to be at most ' + n
      );
    }
  }

  Assertion.addMethod('above', assertAbove);
  Assertion.addMethod('gt', assertAbove);
  Assertion.addMethod('greaterThan', assertAbove);

  /**
   * ### .least(value)
   *
   * Asserts that the target is greater than or equal to `value`.
   *
   *     expect(10).to.be.at.least(10);
   *
   * Can also be used in conjunction with `length` to
   * assert a minimum length. The benefit being a
   * more informative error message than if the length
   * was supplied directly.
   *
   *     expect('foo').to.have.length.of.at.least(2);
   *     expect([ 1, 2, 3 ]).to.have.length.of.at.least(3);
   *
   * @name least
   * @alias gte
   * @param {Number} value
   * @param {String} message _optional_
   * @api public
   */

  function assertLeast (n, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    if (flag(this, 'doLength')) {
      new Assertion(obj, msg).to.have.property('length');
      var len = obj.length;
      this.assert(
          len >= n
        , 'expected #{this} to have a length at least #{exp} but got #{act}'
        , 'expected #{this} to have a length below #{exp}'
        , n
        , len
      );
    } else {
      this.assert(
          obj >= n
        , 'expected #{this} to be at least ' + n
        , 'expected #{this} to be below ' + n
      );
    }
  }

  Assertion.addMethod('least', assertLeast);
  Assertion.addMethod('gte', assertLeast);

  /**
   * ### .below(value)
   *
   * Asserts that the target is less than `value`.
   *
   *     expect(5).to.be.below(10);
   *
   * Can also be used in conjunction with `length` to
   * assert a maximum length. The benefit being a
   * more informative error message than if the length
   * was supplied directly.
   *
   *     expect('foo').to.have.length.below(4);
   *     expect([ 1, 2, 3 ]).to.have.length.below(4);
   *
   * @name below
   * @alias lt
   * @alias lessThan
   * @param {Number} value
   * @param {String} message _optional_
   * @api public
   */

  function assertBelow (n, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    if (flag(this, 'doLength')) {
      new Assertion(obj, msg).to.have.property('length');
      var len = obj.length;
      this.assert(
          len < n
        , 'expected #{this} to have a length below #{exp} but got #{act}'
        , 'expected #{this} to not have a length below #{exp}'
        , n
        , len
      );
    } else {
      this.assert(
          obj < n
        , 'expected #{this} to be below ' + n
        , 'expected #{this} to be at least ' + n
      );
    }
  }

  Assertion.addMethod('below', assertBelow);
  Assertion.addMethod('lt', assertBelow);
  Assertion.addMethod('lessThan', assertBelow);

  /**
   * ### .most(value)
   *
   * Asserts that the target is less than or equal to `value`.
   *
   *     expect(5).to.be.at.most(5);
   *
   * Can also be used in conjunction with `length` to
   * assert a maximum length. The benefit being a
   * more informative error message than if the length
   * was supplied directly.
   *
   *     expect('foo').to.have.length.of.at.most(4);
   *     expect([ 1, 2, 3 ]).to.have.length.of.at.most(3);
   *
   * @name most
   * @alias lte
   * @param {Number} value
   * @param {String} message _optional_
   * @api public
   */

  function assertMost (n, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    if (flag(this, 'doLength')) {
      new Assertion(obj, msg).to.have.property('length');
      var len = obj.length;
      this.assert(
          len <= n
        , 'expected #{this} to have a length at most #{exp} but got #{act}'
        , 'expected #{this} to have a length above #{exp}'
        , n
        , len
      );
    } else {
      this.assert(
          obj <= n
        , 'expected #{this} to be at most ' + n
        , 'expected #{this} to be above ' + n
      );
    }
  }

  Assertion.addMethod('most', assertMost);
  Assertion.addMethod('lte', assertMost);

  /**
   * ### .within(start, finish)
   *
   * Asserts that the target is within a range.
   *
   *     expect(7).to.be.within(5,10);
   *
   * Can also be used in conjunction with `length` to
   * assert a length range. The benefit being a
   * more informative error message than if the length
   * was supplied directly.
   *
   *     expect('foo').to.have.length.within(2,4);
   *     expect([ 1, 2, 3 ]).to.have.length.within(2,4);
   *
   * @name within
   * @param {Number} start lowerbound inclusive
   * @param {Number} finish upperbound inclusive
   * @param {String} message _optional_
   * @api public
   */

  Assertion.addMethod('within', function (start, finish, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object')
      , range = start + '..' + finish;
    if (flag(this, 'doLength')) {
      new Assertion(obj, msg).to.have.property('length');
      var len = obj.length;
      this.assert(
          len >= start && len <= finish
        , 'expected #{this} to have a length within ' + range
        , 'expected #{this} to not have a length within ' + range
      );
    } else {
      this.assert(
          obj >= start && obj <= finish
        , 'expected #{this} to be within ' + range
        , 'expected #{this} to not be within ' + range
      );
    }
  });

  /**
   * ### .instanceof(constructor)
   *
   * Asserts that the target is an instance of `constructor`.
   *
   *     var Tea = function (name) { this.name = name; }
   *       , Chai = new Tea('chai');
   *
   *     expect(Chai).to.be.an.instanceof(Tea);
   *     expect([ 1, 2, 3 ]).to.be.instanceof(Array);
   *
   * @name instanceof
   * @param {Constructor} constructor
   * @param {String} message _optional_
   * @alias instanceOf
   * @api public
   */

  function assertInstanceOf (constructor, msg) {
    if (msg) flag(this, 'message', msg);
    var name = _.getName(constructor);
    this.assert(
        flag(this, 'object') instanceof constructor
      , 'expected #{this} to be an instance of ' + name
      , 'expected #{this} to not be an instance of ' + name
    );
  };

  Assertion.addMethod('instanceof', assertInstanceOf);
  Assertion.addMethod('instanceOf', assertInstanceOf);

  /**
   * ### .property(name, [value])
   *
   * Asserts that the target has a property `name`, optionally asserting that
   * the value of that property is strictly equal to  `value`.
   * If the `deep` flag is set, you can use dot- and bracket-notation for deep
   * references into objects and arrays.
   *
   *     // simple referencing
   *     var obj = { foo: 'bar' };
   *     expect(obj).to.have.property('foo');
   *     expect(obj).to.have.property('foo', 'bar');
   *
   *     // deep referencing
   *     var deepObj = {
   *         green: { tea: 'matcha' }
   *       , teas: [ 'chai', 'matcha', { tea: 'konacha' } ]
   *     };

   *     expect(deepObj).to.have.deep.property('green.tea', 'matcha');
   *     expect(deepObj).to.have.deep.property('teas[1]', 'matcha');
   *     expect(deepObj).to.have.deep.property('teas[2].tea', 'konacha');
   *
   * You can also use an array as the starting point of a `deep.property`
   * assertion, or traverse nested arrays.
   *
   *     var arr = [
   *         [ 'chai', 'matcha', 'konacha' ]
   *       , [ { tea: 'chai' }
   *         , { tea: 'matcha' }
   *         , { tea: 'konacha' } ]
   *     ];
   *
   *     expect(arr).to.have.deep.property('[0][1]', 'matcha');
   *     expect(arr).to.have.deep.property('[1][2].tea', 'konacha');
   *
   * Furthermore, `property` changes the subject of the assertion
   * to be the value of that property from the original object. This
   * permits for further chainable assertions on that property.
   *
   *     expect(obj).to.have.property('foo')
   *       .that.is.a('string');
   *     expect(deepObj).to.have.property('green')
   *       .that.is.an('object')
   *       .that.deep.equals({ tea: 'matcha' });
   *     expect(deepObj).to.have.property('teas')
   *       .that.is.an('array')
   *       .with.deep.property('[2]')
   *         .that.deep.equals({ tea: 'konacha' });
   *
   * @name property
   * @alias deep.property
   * @param {String} name
   * @param {Mixed} value (optional)
   * @param {String} message _optional_
   * @returns value of property for chaining
   * @api public
   */

  Assertion.addMethod('property', function (name, val, msg) {
    if (msg) flag(this, 'message', msg);

    var descriptor = flag(this, 'deep') ? 'deep property ' : 'property '
      , negate = flag(this, 'negate')
      , obj = flag(this, 'object')
      , value = flag(this, 'deep')
        ? _.getPathValue(name, obj)
        : obj[name];

    if (negate && undefined !== val) {
      if (undefined === value) {
        msg = (msg != null) ? msg + ': ' : '';
        throw new Error(msg + _.inspect(obj) + ' has no ' + descriptor + _.inspect(name));
      }
    } else {
      this.assert(
          undefined !== value
        , 'expected #{this} to have a ' + descriptor + _.inspect(name)
        , 'expected #{this} to not have ' + descriptor + _.inspect(name));
    }

    if (undefined !== val) {
      this.assert(
          val === value
        , 'expected #{this} to have a ' + descriptor + _.inspect(name) + ' of #{exp}, but got #{act}'
        , 'expected #{this} to not have a ' + descriptor + _.inspect(name) + ' of #{act}'
        , val
        , value
      );
    }

    flag(this, 'object', value);
  });


  /**
   * ### .ownProperty(name)
   *
   * Asserts that the target has an own property `name`.
   *
   *     expect('test').to.have.ownProperty('length');
   *
   * @name ownProperty
   * @alias haveOwnProperty
   * @param {String} name
   * @param {String} message _optional_
   * @api public
   */

  function assertOwnProperty (name, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    this.assert(
        obj.hasOwnProperty(name)
      , 'expected #{this} to have own property ' + _.inspect(name)
      , 'expected #{this} to not have own property ' + _.inspect(name)
    );
  }

  Assertion.addMethod('ownProperty', assertOwnProperty);
  Assertion.addMethod('haveOwnProperty', assertOwnProperty);

  /**
   * ### .length(value)
   *
   * Asserts that the target's `length` property has
   * the expected value.
   *
   *     expect([ 1, 2, 3]).to.have.length(3);
   *     expect('foobar').to.have.length(6);
   *
   * Can also be used as a chain precursor to a value
   * comparison for the length property.
   *
   *     expect('foo').to.have.length.above(2);
   *     expect([ 1, 2, 3 ]).to.have.length.above(2);
   *     expect('foo').to.have.length.below(4);
   *     expect([ 1, 2, 3 ]).to.have.length.below(4);
   *     expect('foo').to.have.length.within(2,4);
   *     expect([ 1, 2, 3 ]).to.have.length.within(2,4);
   *
   * @name length
   * @alias lengthOf
   * @param {Number} length
   * @param {String} message _optional_
   * @api public
   */

  function assertLengthChain () {
    flag(this, 'doLength', true);
  }

  function assertLength (n, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    new Assertion(obj, msg).to.have.property('length');
    var len = obj.length;

    this.assert(
        len == n
      , 'expected #{this} to have a length of #{exp} but got #{act}'
      , 'expected #{this} to not have a length of #{act}'
      , n
      , len
    );
  }

  Assertion.addChainableMethod('length', assertLength, assertLengthChain);
  Assertion.addMethod('lengthOf', assertLength, assertLengthChain);

  /**
   * ### .match(regexp)
   *
   * Asserts that the target matches a regular expression.
   *
   *     expect('foobar').to.match(/^foo/);
   *
   * @name match
   * @param {RegExp} RegularExpression
   * @param {String} message _optional_
   * @api public
   */

  Assertion.addMethod('match', function (re, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    this.assert(
        re.exec(obj)
      , 'expected #{this} to match ' + re
      , 'expected #{this} not to match ' + re
    );
  });

  /**
   * ### .string(string)
   *
   * Asserts that the string target contains another string.
   *
   *     expect('foobar').to.have.string('bar');
   *
   * @name string
   * @param {String} string
   * @param {String} message _optional_
   * @api public
   */

  Assertion.addMethod('string', function (str, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    new Assertion(obj, msg).is.a('string');

    this.assert(
        ~obj.indexOf(str)
      , 'expected #{this} to contain ' + _.inspect(str)
      , 'expected #{this} to not contain ' + _.inspect(str)
    );
  });


  /**
   * ### .keys(key1, [key2], [...])
   *
   * Asserts that the target has exactly the given keys, or
   * asserts the inclusion of some keys when using the
   * `include` or `contain` modifiers.
   *
   *     expect({ foo: 1, bar: 2 }).to.have.keys(['foo', 'bar']);
   *     expect({ foo: 1, bar: 2, baz: 3 }).to.contain.keys('foo', 'bar');
   *
   * @name keys
   * @alias key
   * @param {String...|Array} keys
   * @api public
   */

  function assertKeys (keys) {
    var obj = flag(this, 'object')
      , str
      , ok = true;

    keys = keys instanceof Array
      ? keys
      : Array.prototype.slice.call(arguments);

    if (!keys.length) throw new Error('keys required');

    var actual = Object.keys(obj)
      , len = keys.length;

    // Inclusion
    ok = keys.every(function(key){
      return ~actual.indexOf(key);
    });

    // Strict
    if (!flag(this, 'negate') && !flag(this, 'contains')) {
      ok = ok && keys.length == actual.length;
    }

    // Key string
    if (len > 1) {
      keys = keys.map(function(key){
        return _.inspect(key);
      });
      var last = keys.pop();
      str = keys.join(', ') + ', and ' + last;
    } else {
      str = _.inspect(keys[0]);
    }

    // Form
    str = (len > 1 ? 'keys ' : 'key ') + str;

    // Have / include
    str = (flag(this, 'contains') ? 'contain ' : 'have ') + str;

    // Assertion
    this.assert(
        ok
      , 'expected #{this} to ' + str
      , 'expected #{this} to not ' + str
    );
  }

  Assertion.addMethod('keys', assertKeys);
  Assertion.addMethod('key', assertKeys);

  /**
   * ### .throw(constructor)
   *
   * Asserts that the function target will throw a specific error, or specific type of error
   * (as determined using `instanceof`), optionally with a RegExp or string inclusion test
   * for the error's message.
   *
   *     var err = new ReferenceError('This is a bad function.');
   *     var fn = function () { throw err; }
   *     expect(fn).to.throw(ReferenceError);
   *     expect(fn).to.throw(Error);
   *     expect(fn).to.throw(/bad function/);
   *     expect(fn).to.not.throw('good function');
   *     expect(fn).to.throw(ReferenceError, /bad function/);
   *     expect(fn).to.throw(err);
   *     expect(fn).to.not.throw(new RangeError('Out of range.'));
   *
   * Please note that when a throw expectation is negated, it will check each
   * parameter independently, starting with error constructor type. The appropriate way
   * to check for the existence of a type of error but for a message that does not match
   * is to use `and`.
   *
   *     expect(fn).to.throw(ReferenceError)
   *        .and.not.throw(/good function/);
   *
   * @name throw
   * @alias throws
   * @alias Throw
   * @param {ErrorConstructor} constructor
   * @param {String|RegExp} expected error message
   * @param {String} message _optional_
   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
   * @returns error for chaining (null if no error)
   * @api public
   */

  function assertThrows (constructor, errMsg, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    new Assertion(obj, msg).is.a('function');

    var thrown = false
      , desiredError = null
      , name = null
      , thrownError = null;

    if (arguments.length === 0) {
      errMsg = null;
      constructor = null;
    } else if (constructor && (constructor instanceof RegExp || 'string' === typeof constructor)) {
      errMsg = constructor;
      constructor = null;
    } else if (constructor && constructor instanceof Error) {
      desiredError = constructor;
      constructor = null;
      errMsg = null;
    } else if (typeof constructor === 'function') {
      name = constructor.prototype.name || constructor.name;
      if (name === 'Error' && constructor !== Error) {
        name = (new constructor()).name;
      }
    } else {
      constructor = null;
    }

    try {
      obj();
    } catch (err) {
      // first, check desired error
      if (desiredError) {
        this.assert(
            err === desiredError
          , 'expected #{this} to throw #{exp} but #{act} was thrown'
          , 'expected #{this} to not throw #{exp}'
          , (desiredError instanceof Error ? desiredError.toString() : desiredError)
          , (err instanceof Error ? err.toString() : err)
        );

        flag(this, 'object', err);
        return this;
      }

      // next, check constructor
      if (constructor) {
        this.assert(
            err instanceof constructor
          , 'expected #{this} to throw #{exp} but #{act} was thrown'
          , 'expected #{this} to not throw #{exp} but #{act} was thrown'
          , name
          , (err instanceof Error ? err.toString() : err)
        );

        if (!errMsg) {
          flag(this, 'object', err);
          return this;
        }
      }

      // next, check message
      var message = 'object' === _.type(err) && "message" in err
        ? err.message
        : '' + err;

      if ((message != null) && errMsg && errMsg instanceof RegExp) {
        this.assert(
            errMsg.exec(message)
          , 'expected #{this} to throw error matching #{exp} but got #{act}'
          , 'expected #{this} to throw error not matching #{exp}'
          , errMsg
          , message
        );

        flag(this, 'object', err);
        return this;
      } else if ((message != null) && errMsg && 'string' === typeof errMsg) {
        this.assert(
            ~message.indexOf(errMsg)
          , 'expected #{this} to throw error including #{exp} but got #{act}'
          , 'expected #{this} to throw error not including #{act}'
          , errMsg
          , message
        );

        flag(this, 'object', err);
        return this;
      } else {
        thrown = true;
        thrownError = err;
      }
    }

    var actuallyGot = ''
      , expectedThrown = name !== null
        ? name
        : desiredError
          ? '#{exp}' //_.inspect(desiredError)
          : 'an error';

    if (thrown) {
      actuallyGot = ' but #{act} was thrown'
    }

    this.assert(
        thrown === true
      , 'expected #{this} to throw ' + expectedThrown + actuallyGot
      , 'expected #{this} to not throw ' + expectedThrown + actuallyGot
      , (desiredError instanceof Error ? desiredError.toString() : desiredError)
      , (thrownError instanceof Error ? thrownError.toString() : thrownError)
    );

    flag(this, 'object', thrownError);
  };

  Assertion.addMethod('throw', assertThrows);
  Assertion.addMethod('throws', assertThrows);
  Assertion.addMethod('Throw', assertThrows);

  /**
   * ### .respondTo(method)
   *
   * Asserts that the object or class target will respond to a method.
   *
   *     Klass.prototype.bar = function(){};
   *     expect(Klass).to.respondTo('bar');
   *     expect(obj).to.respondTo('bar');
   *
   * To check if a constructor will respond to a static function,
   * set the `itself` flag.
   *
   *     Klass.baz = function(){};
   *     expect(Klass).itself.to.respondTo('baz');
   *
   * @name respondTo
   * @param {String} method
   * @param {String} message _optional_
   * @api public
   */

  Assertion.addMethod('respondTo', function (method, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object')
      , itself = flag(this, 'itself')
      , context = ('function' === _.type(obj) && !itself)
        ? obj.prototype[method]
        : obj[method];

    this.assert(
        'function' === typeof context
      , 'expected #{this} to respond to ' + _.inspect(method)
      , 'expected #{this} to not respond to ' + _.inspect(method)
    );
  });

  /**
   * ### .itself
   *
   * Sets the `itself` flag, later used by the `respondTo` assertion.
   *
   *     function Foo() {}
   *     Foo.bar = function() {}
   *     Foo.prototype.baz = function() {}
   *
   *     expect(Foo).itself.to.respondTo('bar');
   *     expect(Foo).itself.not.to.respondTo('baz');
   *
   * @name itself
   * @api public
   */

  Assertion.addProperty('itself', function () {
    flag(this, 'itself', true);
  });

  /**
   * ### .satisfy(method)
   *
   * Asserts that the target passes a given truth test.
   *
   *     expect(1).to.satisfy(function(num) { return num > 0; });
   *
   * @name satisfy
   * @param {Function} matcher
   * @param {String} message _optional_
   * @api public
   */

  Assertion.addMethod('satisfy', function (matcher, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    this.assert(
        matcher(obj)
      , 'expected #{this} to satisfy ' + _.objDisplay(matcher)
      , 'expected #{this} to not satisfy' + _.objDisplay(matcher)
      , this.negate ? false : true
      , matcher(obj)
    );
  });

  /**
   * ### .closeTo(expected, delta)
   *
   * Asserts that the target is equal `expected`, to within a +/- `delta` range.
   *
   *     expect(1.5).to.be.closeTo(1, 0.5);
   *
   * @name closeTo
   * @param {Number} expected
   * @param {Number} delta
   * @param {String} message _optional_
   * @api public
   */

  Assertion.addMethod('closeTo', function (expected, delta, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    this.assert(
        Math.abs(obj - expected) <= delta
      , 'expected #{this} to be close to ' + expected + ' +/- ' + delta
      , 'expected #{this} not to be close to ' + expected + ' +/- ' + delta
    );
  });

  function isSubsetOf(subset, superset, cmp) {
    return subset.every(function(elem) {
      if (!cmp) return superset.indexOf(elem) !== -1;

      return superset.some(function(elem2) {
        return cmp(elem, elem2);
      });
    })
  }

  /**
   * ### .members(set)
   *
   * Asserts that the target is a superset of `set`,
   * or that the target and `set` have the same strictly-equal (===) members.
   * Alternately, if the `deep` flag is set, set members are compared for deep
   * equality.
   *
   *     expect([1, 2, 3]).to.include.members([3, 2]);
   *     expect([1, 2, 3]).to.not.include.members([3, 2, 8]);
   *
   *     expect([4, 2]).to.have.members([2, 4]);
   *     expect([5, 2]).to.not.have.members([5, 2, 1]);
   *
   *     expect([{ id: 1 }]).to.deep.include.members([{ id: 1 }]);
   *
   * @name members
   * @param {Array} set
   * @param {String} message _optional_
   * @api public
   */

  Assertion.addMethod('members', function (subset, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');

    new Assertion(obj).to.be.an('array');
    new Assertion(subset).to.be.an('array');

    var cmp = flag(this, 'deep') ? _.eql : undefined;

    if (flag(this, 'contains')) {
      return this.assert(
          isSubsetOf(subset, obj, cmp)
        , 'expected #{this} to be a superset of #{act}'
        , 'expected #{this} to not be a superset of #{act}'
        , obj
        , subset
      );
    }

    this.assert(
        isSubsetOf(obj, subset, cmp) && isSubsetOf(subset, obj, cmp)
        , 'expected #{this} to have the same members as #{act}'
        , 'expected #{this} to not have the same members as #{act}'
        , obj
        , subset
    );
  });
};

},{}],19:[function(require,module,exports){
/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */


module.exports = function (chai, util) {

  /*!
   * Chai dependencies.
   */

  var Assertion = chai.Assertion
    , flag = util.flag;

  /*!
   * Module export.
   */

  /**
   * ### assert(expression, message)
   *
   * Write your own test expressions.
   *
   *     assert('foo' !== 'bar', 'foo is not bar');
   *     assert(Array.isArray([]), 'empty arrays are arrays');
   *
   * @param {Mixed} expression to test for truthiness
   * @param {String} message to display on error
   * @name assert
   * @api public
   */

  var assert = chai.assert = function (express, errmsg) {
    var test = new Assertion(null, null, chai.assert);
    test.assert(
        express
      , errmsg
      , '[ negation message unavailable ]'
    );
  };

  /**
   * ### .fail(actual, expected, [message], [operator])
   *
   * Throw a failure. Node.js `assert` module-compatible.
   *
   * @name fail
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @param {String} operator
   * @api public
   */

  assert.fail = function (actual, expected, message, operator) {
    message = message || 'assert.fail()';
    throw new chai.AssertionError(message, {
        actual: actual
      , expected: expected
      , operator: operator
    }, assert.fail);
  };

  /**
   * ### .ok(object, [message])
   *
   * Asserts that `object` is truthy.
   *
   *     assert.ok('everything', 'everything is ok');
   *     assert.ok(false, 'this will fail');
   *
   * @name ok
   * @param {Mixed} object to test
   * @param {String} message
   * @api public
   */

  assert.ok = function (val, msg) {
    new Assertion(val, msg).is.ok;
  };

  /**
   * ### .notOk(object, [message])
   *
   * Asserts that `object` is falsy.
   *
   *     assert.notOk('everything', 'this will fail');
   *     assert.notOk(false, 'this will pass');
   *
   * @name notOk
   * @param {Mixed} object to test
   * @param {String} message
   * @api public
   */

  assert.notOk = function (val, msg) {
    new Assertion(val, msg).is.not.ok;
  };

  /**
   * ### .equal(actual, expected, [message])
   *
   * Asserts non-strict equality (`==`) of `actual` and `expected`.
   *
   *     assert.equal(3, '3', '== coerces values to strings');
   *
   * @name equal
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @api public
   */

  assert.equal = function (act, exp, msg) {
    var test = new Assertion(act, msg, assert.equal);

    test.assert(
        exp == flag(test, 'object')
      , 'expected #{this} to equal #{exp}'
      , 'expected #{this} to not equal #{act}'
      , exp
      , act
    );
  };

  /**
   * ### .notEqual(actual, expected, [message])
   *
   * Asserts non-strict inequality (`!=`) of `actual` and `expected`.
   *
   *     assert.notEqual(3, 4, 'these numbers are not equal');
   *
   * @name notEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @api public
   */

  assert.notEqual = function (act, exp, msg) {
    var test = new Assertion(act, msg, assert.notEqual);

    test.assert(
        exp != flag(test, 'object')
      , 'expected #{this} to not equal #{exp}'
      , 'expected #{this} to equal #{act}'
      , exp
      , act
    );
  };

  /**
   * ### .strictEqual(actual, expected, [message])
   *
   * Asserts strict equality (`===`) of `actual` and `expected`.
   *
   *     assert.strictEqual(true, true, 'these booleans are strictly equal');
   *
   * @name strictEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @api public
   */

  assert.strictEqual = function (act, exp, msg) {
    new Assertion(act, msg).to.equal(exp);
  };

  /**
   * ### .notStrictEqual(actual, expected, [message])
   *
   * Asserts strict inequality (`!==`) of `actual` and `expected`.
   *
   *     assert.notStrictEqual(3, '3', 'no coercion for strict equality');
   *
   * @name notStrictEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @api public
   */

  assert.notStrictEqual = function (act, exp, msg) {
    new Assertion(act, msg).to.not.equal(exp);
  };

  /**
   * ### .deepEqual(actual, expected, [message])
   *
   * Asserts that `actual` is deeply equal to `expected`.
   *
   *     assert.deepEqual({ tea: 'green' }, { tea: 'green' });
   *
   * @name deepEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @api public
   */

  assert.deepEqual = function (act, exp, msg) {
    new Assertion(act, msg).to.eql(exp);
  };

  /**
   * ### .notDeepEqual(actual, expected, [message])
   *
   * Assert that `actual` is not deeply equal to `expected`.
   *
   *     assert.notDeepEqual({ tea: 'green' }, { tea: 'jasmine' });
   *
   * @name notDeepEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @api public
   */

  assert.notDeepEqual = function (act, exp, msg) {
    new Assertion(act, msg).to.not.eql(exp);
  };

  /**
   * ### .isTrue(value, [message])
   *
   * Asserts that `value` is true.
   *
   *     var teaServed = true;
   *     assert.isTrue(teaServed, 'the tea has been served');
   *
   * @name isTrue
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isTrue = function (val, msg) {
    new Assertion(val, msg).is['true'];
  };

  /**
   * ### .isFalse(value, [message])
   *
   * Asserts that `value` is false.
   *
   *     var teaServed = false;
   *     assert.isFalse(teaServed, 'no tea yet? hmm...');
   *
   * @name isFalse
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isFalse = function (val, msg) {
    new Assertion(val, msg).is['false'];
  };

  /**
   * ### .isNull(value, [message])
   *
   * Asserts that `value` is null.
   *
   *     assert.isNull(err, 'there was no error');
   *
   * @name isNull
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isNull = function (val, msg) {
    new Assertion(val, msg).to.equal(null);
  };

  /**
   * ### .isNotNull(value, [message])
   *
   * Asserts that `value` is not null.
   *
   *     var tea = 'tasty chai';
   *     assert.isNotNull(tea, 'great, time for tea!');
   *
   * @name isNotNull
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isNotNull = function (val, msg) {
    new Assertion(val, msg).to.not.equal(null);
  };

  /**
   * ### .isUndefined(value, [message])
   *
   * Asserts that `value` is `undefined`.
   *
   *     var tea;
   *     assert.isUndefined(tea, 'no tea defined');
   *
   * @name isUndefined
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isUndefined = function (val, msg) {
    new Assertion(val, msg).to.equal(undefined);
  };

  /**
   * ### .isDefined(value, [message])
   *
   * Asserts that `value` is not `undefined`.
   *
   *     var tea = 'cup of chai';
   *     assert.isDefined(tea, 'tea has been defined');
   *
   * @name isDefined
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isDefined = function (val, msg) {
    new Assertion(val, msg).to.not.equal(undefined);
  };

  /**
   * ### .isFunction(value, [message])
   *
   * Asserts that `value` is a function.
   *
   *     function serveTea() { return 'cup of tea'; };
   *     assert.isFunction(serveTea, 'great, we can have tea now');
   *
   * @name isFunction
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isFunction = function (val, msg) {
    new Assertion(val, msg).to.be.a('function');
  };

  /**
   * ### .isNotFunction(value, [message])
   *
   * Asserts that `value` is _not_ a function.
   *
   *     var serveTea = [ 'heat', 'pour', 'sip' ];
   *     assert.isNotFunction(serveTea, 'great, we have listed the steps');
   *
   * @name isNotFunction
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isNotFunction = function (val, msg) {
    new Assertion(val, msg).to.not.be.a('function');
  };

  /**
   * ### .isObject(value, [message])
   *
   * Asserts that `value` is an object (as revealed by
   * `Object.prototype.toString`).
   *
   *     var selection = { name: 'Chai', serve: 'with spices' };
   *     assert.isObject(selection, 'tea selection is an object');
   *
   * @name isObject
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isObject = function (val, msg) {
    new Assertion(val, msg).to.be.a('object');
  };

  /**
   * ### .isNotObject(value, [message])
   *
   * Asserts that `value` is _not_ an object.
   *
   *     var selection = 'chai'
   *     assert.isNotObject(selection, 'tea selection is not an object');
   *     assert.isNotObject(null, 'null is not an object');
   *
   * @name isNotObject
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isNotObject = function (val, msg) {
    new Assertion(val, msg).to.not.be.a('object');
  };

  /**
   * ### .isArray(value, [message])
   *
   * Asserts that `value` is an array.
   *
   *     var menu = [ 'green', 'chai', 'oolong' ];
   *     assert.isArray(menu, 'what kind of tea do we want?');
   *
   * @name isArray
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isArray = function (val, msg) {
    new Assertion(val, msg).to.be.an('array');
  };

  /**
   * ### .isNotArray(value, [message])
   *
   * Asserts that `value` is _not_ an array.
   *
   *     var menu = 'green|chai|oolong';
   *     assert.isNotArray(menu, 'what kind of tea do we want?');
   *
   * @name isNotArray
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isNotArray = function (val, msg) {
    new Assertion(val, msg).to.not.be.an('array');
  };

  /**
   * ### .isString(value, [message])
   *
   * Asserts that `value` is a string.
   *
   *     var teaOrder = 'chai';
   *     assert.isString(teaOrder, 'order placed');
   *
   * @name isString
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isString = function (val, msg) {
    new Assertion(val, msg).to.be.a('string');
  };

  /**
   * ### .isNotString(value, [message])
   *
   * Asserts that `value` is _not_ a string.
   *
   *     var teaOrder = 4;
   *     assert.isNotString(teaOrder, 'order placed');
   *
   * @name isNotString
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isNotString = function (val, msg) {
    new Assertion(val, msg).to.not.be.a('string');
  };

  /**
   * ### .isNumber(value, [message])
   *
   * Asserts that `value` is a number.
   *
   *     var cups = 2;
   *     assert.isNumber(cups, 'how many cups');
   *
   * @name isNumber
   * @param {Number} value
   * @param {String} message
   * @api public
   */

  assert.isNumber = function (val, msg) {
    new Assertion(val, msg).to.be.a('number');
  };

  /**
   * ### .isNotNumber(value, [message])
   *
   * Asserts that `value` is _not_ a number.
   *
   *     var cups = '2 cups please';
   *     assert.isNotNumber(cups, 'how many cups');
   *
   * @name isNotNumber
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isNotNumber = function (val, msg) {
    new Assertion(val, msg).to.not.be.a('number');
  };

  /**
   * ### .isBoolean(value, [message])
   *
   * Asserts that `value` is a boolean.
   *
   *     var teaReady = true
   *       , teaServed = false;
   *
   *     assert.isBoolean(teaReady, 'is the tea ready');
   *     assert.isBoolean(teaServed, 'has tea been served');
   *
   * @name isBoolean
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isBoolean = function (val, msg) {
    new Assertion(val, msg).to.be.a('boolean');
  };

  /**
   * ### .isNotBoolean(value, [message])
   *
   * Asserts that `value` is _not_ a boolean.
   *
   *     var teaReady = 'yep'
   *       , teaServed = 'nope';
   *
   *     assert.isNotBoolean(teaReady, 'is the tea ready');
   *     assert.isNotBoolean(teaServed, 'has tea been served');
   *
   * @name isNotBoolean
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isNotBoolean = function (val, msg) {
    new Assertion(val, msg).to.not.be.a('boolean');
  };

  /**
   * ### .typeOf(value, name, [message])
   *
   * Asserts that `value`'s type is `name`, as determined by
   * `Object.prototype.toString`.
   *
   *     assert.typeOf({ tea: 'chai' }, 'object', 'we have an object');
   *     assert.typeOf(['chai', 'jasmine'], 'array', 'we have an array');
   *     assert.typeOf('tea', 'string', 'we have a string');
   *     assert.typeOf(/tea/, 'regexp', 'we have a regular expression');
   *     assert.typeOf(null, 'null', 'we have a null');
   *     assert.typeOf(undefined, 'undefined', 'we have an undefined');
   *
   * @name typeOf
   * @param {Mixed} value
   * @param {String} name
   * @param {String} message
   * @api public
   */

  assert.typeOf = function (val, type, msg) {
    new Assertion(val, msg).to.be.a(type);
  };

  /**
   * ### .notTypeOf(value, name, [message])
   *
   * Asserts that `value`'s type is _not_ `name`, as determined by
   * `Object.prototype.toString`.
   *
   *     assert.notTypeOf('tea', 'number', 'strings are not numbers');
   *
   * @name notTypeOf
   * @param {Mixed} value
   * @param {String} typeof name
   * @param {String} message
   * @api public
   */

  assert.notTypeOf = function (val, type, msg) {
    new Assertion(val, msg).to.not.be.a(type);
  };

  /**
   * ### .instanceOf(object, constructor, [message])
   *
   * Asserts that `value` is an instance of `constructor`.
   *
   *     var Tea = function (name) { this.name = name; }
   *       , chai = new Tea('chai');
   *
   *     assert.instanceOf(chai, Tea, 'chai is an instance of tea');
   *
   * @name instanceOf
   * @param {Object} object
   * @param {Constructor} constructor
   * @param {String} message
   * @api public
   */

  assert.instanceOf = function (val, type, msg) {
    new Assertion(val, msg).to.be.instanceOf(type);
  };

  /**
   * ### .notInstanceOf(object, constructor, [message])
   *
   * Asserts `value` is not an instance of `constructor`.
   *
   *     var Tea = function (name) { this.name = name; }
   *       , chai = new String('chai');
   *
   *     assert.notInstanceOf(chai, Tea, 'chai is not an instance of tea');
   *
   * @name notInstanceOf
   * @param {Object} object
   * @param {Constructor} constructor
   * @param {String} message
   * @api public
   */

  assert.notInstanceOf = function (val, type, msg) {
    new Assertion(val, msg).to.not.be.instanceOf(type);
  };

  /**
   * ### .include(haystack, needle, [message])
   *
   * Asserts that `haystack` includes `needle`. Works
   * for strings and arrays.
   *
   *     assert.include('foobar', 'bar', 'foobar contains string "bar"');
   *     assert.include([ 1, 2, 3 ], 3, 'array contains value');
   *
   * @name include
   * @param {Array|String} haystack
   * @param {Mixed} needle
   * @param {String} message
   * @api public
   */

  assert.include = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.include).include(inc);
  };

  /**
   * ### .notInclude(haystack, needle, [message])
   *
   * Asserts that `haystack` does not include `needle`. Works
   * for strings and arrays.
   *i
   *     assert.notInclude('foobar', 'baz', 'string not include substring');
   *     assert.notInclude([ 1, 2, 3 ], 4, 'array not include contain value');
   *
   * @name notInclude
   * @param {Array|String} haystack
   * @param {Mixed} needle
   * @param {String} message
   * @api public
   */

  assert.notInclude = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.notInclude).not.include(inc);
  };

  /**
   * ### .match(value, regexp, [message])
   *
   * Asserts that `value` matches the regular expression `regexp`.
   *
   *     assert.match('foobar', /^foo/, 'regexp matches');
   *
   * @name match
   * @param {Mixed} value
   * @param {RegExp} regexp
   * @param {String} message
   * @api public
   */

  assert.match = function (exp, re, msg) {
    new Assertion(exp, msg).to.match(re);
  };

  /**
   * ### .notMatch(value, regexp, [message])
   *
   * Asserts that `value` does not match the regular expression `regexp`.
   *
   *     assert.notMatch('foobar', /^foo/, 'regexp does not match');
   *
   * @name notMatch
   * @param {Mixed} value
   * @param {RegExp} regexp
   * @param {String} message
   * @api public
   */

  assert.notMatch = function (exp, re, msg) {
    new Assertion(exp, msg).to.not.match(re);
  };

  /**
   * ### .property(object, property, [message])
   *
   * Asserts that `object` has a property named by `property`.
   *
   *     assert.property({ tea: { green: 'matcha' }}, 'tea');
   *
   * @name property
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @api public
   */

  assert.property = function (obj, prop, msg) {
    new Assertion(obj, msg).to.have.property(prop);
  };

  /**
   * ### .notProperty(object, property, [message])
   *
   * Asserts that `object` does _not_ have a property named by `property`.
   *
   *     assert.notProperty({ tea: { green: 'matcha' }}, 'coffee');
   *
   * @name notProperty
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @api public
   */

  assert.notProperty = function (obj, prop, msg) {
    new Assertion(obj, msg).to.not.have.property(prop);
  };

  /**
   * ### .deepProperty(object, property, [message])
   *
   * Asserts that `object` has a property named by `property`, which can be a
   * string using dot- and bracket-notation for deep reference.
   *
   *     assert.deepProperty({ tea: { green: 'matcha' }}, 'tea.green');
   *
   * @name deepProperty
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @api public
   */

  assert.deepProperty = function (obj, prop, msg) {
    new Assertion(obj, msg).to.have.deep.property(prop);
  };

  /**
   * ### .notDeepProperty(object, property, [message])
   *
   * Asserts that `object` does _not_ have a property named by `property`, which
   * can be a string using dot- and bracket-notation for deep reference.
   *
   *     assert.notDeepProperty({ tea: { green: 'matcha' }}, 'tea.oolong');
   *
   * @name notDeepProperty
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @api public
   */

  assert.notDeepProperty = function (obj, prop, msg) {
    new Assertion(obj, msg).to.not.have.deep.property(prop);
  };

  /**
   * ### .propertyVal(object, property, value, [message])
   *
   * Asserts that `object` has a property named by `property` with value given
   * by `value`.
   *
   *     assert.propertyVal({ tea: 'is good' }, 'tea', 'is good');
   *
   * @name propertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.propertyVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg).to.have.property(prop, val);
  };

  /**
   * ### .propertyNotVal(object, property, value, [message])
   *
   * Asserts that `object` has a property named by `property`, but with a value
   * different from that given by `value`.
   *
   *     assert.propertyNotVal({ tea: 'is good' }, 'tea', 'is bad');
   *
   * @name propertyNotVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.propertyNotVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg).to.not.have.property(prop, val);
  };

  /**
   * ### .deepPropertyVal(object, property, value, [message])
   *
   * Asserts that `object` has a property named by `property` with value given
   * by `value`. `property` can use dot- and bracket-notation for deep
   * reference.
   *
   *     assert.deepPropertyVal({ tea: { green: 'matcha' }}, 'tea.green', 'matcha');
   *
   * @name deepPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.deepPropertyVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg).to.have.deep.property(prop, val);
  };

  /**
   * ### .deepPropertyNotVal(object, property, value, [message])
   *
   * Asserts that `object` has a property named by `property`, but with a value
   * different from that given by `value`. `property` can use dot- and
   * bracket-notation for deep reference.
   *
   *     assert.deepPropertyNotVal({ tea: { green: 'matcha' }}, 'tea.green', 'konacha');
   *
   * @name deepPropertyNotVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.deepPropertyNotVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg).to.not.have.deep.property(prop, val);
  };

  /**
   * ### .lengthOf(object, length, [message])
   *
   * Asserts that `object` has a `length` property with the expected value.
   *
   *     assert.lengthOf([1,2,3], 3, 'array has length of 3');
   *     assert.lengthOf('foobar', 5, 'string has length of 6');
   *
   * @name lengthOf
   * @param {Mixed} object
   * @param {Number} length
   * @param {String} message
   * @api public
   */

  assert.lengthOf = function (exp, len, msg) {
    new Assertion(exp, msg).to.have.length(len);
  };

  /**
   * ### .throws(function, [constructor/string/regexp], [string/regexp], [message])
   *
   * Asserts that `function` will throw an error that is an instance of
   * `constructor`, or alternately that it will throw an error with message
   * matching `regexp`.
   *
   *     assert.throw(fn, 'function throws a reference error');
   *     assert.throw(fn, /function throws a reference error/);
   *     assert.throw(fn, ReferenceError);
   *     assert.throw(fn, ReferenceError, 'function throws a reference error');
   *     assert.throw(fn, ReferenceError, /function throws a reference error/);
   *
   * @name throws
   * @alias throw
   * @alias Throw
   * @param {Function} function
   * @param {ErrorConstructor} constructor
   * @param {RegExp} regexp
   * @param {String} message
   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
   * @api public
   */

  assert.Throw = function (fn, errt, errs, msg) {
    if ('string' === typeof errt || errt instanceof RegExp) {
      errs = errt;
      errt = null;
    }

    var assertErr = new Assertion(fn, msg).to.Throw(errt, errs);
    return flag(assertErr, 'object');
  };

  /**
   * ### .doesNotThrow(function, [constructor/regexp], [message])
   *
   * Asserts that `function` will _not_ throw an error that is an instance of
   * `constructor`, or alternately that it will not throw an error with message
   * matching `regexp`.
   *
   *     assert.doesNotThrow(fn, Error, 'function does not throw');
   *
   * @name doesNotThrow
   * @param {Function} function
   * @param {ErrorConstructor} constructor
   * @param {RegExp} regexp
   * @param {String} message
   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
   * @api public
   */

  assert.doesNotThrow = function (fn, type, msg) {
    if ('string' === typeof type) {
      msg = type;
      type = null;
    }

    new Assertion(fn, msg).to.not.Throw(type);
  };

  /**
   * ### .operator(val1, operator, val2, [message])
   *
   * Compares two values using `operator`.
   *
   *     assert.operator(1, '<', 2, 'everything is ok');
   *     assert.operator(1, '>', 2, 'this will fail');
   *
   * @name operator
   * @param {Mixed} val1
   * @param {String} operator
   * @param {Mixed} val2
   * @param {String} message
   * @api public
   */

  assert.operator = function (val, operator, val2, msg) {
    if (!~['==', '===', '>', '>=', '<', '<=', '!=', '!=='].indexOf(operator)) {
      throw new Error('Invalid operator "' + operator + '"');
    }
    var test = new Assertion(eval(val + operator + val2), msg);
    test.assert(
        true === flag(test, 'object')
      , 'expected ' + util.inspect(val) + ' to be ' + operator + ' ' + util.inspect(val2)
      , 'expected ' + util.inspect(val) + ' to not be ' + operator + ' ' + util.inspect(val2) );
  };

  /**
   * ### .closeTo(actual, expected, delta, [message])
   *
   * Asserts that the target is equal `expected`, to within a +/- `delta` range.
   *
   *     assert.closeTo(1.5, 1, 0.5, 'numbers are close');
   *
   * @name closeTo
   * @param {Number} actual
   * @param {Number} expected
   * @param {Number} delta
   * @param {String} message
   * @api public
   */

  assert.closeTo = function (act, exp, delta, msg) {
    new Assertion(act, msg).to.be.closeTo(exp, delta);
  };

  /**
   * ### .sameMembers(set1, set2, [message])
   *
   * Asserts that `set1` and `set2` have the same members.
   * Order is not taken into account.
   *
   *     assert.sameMembers([ 1, 2, 3 ], [ 2, 1, 3 ], 'same members');
   *
   * @name sameMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @api public
   */

  assert.sameMembers = function (set1, set2, msg) {
    new Assertion(set1, msg).to.have.same.members(set2);
  }

  /**
   * ### .includeMembers(superset, subset, [message])
   *
   * Asserts that `subset` is included in `superset`.
   * Order is not taken into account.
   *
   *     assert.includeMembers([ 1, 2, 3 ], [ 2, 1 ], 'include members');
   *
   * @name includeMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @api public
   */

  assert.includeMembers = function (superset, subset, msg) {
    new Assertion(superset, msg).to.include.members(subset);
  }

  /*!
   * Undocumented / untested
   */

  assert.ifError = function (val, msg) {
    new Assertion(val, msg).to.not.be.ok;
  };

  /*!
   * Aliases.
   */

  (function alias(name, as){
    assert[as] = assert[name];
    return alias;
  })
  ('Throw', 'throw')
  ('Throw', 'throws');
};

},{}],20:[function(require,module,exports){
/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

module.exports = function (chai, util) {
  chai.expect = function (val, message) {
    return new chai.Assertion(val, message);
  };
};


},{}],21:[function(require,module,exports){
/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

module.exports = function (chai, util) {
  var Assertion = chai.Assertion;

  function loadShould () {
    // explicitly define this method as function as to have it's name to include as `ssfi`
    function shouldGetter() {
      if (this instanceof String || this instanceof Number) {
        return new Assertion(this.constructor(this), null, shouldGetter);
      } else if (this instanceof Boolean) {
        return new Assertion(this == true, null, shouldGetter);
      }
      return new Assertion(this, null, shouldGetter);
    }
    function shouldSetter(value) {
      // See https://github.com/chaijs/chai/issues/86: this makes
      // `whatever.should = someValue` actually set `someValue`, which is
      // especially useful for `global.should = require('chai').should()`.
      //
      // Note that we have to use [[DefineProperty]] instead of [[Put]]
      // since otherwise we would trigger this very setter!
      Object.defineProperty(this, 'should', {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    }
    // modify Object.prototype to have `should`
    Object.defineProperty(Object.prototype, 'should', {
      set: shouldSetter
      , get: shouldGetter
      , configurable: true
    });

    var should = {};

    should.equal = function (val1, val2, msg) {
      new Assertion(val1, msg).to.equal(val2);
    };

    should.Throw = function (fn, errt, errs, msg) {
      new Assertion(fn, msg).to.Throw(errt, errs);
    };

    should.exist = function (val, msg) {
      new Assertion(val, msg).to.exist;
    }

    // negation
    should.not = {}

    should.not.equal = function (val1, val2, msg) {
      new Assertion(val1, msg).to.not.equal(val2);
    };

    should.not.Throw = function (fn, errt, errs, msg) {
      new Assertion(fn, msg).to.not.Throw(errt, errs);
    };

    should.not.exist = function (val, msg) {
      new Assertion(val, msg).to.not.exist;
    }

    should['throw'] = should['Throw'];
    should.not['throw'] = should.not['Throw'];

    return should;
  };

  chai.should = loadShould;
  chai.Should = loadShould;
};

},{}],22:[function(require,module,exports){
/*!
 * Chai - addChainingMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependencies
 */

var transferFlags = require('./transferFlags');
var flag = require('./flag');
var config = require('../config');

/*!
 * Module variables
 */

// Check whether `__proto__` is supported
var hasProtoSupport = '__proto__' in Object;

// Without `__proto__` support, this module will need to add properties to a function.
// However, some Function.prototype methods cannot be overwritten,
// and there seems no easy cross-platform way to detect them (@see chaijs/chai/issues/69).
var excludeNames = /^(?:length|name|arguments|caller)$/;

// Cache `Function` properties
var call  = Function.prototype.call,
    apply = Function.prototype.apply;

/**
 * ### addChainableMethod (ctx, name, method, chainingBehavior)
 *
 * Adds a method to an object, such that the method can also be chained.
 *
 *     utils.addChainableMethod(chai.Assertion.prototype, 'foo', function (str) {
 *       var obj = utils.flag(this, 'object');
 *       new chai.Assertion(obj).to.be.equal(str);
 *     });
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.addChainableMethod('foo', fn, chainingBehavior);
 *
 * The result can then be used as both a method assertion, executing both `method` and
 * `chainingBehavior`, or as a language chain, which only executes `chainingBehavior`.
 *
 *     expect(fooStr).to.be.foo('bar');
 *     expect(fooStr).to.be.foo.equal('foo');
 *
 * @param {Object} ctx object to which the method is added
 * @param {String} name of method to add
 * @param {Function} method function to be used for `name`, when called
 * @param {Function} chainingBehavior function to be called every time the property is accessed
 * @name addChainableMethod
 * @api public
 */

module.exports = function (ctx, name, method, chainingBehavior) {
  if (typeof chainingBehavior !== 'function') {
    chainingBehavior = function () { };
  }

  var chainableBehavior = {
      method: method
    , chainingBehavior: chainingBehavior
  };

  // save the methods so we can overwrite them later, if we need to.
  if (!ctx.__methods) {
    ctx.__methods = {};
  }
  ctx.__methods[name] = chainableBehavior;

  Object.defineProperty(ctx, name,
    { get: function () {
        chainableBehavior.chainingBehavior.call(this);

        var assert = function assert() {
          var old_ssfi = flag(this, 'ssfi');
          if (old_ssfi && config.includeStack === false)
            flag(this, 'ssfi', assert);
          var result = chainableBehavior.method.apply(this, arguments);
          return result === undefined ? this : result;
        };

        // Use `__proto__` if available
        if (hasProtoSupport) {
          // Inherit all properties from the object by replacing the `Function` prototype
          var prototype = assert.__proto__ = Object.create(this);
          // Restore the `call` and `apply` methods from `Function`
          prototype.call = call;
          prototype.apply = apply;
        }
        // Otherwise, redefine all properties (slow!)
        else {
          var asserterNames = Object.getOwnPropertyNames(ctx);
          asserterNames.forEach(function (asserterName) {
            if (!excludeNames.test(asserterName)) {
              var pd = Object.getOwnPropertyDescriptor(ctx, asserterName);
              Object.defineProperty(assert, asserterName, pd);
            }
          });
        }

        transferFlags(this, assert);
        return assert;
      }
    , configurable: true
  });
};

},{"../config":17,"./flag":25,"./transferFlags":39}],23:[function(require,module,exports){
/*!
 * Chai - addMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

var config = require('../config');

/**
 * ### .addMethod (ctx, name, method)
 *
 * Adds a method to the prototype of an object.
 *
 *     utils.addMethod(chai.Assertion.prototype, 'foo', function (str) {
 *       var obj = utils.flag(this, 'object');
 *       new chai.Assertion(obj).to.be.equal(str);
 *     });
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.addMethod('foo', fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(fooStr).to.be.foo('bar');
 *
 * @param {Object} ctx object to which the method is added
 * @param {String} name of method to add
 * @param {Function} method function to be used for name
 * @name addMethod
 * @api public
 */
var flag = require('./flag');

module.exports = function (ctx, name, method) {
  ctx[name] = function () {
    var old_ssfi = flag(this, 'ssfi');
    if (old_ssfi && config.includeStack === false)
      flag(this, 'ssfi', ctx[name]);
    var result = method.apply(this, arguments);
    return result === undefined ? this : result;
  };
};

},{"../config":17,"./flag":25}],24:[function(require,module,exports){
/*!
 * Chai - addProperty utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### addProperty (ctx, name, getter)
 *
 * Adds a property to the prototype of an object.
 *
 *     utils.addProperty(chai.Assertion.prototype, 'foo', function () {
 *       var obj = utils.flag(this, 'object');
 *       new chai.Assertion(obj).to.be.instanceof(Foo);
 *     });
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.addProperty('foo', fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(myFoo).to.be.foo;
 *
 * @param {Object} ctx object to which the property is added
 * @param {String} name of property to add
 * @param {Function} getter function to be used for name
 * @name addProperty
 * @api public
 */

module.exports = function (ctx, name, getter) {
  Object.defineProperty(ctx, name,
    { get: function () {
        var result = getter.call(this);
        return result === undefined ? this : result;
      }
    , configurable: true
  });
};

},{}],25:[function(require,module,exports){
/*!
 * Chai - flag utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### flag(object ,key, [value])
 *
 * Get or set a flag value on an object. If a
 * value is provided it will be set, else it will
 * return the currently set value or `undefined` if
 * the value is not set.
 *
 *     utils.flag(this, 'foo', 'bar'); // setter
 *     utils.flag(this, 'foo'); // getter, returns `bar`
 *
 * @param {Object} object (constructed Assertion
 * @param {String} key
 * @param {Mixed} value (optional)
 * @name flag
 * @api private
 */

module.exports = function (obj, key, value) {
  var flags = obj.__flags || (obj.__flags = Object.create(null));
  if (arguments.length === 3) {
    flags[key] = value;
  } else {
    return flags[key];
  }
};

},{}],26:[function(require,module,exports){
/*!
 * Chai - getActual utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * # getActual(object, [actual])
 *
 * Returns the `actual` value for an Assertion
 *
 * @param {Object} object (constructed Assertion)
 * @param {Arguments} chai.Assertion.prototype.assert arguments
 */

module.exports = function (obj, args) {
  return args.length > 4 ? args[4] : obj._obj;
};

},{}],27:[function(require,module,exports){
/*!
 * Chai - getEnumerableProperties utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .getEnumerableProperties(object)
 *
 * This allows the retrieval of enumerable property names of an object,
 * inherited or not.
 *
 * @param {Object} object
 * @returns {Array}
 * @name getEnumerableProperties
 * @api public
 */

module.exports = function getEnumerableProperties(object) {
  var result = [];
  for (var name in object) {
    result.push(name);
  }
  return result;
};

},{}],28:[function(require,module,exports){
/*!
 * Chai - message composition utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependancies
 */

var flag = require('./flag')
  , getActual = require('./getActual')
  , inspect = require('./inspect')
  , objDisplay = require('./objDisplay');

/**
 * ### .getMessage(object, message, negateMessage)
 *
 * Construct the error message based on flags
 * and template tags. Template tags will return
 * a stringified inspection of the object referenced.
 *
 * Message template tags:
 * - `#{this}` current asserted object
 * - `#{act}` actual value
 * - `#{exp}` expected value
 *
 * @param {Object} object (constructed Assertion)
 * @param {Arguments} chai.Assertion.prototype.assert arguments
 * @name getMessage
 * @api public
 */

module.exports = function (obj, args) {
  var negate = flag(obj, 'negate')
    , val = flag(obj, 'object')
    , expected = args[3]
    , actual = getActual(obj, args)
    , msg = negate ? args[2] : args[1]
    , flagMsg = flag(obj, 'message');

  msg = msg || '';
  msg = msg
    .replace(/#{this}/g, objDisplay(val))
    .replace(/#{act}/g, objDisplay(actual))
    .replace(/#{exp}/g, objDisplay(expected));

  return flagMsg ? flagMsg + ': ' + msg : msg;
};

},{"./flag":25,"./getActual":26,"./inspect":33,"./objDisplay":34}],29:[function(require,module,exports){
/*!
 * Chai - getName utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * # getName(func)
 *
 * Gets the name of a function, in a cross-browser way.
 *
 * @param {Function} a function (usually a constructor)
 */

module.exports = function (func) {
  if (func.name) return func.name;

  var match = /^\s?function ([^(]*)\(/.exec(func);
  return match && match[1] ? match[1] : "";
};

},{}],30:[function(require,module,exports){
/*!
 * Chai - getPathValue utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * @see https://github.com/logicalparadox/filtr
 * MIT Licensed
 */

/**
 * ### .getPathValue(path, object)
 *
 * This allows the retrieval of values in an
 * object given a string path.
 *
 *     var obj = {
 *         prop1: {
 *             arr: ['a', 'b', 'c']
 *           , str: 'Hello'
 *         }
 *       , prop2: {
 *             arr: [ { nested: 'Universe' } ]
 *           , str: 'Hello again!'
 *         }
 *     }
 *
 * The following would be the results.
 *
 *     getPathValue('prop1.str', obj); // Hello
 *     getPathValue('prop1.att[2]', obj); // b
 *     getPathValue('prop2.arr[0].nested', obj); // Universe
 *
 * @param {String} path
 * @param {Object} object
 * @returns {Object} value or `undefined`
 * @name getPathValue
 * @api public
 */

var getPathValue = module.exports = function (path, obj) {
  var parsed = parsePath(path);
  return _getPathValue(parsed, obj);
};

/*!
 * ## parsePath(path)
 *
 * Helper function used to parse string object
 * paths. Use in conjunction with `_getPathValue`.
 *
 *      var parsed = parsePath('myobject.property.subprop');
 *
 * ### Paths:
 *
 * * Can be as near infinitely deep and nested
 * * Arrays are also valid using the formal `myobject.document[3].property`.
 *
 * @param {String} path
 * @returns {Object} parsed
 * @api private
 */

function parsePath (path) {
  var str = path.replace(/\[/g, '.[')
    , parts = str.match(/(\\\.|[^.]+?)+/g);
  return parts.map(function (value) {
    var re = /\[(\d+)\]$/
      , mArr = re.exec(value)
    if (mArr) return { i: parseFloat(mArr[1]) };
    else return { p: value };
  });
};

/*!
 * ## _getPathValue(parsed, obj)
 *
 * Helper companion function for `.parsePath` that returns
 * the value located at the parsed address.
 *
 *      var value = getPathValue(parsed, obj);
 *
 * @param {Object} parsed definition from `parsePath`.
 * @param {Object} object to search against
 * @returns {Object|Undefined} value
 * @api private
 */

function _getPathValue (parsed, obj) {
  var tmp = obj
    , res;
  for (var i = 0, l = parsed.length; i < l; i++) {
    var part = parsed[i];
    if (tmp) {
      if ('undefined' !== typeof part.p)
        tmp = tmp[part.p];
      else if ('undefined' !== typeof part.i)
        tmp = tmp[part.i];
      if (i == (l - 1)) res = tmp;
    } else {
      res = undefined;
    }
  }
  return res;
};

},{}],31:[function(require,module,exports){
/*!
 * Chai - getProperties utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .getProperties(object)
 *
 * This allows the retrieval of property names of an object, enumerable or not,
 * inherited or not.
 *
 * @param {Object} object
 * @returns {Array}
 * @name getProperties
 * @api public
 */

module.exports = function getProperties(object) {
  var result = Object.getOwnPropertyNames(subject);

  function addProperty(property) {
    if (result.indexOf(property) === -1) {
      result.push(property);
    }
  }

  var proto = Object.getPrototypeOf(subject);
  while (proto !== null) {
    Object.getOwnPropertyNames(proto).forEach(addProperty);
    proto = Object.getPrototypeOf(proto);
  }

  return result;
};

},{}],32:[function(require,module,exports){
/*!
 * chai
 * Copyright(c) 2011 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Main exports
 */

var exports = module.exports = {};

/*!
 * test utility
 */

exports.test = require('./test');

/*!
 * type utility
 */

exports.type = require('./type');

/*!
 * message utility
 */

exports.getMessage = require('./getMessage');

/*!
 * actual utility
 */

exports.getActual = require('./getActual');

/*!
 * Inspect util
 */

exports.inspect = require('./inspect');

/*!
 * Object Display util
 */

exports.objDisplay = require('./objDisplay');

/*!
 * Flag utility
 */

exports.flag = require('./flag');

/*!
 * Flag transferring utility
 */

exports.transferFlags = require('./transferFlags');

/*!
 * Deep equal utility
 */

exports.eql = require('deep-eql');

/*!
 * Deep path value
 */

exports.getPathValue = require('./getPathValue');

/*!
 * Function name
 */

exports.getName = require('./getName');

/*!
 * add Property
 */

exports.addProperty = require('./addProperty');

/*!
 * add Method
 */

exports.addMethod = require('./addMethod');

/*!
 * overwrite Property
 */

exports.overwriteProperty = require('./overwriteProperty');

/*!
 * overwrite Method
 */

exports.overwriteMethod = require('./overwriteMethod');

/*!
 * Add a chainable method
 */

exports.addChainableMethod = require('./addChainableMethod');

/*!
 * Overwrite chainable method
 */

exports.overwriteChainableMethod = require('./overwriteChainableMethod');


},{"./addChainableMethod":22,"./addMethod":23,"./addProperty":24,"./flag":25,"./getActual":26,"./getMessage":28,"./getName":29,"./getPathValue":30,"./inspect":33,"./objDisplay":34,"./overwriteChainableMethod":35,"./overwriteMethod":36,"./overwriteProperty":37,"./test":38,"./transferFlags":39,"./type":40,"deep-eql":42}],33:[function(require,module,exports){
// This is (almost) directly from Node.js utils
// https://github.com/joyent/node/blob/f8c335d0caf47f16d31413f89aa28eda3878e3aa/lib/util.js

var getName = require('./getName');
var getProperties = require('./getProperties');
var getEnumerableProperties = require('./getEnumerableProperties');

module.exports = inspect;

/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Boolean} showHidden Flag that shows hidden (not enumerable)
 *    properties of objects.
 * @param {Number} depth Depth in which to descend in object. Default is 2.
 * @param {Boolean} colors Flag to turn on ANSI escape codes to color the
 *    output. Default is false (no coloring).
 */
function inspect(obj, showHidden, depth, colors) {
  var ctx = {
    showHidden: showHidden,
    seen: [],
    stylize: function (str) { return str; }
  };
  return formatValue(ctx, obj, (typeof depth === 'undefined' ? 2 : depth));
}

// https://gist.github.com/1044128/
var getOuterHTML = function(element) {
  if ('outerHTML' in element) return element.outerHTML;
  var ns = "http://www.w3.org/1999/xhtml";
  var container = document.createElementNS(ns, '_');
  var elemProto = (window.HTMLElement || window.Element).prototype;
  var xmlSerializer = new XMLSerializer();
  var html;
  if (document.xmlVersion) {
    return xmlSerializer.serializeToString(element);
  } else {
    container.appendChild(element.cloneNode(false));
    html = container.innerHTML.replace('><', '>' + element.innerHTML + '<');
    container.innerHTML = '';
    return html;
  }
};

// Returns true if object is a DOM element.
var isDOMElement = function (object) {
  if (typeof HTMLElement === 'object') {
    return object instanceof HTMLElement;
  } else {
    return object &&
      typeof object === 'object' &&
      object.nodeType === 1 &&
      typeof object.nodeName === 'string';
  }
};

function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (value && typeof value.inspect === 'function' &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes);
    if (typeof ret !== 'string') {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // If it's DOM elem, get outer HTML.
  if (isDOMElement(value)) {
    return getOuterHTML(value);
  }

  // Look up the keys of the object.
  var visibleKeys = getEnumerableProperties(value);
  var keys = ctx.showHidden ? getProperties(value) : visibleKeys;

  // Some type of object without properties can be shortcutted.
  // In IE, errors have a single `stack` property, or if they are vanilla `Error`,
  // a `stack` plus `description` property; ignore those for consistency.
  if (keys.length === 0 || (isError(value) && (
      (keys.length === 1 && keys[0] === 'stack') ||
      (keys.length === 2 && keys[0] === 'description' && keys[1] === 'stack')
     ))) {
    if (typeof value === 'function') {
      var name = getName(value);
      var nameSuffix = name ? ': ' + name : '';
      return ctx.stylize('[Function' + nameSuffix + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toUTCString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (typeof value === 'function') {
    var name = getName(value);
    var nameSuffix = name ? ': ' + name : '';
    base = ' [Function' + nameSuffix + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    return formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  switch (typeof value) {
    case 'undefined':
      return ctx.stylize('undefined', 'undefined');

    case 'string':
      var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                               .replace(/'/g, "\\'")
                                               .replace(/\\"/g, '"') + '\'';
      return ctx.stylize(simple, 'string');

    case 'number':
      return ctx.stylize('' + value, 'number');

    case 'boolean':
      return ctx.stylize('' + value, 'boolean');
  }
  // For some reason typeof null is "object", so special case here.
  if (value === null) {
    return ctx.stylize('null', 'null');
  }
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (Object.prototype.hasOwnProperty.call(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str;
  if (value.__lookupGetter__) {
    if (value.__lookupGetter__(key)) {
      if (value.__lookupSetter__(key)) {
        str = ctx.stylize('[Getter/Setter]', 'special');
      } else {
        str = ctx.stylize('[Getter]', 'special');
      }
    } else {
      if (value.__lookupSetter__(key)) {
        str = ctx.stylize('[Setter]', 'special');
      }
    }
  }
  if (visibleKeys.indexOf(key) < 0) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(value[key]) < 0) {
      if (recurseTimes === null) {
        str = formatValue(ctx, value[key], null);
      } else {
        str = formatValue(ctx, value[key], recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (typeof name === 'undefined') {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}

function isArray(ar) {
  return Array.isArray(ar) ||
         (typeof ar === 'object' && objectToString(ar) === '[object Array]');
}

function isRegExp(re) {
  return typeof re === 'object' && objectToString(re) === '[object RegExp]';
}

function isDate(d) {
  return typeof d === 'object' && objectToString(d) === '[object Date]';
}

function isError(e) {
  return typeof e === 'object' && objectToString(e) === '[object Error]';
}

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

},{"./getEnumerableProperties":27,"./getName":29,"./getProperties":31}],34:[function(require,module,exports){
/*!
 * Chai - flag utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependancies
 */

var inspect = require('./inspect');
var config = require('../config');

/**
 * ### .objDisplay (object)
 *
 * Determines if an object or an array matches
 * criteria to be inspected in-line for error
 * messages or should be truncated.
 *
 * @param {Mixed} javascript object to inspect
 * @name objDisplay
 * @api public
 */

module.exports = function (obj) {
  var str = inspect(obj)
    , type = Object.prototype.toString.call(obj);

  if (config.truncateThreshold && str.length >= config.truncateThreshold) {
    if (type === '[object Function]') {
      return !obj.name || obj.name === ''
        ? '[Function]'
        : '[Function: ' + obj.name + ']';
    } else if (type === '[object Array]') {
      return '[ Array(' + obj.length + ') ]';
    } else if (type === '[object Object]') {
      var keys = Object.keys(obj)
        , kstr = keys.length > 2
          ? keys.splice(0, 2).join(', ') + ', ...'
          : keys.join(', ');
      return '{ Object (' + kstr + ') }';
    } else {
      return str;
    }
  } else {
    return str;
  }
};

},{"../config":17,"./inspect":33}],35:[function(require,module,exports){
/*!
 * Chai - overwriteChainableMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### overwriteChainableMethod (ctx, name, fn)
 *
 * Overwites an already existing chainable method
 * and provides access to the previous function or
 * property.  Must return functions to be used for
 * name.
 *
 *     utils.overwriteChainableMethod(chai.Assertion.prototype, 'length',
 *       function (_super) {
 *       }
 *     , function (_super) {
 *       }
 *     );
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.overwriteChainableMethod('foo', fn, fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(myFoo).to.have.length(3);
 *     expect(myFoo).to.have.length.above(3);
 *
 * @param {Object} ctx object whose method / property is to be overwritten
 * @param {String} name of method / property to overwrite
 * @param {Function} method function that returns a function to be used for name
 * @param {Function} chainingBehavior function that returns a function to be used for property
 * @name overwriteChainableMethod
 * @api public
 */

module.exports = function (ctx, name, method, chainingBehavior) {
  var chainableBehavior = ctx.__methods[name];

  var _chainingBehavior = chainableBehavior.chainingBehavior;
  chainableBehavior.chainingBehavior = function () {
    var result = chainingBehavior(_chainingBehavior).call(this);
    return result === undefined ? this : result;
  };

  var _method = chainableBehavior.method;
  chainableBehavior.method = function () {
    var result = method(_method).apply(this, arguments);
    return result === undefined ? this : result;
  };
};

},{}],36:[function(require,module,exports){
/*!
 * Chai - overwriteMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### overwriteMethod (ctx, name, fn)
 *
 * Overwites an already existing method and provides
 * access to previous function. Must return function
 * to be used for name.
 *
 *     utils.overwriteMethod(chai.Assertion.prototype, 'equal', function (_super) {
 *       return function (str) {
 *         var obj = utils.flag(this, 'object');
 *         if (obj instanceof Foo) {
 *           new chai.Assertion(obj.value).to.equal(str);
 *         } else {
 *           _super.apply(this, arguments);
 *         }
 *       }
 *     });
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.overwriteMethod('foo', fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(myFoo).to.equal('bar');
 *
 * @param {Object} ctx object whose method is to be overwritten
 * @param {String} name of method to overwrite
 * @param {Function} method function that returns a function to be used for name
 * @name overwriteMethod
 * @api public
 */

module.exports = function (ctx, name, method) {
  var _method = ctx[name]
    , _super = function () { return this; };

  if (_method && 'function' === typeof _method)
    _super = _method;

  ctx[name] = function () {
    var result = method(_super).apply(this, arguments);
    return result === undefined ? this : result;
  }
};

},{}],37:[function(require,module,exports){
/*!
 * Chai - overwriteProperty utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### overwriteProperty (ctx, name, fn)
 *
 * Overwites an already existing property getter and provides
 * access to previous value. Must return function to use as getter.
 *
 *     utils.overwriteProperty(chai.Assertion.prototype, 'ok', function (_super) {
 *       return function () {
 *         var obj = utils.flag(this, 'object');
 *         if (obj instanceof Foo) {
 *           new chai.Assertion(obj.name).to.equal('bar');
 *         } else {
 *           _super.call(this);
 *         }
 *       }
 *     });
 *
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.overwriteProperty('foo', fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(myFoo).to.be.ok;
 *
 * @param {Object} ctx object whose property is to be overwritten
 * @param {String} name of property to overwrite
 * @param {Function} getter function that returns a getter function to be used for name
 * @name overwriteProperty
 * @api public
 */

module.exports = function (ctx, name, getter) {
  var _get = Object.getOwnPropertyDescriptor(ctx, name)
    , _super = function () {};

  if (_get && 'function' === typeof _get.get)
    _super = _get.get

  Object.defineProperty(ctx, name,
    { get: function () {
        var result = getter(_super).call(this);
        return result === undefined ? this : result;
      }
    , configurable: true
  });
};

},{}],38:[function(require,module,exports){
/*!
 * Chai - test utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependancies
 */

var flag = require('./flag');

/**
 * # test(object, expression)
 *
 * Test and object for expression.
 *
 * @param {Object} object (constructed Assertion)
 * @param {Arguments} chai.Assertion.prototype.assert arguments
 */

module.exports = function (obj, args) {
  var negate = flag(obj, 'negate')
    , expr = args[0];
  return negate ? !expr : expr;
};

},{"./flag":25}],39:[function(require,module,exports){
/*!
 * Chai - transferFlags utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### transferFlags(assertion, object, includeAll = true)
 *
 * Transfer all the flags for `assertion` to `object`. If
 * `includeAll` is set to `false`, then the base Chai
 * assertion flags (namely `object`, `ssfi`, and `message`)
 * will not be transferred.
 *
 *
 *     var newAssertion = new Assertion();
 *     utils.transferFlags(assertion, newAssertion);
 *
 *     var anotherAsseriton = new Assertion(myObj);
 *     utils.transferFlags(assertion, anotherAssertion, false);
 *
 * @param {Assertion} assertion the assertion to transfer the flags from
 * @param {Object} object the object to transfer the flags too; usually a new assertion
 * @param {Boolean} includeAll
 * @name getAllFlags
 * @api private
 */

module.exports = function (assertion, object, includeAll) {
  var flags = assertion.__flags || (assertion.__flags = Object.create(null));

  if (!object.__flags) {
    object.__flags = Object.create(null);
  }

  includeAll = arguments.length === 3 ? includeAll : true;

  for (var flag in flags) {
    if (includeAll ||
        (flag !== 'object' && flag !== 'ssfi' && flag != 'message')) {
      object.__flags[flag] = flags[flag];
    }
  }
};

},{}],40:[function(require,module,exports){
/*!
 * Chai - type utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Detectable javascript natives
 */

var natives = {
    '[object Arguments]': 'arguments'
  , '[object Array]': 'array'
  , '[object Date]': 'date'
  , '[object Function]': 'function'
  , '[object Number]': 'number'
  , '[object RegExp]': 'regexp'
  , '[object String]': 'string'
};

/**
 * ### type(object)
 *
 * Better implementation of `typeof` detection that can
 * be used cross-browser. Handles the inconsistencies of
 * Array, `null`, and `undefined` detection.
 *
 *     utils.type({}) // 'object'
 *     utils.type(null) // `null'
 *     utils.type(undefined) // `undefined`
 *     utils.type([]) // `array`
 *
 * @param {Mixed} object to detect type of
 * @name type
 * @api private
 */

module.exports = function (obj) {
  var str = Object.prototype.toString.call(obj);
  if (natives[str]) return natives[str];
  if (obj === null) return 'null';
  if (obj === undefined) return 'undefined';
  if (obj === Object(obj)) return 'object';
  return typeof obj;
};

},{}],41:[function(require,module,exports){
/*!
 * assertion-error
 * Copyright(c) 2013 Jake Luer <jake@qualiancy.com>
 * MIT Licensed
 */

/*!
 * Return a function that will copy properties from
 * one object to another excluding any originally
 * listed. Returned function will create a new `{}`.
 *
 * @param {String} excluded properties ...
 * @return {Function}
 */

function exclude () {
  var excludes = [].slice.call(arguments);

  function excludeProps (res, obj) {
    Object.keys(obj).forEach(function (key) {
      if (!~excludes.indexOf(key)) res[key] = obj[key];
    });
  }

  return function extendExclude () {
    var args = [].slice.call(arguments)
      , i = 0
      , res = {};

    for (; i < args.length; i++) {
      excludeProps(res, args[i]);
    }

    return res;
  };
};

/*!
 * Primary Exports
 */

module.exports = AssertionError;

/**
 * ### AssertionError
 *
 * An extension of the JavaScript `Error` constructor for
 * assertion and validation scenarios.
 *
 * @param {String} message
 * @param {Object} properties to include (optional)
 * @param {callee} start stack function (optional)
 */

function AssertionError (message, _props, ssf) {
  var extend = exclude('name', 'message', 'stack', 'constructor', 'toJSON')
    , props = extend(_props || {});

  // default values
  this.message = message || 'Unspecified AssertionError';
  this.showDiff = false;

  // copy from properties
  for (var key in props) {
    this[key] = props[key];
  }

  // capture stack trace
  ssf = ssf || arguments.callee;
  if (ssf && Error.captureStackTrace) {
    Error.captureStackTrace(this, ssf);
  }
}

/*!
 * Inherit from Error.prototype
 */

AssertionError.prototype = Object.create(Error.prototype);

/*!
 * Statically set name
 */

AssertionError.prototype.name = 'AssertionError';

/*!
 * Ensure correct constructor
 */

AssertionError.prototype.constructor = AssertionError;

/**
 * Allow errors to be converted to JSON for static transfer.
 *
 * @param {Boolean} include stack (default: `true`)
 * @return {Object} object that can be `JSON.stringify`
 */

AssertionError.prototype.toJSON = function (stack) {
  var extend = exclude('constructor', 'toJSON', 'stack')
    , props = extend({ name: this.name }, this);

  // include stack if exists and not turned off
  if (false !== stack && this.stack) {
    props.stack = this.stack;
  }

  return props;
};

},{}],42:[function(require,module,exports){
module.exports = require('./lib/eql');

},{"./lib/eql":43}],43:[function(require,module,exports){
/*!
 * deep-eql
 * Copyright(c) 2013 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependencies
 */

var type = require('type-detect');

/*!
 * Buffer.isBuffer browser shim
 */

var Buffer;
try { Buffer = require('buffer').Buffer; }
catch(ex) {
  Buffer = {};
  Buffer.isBuffer = function() { return false; }
}

/*!
 * Primary Export
 */

module.exports = deepEqual;

/**
 * Assert super-strict (egal) equality between
 * two objects of any type.
 *
 * @param {Mixed} a
 * @param {Mixed} b
 * @param {Array} memoised (optional)
 * @return {Boolean} equal match
 */

function deepEqual(a, b, m) {
  if (sameValue(a, b)) {
    return true;
  } else if ('date' === type(a)) {
    return dateEqual(a, b);
  } else if ('regexp' === type(a)) {
    return regexpEqual(a, b);
  } else if (Buffer.isBuffer(a)) {
    return bufferEqual(a, b);
  } else if ('arguments' === type(a)) {
    return argumentsEqual(a, b, m);
  } else if (!typeEqual(a, b)) {
    return false;
  } else if (('object' !== type(a) && 'object' !== type(b))
  && ('array' !== type(a) && 'array' !== type(b))) {
    return sameValue(a, b);
  } else {
    return objectEqual(a, b, m);
  }
}

/*!
 * Strict (egal) equality test. Ensures that NaN always
 * equals NaN and `-0` does not equal `+0`.
 *
 * @param {Mixed} a
 * @param {Mixed} b
 * @return {Boolean} equal match
 */

function sameValue(a, b) {
  if (a === b) return a !== 0 || 1 / a === 1 / b;
  return a !== a && b !== b;
}

/*!
 * Compare the types of two given objects and
 * return if they are equal. Note that an Array
 * has a type of `array` (not `object`) and arguments
 * have a type of `arguments` (not `array`/`object`).
 *
 * @param {Mixed} a
 * @param {Mixed} b
 * @return {Boolean} result
 */

function typeEqual(a, b) {
  return type(a) === type(b);
}

/*!
 * Compare two Date objects by asserting that
 * the time values are equal using `saveValue`.
 *
 * @param {Date} a
 * @param {Date} b
 * @return {Boolean} result
 */

function dateEqual(a, b) {
  if ('date' !== type(b)) return false;
  return sameValue(a.getTime(), b.getTime());
}

/*!
 * Compare two regular expressions by converting them
 * to string and checking for `sameValue`.
 *
 * @param {RegExp} a
 * @param {RegExp} b
 * @return {Boolean} result
 */

function regexpEqual(a, b) {
  if ('regexp' !== type(b)) return false;
  return sameValue(a.toString(), b.toString());
}

/*!
 * Assert deep equality of two `arguments` objects.
 * Unfortunately, these must be sliced to arrays
 * prior to test to ensure no bad behavior.
 *
 * @param {Arguments} a
 * @param {Arguments} b
 * @param {Array} memoize (optional)
 * @return {Boolean} result
 */

function argumentsEqual(a, b, m) {
  if ('arguments' !== type(b)) return false;
  a = [].slice.call(a);
  b = [].slice.call(b);
  return deepEqual(a, b, m);
}

/*!
 * Get enumerable properties of a given object.
 *
 * @param {Object} a
 * @return {Array} property names
 */

function enumerable(a) {
  var res = [];
  for (var key in a) res.push(key);
  return res;
}

/*!
 * Simple equality for flat iterable objects
 * such as Arrays or Node.js buffers.
 *
 * @param {Iterable} a
 * @param {Iterable} b
 * @return {Boolean} result
 */

function iterableEqual(a, b) {
  if (a.length !==  b.length) return false;

  var i = 0;
  var match = true;

  for (; i < a.length; i++) {
    if (a[i] !== b[i]) {
      match = false;
      break;
    }
  }

  return match;
}

/*!
 * Extension to `iterableEqual` specifically
 * for Node.js Buffers.
 *
 * @param {Buffer} a
 * @param {Mixed} b
 * @return {Boolean} result
 */

function bufferEqual(a, b) {
  if (!Buffer.isBuffer(b)) return false;
  return iterableEqual(a, b);
}

/*!
 * Block for `objectEqual` ensuring non-existing
 * values don't get in.
 *
 * @param {Mixed} object
 * @return {Boolean} result
 */

function isValue(a) {
  return a !== null && a !== undefined;
}

/*!
 * Recursively check the equality of two objects.
 * Once basic sameness has been established it will
 * defer to `deepEqual` for each enumerable key
 * in the object.
 *
 * @param {Mixed} a
 * @param {Mixed} b
 * @return {Boolean} result
 */

function objectEqual(a, b, m) {
  if (!isValue(a) || !isValue(b)) {
    return false;
  }

  if (a.prototype !== b.prototype) {
    return false;
  }

  var i;
  if (m) {
    for (i = 0; i < m.length; i++) {
      if ((m[i][0] === a && m[i][1] === b)
      ||  (m[i][0] === b && m[i][1] === a)) {
        return true;
      }
    }
  } else {
    m = [];
  }

  try {
    var ka = enumerable(a);
    var kb = enumerable(b);
  } catch (ex) {
    return false;
  }

  ka.sort();
  kb.sort();

  if (!iterableEqual(ka, kb)) {
    return false;
  }

  m.push([ a, b ]);

  var key;
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!deepEqual(a[key], b[key], m)) {
      return false;
    }
  }

  return true;
}

},{"buffer":47,"type-detect":44}],44:[function(require,module,exports){
module.exports = require('./lib/type');

},{"./lib/type":45}],45:[function(require,module,exports){
/*!
 * type-detect
 * Copyright(c) 2013 jake luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Primary Exports
 */

var exports = module.exports = getType;

/*!
 * Detectable javascript natives
 */

var natives = {
    '[object Array]': 'array'
  , '[object RegExp]': 'regexp'
  , '[object Function]': 'function'
  , '[object Arguments]': 'arguments'
  , '[object Date]': 'date'
};

/**
 * ### typeOf (obj)
 *
 * Use several different techniques to determine
 * the type of object being tested.
 *
 *
 * @param {Mixed} object
 * @return {String} object type
 * @api public
 */

function getType (obj) {
  var str = Object.prototype.toString.call(obj);
  if (natives[str]) return natives[str];
  if (obj === null) return 'null';
  if (obj === undefined) return 'undefined';
  if (obj === Object(obj)) return 'object';
  return typeof obj;
}

exports.Library = Library;

/**
 * ### Library
 *
 * Create a repository for custom type detection.
 *
 * ```js
 * var lib = new type.Library;
 * ```
 *
 */

function Library () {
  this.tests = {};
}

/**
 * #### .of (obj)
 *
 * Expose replacement `typeof` detection to the library.
 *
 * ```js
 * if ('string' === lib.of('hello world')) {
 *   // ...
 * }
 * ```
 *
 * @param {Mixed} object to test
 * @return {String} type
 */

Library.prototype.of = getType;

/**
 * #### .define (type, test)
 *
 * Add a test to for the `.test()` assertion.
 *
 * Can be defined as a regular expression:
 *
 * ```js
 * lib.define('int', /^[0-9]+$/);
 * ```
 *
 * ... or as a function:
 *
 * ```js
 * lib.define('bln', function (obj) {
 *   if ('boolean' === lib.of(obj)) return true;
 *   var blns = [ 'yes', 'no', 'true', 'false', 1, 0 ];
 *   if ('string' === lib.of(obj)) obj = obj.toLowerCase();
 *   return !! ~blns.indexOf(obj);
 * });
 * ```
 *
 * @param {String} type
 * @param {RegExp|Function} test
 * @api public
 */

Library.prototype.define = function (type, test) {
  if (arguments.length === 1) return this.tests[type];
  this.tests[type] = test;
  return this;
};

/**
 * #### .test (obj, test)
 *
 * Assert that an object is of type. Will first
 * check natives, and if that does not pass it will
 * use the user defined custom tests.
 *
 * ```js
 * assert(lib.test('1', 'int'));
 * assert(lib.test('yes', 'bln'));
 * ```
 *
 * @param {Mixed} object
 * @param {String} type
 * @return {Boolean} result
 * @api public
 */

Library.prototype.test = function (obj, type) {
  if (type === getType(obj)) return true;
  var test = this.tests[type];

  if (test && 'regexp' === getType(test)) {
    return test.test(obj);
  } else if (test && 'function' === getType(test)) {
    return test(obj);
  } else {
    throw new ReferenceError('Type test "' + type + '" not defined or invalid.');
  }
};

},{}],46:[function(require,module,exports){

},{}],47:[function(require,module,exports){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = Buffer
exports.INSPECT_MAX_BYTES = 50
Buffer.poolSize = 8192

/**
 * If `TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Note:
 *
 * - Implementation must support adding new properties to `Uint8Array` instances.
 *   Firefox 4-29 lacked support, fixed in Firefox 30+.
 *   See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *  - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *  - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *    incorrect length in some situations.
 *
 * We detect these buggy browsers and set `TYPED_ARRAY_SUPPORT` to `false` so they will
 * get the Object implementation, which is slower but will work correctly.
 */
var TYPED_ARRAY_SUPPORT = (function () {
  try {
    var buf = new ArrayBuffer(0)
    var arr = new Uint8Array(buf)
    arr.foo = function () { return 42 }
    return 42 === arr.foo() && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        new Uint8Array(1).subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
})()

/**
 * Class: Buffer
 * =============
 *
 * The Buffer constructor returns instances of `Uint8Array` that are augmented
 * with function properties for all the node `Buffer` API functions. We use
 * `Uint8Array` so that square bracket notation works as expected -- it returns
 * a single octet.
 *
 * By augmenting the instances, we can avoid modifying the `Uint8Array`
 * prototype.
 */
function Buffer (subject, encoding, noZero) {
  if (!(this instanceof Buffer))
    return new Buffer(subject, encoding, noZero)

  var type = typeof subject

  // Find the length
  var length
  if (type === 'number')
    length = subject > 0 ? subject >>> 0 : 0
  else if (type === 'string') {
    if (encoding === 'base64')
      subject = base64clean(subject)
    length = Buffer.byteLength(subject, encoding)
  } else if (type === 'object' && subject !== null) { // assume object is array-like
    if (subject.type === 'Buffer' && isArray(subject.data))
      subject = subject.data
    length = +subject.length > 0 ? Math.floor(+subject.length) : 0
  } else
    throw new Error('First argument needs to be a number, array or string.')

  var buf
  if (TYPED_ARRAY_SUPPORT) {
    // Preferred: Return an augmented `Uint8Array` instance for best performance
    buf = Buffer._augment(new Uint8Array(length))
  } else {
    // Fallback: Return THIS instance of Buffer (created by `new`)
    buf = this
    buf.length = length
    buf._isBuffer = true
  }

  var i
  if (TYPED_ARRAY_SUPPORT && typeof subject.byteLength === 'number') {
    // Speed optimization -- use set if we're copying from a typed array
    buf._set(subject)
  } else if (isArrayish(subject)) {
    // Treat array-ish objects as a byte array
    if (Buffer.isBuffer(subject)) {
      for (i = 0; i < length; i++)
        buf[i] = subject.readUInt8(i)
    } else {
      for (i = 0; i < length; i++)
        buf[i] = ((subject[i] % 256) + 256) % 256
    }
  } else if (type === 'string') {
    buf.write(subject, 0, encoding)
  } else if (type === 'number' && !TYPED_ARRAY_SUPPORT && !noZero) {
    for (i = 0; i < length; i++) {
      buf[i] = 0
    }
  }

  return buf
}

// STATIC METHODS
// ==============

Buffer.isEncoding = function (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'raw':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.isBuffer = function (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.byteLength = function (str, encoding) {
  var ret
  str = str.toString()
  switch (encoding || 'utf8') {
    case 'hex':
      ret = str.length / 2
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8ToBytes(str).length
      break
    case 'ascii':
    case 'binary':
    case 'raw':
      ret = str.length
      break
    case 'base64':
      ret = base64ToBytes(str).length
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = str.length * 2
      break
    default:
      throw new Error('Unknown encoding')
  }
  return ret
}

Buffer.concat = function (list, totalLength) {
  assert(isArray(list), 'Usage: Buffer.concat(list[, length])')

  if (list.length === 0) {
    return new Buffer(0)
  } else if (list.length === 1) {
    return list[0]
  }

  var i
  if (totalLength === undefined) {
    totalLength = 0
    for (i = 0; i < list.length; i++) {
      totalLength += list[i].length
    }
  }

  var buf = new Buffer(totalLength)
  var pos = 0
  for (i = 0; i < list.length; i++) {
    var item = list[i]
    item.copy(buf, pos)
    pos += item.length
  }
  return buf
}

Buffer.compare = function (a, b) {
  assert(Buffer.isBuffer(a) && Buffer.isBuffer(b), 'Arguments must be Buffers')
  var x = a.length
  var y = b.length
  for (var i = 0, len = Math.min(x, y); i < len && a[i] === b[i]; i++) {}
  if (i !== len) {
    x = a[i]
    y = b[i]
  }
  if (x < y) {
    return -1
  }
  if (y < x) {
    return 1
  }
  return 0
}

// BUFFER INSTANCE METHODS
// =======================

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  assert(strLen % 2 === 0, 'Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; i++) {
    var byte = parseInt(string.substr(i * 2, 2), 16)
    assert(!isNaN(byte), 'Invalid hex string')
    buf[offset + i] = byte
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  var charsWritten = blitBuffer(utf8ToBytes(string), buf, offset, length)
  return charsWritten
}

function asciiWrite (buf, string, offset, length) {
  var charsWritten = blitBuffer(asciiToBytes(string), buf, offset, length)
  return charsWritten
}

function binaryWrite (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  var charsWritten = blitBuffer(base64ToBytes(string), buf, offset, length)
  return charsWritten
}

function utf16leWrite (buf, string, offset, length) {
  var charsWritten = blitBuffer(utf16leToBytes(string), buf, offset, length)
  return charsWritten
}

Buffer.prototype.write = function (string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length
      length = undefined
    }
  } else {  // legacy
    var swap = encoding
    encoding = offset
    offset = length
    length = swap
  }

  offset = Number(offset) || 0
  var remaining = this.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase()

  var ret
  switch (encoding) {
    case 'hex':
      ret = hexWrite(this, string, offset, length)
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8Write(this, string, offset, length)
      break
    case 'ascii':
      ret = asciiWrite(this, string, offset, length)
      break
    case 'binary':
      ret = binaryWrite(this, string, offset, length)
      break
    case 'base64':
      ret = base64Write(this, string, offset, length)
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = utf16leWrite(this, string, offset, length)
      break
    default:
      throw new Error('Unknown encoding')
  }
  return ret
}

Buffer.prototype.toString = function (encoding, start, end) {
  var self = this

  encoding = String(encoding || 'utf8').toLowerCase()
  start = Number(start) || 0
  end = (end === undefined) ? self.length : Number(end)

  // Fastpath empty strings
  if (end === start)
    return ''

  var ret
  switch (encoding) {
    case 'hex':
      ret = hexSlice(self, start, end)
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8Slice(self, start, end)
      break
    case 'ascii':
      ret = asciiSlice(self, start, end)
      break
    case 'binary':
      ret = binarySlice(self, start, end)
      break
    case 'base64':
      ret = base64Slice(self, start, end)
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = utf16leSlice(self, start, end)
      break
    default:
      throw new Error('Unknown encoding')
  }
  return ret
}

Buffer.prototype.toJSON = function () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

Buffer.prototype.equals = function (b) {
  assert(Buffer.isBuffer(b), 'Argument must be a Buffer')
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.compare = function (b) {
  assert(Buffer.isBuffer(b), 'Argument must be a Buffer')
  return Buffer.compare(this, b)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function (target, target_start, start, end) {
  var source = this

  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (!target_start) target_start = 0

  // Copy 0 bytes; we're done
  if (end === start) return
  if (target.length === 0 || source.length === 0) return

  // Fatal error conditions
  assert(end >= start, 'sourceEnd < sourceStart')
  assert(target_start >= 0 && target_start < target.length,
      'targetStart out of bounds')
  assert(start >= 0 && start < source.length, 'sourceStart out of bounds')
  assert(end >= 0 && end <= source.length, 'sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length)
    end = this.length
  if (target.length - target_start < end - start)
    end = target.length - target_start + start

  var len = end - start

  if (len < 100 || !TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < len; i++) {
      target[i + target_start] = this[i + start]
    }
  } else {
    target._set(this.subarray(start, start + len), target_start)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  var res = ''
  var tmp = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    if (buf[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i])
      tmp = ''
    } else {
      tmp += '%' + buf[i].toString(16)
    }
  }

  return res + decodeUtf8Char(tmp)
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function binarySlice (buf, start, end) {
  return asciiSlice(buf, start, end)
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; i++) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len;
    if (start < 0)
      start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0)
      end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start)
    end = start

  if (TYPED_ARRAY_SUPPORT) {
    return Buffer._augment(this.subarray(start, end))
  } else {
    var sliceLen = end - start
    var newBuf = new Buffer(sliceLen, undefined, true)
    for (var i = 0; i < sliceLen; i++) {
      newBuf[i] = this[i + start]
    }
    return newBuf
  }
}

// `get` will be removed in Node 0.13+
Buffer.prototype.get = function (offset) {
  console.log('.get() is deprecated. Access using array indexes instead.')
  return this.readUInt8(offset)
}

// `set` will be removed in Node 0.13+
Buffer.prototype.set = function (v, offset) {
  console.log('.set() is deprecated. Access using array indexes instead.')
  return this.writeUInt8(v, offset)
}

Buffer.prototype.readUInt8 = function (offset, noAssert) {
  if (!noAssert) {
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < this.length, 'Trying to read beyond buffer length')
  }

  if (offset >= this.length)
    return

  return this[offset]
}

function readUInt16 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val
  if (littleEndian) {
    val = buf[offset]
    if (offset + 1 < len)
      val |= buf[offset + 1] << 8
  } else {
    val = buf[offset] << 8
    if (offset + 1 < len)
      val |= buf[offset + 1]
  }
  return val
}

Buffer.prototype.readUInt16LE = function (offset, noAssert) {
  return readUInt16(this, offset, true, noAssert)
}

Buffer.prototype.readUInt16BE = function (offset, noAssert) {
  return readUInt16(this, offset, false, noAssert)
}

function readUInt32 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val
  if (littleEndian) {
    if (offset + 2 < len)
      val = buf[offset + 2] << 16
    if (offset + 1 < len)
      val |= buf[offset + 1] << 8
    val |= buf[offset]
    if (offset + 3 < len)
      val = val + (buf[offset + 3] << 24 >>> 0)
  } else {
    if (offset + 1 < len)
      val = buf[offset + 1] << 16
    if (offset + 2 < len)
      val |= buf[offset + 2] << 8
    if (offset + 3 < len)
      val |= buf[offset + 3]
    val = val + (buf[offset] << 24 >>> 0)
  }
  return val
}

Buffer.prototype.readUInt32LE = function (offset, noAssert) {
  return readUInt32(this, offset, true, noAssert)
}

Buffer.prototype.readUInt32BE = function (offset, noAssert) {
  return readUInt32(this, offset, false, noAssert)
}

Buffer.prototype.readInt8 = function (offset, noAssert) {
  if (!noAssert) {
    assert(offset !== undefined && offset !== null,
        'missing offset')
    assert(offset < this.length, 'Trying to read beyond buffer length')
  }

  if (offset >= this.length)
    return

  var neg = this[offset] & 0x80
  if (neg)
    return (0xff - this[offset] + 1) * -1
  else
    return this[offset]
}

function readInt16 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val = readUInt16(buf, offset, littleEndian, true)
  var neg = val & 0x8000
  if (neg)
    return (0xffff - val + 1) * -1
  else
    return val
}

Buffer.prototype.readInt16LE = function (offset, noAssert) {
  return readInt16(this, offset, true, noAssert)
}

Buffer.prototype.readInt16BE = function (offset, noAssert) {
  return readInt16(this, offset, false, noAssert)
}

function readInt32 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val = readUInt32(buf, offset, littleEndian, true)
  var neg = val & 0x80000000
  if (neg)
    return (0xffffffff - val + 1) * -1
  else
    return val
}

Buffer.prototype.readInt32LE = function (offset, noAssert) {
  return readInt32(this, offset, true, noAssert)
}

Buffer.prototype.readInt32BE = function (offset, noAssert) {
  return readInt32(this, offset, false, noAssert)
}

function readFloat (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  return ieee754.read(buf, offset, littleEndian, 23, 4)
}

Buffer.prototype.readFloatLE = function (offset, noAssert) {
  return readFloat(this, offset, true, noAssert)
}

Buffer.prototype.readFloatBE = function (offset, noAssert) {
  return readFloat(this, offset, false, noAssert)
}

function readDouble (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset + 7 < buf.length, 'Trying to read beyond buffer length')
  }

  return ieee754.read(buf, offset, littleEndian, 52, 8)
}

Buffer.prototype.readDoubleLE = function (offset, noAssert) {
  return readDouble(this, offset, true, noAssert)
}

Buffer.prototype.readDoubleBE = function (offset, noAssert) {
  return readDouble(this, offset, false, noAssert)
}

Buffer.prototype.writeUInt8 = function (value, offset, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < this.length, 'trying to write beyond buffer length')
    verifuint(value, 0xff)
  }

  if (offset >= this.length) return

  this[offset] = value
  return offset + 1
}

function writeUInt16 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'trying to write beyond buffer length')
    verifuint(value, 0xffff)
  }

  var len = buf.length
  if (offset >= len)
    return

  for (var i = 0, j = Math.min(len - offset, 2); i < j; i++) {
    buf[offset + i] =
        (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
            (littleEndian ? i : 1 - i) * 8
  }
  return offset + 2
}

Buffer.prototype.writeUInt16LE = function (value, offset, noAssert) {
  return writeUInt16(this, value, offset, true, noAssert)
}

Buffer.prototype.writeUInt16BE = function (value, offset, noAssert) {
  return writeUInt16(this, value, offset, false, noAssert)
}

function writeUInt32 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'trying to write beyond buffer length')
    verifuint(value, 0xffffffff)
  }

  var len = buf.length
  if (offset >= len)
    return

  for (var i = 0, j = Math.min(len - offset, 4); i < j; i++) {
    buf[offset + i] =
        (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
  return offset + 4
}

Buffer.prototype.writeUInt32LE = function (value, offset, noAssert) {
  return writeUInt32(this, value, offset, true, noAssert)
}

Buffer.prototype.writeUInt32BE = function (value, offset, noAssert) {
  return writeUInt32(this, value, offset, false, noAssert)
}

Buffer.prototype.writeInt8 = function (value, offset, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < this.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7f, -0x80)
  }

  if (offset >= this.length)
    return

  if (value >= 0)
    this.writeUInt8(value, offset, noAssert)
  else
    this.writeUInt8(0xff + value + 1, offset, noAssert)
  return offset + 1
}

function writeInt16 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7fff, -0x8000)
  }

  var len = buf.length
  if (offset >= len)
    return

  if (value >= 0)
    writeUInt16(buf, value, offset, littleEndian, noAssert)
  else
    writeUInt16(buf, 0xffff + value + 1, offset, littleEndian, noAssert)
  return offset + 2
}

Buffer.prototype.writeInt16LE = function (value, offset, noAssert) {
  return writeInt16(this, value, offset, true, noAssert)
}

Buffer.prototype.writeInt16BE = function (value, offset, noAssert) {
  return writeInt16(this, value, offset, false, noAssert)
}

function writeInt32 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7fffffff, -0x80000000)
  }

  var len = buf.length
  if (offset >= len)
    return

  if (value >= 0)
    writeUInt32(buf, value, offset, littleEndian, noAssert)
  else
    writeUInt32(buf, 0xffffffff + value + 1, offset, littleEndian, noAssert)
  return offset + 4
}

Buffer.prototype.writeInt32LE = function (value, offset, noAssert) {
  return writeInt32(this, value, offset, true, noAssert)
}

Buffer.prototype.writeInt32BE = function (value, offset, noAssert) {
  return writeInt32(this, value, offset, false, noAssert)
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to write beyond buffer length')
    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }

  var len = buf.length
  if (offset >= len)
    return

  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 7 < buf.length,
        'Trying to write beyond buffer length')
    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }

  var len = buf.length
  if (offset >= len)
    return

  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function (value, start, end) {
  if (!value) value = 0
  if (!start) start = 0
  if (!end) end = this.length

  assert(end >= start, 'end < start')

  // Fill 0 bytes; we're done
  if (end === start) return
  if (this.length === 0) return

  assert(start >= 0 && start < this.length, 'start out of bounds')
  assert(end >= 0 && end <= this.length, 'end out of bounds')

  var i
  if (typeof value === 'number') {
    for (i = start; i < end; i++) {
      this[i] = value
    }
  } else {
    var bytes = utf8ToBytes(value.toString())
    var len = bytes.length
    for (i = start; i < end; i++) {
      this[i] = bytes[i % len]
    }
  }

  return this
}

Buffer.prototype.inspect = function () {
  var out = []
  var len = this.length
  for (var i = 0; i < len; i++) {
    out[i] = toHex(this[i])
    if (i === exports.INSPECT_MAX_BYTES) {
      out[i + 1] = '...'
      break
    }
  }
  return '<Buffer ' + out.join(' ') + '>'
}

/**
 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
 */
Buffer.prototype.toArrayBuffer = function () {
  if (typeof Uint8Array !== 'undefined') {
    if (TYPED_ARRAY_SUPPORT) {
      return (new Buffer(this)).buffer
    } else {
      var buf = new Uint8Array(this.length)
      for (var i = 0, len = buf.length; i < len; i += 1) {
        buf[i] = this[i]
      }
      return buf.buffer
    }
  } else {
    throw new Error('Buffer.toArrayBuffer not supported in this browser')
  }
}

// HELPER FUNCTIONS
// ================

var BP = Buffer.prototype

/**
 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
 */
Buffer._augment = function (arr) {
  arr._isBuffer = true

  // save reference to original Uint8Array get/set methods before overwriting
  arr._get = arr.get
  arr._set = arr.set

  // deprecated, will be removed in node 0.13+
  arr.get = BP.get
  arr.set = BP.set

  arr.write = BP.write
  arr.toString = BP.toString
  arr.toLocaleString = BP.toString
  arr.toJSON = BP.toJSON
  arr.equals = BP.equals
  arr.compare = BP.compare
  arr.copy = BP.copy
  arr.slice = BP.slice
  arr.readUInt8 = BP.readUInt8
  arr.readUInt16LE = BP.readUInt16LE
  arr.readUInt16BE = BP.readUInt16BE
  arr.readUInt32LE = BP.readUInt32LE
  arr.readUInt32BE = BP.readUInt32BE
  arr.readInt8 = BP.readInt8
  arr.readInt16LE = BP.readInt16LE
  arr.readInt16BE = BP.readInt16BE
  arr.readInt32LE = BP.readInt32LE
  arr.readInt32BE = BP.readInt32BE
  arr.readFloatLE = BP.readFloatLE
  arr.readFloatBE = BP.readFloatBE
  arr.readDoubleLE = BP.readDoubleLE
  arr.readDoubleBE = BP.readDoubleBE
  arr.writeUInt8 = BP.writeUInt8
  arr.writeUInt16LE = BP.writeUInt16LE
  arr.writeUInt16BE = BP.writeUInt16BE
  arr.writeUInt32LE = BP.writeUInt32LE
  arr.writeUInt32BE = BP.writeUInt32BE
  arr.writeInt8 = BP.writeInt8
  arr.writeInt16LE = BP.writeInt16LE
  arr.writeInt16BE = BP.writeInt16BE
  arr.writeInt32LE = BP.writeInt32LE
  arr.writeInt32BE = BP.writeInt32BE
  arr.writeFloatLE = BP.writeFloatLE
  arr.writeFloatBE = BP.writeFloatBE
  arr.writeDoubleLE = BP.writeDoubleLE
  arr.writeDoubleBE = BP.writeDoubleBE
  arr.fill = BP.fill
  arr.inspect = BP.inspect
  arr.toArrayBuffer = BP.toArrayBuffer

  return arr
}

var INVALID_BASE64_RE = /[^+\/0-9A-z]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function isArray (subject) {
  return (Array.isArray || function (subject) {
    return Object.prototype.toString.call(subject) === '[object Array]'
  })(subject)
}

function isArrayish (subject) {
  return isArray(subject) || Buffer.isBuffer(subject) ||
      subject && typeof subject === 'object' &&
      typeof subject.length === 'number'
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    var b = str.charCodeAt(i)
    if (b <= 0x7F) {
      byteArray.push(b)
    } else {
      var start = i
      if (b >= 0xD800 && b <= 0xDFFF) i++
      var h = encodeURIComponent(str.slice(start, i+1)).substr(1).split('%')
      for (var j = 0; j < h.length; j++) {
        byteArray.push(parseInt(h[j], 16))
      }
    }
  }
  return byteArray
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(str)
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; i++) {
    if ((i + offset >= dst.length) || (i >= src.length))
      break
    dst[i + offset] = src[i]
  }
  return i
}

function decodeUtf8Char (str) {
  try {
    return decodeURIComponent(str)
  } catch (err) {
    return String.fromCharCode(0xFFFD) // UTF 8 invalid char
  }
}

/*
 * We have to make sure that the value is a valid integer. This means that it
 * is non-negative. It has no fractional component and that it does not
 * exceed the maximum allowed value.
 */
function verifuint (value, max) {
  assert(typeof value === 'number', 'cannot write a non-number as a number')
  assert(value >= 0, 'specified a negative value for writing an unsigned value')
  assert(value <= max, 'value is larger than maximum value for type')
  assert(Math.floor(value) === value, 'value has a fractional component')
}

function verifsint (value, max, min) {
  assert(typeof value === 'number', 'cannot write a non-number as a number')
  assert(value <= max, 'value larger than maximum allowed value')
  assert(value >= min, 'value smaller than minimum allowed value')
  assert(Math.floor(value) === value, 'value has a fractional component')
}

function verifIEEE754 (value, max, min) {
  assert(typeof value === 'number', 'cannot write a non-number as a number')
  assert(value <= max, 'value larger than maximum allowed value')
  assert(value >= min, 'value smaller than minimum allowed value')
}

function assert (test, message) {
  if (!test) throw new Error(message || 'Failed assertion')
}

},{"base64-js":48,"ieee754":49}],48:[function(require,module,exports){
var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

;(function (exports) {
	'use strict';

  var Arr = (typeof Uint8Array !== 'undefined')
    ? Uint8Array
    : Array

	var PLUS   = '+'.charCodeAt(0)
	var SLASH  = '/'.charCodeAt(0)
	var NUMBER = '0'.charCodeAt(0)
	var LOWER  = 'a'.charCodeAt(0)
	var UPPER  = 'A'.charCodeAt(0)

	function decode (elt) {
		var code = elt.charCodeAt(0)
		if (code === PLUS)
			return 62 // '+'
		if (code === SLASH)
			return 63 // '/'
		if (code < NUMBER)
			return -1 //no match
		if (code < NUMBER + 10)
			return code - NUMBER + 26 + 26
		if (code < UPPER + 26)
			return code - UPPER
		if (code < LOWER + 26)
			return code - LOWER + 26
	}

	function b64ToByteArray (b64) {
		var i, j, l, tmp, placeHolders, arr

		if (b64.length % 4 > 0) {
			throw new Error('Invalid string. Length must be a multiple of 4')
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		var len = b64.length
		placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

		// base64 is 4/3 + up to two characters of the original data
		arr = new Arr(b64.length * 3 / 4 - placeHolders)

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length

		var L = 0

		function push (v) {
			arr[L++] = v
		}

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
			push((tmp & 0xFF0000) >> 16)
			push((tmp & 0xFF00) >> 8)
			push(tmp & 0xFF)
		}

		if (placeHolders === 2) {
			tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
			push(tmp & 0xFF)
		} else if (placeHolders === 1) {
			tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
			push((tmp >> 8) & 0xFF)
			push(tmp & 0xFF)
		}

		return arr
	}

	function uint8ToBase64 (uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length

		function encode (num) {
			return lookup.charAt(num)
		}

		function tripletToBase64 (num) {
			return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
		}

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
			output += tripletToBase64(temp)
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1]
				output += encode(temp >> 2)
				output += encode((temp << 4) & 0x3F)
				output += '=='
				break
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
				output += encode(temp >> 10)
				output += encode((temp >> 4) & 0x3F)
				output += encode((temp << 2) & 0x3F)
				output += '='
				break
		}

		return output
	}

	exports.toByteArray = b64ToByteArray
	exports.fromByteArray = uint8ToBase64
}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))

},{}],49:[function(require,module,exports){
exports.read = function(buffer, offset, isLE, mLen, nBytes) {
  var e, m,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      nBits = -7,
      i = isLE ? (nBytes - 1) : 0,
      d = isLE ? -1 : 1,
      s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity);
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
      i = isLE ? 0 : (nBytes - 1),
      d = isLE ? 1 : -1,
      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);

  buffer[offset + i - d] |= s * 128;
};

},{}],50:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this,require("+NscNm"))
},{"+NscNm":51}],51:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            var source = ev.source;
            if ((source === window || source === null) && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}],52:[function(require,module,exports){
/*
 Copyright 2013 Daniel Wirtz <dcode@dcode.io>

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 */

/**
 * @license ProtoBuf.js (c) 2013 Daniel Wirtz <dcode@dcode.io>
 * Released under the Apache License, Version 2.0
 * see: https://github.com/dcodeIO/ProtoBuf.js for details
 */
(function(global) {
    "use strict";

    function init(ByteBuffer) {

        /**
         * The ProtoBuf namespace.
         * @exports ProtoBuf
         * @namespace
         * @expose
         */
        var ProtoBuf = {};

        /**
         * ProtoBuf.js version.
         * @type {string}
         * @const
         * @expose
         */
        ProtoBuf.VERSION = "3.2.1";

        /**
         * Wire types.
         * @type {Object.<string,number>}
         * @const
         * @expose
         */
        ProtoBuf.WIRE_TYPES = {};

        /**
         * Varint wire type.
         * @type {number}
         * @expose
         */
        ProtoBuf.WIRE_TYPES.VARINT = 0;

        /**
         * Fixed 64 bits wire type.
         * @type {number}
         * @const
         * @expose
         */
        ProtoBuf.WIRE_TYPES.BITS64 = 1;

        /**
         * Length delimited wire type.
         * @type {number}
         * @const
         * @expose
         */
        ProtoBuf.WIRE_TYPES.LDELIM = 2;

        /**
         * Start group wire type.
         * @type {number}
         * @const
         * @expose
         */
        ProtoBuf.WIRE_TYPES.STARTGROUP = 3;

        /**
         * End group wire type.
         * @type {number}
         * @const
         * @expose
         */
        ProtoBuf.WIRE_TYPES.ENDGROUP = 4;

        /**
         * Fixed 32 bits wire type.
         * @type {number}
         * @const
         * @expose
         */
        ProtoBuf.WIRE_TYPES.BITS32 = 5;

        /**
         * Packable wire types.
         * @type {!Array.<number>}
         * @const
         * @expose
         */
        ProtoBuf.PACKABLE_WIRE_TYPES = [
            ProtoBuf.WIRE_TYPES.VARINT,
            ProtoBuf.WIRE_TYPES.BITS64,
            ProtoBuf.WIRE_TYPES.BITS32
        ];

        /**
         * Types.
         * @dict
         * @type {Object.<string,{name: string, wireType: number}>}
         * @const
         * @expose
         */
        ProtoBuf.TYPES = {
            // According to the protobuf spec.
            "int32": {
                name: "int32",
                wireType: ProtoBuf.WIRE_TYPES.VARINT
            },
            "uint32": {
                name: "uint32",
                wireType: ProtoBuf.WIRE_TYPES.VARINT
            },
            "sint32": {
                name: "sint32",
                wireType: ProtoBuf.WIRE_TYPES.VARINT
            },
            "int64": {
                name: "int64",
                wireType: ProtoBuf.WIRE_TYPES.VARINT
            },
            "uint64": {
                name: "uint64",
                wireType: ProtoBuf.WIRE_TYPES.VARINT
            },
            "sint64": {
                name: "sint64",
                wireType: ProtoBuf.WIRE_TYPES.VARINT
            },
            "bool": {
                name: "bool",
                wireType: ProtoBuf.WIRE_TYPES.VARINT
            },
            "double": {
                name: "double",
                wireType: ProtoBuf.WIRE_TYPES.BITS64
            },
            "string": {
                name: "string",
                wireType: ProtoBuf.WIRE_TYPES.LDELIM
            },
            "bytes": {
                name: "bytes",
                wireType: ProtoBuf.WIRE_TYPES.LDELIM
            },
            "fixed32": {
                name: "fixed32",
                wireType: ProtoBuf.WIRE_TYPES.BITS32
            },
            "sfixed32": {
                name: "sfixed32",
                wireType: ProtoBuf.WIRE_TYPES.BITS32
            },
            "fixed64": {
                name: "fixed64",
                wireType: ProtoBuf.WIRE_TYPES.BITS64
            },
            "sfixed64": {
                name: "sfixed64",
                wireType: ProtoBuf.WIRE_TYPES.BITS64
            },
            "float": {
                name: "float",
                wireType: ProtoBuf.WIRE_TYPES.BITS32
            },
            "enum": {
                name: "enum",
                wireType: ProtoBuf.WIRE_TYPES.VARINT
            },
            "message": {
                name: "message",
                wireType: ProtoBuf.WIRE_TYPES.LDELIM
            },
            "group": {
                name: "group",
                wireType: ProtoBuf.WIRE_TYPES.STARTGROUP
            }
        };

        /**
         * Minimum field id.
         * @type {number}
         * @const
         * @expose
         */
        ProtoBuf.ID_MIN = 1;

        /**
         * Maximum field id.
         * @type {number}
         * @const
         * @expose
         */
        ProtoBuf.ID_MAX = 0x1FFFFFFF;

        /**
         * @type {!function(new: ByteBuffer, ...[*])}
         * @expose
         */
        ProtoBuf.ByteBuffer = ByteBuffer;

        /**
         * @type {?function(new: Long, ...[*])}
         * @expose
         */
        ProtoBuf.Long = ByteBuffer.Long || null;

        /**
         * If set to `true`, field names will be converted from underscore notation to camel case. Defaults to `false`.
         *  Must be set prior to parsing.
         * @type {boolean}
         * @expose
         */
        ProtoBuf.convertFieldsToCamelCase = false;

        /**
         * @alias ProtoBuf.Util
         * @expose
         */
        ProtoBuf.Util = (function() {
            "use strict";

            // Object.create polyfill
            // ref: https://developer.mozilla.org/de/docs/JavaScript/Reference/Global_Objects/Object/create
            if (!Object.create)
                /** @expose */
                Object.create = function (o) {
                    if (arguments.length > 1)
                        throw Error('Object.create polyfill only accepts the first parameter.');
                    function F() {}
                    F.prototype = o;
                    return new F();
                };

            /**
             * ProtoBuf utilities.
             * @exports ProtoBuf.Util
             * @namespace
             */
            var Util = {};

            /**
             * Flag if running in node (fs is available) or not.
             * @type {boolean}
             * @const
             * @expose
             */
            Util.IS_NODE = false;
            try {
                // There is no reliable way to detect node.js as an environment, so our
                // best bet is to feature-detect what we actually need.
                Util.IS_NODE =
                    typeof require === 'function' &&
                    typeof require("fs").readFileSync === 'function' &&
                    typeof require("path").resolve === 'function';
            } catch (e) {}

            /**
             * Constructs a XMLHttpRequest object.
             * @return {XMLHttpRequest}
             * @throws {Error} If XMLHttpRequest is not supported
             * @expose
             */
            Util.XHR = function() {
                // No dependencies please, ref: http://www.quirksmode.org/js/xmlhttp.html
                var XMLHttpFactories = [
                    function () {return new XMLHttpRequest()},
                    function () {return new ActiveXObject("Msxml2.XMLHTTP")},
                    function () {return new ActiveXObject("Msxml3.XMLHTTP")},
                    function () {return new ActiveXObject("Microsoft.XMLHTTP")}
                ];
                /** @type {?XMLHttpRequest} */
                var xhr = null;
                for (var i=0;i<XMLHttpFactories.length;i++) {
                    try { xhr = XMLHttpFactories[i](); }
                    catch (e) { continue; }
                    break;
                }
                if (!xhr)
                    throw Error("XMLHttpRequest is not supported");
                return xhr;
            };

            /**
             * Fetches a resource.
             * @param {string} path Resource path
             * @param {function(?string)=} callback Callback receiving the resource's contents. If omitted the resource will
             *   be fetched synchronously. If the request failed, contents will be null.
             * @return {?string|undefined} Resource contents if callback is omitted (null if the request failed), else undefined.
             * @expose
             */
            Util.fetch = function(path, callback) {
                if (callback && typeof callback != 'function')
                    callback = null;
                if (Util.IS_NODE) {
                    if (callback) {
                        require("fs").readFile(path, function(err, data) {
                            if (err)
                                callback(null);
                            else
                                callback(""+data);
                        });
                    } else
                        try {
                            return require("fs").readFileSync(path);
                        } catch (e) {
                            return null;
                        }
                } else {
                    var xhr = Util.XHR();
                    xhr.open('GET', path, callback ? true : false);
                    // xhr.setRequestHeader('User-Agent', 'XMLHTTP/1.0');
                    xhr.setRequestHeader('Accept', 'text/plain');
                    if (typeof xhr.overrideMimeType === 'function') xhr.overrideMimeType('text/plain');
                    if (callback) {
                        xhr.onreadystatechange = function() {
                            if (xhr.readyState != 4) return;
                            if (/* remote */ xhr.status == 200 || /* local */ (xhr.status == 0 && typeof xhr.responseText === 'string'))
                                callback(xhr.responseText);
                            else
                                callback(null);
                        };
                        if (xhr.readyState == 4)
                            return;
                        xhr.send(null);
                    } else {
                        xhr.send(null);
                        if (/* remote */ xhr.status == 200 || /* local */ (xhr.status == 0 && typeof xhr.responseText === 'string'))
                            return xhr.responseText;
                        return null;
                    }
                }
            };

            /**
             * Tests if an object is an array.
             * @function
             * @param {*} obj Object to test
             * @returns {boolean} true if it is an array, else false
             * @expose
             */
            Util.isArray = Array.isArray || function(obj) {
                return Object.prototype.toString.call(obj) === "[object Array]";
            };

            return Util;
        })();

        /**
         * Language expressions.
         * @exports ProtoBuf.Lang
         * @type {Object.<string,string|RegExp>}
         * @namespace
         * @expose
         */
        ProtoBuf.Lang = {
            OPEN: "{",
            CLOSE: "}",
            OPTOPEN: "[",
            OPTCLOSE: "]",
            OPTEND: ",",
            EQUAL: "=",
            END: ";",
            STRINGOPEN: '"',
            STRINGCLOSE: '"',
            STRINGOPEN_SQ: "'",
            STRINGCLOSE_SQ: "'",
            COPTOPEN: '(',
            COPTCLOSE: ')',
            DELIM: /[\s\{\}=;\[\],'"\(\)]/g,
            // KEYWORD: /^(?:package|option|import|message|enum|extend|service|syntax|extensions|group)$/,
            RULE: /^(?:required|optional|repeated)$/,
            TYPE: /^(?:double|float|int32|uint32|sint32|int64|uint64|sint64|fixed32|sfixed32|fixed64|sfixed64|bool|string|bytes)$/,
            NAME: /^[a-zA-Z_][a-zA-Z_0-9]*$/,
            TYPEDEF: /^[a-zA-Z][a-zA-Z_0-9]*$/,
            TYPEREF: /^(?:\.?[a-zA-Z_][a-zA-Z_0-9]*)+$/,
            FQTYPEREF: /^(?:\.[a-zA-Z][a-zA-Z_0-9]*)+$/,
            NUMBER: /^-?(?:[1-9][0-9]*|0|0x[0-9a-fA-F]+|0[0-7]+|([0-9]*\.[0-9]+([Ee][+-]?[0-9]+)?))$/,
            NUMBER_DEC: /^(?:[1-9][0-9]*|0)$/,
            NUMBER_HEX: /^0x[0-9a-fA-F]+$/,
            NUMBER_OCT: /^0[0-7]+$/,
            NUMBER_FLT: /^[0-9]*\.[0-9]+([Ee][+-]?[0-9]+)?$/,
            ID: /^(?:[1-9][0-9]*|0|0x[0-9a-fA-F]+|0[0-7]+)$/,
            NEGID: /^\-?(?:[1-9][0-9]*|0|0x[0-9a-fA-F]+|0[0-7]+)$/,
            WHITESPACE: /\s/,
            STRING: /['"]([^'"\\]*(\\.[^"\\]*)*)['"]/g,
            BOOL: /^(?:true|false)$/i
        };

        /**
         * @alias ProtoBuf.DotProto
         * @expose
         */
        ProtoBuf.DotProto = (function(ProtoBuf, Lang) {
            "use strict";

            /**
             * Utilities to parse .proto files.
             * @exports ProtoBuf.DotProto
             * @namespace
             */
            var DotProto = {};

            /**
             * Constructs a new Tokenizer.
             * @exports ProtoBuf.DotProto.Tokenizer
             * @class proto tokenizer
             * @param {string} proto Proto to tokenize
             * @constructor
             */
            var Tokenizer = function(proto) {

                /**
                 * Source to parse.
                 * @type {string}
                 * @expose
                 */
                this.source = ""+proto; // In case it's a buffer

                /**
                 * Current index.
                 * @type {number}
                 * @expose
                 */
                this.index = 0;

                /**
                 * Current line.
                 * @type {number}
                 * @expose
                 */
                this.line = 1;

                /**
                 * Stacked values.
                 * @type {Array}
                 * @expose
                 */
                this.stack = [];

                /**
                 * Whether currently reading a string or not.
                 * @type {boolean}
                 * @expose
                 */
                this.readingString = false;

                /**
                 * Whatever character ends the string. Either a single or double quote character.
                 * @type {string}
                 * @expose
                 */
                this.stringEndsWith = Lang.STRINGCLOSE;
            };

            /**
             * Reads a string beginning at the current index.
             * @return {string} The string
             * @throws {Error} If it's not a valid string
             * @private
             */
            Tokenizer.prototype._readString = function() {
                Lang.STRING.lastIndex = this.index-1; // Include the open quote
                var match;
                if ((match = Lang.STRING.exec(this.source)) !== null) {
                    var s = match[1];
                    this.index = Lang.STRING.lastIndex;
                    this.stack.push(this.stringEndsWith);
                    return s;
                }
                throw Error("Illegal string value at line "+this.line+", index "+this.index);
            };

            /**
             * Gets the next token and advances by one.
             * @return {?string} Token or `null` on EOF
             * @throws {Error} If it's not a valid proto file
             * @expose
             */
            Tokenizer.prototype.next = function() {
                if (this.stack.length > 0)
                    return this.stack.shift();
                if (this.index >= this.source.length)
                    return null; // No more tokens
                if (this.readingString) {
                    this.readingString = false;
                    return this._readString();
                }
                var repeat, last;
                do {
                    repeat = false;
                    // Strip white spaces
                    while (Lang.WHITESPACE.test(last = this.source.charAt(this.index))) {
                        this.index++;
                        if (last === "\n")
                            this.line++;
                        if (this.index === this.source.length)
                            return null;
                    }
                    // Strip comments
                    if (this.source.charAt(this.index) === '/') {
                        if (this.source.charAt(++this.index) === '/') { // Single line
                            while (this.source.charAt(this.index) !== "\n") {
                                this.index++;
                                if (this.index == this.source.length)
                                    return null;
                            }
                            this.index++;
                            this.line++;
                            repeat = true;
                        } else if (this.source.charAt(this.index) === '*') { /* Block */
                            last = '';
                            while (last+(last=this.source.charAt(this.index)) !== '*/') {
                                this.index++;
                                if (last === "\n")
                                    this.line++;
                                if (this.index === this.source.length)
                                    return null;
                            }
                            this.index++;
                            repeat = true;
                        } else
                            throw Error("Invalid comment at line "+this.line+": /"+this.source.charAt(this.index)+" ('/' or '*' expected)");
                    }
                } while (repeat);
                if (this.index === this.source.length) return null;

                // Read the next token
                var end = this.index;
                Lang.DELIM.lastIndex = 0;
                var delim = Lang.DELIM.test(this.source.charAt(end));
                if (!delim) {
                    ++end;
                    while(end < this.source.length && !Lang.DELIM.test(this.source.charAt(end)))
                        end++;
                } else
                    ++end;
                var token = this.source.substring(this.index, this.index = end);
                if (token === Lang.STRINGOPEN)
                    this.readingString = true,
                    this.stringEndsWith = Lang.STRINGCLOSE;
                else if (token === Lang.STRINGOPEN_SQ)
                    this.readingString = true,
                    this.stringEndsWith = Lang.STRINGCLOSE_SQ;
                return token;
            };

            /**
             * Peeks for the next token.
             * @return {?string} Token or `null` on EOF
             * @throws {Error} If it's not a valid proto file
             * @expose
             */
            Tokenizer.prototype.peek = function() {
                if (this.stack.length === 0) {
                    var token = this.next();
                    if (token === null)
                        return null;
                    this.stack.push(token);
                }
                return this.stack[0];
            };

            /**
             * Returns a string representation of this object.
             * @return {string} String representation as of "Tokenizer(index/length)"
             * @expose
             */
            Tokenizer.prototype.toString = function() {
                return "Tokenizer("+this.index+"/"+this.source.length+" at line "+this.line+")";
            };

            /**
             * @alias ProtoBuf.DotProto.Tokenizer
             * @expose
             */
            DotProto.Tokenizer = Tokenizer;

            /**
             * Constructs a new Parser.
             * @exports ProtoBuf.DotProto.Parser
             * @class proto parser
             * @param {string} proto Protocol source
             * @constructor
             */
            var Parser = function(proto) {

                /**
                 * Tokenizer.
                 * @type {ProtoBuf.DotProto.Tokenizer}
                 * @expose
                 */
                this.tn = new Tokenizer(proto);
            };

            /**
             * Runs the parser.
             * @return {{package: string|null, messages: Array.<object>, enums: Array.<object>, imports: Array.<string>, options: object<string,*>}}
             * @throws {Error} If the source cannot be parsed
             * @expose
             */
            Parser.prototype.parse = function() {
                var topLevel = {
                    "name": "[ROOT]", // temporary
                    "package": null,
                    "messages": [],
                    "enums": [],
                    "imports": [],
                    "options": {},
                    "services": []
                };
                var token, header = true;
                while(token = this.tn.next()) {
                    switch (token) {
                        case 'package':
                            if (!header || topLevel["package"] !== null)
                                throw Error("Illegal package at line "+this.tn.line);
                            topLevel["package"] = this._parsePackage(token);
                            break;
                        case 'import':
                            if (!header)
                                throw Error("Illegal import at line "+this.tn.line);
                            topLevel.imports.push(this._parseImport(token));
                            break;
                        case 'message':
                            this._parseMessage(topLevel, null, token);
                            header = false;
                            break;
                        case 'enum':
                            this._parseEnum(topLevel, token);
                            header = false;
                            break;
                        case 'option':
                            if (!header)
                                throw Error("Illegal option at line "+this.tn.line);
                            this._parseOption(topLevel, token);
                            break;
                        case 'service':
                            this._parseService(topLevel, token);
                            break;
                        case 'extend':
                            this._parseExtend(topLevel, token);
                            break;
                        case 'syntax':
                            this._parseIgnoredStatement(topLevel, token);
                            break;
                        default:
                            throw Error("Illegal token at line "+this.tn.line+": "+token);
                    }
                }
                delete topLevel["name"];
                return topLevel;
            };

            /**
             * Parses a number value.
             * @param {string} val Number value to parse
             * @return {number} Number
             * @throws {Error} If the number value is invalid
             * @private
             */
            Parser.prototype._parseNumber = function(val) {
                var sign = 1;
                if (val.charAt(0) == '-')
                    sign = -1,
                    val = val.substring(1);
                if (Lang.NUMBER_DEC.test(val))
                    return sign*parseInt(val, 10);
                else if (Lang.NUMBER_HEX.test(val))
                    return sign*parseInt(val.substring(2), 16);
                else if (Lang.NUMBER_OCT.test(val))
                    return sign*parseInt(val.substring(1), 8);
                else if (Lang.NUMBER_FLT.test(val))
                    return sign*parseFloat(val);
                throw Error("Illegal number at line "+this.tn.line+": "+(sign < 0 ? '-' : '')+val);
            };

            /**
             * Parses an ID value.
             * @param {string} val ID value to parse
             * @param {boolean=} neg Whether the ID may be negative, defaults to `false`
             * @returns {number} ID
             * @throws {Error} If the ID value is invalid
             * @private
             */
            Parser.prototype._parseId = function(val, neg) {
                var id = -1;
                var sign = 1;
                if (val.charAt(0) == '-')
                    sign = -1,
                    val = val.substring(1);
                if (Lang.NUMBER_DEC.test(val))
                    id = parseInt(val);
                else if (Lang.NUMBER_HEX.test(val))
                    id = parseInt(val.substring(2), 16);
                else if (Lang.NUMBER_OCT.test(val))
                    id = parseInt(val.substring(1), 8);
                else
                    throw Error("Illegal ID at line "+this.tn.line+": "+(sign < 0 ? '-' : '')+val);
                id = (sign*id)|0; // Force to 32bit
                if (!neg && id < 0)
                    throw Error("Illegal ID at line "+this.tn.line+": "+(sign < 0 ? '-' : '')+val);
                return id;
            };

            /**
             * Parses the package definition.
             * @param {string} token Initial token
             * @return {string} Package name
             * @throws {Error} If the package definition cannot be parsed
             * @private
             */
            Parser.prototype._parsePackage = function(token) {
                token = this.tn.next();
                if (!Lang.TYPEREF.test(token))
                    throw Error("Illegal package at line "+this.tn.line+": "+token);
                var pkg = token;
                token = this.tn.next();
                if (token != Lang.END)
                    throw Error("Illegal end of package at line "+this.tn.line+": "+token+" ('"+Lang.END+"' expected)");
                return pkg;
            };

            /**
             * Parses an import definition.
             * @param {string} token Initial token
             * @return {string} Import file name
             * @throws {Error} If the import definition cannot be parsed
             * @private
             */
            Parser.prototype._parseImport = function(token) {
                token = this.tn.next();
                if (token === "public")
                    token = this.tn.next();
                if (token !== Lang.STRINGOPEN && token !== Lang.STRINGOPEN_SQ)
                    throw Error("Illegal import at line "+this.tn.line+": "+token+" ('"+Lang.STRINGOPEN+"' or '"+Lang.STRINGOPEN_SQ+"' expected)");
                var imported = this.tn.next();
                token = this.tn.next();
                if (token !== this.tn.stringEndsWith)
                    throw Error("Illegal import at line "+this.tn.line+": "+token+" ('"+this.tn.stringEndsWith+"' expected)");
                token = this.tn.next();
                if (token !== Lang.END)
                    throw Error("Illegal import at line "+this.tn.line+": "+token+" ('"+Lang.END+"' expected)");
                return imported;
            };

            /**
             * Parses a namespace option.
             * @param {Object} parent Parent definition
             * @param {string} token Initial token
             * @throws {Error} If the option cannot be parsed
             * @private
             */
            Parser.prototype._parseOption = function(parent, token) {
                token = this.tn.next();
                var custom = false;
                if (token == Lang.COPTOPEN)
                    custom = true,
                    token = this.tn.next();
                if (!Lang.TYPEREF.test(token))
                    // we can allow options of the form google.protobuf.* since they will just get ignored anyways
                    if (!/google\.protobuf\./.test(token))
                        throw Error("Illegal option in message "+parent.name+" at line "+this.tn.line+": "+token);
                var name = token;
                token = this.tn.next();
                if (custom) { // (my_method_option).foo, (my_method_option), some_method_option, (foo.my_option).bar
                    if (token !== Lang.COPTCLOSE)
                        throw Error("Illegal option in message "+parent.name+", option "+name+" at line "+this.tn.line+": "+token+" ('"+Lang.COPTCLOSE+"' expected)");
                    name = '('+name+')';
                    token = this.tn.next();
                    if (Lang.FQTYPEREF.test(token))
                        name += token,
                        token = this.tn.next();
                }
                if (token !== Lang.EQUAL)
                    throw Error("Illegal option operator in message "+parent.name+", option "+name+" at line "+this.tn.line+": "+token+" ('"+Lang.EQUAL+"' expected)");
                var value;
                token = this.tn.next();
                if (token === Lang.STRINGOPEN || token === Lang.STRINGOPEN_SQ) {
                    value = this.tn.next();
                    token = this.tn.next();
                    if (token !== this.tn.stringEndsWith)
                        throw Error("Illegal end of option value in message "+parent.name+", option "+name+" at line "+this.tn.line+": "+token+" ('"+this.tn.stringEndsWith+"' expected)");
                } else {
                    if (Lang.NUMBER.test(token))
                        value = this._parseNumber(token, true);
                    else if (Lang.BOOL.test(token))
                        value = token === 'true';
                    else if (Lang.TYPEREF.test(token))
                        value = token;
                    else
                        throw Error("Illegal option value in message "+parent.name+", option "+name+" at line "+this.tn.line+": "+token);
                }
                token = this.tn.next();
                if (token !== Lang.END)
                    throw Error("Illegal end of option in message "+parent.name+", option "+name+" at line "+this.tn.line+": "+token+" ('"+Lang.END+"' expected)");
                parent["options"][name] = value;
            };

            /**
             * Parses an ignored statement of the form ['keyword', ..., ';'].
             * @param {Object} parent Parent definition
             * @param {string} keyword Initial token
             * @throws {Error} If the directive cannot be parsed
             * @private
             */
            Parser.prototype._parseIgnoredStatement = function(parent, keyword) {
                var token;
                do {
                    token = this.tn.next();
                    if (token === null)
                        throw Error("Unexpected EOF in "+parent.name+", "+keyword+" (ignored) at line "+this.tn.line);
                    if (token === Lang.END)
                        break;
                } while (true);
            };

            /**
             * Parses a service definition.
             * @param {Object} parent Parent definition
             * @param {string} token Initial token
             * @throws {Error} If the service cannot be parsed
             * @private
             */
            Parser.prototype._parseService = function(parent, token) {
                token = this.tn.next();
                if (!Lang.NAME.test(token))
                    throw Error("Illegal service name at line "+this.tn.line+": "+token);
                var name = token;
                var svc = {
                    "name": name,
                    "rpc": {},
                    "options": {}
                };
                token = this.tn.next();
                if (token !== Lang.OPEN)
                    throw Error("Illegal OPEN after service "+name+" at line "+this.tn.line+": "+token+" ('"+Lang.OPEN+"' expected)");
                do {
                    token = this.tn.next();
                    if (token === "option")
                        this._parseOption(svc, token);
                    else if (token === 'rpc')
                        this._parseServiceRPC(svc, token);
                    else if (token !== Lang.CLOSE)
                        throw Error("Illegal type for service "+name+" at line "+this.tn.line+": "+token);
                } while (token !== Lang.CLOSE);
                parent["services"].push(svc);
            };

            /**
             * Parses a RPC service definition of the form ['rpc', name, (request), 'returns', (response)].
             * @param {Object} svc Parent definition
             * @param {string} token Initial token
             * @private
             */
            Parser.prototype._parseServiceRPC = function(svc, token) {
                var type = token;
                token = this.tn.next();
                if (!Lang.NAME.test(token))
                    throw Error("Illegal RPC method name in service "+svc["name"]+" at line "+this.tn.line+": "+token);
                var name = token;
                var method = {
                    "request": null,
                    "response": null,
                    "options": {}
                };
                token = this.tn.next();
                if (token !== Lang.COPTOPEN)
                    throw Error("Illegal start of request type in RPC service "+svc["name"]+"#"+name+" at line "+this.tn.line+": "+token+" ('"+Lang.COPTOPEN+"' expected)");
                token = this.tn.next();
                if (!Lang.TYPEREF.test(token))
                    throw Error("Illegal request type in RPC service "+svc["name"]+"#"+name+" at line "+this.tn.line+": "+token);
                method["request"] = token;
                token = this.tn.next();
                if (token != Lang.COPTCLOSE)
                    throw Error("Illegal end of request type in RPC service "+svc["name"]+"#"+name+" at line "+this.tn.line+": "+token+" ('"+Lang.COPTCLOSE+"' expected)");
                token = this.tn.next();
                if (token.toLowerCase() !== "returns")
                    throw Error("Illegal request/response delimiter in RPC service "+svc["name"]+"#"+name+" at line "+this.tn.line+": "+token+" ('returns' expected)");
                token = this.tn.next();
                if (token != Lang.COPTOPEN)
                    throw Error("Illegal start of response type in RPC service "+svc["name"]+"#"+name+" at line "+this.tn.line+": "+token+" ('"+Lang.COPTOPEN+"' expected)");
                token = this.tn.next();
                method["response"] = token;
                token = this.tn.next();
                if (token !== Lang.COPTCLOSE)
                    throw Error("Illegal end of response type in RPC service "+svc["name"]+"#"+name+" at line "+this.tn.line+": "+token+" ('"+Lang.COPTCLOSE+"' expected)");
                token = this.tn.next();
                if (token === Lang.OPEN) {
                    do {
                        token = this.tn.next();
                        if (token === 'option')
                            this._parseOption(method, token); // <- will fail for the custom-options example
                        else if (token !== Lang.CLOSE)
                            throw Error("Illegal start of option in RPC service "+svc["name"]+"#"+name+" at line "+this.tn.line+": "+token+" ('option' expected)");
                    } while (token !== Lang.CLOSE);
                    if (this.tn.peek() === Lang.END)
                        this.tn.next();
                } else if (token !== Lang.END)
                    throw Error("Illegal method delimiter in RPC service "+svc["name"]+"#"+name+" at line "+this.tn.line+": "+token+" ('"+Lang.END+"' or '"+Lang.OPEN+"' expected)");
                if (typeof svc[type] === 'undefined')
                    svc[type] = {};
                svc[type][name] = method;
            };

            /**
             * Parses a message definition.
             * @param {Object} parent Parent definition
             * @param {Object} fld Field definition if this is a group, otherwise `null`
             * @param {string} token First token
             * @return {Object}
             * @throws {Error} If the message cannot be parsed
             * @private
             */
            Parser.prototype._parseMessage = function(parent, fld, token) {
                /** @dict */
                var msg = {}; // Note: At some point we might want to exclude the parser, so we need a dict.
                var isGroup = token === "group";
                token = this.tn.next();
                if (!Lang.NAME.test(token))
                    throw Error("Illegal "+(isGroup ? "group" : "message")+" name"+(parent ? " in message "+parent["name"] : "")+" at line "+this.tn.line+": "+token);
                msg["name"] = token;
                if (isGroup) {
                    token = this.tn.next();
                    if (token !== Lang.EQUAL)
                        throw Error("Illegal id assignment after group "+msg.name+" at line "+this.tn.line+": "+token+" ('"+Lang.EQUAL+"' expected)");
                    token = this.tn.next();
                    try {
                        fld["id"] = this._parseId(token);
                    } catch (e) {
                        throw Error("Illegal field id value for group "+msg.name+"#"+fld.name+" at line "+this.tn.line+": "+token);
                    }
                    msg["isGroup"] = true;
                }
                msg["fields"] = []; // Note: Using arrays to support also browser that cannot preserve order of object keys.
                msg["enums"] = [];
                msg["messages"] = [];
                msg["options"] = {};
                token = this.tn.next();
                if (token === Lang.OPTOPEN && fld)
                    this._parseFieldOptions(msg, fld, token),
                    token = this.tn.next();
                if (token !== Lang.OPEN)
                    throw Error("Illegal OPEN after "+(isGroup ? "group" : "message")+" "+msg.name+" at line "+this.tn.line+": "+token+" ('"+Lang.OPEN+"' expected)");
                // msg["extensions"] = undefined
                do {
                    token = this.tn.next();
                    if (token === Lang.CLOSE) {
                        token = this.tn.peek();
                        if (token === Lang.END)
                            this.tn.next();
                        break;
                    } else if (Lang.RULE.test(token))
                        this._parseMessageField(msg, token);
                    else if (token === "enum")
                        this._parseEnum(msg, token);
                    else if (token === "message")
                        this._parseMessage(msg, null, token);
                    else if (token === "option")
                        this._parseOption(msg, token);
                    else if (token === "extensions")
                        msg["extensions"] = this._parseExtensions(msg, token);
                    else if (token === "extend")
                        this._parseExtend(msg, token);
                    else
                        throw Error("Illegal token in message "+msg.name+" at line "+this.tn.line+": "+token+" (type or '"+Lang.CLOSE+"' expected)");
                } while (true);
                parent["messages"].push(msg);
                return msg;
            };

            /**
             * Parses a message field.
             * @param {Object} msg Message definition
             * @param {string} token Initial token
             * @throws {Error} If the message field cannot be parsed
             * @private
             */
            Parser.prototype._parseMessageField = function(msg, token) {
                /** @dict */
                var fld = {}, grp = null;
                fld["rule"] = token;
                /** @dict */
                fld["options"] = {};
                token = this.tn.next();
                if (token === "group") {
                    // "A [legacy] group simply combines a nested message type and a field into a single declaration. In your
                    // code, you can treat this message just as if it had a Result type field called result (the latter name is
                    // converted to lower-case so that it does not conflict with the former)."
                    grp = this._parseMessage(msg, fld, token);
                    if (!/^[A-Z]/.test(grp["name"]))
                        throw Error('Group names must start with a capital letter');
                    fld["type"] = grp["name"];
                    fld["name"] = grp["name"].toLowerCase();
                    token = this.tn.peek();
                    if (token === Lang.END)
                        this.tn.next();
                } else {
                    if (!Lang.TYPE.test(token) && !Lang.TYPEREF.test(token))
                        throw Error("Illegal field type in message "+msg.name+" at line "+this.tn.line+": "+token);
                    fld["type"] = token;
                    token = this.tn.next();
                    if (!Lang.NAME.test(token))
                        throw Error("Illegal field name in message "+msg.name+" at line "+this.tn.line+": "+token);
                    fld["name"] = token;
                    token = this.tn.next();
                    if (token !== Lang.EQUAL)
                        throw Error("Illegal field id assignment in message "+msg.name+"#"+fld.name+" at line "+this.tn.line+": "+token+" ('"+Lang.EQUAL+"' expected)");
                    token = this.tn.next();
                    try {
                        fld["id"] = this._parseId(token);
                    } catch (e) {
                        throw Error("Illegal field id value in message "+msg.name+"#"+fld.name+" at line "+this.tn.line+": "+token);
                    }
                    token = this.tn.next();
                    if (token === Lang.OPTOPEN)
                        this._parseFieldOptions(msg, fld, token),
                        token = this.tn.next();
                    if (token !== Lang.END)
                        throw Error("Illegal field delimiter in message "+msg.name+"#"+fld.name+" at line "+this.tn.line+": "+token+" ('"+Lang.END+"' expected)");
                }
                msg["fields"].push(fld);
            };

            /**
             * Parses a set of field option definitions.
             * @param {Object} msg Message definition
             * @param {Object} fld Field definition
             * @param {string} token Initial token
             * @throws {Error} If the message field options cannot be parsed
             * @private
             */
            Parser.prototype._parseFieldOptions = function(msg, fld, token) {
                var first = true;
                do {
                    token = this.tn.next();
                    if (token === Lang.OPTCLOSE)
                        break;
                    else if (token === Lang.OPTEND) {
                        if (first)
                            throw Error("Illegal start of message field options in message "+msg.name+"#"+fld.name+" at line "+this.tn.line+": "+token);
                        token = this.tn.next();
                    }
                    this._parseFieldOption(msg, fld, token);
                    first = false;
                } while (true);
            };

            /**
             * Parses a single field option.
             * @param {Object} msg Message definition
             * @param {Object} fld Field definition
             * @param {string} token Initial token
             * @throws {Error} If the mesage field option cannot be parsed
             * @private
             */
            Parser.prototype._parseFieldOption = function(msg, fld, token) {
                var custom = false;
                if (token === Lang.COPTOPEN)
                    token = this.tn.next(),
                    custom = true;
                if (!Lang.TYPEREF.test(token))
                    throw Error("Illegal field option in message "+msg.name+"#"+fld.name+" at line "+this.tn.line+": "+token);
                var name = token;
                token = this.tn.next();
                if (custom) {
                    if (token !== Lang.COPTCLOSE)
                        throw Error("Illegal custom field option name delimiter in message "+msg.name+"#"+fld.name+" at line "+this.tn.line+": "+token+" (')' expected)");
                    name = '('+name+')';
                    token = this.tn.next();
                    if (Lang.FQTYPEREF.test(token))
                        name += token,
                        token = this.tn.next();
                }
                if (token !== Lang.EQUAL)
                    throw Error("Illegal field option operation in message "+msg.name+"#"+fld.name+" at line "+this.tn.line+": "+token+" ('=' expected)");
                var value;
                token = this.tn.next();
                if (token === Lang.STRINGOPEN || token === Lang.STRINGOPEN_SQ) {
                    value = this.tn.next();
                    token = this.tn.next();
                    if (token != this.tn.stringEndsWith)
                        throw Error("Illegal end of field value in message "+msg.name+"#"+fld.name+", option "+name+" at line "+this.tn.line+": "+token+" ('"+this.tn.stringEndsWith+"' expected)");
                } else if (Lang.NUMBER.test(token, true))
                    value = this._parseNumber(token, true);
                else if (Lang.BOOL.test(token))
                    value = token.toLowerCase() === 'true';
                else if (Lang.TYPEREF.test(token))
                    value = token; // TODO: Resolve?
                else
                    throw Error("Illegal field option value in message "+msg.name+"#"+fld.name+", option "+name+" at line "+this.tn.line+": "+token);
                fld["options"][name] = value;
            };

            /**
             * Parses an enum.
             * @param {Object} msg Message definition
             * @param {string} token Initial token
             * @throws {Error} If the enum cannot be parsed
             * @private
             */
            Parser.prototype._parseEnum = function(msg, token) {
                /** @dict */
                var enm = {};
                token = this.tn.next();
                if (!Lang.NAME.test(token))
                    throw Error("Illegal enum name in message "+msg.name+" at line "+this.tn.line+": "+token);
                enm["name"] = token;
                token = this.tn.next();
                if (token !== Lang.OPEN)
                    throw Error("Illegal OPEN after enum "+enm.name+" at line "+this.tn.line+": "+token);
                enm["values"] = [];
                enm["options"] = {};
                do {
                    token = this.tn.next();
                    if (token === Lang.CLOSE) {
                        token = this.tn.peek();
                        if (token === Lang.END)
                            this.tn.next();
                        break;
                    }
                    if (token == 'option')
                        this._parseOption(enm, token);
                    else {
                        if (!Lang.NAME.test(token))
                            throw Error("Illegal enum value name in enum "+enm.name+" at line "+this.tn.line+": "+token);
                        this._parseEnumValue(enm, token);
                    }
                } while (true);
                msg["enums"].push(enm);
            };

            /**
             * Parses an enum value.
             * @param {Object} enm Enum definition
             * @param {string} token Initial token
             * @throws {Error} If the enum value cannot be parsed
             * @private
             */
            Parser.prototype._parseEnumValue = function(enm, token) {
                /** @dict */
                var val = {};
                val["name"] = token;
                token = this.tn.next();
                if (token !== Lang.EQUAL)
                    throw Error("Illegal enum value operator in enum "+enm.name+" at line "+this.tn.line+": "+token+" ('"+Lang.EQUAL+"' expected)");
                token = this.tn.next();
                try {
                    val["id"] = this._parseId(token, true);
                } catch (e) {
                    throw Error("Illegal enum value id in enum "+enm.name+" at line "+this.tn.line+": "+token);
                }
                enm["values"].push(val);
                token = this.tn.next();
                if (token === Lang.OPTOPEN) {
                    var opt = { 'options' : {} }; // TODO: Actually expose them somehow.
                    this._parseFieldOptions(enm, opt, token);
                    token = this.tn.next();
                }
                if (token !== Lang.END)
                    throw Error("Illegal enum value delimiter in enum "+enm.name+" at line "+this.tn.line+": "+token+" ('"+Lang.END+"' expected)");
            };

            /**
             * Parses an extensions statement.
             * @param {Object} msg Message object
             * @param {string} token Initial token
             * @throws {Error} If the extensions statement cannot be parsed
             * @private
             */
            Parser.prototype._parseExtensions = function(msg, token) {
                /** @type {Array.<number>} */
                var range = [];
                token = this.tn.next();
                if (token === "min") // FIXME: Does the official implementation support this?
                    range.push(ProtoBuf.ID_MIN);
                else if (token === "max")
                    range.push(ProtoBuf.ID_MAX);
                else
                    range.push(this._parseNumber(token));
                token = this.tn.next();
                if (token !== 'to')
                    throw Error("Illegal extensions delimiter in message "+msg.name+" at line "+this.tn.line+" ('to' expected)");
                token = this.tn.next();
                if (token === "min")
                    range.push(ProtoBuf.ID_MIN);
                else if (token === "max")
                    range.push(ProtoBuf.ID_MAX);
                else
                    range.push(this._parseNumber(token));
                token = this.tn.next();
                if (token !== Lang.END)
                    throw Error("Illegal extension delimiter in message "+msg.name+" at line "+this.tn.line+": "+token+" ('"+Lang.END+"' expected)");
                return range;
            };

            /**
             * Parses an extend block.
             * @param {Object} parent Parent object
             * @param {string} token Initial token
             * @throws {Error} If the extend block cannot be parsed
             * @private
             */
            Parser.prototype._parseExtend = function(parent, token) {
                token = this.tn.next();
                if (!Lang.TYPEREF.test(token))
                    throw Error("Illegal extended message name at line "+this.tn.line+": "+token);
                /** @dict */
                var ext = {};
                ext["ref"] = token;
                ext["fields"] = [];
                token = this.tn.next();
                if (token !== Lang.OPEN)
                    throw Error("Illegal OPEN in extend "+ext.name+" at line "+this.tn.line+": "+token+" ('"+Lang.OPEN+"' expected)");
                do {
                    token = this.tn.next();
                    if (token === Lang.CLOSE) {
                        token = this.tn.peek();
                        if (token == Lang.END)
                            this.tn.next();
                        break;
                    } else if (Lang.RULE.test(token))
                        this._parseMessageField(ext, token);
                    else
                        throw Error("Illegal token in extend "+ext.name+" at line "+this.tn.line+": "+token+" (rule or '"+Lang.CLOSE+"' expected)");
                } while (true);
                parent["messages"].push(ext);
                return ext;
            };

            /**
             * Returns a string representation of this object.
             * @returns {string} String representation as of "Parser"
             */
            Parser.prototype.toString = function() {
                return "Parser";
            };

            /**
             * @alias ProtoBuf.DotProto.Parser
             * @expose
             */
            DotProto.Parser = Parser;

            return DotProto;

        })(ProtoBuf, ProtoBuf.Lang);

        /**
         * @alias ProtoBuf.Reflect
         * @expose
         */
        ProtoBuf.Reflect = (function(ProtoBuf) {
            "use strict";

            /**
             * Reflection types.
             * @exports ProtoBuf.Reflect
             * @namespace
             */
            var Reflect = {};

            /**
             * Constructs a Reflect base class.
             * @exports ProtoBuf.Reflect.T
             * @constructor
             * @abstract
             * @param {ProtoBuf.Reflect.T} parent Parent object
             * @param {string} name Object name
             */
            var T = function(parent, name) {

                /**
                 * Parent object.
                 * @type {ProtoBuf.Reflect.T|null}
                 * @expose
                 */
                this.parent = parent;

                /**
                 * Object name in namespace.
                 * @type {string}
                 * @expose
                 */
                this.name = name;

                /**
                 * Fully qualified class name
                 * @type {string}
                 * @expose
                 */
                this.className;
            };

            /**
             * Returns the fully qualified name of this object.
             * @returns {string} Fully qualified name as of ".PATH.TO.THIS"
             * @expose
             */
            T.prototype.fqn = function() {
                var name = this.name,
                    ptr = this;
                do {
                    ptr = ptr.parent;
                    if (ptr == null)
                        break;
                    name = ptr.name+"."+name;
                } while (true);
                return name;
            };

            /**
             * Returns a string representation of this Reflect object (its fully qualified name).
             * @param {boolean=} includeClass Set to true to include the class name. Defaults to false.
             * @return String representation
             * @expose
             */
            T.prototype.toString = function(includeClass) {
                return (includeClass ? this.className + " " : "") + this.fqn();
            };

            /**
             * Builds this type.
             * @throws {Error} If this type cannot be built directly
             * @expose
             */
            T.prototype.build = function() {
                throw Error(this.toString(true)+" cannot be built directly");
            };

            /**
             * @alias ProtoBuf.Reflect.T
             * @expose
             */
            Reflect.T = T;

            /**
             * Constructs a new Namespace.
             * @exports ProtoBuf.Reflect.Namespace
             * @param {ProtoBuf.Reflect.Namespace|null} parent Namespace parent
             * @param {string} name Namespace name
             * @param {Object.<string,*>} options Namespace options
             * @constructor
             * @extends ProtoBuf.Reflect.T
             */
            var Namespace = function(parent, name, options) {
                T.call(this, parent, name);

                /**
                 * @override
                 */
                this.className = "Namespace";

                /**
                 * Children inside the namespace.
                 * @type {Array.<ProtoBuf.Reflect.T>}
                 */
                this.children = [];

                /**
                 * Options.
                 * @type {Object.<string, *>}
                 */
                this.options = options || {};
            };

            // Extends T
            Namespace.prototype = Object.create(T.prototype);

            /**
             * Returns an array of the namespace's children.
             * @param {ProtoBuf.Reflect.T=} type Filter type (returns instances of this type only). Defaults to null (all children).
             * @return {Array.<ProtoBuf.Reflect.T>}
             * @expose
             */
            Namespace.prototype.getChildren = function(type) {
                type = type || null;
                if (type == null)
                    return this.children.slice();
                var children = [];
                for (var i=0, k=this.children.length; i<k; ++i)
                    if (this.children[i] instanceof type)
                        // We also need to distinguish between Field and ExtensionField which is an instance of Field
                        if (type !== Message.Field || !(this.children[i] instanceof Message.ExtensionField))
                            children.push(this.children[i]);
                return children;
            };

            /**
             * Adds a child to the namespace.
             * @param {ProtoBuf.Reflect.T} child Child
             * @throws {Error} If the child cannot be added (duplicate)
             * @expose
             */
            Namespace.prototype.addChild = function(child) {
                var other;
                if (other = this.getChild(child.name)) {
                    // Try to revert camelcase transformation on collision
                    if (other instanceof Message.Field && other.name !== other.originalName && !this.hasChild(other.originalName))
                        other.name = other.originalName; // Revert previous first (effectively keeps both originals)
                    else if (child instanceof Message.Field && child.name !== child.originalName && !this.hasChild(child.originalName))
                        child.name = child.originalName;
                    else
                        throw Error("Duplicate name in namespace "+this.toString(true)+": "+child.name);
                }
                this.children.push(child);
            };

            /**
             * Tests if this namespace has a child with the specified name.
             * @param {string|number} nameOrId Child name or id
             * @returns {boolean} true if there is one, else false
             * @expose
             */
            Namespace.prototype.hasChild = function(nameOrId) {
                return this._indexOf(nameOrId) > -1;
            };

            /**
             * Gets a child by its name.
             * @param {string|number} nameOrId Child name or id
             * @return {?ProtoBuf.Reflect.T} The child or null if not found
             * @expose
             */
            Namespace.prototype.getChild = function(nameOrId) {
                var index = this._indexOf(nameOrId);
                return index > -1 ? this.children[index] : null;
            };

            /**
             * Returns child index by its name or id.
             * @param {string|number} nameOrId Child name or id
             * @return {Number} The child index
             * @private
             */
            Namespace.prototype._indexOf = function(nameOrId) {
                var key = typeof nameOrId === 'number' ? 'id' : 'name';
                for (var i=0; i<this.children.length; i++)
                    if (typeof this.children[i][key] !== 'undefined' && this.children[i][key] == nameOrId)
                        return i;
                return -1;
            };

            /**
             * Resolves a reflect object inside of this namespace.
             * @param {string} qn Qualified name to resolve
             * @param {boolean=} excludeFields Excludes fields, defaults to `false`
             * @return {ProtoBuf.Reflect.Namespace|null} The resolved type or null if not found
             * @expose
             */
            Namespace.prototype.resolve = function(qn, excludeFields) {
                var part = qn.split(".");
                var ptr = this, i=0;
                if (part[i] == "") { // Fully qualified name, e.g. ".My.Message'
                    while (ptr.parent != null)
                        ptr = ptr.parent;
                    i++;
                }
                var child;
                do {
                    do {
                        child = ptr.getChild(part[i]);
                        if (!child || !(child instanceof Reflect.T) || (excludeFields && child instanceof Reflect.Message.Field)) {
                            ptr = null;
                            break;
                        }
                        ptr = child; i++;
                    } while (i < part.length);
                    if (ptr != null)
                        break; // Found
                    // Else search the parent
                    if (this.parent !== null) {
                        return this.parent.resolve(qn, excludeFields);
                    }
                } while (ptr != null);
                return ptr;
            };

            /**
             * Builds the namespace and returns the runtime counterpart.
             * @return {Object.<string,Function|Object>} Runtime namespace
             * @expose
             */
            Namespace.prototype.build = function() {
                /** @dict */
                var ns = {};
                var children = this.getChildren(), child;
                for (var i=0, k=children.length; i<k; ++i) {
                    child = children[i];
                    if (child instanceof Namespace)
                        ns[child.name] = child.build();
                }
                if (Object.defineProperty)
                    Object.defineProperty(ns, "$options", { "value": this.buildOpt() });
                return ns;
            };

            /**
             * Builds the namespace's '$options' property.
             * @return {Object.<string,*>}
             */
            Namespace.prototype.buildOpt = function() {
                var opt = {};
                var keys = Object.keys(this.options);
                for (var i=0; i<keys.length; i++) {
                    var key = keys[i],
                        val = this.options[keys[i]];
                    // TODO: Options are not resolved, yet.
                    // if (val instanceof Namespace) {
                    //     opt[key] = val.build();
                    // } else {
                    opt[key] = val;
                    // }
                }
                return opt;
            };

            /**
             * Gets the value assigned to the option with the specified name.
             * @param {string=} name Returns the option value if specified, otherwise all options are returned.
             * @return {*|Object.<string,*>}null} Option value or NULL if there is no such option
             */
            Namespace.prototype.getOption = function(name) {
                if (typeof name === 'undefined')
                    return this.options;
                return typeof this.options[name] !== 'undefined' ? this.options[name] : null;
            };

            /**
             * @alias ProtoBuf.Reflect.Namespace
             * @expose
             */
            Reflect.Namespace = Namespace;

            /**
             * Constructs a new Message.
             * @exports ProtoBuf.Reflect.Message
             * @param {ProtoBuf.Reflect.Namespace} parent Parent message or namespace
             * @param {string} name Message name
             * @param {Object.<string,*>} options Message options
             * @param {boolean=} isGroup `true` if this is a legacy group
             * @constructor
             * @extends ProtoBuf.Reflect.Namespace
             */
            var Message = function(parent, name, options, isGroup) {
                Namespace.call(this, parent, name, options);

                /**
                 * @override
                 */
                this.className = "Message";

                /**
                 * Extensions range.
                 * @type {!Array.<number>}
                 * @expose
                 */
                this.extensions = [ProtoBuf.ID_MIN, ProtoBuf.ID_MAX];

                /**
                 * Runtime message class.
                 * @type {?function(new:ProtoBuf.Builder.Message)}
                 * @expose
                 */
                this.clazz = null;

                /**
                 * Whether this is a legacy group or not.
                 * @type {boolean}
                 * @expose
                 */
                this.isGroup = !!isGroup;
            };

            // Extends Namespace
            Message.prototype = Object.create(Namespace.prototype);

            /**
             * Builds the message and returns the runtime counterpart, which is a fully functional class.
             * @see ProtoBuf.Builder.Message
             * @param {boolean=} rebuild Whether to rebuild or not, defaults to false
             * @return {ProtoBuf.Reflect.Message} Message class
             * @throws {Error} If the message cannot be built
             * @expose
             */
            Message.prototype.build = function(rebuild) {
                if (this.clazz && !rebuild) return this.clazz;

                // We need to create a prototyped Message class in an isolated scope
                var clazz = (function(ProtoBuf, T) {

                    var fields = T.getChildren(ProtoBuf.Reflect.Message.Field);

                    /**
                     * Constructs a new runtime Message.
                     * @name ProtoBuf.Builder.Message
                     * @class Barebone of all runtime messages.
                     * @param {Object.<string,*>|...[string]} values Preset values
                     * @constructor
                     * @throws {Error} If the message cannot be created
                     */
                    var Message = function(values) {
                        ProtoBuf.Builder.Message.call(this);
                        var i, field;

                        // Create fields on the object itself to allow setting and getting through Message#fieldname
                        for (i=0; i<fields.length; i++) {
                            field = fields[i];
                            this[field.name] = (field.repeated) ? [] : null;
                        }
                        // Set the default values
                        for (i=0; i<fields.length; i++) {
                            field = fields[i];
                            if (typeof field.options['default'] != 'undefined') {
                                try {
                                    this.$set(field.name, field.options['default']); // Should not throw
                                } catch (e) {
                                    throw Error("[INTERNAL] "+e);
                                }
                            }
                        }
                        // Set field values from a values object
                        if (arguments.length == 1 && typeof values == 'object' &&
                            /* not another Message */ typeof values.encode != 'function' &&
                            /* not a repeated field */ !ProtoBuf.Util.isArray(values) &&
                            /* not a ByteBuffer */ !(values instanceof ByteBuffer) &&
                            /* not an ArrayBuffer */ !(values instanceof ArrayBuffer) &&
                            /* not a Long */ !(ProtoBuf.Long && values instanceof ProtoBuf.Long)) {
                            var keys = Object.keys(values);
                            for (i=0; i<keys.length; i++)
                                this.$set(keys[i], values[keys[i]]); // May throw
                            // Else set field values from arguments, in correct order
                        } else
                            for (i=0; i<arguments.length; i++)
                                if (i<fields.length)
                                    this.$set(fields[i].name, arguments[i]); // May throw
                    };

                    // Extends ProtoBuf.Builder.Message
                    Message.prototype = Object.create(ProtoBuf.Builder.Message.prototype);

                    /**
                     * Adds a value to a repeated field.
                     * @name ProtoBuf.Builder.Message#add
                     * @function
                     * @param {string} key Field name
                     * @param {*} value Value to add
                     * @param {boolean=} noAssert Whether to assert the value or not (asserts by default)
                     * @throws {Error} If the value cannot be added
                     * @expose
                     */
                    Message.prototype.add = function(key, value, noAssert) {
                        var field = T.getChild(key);
                        if (!field)
                            throw Error(this+"#"+key+" is undefined");
                        if (!(field instanceof ProtoBuf.Reflect.Message.Field))
                            throw Error(this+"#"+key+" is not a field: "+field.toString(true)); // May throw if it's an enum or embedded message
                        if (!field.repeated)
                            throw Error(this+"#"+key+" is not a repeated field");
                        if (this[field.name] === null)
                            this[field.name] = [];
                        this[field.name].push(noAssert ? value : field.verifyValue(value, true));
                    };

                    /**
                     * Adds a value to a repeated field. This is an alias for {@link ProtoBuf.Builder.Message#add}.
                     * @name ProtoBuf.Builder.Message#$add
                     * @function
                     * @param {string} key Field name
                     * @param {*} value Value to add
                     * @param {boolean=} noAssert Whether to assert the value or not (asserts by default)
                     * @throws {Error} If the value cannot be added
                     * @expose
                     */
                    Message.prototype.$add = Message.prototype.add;

                    /**
                     * Sets a field's value.
                     * @name ProtoBuf.Builder.Message#set
                     * @function
                     * @param {string} key Key
                     * @param {*} value Value to set
                     * @param {boolean=} noAssert Whether to assert the value or not (asserts by default)
                     * @throws {Error} If the value cannot be set
                     * @expose
                     */
                    Message.prototype.set = function(key, value, noAssert) {
                        var field = T.getChild(key);
                        if (!field)
                            throw Error(this+"#"+key+" is not a field: undefined");
                        if (!(field instanceof ProtoBuf.Reflect.Message.Field))
                            throw Error(this+"#"+key+" is not a field: "+field.toString(true));
                        this[field.name] = noAssert ? value : field.verifyValue(value); // May throw
                    };

                    /**
                     * Sets a field's value. This is an alias for [@link ProtoBuf.Builder.Message#set}.
                     * @name ProtoBuf.Builder.Message#$set
                     * @function
                     * @param {string} key Key
                     * @param {*} value Value to set
                     * @param {boolean=} noAssert Whether to assert the value or not (asserts by default)
                     * @throws {Error} If the value cannot be set
                     * @expose
                     */
                    Message.prototype.$set = Message.prototype.set;

                    /**
                     * Gets a field's value.
                     * @name ProtoBuf.Builder.Message#get
                     * @function
                     * @param {string} key Key
                     * @return {*} Value
                     * @throws {Error} If there is no such field
                     * @expose
                     */
                    Message.prototype.get = function(key) {
                        var field = T.getChild(key);
                        if (!field || !(field instanceof ProtoBuf.Reflect.Message.Field))
                            throw Error(this+"#"+key+" is not a field: undefined");
                        if (!(field instanceof ProtoBuf.Reflect.Message.Field))
                            throw Error(this+"#"+key+" is not a field: "+field.toString(true));
                        return this[field.name];
                    };

                    /**
                     * Gets a field's value. This is an alias for {@link ProtoBuf.Builder.Message#$get}.
                     * @name ProtoBuf.Builder.Message#$get
                     * @function
                     * @param {string} key Key
                     * @return {*} Value
                     * @throws {Error} If there is no such field
                     * @expose
                     */
                    Message.prototype.$get = Message.prototype.get;

                    // Getters and setters

                    for (var i=0; i<fields.length; i++) {
                        var field = fields[i];

                        (function(field) {
                            // set/get[SomeValue]
                            var Name = field.originalName.replace(/(_[a-zA-Z])/g, function(match) {
                                return match.toUpperCase().replace('_','');
                            });
                            Name = Name.substring(0,1).toUpperCase()+Name.substring(1);

                            // set/get_[some_value]
                            var name = field.originalName.replace(/([A-Z])/g, function(match) {
                                return "_"+match;
                            });

                            /**
                             * Sets a value. This method is present for each field, but only if there is no name conflict with
                             * another field.
                             * @name ProtoBuf.Builder.Message#set[SomeField]
                             * @function
                             * @param {*} value Value to set
                             * @abstract
                             * @throws {Error} If the value cannot be set
                             */
                            if (!T.hasChild("set"+Name))
                                Message.prototype["set"+Name] = function(value) {
                                    this.$set(field.name, value);
                                };

                            /**
                             * Sets a value. This method is present for each field, but only if there is no name conflict with
                             * another field.
                             * @name ProtoBuf.Builder.Message#set_[some_field]
                             * @function
                             * @param {*} value Value to set
                             * @abstract
                             * @throws {Error} If the value cannot be set
                             */
                            if (!T.hasChild("set_"+name))
                                Message.prototype["set_"+name] = function(value) {
                                    this.$set(field.name, value);
                                };

                            /**
                             * Gets a value. This method is present for each field, but only if there is no name conflict with
                             * another field.
                             * @name ProtoBuf.Builder.Message#get[SomeField]
                             * @function
                             * @abstract
                             * @return {*} The value
                             */
                            if (!T.hasChild("get"+Name))
                                Message.prototype["get"+Name] = function() {
                                    return this.$get(field.name); // Does not throw, field exists
                                }

                            /**
                             * Gets a value. This method is present for each field, but only if there is no name conflict with
                             * another field.
                             * @name ProtoBuf.Builder.Message#get_[some_field]
                             * @function
                             * @return {*} The value
                             * @abstract
                             */
                            if (!T.hasChild("get_"+name))
                                Message.prototype["get_"+name] = function() {
                                    return this.$get(field.name); // Does not throw, field exists
                                };

                        })(field);
                    }

                    // En-/decoding

                    /**
                     * Encodes the message.
                     * @name ProtoBuf.Builder.Message#$encode
                     * @function
                     * @param {(!ByteBuffer|boolean)=} buffer ByteBuffer to encode to. Will create a new one and flip it if omitted.
                     * @return {!ByteBuffer} Encoded message as a ByteBuffer
                     * @throws {Error} If the message cannot be encoded or if required fields are missing. The later still
                     *  returns the encoded ByteBuffer in the `encoded` property on the error.
                     * @expose
                     * @see ProtoBuf.Builder.Message#encode64
                     * @see ProtoBuf.Builder.Message#encodeHex
                     * @see ProtoBuf.Builder.Message#encodeAB
                     */
                    Message.prototype.encode = function(buffer) {
                        var isNew = false;
                        if (!buffer)
                            buffer = new ByteBuffer(), isNew = true;
                        var le = buffer.littleEndian;
                        try {
                            T.encode(this, buffer.LE());
                            return (isNew ? buffer.flip() : buffer).LE(le);
                        } catch (e) {
                            buffer.LE(le);
                            throw(e);
                        }
                    };

                    /**
                     * Calculates the byte length of the message.
                     * @name ProtoBuf.Builder.Message#calculate
                     * @function
                     * @returns {number} Byte length
                     * @throws {Error} If the message cannot be calculated or if required fields are missing.
                     * @expose
                     */
                    Message.prototype.calculate = function() {
                        return T.calculate(this);
                    };

                    /**
                     * Encodes the varint32 length-delimited message.
                     * @name ProtoBuf.Builder.Message#encodeDelimited
                     * @function
                     * @param {(!ByteBuffer|boolean)=} buffer ByteBuffer to encode to. Will create a new one and flip it if omitted.
                     * @return {!ByteBuffer} Encoded message as a ByteBuffer
                     * @throws {Error} If the message cannot be encoded or if required fields are missing. The later still
                     *  returns the encoded ByteBuffer in the `encoded` property on the error.
                     * @expose
                     */
                    Message.prototype.encodeDelimited = function(buffer) {
                        var isNew = false;
                        if (!buffer)
                            buffer = new ByteBuffer(), isNew = true;
                        var enc = new ByteBuffer().LE();
                        T.encode(this, enc).flip();
                        buffer.writeVarint32(enc.remaining());
                        buffer.append(enc);
                        return isNew ? buffer.flip() : buffer;
                    };

                    /**
                     * Directly encodes the message to an ArrayBuffer.
                     * @name ProtoBuf.Builder.Message#encodeAB
                     * @function
                     * @return {ArrayBuffer} Encoded message as ArrayBuffer
                     * @throws {Error} If the message cannot be encoded or if required fields are missing. The later still
                     *  returns the encoded ArrayBuffer in the `encoded` property on the error.
                     * @expose
                     */
                    Message.prototype.encodeAB = function() {
                        try {
                            return this.encode().toArrayBuffer();
                        } catch (e) {
                            if (e["encoded"]) e["encoded"] = e["encoded"].toArrayBuffer();
                            throw(e);
                        }
                    };

                    /**
                     * Returns the message as an ArrayBuffer. This is an alias for {@link ProtoBuf.Builder.Message#encodeAB}.
                     * @name ProtoBuf.Builder.Message#toArrayBuffer
                     * @function
                     * @return {ArrayBuffer} Encoded message as ArrayBuffer
                     * @throws {Error} If the message cannot be encoded or if required fields are missing. The later still
                     *  returns the encoded ArrayBuffer in the `encoded` property on the error.
                     * @expose
                     */
                    Message.prototype.toArrayBuffer = Message.prototype.encodeAB;

                    /**
                     * Directly encodes the message to a node Buffer.
                     * @name ProtoBuf.Builder.Message#encodeNB
                     * @function
                     * @return {!Buffer}
                     * @throws {Error} If the message cannot be encoded, not running under node.js or if required fields are
                     *  missing. The later still returns the encoded node Buffer in the `encoded` property on the error.
                     * @expose
                     */
                    Message.prototype.encodeNB = function() {
                        try {
                            return this.encode().toBuffer();
                        } catch (e) {
                            if (e["encoded"]) e["encoded"] = e["encoded"].toBuffer();
                            throw(e);
                        }
                    };

                    /**
                     * Returns the message as a node Buffer. This is an alias for {@link ProtoBuf.Builder.Message#encodeNB}.
                     * @name ProtoBuf.Builder.Message#toBuffer
                     * @function
                     * @return {!Buffer}
                     * @throws {Error} If the message cannot be encoded or if required fields are missing. The later still
                     *  returns the encoded node Buffer in the `encoded` property on the error.
                     * @expose
                     */
                    Message.prototype.toBuffer = Message.prototype.encodeNB;

                    /**
                     * Directly encodes the message to a base64 encoded string.
                     * @name ProtoBuf.Builder.Message#encode64
                     * @function
                     * @return {string} Base64 encoded string
                     * @throws {Error} If the underlying buffer cannot be encoded or if required fields are missing. The later
                     *  still returns the encoded base64 string in the `encoded` property on the error.
                     * @expose
                     */
                    Message.prototype.encode64 = function() {
                        try {
                            return this.encode().toBase64();
                        } catch (e) {
                            if (e["encoded"]) e["encoded"] = e["encoded"].toBase64();
                            throw(e);
                        }
                    };

                    /**
                     * Returns the message as a base64 encoded string. This is an alias for {@link ProtoBuf.Builder.Message#encode64}.
                     * @name ProtoBuf.Builder.Message#toBase64
                     * @function
                     * @return {string} Base64 encoded string
                     * @throws {Error} If the message cannot be encoded or if required fields are missing. The later still
                     *  returns the encoded base64 string in the `encoded` property on the error.
                     * @expose
                     */
                    Message.prototype.toBase64 = Message.prototype.encode64;

                    /**
                     * Directly encodes the message to a hex encoded string.
                     * @name ProtoBuf.Builder.Message#encodeHex
                     * @function
                     * @return {string} Hex encoded string
                     * @throws {Error} If the underlying buffer cannot be encoded or if required fields are missing. The later
                     *  still returns the encoded hex string in the `encoded` property on the error.
                     * @expose
                     */
                    Message.prototype.encodeHex = function() {
                        try {
                            return this.encode().toHex();
                        } catch (e) {
                            if (e["encoded"]) e["encoded"] = e["encoded"].toHex();
                            throw(e);
                        }
                    };

                    /**
                     * Returns the message as a hex encoded string. This is an alias for {@link ProtoBuf.Builder.Message#encodeHex}.
                     * @name ProtoBuf.Builder.Message#toHex
                     * @function
                     * @return {string} Hex encoded string
                     * @throws {Error} If the message cannot be encoded or if required fields are missing. The later still
                     *  returns the encoded hex string in the `encoded` property on the error.
                     * @expose
                     */
                    Message.prototype.toHex = Message.prototype.encodeHex;

                    /**
                     * Clones a message object to a raw object.
                     * @param {*} obj Object to clone
                     * @param {boolean} includeBuffers Whether to include native buffer data or not
                     * @returns {*} Cloned object
                     * @inner
                     */
                    function cloneRaw(obj, includeBuffers) {
                        var clone = {};
                        for (var i in obj)
                            if (obj.hasOwnProperty(i)) {
                                if (obj[i] === null || typeof obj[i] !== 'object')
                                    clone[i] = obj[i];
                                else if (obj[i] instanceof ByteBuffer) {
                                    if (includeBuffers)
                                        clone[i] = obj.toBuffer();
                                } else // is a non-null object
                                    clone[i] = cloneRaw(obj[i], includeBuffers);
                            }
                        return clone;
                    }

                    /**
                     * Returns the message's raw payload.
                     * @param {boolean=} includeBuffers Whether to include native buffer data or not, defaults to `false`
                     * @returns {Object.<string,*>} Raw payload
                     * @expose
                     */
                    Message.prototype.toRaw = function(includeBuffers) {
                        return cloneRaw(this, !!includeBuffers);
                    };

                    /**
                     * Decodes a message from the specified buffer or string.
                     * @name ProtoBuf.Builder.Message.decode
                     * @function
                     * @param {!ByteBuffer|!ArrayBuffer|!Buffer|string} buffer Buffer to decode from
                     * @param {string=} enc Encoding if buffer is a string: hex, utf8 (not recommended), defaults to base64
                     * @return {!ProtoBuf.Builder.Message} Decoded message
                     * @throws {Error} If the message cannot be decoded or if required fields are missing. The later still
                     *  returns the decoded message with missing fields in the `decoded` property on the error.
                     * @expose
                     * @see ProtoBuf.Builder.Message.decode64
                     * @see ProtoBuf.Builder.Message.decodeHex
                     */
                    Message.decode = function(buffer, enc) {
                        if (typeof buffer === 'string')
                            buffer = ByteBuffer.wrap(buffer, enc ? enc : "base64");
                        buffer = buffer instanceof ByteBuffer ? buffer : ByteBuffer.wrap(buffer); // May throw
                        var le = buffer.littleEndian;
                        try {
                            var msg = T.decode(buffer.LE());
                            buffer.LE(le);
                            return msg;
                        } catch (e) {
                            buffer.LE(le);
                            throw(e);
                        }
                    };

                    /**
                     * Decodes a varint32 length-delimited message from the specified buffer or string.
                     * @name ProtoBuf.Builder.Message.decodeDelimited
                     * @function
                     * @param {!ByteBuffer|!ArrayBuffer|!Buffer|string} buffer Buffer to decode from
                     * @param {string=} enc Encoding if buffer is a string: hex, utf8 (not recommended), defaults to base64
                     * @return {!ProtoBuf.Builder.Message} Decoded message
                     * @throws {Error} If the message cannot be decoded or if required fields are missing. The later still
                     *  returns the decoded message with missing fields in the `decoded` property on the error.
                     * @expose
                     */
                    Message.decodeDelimited = function(buffer, enc) {
                        if (typeof buffer === 'string')
                            buffer = ByteBuffer.wrap(buffer, enc ? enc : "base64");
                        buffer = buffer instanceof ByteBuffer ? buffer : ByteBuffer.wrap(buffer); // May throw
                        var len = buffer.readVarint32();
                        var msg = T.decode(buffer.slice(buffer.offset, buffer.offset + len).LE());
                        buffer.offset += len;
                        return msg;
                    };

                    /**
                     * Decodes the message from the specified base64 encoded string.
                     * @name ProtoBuf.Builder.Message.decode64
                     * @function
                     * @param {string} str String to decode from
                     * @return {!ProtoBuf.Builder.Message} Decoded message
                     * @throws {Error} If the message cannot be decoded or if required fields are missing. The later still
                     *  returns the decoded message with missing fields in the `decoded` property on the error.
                     * @expose
                     */
                    Message.decode64 = function(str) {
                        return Message.decode(str, "base64");
                    };

                    /**
                     * Decodes the message from the specified hex encoded string.
                     * @name ProtoBuf.Builder.Message.decodeHex
                     * @function
                     * @param {string} str String to decode from
                     * @return {!ProtoBuf.Builder.Message} Decoded message
                     * @throws {Error} If the message cannot be decoded or if required fields are missing. The later still
                     *  returns the decoded message with missing fields in the `decoded` property on the error.
                     * @expose
                     */
                    Message.decodeHex = function(str) {
                        return Message.decode(str, "hex");
                    };

                    // Utility

                    /**
                     * Returns a string representation of this Message.
                     * @name ProtoBuf.Builder.Message#toString
                     * @function
                     * @return {string} String representation as of ".Fully.Qualified.MessageName"
                     * @expose
                     */
                    Message.prototype.toString = function() {
                        return T.toString();
                    };

                    // Static

                    /**
                     * Options.
                     * @name ProtoBuf.Builder.Message.$options
                     * @type {Object.<string,*>}
                     * @expose
                     */
                    var $options; // for cc

                    if (Object.defineProperty)
                        Object.defineProperty(Message, '$options', { "value": T.buildOpt() });

                    return Message;

                })(ProtoBuf, this);

                // Static enums and prototyped sub-messages
                var children = this.getChildren();
                for (var i=0; i<children.length; i++) {
                    if (children[i] instanceof Enum)
                        clazz[children[i]['name']] = children[i].build();
                    else if (children[i] instanceof Message)
                        clazz[children[i]['name']] = children[i].build();
                    else if (children[i] instanceof Message.Field) {
                        // Ignore
                    } else
                        throw Error("Illegal reflect child of "+this.toString(true)+": "+children[i].toString(true));
                }
                return this.clazz = clazz;
            };

            /**
             * Encodes a runtime message's contents to the specified buffer.
             * @param {!ProtoBuf.Builder.Message} message Runtime message to encode
             * @param {ByteBuffer} buffer ByteBuffer to write to
             * @return {ByteBuffer} The ByteBuffer for chaining
             * @throws {Error} If required fields are missing or the message cannot be encoded for another reason
             * @expose
             */
            Message.prototype.encode = function(message, buffer) {
                var fields = this.getChildren(Message.Field),
                    fieldMissing = null;
                for (var i=0, val; i<fields.length; i++) {
                    val = message.$get(fields[i].name);
                    if (fields[i].required && val === null) {
                        if (fieldMissing === null)
                            fieldMissing = fields[i];
                    } else
                        fields[i].encode(val, buffer);
                }
                if (fieldMissing !== null) {
                    var err = Error("Missing at least one required field for "+this.toString(true)+": "+fieldMissing);
                    err["encoded"] = buffer; // Still expose what we got
                    throw(err);
                }
                return buffer;
            };

            /**
             * Calculates a runtime message's byte length.
             * @param {!ProtoBuf.Builder.Message} message Runtime message to encode
             * @returns {number} Byte length
             * @throws {Error} If required fields are missing or the message cannot be calculated for another reason
             * @expose
             */
            Message.prototype.calculate = function(message) {
                var fields = this.getChildren(Message.Field),
                    n = 0;
                for (var i=0, val; i<fields.length; i++) {
                    val = message.$get(fields[i].name);
                    if (fields[i].required && val === null)
                       throw Error("Missing at least one required field for "+this.toString(true)+": "+fields[i]);
                    else
                        n += fields[i].calculate(val);
                }
                return n;
            };

            /**
             * Skips all data until the end of the specified group has been reached.
             * @param {number} expectedId Expected GROUPEND id
             * @param {!ByteBuffer} buf ByteBuffer
             * @returns {boolean} `true` if a value as been skipped, `false` if the end has been reached
             * @throws {Error} If it wasn't possible to find the end of the group (buffer overrun or end tag mismatch)
             * @inner
             */
            function skipTillGroupEnd(expectedId, buf) {
                var tag = buf.readVarint32(), // Throws on OOB
                    wireType = tag & 0x07,
                    id = tag >> 3;
                switch (wireType) {
                    case ProtoBuf.WIRE_TYPES.VARINT:
                        do tag = buf.readUint8();
                        while ((tag & 0x80) === 0x80);
                        break;
                    case ProtoBuf.WIRE_TYPES.BITS64:
                        buf.offset += 8;
                        break;
                    case ProtoBuf.WIRE_TYPES.LDELIM:
                        tag = buf.readVarint32(); // reads the varint
                        buf.offset += tag;        // skips n bytes
                        break;
                    case ProtoBuf.WIRE_TYPES.STARTGROUP:
                        skipTillGroupEnd(id, buf);
                        break;
                    case ProtoBuf.WIRE_TYPES.ENDGROUP:
                        if (id === expectedId)
                            return false;
                        else
                            throw Error("Illegal GROUPEND after unknown group: "+id+" ("+expectedId+" expected)");
                    case ProtoBuf.WIRE_TYPES.BITS32:
                        buf.offset += 4;
                        break;
                    default:
                        throw Error("Illegal wire type in unknown group "+expectedId+": "+wireType);
                }
                return true;
            }

            /**
             * Decodes an encoded message and returns the decoded message.
             * @param {ByteBuffer} buffer ByteBuffer to decode from
             * @param {number=} length Message length. Defaults to decode all the available data.
             * @param {number=} expectedGroupEndId Expected GROUPEND id if this is a legacy group
             * @return {ProtoBuf.Builder.Message} Decoded message
             * @throws {Error} If the message cannot be decoded
             * @expose
             */
            Message.prototype.decode = function(buffer, length, expectedGroupEndId) {
                length = typeof length === 'number' ? length : -1;
                var start = buffer.offset;
                var msg = new (this.clazz)();
                var tag, wireType, id;
                while (buffer.offset < start+length || (length == -1 && buffer.remaining() > 0)) {
                    tag = buffer.readVarint32();
                    wireType = tag & 0x07;
                    id = tag >> 3;
                    if (wireType === ProtoBuf.WIRE_TYPES.ENDGROUP) {
                        if (id !== expectedGroupEndId)
                            throw Error("Illegal group end indicator for "+this.toString(true)+": "+id+" ("+(expectedGroupEndId ? expectedGroupEndId+" expected" : "not a group")+")");
                        break;
                    }
                    var field = this.getChild(id); // Message.Field only
                    if (!field) {
                        // "messages created by your new code can be parsed by your old code: old binaries simply ignore the new field when parsing."
                        switch (wireType) {
                            case ProtoBuf.WIRE_TYPES.VARINT:
                                buffer.readVarint32();
                                break;
                            case ProtoBuf.WIRE_TYPES.BITS32:
                                buffer.offset += 4;
                                break;
                            case ProtoBuf.WIRE_TYPES.BITS64:
                                buffer.offset += 8;
                                break;
                            case ProtoBuf.WIRE_TYPES.LDELIM:
                                var len = buffer.readVarint32();
                                buffer.offset += len;
                                break;
                            case ProtoBuf.WIRE_TYPES.STARTGROUP:
                                while (skipTillGroupEnd(id, buffer)) {}
                                break;
                            default:
                                throw Error("Illegal wire type for unknown field "+id+" in "+this.toString(true)+"#decode: "+wireType);
                        }
                        continue;
                    }
                    if (field.repeated && !field.options["packed"])
                        msg.$add(field.name, field.decode(wireType, buffer), true);
                    else
                        msg.$set(field.name, field.decode(wireType, buffer), true);
                }

                // Check if all required fields are present
                var fields = this.getChildren(ProtoBuf.Reflect.Field);
                for (var i=0; i<fields.length; i++)
                    if (fields[i].required && msg[fields[i].name] === null) {
                        var err = Error("Missing at least one required field for "+this.toString(true)+": "+fields[i].name);
                        err["decoded"] = msg; // Still expose what we got
                        throw(err);
                    }
                return msg;
            };

            /**
             * @alias ProtoBuf.Reflect.Message
             * @expose
             */
            Reflect.Message = Message;

            /**
             * Constructs a new Message Field.
             * @exports ProtoBuf.Reflect.Message.Field
             * @param {ProtoBuf.Reflect.Message} message Message reference
             * @param {string} rule Rule, one of requried, optional, repeated
             * @param {string} type Data type, e.g. int32
             * @param {string} name Field name
             * @param {number} id Unique field id
             * @param {Object.<string.*>=} options Options
             * @constructor
             * @extends ProtoBuf.Reflect.T
             */
            var Field = function(message, rule, type, name, id, options) {
                T.call(this, message, name);

                /**
                 * @override
                 */
                this.className = "Message.Field";

                /**
                 * Message field required flag.
                 * @type {boolean}
                 * @expose
                 */
                this.required = rule == "required";

                /**
                 * Message field repeated flag.
                 * @type {boolean}
                 * @expose
                 */
                this.repeated = rule == "repeated";

                /**
                 * Message field type. Type reference string if unresolved, protobuf type if resolved.
                 * @type {string|{name: string, wireType: number}}
                 * @expose
                 */
                this.type = type;

                /**
                 * Resolved type reference inside the global namespace.
                 * @type {ProtoBuf.Reflect.T|null}
                 * @expose
                 */
                this.resolvedType = null;

                /**
                 * Unique message field id.
                 * @type {number}
                 * @expose
                 */
                this.id = id;

                /**
                 * Message field options.
                 * @type {!Object.<string,*>}
                 * @dict
                 * @expose
                 */
                this.options = options || {};

                /**
                 * Original field name.
                 * @type {string}
                 * @expose
                 */
                this.originalName = this.name; // Used to revert camelcase transformation on naming collisions

                // Convert field names to camel case notation if the override is set
                if (ProtoBuf.convertFieldsToCamelCase) {
                    this.name = this.name.replace(/_([a-zA-Z])/g, function($0, $1) {
                        return $1.toUpperCase();
                    });
                }
            };

            // Extends T
            Field.prototype = Object.create(T.prototype);

            /**
             * Makes a Long from a value.
             * @param {{low: number, high: number, unsigned: boolean}|string|number} value Value
             * @param {boolean=} unsigned Whether unsigned or not, defaults to reuse it from Long-like objects or to signed for
             *  strings and numbers
             * @returns {!Long}
             * @throws {Error} If the value cannot be converted to a Long
             * @inner
             */
            function mkLong(value, unsigned) {
                if (value && typeof value.low === 'number' && typeof value.high === 'number' && typeof value.unsigned === 'boolean'
                    && value.low === value.low && value.high === value.high)
                    return new ProtoBuf.Long(value.low, value.high, typeof unsigned === 'undefined' ? value.unsigned : unsigned);
                if (typeof value === 'string')
                    return ProtoBuf.Long.fromString(value, unsigned || false, 10);
                if (typeof value === 'number')
                    return ProtoBuf.Long.fromNumber(value, unsigned || false);
                throw Error("not convertible to Long");
            }

            /**
             * Checks if the given value can be set for this field.
             * @param {*} value Value to check
             * @param {boolean=} skipRepeated Whether to skip the repeated value check or not. Defaults to false.
             * @return {*} Verified, maybe adjusted, value
             * @throws {Error} If the value cannot be set for this field
             * @expose
             */
            Field.prototype.verifyValue = function(value, skipRepeated) {
                skipRepeated = skipRepeated || false;
                var fail = function(val, msg) {
                    throw Error("Illegal value for "+this.toString(true)+" of type "+this.type.name+": "+val+" ("+msg+")");
                }.bind(this);
                if (value === null) { // NULL values for optional fields
                    if (this.required)
                        fail(typeof value, "required");
                    return null;
                }
                var i;
                if (this.repeated && !skipRepeated) { // Repeated values as arrays
                    if (!ProtoBuf.Util.isArray(value))
                        value = [value];
                    var res = [];
                    for (i=0; i<value.length; i++)
                        res.push(this.verifyValue(value[i], true));
                    return res;
                }
                // All non-repeated fields expect no array
                if (!this.repeated && ProtoBuf.Util.isArray(value))
                    fail(typeof value, "no array expected");

                switch (this.type) {
                    // Signed 32bit
                    case ProtoBuf.TYPES["int32"]:
                    case ProtoBuf.TYPES["sint32"]:
                    case ProtoBuf.TYPES["sfixed32"]:
                        // Account for !NaN: value === value
                        if (typeof value !== 'number' || (value === value && value % 1 !== 0))
                            fail(typeof value, "not an integer");
                        return value > 4294967295 ? value | 0 : value;

                    // Unsigned 32bit
                    case ProtoBuf.TYPES["uint32"]:
                    case ProtoBuf.TYPES["fixed32"]:
                        if (typeof value !== 'number' || (value === value && value % 1 !== 0))
                            fail(typeof value, "not an integer");
                        return value < 0 ? value >>> 0 : value;

                    // Signed 64bit
                    case ProtoBuf.TYPES["int64"]:
                    case ProtoBuf.TYPES["sint64"]:
                    case ProtoBuf.TYPES["sfixed64"]: {
                        if (ProtoBuf.Long)
                            try {
                                return mkLong(value, false);
                            } catch (e) {
                                fail(typeof value, e.message);
                            }
                        else
                            fail(typeof value, "requires Long.js");
                    }

                    // Unsigned 64bit
                    case ProtoBuf.TYPES["uint64"]:
                    case ProtoBuf.TYPES["fixed64"]: {
                        if (ProtoBuf.Long)
                            try {
                                return mkLong(value, true);
                            } catch (e) {
                                fail(typeof value, e.message);
                            }
                        else
                            fail(typeof value, "requires Long.js");
                    }

                    // Bool
                    case ProtoBuf.TYPES["bool"]:
                        if (typeof value !== 'boolean')
                            fail(typeof value, "not a boolean");
                        return value;

                    // Float
                    case ProtoBuf.TYPES["float"]:
                    case ProtoBuf.TYPES["double"]:
                        if (typeof value !== 'number')
                            fail(typeof value, "not a number");
                        return value;

                    // Length-delimited string
                    case ProtoBuf.TYPES["string"]:
                        if (typeof value !== 'string' && !(value && value instanceof String))
                            fail(typeof value, "not a string");
                        return ""+value; // Convert String object to string

                    // Length-delimited bytes
                    case ProtoBuf.TYPES["bytes"]:
                        return value && value instanceof ByteBuffer
                            ? value
                            : ByteBuffer.wrap(value);

                    // Constant enum value
                    case ProtoBuf.TYPES["enum"]: {
                        var values = this.resolvedType.getChildren(Enum.Value);
                        for (i=0; i<values.length; i++) {
                            if (values[i].name == value) {
                                return values[i].id;
                            } else if (values[i].id == value) {
                                return values[i].id;
                            }
                        }
                        fail(value, "not a valid enum value");
                    }
                    // Embedded message
                    case ProtoBuf.TYPES["group"]:
                    case ProtoBuf.TYPES["message"]: {
                        if (!value || typeof value !== 'object')
                            fail(typeof value, "object expected");
                        if (value instanceof this.resolvedType.clazz)
                            return value;
                        // Else let's try to construct one from a key-value object
                        return new (this.resolvedType.clazz)(value); // May throw for a hundred of reasons
                    }
                }

                // We should never end here
                throw Error("[INTERNAL] Illegal value for "+this.toString(true)+": "+value+" (undefined type "+this.type+")");
            };

            /**
             * Encodes the specified field value to the specified buffer.
             * @param {*} value Field value
             * @param {ByteBuffer} buffer ByteBuffer to encode to
             * @return {ByteBuffer} The ByteBuffer for chaining
             * @throws {Error} If the field cannot be encoded
             * @expose
             */
            Field.prototype.encode = function(value, buffer) {
                value = this.verifyValue(value); // May throw
                if (this.type === null || typeof this.type !== 'object')
                    throw Error("[INTERNAL] Unresolved type in "+this.toString(true)+": "+this.type);
                if (value === null || (this.repeated && value.length == 0))
                    return buffer; // Optional omitted
                try {
                    if (this.repeated) {
                        var i;
                        // "Only repeated fields of primitive numeric types (types which use the varint, 32-bit, or 64-bit wire
                        // types) can be declared 'packed'."
                        if (this.options["packed"] && ProtoBuf.PACKABLE_WIRE_TYPES.indexOf(this.type.wireType) >= 0) {
                            // "All of the elements of the field are packed into a single key-value pair with wire type 2
                            // (length-delimited). Each element is encoded the same way it would be normally, except without a
                            // tag preceding it."
                            buffer.writeVarint32((this.id << 3) | ProtoBuf.WIRE_TYPES.LDELIM);
                            buffer.ensureCapacity(buffer.offset += 1); // We do not know the length yet, so let's assume a varint of length 1
                            var start = buffer.offset; // Remember where the contents begin
                            for (i=0; i<value.length; i++)
                                this.encodeValue(value[i], buffer);
                            var len = buffer.offset-start;
                            var varintLen = ByteBuffer.calculateVarint32(len);
                            if (varintLen > 1) { // We need to move the contents
                                var contents = buffer.slice(start, buffer.offset);
                                start += varintLen-1;
                                buffer.offset = start;
                                buffer.append(contents);
                            }
                            buffer.writeVarint32(len, start-varintLen);
                        } else {
                            // "If your message definition has repeated elements (without the [packed=true] option), the encoded
                            // message has zero or more key-value pairs with the same tag number"
                            for (i=0; i<value.length; i++)
                                buffer.writeVarint32((this.id << 3) | this.type.wireType),
                                this.encodeValue(value[i], buffer);
                        }
                    } else
                        buffer.writeVarint32((this.id << 3) | this.type.wireType),
                        this.encodeValue(value, buffer);
                } catch (e) {
                    throw Error("Illegal value for "+this.toString(true)+": "+value+" ("+e+")");
                }
                return buffer;
            };

            /**
             * Encodes a value to the specified buffer. Does not encode the key.
             * @param {*} value Field value
             * @param {ByteBuffer} buffer ByteBuffer to encode to
             * @return {ByteBuffer} The ByteBuffer for chaining
             * @throws {Error} If the value cannot be encoded
             * @expose
             */
            Field.prototype.encodeValue = function(value, buffer) {
                if (value === null) return buffer; // Nothing to encode
                // Tag has already been written

                switch (this.type) {
                    // 32bit signed varint
                    case ProtoBuf.TYPES["int32"]:
                        // "If you use int32 or int64 as the type for a negative number, the resulting varint is always ten bytes
                        // long  it is, effectively, treated like a very large unsigned integer." (see #122)
                        if (value < 0)
                            buffer.writeVarint64(value);
                        else
                            buffer.writeVarint32(value);
                        break;

                    // 32bit unsigned varint
                    case ProtoBuf.TYPES["uint32"]:
                        buffer.writeVarint32(value);
                        break;

                    // 32bit varint zig-zag
                    case ProtoBuf.TYPES["sint32"]:
                        buffer.writeVarint32ZigZag(value);
                        break;

                    // Fixed unsigned 32bit
                    case ProtoBuf.TYPES["fixed32"]:
                        buffer.writeUint32(value);
                        break;

                    // Fixed signed 32bit
                    case ProtoBuf.TYPES["sfixed32"]:
                        buffer.writeInt32(value);
                        break;

                    // 64bit varint as-is
                    case ProtoBuf.TYPES["int64"]:
                    case ProtoBuf.TYPES["uint64"]:
                        buffer.writeVarint64(value); // throws
                        break;

                    // 64bit varint zig-zag
                    case ProtoBuf.TYPES["sint64"]:
                        buffer.writeVarint64ZigZag(value); // throws
                        break;

                    // Fixed unsigned 64bit
                    case ProtoBuf.TYPES["fixed64"]:
                        buffer.writeUint64(value); // throws
                        break;

                    // Fixed signed 64bit
                    case ProtoBuf.TYPES["sfixed64"]:
                        buffer.writeInt64(value); // throws
                        break;

                    // Bool
                    case ProtoBuf.TYPES["bool"]:
                        if (typeof value === 'string')
                            buffer.writeVarint32(value.toLowerCase() === 'false' ? 0 : !!value);
                        else
                            buffer.writeVarint32(value ? 1 : 0);
                        break;

                    // Constant enum value
                    case ProtoBuf.TYPES["enum"]:
                        buffer.writeVarint32(value);
                        break;

                    // 32bit float
                    case ProtoBuf.TYPES["float"]:
                        buffer.writeFloat32(value);
                        break;

                    // 64bit float
                    case ProtoBuf.TYPES["double"]:
                        buffer.writeFloat64(value);
                        break;

                    // Length-delimited string
                    case ProtoBuf.TYPES["string"]:
                        buffer.writeVString(value);
                        break;

                    // Length-delimited bytes
                    case ProtoBuf.TYPES["bytes"]:
                        if (value.remaining() < 0)
                            throw Error("Illegal value for "+this.toString(true)+": "+value.remaining()+" bytes remaining");
                        var prevOffset = value.offset;
                        buffer.writeVarint32(value.remaining());
                        buffer.append(value);
                        value.offset = prevOffset;
                        break;

                    // Embedded message
                    case ProtoBuf.TYPES["message"]:
                        var bb = new ByteBuffer().LE();
                        this.resolvedType.encode(value, bb);
                        buffer.writeVarint32(bb.offset);
                        buffer.append(bb.flip());
                        break;

                    // Legacy group
                    case ProtoBuf.TYPES["group"]:
                        this.resolvedType.encode(value, buffer);
                        buffer.writeVarint32((this.id << 3) | ProtoBuf.WIRE_TYPES.ENDGROUP);
                        break;

                    default:
                        // We should never end here
                        throw Error("[INTERNAL] Illegal value to encode in "+this.toString(true)+": "+value+" (unknown type)");
                }
                return buffer;
            };

            /**
             * Calculates the length of this field's value on the network level.
             * @param {*} value Field value
             * @returns {number} Byte length
             * @expose
             */
            Field.prototype.calculate = function(value) {
                value = this.verifyValue(value); // May throw
                if (this.type === null || typeof this.type !== 'object')
                    throw Error("[INTERNAL] Unresolved type in "+this.toString(true)+": "+this.type);
                if (value === null || (this.repeated && value.length == 0))
                    return 0; // Optional omitted
                var n = 0;
                try {
                    if (this.repeated) {
                        var i, ni;
                        if (this.options["packed"] && ProtoBuf.PACKABLE_WIRE_TYPES.indexOf(this.type.wireType) >= 0) {
                            n += ByteBuffer.calculateVarint32((this.id << 3) | ProtoBuf.WIRE_TYPES.LDELIM);
                            ni = 0;
                            for (i=0; i<value.length; i++)
                                ni += this.calculateValue(value[i]);
                            n += ByteBuffer.calculateVarint32(ni);
                            n += ni;
                        } else {
                            for (i=0; i<value.length; i++)
                                n += ByteBuffer.calculateVarint32((this.id << 3) | this.type.wireType),
                                n += this.calculateValue(value[i]);
                        }
                    } else {
                        n += ByteBuffer.calculateVarint32((this.id << 3) | this.type.wireType);
                        n += this.calculateValue(value);
                    }
                } catch (e) {
                    throw Error("Illegal value for "+this.toString(true)+": "+value+" ("+e+")");
                }
                return n;
            };

            /**
             * Calculates the byte length of a value.
             * @param {*} value Field value
             * @returns {number} Byte length
             * @throws {Error} If the value cannot be calculated
             * @expose
             */
            Field.prototype.calculateValue = function(value) {
                if (value === null) return 0; // Nothing to encode
                // Tag has already been written
                var n;
                switch (this.type) {
                    case ProtoBuf.TYPES["int32"]:
                        return value < 0 ? ByteBuffer.calculateVarint64(value) : ByteBuffer.calculateVarint32(value);
                    case ProtoBuf.TYPES["uint32"]:
                        return ByteBuffer.calculateVarint32(value);
                    case ProtoBuf.TYPES["sint32"]:
                        return ByteBuffer.calculateVarint32(ByteBuffer.zigZagEncode32(value));
                    case ProtoBuf.TYPES["fixed32"]:
                    case ProtoBuf.TYPES["sfixed32"]:
                    case ProtoBuf.TYPES["float"]:
                        return 4;
                    case ProtoBuf.TYPES["int64"]:
                    case ProtoBuf.TYPES["uint64"]:
                        return ByteBuffer.calculateVarint64(value);
                    case ProtoBuf.TYPES["sint64"]:
                        return ByteBuffer.calculateVarint64(ByteBuffer.zigZagEncode64(value));
                    case ProtoBuf.TYPES["fixed64"]:
                    case ProtoBuf.TYPES["sfixed64"]:
                        return 8;
                    case ProtoBuf.TYPES["bool"]:
                        return 1;
                    case ProtoBuf.TYPES["enum"]:
                        return ByteBuffer.calculateVarint32(value);
                    case ProtoBuf.TYPES["double"]:
                        return 8;
                    case ProtoBuf.TYPES["string"]:
                        n = ByteBuffer.calculateUTF8Bytes(value);
                        return ByteBuffer.calculateVarint32(n) + n;
                    case ProtoBuf.TYPES["bytes"]:
                        if (value.remaining() < 0)
                            throw Error("Illegal value for "+this.toString(true)+": "+value.remaining()+" bytes remaining");
                        return ByteBuffer.calculateVarint32(value.remaining()) + value.remaining();
                    case ProtoBuf.TYPES["message"]:
                        n = this.resolvedType.calculate(value);
                        return ByteBuffer.calculateVarint32(n) + n;
                    case ProtoBuf.TYPES["group"]:
                        n = this.resolvedType.calculate(value);
                        return n + ByteBuffer.calculateVarint32((this.id << 3) | ProtoBuf.WIRE_TYPES.ENDGROUP);
                }
                // We should never end here
                throw Error("[INTERNAL] Illegal value to encode in "+this.toString(true)+": "+value+" (unknown type)");
            };

            /**
             * Decode the field value from the specified buffer.
             * @param {number} wireType Leading wire type
             * @param {ByteBuffer} buffer ByteBuffer to decode from
             * @param {boolean=} skipRepeated Whether to skip the repeated check or not. Defaults to false.
             * @return {*} Decoded value
             * @throws {Error} If the field cannot be decoded
             * @expose
             */
            Field.prototype.decode = function(wireType, buffer, skipRepeated) {
                var value, nBytes;
                if (wireType != this.type.wireType && (skipRepeated || (wireType != ProtoBuf.WIRE_TYPES.LDELIM || !this.repeated)))
                    throw Error("Illegal wire type for field "+this.toString(true)+": "+wireType+" ("+this.type.wireType+" expected)");
                if (wireType == ProtoBuf.WIRE_TYPES.LDELIM && this.repeated && this.options["packed"]) {
                    if (!skipRepeated) {
                        nBytes = buffer.readVarint32();
                        nBytes = buffer.offset + nBytes; // Limit
                        var values = [];
                        while (buffer.offset < nBytes)
                            values.push(this.decode(this.type.wireType, buffer, true));
                        return values;
                    }
                    // Read the next value otherwise...
                }
                switch (this.type) {
                    // 32bit signed varint
                    case ProtoBuf.TYPES["int32"]:
                        return buffer.readVarint32() | 0;

                    // 32bit unsigned varint
                    case ProtoBuf.TYPES["uint32"]:
                        return buffer.readVarint32() >>> 0;

                    // 32bit signed varint zig-zag
                    case ProtoBuf.TYPES["sint32"]:
                        return buffer.readVarint32ZigZag() | 0;

                    // Fixed 32bit unsigned
                    case ProtoBuf.TYPES["fixed32"]:
                        return buffer.readUint32() >>> 0;

                    case ProtoBuf.TYPES["sfixed32"]:
                        return buffer.readInt32() | 0;

                    // 64bit signed varint
                    case ProtoBuf.TYPES["int64"]:
                        return buffer.readVarint64();

                    // 64bit unsigned varint
                    case ProtoBuf.TYPES["uint64"]:
                        return buffer.readVarint64().toUnsigned();

                    // 64bit signed varint zig-zag
                    case ProtoBuf.TYPES["sint64"]:
                        return buffer.readVarint64ZigZag();

                    // Fixed 64bit unsigned
                    case ProtoBuf.TYPES["fixed64"]:
                        return buffer.readUint64();

                    // Fixed 64bit signed
                    case ProtoBuf.TYPES["sfixed64"]:
                        return buffer.readInt64();

                    // Bool varint
                    case ProtoBuf.TYPES["bool"]:
                        return !!buffer.readVarint32();

                    // Constant enum value (varint)
                    case ProtoBuf.TYPES["enum"]:
                        // The following Builder.Message#set will already throw
                        return buffer.readVarint32();

                    // 32bit float
                    case ProtoBuf.TYPES["float"]:
                        return buffer.readFloat();

                    // 64bit float
                    case ProtoBuf.TYPES["double"]:
                        return buffer.readDouble();

                    // Length-delimited string
                    case ProtoBuf.TYPES["string"]:
                        return buffer.readVString();

                    // Length-delimited bytes
                    case ProtoBuf.TYPES["bytes"]: {
                        nBytes = buffer.readVarint32();
                        if (buffer.remaining() < nBytes)
                            throw Error("Illegal number of bytes for "+this.toString(true)+": "+nBytes+" required but got only "+buffer.remaining());
                        value = buffer.clone(); // Offset already set
                        value.limit = value.offset+nBytes;
                        buffer.offset += nBytes;
                        return value;
                    }

                    // Length-delimited embedded message
                    case ProtoBuf.TYPES["message"]: {
                        nBytes = buffer.readVarint32();
                        return this.resolvedType.decode(buffer, nBytes);
                    }

                    // Legacy group
                    case ProtoBuf.TYPES["group"]:
                        return this.resolvedType.decode(buffer, -1, this.id);
                }

                // We should never end here
                throw Error("[INTERNAL] Illegal wire type for "+this.toString(true)+": "+wireType);
            }

            /**
             * @alias ProtoBuf.Reflect.Message.Field
             * @expose
             */
            Reflect.Message.Field = Field;

            /**
             * Constructs a new Message ExtensionField.
             * @exports ProtoBuf.Reflect.Message.ExtensionField
             * @param {ProtoBuf.Reflect.Message} message Message reference
             * @param {string} rule Rule, one of requried, optional, repeated
             * @param {string} type Data type, e.g. int32
             * @param {string} name Field name
             * @param {number} id Unique field id
             * @param {Object.<string.*>=} options Options
             * @constructor
             * @extends ProtoBuf.Reflect.Message.Field
             */
            var ExtensionField = function(message, rule, type, name, id, options) {
                Field.call(this, message, rule, type, name, id, options);
            };

            // Extends Field
            ExtensionField.prototype = Object.create(Field.prototype);

            /**
             * @alias ProtoBuf.Reflect.Message.ExtensionField
             * @expose
             */
            Reflect.Message.ExtensionField = ExtensionField;

            /**
             * Constructs a new Enum.
             * @exports ProtoBuf.Reflect.Enum
             * @param {!ProtoBuf.Reflect.T} parent Parent Reflect object
             * @param {string} name Enum name
             * @param {Object.<string.*>=} options Enum options
             * @constructor
             * @extends ProtoBuf.Reflect.Namespace
             */
            var Enum = function(parent, name, options) {
                Namespace.call(this, parent, name, options);

                /**
                 * @override
                 */
                this.className = "Enum";

                /**
                 * Runtime enum object.
                 * @type {Object.<string,number>|null}
                 * @expose
                 */
                this.object = null;
            };

            // Extends Namespace
            Enum.prototype = Object.create(Namespace.prototype);

            /**
             * Builds this enum and returns the runtime counterpart.
             * @return {Object<string,*>}
             * @expose
             */
            Enum.prototype.build = function() {
                var enm = {};
                var values = this.getChildren(Enum.Value);
                for (var i=0; i<values.length; i++)
                    enm[values[i]['name']] = values[i]['id'];
                if (Object.defineProperty)
                    Object.defineProperty(enm, '$options', { "value": this.buildOpt() });
                return this.object = enm;
            };

            /**
             * @alias ProtoBuf.Reflect.Enum
             * @expose
             */
            Reflect.Enum = Enum;

            /**
             * Constructs a new Enum Value.
             * @exports ProtoBuf.Reflect.Enum.Value
             * @param {!ProtoBuf.Reflect.Enum} enm Enum reference
             * @param {string} name Field name
             * @param {number} id Unique field id
             * @constructor
             * @extends ProtoBuf.Reflect.T
             */
            var Value = function(enm, name, id) {
                T.call(this, enm, name);

                /**
                 * @override
                 */
                this.className = "Enum.Value";

                /**
                 * Unique enum value id.
                 * @type {number}
                 * @expose
                 */
                this.id = id;
            };

            // Extends T
            Value.prototype = Object.create(T.prototype);

            /**
             * @alias ProtoBuf.Reflect.Enum.Value
             * @expose
             */
            Reflect.Enum.Value = Value;

            /**
             * Constructs a new Service.
             * @exports ProtoBuf.Reflect.Service
             * @param {!ProtoBuf.Reflect.Namespace} root Root
             * @param {string} name Service name
             * @param {Object.<string,*>=} options Options
             * @constructor
             * @extends ProtoBuf.Reflect.Namespace
             */
            var Service = function(root, name, options) {
                Namespace.call(this, root, name, options);

                /**
                 * @override
                 */
                this.className = "Service";

                /**
                 * Built runtime service class.
                 * @type {?function(new:ProtoBuf.Builder.Service)}
                 */
                this.clazz = null;
            };

            // Extends Namespace
            Service.prototype = Object.create(Namespace.prototype);

            /**
             * Builds the service and returns the runtime counterpart, which is a fully functional class.
             * @see ProtoBuf.Builder.Service
             * @param {boolean=} rebuild Whether to rebuild or not
             * @return {Function} Service class
             * @throws {Error} If the message cannot be built
             * @expose
             */
            Service.prototype.build = function(rebuild) {
                if (this.clazz && !rebuild) return this.clazz;
                return this.clazz = (function(ProtoBuf, T) {

                    /**
                     * Constructs a new runtime Service.
                     * @name ProtoBuf.Builder.Service
                     * @param {function(string, ProtoBuf.Builder.Message, function(Error, ProtoBuf.Builder.Message=))=} rpcImpl RPC implementation receiving the method name and the message
                     * @class Barebone of all runtime services.
                     * @constructor
                     * @throws {Error} If the service cannot be created
                     */
                    var Service = function(rpcImpl) {
                        ProtoBuf.Builder.Service.call(this);

                        /**
                         * Service implementation.
                         * @name ProtoBuf.Builder.Service#rpcImpl
                         * @type {!function(string, ProtoBuf.Builder.Message, function(Error, ProtoBuf.Builder.Message=))}
                         * @expose
                         */
                        this.rpcImpl = rpcImpl || function(name, msg, callback) {
                            // This is what a user has to implement: A function receiving the method name, the actual message to
                            // send (type checked) and the callback that's either provided with the error as its first
                            // argument or null and the actual response message.
                            setTimeout(callback.bind(this, Error("Not implemented, see: https://github.com/dcodeIO/ProtoBuf.js/wiki/Services")), 0); // Must be async!
                        };
                    };

                    // Extends ProtoBuf.Builder.Service
                    Service.prototype = Object.create(ProtoBuf.Builder.Service.prototype);

                    if (Object.defineProperty)
                        Object.defineProperty(Service, "$options", { "value": T.buildOpt() }),
                        Object.defineProperty(Service.prototype, "$options", { "value": Service["$options"] });

                    /**
                     * Asynchronously performs an RPC call using the given RPC implementation.
                     * @name ProtoBuf.Builder.Service.[Method]
                     * @function
                     * @param {!function(string, ProtoBuf.Builder.Message, function(Error, ProtoBuf.Builder.Message=))} rpcImpl RPC implementation
                     * @param {ProtoBuf.Builder.Message} req Request
                     * @param {function(Error, (ProtoBuf.Builder.Message|ByteBuffer|Buffer|string)=)} callback Callback receiving
                     *  the error if any and the response either as a pre-parsed message or as its raw bytes
                     * @abstract
                     */

                    /**
                     * Asynchronously performs an RPC call using the instance's RPC implementation.
                     * @name ProtoBuf.Builder.Service#[Method]
                     * @function
                     * @param {ProtoBuf.Builder.Message} req Request
                     * @param {function(Error, (ProtoBuf.Builder.Message|ByteBuffer|Buffer|string)=)} callback Callback receiving
                     *  the error if any and the response either as a pre-parsed message or as its raw bytes
                     * @abstract
                     */

                    var rpc = T.getChildren(ProtoBuf.Reflect.Service.RPCMethod);
                    for (var i=0; i<rpc.length; i++) {
                        (function(method) {

                            // service#Method(message, callback)
                            Service.prototype[method.name] = function(req, callback) {
                                try {
                                    if (!req || !(req instanceof method.resolvedRequestType.clazz)) {
                                        setTimeout(callback.bind(this, Error("Illegal request type provided to service method "+T.name+"#"+method.name)), 0);
                                        return;
                                    }
                                    this.rpcImpl(method.fqn(), req, function(err, res) { // Assumes that this is properly async
                                        if (err) {
                                            callback(err);
                                            return;
                                        }
                                        try { res = method.resolvedResponseType.clazz.decode(res); } catch (notABuffer) {}
                                        if (!res || !(res instanceof method.resolvedResponseType.clazz)) {
                                            callback(Error("Illegal response type received in service method "+ T.name+"#"+method.name));
                                            return;
                                        }
                                        callback(null, res);
                                    });
                                } catch (err) {
                                    setTimeout(callback.bind(this, err), 0);
                                }
                            };

                            // Service.Method(rpcImpl, message, callback)
                            Service[method.name] = function(rpcImpl, req, callback) {
                                new Service(rpcImpl)[method.name](req, callback);
                            };

                            if (Object.defineProperty)
                                Object.defineProperty(Service[method.name], "$options", { "value": method.buildOpt() }),
                                Object.defineProperty(Service.prototype[method.name], "$options", { "value": Service[method.name]["$options"] });
                        })(rpc[i]);
                    }

                    return Service;

                })(ProtoBuf, this);
            };

            /**
             * @alias ProtoBuf.Reflect.Service
             * @expose
             */
            Reflect.Service = Service;

            /**
             * Abstract service method.
             * @exports ProtoBuf.Reflect.Service.Method
             * @param {!ProtoBuf.Reflect.Service} svc Service
             * @param {string} name Method name
             * @param {Object.<string,*>=} options Options
             * @constructor
             * @extends ProtoBuf.Reflect.T
             */
            var Method = function(svc, name, options) {
                T.call(this, svc, name);

                /**
                 * @override
                 */
                this.className = "Service.Method";

                /**
                 * Options.
                 * @type {Object.<string, *>}
                 * @expose
                 */
                this.options = options || {};
            };

            // Extends T
            Method.prototype = Object.create(T.prototype);

            /**
             * Builds the method's '$options' property.
             * @name ProtoBuf.Reflect.Service.Method#buildOpt
             * @function
             * @return {Object.<string,*>}
             */
            Method.prototype.buildOpt = Namespace.prototype.buildOpt;

            /**
             * @alias ProtoBuf.Reflect.Service.Method
             * @expose
             */
            Reflect.Service.Method = Method;

            /**
             * RPC service method.
             * @exports ProtoBuf.Reflect.Service.RPCMethod
             * @param {!ProtoBuf.Reflect.Service} svc Service
             * @param {string} name Method name
             * @param {string} request Request message name
             * @param {string} response Response message name
             * @param {Object.<string,*>=} options Options
             * @constructor
             * @extends ProtoBuf.Reflect.Service.Method
             */
            var RPCMethod = function(svc, name, request, response, options) {
                Method.call(this, svc, name, options);

                /**
                 * @override
                 */
                this.className = "Service.RPCMethod";

                /**
                 * Request message name.
                 * @type {string}
                 * @expose
                 */
                this.requestName = request;

                /**
                 * Response message name.
                 * @type {string}
                 * @expose
                 */
                this.responseName = response;

                /**
                 * Resolved request message type.
                 * @type {ProtoBuf.Reflect.Message}
                 * @expose
                 */
                this.resolvedRequestType = null;

                /**
                 * Resolved response message type.
                 * @type {ProtoBuf.Reflect.Message}
                 * @expose
                 */
                this.resolvedResponseType = null;
            };

            // Extends Method
            RPCMethod.prototype = Object.create(Method.prototype);

            /**
             * @alias ProtoBuf.Reflect.Service.RPCMethod
             * @expose
             */
            Reflect.Service.RPCMethod = RPCMethod;

            return Reflect;
        })(ProtoBuf);

        /**
         * @alias ProtoBuf.Builder
         * @expose
         */
        ProtoBuf.Builder = (function(ProtoBuf, Lang, Reflect) {
            "use strict";

            /**
             * Constructs a new Builder.
             * @exports ProtoBuf.Builder
             * @class Provides the functionality to build protocol messages.
             * @constructor
             */
            var Builder = function() {

                /**
                 * Namespace.
                 * @type {ProtoBuf.Reflect.Namespace}
                 * @expose
                 */
                this.ns = new Reflect.Namespace(null, ""); // Global namespace

                /**
                 * Namespace pointer.
                 * @type {ProtoBuf.Reflect.T}
                 * @expose
                 */
                this.ptr = this.ns;

                /**
                 * Resolved flag.
                 * @type {boolean}
                 * @expose
                 */
                this.resolved = false;

                /**
                 * The current building result.
                 * @type {Object.<string,ProtoBuf.Builder.Message|Object>|null}
                 * @expose
                 */
                this.result = null;

                /**
                 * Imported files.
                 * @type {Array.<string>}
                 * @expose
                 */
                this.files = {};

                /**
                 * Import root override.
                 * @type {?string}
                 * @expose
                 */
                this.importRoot = null;
            };

            /**
             * Resets the pointer to the root namespace.
             * @expose
             */
            Builder.prototype.reset = function() {
                this.ptr = this.ns;
            };

            /**
             * Defines a package on top of the current pointer position and places the pointer on it.
             * @param {string} pkg
             * @param {Object.<string,*>=} options
             * @return {ProtoBuf.Builder} this
             * @throws {Error} If the package name is invalid
             * @expose
             */
            Builder.prototype.define = function(pkg, options) {
                if (typeof pkg !== 'string' || !Lang.TYPEREF.test(pkg))
                    throw Error("Illegal package: "+pkg);
                var part = pkg.split("."), i;
                for (i=0; i<part.length; i++) // To be absolutely sure
                    if (!Lang.NAME.test(part[i]))
                        throw Error("Illegal package: "+part[i]);
                for (i=0; i<part.length; i++) {
                    if (!this.ptr.hasChild(part[i])) // Keep existing namespace
                        this.ptr.addChild(new Reflect.Namespace(this.ptr, part[i], options));
                    this.ptr = this.ptr.getChild(part[i]);
                }
                return this;
            };

            /**
             * Tests if a definition is a valid message definition.
             * @param {Object.<string,*>} def Definition
             * @return {boolean} true if valid, else false
             * @expose
             */
            Builder.isValidMessage = function(def) {
                // Messages require a string name
                if (typeof def["name"] !== 'string' || !Lang.NAME.test(def["name"]))
                    return false;
                // Messages must not contain values (that'd be an enum) or methods (that'd be a service)
                if (typeof def["values"] !== 'undefined' || typeof def["rpc"] !== 'undefined')
                    return false;
                // Fields, enums and messages are arrays if provided
                var i;
                if (typeof def["fields"] !== 'undefined') {
                    if (!ProtoBuf.Util.isArray(def["fields"]))
                        return false;
                    var ids = [], id; // IDs must be unique
                    for (i=0; i<def["fields"].length; i++) {
                        if (!Builder.isValidMessageField(def["fields"][i]))
                            return false;
                        id = parseInt(def["fields"][i]["id"], 10);
                        if (ids.indexOf(id) >= 0)
                            return false;
                        ids.push(id);
                    }
                    ids = null;
                }
                if (typeof def["enums"] !== 'undefined') {
                    if (!ProtoBuf.Util.isArray(def["enums"]))
                        return false;
                    for (i=0; i<def["enums"].length; i++)
                        if (!Builder.isValidEnum(def["enums"][i]))
                            return false;
                }
                if (typeof def["messages"] !== 'undefined') {
                    if (!ProtoBuf.Util.isArray(def["messages"]))
                        return false;
                    for (i=0; i<def["messages"].length; i++)
                        if (!Builder.isValidMessage(def["messages"][i]) && !Builder.isValidExtend(def["messages"][i]))
                            return false;
                }
                if (typeof def["extensions"] !== 'undefined')
                    if (!ProtoBuf.Util.isArray(def["extensions"]) || def["extensions"].length !== 2 || typeof def["extensions"][0] !== 'number' || typeof def["extensions"][1] !== 'number')
                        return false;
                return true;
            };

            /**
             * Tests if a definition is a valid message field definition.
             * @param {Object} def Definition
             * @return {boolean} true if valid, else false
             * @expose
             */
            Builder.isValidMessageField = function(def) {
                // Message fields require a string rule, name and type and an id
                if (typeof def["rule"] !== 'string' || typeof def["name"] !== 'string' || typeof def["type"] !== 'string' || typeof def["id"] === 'undefined')
                    return false;
                if (!Lang.RULE.test(def["rule"]) || !Lang.NAME.test(def["name"]) || !Lang.TYPEREF.test(def["type"]) || !Lang.ID.test(""+def["id"]))
                    return false;
                if (typeof def["options"] !== 'undefined') {
                    // Options are objects
                    if (typeof def["options"] !== 'object')
                        return false;
                    // Options are <string,string|number|boolean>
                    var keys = Object.keys(def["options"]);
                    for (var i=0, key; i<keys.length; i++)
                        if (typeof (key = keys[i]) !== 'string' || (typeof def["options"][key] !== 'string' && typeof def["options"][key] !== 'number' && typeof def["options"][key] !== 'boolean'))
                            return false;
                }
                return true;
            };

            /**
             * Tests if a definition is a valid enum definition.
             * @param {Object} def Definition
             * @return {boolean} true if valid, else false
             * @expose
             */
            Builder.isValidEnum = function(def) {
                // Enums require a string name
                if (typeof def["name"] !== 'string' || !Lang.NAME.test(def["name"]))
                    return false;
                // Enums require at least one value
                if (typeof def["values"] === 'undefined' || !ProtoBuf.Util.isArray(def["values"]) || def["values"].length == 0)
                    return false;
                for (var i=0; i<def["values"].length; i++) {
                    // Values are objects
                    if (typeof def["values"][i] != "object")
                        return false;
                    // Values require a string name and an id
                    if (typeof def["values"][i]["name"] !== 'string' || typeof def["values"][i]["id"] === 'undefined')
                        return false;
                    if (!Lang.NAME.test(def["values"][i]["name"]) || !Lang.NEGID.test(""+def["values"][i]["id"]))
                        return false;
                }
                // It's not important if there are other fields because ["values"] is already unique
                return true;
            };

            /**
             * Creates ths specified protocol types at the current pointer position.
             * @param {Array.<Object.<string,*>>} defs Messages, enums or services to create
             * @return {ProtoBuf.Builder} this
             * @throws {Error} If a message definition is invalid
             * @expose
             */
            Builder.prototype.create = function(defs) {
                if (!defs)
                    return this; // Nothing to create
                if (!ProtoBuf.Util.isArray(defs))
                    defs = [defs];
                if (defs.length == 0)
                    return this;

                // It's quite hard to keep track of scopes and memory here, so let's do this iteratively.
                var stack = [], def, obj, subObj, i, j;
                stack.push(defs); // One level [a, b, c]
                while (stack.length > 0) {
                    defs = stack.pop();
                    if (ProtoBuf.Util.isArray(defs)) { // Stack always contains entire namespaces
                        while (defs.length > 0) {
                            def = defs.shift(); // Namespace always contains an array of messages, enums and services
                            if (Builder.isValidMessage(def)) {
                                obj = new Reflect.Message(this.ptr, def["name"], def["options"], def["isGroup"]);
                                // Create fields
                                if (def["fields"] && def["fields"].length > 0) {
                                    for (i=0; i<def["fields"].length; i++) { // i=Fields
                                        if (obj.hasChild(def['fields'][i]['id']))
                                            throw Error("Duplicate field id in message "+obj.name+": "+def['fields'][i]['id']);
                                        if (def["fields"][i]["options"]) {
                                            subObj = Object.keys(def["fields"][i]["options"]);
                                            for (j=0; j<subObj.length; j++) { // j=Option names
                                                if (typeof subObj[j] !== 'string')
                                                    throw Error("Illegal field option name in message "+obj.name+"#"+def["fields"][i]["name"]+": "+subObj[j]);
                                                if (typeof def["fields"][i]["options"][subObj[j]] !== 'string' && typeof def["fields"][i]["options"][subObj[j]] !== 'number' && typeof def["fields"][i]["options"][subObj[j]] !== 'boolean')
                                                    throw Error("Illegal field option value in message "+obj.name+"#"+def["fields"][i]["name"]+"#"+subObj[j]+": "+def["fields"][i]["options"][subObj[j]]);
                                            }
                                            subObj = null;
                                        }
                                        obj.addChild(new Reflect.Message.Field(obj, def["fields"][i]["rule"], def["fields"][i]["type"], def["fields"][i]["name"], def["fields"][i]["id"], def["fields"][i]["options"]));
                                    }
                                }
                                // Push enums and messages to stack
                                subObj = [];
                                if (typeof def["enums"] !== 'undefined' && def['enums'].length > 0)
                                    for (i=0; i<def["enums"].length; i++)
                                        subObj.push(def["enums"][i]);
                                if (def["messages"] && def["messages"].length > 0)
                                    for (i=0; i<def["messages"].length; i++)
                                        subObj.push(def["messages"][i]);
                                // Set extension range
                                if (def["extensions"]) {
                                    obj.extensions = def["extensions"];
                                    if (obj.extensions[0] < ProtoBuf.ID_MIN)
                                        obj.extensions[0] = ProtoBuf.ID_MIN;
                                    if (obj.extensions[1] > ProtoBuf.ID_MAX)
                                        obj.extensions[1] = ProtoBuf.ID_MAX;
                                }
                                this.ptr.addChild(obj); // Add to current namespace
                                if (subObj.length > 0) {
                                    stack.push(defs); // Push the current level back
                                    defs = subObj; // Continue processing sub level
                                    subObj = null;
                                    this.ptr = obj; // And move the pointer to this namespace
                                    obj = null;
                                    continue;
                                }
                                subObj = null;
                                obj = null;
                            } else if (Builder.isValidEnum(def)) {
                                obj = new Reflect.Enum(this.ptr, def["name"], def["options"]);
                                for (i=0; i<def["values"].length; i++)
                                    obj.addChild(new Reflect.Enum.Value(obj, def["values"][i]["name"], def["values"][i]["id"]));
                                this.ptr.addChild(obj);
                                obj = null;
                            } else if (Builder.isValidService(def)) {
                                obj = new Reflect.Service(this.ptr, def["name"], def["options"]);
                                for (i in def["rpc"])
                                    if (def["rpc"].hasOwnProperty(i))
                                        obj.addChild(new Reflect.Service.RPCMethod(obj, i, def["rpc"][i]["request"], def["rpc"][i]["response"], def["rpc"][i]["options"]));
                                this.ptr.addChild(obj);
                                obj = null;
                            } else if (Builder.isValidExtend(def)) {
                                obj = this.ptr.resolve(def["ref"]);
                                if (obj) {
                                    for (i=0; i<def["fields"].length; i++) { // i=Fields
                                        if (obj.hasChild(def['fields'][i]['id']))
                                            throw Error("Duplicate extended field id in message "+obj.name+": "+def['fields'][i]['id']);
                                        if (def['fields'][i]['id'] < obj.extensions[0] || def['fields'][i]['id'] > obj.extensions[1])
                                            throw Error("Illegal extended field id in message "+obj.name+": "+def['fields'][i]['id']+" ("+obj.extensions.join(' to ')+" expected)");
                                        // TODO: See #161
                                        /* subObj = new (this.ptr instanceof Reflect.Message ? Reflect.Message.ExtensionField : Reflect.Message.Field)(obj, def["fields"][i]["rule"], def["fields"][i]["type"], def["fields"][i]["name"], def["fields"][i]["id"], def["fields"][i]["options"]);
                                        if (this.ptr instanceof Reflect.Message)
                                            this.ptr.addChild(subObj);
                                        else
                                            obj.addChild(subObj); */
                                        obj.addChild(new Reflect.Message.Field(obj, def["fields"][i]["rule"], def["fields"][i]["type"], def["fields"][i]["name"], def["fields"][i]["id"], def["fields"][i]["options"]));
                                    }
                                } else if (!/\.?google\.protobuf\./.test(def["ref"])) // Silently skip internal extensions
                                    throw Error("Extended message "+def["ref"]+" is not defined");
                            } else
                                throw Error("Not a valid definition: "+JSON.stringify(def));
                            def = null;
                        }
                        // Break goes here
                    } else
                        throw Error("Not a valid namespace: "+JSON.stringify(defs));
                    defs = null;
                    this.ptr = this.ptr.parent; // This namespace is s done
                }
                this.resolved = false; // Require re-resolve
                this.result = null; // Require re-build
                return this;
            };

            /**
             * Imports another definition into this builder.
             * @param {Object.<string,*>} json Parsed import
             * @param {(string|{root: string, file: string})=} filename Imported file name
             * @return {ProtoBuf.Builder} this
             * @throws {Error} If the definition or file cannot be imported
             * @expose
             */
            Builder.prototype["import"] = function(json, filename) {
                if (typeof filename === 'string') {
                    if (ProtoBuf.Util.IS_NODE)
                        filename = require("path")['resolve'](filename);
                    if (this.files[filename] === true) {
                        this.reset();
                        return this; // Skip duplicate imports
                    }
                    this.files[filename] = true;
                }
                if (!!json['imports'] && json['imports'].length > 0) {
                    var importRoot, delim = '/', resetRoot = false;
                    if (typeof filename === 'object') { // If an import root is specified, override
                        this.importRoot = filename["root"]; resetRoot = true; // ... and reset afterwards
                        importRoot = this.importRoot;
                        filename = filename["file"];
                        if (importRoot.indexOf("\\") >= 0 || filename.indexOf("\\") >= 0) delim = '\\';
                    } else if (typeof filename === 'string') {
                        if (this.importRoot) // If import root is overridden, use it
                            importRoot = this.importRoot;
                        else { // Otherwise compute from filename
                            if (filename.indexOf("/") >= 0) { // Unix
                                importRoot = filename.replace(/\/[^\/]*$/, "");
                                if (/* /file.proto */ importRoot === "")
                                    importRoot = "/";
                            } else if (filename.indexOf("\\") >= 0) { // Windows
                                importRoot = filename.replace(/\\[^\\]*$/, "");
                                delim = '\\';
                            } else
                                importRoot = ".";
                        }
                    } else
                        importRoot = null;

                    for (var i=0; i<json['imports'].length; i++) {
                        if (typeof json['imports'][i] === 'string') { // Import file
                            if (!importRoot)
                                throw Error("Cannot determine import root: File name is unknown");
                            var importFilename = json['imports'][i];
                            if (/^google\/protobuf\//.test(importFilename))
                                continue; // Not needed and therefore not used
                            importFilename = importRoot+delim+importFilename;
                            if (this.files[importFilename] === true)
                                continue; // Already imported
                            if (/\.proto$/i.test(importFilename) && !ProtoBuf.DotProto)     // If this is a NOPARSE build
                                importFilename = importFilename.replace(/\.proto$/, ".json"); // always load the JSON file
                            var contents = ProtoBuf.Util.fetch(importFilename);
                            if (contents === null)
                                throw Error("Failed to import '"+importFilename+"' in '"+filename+"': File not found");
                            if (/\.json$/i.test(importFilename)) // Always possible
                                this["import"](JSON.parse(contents+""), importFilename); // May throw
                            else
                                this["import"]((new ProtoBuf.DotProto.Parser(contents+"")).parse(), importFilename); // May throw
                        } else // Import structure
                            if (!filename)
                                this["import"](json['imports'][i]);
                            else if (/\.(\w+)$/.test(filename)) // With extension: Append _importN to the name portion to make it unique
                                this["import"](json['imports'][i], filename.replace(/^(.+)\.(\w+)$/, function($0, $1, $2) { return $1+"_import"+i+"."+$2; }));
                            else // Without extension: Append _importN to make it unique
                                this["import"](json['imports'][i], filename+"_import"+i);
                    }
                    if (resetRoot) // Reset import root override when all imports are done
                        this.importRoot = null;
                }
                if (json['messages']) {
                    if (json['package'])
                        this.define(json['package'], json["options"]);
                    this.create(json['messages']);
                    this.reset();
                }
                if (json['enums']) {
                    if (json['package'])
                        this.define(json['package'], json["options"]);
                    this.create(json['enums']);
                    this.reset();
                }
                if (json['services']) {
                    if (json['package'])
                        this.define(json['package'], json["options"]);
                    this.create(json['services']);
                    this.reset();
                }
                if (json['extends']) {
                    if (json['package'])
                        this.define(json['package'], json["options"]);
                    this.create(json['extends']);
                    this.reset();
                }
                return this;
            };

            /**
             * Tests if a definition is a valid service definition.
             * @param {Object} def Definition
             * @return {boolean} true if valid, else false
             * @expose
             */
            Builder.isValidService = function(def) {
                // Services require a string name and an rpc object
                return !(typeof def["name"] !== 'string' || !Lang.NAME.test(def["name"]) || typeof def["rpc"] !== 'object');
            };

            /**
             * Tests if a definition is a valid extension.
             * @param {Object} def Definition
             * @returns {boolean} true if valid, else false
             * @expose
            */
            Builder.isValidExtend = function(def) {
                if (typeof def["ref"] !== 'string' || !Lang.TYPEREF.test(def["ref"]))
                    return false;
                var i;
                if (typeof def["fields"] !== 'undefined') {
                    if (!ProtoBuf.Util.isArray(def["fields"]))
                        return false;
                    var ids = [], id; // IDs must be unique (does not yet test for the extended message's ids)
                    for (i=0; i<def["fields"].length; i++) {
                        if (!Builder.isValidMessageField(def["fields"][i]))
                            return false;
                        id = parseInt(def["id"], 10);
                        if (ids.indexOf(id) >= 0)
                            return false;
                        ids.push(id);
                    }
                    ids = null;
                }
                return true;
            };

            /**
             * Resolves all namespace objects.
             * @throws {Error} If a type cannot be resolved
             * @expose
             */
            Builder.prototype.resolveAll = function() {
                // Resolve all reflected objects
                var res;
                if (this.ptr == null || typeof this.ptr.type === 'object')
                    return; // Done (already resolved)
                if (this.ptr instanceof Reflect.Namespace) {
                    // Build all children
                    var children = this.ptr.getChildren();
                    for (var i=0; i<children.length; i++)
                        this.ptr = children[i], this.resolveAll();
                } else if (this.ptr instanceof Reflect.Message.Field) {
                    if (!Lang.TYPE.test(this.ptr.type)) { // Resolve type...
                        if (!Lang.TYPEREF.test(this.ptr.type))
                            throw Error("Illegal type reference in "+this.ptr.toString(true)+": "+this.ptr.type);
                        res = this.ptr.parent.resolve(this.ptr.type, true);
                        if (!res)
                            throw Error("Unresolvable type reference in "+this.ptr.toString(true)+": "+this.ptr.type);
                        this.ptr.resolvedType = res;
                        if (res instanceof Reflect.Enum)
                            this.ptr.type = ProtoBuf.TYPES["enum"];
                        else if (res instanceof Reflect.Message)
                            this.ptr.type = res.isGroup ? ProtoBuf.TYPES["group"] : ProtoBuf.TYPES["message"];
                        else
                            throw Error("Illegal type reference in "+this.ptr.toString(true)+": "+this.ptr.type);
                    } else
                        this.ptr.type = ProtoBuf.TYPES[this.ptr.type];
                } else if (this.ptr instanceof ProtoBuf.Reflect.Enum.Value) {
                    // No need to build enum values (built in enum)
                } else if (this.ptr instanceof ProtoBuf.Reflect.Service.Method) {
                    if (this.ptr instanceof ProtoBuf.Reflect.Service.RPCMethod) {
                        res = this.ptr.parent.resolve(this.ptr.requestName);
                        if (!res || !(res instanceof ProtoBuf.Reflect.Message))
                            throw Error("Illegal type reference in "+this.ptr.toString(true)+": "+this.ptr.requestName);
                        this.ptr.resolvedRequestType = res;
                        res = this.ptr.parent.resolve(this.ptr.responseName);
                        if (!res || !(res instanceof ProtoBuf.Reflect.Message))
                            throw Error("Illegal type reference in "+this.ptr.toString(true)+": "+this.ptr.responseName);
                        this.ptr.resolvedResponseType = res;
                    } else {
                        // Should not happen as nothing else is implemented
                        throw Error("Illegal service type in "+this.ptr.toString(true));
                    }
                } else
                    throw Error("Illegal object in namespace: "+typeof(this.ptr)+":"+this.ptr);
                this.reset();
            };

            /**
             * Builds the protocol. This will first try to resolve all definitions and, if this has been successful,
             * return the built package.
             * @param {string=} path Specifies what to return. If omitted, the entire namespace will be returned.
             * @return {ProtoBuf.Builder.Message|Object.<string,*>}
             * @throws {Error} If a type could not be resolved
             * @expose
             */
            Builder.prototype.build = function(path) {
                this.reset();
                if (!this.resolved)
                    this.resolveAll(),
                    this.resolved = true,
                    this.result = null; // Require re-build
                if (this.result == null) // (Re-)Build
                    this.result = this.ns.build();
                if (!path)
                    return this.result;
                else {
                    var part = path.split(".");
                    var ptr = this.result; // Build namespace pointer (no hasChild etc.)
                    for (var i=0; i<part.length; i++)
                        if (ptr[part[i]])
                            ptr = ptr[part[i]];
                        else {
                            ptr = null;
                            break;
                        }
                    return ptr;
                }
            };

            /**
             * Similar to {@link ProtoBuf.Builder#build}, but looks up the internal reflection descriptor.
             * @param {string=} path Specifies what to return. If omitted, the entire namespace wiil be returned.
             * @return {ProtoBuf.Reflect.T} Reflection descriptor or `null` if not found
             */
            Builder.prototype.lookup = function(path) {
                return path ? this.ns.resolve(path) : this.ns;
            };

            /**
             * Returns a string representation of this object.
             * @return {string} String representation as of "Builder"
             * @expose
             */
            Builder.prototype.toString = function() {
                return "Builder";
            };

            // Pseudo types documented in Reflect.js.
            // Exist for the sole purpose of being able to "... instanceof ProtoBuf.Builder.Message" etc.
            Builder.Message = function() {};
            Builder.Service = function() {};

            return Builder;

        })(ProtoBuf, ProtoBuf.Lang, ProtoBuf.Reflect);


        /**
         * Loads a .proto string and returns the Builder.
         * @param {string} proto .proto file contents
         * @param {(ProtoBuf.Builder|string|{root: string, file: string})=} builder Builder to append to. Will create a new one if omitted.
         * @param {(string|{root: string, file: string})=} filename The corresponding file name if known. Must be specified for imports.
         * @return {ProtoBuf.Builder} Builder to create new messages
         * @throws {Error} If the definition cannot be parsed or built
         * @expose
         */
        ProtoBuf.loadProto = function(proto, builder, filename) {
            if (typeof builder === 'string' || (builder && typeof builder["file"] === 'string' && typeof builder["root"] === 'string')) {
                filename = builder;
                builder = null;
            }
            return ProtoBuf.loadJson((new ProtoBuf.DotProto.Parser(proto)).parse(), builder, filename);
        };

        /**
         * Loads a .proto string and returns the Builder. This is an alias of {@link ProtoBuf.loadProto}.
         * @function
         * @param {string} proto .proto file contents
         * @param {(ProtoBuf.Builder|string)=} builder Builder to append to. Will create a new one if omitted.
         * @param {(string|{root: string, file: string})=} filename The corresponding file name if known. Must be specified for imports.
         * @return {ProtoBuf.Builder} Builder to create new messages
         * @throws {Error} If the definition cannot be parsed or built
         * @expose
         */
        ProtoBuf.protoFromString = ProtoBuf.loadProto; // Legacy

        /**
         * Loads a .proto file and returns the Builder.
         * @param {string|{root: string, file: string}} filename Path to proto file or an object specifying 'file' with
         *  an overridden 'root' path for all imported files.
         * @param {function(?Error, !ProtoBuf.Builder=)=} callback Callback that will receive `null` as the first and
         *  the Builder as its second argument on success, otherwise the error as its first argument. If omitted, the
         *  file will be read synchronously and this function will return the Builder.
         * @param {ProtoBuf.Builder=} builder Builder to append to. Will create a new one if omitted.
         * @return {?ProtoBuf.Builder|undefined} The Builder if synchronous (no callback specified, will be NULL if the
         *   request has failed), else undefined
         * @expose
         */
        ProtoBuf.loadProtoFile = function(filename, callback, builder) {
            if (callback && typeof callback === 'object')
                builder = callback,
                callback = null;
            else if (!callback || typeof callback !== 'function')
                callback = null;
            if (callback)
                return ProtoBuf.Util.fetch(typeof filename === 'string' ? filename : filename["root"]+"/"+filename["file"], function(contents) {
                    if (contents === null) {
                        callback(Error("Failed to fetch file"));
                        return;
                    }
                    try {
                        callback(null, ProtoBuf.loadProto(contents, builder, filename));
                    } catch (e) {
                        callback(e);
                    }
                });
            var contents = ProtoBuf.Util.fetch(typeof filename === 'object' ? filename["root"]+"/"+filename["file"] : filename);
            return contents === null ? null : ProtoBuf.loadProto(contents, builder, filename);
        };

        /**
         * Loads a .proto file and returns the Builder. This is an alias of {@link ProtoBuf.loadProtoFile}.
         * @function
         * @param {string|{root: string, file: string}} filename Path to proto file or an object specifying 'file' with
         *  an overridden 'root' path for all imported files.
         * @param {function(?Error, !ProtoBuf.Builder=)=} callback Callback that will receive `null` as the first and
         *  the Builder as its second argument on success, otherwise the error as its first argument. If omitted, the
         *  file will be read synchronously and this function will return the Builder.
         * @param {ProtoBuf.Builder=} builder Builder to append to. Will create a new one if omitted.
         * @return {!ProtoBuf.Builder|undefined} The Builder if synchronous (no callback specified, will be NULL if the
         *   request has failed), else undefined
         * @expose
         */
        ProtoBuf.protoFromFile = ProtoBuf.loadProtoFile; // Legacy


        /**
         * Constructs a new Builder with the specified package defined.
         * @param {string=} pkg Package name as fully qualified name, e.g. "My.Game". If no package is specified, the
         * builder will only contain a global namespace.
         * @param {Object.<string,*>=} options Top level options
         * @return {ProtoBuf.Builder} New Builder
         * @expose
         */
        ProtoBuf.newBuilder = function(pkg, options) {
            var builder = new ProtoBuf.Builder();
            if (typeof pkg !== 'undefined' && pkg !== null)
                builder.define(pkg, options);
            return builder;
        };

        /**
         * Loads a .json definition and returns the Builder.
         * @param {!*|string} json JSON definition
         * @param {(ProtoBuf.Builder|string|{root: string, file: string})=} builder Builder to append to. Will create a new one if omitted.
         * @param {(string|{root: string, file: string})=} filename The corresponding file name if known. Must be specified for imports.
         * @return {ProtoBuf.Builder} Builder to create new messages
         * @throws {Error} If the definition cannot be parsed or built
         * @expose
         */
        ProtoBuf.loadJson = function(json, builder, filename) {
            if (typeof builder === 'string' || (builder && typeof builder["file"] === 'string' && typeof builder["root"] === 'string'))
                filename = builder,
                builder = null;
            if (!builder || typeof builder !== 'object')
                builder = ProtoBuf.newBuilder();
            if (typeof json === 'string')
                json = JSON.parse(json);
            builder["import"](json, filename);
            builder.resolveAll();
            builder.build();
            return builder;
        };

        /**
         * Loads a .json file and returns the Builder.
         * @param {string|!{root: string, file: string}} filename Path to json file or an object specifying 'file' with
         *  an overridden 'root' path for all imported files.
         * @param {function(?Error, !ProtoBuf.Builder=)=} callback Callback that will receive `null` as the first and
         *  the Builder as its second argument on success, otherwise the error as its first argument. If omitted, the
         *  file will be read synchronously and this function will return the Builder.
         * @param {ProtoBuf.Builder=} builder Builder to append to. Will create a new one if omitted.
         * @return {?ProtoBuf.Builder|undefined} The Builder if synchronous (no callback specified, will be NULL if the
         *   request has failed), else undefined
         * @expose
         */
        ProtoBuf.loadJsonFile = function(filename, callback, builder) {
            if (callback && typeof callback === 'object')
                builder = callback,
                callback = null;
            else if (!callback || typeof callback !== 'function')
                callback = null;
            if (callback)
                return ProtoBuf.Util.fetch(typeof filename === 'string' ? filename : filename["root"]+"/"+filename["file"], function(contents) {
                    if (contents === null) {
                        callback(Error("Failed to fetch file"));
                        return;
                    }
                    try {
                        callback(null, ProtoBuf.loadJson(JSON.parse(contents), builder, filename));
                    } catch (e) {
                        callback(e);
                    }
                });
            var contents = ProtoBuf.Util.fetch(typeof filename === 'object' ? filename["root"]+"/"+filename["file"] : filename);
            return contents === null ? null : ProtoBuf.loadJson(JSON.parse(contents), builder, filename);
        };

        return ProtoBuf;
    }

    /* CommonJS */ if (typeof module !== 'undefined' && module["exports"])
        module["exports"] = init(require("bytebuffer"));
    /* AMD */ else if (typeof define === 'function' && define["amd"])
        define(["ByteBuffer"], init);
    /* Global */ else
        (global["dcodeIO"] = global["dcodeIO"] || {})["ProtoBuf"] = init(global["dcodeIO"]["ByteBuffer"]);

})(this);

},{"bytebuffer":54,"fs":46,"path":50}],53:[function(require,module,exports){
/*
 Copyright 2013 Daniel Wirtz <dcode@dcode.io>

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 */
var ProtoBuf = require("./dist/ProtoBuf.js");

module.exports = ProtoBuf;

},{"./dist/ProtoBuf.js":52}],54:[function(require,module,exports){
/*
 ByteBuffer.js (c) 2013-2014 Daniel Wirtz <dcode@dcode.io>
 This version of ByteBuffer.js uses an ArrayBuffer (AB) as its backing buffer and is compatible with modern browsers.
 Released under the Apache License, Version 2.0
 see: https://github.com/dcodeIO/ByteBuffer.js for details
*/
(function(r){function s(l){function d(a,b,c){"undefined"===typeof a&&(a=d.DEFAULT_CAPACITY);"undefined"===typeof b&&(b=d.DEFAULT_ENDIAN);"undefined"===typeof c&&(c=d.DEFAULT_NOASSERT);if(!c){a|=0;if(0>a)throw new RangeError("Illegal capacity: 0 <= "+a);if("boolean"!==typeof b)throw new TypeError("Illegal littleEndian: Not a boolean");if("boolean"!==typeof c)throw new TypeError("Illegal noAssert: Not a boolean");}this.buffer=0===a?r:new ArrayBuffer(a);this.view=0===a?null:new DataView(this.buffer);
this.offset=0;this.markedOffset=-1;this.limit=a;this.littleEndian="undefined"!==typeof b?!!b:!1;this.noAssert=!!c}d.VERSION="3.1.0";d.LITTLE_ENDIAN=!0;d.BIG_ENDIAN=!1;d.DEFAULT_CAPACITY=16;d.DEFAULT_ENDIAN=d.BIG_ENDIAN;d.DEFAULT_NOASSERT=!1;d.Long=l||null;var r=new ArrayBuffer(0);d.allocate=function(a,b,c){return new d(a,b,c)};d.concat=function(a,b,c,e){if("boolean"===typeof b||"string"!==typeof b)e=c,c=b,b=void 0;for(var h=0,f=0,g=a.length,n;f<g;++f)d.isByteBuffer(a[f])||(a[f]=d.wrap(a[f],b)),n=
a[f].limit-a[f].offset,0<n&&(h+=n);if(0===h)return new d(0,c,e);b=new d(h,c,e);e=new Uint8Array(b.buffer);for(f=0;f<g;)c=a[f++],n=c.limit-c.offset,0>=n||(e.set((new Uint8Array(c.buffer)).subarray(c.offset,c.limit),b.offset),b.offset+=n);b.limit=b.offset;b.offset=0;return b};d.isByteBuffer=function(a){return a&&a instanceof d};d.type=function(){return ArrayBuffer};d.wrap=function(a,b,c,e){"string"!==typeof b&&(e=c,c=b,b=void 0);if("string"===typeof a)switch("undefined"===typeof b&&(b="utf8"),b){case "base64":return d.fromBase64(a,
c);case "hex":return d.fromHex(a,c);case "binary":return d.fromBinary(a,c);case "utf8":return d.fromUTF8(a,c);case "debug":return d.fromDebug(a,c);default:throw new TypeError("Unsupported encoding: "+b);}if(null===a||"object"!==typeof a)throw new TypeError("Illegal buffer: null or non-object");if(d.isByteBuffer(a))return b=d.prototype.clone.call(a),b.markedOffset=-1,b;if(a instanceof Uint8Array)b=new d(0,c,e),0<a.length&&(b.buffer=a.buffer,b.offset=a.byteOffset,b.limit=a.byteOffset+a.length,b.view=
0<a.length?new DataView(a.buffer):null);else if(a instanceof ArrayBuffer)b=new d(0,c,e),0<a.byteLength&&(b.buffer=a,b.offset=0,b.limit=a.byteLength,b.view=0<a.byteLength?new DataView(a):null);else if("[object Array]"===Object.prototype.toString.call(a))for(b=new d(a.length,c,e),b.limit=a.length,i=0;i<a.length;++i)b.view.setUint8(i,a[i]);else throw new TypeError("Illegal buffer");return b};d.prototype.writeInt8=function(a,b){var c="undefined"===typeof b;c&&(b=this.offset);if(!this.noAssert){if("number"!==
typeof a||0!==a%1)throw new TypeError("Illegal value: "+a+" (not an integer)");a|=0;if("number"!==typeof b||0!==b%1)throw new TypeError("Illegal offset: "+b+" (not an integer)");b>>>=0;if(0>b||b+0>this.buffer.byteLength)throw new RangeError("Illegal offset: 0 <= "+b+" (+0) <= "+this.buffer.byteLength);}b+=1;var e=this.buffer.byteLength;b>e&&this.resize((e*=2)>b?e:b);this.view.setInt8(b-1,a);c&&(this.offset+=1);return this};d.prototype.writeByte=d.prototype.writeInt8;d.prototype.readInt8=function(a){var b=
"undefined"===typeof a;b&&(a=this.offset);if(!this.noAssert){if("number"!==typeof a||0!==a%1)throw new TypeError("Illegal offset: "+a+" (not an integer)");a>>>=0;if(0>a||a+1>this.buffer.byteLength)throw new RangeError("Illegal offset: 0 <= "+a+" (+1) <= "+this.buffer.byteLength);}a=this.view.getInt8(a);b&&(this.offset+=1);return a};d.prototype.readByte=d.prototype.readInt8;d.prototype.writeUint8=function(a,b){var c="undefined"===typeof b;c&&(b=this.offset);if(!this.noAssert){if("number"!==typeof a||
0!==a%1)throw new TypeError("Illegal value: "+a+" (not an integer)");a>>>=0;if("number"!==typeof b||0!==b%1)throw new TypeError("Illegal offset: "+b+" (not an integer)");b>>>=0;if(0>b||b+0>this.buffer.byteLength)throw new RangeError("Illegal offset: 0 <= "+b+" (+0) <= "+this.buffer.byteLength);}b+=1;var e=this.buffer.byteLength;b>e&&this.resize((e*=2)>b?e:b);this.view.setUint8(b-1,a);c&&(this.offset+=1);return this};d.prototype.readUint8=function(a){var b="undefined"===typeof a;b&&(a=this.offset);
if(!this.noAssert){if("number"!==typeof a||0!==a%1)throw new TypeError("Illegal offset: "+a+" (not an integer)");a>>>=0;if(0>a||a+1>this.buffer.byteLength)throw new RangeError("Illegal offset: 0 <= "+a+" (+1) <= "+this.buffer.byteLength);}a=this.view.getUint8(a);b&&(this.offset+=1);return a};d.prototype.writeInt16=function(a,b){var c="undefined"===typeof b;c&&(b=this.offset);if(!this.noAssert){if("number"!==typeof a||0!==a%1)throw new TypeError("Illegal value: "+a+" (not an integer)");a|=0;if("number"!==
typeof b||0!==b%1)throw new TypeError("Illegal offset: "+b+" (not an integer)");b>>>=0;if(0>b||b+0>this.buffer.byteLength)throw new RangeError("Illegal offset: 0 <= "+b+" (+0) <= "+this.buffer.byteLength);}b+=2;var e=this.buffer.byteLength;b>e&&this.resize((e*=2)>b?e:b);this.view.setInt16(b-2,a,this.littleEndian);c&&(this.offset+=2);return this};d.prototype.writeShort=d.prototype.writeInt16;d.prototype.readInt16=function(a){var b="undefined"===typeof a;b&&(a=this.offset);if(!this.noAssert){if("number"!==
typeof a||0!==a%1)throw new TypeError("Illegal offset: "+a+" (not an integer)");a>>>=0;if(0>a||a+2>this.buffer.byteLength)throw new RangeError("Illegal offset: 0 <= "+a+" (+2) <= "+this.buffer.byteLength);}a=this.view.getInt16(a,this.littleEndian);b&&(this.offset+=2);return a};d.prototype.readShort=d.prototype.readInt16;d.prototype.writeUint16=function(a,b){var c="undefined"===typeof b;c&&(b=this.offset);if(!this.noAssert){if("number"!==typeof a||0!==a%1)throw new TypeError("Illegal value: "+a+" (not an integer)");
a>>>=0;if("number"!==typeof b||0!==b%1)throw new TypeError("Illegal offset: "+b+" (not an integer)");b>>>=0;if(0>b||b+0>this.buffer.byteLength)throw new RangeError("Illegal offset: 0 <= "+b+" (+0) <= "+this.buffer.byteLength);}b+=2;var e=this.buffer.byteLength;b>e&&this.resize((e*=2)>b?e:b);this.view.setUint16(b-2,a,this.littleEndian);c&&(this.offset+=2);return this};d.prototype.readUint16=function(a){var b="undefined"===typeof a;b&&(a=this.offset);if(!this.noAssert){if("number"!==typeof a||0!==a%
1)throw new TypeError("Illegal offset: "+a+" (not an integer)");a>>>=0;if(0>a||a+2>this.buffer.byteLength)throw new RangeError("Illegal offset: 0 <= "+a+" (+2) <= "+this.buffer.byteLength);}a=this.view.getUint16(a,this.littleEndian);b&&(this.offset+=2);return a};d.prototype.writeInt32=function(a,b){var c="undefined"===typeof b;c&&(b=this.offset);if(!this.noAssert){if("number"!==typeof a||0!==a%1)throw new TypeError("Illegal value: "+a+" (not an integer)");a|=0;if("number"!==typeof b||0!==b%1)throw new TypeError("Illegal offset: "+
b+" (not an integer)");b>>>=0;if(0>b||b+0>this.buffer.byteLength)throw new RangeError("Illegal offset: 0 <= "+b+" (+0) <= "+this.buffer.byteLength);}b+=4;var e=this.buffer.byteLength;b>e&&this.resize((e*=2)>b?e:b);this.view.setInt32(b-4,a,this.littleEndian);c&&(this.offset+=4);return this};d.prototype.writeInt=d.prototype.writeInt32;d.prototype.readInt32=function(a){var b="undefined"===typeof a;b&&(a=this.offset);if(!this.noAssert){if("number"!==typeof a||0!==a%1)throw new TypeError("Illegal offset: "+
a+" (not an integer)");a>>>=0;if(0>a||a+4>this.buffer.byteLength)throw new RangeError("Illegal offset: 0 <= "+a+" (+4) <= "+this.buffer.byteLength);}a=this.view.getInt32(a,this.littleEndian);b&&(this.offset+=4);return a};d.prototype.readInt=d.prototype.readInt32;d.prototype.writeUint32=function(a,b){var c="undefined"===typeof b;c&&(b=this.offset);if(!this.noAssert){if("number"!==typeof a||0!==a%1)throw new TypeError("Illegal value: "+a+" (not an integer)");a>>>=0;if("number"!==typeof b||0!==b%1)throw new TypeError("Illegal offset: "+
b+" (not an integer)");b>>>=0;if(0>b||b+0>this.buffer.byteLength)throw new RangeError("Illegal offset: 0 <= "+b+" (+0) <= "+this.buffer.byteLength);}b+=4;var e=this.buffer.byteLength;b>e&&this.resize((e*=2)>b?e:b);this.view.setUint32(b-4,a,this.littleEndian);c&&(this.offset+=4);return this};d.prototype.readUint32=function(a){var b="undefined"===typeof a;b&&(a=this.offset);if(!this.noAssert){if("number"!==typeof a||0!==a%1)throw new TypeError("Illegal offset: "+a+" (not an integer)");a>>>=0;if(0>a||
a+4>this.buffer.byteLength)throw new RangeError("Illegal offset: 0 <= "+a+" (+4) <= "+this.buffer.byteLength);}a=this.view.getUint32(a,this.littleEndian);b&&(this.offset+=4);return a};l&&(d.prototype.writeInt64=function(a,b){var c="undefined"===typeof b;c&&(b=this.offset);if(!this.noAssert){if("number"===typeof a)a=l.fromNumber(a);else if(!(a&&a instanceof l))throw new TypeError("Illegal value: "+a+" (not an integer or Long)");if("number"!==typeof b||0!==b%1)throw new TypeError("Illegal offset: "+
b+" (not an integer)");b>>>=0;if(0>b||b+0>this.buffer.byteLength)throw new RangeError("Illegal offset: 0 <= "+b+" (+0) <= "+this.buffer.byteLength);}"number"===typeof a&&(a=l.fromNumber(a));b+=8;var e=this.buffer.byteLength;b>e&&this.resize((e*=2)>b?e:b);b-=8;this.littleEndian?(this.view.setInt32(b,a.low,!0),this.view.setInt32(b+4,a.high,!0)):(this.view.setInt32(b,a.high,!1),this.view.setInt32(b+4,a.low,!1));c&&(this.offset+=8);return this},d.prototype.writeLong=d.prototype.writeInt64,d.prototype.readInt64=
function(a){var b="undefined"===typeof a;b&&(a=this.offset);if(!this.noAssert){if("number"!==typeof a||0!==a%1)throw new TypeError("Illegal offset: "+a+" (not an integer)");a>>>=0;if(0>a||a+8>this.buffer.byteLength)throw new RangeError("Illegal offset: 0 <= "+a+" (+8) <= "+this.buffer.byteLength);}a=this.littleEndian?new l(this.view.getInt32(a,!0),this.view.getInt32(a+4,!0),!1):new l(this.view.getInt32(a+4,!1),this.view.getInt32(a,!1),!1);b&&(this.offset+=8);return a},d.prototype.readLong=d.prototype.readInt64,
d.prototype.writeUint64=function(a,b){var c="undefined"===typeof b;c&&(b=this.offset);if(!this.noAssert){if("number"===typeof a)a=l.fromNumber(a);else if(!(a&&a instanceof l))throw new TypeError("Illegal value: "+a+" (not an integer or Long)");if("number"!==typeof b||0!==b%1)throw new TypeError("Illegal offset: "+b+" (not an integer)");b>>>=0;if(0>b||b+0>this.buffer.byteLength)throw new RangeError("Illegal offset: 0 <= "+b+" (+0) <= "+this.buffer.byteLength);}"number"===typeof a&&(a=l.fromNumber(a));
b+=8;var e=this.buffer.byteLength;b>e&&this.resize((e*=2)>b?e:b);b-=8;this.littleEndian?(this.view.setInt32(b,a.low,!0),this.view.setInt32(b+4,a.high,!0)):(this.view.setInt32(b,a.high,!1),this.view.setInt32(b+4,a.low,!1));c&&(this.offset+=8);return this},d.prototype.readUint64=function(a){var b="undefined"===typeof a;b&&(a=this.offset);if(!this.noAssert){if("number"!==typeof a||0!==a%1)throw new TypeError("Illegal offset: "+a+" (not an integer)");a>>>=0;if(0>a||a+8>this.buffer.byteLength)throw new RangeError("Illegal offset: 0 <= "+
a+" (+8) <= "+this.buffer.byteLength);}a=this.littleEndian?new l(this.view.getInt32(a,!0),this.view.getInt32(a+4,!0),!0):new l(this.view.getInt32(a+4,!1),this.view.getInt32(a,!1),!0);b&&(this.offset+=8);return a});d.prototype.writeFloat32=function(a,b){var c="undefined"===typeof b;c&&(b=this.offset);if(!this.noAssert){if("number"!==typeof a)throw new TypeError("Illegal value: "+a+" (not a number)");if("number"!==typeof b||0!==b%1)throw new TypeError("Illegal offset: "+b+" (not an integer)");b>>>=
0;if(0>b||b+0>this.buffer.byteLength)throw new RangeError("Illegal offset: 0 <= "+b+" (+0) <= "+this.buffer.byteLength);}b+=4;var e=this.buffer.byteLength;b>e&&this.resize((e*=2)>b?e:b);this.view.setFloat32(b-4,a,this.littleEndian);c&&(this.offset+=4);return this};d.prototype.writeFloat=d.prototype.writeFloat32;d.prototype.readFloat32=function(a){var b="undefined"===typeof a;b&&(a=this.offset);if(!this.noAssert){if("number"!==typeof a||0!==a%1)throw new TypeError("Illegal offset: "+a+" (not an integer)");
a>>>=0;if(0>a||a+4>this.buffer.byteLength)throw new RangeError("Illegal offset: 0 <= "+a+" (+4) <= "+this.buffer.byteLength);}a=this.view.getFloat32(a,this.littleEndian);b&&(this.offset+=4);return a};d.prototype.readFloat=d.prototype.readFloat32;d.prototype.writeFloat64=function(a,b){var c="undefined"===typeof b;c&&(b=this.offset);if(!this.noAssert){if("number"!==typeof a)throw new TypeError("Illegal value: "+a+" (not a number)");if("number"!==typeof b||0!==b%1)throw new TypeError("Illegal offset: "+
b+" (not an integer)");b>>>=0;if(0>b||b+0>this.buffer.byteLength)throw new RangeError("Illegal offset: 0 <= "+b+" (+0) <= "+this.buffer.byteLength);}b+=8;var e=this.buffer.byteLength;b>e&&this.resize((e*=2)>b?e:b);this.view.setFloat64(b-8,a,this.littleEndian);c&&(this.offset+=8);return this};d.prototype.writeDouble=d.prototype.writeFloat64;d.prototype.readFloat64=function(a){var b="undefined"===typeof a;b&&(a=this.offset);if(!this.noAssert){if("number"!==typeof a||0!==a%1)throw new TypeError("Illegal offset: "+
a+" (not an integer)");a>>>=0;if(0>a||a+8>this.buffer.byteLength)throw new RangeError("Illegal offset: 0 <= "+a+" (+8) <= "+this.buffer.byteLength);}a=this.view.getFloat64(a,this.littleEndian);b&&(this.offset+=8);return a};d.prototype.readDouble=d.prototype.readFloat64;d.MAX_VARINT32_BYTES=5;d.calculateVarint32=function(a){a>>>=0;return 128>a?1:16384>a?2:2097152>a?3:268435456>a?4:5};d.zigZagEncode32=function(a){return((a|=0)<<1^a>>31)>>>0};d.zigZagDecode32=function(a){return a>>>1^-(a&1)|0};d.prototype.writeVarint32=
function(a,b){var c="undefined"===typeof b;c&&(b=this.offset);if(!this.noAssert){if("number"!==typeof a||0!==a%1)throw new TypeError("Illegal value: "+a+" (not an integer)");a|=0;if("number"!==typeof b||0!==b%1)throw new TypeError("Illegal offset: "+b+" (not an integer)");b>>>=0;if(0>b||b+0>this.buffer.byteLength)throw new RangeError("Illegal offset: 0 <= "+b+" (+0) <= "+this.buffer.byteLength);}var e=d.calculateVarint32(a);b+=e;var h=this.buffer.byteLength;b>h&&this.resize((h*=2)>b?h:b);b-=e;this.view.setUint8(b,
e=a|128);a>>>=0;128<=a?(e=a>>7|128,this.view.setUint8(b+1,e),16384<=a?(e=a>>14|128,this.view.setUint8(b+2,e),2097152<=a?(e=a>>21|128,this.view.setUint8(b+3,e),268435456<=a?(this.view.setUint8(b+4,a>>28&15),e=5):(this.view.setUint8(b+3,e&127),e=4)):(this.view.setUint8(b+2,e&127),e=3)):(this.view.setUint8(b+1,e&127),e=2)):(this.view.setUint8(b,e&127),e=1);return c?(this.offset+=e,this):e};d.prototype.writeVarint32ZigZag=function(a,b){return this.writeVarint32(d.zigZagEncode32(a),b)};d.prototype.readVarint32=
function(a){var b="undefined"===typeof a;b&&(a=this.offset);if(!this.noAssert){if("number"!==typeof a||0!==a%1)throw new TypeError("Illegal offset: "+a+" (not an integer)");a>>>=0;if(0>a||a+1>this.buffer.byteLength)throw new RangeError("Illegal offset: 0 <= "+a+" (+1) <= "+this.buffer.byteLength);}var c=0,e=0,d;do d=this.view.getUint8(a+c),5>c&&(e|=(d&127)<<7*c>>>0),++c;while(128===(d&128));e|=0;return b?(this.offset+=c,e):{value:e,length:c}};d.prototype.readVarint32ZigZag=function(a){a=this.readVarint32(a);
"object"===typeof a?a.value=d.zigZagDecode32(a.value):a=d.zigZagDecode32(a);return a};l&&(d.MAX_VARINT64_BYTES=10,d.calculateVarint64=function(a){"number"===typeof a&&(a=l.fromNumber(a));var b=a.toInt()>>>0,c=a.shiftRightUnsigned(28).toInt()>>>0;a=a.shiftRightUnsigned(56).toInt()>>>0;return 0==a?0==c?16384>b?128>b?1:2:2097152>b?3:4:16384>c?128>c?5:6:2097152>c?7:8:128>a?9:10},d.zigZagEncode64=function(a){"number"===typeof a?a=l.fromNumber(a,!1):!1!==a.unsigned&&(a=a.toSigned());return a.shiftLeft(1).xor(a.shiftRight(63)).toUnsigned()},
d.zigZagDecode64=function(a){"number"===typeof a?a=l.fromNumber(a,!1):!1!==a.unsigned&&(a=a.toSigned());return a.shiftRightUnsigned(1).xor(a.and(l.ONE).toSigned().negate()).toSigned()},d.prototype.writeVarint64=function(a,b){var c="undefined"===typeof b;c&&(b=this.offset);if(!this.noAssert){if("number"===typeof a)a=l.fromNumber(a);else if(!(a&&a instanceof l))throw new TypeError("Illegal value: "+a+" (not an integer or Long)");if("number"!==typeof b||0!==b%1)throw new TypeError("Illegal offset: "+
b+" (not an integer)");b>>>=0;if(0>b||b+0>this.buffer.byteLength)throw new RangeError("Illegal offset: 0 <= "+b+" (+0) <= "+this.buffer.byteLength);}"number"===typeof a?a=l.fromNumber(a,!1):!1!==a.unsigned&&(a=a.toSigned());var e=d.calculateVarint64(a),h=a.toInt()>>>0,f=a.shiftRightUnsigned(28).toInt()>>>0,g=a.shiftRightUnsigned(56).toInt()>>>0;b+=e;var n=this.buffer.byteLength;b>n&&this.resize((n*=2)>b?n:b);b-=e;switch(e){case 10:this.view.setUint8(b+9,g>>>7&1);case 9:this.view.setUint8(b+8,9!==
e?g|128:g&127);case 8:this.view.setUint8(b+7,8!==e?f>>>21|128:f>>>21&127);case 7:this.view.setUint8(b+6,7!==e?f>>>14|128:f>>>14&127);case 6:this.view.setUint8(b+5,6!==e?f>>>7|128:f>>>7&127);case 5:this.view.setUint8(b+4,5!==e?f|128:f&127);case 4:this.view.setUint8(b+3,4!==e?h>>>21|128:h>>>21&127);case 3:this.view.setUint8(b+2,3!==e?h>>>14|128:h>>>14&127);case 2:this.view.setUint8(b+1,2!==e?h>>>7|128:h>>>7&127);case 1:this.view.setUint8(b,1!==e?h|128:h&127)}return c?(this.offset+=e,this):e},d.prototype.writeVarint64ZigZag=
function(a,b){return this.writeVarint64(d.zigZagEncode64(a),b)},d.prototype.readVarint64=function(a){var b="undefined"===typeof a;b&&(a=this.offset);if(!this.noAssert){if("number"!==typeof a||0!==a%1)throw new TypeError("Illegal offset: "+a+" (not an integer)");a>>>=0;if(0>a||a+1>this.buffer.byteLength)throw new RangeError("Illegal offset: 0 <= "+a+" (+1) <= "+this.buffer.byteLength);}var c=a,e=0,d=0,f=0,g=0,g=this.view.getUint8(a++),e=g&127;if(g&128&&(g=this.view.getUint8(a++),e|=(g&127)<<7,g&128&&
(g=this.view.getUint8(a++),e|=(g&127)<<14,g&128&&(g=this.view.getUint8(a++),e|=(g&127)<<21,g&128&&(g=this.view.getUint8(a++),d=g&127,g&128&&(g=this.view.getUint8(a++),d|=(g&127)<<7,g&128&&(g=this.view.getUint8(a++),d|=(g&127)<<14,g&128&&(g=this.view.getUint8(a++),d|=(g&127)<<21,g&128&&(g=this.view.getUint8(a++),f=g&127,g&128&&(g=this.view.getUint8(a++),f|=(g&127)<<7,g&128))))))))))throw Error("Data must be corrupt: Buffer overrun");e=l.from28Bits(e,d,f,!1);return b?(this.offset=a,e):{value:e,length:a-
c}},d.prototype.readVarint64ZigZag=function(a){(a=this.readVarint64(a))&&a.value instanceof l?a.value=d.zigZagDecode64(a.value):a=d.zigZagDecode64(a);return a});d.prototype.writeCString=function(a,b){var c="undefined"===typeof b;c&&(b=this.offset);var e,d=a.length;if(!this.noAssert){if("string"!==typeof a)throw new TypeError("Illegal str: Not a string");for(e=0;e<d;++e)if(0===a.charCodeAt(e))throw new RangeError("Illegal str: Contains NULL-characters");if("number"!==typeof b||0!==b%1)throw new TypeError("Illegal offset: "+
b+" (not an integer)");b>>>=0;if(0>b||b+0>this.buffer.byteLength)throw new RangeError("Illegal offset: 0 <= "+b+" (+0) <= "+this.buffer.byteLength);}e=b;d=k.b(k.a(a))[1];b+=d+1;var f=this.buffer.byteLength;b>f&&this.resize((f*=2)>b?f:b);b-=d+1;k.e(k.a(a),function(a){this.view.setUint8(b++,a)}.bind(this));this.view.setUint8(b++,0);return c?(this.offset=b-e,this):d};d.prototype.readCString=function(a){var b="undefined"===typeof a;b&&(a=this.offset);if(!this.noAssert){if("number"!==typeof a||0!==a%1)throw new TypeError("Illegal offset: "+
a+" (not an integer)");a>>>=0;if(0>a||a+1>this.buffer.byteLength)throw new RangeError("Illegal offset: 0 <= "+a+" (+1) <= "+this.buffer.byteLength);}var c=a,e,d=-1;k.d(function(){if(0===d)return null;if(a>=this.limit)throw RangeError("Illegal range: Truncated data, "+a+" < "+this.limit);return 0===(d=this.view.getUint8(a++))?null:d}.bind(this),e=k.c(),!0);return b?(this.offset=a,e()):{string:e(),length:a-c}};d.prototype.writeIString=function(a,b){var c="undefined"===typeof b;c&&(b=this.offset);if(!this.noAssert){if("string"!==
typeof a)throw new TypeError("Illegal str: Not a string");if("number"!==typeof b||0!==b%1)throw new TypeError("Illegal offset: "+b+" (not an integer)");b>>>=0;if(0>b||b+0>this.buffer.byteLength)throw new RangeError("Illegal offset: 0 <= "+b+" (+0) <= "+this.buffer.byteLength);}var e=b,d;d=k.b(k.a(a),this.noAssert)[1];b+=4+d;var f=this.buffer.byteLength;b>f&&this.resize((f*=2)>b?f:b);b-=4+d;this.view.setUint32(b,d,this.littleEndian);b+=4;k.e(k.a(a),function(a){this.view.setUint8(b++,a)}.bind(this));
if(b!==e+4+d)throw new RangeError("Illegal range: Truncated data, "+b+" == "+(b+4+d));return c?(this.offset=b,this):b-e};d.prototype.readIString=function(a){var b="undefined"===typeof a;b&&(a=this.offset);if(!this.noAssert){if("number"!==typeof a||0!==a%1)throw new TypeError("Illegal offset: "+a+" (not an integer)");a>>>=0;if(0>a||a+4>this.buffer.byteLength)throw new RangeError("Illegal offset: 0 <= "+a+" (+4) <= "+this.buffer.byteLength);}var c=0,e=a,c=this.view.getUint32(a,this.littleEndian);a+=
4;var d=a+c;k.d(function(){return a<d?this.view.getUint8(a++):null}.bind(this),c=k.c(),this.noAssert);c=c();return b?(this.offset=a,c):{string:c,length:a-e}};d.METRICS_CHARS="c";d.METRICS_BYTES="b";d.prototype.writeUTF8String=function(a,b){var c="undefined"===typeof b;c&&(b=this.offset);if(!this.noAssert){if("number"!==typeof b||0!==b%1)throw new TypeError("Illegal offset: "+b+" (not an integer)");b>>>=0;if(0>b||b+0>this.buffer.byteLength)throw new RangeError("Illegal offset: 0 <= "+b+" (+0) <= "+
this.buffer.byteLength);}var e,d=b;e=k.b(k.a(a))[1];b+=e;var f=this.buffer.byteLength;b>f&&this.resize((f*=2)>b?f:b);b-=e;k.e(k.a(a),function(a){this.view.setUint8(b++,a)}.bind(this));return c?(this.offset=b,this):b-d};d.prototype.writeString=d.prototype.writeUTF8String;d.calculateUTF8Chars=function(a){return k.b(k.a(a))[0]};d.calculateUTF8Bytes=function(a){return k.b(k.a(a))[1]};d.prototype.readUTF8String=function(a,b,c){"number"===typeof b&&(c=b,b=void 0);var e="undefined"===typeof c;e&&(c=this.offset);
"undefined"===typeof b&&(b=d.METRICS_CHARS);if(!this.noAssert){if("number"!==typeof a||0!==a%1)throw new TypeError("Illegal length: "+a+" (not an integer)");a|=0;if("number"!==typeof c||0!==c%1)throw new TypeError("Illegal offset: "+c+" (not an integer)");c>>>=0;if(0>c||c+0>this.buffer.byteLength)throw new RangeError("Illegal offset: 0 <= "+c+" (+0) <= "+this.buffer.byteLength);}var h=0,f=c,g;if(b===d.METRICS_CHARS){g=k.c();k.i(function(){return h<a&&c<this.limit?this.view.getUint8(c++):null}.bind(this),
function(a){++h;k.g(a,g)}.bind(this));if(h!==a)throw new RangeError("Illegal range: Truncated data, "+h+" == "+a);return e?(this.offset=c,g()):{string:g(),length:c-f}}if(b===d.METRICS_BYTES){if(!this.noAssert){if("number"!==typeof c||0!==c%1)throw new TypeError("Illegal offset: "+c+" (not an integer)");c>>>=0;if(0>c||c+a>this.buffer.byteLength)throw new RangeError("Illegal offset: 0 <= "+c+" (+"+a+") <= "+this.buffer.byteLength);}var n=c+a;k.d(function(){return c<n?this.view.getUint8(c++):null}.bind(this),
g=k.c(),this.noAssert);if(c!==n)throw new RangeError("Illegal range: Truncated data, "+c+" == "+n);return e?(this.offset=c,g()):{string:g(),length:c-f}}throw new TypeError("Unsupported metrics: "+b);};d.prototype.readString=d.prototype.readUTF8String;d.prototype.writeVString=function(a,b){var c="undefined"===typeof b;c&&(b=this.offset);if(!this.noAssert){if("string"!==typeof a)throw new TypeError("Illegal str: Not a string");if("number"!==typeof b||0!==b%1)throw new TypeError("Illegal offset: "+b+
" (not an integer)");b>>>=0;if(0>b||b+0>this.buffer.byteLength)throw new RangeError("Illegal offset: 0 <= "+b+" (+0) <= "+this.buffer.byteLength);}var e=b,h,f;h=k.b(k.a(a),this.noAssert)[1];f=d.calculateVarint32(h);b+=f+h;var g=this.buffer.byteLength;b>g&&this.resize((g*=2)>b?g:b);b-=f+h;b+=this.writeVarint32(h,b);k.e(k.a(a),function(a){this.view.setUint8(b++,a)}.bind(this));if(b!==e+h+f)throw new RangeError("Illegal range: Truncated data, "+b+" == "+(b+h+f));return c?(this.offset=b,this):b-e};d.prototype.readVString=
function(a){var b="undefined"===typeof a;b&&(a=this.offset);if(!this.noAssert){if("number"!==typeof a||0!==a%1)throw new TypeError("Illegal offset: "+a+" (not an integer)");a>>>=0;if(0>a||a+1>this.buffer.byteLength)throw new RangeError("Illegal offset: 0 <= "+a+" (+1) <= "+this.buffer.byteLength);}var c=this.readVarint32(a),e=a;a+=c.length;var c=c.value,d=a+c,c=k.c();k.d(function(){return a<d?this.view.getUint8(a++):null}.bind(this),c,this.noAssert);c=c();return b?(this.offset=a,c):{string:c,length:a-
e}};d.prototype.append=function(a,b,c){if("number"===typeof b||"string"!==typeof b)c=b,b=void 0;var e="undefined"===typeof c;e&&(c=this.offset);if(!this.noAssert){if("number"!==typeof c||0!==c%1)throw new TypeError("Illegal offset: "+c+" (not an integer)");c>>>=0;if(0>c||c+0>this.buffer.byteLength)throw new RangeError("Illegal offset: 0 <= "+c+" (+0) <= "+this.buffer.byteLength);}a instanceof d||(a=d.wrap(a,b));b=a.limit-a.offset;if(0>=b)return this;c+=b;var h=this.buffer.byteLength;c>h&&this.resize((h*=
2)>c?h:c);(new Uint8Array(this.buffer,c-b)).set((new Uint8Array(a.buffer)).subarray(a.offset,a.limit));a.offset+=b;e&&(this.offset+=b);return this};d.prototype.appendTo=function(a,b){a.append(this,b);return this};d.prototype.assert=function(a){this.noAssert=!a;return this};d.prototype.capacity=function(){return this.buffer.byteLength};d.prototype.clear=function(){this.offset=0;this.limit=this.buffer.byteLength;this.markedOffset=-1;return this};d.prototype.clone=function(a){var b=new d(0,this.littleEndian,
this.noAssert);a?(a=new ArrayBuffer(this.buffer.byteLength),(new Uint8Array(a)).set(this.buffer),b.buffer=a,b.view=new DataView(a)):(b.buffer=this.buffer,b.view=this.view);b.offset=this.offset;b.markedOffset=this.markedOffset;b.limit=this.limit;return b};d.prototype.compact=function(a,b){"undefined"===typeof a&&(a=this.offset);"undefined"===typeof b&&(b=this.limit);if(!this.noAssert){if("number"!==typeof a||0!==a%1)throw new TypeError("Illegal begin: Not an integer");a>>>=0;if("number"!==typeof b||
0!==b%1)throw new TypeError("Illegal end: Not an integer");b>>>=0;if(0>a||a>b||b>this.buffer.byteLength)throw new RangeError("Illegal range: 0 <= "+a+" <= "+b+" <= "+this.buffer.byteLength);}if(0===a&&b===this.buffer.byteLength)return this;var c=b-a;if(0===c)return this.buffer=r,this.view=null,0<=this.markedOffset&&(this.markedOffset-=a),this.limit=this.offset=0,this;var e=new ArrayBuffer(c);(new Uint8Array(e)).set((new Uint8Array(this.buffer)).subarray(a,b));this.buffer=e;this.view=new DataView(e);
0<=this.markedOffset&&(this.markedOffset-=a);this.offset=0;this.limit=c;return this};d.prototype.copy=function(a,b){"undefined"===typeof a&&(a=this.offset);"undefined"===typeof b&&(b=this.limit);if(!this.noAssert){if("number"!==typeof a||0!==a%1)throw new TypeError("Illegal begin: Not an integer");a>>>=0;if("number"!==typeof b||0!==b%1)throw new TypeError("Illegal end: Not an integer");b>>>=0;if(0>a||a>b||b>this.buffer.byteLength)throw new RangeError("Illegal range: 0 <= "+a+" <= "+b+" <= "+this.buffer.byteLength);
}if(a===b)return new d(0,this.littleEndian,this.noAssert);var c=b-a,e=new d(c,this.littleEndian,this.noAssert);e.offset=0;e.limit=c;0<=e.markedOffset&&(e.markedOffset-=a);this.copyTo(e,0,a,b);return e};d.prototype.copyTo=function(a,b,c,e){var h,f;if(!this.noAssert&&!d.isByteBuffer(a))throw new TypeError("Illegal target: Not a ByteBuffer");b=(f="undefined"===typeof b)?a.offset:b|0;c=(h="undefined"===typeof c)?this.offset:c|0;e="undefined"===typeof e?this.limit:e|0;if(0>b||b>a.buffer.byteLength)throw new RangeError("Illegal target range: 0 <= "+
b+" <= "+a.buffer.byteLength);if(0>c||e>this.buffer.byteLength)throw new RangeError("Illegal source range: 0 <= "+c+" <= "+this.buffer.byteLength);var g=e-c;if(0===g)return a;a.ensureCapacity(b+g);(new Uint8Array(a.buffer)).set((new Uint8Array(this.buffer)).subarray(c,e),b);h&&(this.offset+=g);f&&(a.offset+=g);return this};d.prototype.ensureCapacity=function(a){var b=this.buffer.byteLength;return b<a?this.resize((b*=2)>a?b:a):this};d.prototype.fill=function(a,b,c){var e="undefined"===typeof b;e&&
(b=this.offset);"string"===typeof a&&0<a.length&&(a=a.charCodeAt(0));"undefined"===typeof b&&(b=this.offset);"undefined"===typeof c&&(c=this.limit);if(!this.noAssert){if("number"!==typeof a||0!==a%1)throw new TypeError("Illegal value: "+a+" (not an integer)");a|=0;if("number"!==typeof b||0!==b%1)throw new TypeError("Illegal begin: Not an integer");b>>>=0;if("number"!==typeof c||0!==c%1)throw new TypeError("Illegal end: Not an integer");c>>>=0;if(0>b||b>c||c>this.buffer.byteLength)throw new RangeError("Illegal range: 0 <= "+
b+" <= "+c+" <= "+this.buffer.byteLength);}if(b>=c)return this;for(;b<c;)this.view.setUint8(b++,a);e&&(this.offset=b);return this};d.prototype.flip=function(){this.limit=this.offset;this.offset=0;return this};d.prototype.mark=function(a){a="undefined"===typeof a?this.offset:a;if(!this.noAssert){if("number"!==typeof a||0!==a%1)throw new TypeError("Illegal offset: "+a+" (not an integer)");a>>>=0;if(0>a||a+0>this.buffer.byteLength)throw new RangeError("Illegal offset: 0 <= "+a+" (+0) <= "+this.buffer.byteLength);
}this.markedOffset=a;return this};d.prototype.order=function(a){if(!this.noAssert&&"boolean"!==typeof a)throw new TypeError("Illegal littleEndian: Not a boolean");this.littleEndian=!!a;return this};d.prototype.LE=function(a){this.littleEndian="undefined"!==typeof a?!!a:!0;return this};d.prototype.BE=function(a){this.littleEndian="undefined"!==typeof a?!a:!1;return this};d.prototype.prepend=function(a,b,c){if("number"===typeof b||"string"!==typeof b)c=b,b=void 0;var e="undefined"===typeof c;e&&(c=
this.offset);if(!this.noAssert){if("number"!==typeof c||0!==c%1)throw new TypeError("Illegal offset: "+c+" (not an integer)");c>>>=0;if(0>c||c+0>this.buffer.byteLength)throw new RangeError("Illegal offset: 0 <= "+c+" (+0) <= "+this.buffer.byteLength);}a instanceof d||(a=d.wrap(a,b));b=a.limit-a.offset;if(0>=b)return this;var h=b-c,f;if(0<h){var g=new ArrayBuffer(this.buffer.byteLength+h);f=new Uint8Array(g);f.set((new Uint8Array(this.buffer)).subarray(c,this.buffer.byteLength),b);this.buffer=g;this.view=
new DataView(g);this.offset+=h;0<=this.markedOffset&&(this.markedOffset+=h);this.limit+=h;c+=h}else f=new Uint8Array(this.buffer);f.set((new Uint8Array(a.buffer)).subarray(a.offset,a.limit),c-b);a.offset=a.limit;e&&(this.offset-=b);return this};d.prototype.prependTo=function(a,b){a.prepend(this,b);return this};d.prototype.printDebug=function(a){"function"!==typeof a&&(a=console.log.bind(console));a(this.toString()+"\n-------------------------------------------------------------------\n"+this.toDebug(!0))};
d.prototype.remaining=function(){return this.limit-this.offset};d.prototype.reset=function(){0<=this.markedOffset?(this.offset=this.markedOffset,this.markedOffset=-1):this.offset=0;return this};d.prototype.resize=function(a){if(!this.noAssert){if("number"!==typeof a||0!==a%1)throw new TypeError("Illegal capacity: "+a+" (not an integer)");a|=0;if(0>a)throw new RangeError("Illegal capacity: 0 <= "+a);}this.buffer.byteLength<a&&(a=new ArrayBuffer(a),(new Uint8Array(a)).set(new Uint8Array(this.buffer)),
this.buffer=a,this.view=new DataView(a));return this};d.prototype.reverse=function(a,b){"undefined"===typeof a&&(a=this.offset);"undefined"===typeof b&&(b=this.limit);if(!this.noAssert){if("number"!==typeof a||0!==a%1)throw new TypeError("Illegal begin: Not an integer");a>>>=0;if("number"!==typeof b||0!==b%1)throw new TypeError("Illegal end: Not an integer");b>>>=0;if(0>a||a>b||b>this.buffer.byteLength)throw new RangeError("Illegal range: 0 <= "+a+" <= "+b+" <= "+this.buffer.byteLength);}if(a===b)return this;
Array.prototype.reverse.call((new Uint8Array(this.buffer)).subarray(a,b));this.view=new DataView(this.buffer);return this};d.prototype.skip=function(a){if(!this.noAssert){if("number"!==typeof a||0!==a%1)throw new TypeError("Illegal length: "+a+" (not an integer)");a|=0}var b=this.offset+a;if(!this.noAssert&&(0>b||b>this.buffer.byteLength))throw new RangeError("Illegal length: 0 <= "+this.offset+" + "+a+" <= "+this.buffer.byteLength);this.offset=b;return this};d.prototype.slice=function(a,b){"undefined"===
typeof a&&(a=this.offset);"undefined"===typeof b&&(b=this.limit);if(!this.noAssert){if("number"!==typeof a||0!==a%1)throw new TypeError("Illegal begin: Not an integer");a>>>=0;if("number"!==typeof b||0!==b%1)throw new TypeError("Illegal end: Not an integer");b>>>=0;if(0>a||a>b||b>this.buffer.byteLength)throw new RangeError("Illegal range: 0 <= "+a+" <= "+b+" <= "+this.buffer.byteLength);}var c=this.clone();c.offset=a;c.limit=b;return c};d.prototype.toBuffer=function(a){var b=this.offset,c=this.limit;
if(b>c)var e=b,b=c,c=e;if(!this.noAssert){if("number"!==typeof b||0!==b%1)throw new TypeError("Illegal offset: Not an integer");b>>>=0;if("number"!==typeof c||0!==c%1)throw new TypeError("Illegal limit: Not an integer");c>>>=0;if(0>b||b>c||c>this.buffer.byteLength)throw new RangeError("Illegal range: 0 <= "+b+" <= "+c+" <= "+this.buffer.byteLength);}if(!a&&0===b&&c===this.buffer.byteLength)return this.buffer;if(b===c)return r;a=new ArrayBuffer(c-b);(new Uint8Array(a)).set((new Uint8Array(this.buffer)).subarray(b,
c),0);return a};d.prototype.toArrayBuffer=d.prototype.toBuffer;d.prototype.toString=function(a){if("undefined"===typeof a)return"ByteBufferAB(offset="+this.offset+",markedOffset="+this.markedOffset+",limit="+this.limit+",capacity="+this.capacity()+")";switch(a){case "utf8":return this.toUTF8();case "base64":return this.toBase64();case "hex":return this.toHex();case "binary":return this.toBinary();case "debug":return this.toDebug();case "columns":return this.o();default:throw Error("Unsupported encoding: "+
a);}};var m="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",m=m+"";d.prototype.toBase64=function(a,b){"undefined"===typeof a&&(a=this.offset);"undefined"===typeof b&&(b=this.limit);if(!this.noAssert){if("number"!==typeof a||0!==a%1)throw new TypeError("Illegal begin: Not an integer");a>>>=0;if("number"!==typeof b||0!==b%1)throw new TypeError("Illegal end: Not an integer");b>>>=0;if(0>a||a>b||b>this.buffer.byteLength)throw new RangeError("Illegal range: 0 <= "+a+" <= "+b+" <= "+
this.buffer.byteLength);}if(a===b)return"";for(var c,e,d,f,g,k,l="";a<b;)c=this.view.getUint8(a++),e=(f=a<b)?this.view.getUint8(a++):0,d=(g=a<b)?this.view.getUint8(a++):0,k=c>>2,c=(c&3)<<4|e>>4,e=(e&15)<<2|d>>6,d&=63,g||(d=64,f||(e=64)),l+=m.charAt(k)+m.charAt(c)+m.charAt(e)+m.charAt(d);return l};d.fromBase64=function(a,b,c){if(!c){if("string"!==typeof a)throw new TypeError("Illegal str: Not a string");if(0!==a.length%4)throw new TypeError("Illegal str: Length not a multiple of 4");}var e=a.length,
h=0,f;for(f=a.length-1;0<=f;--f)if("="===a.charAt(f))h++;else break;if(2<h)throw new TypeError("Illegal str: Suffix is too large");if(0===e)return new d(0,b,c);var g,k,l,p=new d(e/4*3-h,b,c);for(b=f=0;f<e;){h=m.indexOf(a.charAt(f++));g=f<e?m.indexOf(a.charAt(f++)):0;k=f<e?m.indexOf(a.charAt(f++)):0;l=f<e?m.indexOf(a.charAt(f++)):0;if(!c&&(0>h||0>g||0>k||0>l))throw new TypeError("Illegal str: Contains non-base64 characters");p.view.setUint8(b++,h<<2|g>>4);64!==k&&(p.view.setUint8(b++,g<<4&240|k>>2,
b),64!==l&&p.view.setUint8(b++,k<<6&192|l))}p.limit=b;return p};d.btoa=function(a){return d.fromBinary(a).toBase64()};d.atob=function(a){return d.fromBase64(a).toBinary()};d.prototype.toBinary=function(a,b){a="undefined"===typeof a?this.offset:a;b="undefined"===typeof b?this.limit:b;if(!this.noAssert){if("number"!==typeof a||0!==a%1)throw new TypeError("Illegal begin: Not an integer");a>>>=0;if("number"!==typeof b||0!==b%1)throw new TypeError("Illegal end: Not an integer");b>>>=0;if(0>a||a>b||b>this.buffer.byteLength)throw new RangeError("Illegal range: 0 <= "+
a+" <= "+b+" <= "+this.buffer.byteLength);}if(a===b)return"";for(var c=[];a<b;)c.push(this.view.getUint8(a++));return String.fromCharCode.apply(String,c)};d.fromBinary=function(a,b,c){if(!c&&"string"!==typeof a)throw new TypeError("Illegal str: Not a string");for(var e=0,h=a.length,f=new d(h,b,c);e<h;){b=a.charCodeAt(e);if(!c&&255<b)throw new TypeError("Illegal charCode at "+e+": 0 <= "+b+" <= 255");f.view.setUint8(e++,b)}f.limit=h;return f};d.prototype.toDebug=function(a){for(var b=-1,c=this.buffer.byteLength,
e,d="",f="",g="";b<c;){-1!==b&&(e=this.view.getUint8(b),d=16>e?d+("0"+e.toString(16).toUpperCase()):d+e.toString(16).toUpperCase(),a&&(f+=32<e&&127>e?String.fromCharCode(e):"."));++b;if(a&&0<b&&0===b%16&&b!==c){for(;51>d.length;)d+=" ";g+=d+f+"\n";d=f=""}d=b===this.offset&&b===this.limit?d+(b===this.markedOffset?"!":"|"):b===this.offset?d+(b===this.markedOffset?"[":"<"):b===this.limit?d+(b===this.markedOffset?"]":">"):d+(b===this.markedOffset?"'":a||0!==b&&b!==c?" ":"")}if(a&&" "!==d){for(;51>d.length;)d+=
" ";g+=d+f+"\n"}return a?g:d};d.fromDebug=function(a,b,c){var e=a.length;b=new d((e+1)/3|0,b,c);for(var h=0,f=0,g,k=!1,l=!1,p=!1,m=!1,q=!1;h<e;){switch(g=a.charAt(h++)){case "!":if(!c){if(l||p||m){q=!0;break}l=p=m=!0}b.offset=b.markedOffset=b.limit=f;k=!1;break;case "|":if(!c){if(l||m){q=!0;break}l=m=!0}b.offset=b.limit=f;k=!1;break;case "[":if(!c){if(l||p){q=!0;break}l=p=!0}b.offset=b.markedOffset=f;k=!1;break;case "<":if(!c){if(l){q=!0;break}l=!0}b.offset=f;k=!1;break;case "]":if(!c){if(m||p){q=
!0;break}m=p=!0}b.limit=b.markedOffset=f;k=!1;break;case ">":if(!c){if(m){q=!0;break}m=!0}b.limit=f;k=!1;break;case "'":if(!c){if(p){q=!0;break}p=!0}b.markedOffset=f;k=!1;break;case " ":k=!1;break;default:if(!c&&k){q=!0;break}g=parseInt(g+a.charAt(h++),16);if(!c&&(isNaN(g)||0>g||255<g))throw new TypeError("Illegal str: Not a debug encoded string");b.view.setUint8(f++,g);k=!0}if(q)throw new TypeError("Illegal str: Invalid symbol at "+h);}if(!c){if(!l||!m)throw new TypeError("Illegal str: Missing offset or limit");
if(f<b.buffer.byteLength)throw new TypeError("Illegal str: Not a debug encoded string (is it hex?) "+f+" < "+e);}return b};d.prototype.toHex=function(a,b){a="undefined"===typeof a?this.offset:a;b="undefined"===typeof b?this.limit:b;if(!this.noAssert){if("number"!==typeof a||0!==a%1)throw new TypeError("Illegal begin: Not an integer");a>>>=0;if("number"!==typeof b||0!==b%1)throw new TypeError("Illegal end: Not an integer");b>>>=0;if(0>a||a>b||b>this.buffer.byteLength)throw new RangeError("Illegal range: 0 <= "+
a+" <= "+b+" <= "+this.buffer.byteLength);}for(var c=Array(b-a),e;a<b;)e=this.view.getUint8(a++),16>e?c.push("0",e.toString(16)):c.push(e.toString(16));return c.join("")};d.fromHex=function(a,b,c){if(!c){if("string"!==typeof a)throw new TypeError("Illegal str: Not a string");if(0!==a.length%2)throw new TypeError("Illegal str: Length not a multiple of 2");}var e=a.length;b=new d(e/2|0,b);for(var h,f=0,g=0;f<e;f+=2){h=parseInt(a.substring(f,f+2),16);if(!c&&(!isFinite(h)||0>h||255<h))throw new TypeError("Illegal str: Contains non-hex characters");
b.view.setUint8(g++,h)}b.limit=g;return b};var k=function(){var a={j:function(a,c){var e=null;"number"===typeof a&&(e=a,a=function(){return null});for(;null!==e||null!==(e=a());)128>e?c(e&127):(2048>e?c(e>>6&31|192):(65536>e?c(e>>12&15|224):(c(e>>18&7|240),c(e>>12&63|128)),c(e>>6&63|128)),c(e&63|128)),e=null},i:function(a,c){function e(a){a=a.slice(0,a.indexOf(null));var b=Error(a.toString());b.name="TruncatedError";b.bytes=a;throw b;}for(var d,f,g,k;null!==(d=a());)if(0===(d&128))c(d);else if(192===
(d&224))null===(f=a())&&e([d,f]),c((d&31)<<6|f&63);else if(224===(d&240))null!==(f=a())&&null!==(g=a())||e([d,f,g]),c((d&15)<<12|(f&63)<<6|g&63);else if(240===(d&248))null!==(f=a())&&null!==(g=a())&&null!==(k=a())||e([d,f,g,k]),c((d&7)<<18|(f&63)<<12|(g&63)<<6|k&63);else throw RangeError("Illegal starting byte: "+d);},f:function(a,c){for(var e,d=null;null!==(e=null!==d?d:a());)55296<=e&&57343>=e&&null!==(d=a())&&56320<=d&&57343>=d?(c(1024*(e-55296)+d-56320+65536),d=null):c(e);null!==d&&c(d)},g:function(a,
c){var e=null;"number"===typeof a&&(e=a,a=function(){return null});for(;null!==e||null!==(e=a());)65535>=e?c(e):(e-=65536,c((e>>10)+55296),c(e%1024+56320)),e=null},e:function(b,c){a.f(b,function(b){a.j(b,c)})},d:function(b,c){a.i(b,function(b){a.g(b,c)})},k:function(a){if("number"!==typeof a||a!==a)throw TypeError("Illegal byte: "+typeof a);if(-128>a||255<a)throw RangeError("Illegal byte: "+a);return a},l:function(a){if("number"!==typeof a||a!==a)throw TypeError("Illegal char code: "+typeof a);if(0>
a||65535<a)throw RangeError("Illegal char code: "+a);return a},m:function(a){if("number"!==typeof a||a!==a)throw TypeError("Illegal code point: "+typeof a);if(0>a||1114111<a)throw RangeError("Illegal code point: "+a);return a},h:function(a){return 128>a?1:2048>a?2:65536>a?3:4},n:function(b){for(var c,d=0;null!==(c=b());)d+=a.h(c);return d},b:function(b){var c=0,d=0;a.f(b,function(b){++c;d+=a.h(b)});return[c,d]}};return a}(),s=String.fromCharCode;k.a=function(a){var b=0;return function(){return b<
a.length?a.charCodeAt(b++):null}};k.c=function(){var a=[],b=[];return function(){if(0===arguments.length)return b.join("")+s.apply(String,a);1024<a.length+arguments.length&&(b.push(s.apply(String,a)),a.length=0);Array.prototype.push.apply(a,arguments)}};d.prototype.toUTF8=function(a,b){"undefined"===typeof a&&(a=this.offset);"undefined"===typeof b&&(b=this.limit);if(!this.noAssert){if("number"!==typeof a||0!==a%1)throw new TypeError("Illegal begin: Not an integer");a>>>=0;if("number"!==typeof b||
0!==b%1)throw new TypeError("Illegal end: Not an integer");b>>>=0;if(0>a||a>b||b>this.buffer.byteLength)throw new RangeError("Illegal range: 0 <= "+a+" <= "+b+" <= "+this.buffer.byteLength);}var c=this,d;try{k.d(function(){return a<b?c.view.getUint8(a++):null},d=k.c())}catch(h){if(a!==b)throw new RangeError("Illegal range: Truncated data, "+a+" != "+b);}return d()};d.fromUTF8=function(a,b,c){if(!c&&"string"!==typeof a)throw new TypeError("Illegal str: Not a string");var e=new d(k.b(k.a(a),!0)[1],
b,c),h=0;k.e(k.a(a),function(a){e.view.setUint8(h++,a)});e.limit=h;return e};return d}"undefined"!=typeof module&&module.exports?module.exports=s(require("long")):"undefined"!==typeof define&&define.amd?define("ByteBuffer",["Math/Long"],function(l){return s(l)}):(r.dcodeIO||(r.dcodeIO={}),r.dcodeIO.ByteBuffer=s(r.dcodeIO.Long))})(this);

},{"long":56}],55:[function(require,module,exports){
/*
 Copyright 2013 Daniel Wirtz <dcode@dcode.io>
 Copyright 2009 The Closure Library Authors. All Rights Reserved.

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS-IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 */
/**
 * @license Long.js (c) 2013 Daniel Wirtz <dcode@dcode.io>
 * Released under the Apache License, Version 2.0
 * Derived from goog.math.Long from the Closure Library
 * see: https://github.com/dcodeIO/Long.js for details
 */
(function(global) {
    "use strict";

    /**
     * Constructs a 64-bit two's-complement integer, given its low and high 32-bit
     * values as *signed* integers.  See the from* functions below for more
     * convenient ways of constructing Longs.
     *
     * The internal representation of a long is the two given signed, 32-bit values.
     * We use 32-bit pieces because these are the size of integers on which
     * Javascript performs bit-operations.  For operations like addition and
     * multiplication, we split each number into 16-bit pieces, which can easily be
     * multiplied within Javascript's floating-point representation without overflow
     * or change in sign.
     *
     * In the algorithms below, we frequently reduce the negative case to the
     * positive case by negating the input(s) and then post-processing the result.
     * Note that we must ALWAYS check specially whether those values are MIN_VALUE
     * (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as
     * a positive number, it overflows back into a negative).  Not handling this
     * case would often result in infinite recursion.
     * 
     * @exports Long
     * @class A Long class for representing a 64-bit two's-complement integer value.
     * @param {number|!{low: number, high: number, unsigned: boolean}} low The low (signed) 32 bits of the long.
     *  Optionally accepts a Long-like object as the first parameter.
     * @param {number=} high The high (signed) 32 bits of the long.
     * @param {boolean=} unsigned Whether unsigned or not. Defaults to `false` (signed).
     * @constructor
     */
    var Long = function(low, high, unsigned) {
        if (low && typeof low === 'object') {
            high = low.high;
            unsigned = low.unsigned;
            low = low.low;
        }
        
        /**
         * The low 32 bits as a signed value.
         * @type {number}
         * @expose
         */
        this.low = low | 0;

        /**
         * The high 32 bits as a signed value.
         * @type {number}
         * @expose
         */
        this.high = high | 0;

        /**
         * Whether unsigned or not.
         * @type {boolean}
         * @expose
         */
        this.unsigned = !!unsigned;
    };

    // NOTE: Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from* methods on which they depend.

    // NOTE: The following cache variables are used internally only and are therefore not exposed as properties of the
    // Long class.
    
    /**
     * A cache of the Long representations of small integer values.
     * @type {!Object}
     */
    var INT_CACHE = {};

    /**
     * A cache of the Long representations of small unsigned integer values.
     * @type {!Object}
     */
    var UINT_CACHE = {};

    /**
     * Returns a Long representing the given (32-bit) integer value.
     * @param {number} value The 32-bit integer in question.
     * @param {boolean=} unsigned Whether unsigned or not. Defaults to false (signed).
     * @return {!Long} The corresponding Long value.
     * @expose
     */
    Long.fromInt = function(value, unsigned) {
        var obj, cachedObj;
        if (!unsigned) {
            value = value | 0;
            if (-128 <= value && value < 128) {
                cachedObj = INT_CACHE[value];
                if (cachedObj) return cachedObj;
            }
            obj = new Long(value, value < 0 ? -1 : 0, false);
            if (-128 <= value && value < 128) {
                INT_CACHE[value] = obj;
            }
            return obj;
        } else {
            value = value >>> 0;
            if (0 <= value && value < 256) {
                cachedObj = UINT_CACHE[value];
                if (cachedObj) return cachedObj;
            }
            obj = new Long(value, (value | 0) < 0 ? -1 : 0, true);
            if (0 <= value && value < 256) {
                UINT_CACHE[value] = obj;
            }
            return obj;
        }
    };

    /**
     * Returns a Long representing the given value, provided that it is a finite
     * number.  Otherwise, zero is returned.
     * @param {number} value The number in question.
     * @param {boolean=} unsigned Whether unsigned or not. Defaults to false (signed).
     * @return {!Long} The corresponding Long value.
     * @expose
     */
    Long.fromNumber = function(value, unsigned) {
        unsigned = !!unsigned;
        if (isNaN(value) || !isFinite(value)) {
            return Long.ZERO;
        } else if (!unsigned && value <= -TWO_PWR_63_DBL) {
            return Long.MIN_SIGNED_VALUE;
        } else if (unsigned && value <= 0) {
            return Long.MIN_UNSIGNED_VALUE;
        } else if (!unsigned && value + 1 >= TWO_PWR_63_DBL) {
            return Long.MAX_SIGNED_VALUE;
        } else if (unsigned && value >= TWO_PWR_64_DBL) {
            return Long.MAX_UNSIGNED_VALUE;
        } else if (value < 0) {
            return Long.fromNumber(-value, false).negate();
        } else {
            return new Long((value % TWO_PWR_32_DBL) | 0, (value / TWO_PWR_32_DBL) | 0, unsigned);
        }
    };

    /**
     * Returns a Long representing the 64bit integer that comes by concatenating the given low and high bits. Each is
     *  assumed to use 32 bits.
     * @param {number} lowBits The low 32 bits.
     * @param {number} highBits The high 32 bits.
     * @param {boolean=} unsigned Whether unsigned or not. Defaults to false (signed).
     * @return {!Long} The corresponding Long value.
     * @expose
     */
    Long.fromBits = function(lowBits, highBits, unsigned) {
        return new Long(lowBits, highBits, unsigned);
    };

    /**
     * Returns a Long representing the 64bit integer that comes by concatenating the given low, middle and high bits.
     *  Each is assumed to use 28 bits.
     * @param {number} part0 The low 28 bits
     * @param {number} part1 The middle 28 bits
     * @param {number} part2 The high 28 (8) bits
     * @param {boolean=} unsigned Whether unsigned or not. Defaults to false (signed).
     * @return {!Long}
     * @expose
     */
    Long.from28Bits = function(part0, part1, part2, unsigned) {
        // 00000000000000000000000000001111 11111111111111111111111122222222 2222222222222
        // LLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH
        return Long.fromBits(part0 | (part1 << 28), (part1 >>> 4) | (part2) << 24, unsigned);
    };

    /**
     * Returns a Long representation of the given string, written using the given
     * radix.
     * @param {string} str The textual representation of the Long.
     * @param {(boolean|number)=} unsigned Whether unsigned or not. Defaults to false (signed).
     * @param {number=} radix The radix in which the text is written.
     * @return {!Long} The corresponding Long value.
     * @expose
     */
    Long.fromString = function(str, unsigned, radix) {
        if (str.length == 0) {
            throw(new Error('number format error: empty string'));
        }
        if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity") {
            return Long.ZERO;
        }
        if (typeof unsigned === 'number') { // For goog.math.Long compatibility
            radix = unsigned;
            unsigned = false;
        }
        radix = radix || 10;
        if (radix < 2 || 36 < radix) {
            throw(new Error('radix out of range: ' + radix));
        }

        if (str.charAt(0) == '-') {
            return Long.fromString(str.substring(1), unsigned, radix).negate();
        } else if (str.indexOf('-') >= 0) {
            throw(new Error('number format error: interior "-" character: ' + str));
        }

        // Do several (8) digits each time through the loop, so as to
        // minimize the calls to the very expensive emulated div.
        var radixToPower = Long.fromNumber(Math.pow(radix, 8));

        var result = Long.ZERO;
        for (var i = 0; i < str.length; i += 8) {
            var size = Math.min(8, str.length - i);
            var value = parseInt(str.substring(i, i + size), radix);
            if (size < 8) {
                var power = Long.fromNumber(Math.pow(radix, size));
                result = result.multiply(power).add(Long.fromNumber(value));
            } else {
                result = result.multiply(radixToPower);
                result = result.add(Long.fromNumber(value));
            }
        }
        result.unsigned = unsigned;
        return result;
    };

    // NOTE: the compiler should inline these constant values below and then remove these variables, so there should be
    // no runtime penalty for these.
    
    // NOTE: The following constant values are used internally only and are therefore not exposed as properties of the
    // Long class.

    /**
     * @type {number}
     */
    var TWO_PWR_16_DBL = 1 << 16;

    /**
     * @type {number}
     */
    var TWO_PWR_24_DBL = 1 << 24;

    /**
     * @type {number}
     */
    var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;

    /**
     * @type {number}
     */
    var TWO_PWR_31_DBL = TWO_PWR_32_DBL / 2;

    /**
     * @type {number}
     */
    var TWO_PWR_48_DBL = TWO_PWR_32_DBL * TWO_PWR_16_DBL;

    /**
     * @type {number}
     */
    var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;

    /**
     * @type {number}
     */
    var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;

    /**
     * @type {!Long}
     */
    var TWO_PWR_24 = Long.fromInt(1 << 24);

    /**
     * @type {!Long}
     * @expose
     */
    Long.ZERO = Long.fromInt(0);

    /**
     * @type {!Long}
     * @expose
     */
    Long.UZERO = Long.fromInt(0, true);

    /**
     * @type {!Long}
     * @expose
     */
    Long.ONE = Long.fromInt(1);

    /**
     * @type {!Long}
     * @expose
     */
    Long.UONE = Long.fromInt(1, true);

    /**
     * @type {!Long}
     * @expose
     */
    Long.NEG_ONE = Long.fromInt(-1);

    /**
     * @type {!Long}
     * @expose
     */
    Long.MAX_SIGNED_VALUE = Long.fromBits(0xFFFFFFFF | 0, 0x7FFFFFFF | 0, false);

    /**
     * @type {!Long}
     * @expose
     */
    Long.MAX_UNSIGNED_VALUE = Long.fromBits(0xFFFFFFFF | 0, 0xFFFFFFFF | 0, true);

    /**
     * Alias of {@link Long.MAX_SIGNED_VALUE} for goog.math.Long compatibility.
     * @type {!Long}
     * @expose
     */
    Long.MAX_VALUE = Long.MAX_SIGNED_VALUE;

    /**
     * @type {!Long}
     * @expose
     */
    Long.MIN_SIGNED_VALUE = Long.fromBits(0, 0x80000000 | 0, false);

    /**
     * @type {!Long}
     * @expose
     */
    Long.MIN_UNSIGNED_VALUE = Long.fromBits(0, 0, true);

    /**
     * Alias of {@link Long.MIN_SIGNED_VALUE}  for goog.math.Long compatibility.
     * @type {!Long}
     * @expose
     */
    Long.MIN_VALUE = Long.MIN_SIGNED_VALUE;

    /**
     * @return {number} The value, assuming it is a 32-bit integer.
     * @expose
     */
    Long.prototype.toInt = function() {
        return this.unsigned ? this.low >>> 0 : this.low;
    };

    /**
     * @return {number} The closest floating-point representation to this value.
     * @expose
     */
    Long.prototype.toNumber = function() {
        if (this.unsigned) {
            return ((this.high >>> 0) * TWO_PWR_32_DBL) + (this.low >>> 0);
        }
        return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
    };

    /**
     * @param {number=} radix The radix in which the text should be written.
     * @return {string} The textual representation of this value.
     * @override
     * @expose
     */
    Long.prototype.toString = function(radix) {
        radix = radix || 10;
        if (radix < 2 || 36 < radix) {
            throw(new Error('radix out of range: ' + radix));
        }
        if (this.isZero()) {
            return '0';
        }
        var rem;
        if (this.isNegative()) { // Unsigned Longs are never negative
            if (this.equals(Long.MIN_SIGNED_VALUE)) {
                // We need to change the Long value before it can be negated, so we remove
                // the bottom-most digit in this base and then recurse to do the rest.
                var radixLong = Long.fromNumber(radix);
                var div = this.div(radixLong);
                rem = div.multiply(radixLong).subtract(this);
                return div.toString(radix) + rem.toInt().toString(radix);
            } else {
                return '-' + this.negate().toString(radix);
            }
        }

        // Do several (6) digits each time through the loop, so as to
        // minimize the calls to the very expensive emulated div.
        var radixToPower = Long.fromNumber(Math.pow(radix, 6));
        rem = this;
        var result = '';
        while (true) {
            var remDiv = rem.div(radixToPower);
            var intval = rem.subtract(remDiv.multiply(radixToPower)).toInt();
            var digits = intval.toString(radix);
            rem = remDiv;
            if (rem.isZero()) {
                return digits + result;
            } else {
                while (digits.length < 6) {
                    digits = '0' + digits;
                }
                result = '' + digits + result;
            }
        }
    };

    /**
     * @return {number} The high 32 bits as a signed value.
     * @expose
     */
    Long.prototype.getHighBits = function() {
        return this.high;
    };

    /**
     * @return {number} The high 32 bits as an unsigned value.
     * @expose
     */
    Long.prototype.getHighBitsUnsigned = function() {
        return this.high >>> 0;
    };

    /**
     * @return {number} The low 32 bits as a signed value.
     * @expose
     */
    Long.prototype.getLowBits = function() {
        return this.low;
    };

    /**
     * @return {number} The low 32 bits as an unsigned value.
     * @expose
     */
    Long.prototype.getLowBitsUnsigned = function() {
        return this.low >>> 0;
    };

    /**
     * @return {number} Returns the number of bits needed to represent the absolute
     *     value of this Long.
     * @expose
     */
    Long.prototype.getNumBitsAbs = function() {
        if (this.isNegative()) { // Unsigned Longs are never negative
            if (this.equals(Long.MIN_SIGNED_VALUE)) {
                return 64;
            } else {
                return this.negate().getNumBitsAbs();
            }
        } else {
            var val = this.high != 0 ? this.high : this.low;
            for (var bit = 31; bit > 0; bit--) {
                if ((val & (1 << bit)) != 0) {
                    break;
                }
            }
            return this.high != 0 ? bit + 33 : bit + 1;
        }
    };

    /**
     * @return {boolean} Whether this value is zero.
     * @expose
     */
    Long.prototype.isZero = function() {
        return this.high == 0 && this.low == 0;
    };

    /**
     * @return {boolean} Whether this value is negative.
     * @expose
     */
    Long.prototype.isNegative = function() {
        return !this.unsigned && this.high < 0;
    };

    /**
     * @return {boolean} Whether this value is odd.
     * @expose
     */
    Long.prototype.isOdd = function() {
        return (this.low & 1) == 1;
    };

    /**
     * @return {boolean} Whether this value is even.
     */
    Long.prototype.isEven = function() {
        return (this.low & 1) == 0;
    };

    /**
     * @param {Long} other Long to compare against.
     * @return {boolean} Whether this Long equals the other.
     * @expose
     */
    Long.prototype.equals = function(other) {
        if (this.unsigned != other.unsigned && (this.high >>> 31) != (other.high >>> 31)) return false;
        return (this.high == other.high) && (this.low == other.low);
    };

    /**
     * @param {Long} other Long to compare against.
     * @return {boolean} Whether this Long does not equal the other.
     * @expose
     */
    Long.prototype.notEquals = function(other) {
        return !this.equals(other);
    };

    /**
     * @param {Long} other Long to compare against.
     * @return {boolean} Whether this Long is less than the other.
     * @expose
     */
    Long.prototype.lessThan = function(other) {
        return this.compare(other) < 0;
    };

    /**
     * @param {Long} other Long to compare against.
     * @return {boolean} Whether this Long is less than or equal to the other.
     * @expose
     */
    Long.prototype.lessThanOrEqual = function(other) {
        return this.compare(other) <= 0;
    };

    /**
     * @param {Long} other Long to compare against.
     * @return {boolean} Whether this Long is greater than the other.
     * @expose
     */
    Long.prototype.greaterThan = function(other) {
        return this.compare(other) > 0;
    };

    /**
     * @param {Long} other Long to compare against.
     * @return {boolean} Whether this Long is greater than or equal to the other.
     * @expose
     */
    Long.prototype.greaterThanOrEqual = function(other) {
        return this.compare(other) >= 0;
    };

    /**
     * Compares this Long with the given one.
     * @param {Long} other Long to compare against.
     * @return {number} 0 if they are the same, 1 if the this is greater, and -1
     *     if the given one is greater.
     * @expose
     */
    Long.prototype.compare = function(other) {
        if (this.equals(other)) {
            return 0;
        }
        var thisNeg = this.isNegative();
        var otherNeg = other.isNegative();
        if (thisNeg && !otherNeg) return -1;
        if (!thisNeg && otherNeg) return 1;
        if (!this.unsigned) {
            // At this point the signs are the same
            return this.subtract(other).isNegative() ? -1 : 1;
        } else {
            // Both are positive if at least one is unsigned
            return (other.high >>> 0) > (this.high >>> 0) || (other.high == this.high && (other.low >>> 0) > (this.low >>> 0)) ? -1 : 1;
        }
    };

    /**
     * @return {!Long} The negation of this value.
     * @expose
     */
    Long.prototype.negate = function() {
        if (!this.unsigned && this.equals(Long.MIN_SIGNED_VALUE)) {
            return Long.MIN_SIGNED_VALUE;
        }
        return this.not().add(Long.ONE);
    };

    /**
     * Returns the sum of this and the given Long.
     * @param {Long} other Long to add to this one.
     * @return {!Long} The sum of this and the given Long.
     * @expose
     */
    Long.prototype.add = function(other) {
        // Divide each number into 4 chunks of 16 bits, and then sum the chunks.
        
        var a48 = this.high >>> 16;
        var a32 = this.high & 0xFFFF;
        var a16 = this.low >>> 16;
        var a00 = this.low & 0xFFFF;

        var b48 = other.high >>> 16;
        var b32 = other.high & 0xFFFF;
        var b16 = other.low >>> 16;
        var b00 = other.low & 0xFFFF;

        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
        c00 += a00 + b00;
        c16 += c00 >>> 16;
        c00 &= 0xFFFF;
        c16 += a16 + b16;
        c32 += c16 >>> 16;
        c16 &= 0xFFFF;
        c32 += a32 + b32;
        c48 += c32 >>> 16;
        c32 &= 0xFFFF;
        c48 += a48 + b48;
        c48 &= 0xFFFF;
        return Long.fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
    };

    /**
     * Returns the difference of this and the given Long.
     * @param {Long} other Long to subtract from this.
     * @return {!Long} The difference of this and the given Long.
     * @expose
     */
    Long.prototype.subtract = function(other) {
        return this.add(other.negate());
    };

    /**
     * Returns the product of this and the given long.
     * @param {Long} other Long to multiply with this.
     * @return {!Long} The product of this and the other.
     * @expose
     */
    Long.prototype.multiply = function(other) {
        if (this.isZero()) {
            return Long.ZERO;
        } else if (other.isZero()) {
            return Long.ZERO;
        }

        if (this.equals(Long.MIN_VALUE)) {
            return other.isOdd() ? Long.MIN_VALUE : Long.ZERO;
        } else if (other.equals(Long.MIN_VALUE)) {
            return this.isOdd() ? Long.MIN_VALUE : Long.ZERO;
        }

        if (this.isNegative()) {
            if (other.isNegative()) {
                return this.negate().multiply(other.negate());
            } else {
                return this.negate().multiply(other).negate();
            }
        } else if (other.isNegative()) {
            return this.multiply(other.negate()).negate();
        }
        // If both longs are small, use float multiplication
        if (this.lessThan(TWO_PWR_24) &&
            other.lessThan(TWO_PWR_24)) {
            return Long.fromNumber(this.toNumber() * other.toNumber(), this.unsigned);
        }

        // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.
        // We can skip products that would overflow.
        
        var a48 = this.high >>> 16;
        var a32 = this.high & 0xFFFF;
        var a16 = this.low >>> 16;
        var a00 = this.low & 0xFFFF;

        var b48 = other.high >>> 16;
        var b32 = other.high & 0xFFFF;
        var b16 = other.low >>> 16;
        var b00 = other.low & 0xFFFF;

        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
        c00 += a00 * b00;
        c16 += c00 >>> 16;
        c00 &= 0xFFFF;
        c16 += a16 * b00;
        c32 += c16 >>> 16;
        c16 &= 0xFFFF;
        c16 += a00 * b16;
        c32 += c16 >>> 16;
        c16 &= 0xFFFF;
        c32 += a32 * b00;
        c48 += c32 >>> 16;
        c32 &= 0xFFFF;
        c32 += a16 * b16;
        c48 += c32 >>> 16;
        c32 &= 0xFFFF;
        c32 += a00 * b32;
        c48 += c32 >>> 16;
        c32 &= 0xFFFF;
        c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
        c48 &= 0xFFFF;
        return Long.fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
    };

    /**
     * Returns this Long divided by the given one.
     * @param {Long} other Long by which to divide.
     * @return {!Long} This Long divided by the given one.
     * @expose
     */
    Long.prototype.div = function(other) {
        if (other.isZero()) {
            throw(new Error('division by zero'));
        } else if (this.isZero()) {
            return this.unsigned ? Long.UZERO : Long.ZERO;
        }
        var approx, rem, res;
        if (this.equals(Long.MIN_SIGNED_VALUE)) {
            if (other.equals(Long.ONE) || other.equals(Long.NEG_ONE)) {
                return Long.MIN_SIGNED_VALUE;  // recall that -MIN_VALUE == MIN_VALUE
            } else if (other.equals(Long.MIN_SIGNED_VALUE)) {
                return Long.ONE;
            } else {
                // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.
                var halfThis = this.shiftRight(1);
                approx = halfThis.div(other).shiftLeft(1);
                if (approx.equals(Long.ZERO)) {
                    return other.isNegative() ? Long.ONE : Long.NEG_ONE;
                } else {
                    rem = this.subtract(other.multiply(approx));
                    res = approx.add(rem.div(other));
                    return res;
                }
            }
        } else if (other.equals(Long.MIN_SIGNED_VALUE)) {
            return this.unsigned ? Long.UZERO : Long.ZERO;
        }
        if (this.isNegative()) {
            if (other.isNegative()) {
                return this.negate().div(other.negate());
            } else {
                return this.negate().div(other).negate();
            }
        } else if (other.isNegative()) {
            return this.div(other.negate()).negate();
        }
        
        // Repeat the following until the remainder is less than other:  find a
        // floating-point that approximates remainder / other *from below*, add this
        // into the result, and subtract it from the remainder.  It is critical that
        // the approximate value is less than or equal to the real value so that the
        // remainder never becomes negative.
        res = Long.ZERO;
        rem = this;
        while (rem.greaterThanOrEqual(other)) {
            // Approximate the result of division. This may be a little greater or
            // smaller than the actual value.
            approx = Math.max(1, Math.floor(rem.toNumber() / other.toNumber()));

            // We will tweak the approximate result by changing it in the 48-th digit or
            // the smallest non-fractional digit, whichever is larger.
            var log2 = Math.ceil(Math.log(approx) / Math.LN2);
            var delta = (log2 <= 48) ? 1 : Math.pow(2, log2 - 48);

            // Decrease the approximation until it is smaller than the remainder.  Note
            // that if it is too large, the product overflows and is negative.
            var approxRes = Long.fromNumber(approx, this.unsigned);
            var approxRem = approxRes.multiply(other);
            while (approxRem.isNegative() || approxRem.greaterThan(rem)) {
                approx -= delta;
                approxRes = Long.fromNumber(approx, this.unsigned);
                approxRem = approxRes.multiply(other);
            }

            // We know the answer can't be zero... and actually, zero would cause
            // infinite recursion since we would make no progress.
            if (approxRes.isZero()) {
                approxRes = Long.ONE;
            }

            res = res.add(approxRes);
            rem = rem.subtract(approxRem);
        }
        return res;
    };

    /**
     * Returns this Long modulo the given one.
     * @param {Long} other Long by which to mod.
     * @return {!Long} This Long modulo the given one.
     * @expose
     */
    Long.prototype.modulo = function(other) {
        return this.subtract(this.div(other).multiply(other));
    };

    /**
     * @return {!Long} The bitwise-NOT of this value.
     * @expose
     */
    Long.prototype.not = function() {
        return Long.fromBits(~this.low, ~this.high, this.unsigned);
    };

    /**
     * Returns the bitwise-AND of this Long and the given one.
     * @param {Long} other The Long with which to AND.
     * @return {!Long} The bitwise-AND of this and the other.
     * @expose
     */
    Long.prototype.and = function(other) {
        return Long.fromBits(this.low & other.low, this.high & other.high, this.unsigned);
    };

    /**
     * Returns the bitwise-OR of this Long and the given one.
     * @param {Long} other The Long with which to OR.
     * @return {!Long} The bitwise-OR of this and the other.
     * @expose
     */
    Long.prototype.or = function(other) {
        return Long.fromBits(this.low | other.low, this.high | other.high, this.unsigned);
    };

    /**
     * Returns the bitwise-XOR of this Long and the given one.
     * @param {Long} other The Long with which to XOR.
     * @return {!Long} The bitwise-XOR of this and the other.
     * @expose
     */
    Long.prototype.xor = function(other) {
        return Long.fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
    };

    /**
     * Returns this Long with bits shifted to the left by the given amount.
     * @param {number} numBits The number of bits by which to shift.
     * @return {!Long} This shifted to the left by the given amount.
     * @expose
     */
    Long.prototype.shiftLeft = function(numBits) {
        numBits &= 63;
        if (numBits == 0) {
            return this;
        } else {
            var low = this.low;
            if (numBits < 32) {
                var high = this.high;
                return Long.fromBits(low << numBits, (high << numBits) | (low >>> (32 - numBits)), this.unsigned);
            } else {
                return Long.fromBits(0, low << (numBits - 32), this.unsigned);
            }
        }
    };

    /**
     * Returns this Long with bits shifted to the right by the given amount.
     * @param {number} numBits The number of bits by which to shift.
     * @return {!Long} This shifted to the right by the given amount.
     * @expose
     */
    Long.prototype.shiftRight = function(numBits) {
        numBits &= 63;
        if (numBits == 0) {
            return this;
        } else {
            var high = this.high;
            if (numBits < 32) {
                var low = this.low;
                return Long.fromBits((low >>> numBits) | (high << (32 - numBits)), high >> numBits, this.unsigned);
            } else {
                return Long.fromBits(high >> (numBits - 32), high >= 0 ? 0 : -1, this.unsigned);
            }
        }
    };

    /**
     * Returns this Long with bits shifted to the right by the given amount, with
     * the new top bits matching the current sign bit.
     * @param {number} numBits The number of bits by which to shift.
     * @return {!Long} This shifted to the right by the given amount, with
     *     zeros placed into the new leading bits.
     * @expose
     */
    Long.prototype.shiftRightUnsigned = function(numBits) {
        numBits &= 63;
        if (numBits == 0) {
            return this;
        } else {
            var high = this.high;
            if (numBits < 32) {
                var low = this.low;
                return Long.fromBits((low >>> numBits) | (high << (32 - numBits)), high >>> numBits, this.unsigned);
            } else if (numBits == 32) {
                return Long.fromBits(high, 0, this.unsigned);
            } else {
                return Long.fromBits(high >>> (numBits - 32), 0, this.unsigned);
            }
        }
    };

    /**
     * @return {!Long} Signed long
     * @expose
     */
    Long.prototype.toSigned = function() {
        var l = this.clone();
        l.unsigned = false;
        return l;
    };

    /**
     * @return {!Long} Unsigned long
     * @expose
     */
    Long.prototype.toUnsigned = function() {
        var l = this.clone();
        l.unsigned = true;
        return l;
    };
    
    /**
     * @return {Long} Cloned instance with the same low/high bits and unsigned flag.
     * @expose
     */
    Long.prototype.clone = function() {
        return new Long(this.low, this.high, this.unsigned);
    };

    // Enable module loading if available
    if (typeof module != 'undefined' && module["exports"]) { // CommonJS
        module["exports"] = Long;
    } else if (typeof define != 'undefined' && define["amd"]) { // AMD
        define("Math/Long", [], function() { return Long; });
    } else { // Shim
        if (!global["dcodeIO"]) {
            global["dcodeIO"] = {};
        }
        global["dcodeIO"]["Long"] = Long;
    }

})(this);

},{}],56:[function(require,module,exports){
/*
 Copyright 2013 Daniel Wirtz <dcode@dcode.io>
 Copyright 2009 The Closure Library Authors. All Rights Reserved.

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS-IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 */

module.exports = require("./dist/Long.js");

},{"./dist/Long.js":55}],57:[function(require,module,exports){
var furious = require("../lib/furious.js");
var expect = require("chai").expect;

var context = null;
before(function(done) {
	furious.init(function(ctx) {
		context = ctx;
		done();
	});
});

describe("Context", function(){
	describe("barrier", function() {
		it("Calls the callback", function(done) {
			context.barrier(function () {
				done();
			});
		});
		it("Executes after preceeding commands have finished", function(done) {
			var x = context.zeros([3, 3]);
			var getHasFinished = false;
			x.get(function(data) {
				getHasFinished = true;
			});
			context.barrier(function (){
				expect(getHasFinished).to.be.true;
				done();
			});
		});
		it("Executes before subsequent commands have started", function(done) {
			var x = context.zeros([3, 3]);
			var barrierHasFinished = false;
			context.barrier(function (){
				barrierHasFinished = true;
			});
			x.get(function(x) {
				expect(barrierHasFinished).to.be.true;
				done();
			});
		});
	});
	describe("empty", function(){
		it("Creates array with specified shape", function() {
			var x = context.empty(42);
			var y = context.empty([42]);
			var z = context.empty([4, 2]);
			expect(x.shape).to.deep.equal([42]);
			expect(y.shape).to.deep.equal([42]);
			expect(z.shape).to.deep.equal([4, 2]);
			x.invalidate();
			y.invalidate();
			z.invalidate();
		});
		it("Creates array with specified data type (f64 by default)", function() {
			var x = context.empty([4, 2]);
			var y = context.empty([4, 2], new furious.DataType("f64"));
			var z = context.empty([4, 2], new furious.DataType("f32"));
			expect(x.dataType.equals(new furious.DataType("f64"))).to.be.true;
			expect(y.dataType.equals(new furious.DataType("f64"))).to.be.true;
			expect(z.dataType.equals(new furious.DataType("f32"))).to.be.true;
			x.invalidate();
			y.invalidate();
			z.invalidate();
		});
	});
	describe("zeros", function(){
		it("Creates array with specified shape", function() {
			var x = context.zeros(42);
			var y = context.zeros([42]);
			var z = context.zeros([4, 2]);
			expect(x.shape).to.deep.equal([42]);
			expect(y.shape).to.deep.equal([42]);
			expect(z.shape).to.deep.equal([4, 2]);
			x.invalidate();
			y.invalidate();
			z.invalidate();
		});
		it("Creates array with specified data type (f64 by default)", function() {
			var x = context.zeros([4, 2]);
			var y = context.zeros([4, 2], new furious.DataType("f64"));
			var z = context.zeros([4, 2], new furious.DataType("f32"));
			expect(x.dataType.equals(new furious.DataType("f64"))).to.be.true;
			expect(y.dataType.equals(new furious.DataType("f64"))).to.be.true;
			expect(z.dataType.equals(new furious.DataType("f32"))).to.be.true;
			x.invalidate();
			y.invalidate();
			z.invalidate();
		});
		it("Creates array with all elements initialized to zero", function(done) {
			var x = context.zeros([3, 2], new furious.DataType("f64"));
			var y = context.zeros([2, 3], new furious.DataType("f32"));
			context.get(x, y, function(x, y) {
				expect(x).to.deep.equal([[0.0, 0.0],
				                         [0.0, 0.0],
				                         [0.0, 0.0]]);
				expect(y).to.deep.equal([[0.0, 0.0, 0.0],
				                         [0.0, 0.0, 0.0]]);
				done();
			});
		});
	});
	describe("ones", function(){
		it("Creates array with specified shape", function() {
			var x = context.ones(42);
			var y = context.ones([42]);
			var z = context.ones([4, 2]);
			expect(x.shape).to.deep.equal([42]);
			expect(y.shape).to.deep.equal([42]);
			expect(z.shape).to.deep.equal([4, 2]);
			x.invalidate();
			y.invalidate();
			z.invalidate();
		});
		it("Creates array with specified data type (f64 by default)", function() {
			var x = context.ones([4, 2]);
			var y = context.ones([4, 2], new furious.DataType("f64"));
			var z = context.ones([4, 2], new furious.DataType("f32"));
			expect(x.dataType.equals(new furious.DataType("f64"))).to.be.true;
			expect(y.dataType.equals(new furious.DataType("f64"))).to.be.true;
			expect(z.dataType.equals(new furious.DataType("f32"))).to.be.true;
			x.invalidate();
			y.invalidate();
			z.invalidate();
		});
		it("Creates array with all elements initialized to one", function(done) {
			var x = context.ones([3, 2], new furious.DataType("f64"));
			var y = context.ones([2, 3], new furious.DataType("f32"));
			context.get(x, y, function(x, y) {
				expect(x).to.deep.equal([[1.0, 1.0],
				                         [1.0, 1.0],
				                         [1.0, 1.0]]);
				expect(y).to.deep.equal([[1.0, 1.0, 1.0],
				                         [1.0, 1.0, 1.0]]);
				done();
			});
		});
	});
	describe("array", function(){
		it("Creates array of the same length as the provided array", function(){
			var x = context.array([0, 1]);
			var y = context.array([[0, 1],
			                       [2, 3],
			                       [3, 4]]);
			expect(x.length).to.equal(2);
			expect(y.length).to.equal(6);
			x.invalidate();
			y.invalidate();
		});
		it("Creates array of the same shape as the provided array", function(){
			var x = context.array([0, 1]);
			var y = context.array([[0, 1],
			                       [2, 3],
			                       [3, 4]]);
			var z = context.array([[[1, 2, 3], [ 4,  5,  6]],
			                       [[7, 8, 9], [10, 11, 12]]]);
			expect(x.shape).to.deep.equal([2]);
			expect(y.shape).to.deep.equal([3, 2]);
			expect(z.shape).to.deep.equal([2, 2, 3]);
			x.invalidate();
			y.invalidate();
			z.invalidate();
		});
		it("Creates array with the same data as the provided array", function(done){
			var array = [[[1, 2, 3], [ 4,  5,  6]],
			             [[7, 8, 9], [10, 11, 12]]];
			var x = context.array(array, new furious.DataType("f64"));
			var y = context.array(array, new furious.DataType("f32"));
			context.get(x, y, function(x, y) {
				expect(x).to.deep.equal(array);
				expect(y).to.deep.equal(array);
				done();
			});
		});
	});
	describe("linspace", function(){
		it("Has length of 50 with default arguments", function(){
			expect((context.linspace(0, 1)).length).to.equal(50);
		});
		it("Has the specified number of samples", function(){
			expect((context.linspace(0, 1, 243)).length).to.equal(243);
		});
		it("Has expected values", function(done){
			var start = 50;
			var stop = 99;
			var x = context.linspace(start, stop);
			x.get(function(result) {
				for (var i = 0; i < result.length; i++) {
					expect(result[i]).to.equal(start+i);
				}
				done();
			});
		});
		describe("with includeStop === false", function(){
			it("Has the specified number of samples", function(){
				expect((context.linspace(0, 1, 243, false)).length).to.equal(243);
			});
			it("Does not contain the right endpoint", function(done){
				var x = context.linspace(-1, 1, 1000, false);
				x.get(function(result) {
					expect(result[result.length - 1]).to.not.equal(1);
					done();
				});
			});
		});
	});
	describe("neg", function() {
		var xRef = [ 1, -7.5,  0, -15];
		var yRef = [-1,  7.5, -0,  15];
		var dataTypes = ["f32", "f64"];

		describe("With no output array supplied", function() {
			it("Creates an output array with the same shape as input array", function() {
				var x = context.ones([2, 3, 4]);
				var y = context.neg(x);
				expect(y.shape).to.deep.equal([2, 3, 4]);
				y.invalidate();
			});

			for (var i = 0; i < dataTypes.length; i++) {
				(function(dataType) {
					it("Creates an output array with the same data type as input array (" + dataType + " data type)", function() {
						var x = context.array(xRef, new furious.DataType(dataType));
						var y = context.neg(x);
						expect(y.dataType.equals(new furious.DataType(dataType))).to.be.true;
						y.invalidate();
					});
				})(dataTypes[i]);
			}

			for (var i = 0; i < dataTypes.length; i++) {
				(function(dataType) {
					it("Creates an output array with negated elements (" + dataType + " data type)", function(done) {
						var x = context.array(xRef, new furious.DataType(dataType));
						var y = context.neg(x);
						y.get(function(y) {
							expect(y).to.deep.equal(yRef);
							done();
						});
					});
				})(dataTypes[i]);
			}
		});
		describe("With an output array", function() {
			for (var i = 0; i < dataTypes.length; i++) {
				(function(dataType) {
					it("Populates the output array with negated elements (" + dataType + " data type)", function(done) {
						var x = context.array(xRef, new furious.DataType(dataType));
						var y = context.ones(x.shape, x.dataType);
						context.neg(x, y);
						y.get(function(y) {
							expect(y).to.deep.equal(yRef);
							done();
						});
					});
				})(dataTypes[i]);
			}
		});
	});
	describe("abs", function() {
		var xRef = [1, -7.5, 0, -15];
		var yRef = [1,  7.5, 0,  15];
		var dataTypes = ["f32", "f64"];

		describe("With no output array supplied", function() {
			it("Creates an output array with the same shape as input array", function() {
				var x = context.ones([2, 3, 4]);
				var y = context.abs(x);
				expect(y.shape).to.deep.equal([2, 3, 4]);
				y.invalidate();
			});

			for (var i = 0; i < dataTypes.length; i++) {
				(function(dataType) {
					it("Creates an output array with the same data type as input array (" + dataType + " data type)", function() {
						var x = context.array(xRef, new furious.DataType(dataType));
						var y = context.abs(x);
						expect(y.dataType.equals(new furious.DataType(dataType))).to.be.true;
						y.invalidate();
					});
				})(dataTypes[i]);
			}

			for (var i = 0; i < dataTypes.length; i++) {
				(function(dataType) {
					it("Creates an output array with absolute values of elements (" + dataType + " data type)", function(done) {
						var x = context.array(xRef, new furious.DataType(dataType));
						var y = context.abs(x);
						y.get(function(y) {
							expect(y).to.deep.equal(yRef);
							done();
						});
					});
				})(dataTypes[i]);
			}
		});
		describe("With an output array", function() {
			for (var i = 0; i < dataTypes.length; i++) {
				(function(dataType) {
					it("Populates the output array with absolute values of elements (" + dataType + " data type)", function(done) {
						var x = context.array(xRef, new furious.DataType(dataType));
						var y = context.ones(x.shape, x.dataType);
						context.abs(x, y);
						y.get(function(y) {
							expect(y).to.deep.equal(yRef);
							done();
						});
					});
				})(dataTypes[i]);
			}
		});
	});
	describe("exp", function() {
		var xRef = [1, -1, 0];
		var dataTypes = ["f32", "f64"];

		describe("With no output array supplied", function() {
			it("Creates an output array with the same shape as input array", function() {
				var x = context.ones([2, 3, 4]);
				var y = context.exp(x);
				expect(y.shape).to.deep.equal([2, 3, 4]);
				y.invalidate();
			});

			for (var i = 0; i < dataTypes.length; i++) {
				(function(dataType) {
					it("Creates an output array with the same data type as input array (" + dataType + " data type)", function() {
						var x = context.array(xRef, new furious.DataType(dataType));
						var y = context.exp(x);
						expect(y.dataType.equals(new furious.DataType(dataType))).to.be.true;
						y.invalidate();
					});
				})(dataTypes[i]);
			}

			for (var i = 0; i < dataTypes.length; i++) {
				(function(dataType) {
					it("Creates an output array with absolute values of elements (" + dataType + " data type)", function(done) {
						var x = context.array(xRef, new furious.DataType(dataType));
						var y = context.exp(x);
						y.get(function(y) {
							for (var k = 0; k < y.length; k++) {
								expect(y[k]).to.be.closeTo(Math.exp(xRef[k]), Math.exp(xRef[k]) * 3 * x.dataType.epsilon);
							}
							done();
						});
					});
				})(dataTypes[i]);
			}
		});
		describe("With an output array", function() {
			for (var i = 0; i < dataTypes.length; i++) {
				(function(dataType) {
					it("Populates the output array with absolute values of elements (" + dataType + " data type)", function(done) {
						var x = context.array(xRef, new furious.DataType(dataType));
						var y = context.ones(x.shape, x.dataType);
						context.exp(x, y);
						y.get(function(y) {
							for (var k = 0; k < y.length; k++) {
								expect(y[k]).to.be.closeTo(Math.exp(xRef[k]), Math.exp(xRef[k]) * 3 * x.dataType.epsilon);
							}
							done();
						});
					});
				})(dataTypes[i]);
			}
		});
	});
	describe("log", function() {
		var xRef = [1, 3, 10];
		var dataTypes = ["f32", "f64"];

		describe("With no output array supplied", function() {
			it("Creates an output array with the same shape as input array", function() {
				var x = context.ones([2, 3, 4]);
				var y = context.log(x);
				expect(y.shape).to.deep.equal([2, 3, 4]);
				y.invalidate();
			});

			for (var i = 0; i < dataTypes.length; i++) {
				(function(dataType) {
					it("Creates an output array with the same data type as input array (" + dataType + " data type)", function() {
						var x = context.array(xRef, new furious.DataType(dataType));
						var y = context.log(x);
						expect(y.dataType.equals(new furious.DataType(dataType))).to.be.true;
						y.invalidate();
					});
				})(dataTypes[i]);
			}

			for (var i = 0; i < dataTypes.length; i++) {
				(function(dataType) {
					it("Creates an output array with absolute values of elements (" + dataType + " data type)", function(done) {
						var x = context.array(xRef, new furious.DataType(dataType));
						var y = context.log(x);
						y.get(function(y) {
							for (var k = 0; k < y.length; k++) {
								expect(y[k]).to.be.closeTo(Math.log(xRef[k]), Math.log(xRef[k]) * 3 * x.dataType.epsilon);
							}
							done();
						});
					});
				})(dataTypes[i]);
			}
		});
		describe("With an output array", function() {
			for (var i = 0; i < dataTypes.length; i++) {
				(function(dataType) {
					it("Populates the output array with absolute values of elements (" + dataType + " data type)", function(done) {
						var x = context.array(xRef, new furious.DataType(dataType));
						var y = context.ones(x.shape, x.dataType);
						context.log(x, y);
						y.get(function(y) {
							for (var k = 0; k < y.length; k++) {
								expect(y[k]).to.be.closeTo(Math.log(xRef[k]), Math.log(xRef[k]) * 3 * x.dataType.epsilon);
							}
							done();
						});
					});
				})(dataTypes[i]);
			}
		});
	});
	describe("sqrt", function() {
		var xRef = [0, 0.25, 1, 9, 10];
		var dataTypes = ["f32", "f64"];

		describe("With no output array supplied", function() {
			it("Creates an output array with the same shape as input array", function() {
				var x = context.ones([2, 3, 4]);
				var y = context.sqrt(x);
				expect(y.shape).to.deep.equal([2, 3, 4]);
				y.invalidate();
			});

			for (var i = 0; i < dataTypes.length; i++) {
				(function(dataType) {
					it("Creates an output array with the same data type as input array (" + dataType + " data type)", function() {
						var x = context.array(xRef, new furious.DataType(dataType));
						var y = context.sqrt(x);
						expect(y.dataType.equals(new furious.DataType(dataType))).to.be.true;
						y.invalidate();
					});
				})(dataTypes[i]);
			}

			for (var i = 0; i < dataTypes.length; i++) {
				(function(dataType) {
					it("Creates an output array with absolute values of elements (" + dataType + " data type)", function(done) {
						var x = context.array(xRef, new furious.DataType(dataType));
						var y = context.sqrt(x);
						y.get(function(y) {
							for (var k = 0; k < y.length; k++) {
								expect(y[k]).to.be.closeTo(Math.sqrt(xRef[k]), Math.sqrt(xRef[k]) * 3 * x.dataType.epsilon);
							}
							done();
						});
					});
				})(dataTypes[i]);
			}
		});
		describe("With an output array", function() {
			for (var i = 0; i < dataTypes.length; i++) {
				(function(dataType) {
					it("Populates the output array with absolute values of elements (" + dataType + " data type)", function(done) {
						var x = context.array(xRef, new furious.DataType(dataType));
						var y = context.ones(x.shape, x.dataType);
						context.sqrt(x, y);
						y.get(function(y) {
							for (var k = 0; k < y.length; k++) {
								expect(y[k]).to.be.closeTo(Math.sqrt(xRef[k]), Math.sqrt(xRef[k]) * 3 * x.dataType.epsilon);
							}
							done();
						});
					});
				})(dataTypes[i]);
			}
		});
	});
	describe("square", function() {
		var xRef = [-2, 0, 0.5, 1, 3];
		var dataTypes = ["f32", "f64"];

		describe("With no output array supplied", function() {
			it("Creates an output array with the same shape as input array", function() {
				var x = context.ones([2, 3, 4]);
				var y = context.square(x);
				expect(y.shape).to.deep.equal([2, 3, 4]);
				y.invalidate();
			});

			for (var i = 0; i < dataTypes.length; i++) {
				(function(dataType) {
					it("Creates an output array with the same data type as input array (" + dataType + " data type)", function() {
						var x = context.array(xRef, new furious.DataType(dataType));
						var y = context.square(x);
						expect(y.dataType.equals(new furious.DataType(dataType))).to.be.true;
						y.invalidate();
					});
				})(dataTypes[i]);
			}

			for (var i = 0; i < dataTypes.length; i++) {
				(function(dataType) {
					it("Creates an output array with absolute values of elements (" + dataType + " data type)", function(done) {
						var x = context.array(xRef, new furious.DataType(dataType));
						var y = context.square(x);
						y.get(function(y) {
							for (var k = 0; k < y.length; k++) {
								expect(y[k]).to.be.closeTo(xRef[k] * xRef[k], xRef[k] * xRef[k] * x.dataType.epsilon);
							}
							done();
						});
					});
				})(dataTypes[i]);
			}
		});
		describe("With an output array", function() {
			for (var i = 0; i < dataTypes.length; i++) {
				(function(dataType) {
					it("Populates the output array with absolute values of elements (" + dataType + " data type)", function(done) {
						var x = context.array(xRef, new furious.DataType(dataType));
						var y = context.ones(x.shape, x.dataType);
						context.square(x, y);
						y.get(function(y) {
							for (var k = 0; k < y.length; k++) {
								expect(y[k]).to.be.closeTo(xRef[k] * xRef[k], xRef[k] * xRef[k] * x.dataType.epsilon);
							}
							done();
						});
					});
				})(dataTypes[i]);
			}
		});
	});
});

},{"../lib/furious.js":6,"chai":14}],58:[function(require,module,exports){
var furious = require("../lib/furious.js");
var expect = require("chai").expect;

describe("DataType", function(){
	describe("f32", function(){
		it("should have size 4", function(){
			var dtype = new furious.DataType("f32");
			expect(dtype.size).to.equal(4);
		});

		it("should have type \"f32\"", function(){
			var dtype = new furious.DataType("f32");
			expect(dtype.type).to.equal("f32");
		});
	});
	describe("f64", function(){
		it("should have size 8", function(){
			var dtype = new furious.DataType("f64");
			expect(dtype.size).to.equal(8);
		});

		it("should have type \"f64\"", function(){
			var dtype = new furious.DataType("f64");
			expect(dtype.type).to.equal("f64");
		});
	});
});

},{"../lib/furious.js":6,"chai":14}],59:[function(require,module,exports){
var furious = require("../lib/furious.js");
var expect = require("chai").expect;

var context = null;
before(function(done) {
	furious.init(function(ctx) {
		context = ctx;
		done();
	});
});

describe("NDArray", function() {
	describe("length", function() {
		it("Equals to the number passed in constructor", function() {
			var x = context.empty(42);
			expect(x.length).to.equal(42);
			x.invalidate();
		});
		it("Equals to the number passed in constructor as an array", function() {
			var x = context.empty([42]);
			expect(x.length).to.equal(42);
			x.invalidate();
		});
		it("Equals to the product of dimensions", function() {
			var x = context.empty([2, 5, 3]);
			expect(x.length).to.equal(30);
			x.invalidate();
		});
	});
	describe("reshape", function() {
		it("Preserves length", function() {
			var x = context.empty([7,5,3]);
			var y = x.reshape([21,5]);
			expect(y.length).to.equal(x.length);
			y.invalidate();
		});
		it("Changes shape", function() {
			var x = context.empty([7,5,3]);
			var y = x.reshape([21,5]);
			expect(y.shape).to.deep.equal([21,5]);
			y.invalidate();
		});
		it("Rearranges data", function(done) {
			var x = context.linspace(1, 8, 8).reshape([2, 2, 2]);
			x.get(function(result) {
				expect(result).to.deep.equal([[[ 1,  2], [ 3,  4]],
											  [[ 5,  6], [ 7,  8]]]);
				done();
			});
		});
	});
	describe("repeat", function() {
		it("Repeats array elements along axis 0", function(done) {
			var x = context.array([[8, 1, 6],
			                       [3, 5, 7],
			                       [4, 9, 2]]);
			x.repeat(2, 0).get(function(y) {
				expect(y).to.deep.equal([[8, 1, 6],
				                         [8, 1, 6],
				                         [3, 5, 7],
				                         [3, 5, 7],
				                         [4, 9, 2],
				                         [4, 9, 2]]);
				done();
			});
		});
		it("Repeats array elements along axis 1", function(done) {
			var x = context.array([[8, 1, 6],
			                       [3, 5, 7],
			                       [4, 9, 2]]);
			x.repeat(2, 1).get(function(y) {
				expect(y).to.deep.equal([[8, 8, 1, 1, 6, 6],
				                         [3, 3, 5, 5, 7, 7],
				                         [4, 4, 9, 9, 2, 2]]);
				done();
			});
		});
	});
	describe("get", function(){
		it("Works with 1-dimensional array", function(done) {
			var x = context.array([42, 10]);
			x.get(function(y) {
				expect(y).to.deep.equal([42, 10]);
				done();
			});
		});
		it("Works with 2-dimensional array", function(done) {
			var array = [[16,  2,  3, 13,  5],
						 [11, 10,  8,  9,  7],
						 [ 6, 12,  4, 14, 15]];
			var x = context.array(array);
			x.get(function(y) {
				expect(y).to.deep.equal(array);
				done();
			});
		});
	});
	describe("add", function() {
		describe("Add array", function() {
			it("Correct result for 1-dimensional arrays", function(done) {
				var x = context.array([1, 4, 9]);
				var y = context.array([8, -1, 10]);
				var z = x.add(y);
				z.get(function(z) {
					expect(z).to.deep.equal([9, 3, 19]);
					done();
				});
			});
			it("Correct result for 2-dimensional arrays", function(done) {
				var x = context.array([[1, 4], [9, -17]]);
				var y = context.array([[8, -1], [10, -21]]);
				var z = x.add(y);
				z.get(function(result) {
					expect(result).to.deep.equal([[9, 3], [19, -38]]);
					done();
				});
			});
		});
		describe("Add scalar", function(){
			it("Correct result for 1-dimensional arrays", function(done) {
				var x = context.array([1, 4, 9]);
				var z = x.add(-7);
				z.get(function(z) {
					expect(z).to.deep.equal([-6, -3, 2]);
					done();
				});
			});
			it("Correct result for 2-dimensional arrays", function(done) {
				var x = context.array([[1, 4], [9, -17]]);
				var z = x.add(42);
				z.get(function(z) {
					expect(z).to.deep.equal([[43, 46], [51, 25]]);
					done();
				});
			});
		});
	});
	describe("sub", function() {
		describe("Subtract array", function() {
			it("Correct result for 1-dimensional arrays", function(done) {
				var x = context.array([1, 4, 9]);
				var y = context.array([8, -1, 10]);
				var z = x.sub(y);
				z.get(function(result) {
					expect(result).to.deep.equal([-7, 5, -1]);
					done();
				});
			});
			it("Correct result for 2-dimensional arrays", function(done) {
				var x = context.array([[1, 4], [9, -17]]);
				var y = context.array([[8, -1], [10, -21]]);
				var z = x.sub(y);
				z.get(function(result) {
					expect(result).to.deep.equal([[-7, 5], [-1, 4]]);
					done();
				});
			});
		});
		describe("Subtract scalar", function() {
			it("Correct result for 1-dimensional arrays", function(done) {
				var x = context.array([1, 4, 9]);
				var y = x.sub(-7);
				y.get(function(y) {
					expect(y).to.deep.equal([8, 11, 16]);
					done();
				});
			});
			it("Correct result for 2-dimensional arrays", function(done) {
				var x = context.array([[1, 4], [9, -17]]);
				var y = x.sub(42);
				y.get(function(y) {
					expect(y).to.deep.equal([[-41, -38], [-33, -59]]);
					done();
				});
			});
		});
	});
	describe("mul", function() {
		describe("Multiply by array", function() {
			it("Correct result for 1-dimensional arrays", function(done) {
				var x = context.array([1, 4, 9]);
				var y = context.array([8, -1, 10]);
				var z = x.mul(y);
				z.get(function(z) {
					expect(z).to.deep.equal([8, -4, 90]);
					done();
				});
			});
			it("Correct result for 2-dimensional arrays", function(done) {
				var x = context.array([[1, 4], [9, -17]]);
				var y = context.array([[8, -1], [10, -21]]);
				var z = x.mul(y);
				z.get(function(z) {
					expect(z).to.deep.equal([[8, -4], [90, 357]]);
					done();
				});
			});
		});
		describe("Multiply by scalar", function() {
			it("Correct result for 1-dimensional arrays", function(done) {
				var x = context.array([1, 4, 9]);
				var y = x.mul(-10);
				y.get(function(y) {
					expect(y).to.deep.equal([-10, -40, -90]);
					done();
				});
			});
			it("Correct result for 2-dimensional arrays", function(done) {
				var x = context.array([[1, 4], [9, -17]]);
				var y = x.mul(10);
				y.get(function(y) {
					expect(y).to.deep.equal([[10, 40], [90, -170]]);
					done();
				});
			});
		});
	});
	describe("div", function(){
		describe("Divide by array", function(){
			it("Correct result for 1-dimensional arrays", function(done) {
				var x = context.array([1, 4, 9]);
				var y = context.array([2, -4, 8]);
				var z = x.div(y);
				z.get(function(z) {
					expect(z).to.deep.equal([0.5, -1, 1.125]);
					done();
				});
			});
			it("Correct result for 2-dimensional arrays", function(done) {
				var x = context.array([[1, 4], [9, -17]]);
				var y = context.array([[-2, 4], [-8, 16]]);
				var z = x.div(y);
				z.get(function(z) {
					expect(z).to.deep.equal([[-0.5, 1], [-1.125, -1.0625]]);
					done();
				});
			});
		});
		describe("Divide by scalar", function() {
			it("Correct result for 1-dimensional arrays", function() {
				var x = context.array([1, 4, 9]);
				var y = x.div(-2);
				y.get(function(y) {
					expect(y).to.deep.equal([-0.5, -2, -4.5]);
				});
			});
			it("Correct result for 2-dimensional arrays", function() {
				var x = context.array([[1, 4], [9, -17]]);
				var y = x.div(-4);
				y.get(function(y) {
					expect(y).to.deep.equal([[-0.25, -1], [-2.25, 4.25]]);
				});
			});
		});
	});
	describe("min", function(){
		describe("All elements", function(){
			it("Returns zero-dimensional array of length one", function() {
				var x = context.zeros([20, 30]);
				var y = x.min();
				expect(y.shape).to.deep.equal([]);
				expect(y.length).to.equal(1);
				y.invalidate();
			});
			it("Computes the minimum of all elements in an array", function(done) {
				var x = context.linspace(-50, 100, 100000).reshape([200, 500]);
				x.min().get(function(y) {
					expect(y).to.equal(-50);
					done();
				});
			});
		});
		describe("Along an axis", function() {
			it("Correct shape for 3-dimensional arrays", function() {
				var x = context.linspace(1, 24, 24).reshape([2, 3, 4]).lock();
				expect(x.min(0).shape).to.deep.equal([3, 4]);
				expect(x.min(1).shape).to.deep.equal([2, 4]);
				expect(x.min(2).shape).to.deep.equal([2, 3]);
				x.invalidate();
			});
			it("Correct result for 3-dimensional arrays, axis 0", function(done) {
				var x = context.linspace(1, 24, 24).reshape([2, 3, 4]);
				x.min(0).get(function(y) {
					expect(y).to.deep.equal([[ 1,  2,  3,  4],
					                         [ 5,  6,  7,  8],
					                         [ 9, 10, 11, 12]]);
					done();
				});
			});
			it("Correct result for 3-dimensional arrays, axis 1", function(done) {
				var x = context.linspace(1, 24, 24).reshape([2, 3, 4]);
				x.min(1).get(function(y) {
					expect(y).to.deep.equal([[  1,  2,  3,  4],
					                         [ 13, 14, 15, 16]]);
					done();
				});
			});
			it("Correct result for 3-dimensional arrays, axis 2", function(done) {
				var x = context.linspace(1, 24, 24).reshape([2, 3, 4]);
				x.min(2).get(function(y) {
					expect(y).to.deep.equal([[  1,  5,  9],
					                         [ 13, 17, 21]]);
					done();
				});
			});
		});
	});
	describe("max", function() {
		describe("All elements", function() {
			it("Returns zero-dimensional array of length one", function() {
				var x = context.zeros([20, 30]);
				var y = x.max();
				expect(y.shape).to.deep.equal([]);
				expect(y.length).to.equal(1);
				y.invalidate();
			});
			it("Computes the maximum of all elements in an array", function(done) {
				var x = context.linspace(-50, 100, 100000).reshape([200, 500]);
				x.max().get(function(y) {
					expect(y).to.equal(100);
					done();
				});
			});
		});
		describe("Along an axis", function() {
			it("Correct shape for 3-dimensional arrays", function() {
				var x = context.linspace(1, 24, 24).reshape([2, 3, 4]).lock();
				expect(x.max(0).shape).to.deep.equal([3, 4]);
				expect(x.max(1).shape).to.deep.equal([2, 4]);
				expect(x.max(2).shape).to.deep.equal([2, 3]);
				x.invalidate();
			});
			it("Correct result for 3-dimensional arrays, axis 0", function(done) {
				var x = context.linspace(1, 24, 24).reshape([2, 3, 4]);
				x.max(0).get(function(y) {
					expect(y).to.deep.equal([[ 13, 14, 15, 16],
					                         [ 17, 18, 19, 20],
					                         [ 21, 22, 23, 24]]);
					done();
				});
			});
			it("Correct result for 3-dimensional arrays, axis 1", function(done) {
				var x = context.linspace(1, 24, 24).reshape([2, 3, 4]);
				x.max(1).get(function(y) {
					expect(y).to.deep.equal([[  9, 10, 11, 12],
					                         [ 21, 22, 23, 24]]);
					done();
				});
			});
			it("Correct result for 3-dimensional arrays, axis 2", function(done) {
				var x = context.linspace(1, 24, 24).reshape([2, 3, 4]);
				x.max(2).get(function(y) {
					expect(y).to.deep.equal([[  4,  8, 12],
					                         [ 16, 20, 24]]);
					done();
				});
			});
		});
	});
	describe("sum", function() {
		describe("All elements", function() {
			it("Returns zero-dimensional array of length one", function() {
				var x = context.zeros([20, 30]);
				var y = x.sum();
				expect(y.shape).to.deep.equal([]);
				expect(y.length).to.equal(1);
				y.invalidate();
			});
			it("Computes the sum of all elements in an array", function(done) {
				var x = context.linspace(1, 100000, 100000).reshape([200, 500]);
				x.sum().get(function(y) {
					expect(y).to.equal(5000050000);
					done();
				});
			});
		});
		describe("Along an axis", function() {
			it("Correct shape for 3-dimensional arrays", function() {
				var x = context.linspace(1, 24, 24).reshape([2, 3, 4]).lock();
				expect(x.sum(0).shape).to.deep.equal([3, 4]);
				expect(x.sum(1).shape).to.deep.equal([2, 4]);
				expect(x.sum(2).shape).to.deep.equal([2, 3]);
				x.invalidate();
			});
			it("Correct result for 3-dimensional arrays, axis 0", function(done) {
				var x = context.linspace(1, 24, 24).reshape([2, 3, 4]);
				x.sum(0).get(function(y) {
					expect(y).to.deep.equal([[ 14, 16, 18, 20],
					                         [ 22, 24, 26, 28],
					                         [ 30, 32, 34, 36]]);
					done();
				});
			});
			it("Correct result for 3-dimensional arrays, axis 1", function(done) {
				var x = context.linspace(1, 24, 24).reshape([2, 3, 4]);
				x.sum(1).get(function(y) {
					expect(y).to.deep.equal([[ 15,  18,  21,  24],
					                         [ 51,  54,  57,  60]]);
					done();
				});
			});
			it("Correct result for 3-dimensional arrays, axis 2", function(done) {
				var x = context.linspace(1, 24, 24).reshape([2, 3, 4]);
				x.sum(2).get(function(y) {
					expect(y).to.deep.equal([[ 10,  26,  42],
					                         [ 58,  74,  90]]);
					done();
				});
			});
		});
	});
	describe("dot", function() {
		it("Correct shape for 2-dimensional arrays", function() {
			var x = context.empty([2, 5]);
			var y = context.empty([5, 11]);
			var z = context.dot(x, y);
			expect(z.shape).to.deep.equal([2, 11]);
			z.invalidate();
		});
		it("Correct shape for 3-dimensional arrays", function() {
			var x = context.empty([2, 3, 4]);
			var y = context.empty([7, 4, 8]);
			var z = context.dot(x, y);
			expect(z.shape).to.deep.equal([2, 3, 7, 8]);
			z.invalidate();
		});
		it("Correct shape for 4-dimensional arrays", function() {
			var x = context.empty([2, 3, 4, 5]);
			var y = context.empty([6, 7, 5, 8]);
			var z = context.dot(x, y);
			expect(z.shape).to.deep.equal([2, 3, 4, 6, 7, 8]);
			z.invalidate();
		});
		it("Correct value for 1-dimensional arrays", function(done) {
			var x = context.array([2, 5]);
			var y = context.array([5, 11]);
			context.dot(x, y).get(function(z) {
				expect(z).to.deep.equal(65);
				done();
			});
		});
		it("Correct value for 2-dimensional arrays", function(done) {
			var x = context.array([[64,  2,  3],
			                       [61, 60,  6]]);
			var y = context.array([[92, 99,  1,  8, 15],
			                       [67, 74, 51, 58, 40],
			                       [98, 80,  7, 14, 16]]);
			var z = context.dot(x, y);
			z.get(function(result) {
				expect(result).to.deep.equal([[  6316,  6724,  187,  670, 1088],
				                              [ 10220, 10959, 3163, 4052, 3411]]);
				done();
			});
		});
	});
});

},{"../lib/furious.js":6,"chai":14}]},{},[57,58,59])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkM6XFxQcm9qZWN0c1xcZnVyaW91cy5qc1xcbm9kZV9tb2R1bGVzXFxncnVudC1icm93c2VyaWZ5XFxub2RlX21vZHVsZXNcXGJyb3dzZXJpZnlcXG5vZGVfbW9kdWxlc1xcYnJvd3Nlci1wYWNrXFxfcHJlbHVkZS5qcyIsIkM6L1Byb2plY3RzL2Z1cmlvdXMuanMvbGliL0RhdGFUeXBlLmpzIiwiQzovUHJvamVjdHMvZnVyaW91cy5qcy9saWIvTkRBcnJheS5qcyIsIkM6L1Byb2plY3RzL2Z1cmlvdXMuanMvbGliL1BCQ29udGV4dC5qcyIsIkM6L1Byb2plY3RzL2Z1cmlvdXMuanMvbGliL1BOYUNsQ29udGV4dC5qcyIsIkM6L1Byb2plY3RzL2Z1cmlvdXMuanMvbGliL2FsbG9jYXRvci5qcyIsIkM6L1Byb2plY3RzL2Z1cmlvdXMuanMvbGliL2Z1cmlvdXMuanMiLCJDOi9Qcm9qZWN0cy9mdXJpb3VzLmpzL2xpYi9qcy9KU0NvbnRleHQuanMiLCJDOi9Qcm9qZWN0cy9mdXJpb3VzLmpzL2xpYi9qcy9XZWJXb3JrZXJDb250ZXh0LmpzIiwiQzovUHJvamVjdHMvZnVyaW91cy5qcy9saWIvanMvanNtYXRoLmpzIiwiQzovUHJvamVjdHMvZnVyaW91cy5qcy9saWIvcmVxdWVzdHMucGIuanMiLCJDOi9Qcm9qZWN0cy9mdXJpb3VzLmpzL2xpYi9yZXNwb25zZXMucGIuanMiLCJDOi9Qcm9qZWN0cy9mdXJpb3VzLmpzL2xpYi91dGlsLmpzIiwiQzovUHJvamVjdHMvZnVyaW91cy5qcy9saWIvd2ViY2wvV2ViQ0xDb250ZXh0LmpzIiwiQzovUHJvamVjdHMvZnVyaW91cy5qcy9ub2RlX21vZHVsZXMvY2hhaS9pbmRleC5qcyIsIkM6L1Byb2plY3RzL2Z1cmlvdXMuanMvbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkuanMiLCJDOi9Qcm9qZWN0cy9mdXJpb3VzLmpzL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL2Fzc2VydGlvbi5qcyIsIkM6L1Byb2plY3RzL2Z1cmlvdXMuanMvbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvY29uZmlnLmpzIiwiQzovUHJvamVjdHMvZnVyaW91cy5qcy9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS9jb3JlL2Fzc2VydGlvbnMuanMiLCJDOi9Qcm9qZWN0cy9mdXJpb3VzLmpzL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL2ludGVyZmFjZS9hc3NlcnQuanMiLCJDOi9Qcm9qZWN0cy9mdXJpb3VzLmpzL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL2ludGVyZmFjZS9leHBlY3QuanMiLCJDOi9Qcm9qZWN0cy9mdXJpb3VzLmpzL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL2ludGVyZmFjZS9zaG91bGQuanMiLCJDOi9Qcm9qZWN0cy9mdXJpb3VzLmpzL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL3V0aWxzL2FkZENoYWluYWJsZU1ldGhvZC5qcyIsIkM6L1Byb2plY3RzL2Z1cmlvdXMuanMvbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvYWRkTWV0aG9kLmpzIiwiQzovUHJvamVjdHMvZnVyaW91cy5qcy9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS91dGlscy9hZGRQcm9wZXJ0eS5qcyIsIkM6L1Byb2plY3RzL2Z1cmlvdXMuanMvbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvZmxhZy5qcyIsIkM6L1Byb2plY3RzL2Z1cmlvdXMuanMvbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvZ2V0QWN0dWFsLmpzIiwiQzovUHJvamVjdHMvZnVyaW91cy5qcy9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS91dGlscy9nZXRFbnVtZXJhYmxlUHJvcGVydGllcy5qcyIsIkM6L1Byb2plY3RzL2Z1cmlvdXMuanMvbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvZ2V0TWVzc2FnZS5qcyIsIkM6L1Byb2plY3RzL2Z1cmlvdXMuanMvbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvZ2V0TmFtZS5qcyIsIkM6L1Byb2plY3RzL2Z1cmlvdXMuanMvbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvZ2V0UGF0aFZhbHVlLmpzIiwiQzovUHJvamVjdHMvZnVyaW91cy5qcy9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS91dGlscy9nZXRQcm9wZXJ0aWVzLmpzIiwiQzovUHJvamVjdHMvZnVyaW91cy5qcy9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS91dGlscy9pbmRleC5qcyIsIkM6L1Byb2plY3RzL2Z1cmlvdXMuanMvbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvaW5zcGVjdC5qcyIsIkM6L1Byb2plY3RzL2Z1cmlvdXMuanMvbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvb2JqRGlzcGxheS5qcyIsIkM6L1Byb2plY3RzL2Z1cmlvdXMuanMvbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvb3ZlcndyaXRlQ2hhaW5hYmxlTWV0aG9kLmpzIiwiQzovUHJvamVjdHMvZnVyaW91cy5qcy9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS91dGlscy9vdmVyd3JpdGVNZXRob2QuanMiLCJDOi9Qcm9qZWN0cy9mdXJpb3VzLmpzL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL3V0aWxzL292ZXJ3cml0ZVByb3BlcnR5LmpzIiwiQzovUHJvamVjdHMvZnVyaW91cy5qcy9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS91dGlscy90ZXN0LmpzIiwiQzovUHJvamVjdHMvZnVyaW91cy5qcy9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS91dGlscy90cmFuc2ZlckZsYWdzLmpzIiwiQzovUHJvamVjdHMvZnVyaW91cy5qcy9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS91dGlscy90eXBlLmpzIiwiQzovUHJvamVjdHMvZnVyaW91cy5qcy9ub2RlX21vZHVsZXMvY2hhaS9ub2RlX21vZHVsZXMvYXNzZXJ0aW9uLWVycm9yL2luZGV4LmpzIiwiQzovUHJvamVjdHMvZnVyaW91cy5qcy9ub2RlX21vZHVsZXMvY2hhaS9ub2RlX21vZHVsZXMvZGVlcC1lcWwvaW5kZXguanMiLCJDOi9Qcm9qZWN0cy9mdXJpb3VzLmpzL25vZGVfbW9kdWxlcy9jaGFpL25vZGVfbW9kdWxlcy9kZWVwLWVxbC9saWIvZXFsLmpzIiwiQzovUHJvamVjdHMvZnVyaW91cy5qcy9ub2RlX21vZHVsZXMvY2hhaS9ub2RlX21vZHVsZXMvZGVlcC1lcWwvbm9kZV9tb2R1bGVzL3R5cGUtZGV0ZWN0L2luZGV4LmpzIiwiQzovUHJvamVjdHMvZnVyaW91cy5qcy9ub2RlX21vZHVsZXMvY2hhaS9ub2RlX21vZHVsZXMvZGVlcC1lcWwvbm9kZV9tb2R1bGVzL3R5cGUtZGV0ZWN0L2xpYi90eXBlLmpzIiwiQzovUHJvamVjdHMvZnVyaW91cy5qcy9ub2RlX21vZHVsZXMvZ3J1bnQtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9saWIvX2VtcHR5LmpzIiwiQzovUHJvamVjdHMvZnVyaW91cy5qcy9ub2RlX21vZHVsZXMvZ3J1bnQtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnVmZmVyL2luZGV4LmpzIiwiQzovUHJvamVjdHMvZnVyaW91cy5qcy9ub2RlX21vZHVsZXMvZ3J1bnQtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnVmZmVyL25vZGVfbW9kdWxlcy9iYXNlNjQtanMvbGliL2I2NC5qcyIsIkM6L1Byb2plY3RzL2Z1cmlvdXMuanMvbm9kZV9tb2R1bGVzL2dydW50LWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2J1ZmZlci9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIsIkM6L1Byb2plY3RzL2Z1cmlvdXMuanMvbm9kZV9tb2R1bGVzL2dydW50LWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3BhdGgtYnJvd3NlcmlmeS9pbmRleC5qcyIsIkM6L1Byb2plY3RzL2Z1cmlvdXMuanMvbm9kZV9tb2R1bGVzL2dydW50LWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIkM6L1Byb2plY3RzL2Z1cmlvdXMuanMvbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvZGlzdC9Qcm90b0J1Zi5qcyIsIkM6L1Byb2plY3RzL2Z1cmlvdXMuanMvbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvaW5kZXguanMiLCJDOi9Qcm9qZWN0cy9mdXJpb3VzLmpzL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL25vZGVfbW9kdWxlcy9ieXRlYnVmZmVyL2Rpc3QvQnl0ZUJ1ZmZlckFCLm1pbi5qcyIsIkM6L1Byb2plY3RzL2Z1cmlvdXMuanMvbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvbm9kZV9tb2R1bGVzL2J5dGVidWZmZXIvbm9kZV9tb2R1bGVzL2xvbmcvZGlzdC9Mb25nLmpzIiwiQzovUHJvamVjdHMvZnVyaW91cy5qcy9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9ub2RlX21vZHVsZXMvYnl0ZWJ1ZmZlci9ub2RlX21vZHVsZXMvbG9uZy9pbmRleC5qcyIsIkM6L1Byb2plY3RzL2Z1cmlvdXMuanMvdGVzdC9Db250ZXh0LnRlc3QuanMiLCJDOi9Qcm9qZWN0cy9mdXJpb3VzLmpzL3Rlc3QvRGF0YVR5cGUudGVzdC5qcyIsIkM6L1Byb2plY3RzL2Z1cmlvdXMuanMvdGVzdC9OREFycmF5LnRlc3QuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3J5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3haQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbGZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3psQ0E7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNseUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hpQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9HQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaFVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3REQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5R0E7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDalFBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5SUE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3NUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdDdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3Rocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIil9dmFyIGY9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGYuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sZixmLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxuLyoqXHJcbiAqIEEgbnVtZXJpY2FsIGRhdGEgdHlwZSBvYmplY3QuXHJcbiAqXHJcbiAqIEBjbGFzcyBEYXRhVHlwZVxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgLSB0aGUgYWJicmV2aWF0ZWQgbmFtZSBvZiB0aGUgZGF0YSB0eXBlLiBUaGUgZm9sbG93aW5nIG5hbWVzIGFyZSBzdXBwb3J0ZWQ6XHJcbiAqXHJcbiAqICAgICA8dGFibGU+XHJcbiAqICAgICAgICAgPHRyPlxyXG4gKiAgICAgICAgICAgICA8dGg+QWJicmV2aWF0ZWQgTmFtZTwvdGg+XHJcbiAqICAgICAgICAgICAgIDx0aD5JbnRlcnByZXRhdGlvbjwvdGg+XHJcbiAqICAgICAgICAgPC90cj5cclxuICogICAgICAgICA8dHI+XHJcbiAqICAgICAgICAgICAgIDx0ZD5cImYzMlwiPC90ZD5cclxuICogICAgICAgICAgICAgPHRkPlNpbmdsZS1wcmVjaXNpb24gKDMyLWJpdCkgSUVFRS03NTQgZmxvYXRpbmctcG9pbnQgdHlwZS48L3RkPlxyXG4gKiAgICAgICAgIDwvdHI+XHJcbiAqICAgICAgICAgPHRyPlxyXG4gKiAgICAgICAgICAgICA8dGQ+XCJmNjRcIjwvdGQ+XHJcbiAqICAgICAgICAgICAgIDx0ZD5Eb3VibGUtcHJlY2lzaW9uICg2NC1iaXQpIElFRUUtNzU0IGZsb2F0aW5nLXBvaW50IHR5cGUuPC90ZD5cclxuICogICAgICAgICA8L3RyPlxyXG4gKiAgICAgPC90YWJsZT5cclxuICpcclxuICovXHJcbmZ1bmN0aW9uIERhdGFUeXBlKHR5cGUpIHtcclxuXHRpZiAoW1wiZjMyXCIsIFwiZjY0XCJdLmluZGV4T2YodHlwZSkgPj0gMCkge1xyXG5cdFx0dGhpcy50eXBlID0gdHlwZTtcclxuXHRcdHRoaXMuc2l6ZSA9IHtcImYzMlwiOiA0LCBcImY2NFwiOiA4fVt0eXBlXTtcclxuXHRcdHRoaXMuZXBzaWxvbiA9IHtcImYzMlwiOiAxLjE5MjA5Mjg5NTUwNzgxMjVlLTcsIFwiZjY0XCI6IDIuMjIwNDQ2MDQ5MjUwMzEzMWUtMTZ9W3R5cGVdO1xyXG5cdFx0dGhpcy5hcnJheVR5cGUgPSB7XCJmMzJcIjogRmxvYXQzMkFycmF5LCBcImY2NFwiOiBGbG9hdDY0QXJyYXl9W3R5cGVdO1xyXG5cdH0gZWxzZSB7XHJcblx0XHR0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlR5cGUgXCIgKyB0eXBlICsgXCIgaXMgbm90IHN1cHBvcnRlZFwiKTtcclxuXHR9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDb21wYXJlcyB0d28gZGF0YSB0eXBlIG9iamVjdHMgZm9yIGVxdWFsaXR5LlxyXG4gKlxyXG4gKiBAbWV0aG9kIGVxdWFsc1xyXG4gKiBAcGFyYW0ge2FueX0gb3RoZXIgLSBhbiBvYmplY3QgdG8gY29tcGFyZSB0by5cclxuICovXHJcbkRhdGFUeXBlLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbihvdGhlcikge1xyXG5cdHJldHVybiAob3RoZXIgaW5zdGFuY2VvZiBEYXRhVHlwZSkgJiYgKHRoaXMuYXJyYXlUeXBlID09PSBvdGhlci5hcnJheVR5cGUpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBEYXRhVHlwZTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XHJcbnZhciBEYXRhVHlwZSA9IHJlcXVpcmUoXCIuL0RhdGFUeXBlXCIpO1xyXG5cclxuLyoqXHJcbiAqIEFuIG9wYXF1ZSBOLWRpbWVuc2lvbmFsIGFycmF5IG9iamVjdC5cclxuICpcclxuICogQGNsYXNzIE5EQXJyYXlcclxuICovXHJcblxyXG4vKipcclxuICogQ29uc3RydWN0cyBhbiBOREFycmF5IG9iamVjdCB3aXRob3V0IGRhdGEuXHJcbiAqIE5vcm1hbGx5IHRoaXMgY29uc3RydWN0b3IgaXMgY2FsbGVkIGZyb20gYXJyYXkgY29uc3RydWN0aW9uIG1ldGhvZHMgb2YgY29tcHV0YXRpb25hbCBjb250ZXh0cy5cclxuICogVGhlIGNhbGxpbmcgZnVuY3Rpb24gaXMgcmVzcG9uc2libGUgZm9yIGluaXRpYWxpemluZyB0aGUgZGF0YSBmb3IgdGhlIGFycmF5LlxyXG4gKlxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIE5EQXJyYXkoc2hhcGUsIGRhdGFUeXBlLCBjb250ZXh0KSB7XHJcblx0aWYgKHR5cGVvZiBjb250ZXh0ID09PSBcInVuZGVmaW5lZFwiKSB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJDb250ZXh0IG5vdCBkZWZpbmVkXCIpO1xyXG5cdH1cclxuXHRpZiAoIXV0aWwuaXNQb3NpdGl2ZUludEFycmF5KHNoYXBlKSAmJiAhdXRpbC5pc1Bvc2l0aXZlSW50KHNoYXBlKSkge1xyXG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihzaGFwZSArIFwiIGlzIG5vdCBhIHZhbGlkIGFycmF5IHNoYXBlXCIpO1xyXG5cdH1cclxuXHRpZiAodHlwZW9mIGRhdGFUeXBlID09PSBcInVuZGVmaW5lZFwiKSB7XHJcblx0XHRkYXRhVHlwZSA9IG5ldyBEYXRhVHlwZShcImY2NFwiKTtcclxuXHR9IGVsc2UgaWYgKCEoZGF0YVR5cGUgaW5zdGFuY2VvZiBEYXRhVHlwZSkpIHtcclxuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoZGF0YVR5cGUgKyBcIiBpcyBub3QgYW4gaW5zdGFuY2Ugb2YgRGF0YVR5cGVcIik7XHJcblx0fVxyXG5cdHRoaXMuc2hhcGUgPSBzaGFwZTtcclxuXHR0aGlzLmRhdGFUeXBlID0gZGF0YVR5cGU7XHJcblx0dGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XHJcblx0dGhpcy5sZW5ndGggPSB1dGlsLmNvbXB1dGVMZW5ndGgodGhpcy5zaGFwZSk7XHJcblx0dGhpcy5fbG9ja0NvdW50ID0gMDtcclxuXHR0aGlzLl9yZWZDb3VudCA9IDE7XHJcblx0dGhpcy5faXNWYWxpZCA9IHRydWU7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBMb2NrcyB0aGUgYXJyYXkgcmVmZXJlbmNlIGNvdW50ZXIuXHJcbiAqIFdoaWxlIHRoZSBhcnJheSBpcyBsb2NrZWQsIGZ1bmN0aW9ucyBhbmQgbWV0aG9kcyB0aGF0IG9wZXJhdGUgb24gdGhpcyBhcnJheSBkbyBub3QgZGVjcmVhc2UgaXRzIHJlZmVyZW5jZSBjb3VudC5cclxuICogVGhlIGFycmF5IGNhbiBiZSBsb2NrZWQgbXVsdGlwbGUgdGltZXMsIGFuZCB3b3VsZCBuZWVkIGp1c3QgYXMgbWFueSB1bmxvY2sgY2FsbHMgdG8gbGlmdCB0aGUgbG9jay5cclxuICogSWYgdGhlIGFycmF5IGlzIG5vdCB2YWxpZCwgdGhpcyBvcGVyYXRpb24gd2lsbCBmYWlsIHdpdGggYW4gZXJyb3IuXHJcbiAqXHJcbiAqIEBtZXRob2QgbG9ja1xyXG4gKiBAY2hhaW5hYmxlXHJcbiAqL1xyXG5OREFycmF5LnByb3RvdHlwZS5sb2NrID0gZnVuY3Rpb24oKSB7XHJcblx0aWYgKCF0aGlzLmlzVmFsaWQoKSkge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiQXR0ZW1wdGVkIHRvIGxvY2sgYW4gaW52YWxpZGF0ZWQgYXJyYXlcIik7XHJcblx0fVxyXG5cdHRoaXMuX2xvY2tDb3VudCsrO1xyXG5cdHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFVubG9ja3MgdGhlIGFycmF5IHJlZmVyZW5jZSBjb3VudGVyLlxyXG4gKiBPbmNlIHRoZSBhcnJheSBpcyB1bmxvY2tlZCwgZnVuY3Rpb25zIGFuZCBtZXRob2RzIHRoYXQgb3BlcmF0ZSBvbiB0aGlzIGFycmF5IGRlY3JlYXNlIGl0cyByZWZlcmVuY2UgY291bnQgYW5kLCBpZiB0aGUgcmVmZXJlbmNlIGNvdW50IHJlYWNoZXMgemVybywgaW52YWxpZGF0ZSB0aGUgYXJyYXkuXHJcbiAqIElmIHRoZSBhcnJheSB3YXMgbG9ja2VkIG11bHRpcGxlIHRpbWVzLCBpdCB3b3VsZCBuZWVkIGp1c3QgYXMgbWFueSB1bmxvY2sgY2FsbHMgdG8gbGlmdCB0aGUgbG9jay5cclxuICogSWYgdGhlIGFycmF5IGlzIG5vdCBsb2NrZWQsIHRoaXMgb3BlcmF0aW9uIHdpbGwgZmFpbCB3aXRoIGFuIGVycm9yLlxyXG4gKlxyXG4gKiBAbWV0aG9kIHVubG9ja1xyXG4gKiBAY2hhaW5hYmxlXHJcbiAqL1xyXG5OREFycmF5LnByb3RvdHlwZS51bmxvY2sgPSBmdW5jdGlvbigpIHtcclxuXHRpZiAoIXRoaXMuaXNMb2NrZWQoKSkge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiQXR0ZW1wdGVkIHRvIGxvY2sgYSB1bmxvY2tlZCBhcnJheVwiKTtcclxuXHR9XHJcblx0dGhpcy5fbG9ja0NvdW50LS07XHJcblx0cmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogQ2hlY2tlcyBpZiB0aGUgYXJyYXkgaXMgaW4gdGhlIGxvY2tlZCBzdGF0ZS5cclxuICogSWYgdGhlIGFycmF5IGlzIG5vdCB2YWxpZCwgdGhpcyBtZXRob2QgcmV0dXJuIGZhbHNlLlxyXG4gKlxyXG4gKiBAbWV0aG9kIGlzTG9ja2VkXHJcbiAqXHJcbiAqIEByZXR1cm4ge0Jvb2xlYW59IC0gdHJ1ZSBpcyB0aGUgYXJyYXkgaXMgbG9ja2VkIGFuZCBmYWxzZSBvdGhlcndpc2VcclxuICovXHJcbk5EQXJyYXkucHJvdG90eXBlLmlzTG9ja2VkID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXMuX2xvY2tDb3VudCA+IDA7XHJcbn07XHJcblxyXG4vKipcclxuICogSW5jcmVtZW50cyB0aGUgYXJyYXkgcmVmZXJlbmNlIGNvdW50LlxyXG4gKiBJZiB0aGUgYXJyYXkgaXMgaW52YWxpZCBvciBsb2NrZWQsIHRoaXMgb3BlcmF0aW9uIHdpbGwgZmFpbCB3aXRoIGFuIGVycm9yLlxyXG4gKlxyXG4gKiBAbWV0aG9kIHJldGFpblxyXG4gKiBAY2hhaW5hYmxlXHJcbiAqL1xyXG5OREFycmF5LnByb3RvdHlwZS5yZXRhaW4gPSBmdW5jdGlvbigpIHtcclxuXHRpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJBdHRlbXB0ZWQgdG8gcmVsZWFzZSBhbiBpbnZhbGlkYXRlZCBhcnJheVwiKTtcclxuXHR9XHJcblx0aWYgKHRoaXMuaXNMb2NrZWQoKSkge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiQXR0ZW1wdGVkIHRvIHJldGFpbiBhIGxvY2tlZCBhcnJheVwiKTtcclxuXHR9XHJcblx0dGhpcy5fcmVmQ291bnQrKztcclxuXHRyZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBEZWNyZW1lbnRzIHRoZSBhcnJheSByZWZlcmVuY2UgY291bnQuIElmIHRoZSByZWZlcmVuY2UgY291bnQgdHVybnMgemVybywgdGhlIGFycmF5IGJlY29tZXMgaW52YWxpZCBhbmQgaXRzIGRhdGEgYnVmZmVyIGlzIGRlYWxsb2NhdGVkLlxyXG4gKiBJZiB0aGUgYXJyYXkgaXMgaW52YWxpZCBvciBsb2NrZWQsIHRoaXMgb3BlcmF0aW9uIHdpbGwgZmFpbCB3aXRoIGFuIGVycm9yLlxyXG4gKlxyXG4gKiBAbWV0aG9kIHJlbGVhc2VcclxuICogQGNoYWluYWJsZVxyXG4gKi9cclxuTkRBcnJheS5wcm90b3R5cGUucmVsZWFzZSA9IGZ1bmN0aW9uKCkge1xyXG5cdGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcihcIkF0dGVtcHRlZCB0byByZWxlYXNlIGFuIGludmFsaWRhdGVkIGFycmF5XCIpO1xyXG5cdH1cclxuXHRpZiAodGhpcy5pc0xvY2tlZCgpKSB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJBdHRlbXB0ZWQgdG8gcmVsZWFzZSBhIGxvY2tlZCBhcnJheVwiKTtcclxuXHR9XHJcblx0aWYgKC0tdGhpcy5fcmVmQ291bnQgPT09IDApIHtcclxuXHRcdHRoaXMuX2NvbnRleHQuX2ludmFsaWRhdGUodGhpcyk7XHJcblx0fVxyXG5cdHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEZvciBhIG5vbi1sb2NrZWQgYXJyYXksIGRlY3JlbWVudHMgdGhlIGFycmF5IHJlZmVyZW5jZSBjb3VudC4gSWYgdGhlIHJlZmVyZW5jZSBjb3VudCB0dXJucyB6ZXJvLCB0aGUgYXJyYXkgYmVjb21lcyBpbnZhbGlkIGFuZCBpdHMgZGF0YSBidWZmZXIgaXMgZGVhbGxvY2F0ZWQuXHJcbiAqIElmIHRoZSBhcnJheSBpcyBpbnZhbGlkLCB0aGlzIG9wZXJhdGlvbiB3aWxsIGZhaWwgd2l0aCBhbiBlcnJvci5cclxuICpcclxuICogQG1ldGhvZCB0cnlSZWxlYXNlXHJcbiAqIEBjaGFpbmFibGVcclxuICovXHJcbk5EQXJyYXkucHJvdG90eXBlLnRyeVJlbGVhc2UgPSBmdW5jdGlvbigpIHtcclxuXHRpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJBdHRlbXB0ZWQgdG8gcmVsZWFzZSBhbiBpbnZhbGlkYXRlZCBhcnJheVwiKTtcclxuXHR9XHJcblx0aWYgKCF0aGlzLmlzTG9ja2VkKCkpIHtcclxuXHRcdGlmICgtLXRoaXMuX3JlZkNvdW50ID09PSAwKSB7XHJcblx0XHRcdHRoaXMuX2NvbnRleHQuX2ludmFsaWRhdGUodGhpcyk7XHJcblx0XHR9XHJcblx0fVxyXG5cdHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEZvciBhIG5vbi1sb2NrZWQgYXJyYXksIGRlY3JlbWVudHMgdGhlIGFycmF5IHJlZmVyZW5jZSBjb3VudC4gSWYgdGhlIHJlZmVyZW5jZSBjb3VudCB0dXJucyB6ZXJvLCB0aGUgYXJyYXkgYmVjb21lcyBpbnZhbGlkIGFuZCBpdHMgZGF0YSBidWZmZXIgaXMgZGVhbGxvY2F0ZWQuXHJcbiAqIFRoZSBhcnJheSBtdXN0IGJlIHZhbGlkIHRvIHBlcmZvcm0gdGhpcyBvcGVyYXRpb24uXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBtZXRob2QgX3RyeVJlbGVhc2VcclxuICogQGNoYWluYWJsZVxyXG4gKi9cclxuTkRBcnJheS5wcm90b3R5cGUuX3RyeVJlbGVhc2UgPSBmdW5jdGlvbigpIHtcclxuXHRpZiAoIXRoaXMuaXNMb2NrZWQoKSkge1xyXG5cdFx0aWYgKC0tdGhpcy5fcmVmQ291bnQgPT09IDApIHtcclxuXHRcdFx0dGhpcy5fY29udGV4dC5faW52YWxpZGF0ZSh0aGlzKTtcclxuXHRcdH1cclxuXHR9XHJcblx0cmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogSW52YWxpZGF0ZXMgdGhlIGFycmF5IGFuZCBkZWFsbG9jYXRlcyBpdHMgZGF0YSBidWZmZXIsIHJlZ2FyZGxlc3Mgb2YgbG9ja3MgYW5kIHJlZmVyZW5jZSBjb3VudC5cclxuICogQ2FsbGluZyB0aGlzIG1ldGhvZCBvbiBhbiBpbnZhbGlkYXRlZCBhcnJheSBoYXMgbm8gZWZmZWN0LlxyXG4gKlxyXG4gKiBAbWV0aG9kIGludmFsaWRhdGVcclxuICogQGNoYWluYWJsZVxyXG4gKi9cclxuTkRBcnJheS5wcm90b3R5cGUuaW52YWxpZGF0ZSA9IGZ1bmN0aW9uKCkge1xyXG5cdGlmICh0aGlzLmlzVmFsaWQoKSkge1xyXG5cdFx0dGhpcy5fY29udGV4dC5faW52YWxpZGF0ZSh0aGlzKTtcclxuXHRcdHRoaXMuX2lzVmFsaWQgPSBmYWxzZTtcclxuXHRcdHRoaXMuX3JlZkNvdW50ID0gMDtcclxuXHRcdHRoaXMuX2xvY2tDb3VudCA9IDA7XHJcblx0fVxyXG5cdHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENoZWNrZXMgaWYgdGhlIGFycmF5IGlzIGluIGEgdmFsaWQgc3RhdGUuXHJcbiAqIElmIHRoZSBhcnJheSBpcyBub3QgaW4gYSB2YWxpZCBzdGF0ZSwgaXRzIGRhdGEgYnVmZmVyIHdhcyBkZWFsbG9jYXRlZCwgYW5kIGFueSBvcGVyYXRpb25zIG9uIHRoZSBhcnJheSB3aWxsIHRocm93IGFuIGVycm9yLlxyXG4gKlxyXG4gKiBAbWV0aG9kIGlzVmFsaWRcclxuICpcclxuICogQHJldHVybiB7Qm9vbGVhbn0gLSB0cnVlIGlzIHRoZSBhcnJheSBpcyB2YWxpZCBhbmQgZmFsc2Ugb3RoZXJ3aXNlXHJcbiAqL1xyXG5OREFycmF5LnByb3RvdHlwZS5pc1ZhbGlkID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXMuX2lzVmFsaWQ7XHJcbn07XHJcblxyXG4vKipcclxuICogRGVjcmVtZW50cyB0aGUgYXJyYXkgcmVmZXJlbmNlIGNvdW50IGlmIHRoZSBhcnJheSBpcyBub3QgbG9ja2VkLlxyXG4gKiBUaGlzIGZ1bmN0aW9uIGRvZXMgbm90IGludmFsaWRhdGUgdGhlIGFycmF5IHdoZW4gdGhlIHJlZmVyZW5jZSBjb3VudCByZWFjaCB6ZXJvLlxyXG4gKiBUaGUgY2FsbGVyIGlzIHJlc3BvbnNpYmxlIGZvciBpbnZhbGlkYXRpbmcgYXJyYXkgaWYgaXRzIHJlZmVyZW5jZSBjb3VudCBpcyB6ZXJvIGFmdGVyIHRoZSBvcGVyYXRpb24uXHJcbiAqXHJcbiAqIEZvciBhIGxvY2tlZCBhcnJheSB0aGUgbWV0aG9kIGhhcyBubyBlZmZlY3QgYW5kIGFsd2F5cyByZXR1cm5zIHRydWUuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBtZXRob2QgX2RlY1JlZlxyXG4gKiBAcGFyYW0ge05EQXJyYXl9IGFycmF5IC0gdGhlIGFycmF5IHRvIGRlY3JlbWVudCB0aGUgcmVmZXJlbmNlIGNvdW50IGZvci4gTXVzdCBiZSB2YWxpZCBiZWZvcmUgdGhlIGNhbGwuXHJcbiAqIEByZXR1cm4ge0Jvb2xlYW59IC0gdHJ1ZSBpZiB0aGUgcmVmZXJlbmNlIGNvdW50IGlzIG5vbi16ZXJvIGFmdGVyIHRoZSBvcGVyYXRpb24gYW5kIGZhbHNlIG90aGVyd2lzZS5cclxuICovXHJcbk5EQXJyYXkucHJvdG90eXBlLl9kZWNSZWYgPSBmdW5jdGlvbihhcnJheSkge1xyXG5cdGlmICh0aGlzLl9sb2NrQ291bnQgPT09IDApIHtcclxuXHRcdC0tdGhpcy5fcmVmQ291bnQ7XHJcblx0fVxyXG5cdHJldHVybiB0aGlzLl9yZWZDb3VudCAhPT0gMDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBJbmNyZW1lbnRzIHRoZSBhcnJheSByZWZlcmVuY2UgY291bnQgaWYgdGhlIGFycmF5IGlzIG5vdCBsb2NrZWQuXHJcbiAqIEZvciBhIGxvY2tlZCBhcnJheSB0aGUgbWV0aG9kIGhhcyBubyBlZmZlY3QuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBtZXRob2QgX2luY1JlZlxyXG4gKiBAY2hhaW5hYmxlXHJcbiAqIEBwYXJhbSB7TkRBcnJheX0gYXJyYXkgLSB0aGUgYXJyYXkgdG8gaW5jcmVtZW50IHRoZSByZWZlcmVuY2UgY291bnQgZm9yLiBNdXN0IGJlIHZhbGlkIGJlZm9yZSB0aGUgY2FsbCwgYnV0IG1heSBoYXZlIHplcm8gcmVmZXJlbmNlIGNvdW50LlxyXG4gKi9cclxuTkRBcnJheS5wcm90b3R5cGUuX2luY1JlZiA9IGZ1bmN0aW9uKGFycmF5KSB7XHJcblx0aWYgKHRoaXMuX2xvY2tDb3VudCA9PT0gMCkge1xyXG5cdFx0Kyt0aGlzLl9yZWZDb3VudDtcclxuXHR9XHJcblx0cmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogQ2hlY2tzIGlmIHRoZSBhcnJheSBpcyBsb2NrZWQgb3IgaGFzIGFueSByZWZlcmVuY2VzLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAbWV0aG9kIF9oYXNSZWZzXHJcbiAqIEBwYXJhbSB7TkRBcnJheX0gYXJyYXkgLSB0aGUgYXJyYXkgdG8gY2hlY2suIE11c3QgYmUgdmFsaWQgYmVmb3JlIHRoZSBjYWxsLCBidXQgbWF5IGhhdmUgemVybyByZWZlcmVuY2UgY291bnQuXHJcbiAqIEByZXR1cm4ge0Jvb2xlYW59IC0gdHJ1ZSBpZiB0aGUgYXJyYXkgaXMgbG9ja2VkIG9yIGhhcyByZWZlcmVuY2VzIGFuZCBmYWxzZSBvdGhlcndpc2UuXHJcbiAqL1xyXG5OREFycmF5LnByb3RvdHlwZS5faGFzUmVmcyA9IGZ1bmN0aW9uKGFycmF5KSB7XHJcblx0cmV0dXJuICh0aGlzLl9sb2NrQ291bnQgIT09IDApIHx8ICh0aGlzLl9yZWZDb3VudCAhPT0gMCk7XHJcbn07XHJcblxyXG4vKipcclxuICogSW52YWxpZGF0ZXMgdGhlIGFycmF5IGlmIGl0IHZhbGlkLCBub3QgbG9ja2VkLCBhbmQgaGFzIHplcm8gcmVmZXJlbmNlIGNvdW50LlxyXG4gKiBIYXMgbm8gZWZmZWN0IGluIGFsbCBvdGhlciBjYXNlcy5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQG1ldGhvZCBfdHJ5SW52YWxpZGF0ZVxyXG4gKiBAcGFyYW0ge05EQXJyYXl9IGFycmF5IC0gdGhlIGFycmF5IHRvIHRyeSB0byBpbnZhbGlkYXRlLiBDYW4gYmUgaW52YWxpZC5cclxuICogQHJldHVybiB7Qm9vbGVhbn0gLSB0cnVlIGlmIHRoZSBhcnJheSB3YXMgaW52YWxpZGF0ZWQgYnkgdGhpcyBjYWxsIGFuZCBmYWxzZSBvdGhlcndpc2UuXHJcbiAqL1xyXG5OREFycmF5LnByb3RvdHlwZS5fdHJ5SW52YWxpZGF0ZSA9IGZ1bmN0aW9uKGFycmF5KSB7XHJcblx0aWYgKHRoaXMuaXNWYWxpZCgpICYmICF0aGlzLl9oYXNSZWZzKCkpIHtcclxuXHRcdHRoaXMuX2NvbnRleHQuX2ludmFsaWRhdGUodGhpcyk7XHJcblx0XHR0aGlzLl9pc1ZhbGlkID0gZmFsc2U7XHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBBZGRzIGFub3RoZXIgYXJyYXkgb3IgYSBudW1iZXIgdG8gdGhpcyBhcnJheS5cclxuICpcclxuICogQG1ldGhvZCBhZGRcclxuICogQHBhcmFtIHsoTkRBcnJheXxOdW1iZXIpfSBvdGhlciAtIHRoZSBhcnJheSBvciBzY2FsYXIgdG8gYmUgYWRkZWQuXHJcbiAqIEByZXR1cm4ge05EQXJyYXl9XHJcbiAqL1xyXG5OREFycmF5LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihvdGhlcikge1xyXG5cdHJldHVybiB0aGlzLl9jb250ZXh0LmFkZCh0aGlzLCBvdGhlcik7XHJcbn07XHJcblxyXG4vKipcclxuICogU3VidHJhY3RzIGFub3RoZXIgYXJyYXkgb3IgYSBudW1iZXIgZnJvbSB0aGlzIGFycmF5LlxyXG4gKlxyXG4gKiBAbWV0aG9kIHN1YlxyXG4gKiBAcGFyYW0geyhOREFycmF5fE51bWJlcil9IG90aGVyIC0gdGhlIGFycmF5IG9yIHNjYWxhciB0byBiZSBzdWJ0cmFjdGVkLlxyXG4gKiBAcmV0dXJuIHtOREFycmF5fVxyXG4gKi9cclxuTkRBcnJheS5wcm90b3R5cGUuc3ViID0gZnVuY3Rpb24ob3RoZXIpIHtcclxuXHRyZXR1cm4gdGhpcy5fY29udGV4dC5zdWIodGhpcywgb3RoZXIpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIE11bHRpcGxpZXMgYXJyYXkgZWxlbWVudHMgYnkgYW5vdGhlciBhcnJheSBvciBieSBhIG51bWJlci5cclxuICpcclxuICogQG1ldGhvZCBtdWxcclxuICogQHBhcmFtIHsoTkRBcnJheXxOdW1iZXIpfSBvdGhlciAtIHRoZSBhcnJheSBvciBzY2FsYXIgdG8gbXVsdGlwbHkgZWxlbWVudHMgYnkuXHJcbiAqIEByZXR1cm4ge05EQXJyYXl9XHJcbiAqL1xyXG5OREFycmF5LnByb3RvdHlwZS5tdWwgPSBmdW5jdGlvbihvdGhlcikge1xyXG5cdHJldHVybiB0aGlzLl9jb250ZXh0Lm11bCh0aGlzLCBvdGhlcik7XHJcbn07XHJcblxyXG4vKipcclxuICogRGl2aWRlcyBhcnJheSBlbGVtZW50cyBieSBhbm90aGVyIGFycmF5IG9yIGJ5IGEgbnVtYmVyLlxyXG4gKlxyXG4gKiBAbWV0aG9kIGRpdlxyXG4gKiBAcGFyYW0geyhOREFycmF5fE51bWJlcil9IG90aGVyIC0gdGhlIGFycmF5IG9yIHNjYWxhciB0byBkaXZpZGUgZWxlbWVudHMgYnkuXHJcbiAqIEByZXR1cm4ge05EQXJyYXl9XHJcbiAqL1xyXG5OREFycmF5LnByb3RvdHlwZS5kaXYgPSBmdW5jdGlvbihvdGhlcikge1xyXG5cdHJldHVybiB0aGlzLl9jb250ZXh0LmRpdih0aGlzLCBvdGhlcik7XHJcbn07XHJcblxyXG4vKipcclxuICogUmVkdWNlcyBhcnJheSBlbGVtZW50cyB1c2luZyBtaW5pbXVtIG9wZXJhdGlvbi5cclxuICogSWYgdGhlIGF4aXMgYXJndW1lbnQgaXMgcHJvdmlkZWQsIHRoZSBtZXRob2QgY29tcHV0ZXMgbWluaW11bSBvZiBlbGVtZW50cyBhbG9uZyB0aGUgc3BlY2lmaWVkIGF4aXMuXHJcbiAqIE90aGVyd2lzZSwgdGhlIG1ldGhvZCBjb21wdXRlcyBhbiBhbGwtYXJyYXkgbWluaW11bSBvZiB0aGUgZWxlbWVudHMgYW5kIHJldHVybnMgdGhlbSBhcyBhIDEtZWxlbWVudCBhcnJheS5cclxuICpcclxuICogQG1ldGhvZCBtaW5cclxuICogQHBhcmFtIHtOdW1iZXJ9IFtheGlzXSAtIHRoZSBheGlzIGFsb25nIHdoaWNoIHRoZSBtaW5pbXVtIGlzIGNvbXB1dGVkLlxyXG4gKiBAcmV0dXJuIHtOREFycmF5fVxyXG4gKi9cclxuTkRBcnJheS5wcm90b3R5cGUubWluID0gZnVuY3Rpb24oYXhpcykge1xyXG5cdHJldHVybiB0aGlzLl9jb250ZXh0Lm1pbih0aGlzLCBheGlzKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZWR1Y2VzIGFycmF5IGVsZW1lbnRzIHVzaW5nIG1heGltdW0gb3BlcmF0aW9uLlxyXG4gKiBJZiB0aGUgYXhpcyBhcmd1bWVudCBpcyBwcm92aWRlZCwgdGhlIG1ldGhvZCBjb21wdXRlcyBtYXhpbXVtIG9mIGVsZW1lbnRzIGFsb25nIHRoZSBzcGVjaWZpZWQgYXhpcy5cclxuICogT3RoZXJ3aXNlLCB0aGUgbWV0aG9kIGNvbXB1dGVzIGFuIGFsbC1hcnJheSBtYXhpbXVtIG9mIHRoZSBlbGVtZW50cyBhbmQgcmV0dXJucyB0aGVtIGFzIGEgMS1lbGVtZW50IGFycmF5LlxyXG4gKlxyXG4gKiBAbWV0aG9kIG1pblxyXG4gKiBAcGFyYW0ge051bWJlcn0gW2F4aXNdIC0gdGhlIGF4aXMgYWxvbmcgd2hpY2ggdGhlIG1heGltdW0gaXMgY29tcHV0ZWQuXHJcbiAqIEByZXR1cm4ge05EQXJyYXl9XHJcbiAqL1xyXG5OREFycmF5LnByb3RvdHlwZS5tYXggPSBmdW5jdGlvbihheGlzKSB7XHJcblx0cmV0dXJuIHRoaXMuX2NvbnRleHQubWF4KHRoaXMsIGF4aXMpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlZHVjZXMgYXJyYXkgZWxlbWVudHMgdXNpbmcgc3VtIG9wZXJhdGlvbi5cclxuICogSWYgdGhlIGF4aXMgYXJndW1lbnQgaXMgcHJvdmlkZWQsIHRoZSBtZXRob2QgY29tcHV0ZXMgc3VtIG9mIGVsZW1lbnRzIGFsb25nIHRoZSBzcGVjaWZpZWQgYXhpcy5cclxuICogT3RoZXJ3aXNlLCB0aGUgbWV0aG9kIGNvbXB1dGVzIGFuIGFsbC1hcnJheSBzdW0gb2YgdGhlIGVsZW1lbnRzIGFuZCByZXR1cm5zIHRoZW0gYXMgYSAxLWVsZW1lbnQgYXJyYXkuXHJcbiAqXHJcbiAqIEBtZXRob2QgbWluXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbYXhpc10gLSB0aGUgYXhpcyBhbG9uZyB3aGljaCB0aGUgc3VtIGlzIGNvbXB1dGVkLlxyXG4gKiBAcmV0dXJuIHtOREFycmF5fVxyXG4gKi9cclxuTkRBcnJheS5wcm90b3R5cGUuc3VtID0gZnVuY3Rpb24oYXhpcykge1xyXG5cdHJldHVybiB0aGlzLl9jb250ZXh0LnN1bSh0aGlzLCBheGlzKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGFub3RoZXIgYXJyYXkgd2l0aCB0aGUgc2FtZSBkYXRhLCBidXQgZGlmZmVyZW50IGRpbWVuc2lvbnMuXHJcbiAqXHJcbiAqIEBtZXRob2QgcmVzaGFwZVxyXG4gKiBAcGFyYW0geyhOREFycmF5fE51bWJlcil9IG90aGVyIC0gZGltZW5zaW9ucyBvZiB0aGUgbmV3IGFycmF5LlxyXG4gKiBAcmV0dXJuIHtOREFycmF5fVxyXG4gKi9cclxuTkRBcnJheS5wcm90b3R5cGUucmVzaGFwZSA9IGZ1bmN0aW9uKG5ld1NoYXBlKSB7XHJcblx0cmV0dXJuIHRoaXMuX2NvbnRleHQucmVzaGFwZSh0aGlzLCBuZXdTaGFwZSk7XHJcbn07XHJcblxyXG4vKipcclxuICogRHVwbGljYXRlcyBhcnJheSBlbGVtZW50cyBhbG9uZyB0aGUgc3BlY2lmaWVkIGF4aXMuXHJcbiAqXHJcbiAqIEBtZXRob2QgcmVwZWF0XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSByZXBlYXRzIC0gdGhlIG51bWJlciBvZiB0aW1lcyB0byByZXBlYXQgZWFjaCBlbGVtZW50LlxyXG4gKiBAcGFyYW0ge051bWJlcn0gYXhpcyAtIHRoZSBheGlzIGFsb25nIHdoaWNoIHRoZSBlbGVtZW50cyB3aWxsIGJlIGR1cGxpY2F0ZWQuXHJcbiAqIEByZXR1cm4ge05EQXJyYXl9XHJcbiAqL1xyXG5OREFycmF5LnByb3RvdHlwZS5yZXBlYXQgPSBmdW5jdGlvbihyZXBlYXRzLCBheGlzKSB7XHJcblx0cmV0dXJuIHRoaXMuX2NvbnRleHQucmVwZWF0KHRoaXMsIHJlcGVhdHMsIGF4aXMpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIHRoZSBkYXRhIHRvIGEgSmF2YVNjcmlwdCBBcnJheS5cclxuICpcclxuICogQG1ldGhvZCBnZXRcclxuICogQGFzeW5jXHJcbiAqL1xyXG5OREFycmF5LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihjYWxsYmFjaykge1xyXG5cdHRoaXMuX2NvbnRleHQuZ2V0KHRoaXMsIGNhbGxiYWNrKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTkRBcnJheTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG52YXIgTkRBcnJheSA9IHJlcXVpcmUoXCIuL05EQXJyYXlcIik7XHJcbnZhciBEYXRhVHlwZSA9IHJlcXVpcmUoXCIuL0RhdGFUeXBlXCIpO1xyXG52YXIgYWxsb2NhdG9yID0gcmVxdWlyZShcIi4vYWxsb2NhdG9yXCIpO1xyXG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XHJcbnZhciByZXF1ZXN0cyA9IHJlcXVpcmUoXCIuL3JlcXVlc3RzLnBiXCIpO1xyXG52YXIgUmVxdWVzdCA9IHJlcXVlc3RzLlJlcXVlc3Q7XHJcbnZhciBFbXB0eUFycmF5UmVxdWVzdCA9IHJlcXVlc3RzLkVtcHR5QXJyYXlSZXF1ZXN0O1xyXG52YXIgRGF0YUFycmF5UmVxdWVzdCA9IHJlcXVlc3RzLkRhdGFBcnJheVJlcXVlc3Q7XHJcbnZhciBDb25zdEFycmF5UmVxdWVzdCA9IHJlcXVlc3RzLkNvbnN0QXJyYXlSZXF1ZXN0O1xyXG52YXIgTGluc3BhY2VSZXF1ZXN0ID0gcmVxdWVzdHMuTGluc3BhY2VSZXF1ZXN0O1xyXG52YXIgUmVzaGFwZVJlcXVlc3QgPSByZXF1ZXN0cy5SZXNoYXBlUmVxdWVzdDtcclxudmFyIFJlcGVhdFJlcXVlc3QgPSByZXF1ZXN0cy5SZXBlYXRSZXF1ZXN0O1xyXG52YXIgRGVhbGxvY2F0ZVJlcXVlc3QgPSByZXF1ZXN0cy5EZWFsbG9jYXRlUmVxdWVzdDtcclxudmFyIEZldGNoUmVxdWVzdCA9IHJlcXVlc3RzLkZldGNoUmVxdWVzdDtcclxudmFyIEJpbmFyeU9wZXJhdGlvblJlcXVlc3QgPSByZXF1ZXN0cy5CaW5hcnlPcGVyYXRpb25SZXF1ZXN0O1xyXG52YXIgQmluYXJ5Q29uc3RPcGVyYXRpb25SZXF1ZXN0ID0gcmVxdWVzdHMuQmluYXJ5Q29uc3RPcGVyYXRpb25SZXF1ZXN0O1xyXG52YXIgVW5hcnlPcGVyYXRpb25SZXF1ZXN0ID0gcmVxdWVzdHMuVW5hcnlPcGVyYXRpb25SZXF1ZXN0O1xyXG52YXIgUmVkdWN0aW9uUmVxdWVzdCA9IHJlcXVlc3RzLlJlZHVjdGlvblJlcXVlc3Q7XHJcbnZhciBBeGlzUmVkdWN0aW9uUmVxdWVzdCA9IHJlcXVlc3RzLkF4aXNSZWR1Y3Rpb25SZXF1ZXN0O1xyXG52YXIgRG90T3BlcmF0aW9uUmVxdWVzdCA9IHJlcXVlc3RzLkRvdE9wZXJhdGlvblJlcXVlc3Q7XHJcbnZhciBSZXNwb25zZSA9IHJlcXVpcmUoXCIuL3Jlc3BvbnNlcy5wYlwiKS5SZXNwb25zZTtcclxuXHJcbnZhciBkYXRhVHlwZU1hcCA9IHtcclxuXHRcImYzMlwiOiByZXF1ZXN0cy5EYXRhVHlwZS5GTE9BVDMyLFxyXG5cdFwiZjY0XCI6IHJlcXVlc3RzLkRhdGFUeXBlLkZMT0FUNjRcclxufTtcclxuXHJcbmZ1bmN0aW9uIFBCQ29udGV4dChvcHRpb25zLCBwb3N0TWVzc2FnZSwgY2FsbGJhY2spIHtcclxuXHR2YXIgY29udGV4dCA9IHRoaXM7XHJcblx0dGhpcy5fcG9zdE1lc3NhZ2UgPSBwb3N0TWVzc2FnZTtcclxuXHR0aGlzLl9jYWxsYmFja3MgPSB7fTtcclxuXHR0aGlzLl9jYWxsYmFja3NbMF0gPSBmdW5jdGlvbihsaW1pdHMpIHtcclxuXHRcdGNhbGxiYWNrKGNvbnRleHQsIGxpbWl0cyk7XHJcblx0fTtcclxufVxyXG5cclxuUEJDb250ZXh0LnByb3RvdHlwZS5fb25NZXNzYWdlID0gZnVuY3Rpb24obWVzc2FnZSkge1xyXG5cdHZhciByZXNwb25zZSA9IFJlc3BvbnNlLmRlY29kZShtZXNzYWdlLmRhdGEpO1xyXG5cdHZhciBpZCA9IHJlc3BvbnNlLmlkO1xyXG5cdHZhciBjYWxsYmFjayA9IHRoaXMuX2NhbGxiYWNrc1tpZF07XHJcblx0ZGVsZXRlIHRoaXMuX2NhbGxiYWNrc1tpZF07XHJcblx0c3dpdGNoIChyZXNwb25zZS50eXBlKSB7XHJcblx0XHRjYXNlIFJlc3BvbnNlLlR5cGUuSU5JVDpcclxuXHRcdFx0dmFyIGxpbWl0cyA9IHt9O1xyXG5cdFx0XHR2YXIgaW5pdFJlc3BvbnNlID0gcmVzcG9uc2UuaW5pdFJlc3BvbnNlO1xyXG5cdFx0XHRpZiAoaW5pdFJlc3BvbnNlLmNvbmN1cnJlbmN5ICE9PSBudWxsKSB7XHJcblx0XHRcdFx0bGltaXRzLmNvbmN1cnJlbmN5ID0gaW5pdFJlc3BvbnNlLmNvbmN1cnJlbmN5O1xyXG5cdFx0XHR9XHJcblx0XHRcdGNhbGxiYWNrKGxpbWl0cyk7XHJcblx0XHRcdGJyZWFrO1xyXG5cdFx0Y2FzZSBSZXNwb25zZS5UeXBlLkJBUlJJRVI6XHJcblx0XHRcdGNhbGxiYWNrKCk7XHJcblx0XHRcdGJyZWFrO1xyXG5cdFx0Y2FzZSBSZXNwb25zZS5UeXBlLkZFVENIOlxyXG5cdFx0XHRjYWxsYmFjayhyZXNwb25zZS5mZXRjaFJlc3BvbnNlLmRhdGFCdWZmZXIudG9BcnJheUJ1ZmZlcigpKTtcclxuXHRcdFx0YnJlYWs7XHJcblx0XHRjYXNlIFJlc3BvbnNlLlR5cGUuRVJST1I6XHJcblx0XHRcdGJyZWFrO1xyXG5cdFx0Y2FzZSBSZXNwb25zZS5UeXBlLklORk86XHJcblx0XHRcdGJyZWFrO1xyXG5cdH1cclxufTtcclxuXHJcblBCQ29udGV4dC5wcm90b3R5cGUuZW1wdHkgPSBmdW5jdGlvbihzaGFwZSwgZGF0YVR5cGUpIHtcclxuXHRzaGFwZSA9IHV0aWwuY2hlY2tTaGFwZShzaGFwZSk7XHJcblx0aWYgKHR5cGVvZiBkYXRhVHlwZSA9PT0gXCJ1bmRlZmluZWRcIikge1xyXG5cdFx0ZGF0YVR5cGUgPSBuZXcgRGF0YVR5cGUoXCJmNjRcIik7XHJcblx0fSBlbHNlIGlmICghKGRhdGFUeXBlIGluc3RhbmNlb2YgRGF0YVR5cGUpKSB7XHJcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKGRhdGFUeXBlICsgXCIgaXMgbm90IGFuIGluc3RhbmNlIG9mIERhdGFUeXBlXCIpO1xyXG5cdH1cclxuXHR2YXIgYXJyYXkgPSBuZXcgTkRBcnJheShzaGFwZSwgZGF0YVR5cGUsIHRoaXMpO1xyXG5cdGFycmF5Ll9pZCA9IGFsbG9jYXRvci5uZXdBcnJheUlkKCk7XHJcblxyXG5cdHZhciByZXF1ZXN0ID0gbmV3IFJlcXVlc3QoKTtcclxuXHRyZXF1ZXN0LmlkID0gYWxsb2NhdG9yLm5ld01lc3NhZ2VJZCgpO1xyXG5cdHJlcXVlc3QudHlwZSA9IFJlcXVlc3QuVHlwZS5FTVBUWV9BUlJBWTtcclxuXHR2YXIgZW1wdHlBcnJheVJlcXVlc3QgPSBuZXcgRW1wdHlBcnJheVJlcXVlc3QoKTtcclxuXHRlbXB0eUFycmF5UmVxdWVzdC5pZE91dCA9IGFycmF5Ll9pZDtcclxuXHRlbXB0eUFycmF5UmVxdWVzdC5zaGFwZSA9IHNoYXBlO1xyXG5cdGVtcHR5QXJyYXlSZXF1ZXN0LmRhdGFUeXBlID0gZGF0YVR5cGVNYXBbZGF0YVR5cGUudHlwZV07XHJcblx0cmVxdWVzdC5lbXB0eUFycmF5UmVxdWVzdCA9IGVtcHR5QXJyYXlSZXF1ZXN0O1xyXG5cdHRoaXMuX3Bvc3RNZXNzYWdlKHJlcXVlc3QuZW5jb2RlQUIoKSk7XHJcblxyXG5cdHJldHVybiBhcnJheTtcclxufTtcclxuXHJcblBCQ29udGV4dC5wcm90b3R5cGUuemVyb3MgPSBmdW5jdGlvbihzaGFwZSwgZGF0YVR5cGUpIHtcclxuXHRzaGFwZSA9IHV0aWwuY2hlY2tTaGFwZShzaGFwZSk7XHJcblx0aWYgKHR5cGVvZiBkYXRhVHlwZSA9PT0gXCJ1bmRlZmluZWRcIikge1xyXG5cdFx0ZGF0YVR5cGUgPSBuZXcgRGF0YVR5cGUoXCJmNjRcIik7XHJcblx0fSBlbHNlIGlmICghKGRhdGFUeXBlIGluc3RhbmNlb2YgRGF0YVR5cGUpKSB7XHJcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKGRhdGFUeXBlICsgXCIgaXMgbm90IGFuIGluc3RhbmNlIG9mIERhdGFUeXBlXCIpO1xyXG5cdH1cclxuXHR2YXIgYXJyYXkgPSBuZXcgTkRBcnJheShzaGFwZSwgZGF0YVR5cGUsIHRoaXMpO1xyXG5cdGFycmF5Ll9pZCA9IGFsbG9jYXRvci5uZXdBcnJheUlkKCk7XHJcblxyXG5cdHZhciByZXF1ZXN0ID0gbmV3IFJlcXVlc3QoKTtcclxuXHRyZXF1ZXN0LmlkID0gYWxsb2NhdG9yLm5ld01lc3NhZ2VJZCgpO1xyXG5cdHJlcXVlc3QudHlwZSA9IFJlcXVlc3QuVHlwZS5DT05TVF9BUlJBWTtcclxuXHR2YXIgY29uc3RBcnJheVJlcXVlc3QgPSBuZXcgQ29uc3RBcnJheVJlcXVlc3QoKTtcclxuXHRjb25zdEFycmF5UmVxdWVzdC5pZE91dCA9IGFycmF5Ll9pZDtcclxuXHRjb25zdEFycmF5UmVxdWVzdC5zaGFwZSA9IHNoYXBlO1xyXG5cdGNvbnN0QXJyYXlSZXF1ZXN0LmRhdGFUeXBlID0gZGF0YVR5cGVNYXBbZGF0YVR5cGUudHlwZV07XHJcblx0Y29uc3RBcnJheVJlcXVlc3QuZmlsbFZhbHVlID0gMC4wO1xyXG5cdHJlcXVlc3QuY29uc3RBcnJheVJlcXVlc3QgPSBjb25zdEFycmF5UmVxdWVzdDtcclxuXHR0aGlzLl9wb3N0TWVzc2FnZShyZXF1ZXN0LmVuY29kZUFCKCkpO1xyXG5cclxuXHRyZXR1cm4gYXJyYXk7XHJcbn07XHJcblxyXG5QQkNvbnRleHQucHJvdG90eXBlLm9uZXMgPSBmdW5jdGlvbihzaGFwZSwgZGF0YVR5cGUpIHtcclxuXHRzaGFwZSA9IHV0aWwuY2hlY2tTaGFwZShzaGFwZSk7XHJcblx0aWYgKHR5cGVvZiBkYXRhVHlwZSA9PT0gXCJ1bmRlZmluZWRcIikge1xyXG5cdFx0ZGF0YVR5cGUgPSBuZXcgRGF0YVR5cGUoXCJmNjRcIik7XHJcblx0fSBlbHNlIGlmICghKGRhdGFUeXBlIGluc3RhbmNlb2YgRGF0YVR5cGUpKSB7XHJcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKGRhdGFUeXBlICsgXCIgaXMgbm90IGFuIGluc3RhbmNlIG9mIERhdGFUeXBlXCIpO1xyXG5cdH1cclxuXHR2YXIgYXJyYXkgPSBuZXcgTkRBcnJheShzaGFwZSwgZGF0YVR5cGUsIHRoaXMpO1xyXG5cdGFycmF5Ll9pZCA9IGFsbG9jYXRvci5uZXdBcnJheUlkKCk7XHJcblxyXG5cdHZhciByZXF1ZXN0ID0gbmV3IFJlcXVlc3QoKTtcclxuXHRyZXF1ZXN0LmlkID0gYWxsb2NhdG9yLm5ld01lc3NhZ2VJZCgpO1xyXG5cdHJlcXVlc3QudHlwZSA9IFJlcXVlc3QuVHlwZS5DT05TVF9BUlJBWTtcclxuXHR2YXIgY29uc3RBcnJheVJlcXVlc3QgPSBuZXcgQ29uc3RBcnJheVJlcXVlc3QoKTtcclxuXHRjb25zdEFycmF5UmVxdWVzdC5pZE91dCA9IGFycmF5Ll9pZDtcclxuXHRjb25zdEFycmF5UmVxdWVzdC5zaGFwZSA9IHNoYXBlO1xyXG5cdGNvbnN0QXJyYXlSZXF1ZXN0LmRhdGFUeXBlID0gZGF0YVR5cGVNYXBbZGF0YVR5cGUudHlwZV07XHJcblx0Y29uc3RBcnJheVJlcXVlc3QuZmlsbFZhbHVlID0gMS4wO1xyXG5cdHJlcXVlc3QuY29uc3RBcnJheVJlcXVlc3QgPSBjb25zdEFycmF5UmVxdWVzdDtcclxuXHR0aGlzLl9wb3N0TWVzc2FnZShyZXF1ZXN0LmVuY29kZUFCKCkpO1xyXG5cclxuXHRyZXR1cm4gYXJyYXk7XHJcbn07XHJcblxyXG5QQkNvbnRleHQucHJvdG90eXBlLmFycmF5ID0gZnVuY3Rpb24oZGF0YSwgZGF0YVR5cGUpIHtcclxuXHR2YXIgc2hhcGUgPSBbXTtcclxuXHR1dGlsLmRpc2NvdmVyQXJyYXlTaGFwZVJlY3Vyc2l2ZShkYXRhLCBzaGFwZSwgMCk7XHJcblx0aWYgKHR5cGVvZiBkYXRhVHlwZSA9PT0gXCJ1bmRlZmluZWRcIikge1xyXG5cdFx0ZGF0YVR5cGUgPSBuZXcgRGF0YVR5cGUoXCJmNjRcIik7XHJcblx0fSBlbHNlIGlmICghKGRhdGFUeXBlIGluc3RhbmNlb2YgRGF0YVR5cGUpKSB7XHJcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKGRhdGFUeXBlICsgXCIgaXMgbm90IGFuIGluc3RhbmNlIG9mIERhdGFUeXBlXCIpO1xyXG5cdH1cclxuXHR2YXIgYXJyYXkgPSBuZXcgTkRBcnJheShzaGFwZSwgZGF0YVR5cGUsIHRoaXMpO1xyXG5cdGFycmF5Ll9pZCA9IGFsbG9jYXRvci5uZXdBcnJheUlkKCk7XHJcblx0dmFyIGFycmF5QnVmZmVyID0gbmV3IGRhdGFUeXBlLmFycmF5VHlwZShhcnJheS5sZW5ndGgpO1xyXG5cdHV0aWwuY29weUFycmF5RGF0YVJlY3Vyc2l2ZShhcnJheUJ1ZmZlciwgZGF0YSwgc2hhcGUsIDAsIDApO1xyXG5cclxuXHR2YXIgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KCk7XHJcblx0cmVxdWVzdC5pZCA9IGFsbG9jYXRvci5uZXdNZXNzYWdlSWQoKTtcclxuXHRyZXF1ZXN0LnR5cGUgPSBSZXF1ZXN0LlR5cGUuREFUQV9BUlJBWTtcclxuXHR2YXIgZGF0YUFycmF5UmVxdWVzdCA9IG5ldyBEYXRhQXJyYXlSZXF1ZXN0KCk7XHJcblx0ZGF0YUFycmF5UmVxdWVzdC5pZE91dCA9IGFycmF5Ll9pZDtcclxuXHRkYXRhQXJyYXlSZXF1ZXN0LnNoYXBlID0gc2hhcGU7XHJcblx0ZGF0YUFycmF5UmVxdWVzdC5kYXRhVHlwZSA9IGRhdGFUeXBlTWFwW2RhdGFUeXBlLnR5cGVdO1xyXG5cdGRhdGFBcnJheVJlcXVlc3QuZGF0YUJ1ZmZlciA9IGFycmF5QnVmZmVyLmJ1ZmZlcjtcclxuXHRyZXF1ZXN0LmRhdGFBcnJheVJlcXVlc3QgPSBkYXRhQXJyYXlSZXF1ZXN0O1xyXG5cdHRoaXMuX3Bvc3RNZXNzYWdlKHJlcXVlc3QuZW5jb2RlQUIoKSk7XHJcblxyXG5cdHJldHVybiBhcnJheTtcclxufTtcclxuXHJcblBCQ29udGV4dC5wcm90b3R5cGUubGluc3BhY2UgPSBmdW5jdGlvbihzdGFydCwgc3RvcCwgc2FtcGxlcywgaW5jbHVkZVN0b3ApIHtcclxuXHRpZiAoIXV0aWwuaXNSZWFsKHN0YXJ0KSkge1xyXG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihzdGFydCArIFwiIGlzIG5vdCBhIHJlYWwgbnVtYmVyXCIpO1xyXG5cdH1cclxuXHRpZiAoIXV0aWwuaXNSZWFsKHN0b3ApKSB7XHJcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKHN0b3AgKyBcIiBpcyBub3QgYSByZWFsIG51bWJlclwiKTtcclxuXHR9XHJcblx0aWYgKHR5cGVvZiBzYW1wbGVzID09PSBcInVuZGVmaW5lZFwiKSB7XHJcblx0XHQvKiBEZWZhdWx0IHZhbHVlIGluIE51bVB5ICovXHJcblx0XHRzYW1wbGVzID0gNTA7XHJcblx0fSBlbHNlIGlmICghdXRpbC5pc0ludChzYW1wbGVzKSkge1xyXG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihzYW1wbGVzICsgXCIgaXMgbm90IGFuIGludGVnZXJcIik7XHJcblx0fSBlbHNlIGlmIChzYW1wbGVzIDw9IDApIHtcclxuXHRcdHRocm93IG5ldyBSYW5nZUVycm9yKFwiVGhlIG51bWJlciBvZiBzYW1wbGVzIG11c3QgYmUgcG9zaXRpdmVcIik7XHJcblx0fVxyXG5cdGlmICh0eXBlb2YgaW5jbHVkZVN0b3AgPT09IFwidW5kZWZpbmVkXCIpIHtcclxuXHRcdGluY2x1ZGVTdG9wID0gdHJ1ZTtcclxuXHR9XHJcblx0aWYgKGluY2x1ZGVTdG9wICYmIChzYW1wbGVzID09PSAxKSkge1xyXG5cdFx0dGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUaGUgbnVtYmVyIG9mIHNhbXBsZXMgbXVzdCBiZSBhIGxlYXN0IDIgKGZvciBzdGFydCBhbmQgZW5kIHBvaW50cylcIik7XHJcblx0fVxyXG5cdHZhciBkYXRhVHlwZSA9IG5ldyBEYXRhVHlwZShcImY2NFwiKTtcclxuXHR2YXIgYXJyYXkgPSBuZXcgTkRBcnJheShbc2FtcGxlc10sIGRhdGFUeXBlLCB0aGlzKTtcclxuXHRhcnJheS5faWQgPSBhbGxvY2F0b3IubmV3QXJyYXlJZCgpO1xyXG5cclxuXHR2YXIgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KCk7XHJcblx0cmVxdWVzdC5pZCA9IGFsbG9jYXRvci5uZXdNZXNzYWdlSWQoKTtcclxuXHRyZXF1ZXN0LnR5cGUgPSBSZXF1ZXN0LlR5cGUuTElOU1BBQ0U7XHJcblx0dmFyIGxpbnNwYWNlUmVxdWVzdCA9IG5ldyBMaW5zcGFjZVJlcXVlc3QoKTtcclxuXHRsaW5zcGFjZVJlcXVlc3QuaWRPdXQgPSBhcnJheS5faWQ7XHJcblx0bGluc3BhY2VSZXF1ZXN0LnN0YXJ0ID0gc3RhcnQ7XHJcblx0bGluc3BhY2VSZXF1ZXN0LnN0b3AgPSBzdG9wO1xyXG5cdGxpbnNwYWNlUmVxdWVzdC5zYW1wbGVzID0gc2FtcGxlcztcclxuXHRsaW5zcGFjZVJlcXVlc3QuY2xvc2VkID0gaW5jbHVkZVN0b3A7XHJcblx0bGluc3BhY2VSZXF1ZXN0LmRhdGFUeXBlID0gZGF0YVR5cGVNYXBbZGF0YVR5cGUudHlwZV07XHJcblx0cmVxdWVzdC5saW5zcGFjZVJlcXVlc3QgPSBsaW5zcGFjZVJlcXVlc3Q7XHJcblx0dGhpcy5fcG9zdE1lc3NhZ2UocmVxdWVzdC5lbmNvZGVBQigpKTtcclxuXHJcblx0cmV0dXJuIGFycmF5O1xyXG59O1xyXG5cclxuUEJDb250ZXh0LnByb3RvdHlwZS5yZXNoYXBlID0gZnVuY3Rpb24oYSwgc2hhcGUpIHtcclxuXHR1dGlsLmNoZWNrTkRBcnJheShhLCBcImFcIik7XHJcblx0c2hhcGUgPSB1dGlsLmNoZWNrU2hhcGUoc2hhcGUpO1xyXG5cdGlmICh1dGlsLmNvbXB1dGVMZW5ndGgoc2hhcGUpICE9PSBhLmxlbmd0aCkge1xyXG5cdFx0dGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUaGUgc2hhcGUgaXMgbm90IGNvbXBhdGlibGUgd2l0aCB0aGUgYXJyYXlcIik7XHJcblx0fVxyXG5cdHZhciBpZEEgPSBhLl9pZDtcclxuXHR2YXIgcmVsZWFzZUEgPSAhYS5fZGVjUmVmKCk7XHJcblx0dmFyIG91dCA9IG5ldyBOREFycmF5KHNoYXBlLCBhLmRhdGFUeXBlLCB0aGlzKTtcclxuXHRpZiAocmVsZWFzZUEpIHtcclxuXHRcdG91dC5faWQgPSBpZEE7XHJcblx0XHRhLl9pZCA9IDA7XHJcblx0XHRyZWxlYXNlQSA9IGZhbHNlO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRvdXQuX2lkID0gYWxsb2NhdG9yLm5ld0FycmF5SWQoKTtcclxuXHR9XHJcblxyXG5cdHZhciByZXF1ZXN0ID0gbmV3IFJlcXVlc3QoKTtcclxuXHRyZXF1ZXN0LmlkID0gYWxsb2NhdG9yLm5ld01lc3NhZ2VJZCgpO1xyXG5cdHJlcXVlc3QudHlwZSA9IFJlcXVlc3QuVHlwZS5SRVNIQVBFO1xyXG5cdHZhciByZXNoYXBlUmVxdWVzdCA9IG5ldyBSZXNoYXBlUmVxdWVzdCgpO1xyXG5cdHJlc2hhcGVSZXF1ZXN0LmlkQSA9IGlkQTtcclxuXHRyZXNoYXBlUmVxdWVzdC5pZE91dCA9IG91dC5faWQ7XHJcblx0cmVzaGFwZVJlcXVlc3Quc2hhcGVPdXQgPSBzaGFwZTtcclxuXHRyZXF1ZXN0LnJlc2hhcGVSZXF1ZXN0ID0gcmVzaGFwZVJlcXVlc3Q7XHJcblx0dGhpcy5fcG9zdE1lc3NhZ2UocmVxdWVzdC5lbmNvZGVBQigpKTtcclxuXHJcblx0YS5fdHJ5SW52YWxpZGF0ZSgpO1xyXG5cdHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG5QQkNvbnRleHQucHJvdG90eXBlLnJlcGVhdCA9IGZ1bmN0aW9uKGEsIHJlcGVhdHMsIGF4aXMsIG91dCkge1xyXG5cdHV0aWwuY2hlY2tOREFycmF5KGEsIFwiYVwiKTtcclxuXHRyZXBlYXRzID0gdXRpbC5jaGVja1JlcGVhdHMocmVwZWF0cyk7XHJcblx0YXhpcyA9IHV0aWwuY2hlY2tBeGlzKGF4aXMsIGEuc2hhcGUubGVuZ3RoKTtcclxuXHR2YXIgc2hhcGVBID0gYS5zaGFwZTtcclxuXHR2YXIgc2hhcGVPdXQgPSBzaGFwZUEuc2xpY2UoMCk7XHJcblx0c2hhcGVPdXRbYXhpc10gKj0gcmVwZWF0cztcclxuXHRpZiAodHlwZW9mIG91dCA9PT0gXCJ1bmRlZmluZWRcIikge1xyXG5cdFx0b3V0ID0gbmV3IE5EQXJyYXkoc2hhcGVPdXQsIGEuZGF0YVR5cGUsIHRoaXMpO1xyXG5cdFx0b3V0Ll9pZCA9IGFsbG9jYXRvci5uZXdBcnJheUlkKCk7XHJcblx0fSBlbHNlIHtcclxuXHRcdHV0aWwuY2hlY2tOREFycmF5KG91dCwgXCJvdXRcIik7XHJcblx0XHR1dGlsLmNoZWNrU2hhcGVzQ29tcGF0aWJpbGl0eShvdXQuc2hhcGUsIHNoYXBlT3V0KTtcclxuXHRcdHV0aWwuY2hlY2tEYXRhVHlwZXNDb21wYXRpYmlsaXR5KGEuZGF0YVR5cGUsIG91dC5kYXRhVHlwZSk7XHJcblx0XHRvdXQuX2luY1JlZigpO1xyXG5cdH1cclxuXHR2YXIgaWRBID0gYS5faWQ7XHJcblx0aWYgKCFhLl9kZWNSZWYoKSkge1xyXG5cdFx0aWRBID0gLWlkQTtcclxuXHRcdGEuX2lkID0gMDtcclxuXHR9XHJcblxyXG5cdHZhciByZXF1ZXN0ID0gbmV3IFJlcXVlc3QoKTtcclxuXHRyZXF1ZXN0LmlkID0gYWxsb2NhdG9yLm5ld01lc3NhZ2VJZCgpO1xyXG5cdHJlcXVlc3QudHlwZSA9IFJlcXVlc3QuVHlwZS5SRVBFQVQ7XHJcblx0dmFyIHJlcGVhdFJlcXVlc3QgPSBuZXcgUmVwZWF0UmVxdWVzdCgpO1xyXG5cdHJlcGVhdFJlcXVlc3QuaWRBID0gaWRBO1xyXG5cdHJlcGVhdFJlcXVlc3QuaWRPdXQgPSBvdXQuX2lkO1xyXG5cdHJlcGVhdFJlcXVlc3QuYXhpcyA9IGF4aXM7XHJcblx0cmVwZWF0UmVxdWVzdC5yZXBlYXRzID0gcmVwZWF0cztcclxuXHRyZXF1ZXN0LnJlcGVhdFJlcXVlc3QgPSByZXBlYXRSZXF1ZXN0O1xyXG5cdHRoaXMuX3Bvc3RNZXNzYWdlKHJlcXVlc3QuZW5jb2RlQUIoKSk7XHJcblxyXG5cdGEuX3RyeUludmFsaWRhdGUoKTtcclxuXHRyZXR1cm4gb3V0O1xyXG59O1xyXG5cclxuUEJDb250ZXh0LnByb3RvdHlwZS5faW52YWxpZGF0ZSA9IGZ1bmN0aW9uKGFycmF5KSB7XHJcblx0aWYgKGFycmF5Ll9pZCAhPT0gMCkge1xyXG5cdFx0dmFyIHJlcXVlc3QgPSBuZXcgUmVxdWVzdCgpO1xyXG5cdFx0cmVxdWVzdC5pZCA9IGFsbG9jYXRvci5uZXdNZXNzYWdlSWQoKTtcclxuXHRcdHJlcXVlc3QudHlwZSA9IFJlcXVlc3QuVHlwZS5ERUFMTE9DQVRFO1xyXG5cdFx0dmFyIGRlYWxsb2NhdGVSZXF1ZXN0ID0gbmV3IERlYWxsb2NhdGVSZXF1ZXN0KCk7XHJcblx0XHRkZWFsbG9jYXRlUmVxdWVzdC5pZEEgPSBhcnJheS5faWQ7XHJcblx0XHRyZXF1ZXN0LmRlYWxsb2NhdGVSZXF1ZXN0ID0gZGVhbGxvY2F0ZVJlcXVlc3Q7XHJcblx0XHR0aGlzLl9wb3N0TWVzc2FnZShyZXF1ZXN0LmVuY29kZUFCKCkpO1xyXG5cdH1cclxufTtcclxuXHJcblBCQ29udGV4dC5wcm90b3R5cGUuZmV0Y2ggPSBmdW5jdGlvbigpIHtcclxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiQ2FsbGJhY2sgYXJndW1lbnQgbWlzc2luZ1wiKTtcclxuXHR9XHJcblx0dmFyIGNhbGxiYWNrID0gYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAxXTtcclxuXHQvKiBWYWxpZGF0ZSBhcmd1bWVudHMgKi9cclxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiQXQgbGVhc3Qgb25lIE5EQXJyYXkgYXJndW1lbnQgZXhwZWN0ZWRcIik7XHJcblx0fVxyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aCAtIDE7ICsraSkge1xyXG5cdFx0dXRpbC5jaGVja05EQXJyYXkoYXJndW1lbnRzW2ldLCBcImFyZ3VtZW50IFwiICsgaSk7XHJcblx0fVxyXG5cdHZhciByZWxlYXNlID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGggLSAxOyArK2kpIHtcclxuXHRcdHJlbGVhc2VbaV0gPSAhYXJndW1lbnRzW2ldLl9kZWNSZWYoKTtcclxuXHR9XHJcblx0dmFyIGNhbGxiYWNrV2FpdEFyZ3VtZW50cyA9IGFyZ3VtZW50cy5sZW5ndGggLSAxO1xyXG5cdHZhciBjYWxsYmFja0FyZ3VtZW50cyA9IG5ldyBBcnJheShjYWxsYmFja1dhaXRBcmd1bWVudHMpO1xyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgY2FsbGJhY2tXYWl0QXJndW1lbnRzOyBpKyspIHtcclxuXHRcdHZhciBhcnJheSA9IGFyZ3VtZW50c1tpXTtcclxuXHRcdHZhciBtZXNzYWdlSWQgPSBhbGxvY2F0b3IubmV3TWVzc2FnZUlkKCk7XHJcblx0XHR0aGlzLl9jYWxsYmFja3NbbWVzc2FnZUlkXSA9IChmdW5jdGlvbihpLCBBcnJheVR5cGUpIHtcclxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKGJ1ZmZlcikge1xyXG5cdFx0XHRcdGNhbGxiYWNrQXJndW1lbnRzW2ldID0gbmV3IEFycmF5VHlwZShidWZmZXIpO1xyXG5cdFx0XHRcdGlmICgtLWNhbGxiYWNrV2FpdEFyZ3VtZW50cyA9PT0gMCkge1xyXG5cdFx0XHRcdFx0Y2FsbGJhY2suYXBwbHkobnVsbCwgY2FsbGJhY2tBcmd1bWVudHMpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fTtcclxuXHRcdH0pKGksIGFycmF5LmRhdGFUeXBlLmFycmF5VHlwZSk7XHJcblx0XHR2YXIgYXJyYXlJZCA9IGFycmF5Ll9pZDtcclxuXHRcdGlmIChyZWxlYXNlW2ldKSB7XHJcblx0XHRcdGFycmF5Ll9pZCA9IDA7XHJcblx0XHRcdGFycmF5SWQgPSAtYXJyYXlJZDtcclxuXHRcdFx0YXJyYXkuX3RyeUludmFsaWRhdGUoKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KCk7XHJcblx0XHRyZXF1ZXN0LmlkID0gbWVzc2FnZUlkO1xyXG5cdFx0cmVxdWVzdC50eXBlID0gUmVxdWVzdC5UeXBlLkZFVENIO1xyXG5cdFx0dmFyIGZldGNoUmVxdWVzdCA9IG5ldyBGZXRjaFJlcXVlc3QoKTtcclxuXHRcdGZldGNoUmVxdWVzdC5pZEEgPSBhcnJheUlkO1xyXG5cdFx0cmVxdWVzdC5mZXRjaFJlcXVlc3QgPSBmZXRjaFJlcXVlc3Q7XHJcblx0XHR0aGlzLl9wb3N0TWVzc2FnZShyZXF1ZXN0LmVuY29kZUFCKCkpO1xyXG5cdH1cclxufTtcclxuXHJcblBCQ29udGV4dC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oKSB7XHJcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcihcIkNhbGxiYWNrIGFyZ3VtZW50IG1pc3NpbmdcIik7XHJcblx0fVxyXG5cdHZhciBjYWxsYmFjayA9IGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoIC0gMV07XHJcblx0LyogVmFsaWRhdGUgYXJndW1lbnRzICovXHJcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcihcIkF0IGxlYXN0IG9uZSBOREFycmF5IGFyZ3VtZW50IGV4cGVjdGVkXCIpO1xyXG5cdH1cclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGggLSAxOyArK2kpIHtcclxuXHRcdHV0aWwuY2hlY2tOREFycmF5KGFyZ3VtZW50c1tpXSwgXCJhcmd1bWVudCBcIiArIGkpO1xyXG5cdH1cclxuXHR2YXIgcmVsZWFzZSA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XHJcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoIC0gMTsgKytpKSB7XHJcblx0XHRyZWxlYXNlW2ldID0gIWFyZ3VtZW50c1tpXS5fZGVjUmVmKCk7XHJcblx0fVxyXG5cdHZhciBjYWxsYmFja1dhaXRBcmd1bWVudHMgPSBhcmd1bWVudHMubGVuZ3RoIC0gMTtcclxuXHR2YXIgY2FsbGJhY2tBcmd1bWVudHMgPSBuZXcgQXJyYXkoY2FsbGJhY2tXYWl0QXJndW1lbnRzKTtcclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGNhbGxiYWNrV2FpdEFyZ3VtZW50czsgaSsrKSB7XHJcblx0XHR2YXIgYXJyYXkgPSBhcmd1bWVudHNbaV07XHJcblx0XHR2YXIgbWVzc2FnZUlkID0gYWxsb2NhdG9yLm5ld01lc3NhZ2VJZCgpO1xyXG5cdFx0aWYgKGFycmF5LnNoYXBlLmxlbmd0aCA9PT0gMCkge1xyXG5cdFx0XHR0aGlzLl9jYWxsYmFja3NbbWVzc2FnZUlkXSA9IChmdW5jdGlvbihpLCBBcnJheVR5cGUpIHtcclxuXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oYnVmZmVyKSB7XHJcblx0XHRcdFx0XHR2YXIgdHlwZWRBcnJheSA9IG5ldyBBcnJheVR5cGUoYnVmZmVyKTtcclxuXHRcdFx0XHRcdGNhbGxiYWNrQXJndW1lbnRzW2ldID0gdHlwZWRBcnJheVswXTtcclxuXHRcdFx0XHRcdGlmICgtLWNhbGxiYWNrV2FpdEFyZ3VtZW50cyA9PT0gMCkge1xyXG5cdFx0XHRcdFx0XHRjYWxsYmFjay5hcHBseShudWxsLCBjYWxsYmFja0FyZ3VtZW50cyk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fTtcclxuXHRcdFx0fSkoaSwgYXJyYXkuZGF0YVR5cGUuYXJyYXlUeXBlKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRoaXMuX2NhbGxiYWNrc1ttZXNzYWdlSWRdID0gKGZ1bmN0aW9uKGksIEFycmF5VHlwZSwgc2hhcGUpIHtcclxuXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oYnVmZmVyKSB7XHJcblx0XHRcdFx0XHR2YXIganNhcnJheSA9IG5ldyBBcnJheShzaGFwZVswXSk7XHJcblx0XHRcdFx0XHR1dGlsLmNyZWF0ZUFycmF5UmVjdXJzaXZlKG5ldyBBcnJheVR5cGUoYnVmZmVyKSwganNhcnJheSwgc2hhcGUsIDAsIDApO1xyXG5cdFx0XHRcdFx0Y2FsbGJhY2tBcmd1bWVudHNbaV0gPSBqc2FycmF5O1xyXG5cdFx0XHRcdFx0aWYgKC0tY2FsbGJhY2tXYWl0QXJndW1lbnRzID09PSAwKSB7XHJcblx0XHRcdFx0XHRcdGNhbGxiYWNrLmFwcGx5KG51bGwsIGNhbGxiYWNrQXJndW1lbnRzKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9O1xyXG5cdFx0XHR9KShpLCBhcnJheS5kYXRhVHlwZS5hcnJheVR5cGUsIGFycmF5LnNoYXBlKTtcclxuXHRcdH1cclxuXHRcdHZhciBhcnJheUlkID0gYXJyYXkuX2lkO1xyXG5cdFx0aWYgKHJlbGVhc2VbaV0pIHtcclxuXHRcdFx0YXJyYXkuX2lkID0gMDtcclxuXHRcdFx0YXJyYXlJZCA9IC1hcnJheUlkO1xyXG5cdFx0XHRhcnJheS5fdHJ5SW52YWxpZGF0ZSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciByZXF1ZXN0ID0gbmV3IFJlcXVlc3QoKTtcclxuXHRcdHJlcXVlc3QuaWQgPSBtZXNzYWdlSWQ7XHJcblx0XHRyZXF1ZXN0LnR5cGUgPSBSZXF1ZXN0LlR5cGUuRkVUQ0g7XHJcblx0XHR2YXIgZmV0Y2hSZXF1ZXN0ID0gbmV3IEZldGNoUmVxdWVzdCgpO1xyXG5cdFx0ZmV0Y2hSZXF1ZXN0LmlkQSA9IGFycmF5SWQ7XHJcblx0XHRyZXF1ZXN0LmZldGNoUmVxdWVzdCA9IGZldGNoUmVxdWVzdDtcclxuXHRcdHRoaXMuX3Bvc3RNZXNzYWdlKHJlcXVlc3QuZW5jb2RlQUIoKSk7XHJcblx0fVxyXG59O1xyXG5cclxuUEJDb250ZXh0LnByb3RvdHlwZS5pbmZvID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcclxuXHR0aHJvdyBuZXcgRXJyb3IoXCJOb3QgaW1wbGVtZW50ZWRcIik7XHJcbi8qXHR2YXIgbWVzc2FnZUlkID0gYWxsb2NhdG9yLm5ld01lc3NhZ2VJZCgpO1xyXG5cdG1lc3NhZ2VDYWxsYmFja3NbbWVzc2FnZUlkXSA9IGNhbGxiYWNrO1xyXG5cdHRoaXMuX3BuYWNsT2JqZWN0LnBvc3RNZXNzYWdlKHtcclxuXHRcdFwiaWRcIjogbWVzc2FnZUlkLFxyXG5cdFx0XCJjb21tYW5kXCI6IFwiaW5mb1wiXHJcblx0fSk7Ki9cclxufTtcclxuXHJcblBCQ29udGV4dC5wcm90b3R5cGUuYmFycmllciA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XHJcblx0dmFyIG1lc3NhZ2VJZCA9IGFsbG9jYXRvci5uZXdNZXNzYWdlSWQoKTtcclxuXHR0aGlzLl9jYWxsYmFja3NbbWVzc2FnZUlkXSA9IGNhbGxiYWNrO1xyXG5cclxuXHR2YXIgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KCk7XHJcblx0cmVxdWVzdC5pZCA9IG1lc3NhZ2VJZDtcclxuXHRyZXF1ZXN0LnR5cGUgPSBSZXF1ZXN0LlR5cGUuQkFSUklFUjtcclxuXHR0aGlzLl9wb3N0TWVzc2FnZShyZXF1ZXN0LmVuY29kZUFCKCkpO1xyXG59O1xyXG5cclxudmFyIGJpbmFyeUFyaXRoT3AgPSBmdW5jdGlvbihhLCBiLCBvdXQsIGNvbnRleHQsIG9wZXJhdGlvbiwgY29uc3RPcGVyYXRpb24sIHJldkNvbnN0T3BlcmF0aW9uKSB7XHJcblx0dmFyIHNoYXBlT3V0ID0gbnVsbCwgZGF0YVR5cGVPdXQgPSBudWxsLCByZWxlYXNlSWRBID0gZmFsc2UsIHJlbGVhc2VJZEIgPSBmYWxzZSwgaWRBID0gMCwgaWRCID0gMDtcclxuXHRpZiAoYSBpbnN0YW5jZW9mIE5EQXJyYXkpIHtcclxuXHRcdGlkQSA9IGEuX2lkO1xyXG5cdFx0c2hhcGVPdXQgPSBhLnNoYXBlO1xyXG5cdFx0ZGF0YVR5cGVPdXQgPSBhLmRhdGFUeXBlO1xyXG5cdFx0aWYgKGIgaW5zdGFuY2VvZiBOREFycmF5KSB7XHJcblx0XHRcdGlkQiA9IGIuX2lkO1xyXG5cdFx0XHR1dGlsLmNoZWNrU2hhcGVzQ29tcGF0aWJpbGl0eShhLnNoYXBlLCBiLnNoYXBlKTtcclxuXHRcdFx0dXRpbC5jaGVja0RhdGFUeXBlc0NvbXBhdGliaWxpdHkoYS5kYXRhVHlwZSwgYi5kYXRhVHlwZSk7XHJcblx0XHR9IGVsc2UgaWYgKCF1dGlsLmlzTnVtYmVyKGIpKSB7XHJcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoXCJVbnN1cHBvcnRlZCB0eXBlIG9mIGJcIik7XHJcblx0XHR9XHJcblx0fSBlbHNlIGlmICh1dGlsLmlzTnVtYmVyKGEpKSB7XHJcblx0XHRpZEIgPSBiLl9pZDtcclxuXHRcdHNoYXBlT3V0ID0gYi5zaGFwZTtcclxuXHRcdGRhdGFUeXBlT3V0ID0gYi5kYXRhVHlwZTtcclxuXHRcdHV0aWwuY2hlY2tOREFycmF5KGIsIFwiYlwiKTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihcIlVuc3VwcG9ydGVkIHR5cGUgb2YgYVwiKTtcclxuXHR9XHJcblx0LyogVGhlIElEcyBvZiBhIGFuZCBiIG11c3QgYmUgaW52YWxpZGF0ZWQgYmVmb3JlIHdlIGFzc2lnbiBJRCB0byBvdXQgYmVjYXVzZSBhL2IgYW5kIG91dCBtYXkgYmUgdGhlIHNhbWUgYXJyYXlzICovXHJcblx0aWYgKGlkQSAhPT0gMCkge1xyXG5cdFx0cmVsZWFzZUlkQSA9ICFhLl9kZWNSZWYoKTtcclxuXHRcdGlmIChyZWxlYXNlSWRBKSB7XHJcblx0XHRcdGEuX2lkID0gMDtcclxuXHRcdH1cclxuXHR9XHJcblx0aWYgKGlkQiAhPT0gMCkge1xyXG5cdFx0cmVsZWFzZUlkQiA9ICFiLl9kZWNSZWYoKTtcclxuXHRcdGlmIChyZWxlYXNlSWRCKSB7XHJcblx0XHRcdGIuX2lkID0gMDtcclxuXHRcdH1cclxuXHR9XHJcblx0dHJ5IHtcclxuXHRcdGlmICh0eXBlb2Ygb3V0ID09PSBcInVuZGVmaW5lZFwiKSB7XHJcblx0XHRcdG91dCA9IG5ldyBOREFycmF5KHNoYXBlT3V0LCBkYXRhVHlwZU91dCwgY29udGV4dCk7XHJcblx0XHRcdGlmIChyZWxlYXNlSWRBKSB7XHJcblx0XHRcdFx0b3V0Ll9pZCA9IGlkQTtcclxuXHRcdFx0XHRyZWxlYXNlSWRBID0gZmFsc2U7XHJcblx0XHRcdH0gZWxzZSBpZiAocmVsZWFzZUlkQikge1xyXG5cdFx0XHRcdG91dC5faWQgPSBpZEI7XHJcblx0XHRcdFx0cmVsZWFzZUlkQiA9IGZhbHNlO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdG91dC5faWQgPSBhbGxvY2F0b3IubmV3QXJyYXlJZCgpO1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR1dGlsLmNoZWNrTkRBcnJheShvdXQsIFwib3V0XCIpO1xyXG5cdFx0XHR1dGlsLmNoZWNrU2hhcGVzQ29tcGF0aWJpbGl0eShzaGFwZU91dCwgb3V0LnNoYXBlKTtcclxuXHRcdFx0dXRpbC5jaGVja0RhdGFUeXBlc0NvbXBhdGliaWxpdHkoZGF0YVR5cGVPdXQsIG91dC5kYXRhVHlwZSk7XHJcblx0XHRcdG91dC5faW5jUmVmKCk7XHJcblx0XHR9XHJcblx0XHR2YXIgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KCk7XHJcblx0XHRyZXF1ZXN0LmlkID0gYWxsb2NhdG9yLm5ld01lc3NhZ2VJZCgpO1xyXG5cdFx0aWYgKGlkQSAhPT0gMCkge1xyXG5cdFx0XHRpZiAoaWRCICE9PSAwKSB7XHJcblx0XHRcdFx0cmVxdWVzdC50eXBlID0gUmVxdWVzdC5UeXBlLkJJTkFSWV9PUEVSQVRJT047XHJcblx0XHRcdFx0dmFyIGJpbmFyeU9wZXJhdGlvblJlcXVlc3QgPSBuZXcgQmluYXJ5T3BlcmF0aW9uUmVxdWVzdCgpO1xyXG5cdFx0XHRcdGJpbmFyeU9wZXJhdGlvblJlcXVlc3QudHlwZSA9IG9wZXJhdGlvbjtcclxuXHRcdFx0XHRiaW5hcnlPcGVyYXRpb25SZXF1ZXN0LmlkQSA9IChyZWxlYXNlSWRBID8gLWlkQSA6IGlkQSk7XHJcblx0XHRcdFx0YmluYXJ5T3BlcmF0aW9uUmVxdWVzdC5pZEIgPSAocmVsZWFzZUlkQiA/IC1pZEIgOiBpZEIpO1xyXG5cdFx0XHRcdGJpbmFyeU9wZXJhdGlvblJlcXVlc3QuaWRPdXQgPSBvdXQuX2lkO1xyXG5cdFx0XHRcdHJlcXVlc3QuYmluYXJ5T3BlcmF0aW9uUmVxdWVzdCA9IGJpbmFyeU9wZXJhdGlvblJlcXVlc3Q7XHJcblx0XHRcdFx0Y29udGV4dC5fcG9zdE1lc3NhZ2UocmVxdWVzdC5lbmNvZGVBQigpKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRyZXF1ZXN0LnR5cGUgPSBSZXF1ZXN0LlR5cGUuQklOQVJZX0NPTlNUX09QRVJBVElPTjtcclxuXHRcdFx0XHR2YXIgYmluYXJ5Q29uc3RPcGVyYXRpb25SZXF1ZXN0ID0gbmV3IEJpbmFyeUNvbnN0T3BlcmF0aW9uUmVxdWVzdCgpO1xyXG5cdFx0XHRcdGJpbmFyeUNvbnN0T3BlcmF0aW9uUmVxdWVzdC50eXBlID0gY29uc3RPcGVyYXRpb247XHJcblx0XHRcdFx0YmluYXJ5Q29uc3RPcGVyYXRpb25SZXF1ZXN0LmlkQSA9IChyZWxlYXNlSWRBID8gLWlkQSA6IGlkQSk7XHJcblx0XHRcdFx0YmluYXJ5Q29uc3RPcGVyYXRpb25SZXF1ZXN0LnZhbHVlQiA9IGI7XHJcblx0XHRcdFx0YmluYXJ5Q29uc3RPcGVyYXRpb25SZXF1ZXN0LmlkT3V0ID0gb3V0Ll9pZDtcclxuXHRcdFx0XHRyZXF1ZXN0LmJpbmFyeUNvbnN0T3BlcmF0aW9uUmVxdWVzdCA9IGJpbmFyeUNvbnN0T3BlcmF0aW9uUmVxdWVzdDtcclxuXHRcdFx0XHRjb250ZXh0Ll9wb3N0TWVzc2FnZShyZXF1ZXN0LmVuY29kZUFCKCkpO1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRyZXF1ZXN0LnR5cGUgPSBSZXF1ZXN0LlR5cGUuQklOQVJZX0NPTlNUX09QRVJBVElPTjtcclxuXHRcdFx0dmFyIGJpbmFyeUNvbnN0T3BlcmF0aW9uUmVxdWVzdCA9IG5ldyBCaW5hcnlDb25zdE9wZXJhdGlvblJlcXVlc3QoKTtcclxuXHRcdFx0YmluYXJ5Q29uc3RPcGVyYXRpb25SZXF1ZXN0LnR5cGUgPSByZXZDb25zdE9wZXJhdGlvbjtcclxuXHRcdFx0YmluYXJ5Q29uc3RPcGVyYXRpb25SZXF1ZXN0LmlkQSA9IChyZWxlYXNlSWRCID8gLWlkQiA6IGlkQik7XHJcblx0XHRcdGJpbmFyeUNvbnN0T3BlcmF0aW9uUmVxdWVzdC52YWx1ZUIgPSBhO1xyXG5cdFx0XHRiaW5hcnlDb25zdE9wZXJhdGlvblJlcXVlc3QuaWRPdXQgPSBvdXQuX2lkO1xyXG5cdFx0XHRyZXF1ZXN0LmJpbmFyeUNvbnN0T3BlcmF0aW9uUmVxdWVzdCA9IGJpbmFyeUNvbnN0T3BlcmF0aW9uUmVxdWVzdDtcclxuXHRcdFx0Y29udGV4dC5fcG9zdE1lc3NhZ2UocmVxdWVzdC5lbmNvZGVBQigpKTtcclxuXHRcdH1cclxuXHR9IGNhdGNoIChlKSB7XHJcblx0XHQvKiBSZXN0b3JlIHRoZSBwcmV2aW91cyBzdGF0ZSAqL1xyXG5cdFx0aWYgKGlkQSAhPT0gMCkge1xyXG5cdFx0XHRhLl9pZCA9IGlkQTtcclxuXHRcdFx0YS5faW5jUmVmKCk7XHJcblx0XHR9XHJcblx0XHRpZiAoaWRCICE9PSAwKSB7XHJcblx0XHRcdGIuX2lkID0gaWRCO1xyXG5cdFx0XHRiLl9pbmNSZWYoKTtcclxuXHRcdH1cclxuXHRcdHRocm93IGU7XHJcblx0fVxyXG5cdC8qXHJcblx0ICogSWYgYSBvciBiIGFyZSBhcnJheXMsIGludmFsaWRhdGUgdGhlbSBhcyBuZWVkZWQuXHJcblx0ICogSWYgYS9iIGFuZCBvdXQgYXJlIHRoZSBzYW1lLCB0aGVpciByZWYgY291bnQgaXMgbm9uLXplcm8gYXQgdGhpcyBwb2ludCwgc28gdGhleSB3aWxsIHN0YXkgdmFsaWQuXHJcblx0ICovXHJcblx0aWYgKGlkQSAhPT0gMCkge1xyXG5cdFx0YS5fdHJ5SW52YWxpZGF0ZSgpO1xyXG5cdH1cclxuXHRpZiAoaWRCICE9PSAwKSB7XHJcblx0XHRiLl90cnlJbnZhbGlkYXRlKCk7XHJcblx0fVxyXG5cdHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG52YXIgdW5hcnlBcml0aE9wID0gZnVuY3Rpb24oYSwgb3V0LCBjb250ZXh0LCBvcGVyYXRpb24pIHtcclxuXHR1dGlsLmNoZWNrTkRBcnJheShhLCBcImFcIik7XHJcblx0dmFyIGlkQSA9IGEuX2lkO1xyXG5cdHZhciByZWxlYXNlSWRBID0gIWEuX2RlY1JlZigpO1xyXG5cdC8qIFRoZSBJRCBvZiBhIG11c3QgYmUgaW52YWxpZGF0ZWQgYmVmb3JlIHdlIGFzc2lnbiBJRCB0byBvdXQgYmVjYXVzZSBhIGFuZCBvdXQgbWF5IGJlIHRoZSBzYW1lIGFycmF5cyAqL1xyXG5cdGlmIChyZWxlYXNlSWRBKSB7XHJcblx0XHRhLl9pZCA9IDA7XHJcblx0fVxyXG5cdHRyeSB7XHJcblx0XHRpZiAodHlwZW9mIG91dCA9PT0gXCJ1bmRlZmluZWRcIikge1xyXG5cdFx0XHRvdXQgPSBuZXcgTkRBcnJheShhLnNoYXBlLCBhLmRhdGFUeXBlLCBjb250ZXh0KTtcclxuXHRcdFx0aWYgKHJlbGVhc2VJZEEpIHtcclxuXHRcdFx0XHRvdXQuX2lkID0gaWRBO1xyXG5cdFx0XHRcdHJlbGVhc2VJZEEgPSBmYWxzZTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRvdXQuX2lkID0gYWxsb2NhdG9yLm5ld0FycmF5SWQoKTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dXRpbC5jaGVja05EQXJyYXkob3V0LCBcIm91dFwiKTtcclxuXHRcdFx0dXRpbC5jaGVja1NoYXBlc0NvbXBhdGliaWxpdHkoYS5zaGFwZSwgb3V0LnNoYXBlKTtcclxuXHRcdFx0dXRpbC5jaGVja0RhdGFUeXBlc0NvbXBhdGliaWxpdHkoYS5kYXRhVHlwZSwgb3V0LmRhdGFUeXBlKTtcclxuXHRcdFx0b3V0Ll9pbmNSZWYoKTtcclxuXHRcdH1cclxuXHR9IGNhdGNoIChlKSB7XHJcblx0XHQvKiBSZXN0b3JlIHRoZSBwcmV2aW91cyBzdGF0ZSAqL1xyXG5cdFx0YS5faWQgPSBpZEE7XHJcblx0XHRhLl9pbmNSZWYoKTtcclxuXHRcdHRocm93IGU7XHJcblx0fVxyXG5cclxuXHR2YXIgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KCk7XHJcblx0cmVxdWVzdC5pZCA9IGFsbG9jYXRvci5uZXdNZXNzYWdlSWQoKTtcclxuXHRyZXF1ZXN0LnR5cGUgPSBSZXF1ZXN0LlR5cGUuVU5BUllfT1BFUkFUSU9OO1xyXG5cdHZhciB1bmFyeU9wZXJhdGlvblJlcXVlc3QgPSBuZXcgVW5hcnlPcGVyYXRpb25SZXF1ZXN0KCk7XHJcblx0dW5hcnlPcGVyYXRpb25SZXF1ZXN0LnR5cGUgPSBvcGVyYXRpb247XHJcblx0dW5hcnlPcGVyYXRpb25SZXF1ZXN0LmlkQSA9IChyZWxlYXNlSWRBID8gLWlkQSA6IGlkQSk7XHJcblx0dW5hcnlPcGVyYXRpb25SZXF1ZXN0LmlkT3V0ID0gb3V0Ll9pZDtcclxuXHRyZXF1ZXN0LnVuYXJ5T3BlcmF0aW9uUmVxdWVzdCA9IHVuYXJ5T3BlcmF0aW9uUmVxdWVzdDtcclxuXHRjb250ZXh0Ll9wb3N0TWVzc2FnZShyZXF1ZXN0LmVuY29kZUFCKCkpO1xyXG5cclxuXHQvKiBJZiBhIGFuZCBvdXQgYXJlIHRoZSBzYW1lLCB0aGVpciByZWYgY291bnQgaXMgbm9uLXplcm8gYXQgdGhpcyBwb2ludCwgc28gdGhleSB3aWxsIHN0YXkgdmFsaWQuICovXHJcblx0YS5fdHJ5SW52YWxpZGF0ZSgpO1xyXG5cdHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG52YXIgcmVkdWNlQXJpdGhPcCA9IGZ1bmN0aW9uKGEsIG91dCwgY29udGV4dCwgb3BlcmF0aW9uKSB7XHJcblx0dXRpbC5jaGVja05EQXJyYXkoYSwgXCJhXCIpO1xyXG5cdHZhciBpZEEgPSBhLl9pZDtcclxuXHR2YXIgcmVsZWFzZUlkQSA9ICFhLl9kZWNSZWYoKTtcclxuXHRpZiAocmVsZWFzZUlkQSkge1xyXG5cdFx0YS5faWQgPSAwO1xyXG5cdH1cclxuXHR0cnkge1xyXG5cdFx0aWYgKHR5cGVvZiBvdXQgPT09IFwidW5kZWZpbmVkXCIpIHtcclxuXHRcdFx0b3V0ID0gbmV3IE5EQXJyYXkoW10sIGEuZGF0YVR5cGUsIGNvbnRleHQpO1xyXG5cdFx0XHRvdXQuX2lkID0gYWxsb2NhdG9yLm5ld0FycmF5SWQoKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHV0aWwuY2hlY2tOREFycmF5KG91dCwgXCJvdXRcIik7XHJcblx0XHRcdHV0aWwuY2hlY2tTaGFwZXNDb21wYXRpYmlsaXR5KG91dC5zaGFwZSwgW10pO1xyXG5cdFx0XHR1dGlsLmNoZWNrRGF0YVR5cGVzQ29tcGF0aWJpbGl0eShhLmRhdGFUeXBlLCBvdXQuZGF0YVR5cGUpO1xyXG5cdFx0XHRvdXQuX2luY1JlZigpO1xyXG5cdFx0fVxyXG5cdH0gY2F0Y2ggKGUpIHtcclxuXHRcdC8qIFJlc3RvcmUgdGhlIHByZXZpb3VzIHN0YXRlICovXHJcblx0XHRhLl9pZCA9IGlkQTtcclxuXHRcdGEuX2luY1JlZigpO1xyXG5cdFx0dGhyb3cgZTtcclxuXHR9XHJcblxyXG5cdHZhciByZXF1ZXN0ID0gbmV3IFJlcXVlc3QoKTtcclxuXHRyZXF1ZXN0LmlkID0gYWxsb2NhdG9yLm5ld01lc3NhZ2VJZCgpO1xyXG5cdHJlcXVlc3QudHlwZSA9IFJlcXVlc3QuVHlwZS5SRURVQ1RJT05fT1BFUkFUSU9OO1xyXG5cdHZhciByZWR1Y3Rpb25SZXF1ZXN0ID0gbmV3IFJlZHVjdGlvblJlcXVlc3QoKTtcclxuXHRyZWR1Y3Rpb25SZXF1ZXN0LnR5cGUgPSBvcGVyYXRpb247XHJcblx0cmVkdWN0aW9uUmVxdWVzdC5pZEEgPSAocmVsZWFzZUlkQSA/IC1pZEEgOiBpZEEpO1xyXG5cdHJlZHVjdGlvblJlcXVlc3QuaWRPdXQgPSBvdXQuX2lkO1xyXG5cdHJlcXVlc3QucmVkdWN0aW9uUmVxdWVzdCA9IHJlZHVjdGlvblJlcXVlc3Q7XHJcblx0Y29udGV4dC5fcG9zdE1lc3NhZ2UocmVxdWVzdC5lbmNvZGVBQigpKTtcclxuXHJcblx0YS5fdHJ5SW52YWxpZGF0ZSgpO1xyXG5cdHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG52YXIgYXhpc1JlZHVjZUFyaXRoT3AgPSBmdW5jdGlvbihhLCBheGlzLCBvdXQsIGNvbnRleHQsIG9wZXJhdGlvbikge1xyXG5cdHV0aWwuY2hlY2tOREFycmF5KGEsIFwiYVwiKTtcclxuXHR2YXIgaWRBID0gYS5faWQ7XHJcblx0dmFyIHJlbGVhc2VJZEEgPSAhYS5fZGVjUmVmKCk7XHJcblx0aWYgKHJlbGVhc2VJZEEpIHtcclxuXHRcdGEuX2lkID0gMDtcclxuXHR9XHJcblx0dHJ5IHtcclxuXHRcdHV0aWwuY2hlY2tBeGlzKGF4aXMpO1xyXG5cdFx0aWYgKHR5cGVvZiBvdXQgPT09IFwidW5kZWZpbmVkXCIpIHtcclxuXHRcdFx0b3V0ID0gbmV3IE5EQXJyYXkodXRpbC5jb21wdXRlQXhpc1JlZHVjdGlvbk91dFNoYXBlKGEuc2hhcGUsIGF4aXMpLCBhLmRhdGFUeXBlLCBjb250ZXh0KTtcclxuXHRcdFx0b3V0Ll9pZCA9IGFsbG9jYXRvci5uZXdBcnJheUlkKCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR1dGlsLmNoZWNrTkRBcnJheShvdXQsIFwib3V0XCIpO1xyXG5cdFx0XHR1dGlsLmNoZWNrU2hhcGVzQ29tcGF0aWJpbGl0eShvdXQuc2hhcGUsIFtdKTtcclxuXHRcdFx0dXRpbC5jaGVja0RhdGFUeXBlc0NvbXBhdGliaWxpdHkoYS5kYXRhVHlwZSwgb3V0LmRhdGFUeXBlKTtcclxuXHRcdFx0b3V0Ll9pbmNSZWYoKTtcclxuXHRcdH1cclxuXHR9IGNhdGNoIChlKSB7XHJcblx0XHQvKiBSZXN0b3JlIHRoZSBwcmV2aW91cyBzdGF0ZSAqL1xyXG5cdFx0YS5faWQgPSBpZEE7XHJcblx0XHRhLl9pbmNSZWYoKTtcclxuXHRcdHRocm93IGU7XHJcblx0fVxyXG5cclxuXHR2YXIgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KCk7XHJcblx0cmVxdWVzdC5pZCA9IGFsbG9jYXRvci5uZXdNZXNzYWdlSWQoKTtcclxuXHRyZXF1ZXN0LnR5cGUgPSBSZXF1ZXN0LlR5cGUuQVhJU19SRURVQ1RJT05fT1BFUkFUSU9OO1xyXG5cdHZhciBheGlzUmVkdWN0aW9uUmVxdWVzdCA9IG5ldyBBeGlzUmVkdWN0aW9uUmVxdWVzdCgpO1xyXG5cdGF4aXNSZWR1Y3Rpb25SZXF1ZXN0LnR5cGUgPSBvcGVyYXRpb247XHJcblx0YXhpc1JlZHVjdGlvblJlcXVlc3QuaWRBID0gKHJlbGVhc2VJZEEgPyAtaWRBIDogaWRBKTtcclxuXHRheGlzUmVkdWN0aW9uUmVxdWVzdC5heGlzID0gYXhpcztcclxuXHRheGlzUmVkdWN0aW9uUmVxdWVzdC5pZE91dCA9IG91dC5faWQ7XHJcblx0cmVxdWVzdC5heGlzUmVkdWN0aW9uUmVxdWVzdCA9IGF4aXNSZWR1Y3Rpb25SZXF1ZXN0O1xyXG5cdGNvbnRleHQuX3Bvc3RNZXNzYWdlKHJlcXVlc3QuZW5jb2RlQUIoKSk7XHJcblxyXG5cdGEuX3RyeUludmFsaWRhdGUoKTtcclxuXHRyZXR1cm4gb3V0O1xyXG59O1xyXG5cclxudmFyIGRvdEFyaXRoT3AgPSBmdW5jdGlvbihhLCBiLCBvdXQsIGNvbnRleHQpIHtcclxuXHR1dGlsLmNoZWNrTkRBcnJheShhLCBcImFcIik7XHJcblx0dXRpbC5jaGVja05EQXJyYXkoYiwgXCJiXCIpO1xyXG5cdHV0aWwuY2hlY2tEYXRhVHlwZXNDb21wYXRpYmlsaXR5KGEuZGF0YVR5cGUsIGIuZGF0YVR5cGUpO1xyXG5cdHZhciBpZEEgPSBhLl9pZDtcclxuXHR2YXIgcmVsZWFzZUlkQSA9ICFhLl9kZWNSZWYoKTtcclxuXHRpZiAocmVsZWFzZUlkQSkge1xyXG5cdFx0YS5faWQgPSAwO1xyXG5cdH1cclxuXHR2YXIgaWRCID0gYi5faWQ7XHJcblx0dmFyIHJlbGVhc2VJZEIgPSAhYi5fZGVjUmVmKCk7XHJcblx0aWYgKHJlbGVhc2VJZEIpIHtcclxuXHRcdGIuX2lkID0gMDtcclxuXHR9XHJcblx0dHJ5IHtcclxuXHRcdGlmICh0eXBlb2Ygb3V0ID09PSBcInVuZGVmaW5lZFwiKSB7XHJcblx0XHRcdHZhciBzaGFwZUEgPSBhLnNoYXBlO1xyXG5cdFx0XHR2YXIgc2hhcGVCID0gYi5zaGFwZTtcclxuXHRcdFx0dmFyIGF4aXNBID0gTWF0aC5tYXgoc2hhcGVBLmxlbmd0aCAtIDEsIDApO1xyXG5cdFx0XHR2YXIgYXhpc0IgPSBNYXRoLm1heChzaGFwZUIubGVuZ3RoIC0gMiwgMCk7XHJcblx0XHRcdGlmIChzaGFwZUFbYXhpc0FdICE9IHNoYXBlQltheGlzQl0pIHtcclxuXHRcdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKFwiTWlzbWF0Y2ggaW4gcmVkdWN0aW9uIGRpbWVuc2lvbnNcIik7XHJcblx0XHRcdH1cclxuXHRcdFx0dmFyIHNoYXBlT3V0ID0gW107XHJcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYXhpc0E7IGkrKykge1xyXG5cdFx0XHRcdHNoYXBlT3V0LnB1c2goc2hhcGVBW2ldKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAoc2hhcGVCLmxlbmd0aCA+IDEpIHtcclxuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGF4aXNCOyBpKyspIHtcclxuXHRcdFx0XHRcdHNoYXBlT3V0LnB1c2goc2hhcGVCW2ldKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0c2hhcGVPdXQucHVzaChzaGFwZUJbc2hhcGVCLmxlbmd0aCAtIDFdKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRvdXQgPSBuZXcgTkRBcnJheShzaGFwZU91dCwgYS5kYXRhVHlwZSwgY29udGV4dCk7XHJcblx0XHRcdG91dC5faWQgPSBhbGxvY2F0b3IubmV3QXJyYXlJZCgpO1xyXG5cdFx0fSBlbHNlIGlmIChvdXQgaW5zdGFuY2VvZiBOREFycmF5KSB7XHJcblx0XHRcdHV0aWwuY2hlY2tOREFycmF5KG91dCwgXCJvdXRcIik7XHJcblx0XHRcdHV0aWwuY2hlY2tEYXRhVHlwZXNDb21wYXRpYmlsaXR5KGEuZGF0YVR5cGUsIG91dC5kYXRhVHlwZSk7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZFwiKTtcclxuXHRcdH1cclxuXHR9IGNhdGNoIChlKSB7XHJcblx0XHQvKiBSZXN0b3JlIHRoZSBwcmV2aW91cyBzdGF0ZSAqL1xyXG5cdFx0YS5faWQgPSBpZEE7XHJcblx0XHRhLl9pbmNSZWYoKTtcclxuXHRcdGIuX2lkID0gaWRCO1xyXG5cdFx0Yi5faW5jUmVmKCk7XHJcblx0XHR0aHJvdyBlO1xyXG5cdH1cclxuXHJcblx0dmFyIHJlcXVlc3QgPSBuZXcgUmVxdWVzdCgpO1xyXG5cdHJlcXVlc3QuaWQgPSBhbGxvY2F0b3IubmV3TWVzc2FnZUlkKCk7XHJcblx0cmVxdWVzdC50eXBlID0gUmVxdWVzdC5UeXBlLkRPVF9PUEVSQVRJT047XHJcblx0dmFyIGRvdE9wZXJhdGlvblJlcXVlc3QgPSBuZXcgRG90T3BlcmF0aW9uUmVxdWVzdCgpO1xyXG5cdGRvdE9wZXJhdGlvblJlcXVlc3QuaWRBID0gKHJlbGVhc2VJZEEgPyAtaWRBIDogaWRBKTtcclxuXHRkb3RPcGVyYXRpb25SZXF1ZXN0LmlkQiA9IChyZWxlYXNlSWRCID8gLWlkQiA6IGlkQik7XHJcblx0ZG90T3BlcmF0aW9uUmVxdWVzdC5pZE91dCA9IG91dC5faWQ7XHJcblx0cmVxdWVzdC5kb3RPcGVyYXRpb25SZXF1ZXN0ID0gZG90T3BlcmF0aW9uUmVxdWVzdDtcclxuXHRjb250ZXh0Ll9wb3N0TWVzc2FnZShyZXF1ZXN0LmVuY29kZUFCKCkpO1xyXG5cclxuXHRhLl90cnlJbnZhbGlkYXRlKCk7XHJcblx0Yi5fdHJ5SW52YWxpZGF0ZSgpO1xyXG5cdHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG5QQkNvbnRleHQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKGEsIGIsIG91dCkge1xyXG5cdHJldHVybiBiaW5hcnlBcml0aE9wKGEsIGIsIG91dCwgdGhpcyxcclxuXHRcdEJpbmFyeU9wZXJhdGlvblJlcXVlc3QuVHlwZS5BREQsXHJcblx0XHRCaW5hcnlDb25zdE9wZXJhdGlvblJlcXVlc3QuVHlwZS5BRERDLFxyXG5cdFx0QmluYXJ5Q29uc3RPcGVyYXRpb25SZXF1ZXN0LlR5cGUuQUREQyk7XHJcbn07XHJcblxyXG5QQkNvbnRleHQucHJvdG90eXBlLnN1YiA9IGZ1bmN0aW9uKGEsIGIsIG91dCkge1xyXG5cdHJldHVybiBiaW5hcnlBcml0aE9wKGEsIGIsIG91dCwgdGhpcyxcclxuXHRcdEJpbmFyeU9wZXJhdGlvblJlcXVlc3QuVHlwZS5TVUIsXHJcblx0XHRCaW5hcnlDb25zdE9wZXJhdGlvblJlcXVlc3QuVHlwZS5TVUJDLFxyXG5cdFx0QmluYXJ5Q29uc3RPcGVyYXRpb25SZXF1ZXN0LlR5cGUuU1VCUkMpO1xyXG59O1xyXG5cclxuUEJDb250ZXh0LnByb3RvdHlwZS5tdWwgPSBmdW5jdGlvbihhLCBiLCBvdXQpIHtcclxuXHRyZXR1cm4gYmluYXJ5QXJpdGhPcChhLCBiLCBvdXQsIHRoaXMsXHJcblx0XHRCaW5hcnlPcGVyYXRpb25SZXF1ZXN0LlR5cGUuTVVMLFxyXG5cdFx0QmluYXJ5Q29uc3RPcGVyYXRpb25SZXF1ZXN0LlR5cGUuTVVMQyxcclxuXHRcdEJpbmFyeUNvbnN0T3BlcmF0aW9uUmVxdWVzdC5UeXBlLk1VTEMpO1xyXG59O1xyXG5cclxuUEJDb250ZXh0LnByb3RvdHlwZS5kaXYgPSBmdW5jdGlvbihhLCBiLCBvdXQpIHtcclxuXHRyZXR1cm4gYmluYXJ5QXJpdGhPcChhLCBiLCBvdXQsIHRoaXMsXHJcblx0XHRCaW5hcnlPcGVyYXRpb25SZXF1ZXN0LlR5cGUuRElWLFxyXG5cdFx0QmluYXJ5Q29uc3RPcGVyYXRpb25SZXF1ZXN0LlR5cGUuRElWQyxcclxuXHRcdEJpbmFyeUNvbnN0T3BlcmF0aW9uUmVxdWVzdC5UeXBlLkRJVlJDKTtcclxufTtcclxuXHJcblBCQ29udGV4dC5wcm90b3R5cGUubmVnID0gZnVuY3Rpb24oYSwgb3V0KSB7XHJcblx0cmV0dXJuIHVuYXJ5QXJpdGhPcChhLCBvdXQsIHRoaXMsXHJcblx0XHRVbmFyeU9wZXJhdGlvblJlcXVlc3QuVHlwZS5ORUcpO1xyXG59O1xyXG5cclxuUEJDb250ZXh0LnByb3RvdHlwZS5hYnMgPSBmdW5jdGlvbihhLCBvdXQpIHtcclxuXHRyZXR1cm4gdW5hcnlBcml0aE9wKGEsIG91dCwgdGhpcyxcclxuXHRcdFVuYXJ5T3BlcmF0aW9uUmVxdWVzdC5UeXBlLkFCUyk7XHJcbn07XHJcblxyXG5QQkNvbnRleHQucHJvdG90eXBlLmV4cCA9IGZ1bmN0aW9uKGEsIG91dCkge1xyXG5cdHJldHVybiB1bmFyeUFyaXRoT3AoYSwgb3V0LCB0aGlzLFxyXG5cdFx0VW5hcnlPcGVyYXRpb25SZXF1ZXN0LlR5cGUuRVhQKTtcclxufTtcclxuXHJcblBCQ29udGV4dC5wcm90b3R5cGUubG9nID0gZnVuY3Rpb24oYSwgb3V0KSB7XHJcblx0cmV0dXJuIHVuYXJ5QXJpdGhPcChhLCBvdXQsIHRoaXMsXHJcblx0XHRVbmFyeU9wZXJhdGlvblJlcXVlc3QuVHlwZS5MT0cpO1xyXG59O1xyXG5cclxuUEJDb250ZXh0LnByb3RvdHlwZS5zcXJ0ID0gZnVuY3Rpb24oYSwgb3V0KSB7XHJcblx0cmV0dXJuIHVuYXJ5QXJpdGhPcChhLCBvdXQsIHRoaXMsXHJcblx0XHRVbmFyeU9wZXJhdGlvblJlcXVlc3QuVHlwZS5TUVJUKTtcclxufTtcclxuXHJcblBCQ29udGV4dC5wcm90b3R5cGUuc3F1YXJlID0gZnVuY3Rpb24oYSwgb3V0KSB7XHJcblx0cmV0dXJuIHVuYXJ5QXJpdGhPcChhLCBvdXQsIHRoaXMsXHJcblx0XHRVbmFyeU9wZXJhdGlvblJlcXVlc3QuVHlwZS5TUVVBUkUpO1xyXG59O1xyXG5cclxuUEJDb250ZXh0LnByb3RvdHlwZS5taW4gPSBmdW5jdGlvbihhLCBheGlzKSB7XHJcblx0aWYgKHR5cGVvZiBheGlzID09PSBcInVuZGVmaW5lZFwiKSB7XHJcblx0XHRyZXR1cm4gcmVkdWNlQXJpdGhPcChhLCB1bmRlZmluZWQsIHRoaXMsXHJcblx0XHRcdFJlZHVjdGlvblJlcXVlc3QuVHlwZS5NSU4pO1xyXG5cdH0gZWxzZSBpZiAodXRpbC5pc0ludChheGlzKSkge1xyXG5cdFx0cmV0dXJuIGF4aXNSZWR1Y2VBcml0aE9wKGEsIGF4aXMsIHVuZGVmaW5lZCwgdGhpcyxcclxuXHRcdFx0QXhpc1JlZHVjdGlvblJlcXVlc3QuVHlwZS5NSU4pO1xyXG5cdH0gZWxzZSB7XHJcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5zdXBwb3J0ZWQgYXhpcyB0eXBlXCIpO1xyXG5cdH1cclxufTtcclxuXHJcblBCQ29udGV4dC5wcm90b3R5cGUubWF4ID0gZnVuY3Rpb24oYSwgYXhpcykge1xyXG5cdGlmICh0eXBlb2YgYXhpcyA9PT0gXCJ1bmRlZmluZWRcIikge1xyXG5cdFx0cmV0dXJuIHJlZHVjZUFyaXRoT3AoYSwgdW5kZWZpbmVkLCB0aGlzLFxyXG5cdFx0XHRSZWR1Y3Rpb25SZXF1ZXN0LlR5cGUuTUFYKTtcclxuXHR9IGVsc2UgaWYgKHV0aWwuaXNJbnQoYXhpcykpIHtcclxuXHRcdHJldHVybiBheGlzUmVkdWNlQXJpdGhPcChhLCBheGlzLCB1bmRlZmluZWQsIHRoaXMsXHJcblx0XHRcdEF4aXNSZWR1Y3Rpb25SZXF1ZXN0LlR5cGUuTUFYKTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihcIlVuc3VwcG9ydGVkIGF4aXMgdHlwZVwiKTtcclxuXHR9XHJcbn07XHJcblxyXG5QQkNvbnRleHQucHJvdG90eXBlLnN1bSA9IGZ1bmN0aW9uKGEsIGF4aXMpIHtcclxuXHRpZiAodHlwZW9mIGF4aXMgPT09IFwidW5kZWZpbmVkXCIpIHtcclxuXHRcdHJldHVybiByZWR1Y2VBcml0aE9wKGEsIHVuZGVmaW5lZCwgdGhpcyxcclxuXHRcdFx0UmVkdWN0aW9uUmVxdWVzdC5UeXBlLlNVTSk7XHJcblx0fSBlbHNlIGlmICh1dGlsLmlzSW50KGF4aXMpKSB7XHJcblx0XHRyZXR1cm4gYXhpc1JlZHVjZUFyaXRoT3AoYSwgYXhpcywgdW5kZWZpbmVkLCB0aGlzLFxyXG5cdFx0XHRBeGlzUmVkdWN0aW9uUmVxdWVzdC5UeXBlLlNVTSk7XHJcblx0fSBlbHNlIHtcclxuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoXCJVbnN1cHBvcnRlZCBheGlzIHR5cGVcIik7XHJcblx0fVxyXG59O1xyXG5cclxuUEJDb250ZXh0LnByb3RvdHlwZS5kb3QgPSBmdW5jdGlvbihhLCBiLCBvdXQpIHtcclxuXHRyZXR1cm4gZG90QXJpdGhPcChhLCBiLCBvdXQsIHRoaXMpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBQQkNvbnRleHQ7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxudmFyIFBCQ29udGV4dCA9IHJlcXVpcmUoXCIuL1BCQ29udGV4dFwiKTtcclxuXHJcbmZ1bmN0aW9uIFBOYUNsQ29udGV4dChvcHRpb25zLCBjYWxsYmFjaykge1xyXG5cdHZhciBzZWxmID0gdGhpcztcclxuXHR0aGlzLl9wbmFjbE9iamVjdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJvYmplY3RcIik7XHJcblx0dGhpcy5fcG5hY2xPYmplY3Qud2lkdGggPSAwO1xyXG5cdHRoaXMuX3BuYWNsT2JqZWN0LmhlaWdodCA9IDA7XHJcblx0dGhpcy5fcG5hY2xPYmplY3QuZGF0YSA9IFBOYUNsQ29udGV4dC5nZXREZWZhdWx0TWFuaWZlc3RVUkwob3B0aW9ucy5iYXNlVXJsKTtcclxuXHR0aGlzLl9wbmFjbE9iamVjdC50eXBlID0gXCJhcHBsaWNhdGlvbi94LXBuYWNsXCI7XHJcblx0dGhpcy5fcG5hY2xPYmplY3QuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgZnVuY3Rpb24oZSkge1xyXG5cdFx0c2VsZi5fbWVzc2FnaW5nQ29udGV4dC5fb25NZXNzYWdlKGUpO1xyXG5cdH0sIHRydWUpO1xyXG5cdHRoaXMuX21lc3NhZ2luZ0NvbnRleHQgPSBuZXcgUEJDb250ZXh0KG9wdGlvbnMsIGZ1bmN0aW9uKG1lc3NhZ2UpIHtcclxuXHRcdHNlbGYuX3BuYWNsT2JqZWN0LnBvc3RNZXNzYWdlKG1lc3NhZ2UpO1xyXG5cdH0sIGNhbGxiYWNrKTtcclxuXHRkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuX3BuYWNsT2JqZWN0KTtcclxufVxyXG5cclxuUE5hQ2xDb250ZXh0LmlzU3VwcG9ydGVkID0gZnVuY3Rpb24oKSB7XHJcblx0dHJ5IHtcclxuXHRcdHJldHVybiAodHlwZW9mIG5hdmlnYXRvci5taW1lVHlwZXNbXCJhcHBsaWNhdGlvbi94LXBuYWNsXCJdKSAhPT0gXCJ1bmRlZmluZWRcIjtcclxuXHR9IGNhdGNoIChlKSB7XHJcblx0fVxyXG5cdHJldHVybiBmYWxzZTtcclxufTtcclxuXHJcblBOYUNsQ29udGV4dC5nZXRNYW5pZmVzdFVSTCA9IGZ1bmN0aW9uKGJhc2VVcmwpIHtcclxuXHRpZiAoYmFzZVVybCkge1xyXG5cdFx0cmV0dXJuIGJhc2VVcmwgKyBcImZ1cmlvdXMubm1mXCI7XHJcblx0fSBlbHNlIHtcclxuXHRcdHJldHVybiBcImZ1cmlvdXMubm1mXCI7XHJcblx0fVxyXG59O1xyXG5cclxuUE5hQ2xDb250ZXh0LnByb3RvdHlwZS5lbXB0eSA9IGZ1bmN0aW9uKHNoYXBlLCBkYXRhVHlwZSkge1xyXG5cdHJldHVybiB0aGlzLl9tZXNzYWdpbmdDb250ZXh0LmVtcHR5KHNoYXBlLCBkYXRhVHlwZSk7XHJcbn07XHJcblxyXG5QTmFDbENvbnRleHQucHJvdG90eXBlLnplcm9zID0gZnVuY3Rpb24oc2hhcGUsIGRhdGFUeXBlKSB7XHJcblx0cmV0dXJuIHRoaXMuX21lc3NhZ2luZ0NvbnRleHQuemVyb3Moc2hhcGUsIGRhdGFUeXBlKTtcclxufTtcclxuXHJcblBOYUNsQ29udGV4dC5wcm90b3R5cGUub25lcyA9IGZ1bmN0aW9uKHNoYXBlLCBkYXRhVHlwZSkge1xyXG5cdHJldHVybiB0aGlzLl9tZXNzYWdpbmdDb250ZXh0Lm9uZXMoc2hhcGUsIGRhdGFUeXBlKTtcclxufTtcclxuXHJcblBOYUNsQ29udGV4dC5wcm90b3R5cGUuYXJyYXkgPSBmdW5jdGlvbihkYXRhLCBkYXRhVHlwZSkge1xyXG5cdHJldHVybiB0aGlzLl9tZXNzYWdpbmdDb250ZXh0LmFycmF5KGRhdGEsIGRhdGFUeXBlKTtcclxufTtcclxuXHJcblBOYUNsQ29udGV4dC5wcm90b3R5cGUubGluc3BhY2UgPSBmdW5jdGlvbihzdGFydCwgc3RvcCwgc2FtcGxlcywgY2xvc2VkKSB7XHJcblx0cmV0dXJuIHRoaXMuX21lc3NhZ2luZ0NvbnRleHQubGluc3BhY2Uoc3RhcnQsIHN0b3AsIHNhbXBsZXMsIGNsb3NlZCk7XHJcbn07XHJcblxyXG5QTmFDbENvbnRleHQucHJvdG90eXBlLnJlc2hhcGUgPSBmdW5jdGlvbihhLCBzaGFwZSkge1xyXG5cdHJldHVybiB0aGlzLl9tZXNzYWdpbmdDb250ZXh0LnJlc2hhcGUoYSwgc2hhcGUpO1xyXG59O1xyXG5cclxuUE5hQ2xDb250ZXh0LnByb3RvdHlwZS5yZXBlYXQgPSBmdW5jdGlvbihhLCByZXBlYXRzLCBheGlzLCBvdXQpIHtcclxuXHRyZXR1cm4gdGhpcy5fbWVzc2FnaW5nQ29udGV4dC5yZXBlYXQoYSwgcmVwZWF0cywgYXhpcywgb3V0KTtcclxufTtcclxuXHJcblBOYUNsQ29udGV4dC5wcm90b3R5cGUuX2ludmFsaWRhdGUgPSBmdW5jdGlvbihhcnJheSkge1xyXG5cdHJldHVybiB0aGlzLl9tZXNzYWdpbmdDb250ZXh0Ll9pbnZhbGlkYXRlKGFycmF5KTtcclxufTtcclxuXHJcblBOYUNsQ29udGV4dC5wcm90b3R5cGUuZmV0Y2ggPSBmdW5jdGlvbigpIHtcclxuXHR0aGlzLl9tZXNzYWdpbmdDb250ZXh0LmZldGNoLmFwcGx5KHRoaXMuX21lc3NhZ2luZ0NvbnRleHQsIGFyZ3VtZW50cyk7XHJcbn07XHJcblxyXG5QTmFDbENvbnRleHQucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKCkge1xyXG5cdHRoaXMuX21lc3NhZ2luZ0NvbnRleHQuZ2V0LmFwcGx5KHRoaXMuX21lc3NhZ2luZ0NvbnRleHQsIGFyZ3VtZW50cyk7XHJcbn07XHJcblxyXG5QTmFDbENvbnRleHQucHJvdG90eXBlLmluZm8gPSBmdW5jdGlvbihjYWxsYmFjaykge1xyXG5cdHRoaXMuX21lc3NhZ2luZ0NvbnRleHQuaW5mbyhjYWxsYmFjayk7XHJcbn07XHJcblxyXG5QTmFDbENvbnRleHQucHJvdG90eXBlLmJhcnJpZXIgPSBmdW5jdGlvbihjYWxsYmFjaykge1xyXG5cdHRoaXMuX21lc3NhZ2luZ0NvbnRleHQuYmFycmllcihjYWxsYmFjayk7XHJcbn07XHJcblxyXG5QTmFDbENvbnRleHQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKGEsIGIsIG91dCkge1xyXG5cdHJldHVybiB0aGlzLl9tZXNzYWdpbmdDb250ZXh0LmFkZChhLCBiLCBvdXQpO1xyXG59O1xyXG5cclxuUE5hQ2xDb250ZXh0LnByb3RvdHlwZS5zdWIgPSBmdW5jdGlvbihhLCBiLCBvdXQpIHtcclxuXHRyZXR1cm4gdGhpcy5fbWVzc2FnaW5nQ29udGV4dC5zdWIoYSwgYiwgb3V0KTtcclxufTtcclxuXHJcblBOYUNsQ29udGV4dC5wcm90b3R5cGUubXVsID0gZnVuY3Rpb24oYSwgYiwgb3V0KSB7XHJcblx0cmV0dXJuIHRoaXMuX21lc3NhZ2luZ0NvbnRleHQubXVsKGEsIGIsIG91dCk7XHJcbn07XHJcblxyXG5QTmFDbENvbnRleHQucHJvdG90eXBlLmRpdiA9IGZ1bmN0aW9uKGEsIGIsIG91dCkge1xyXG5cdHJldHVybiB0aGlzLl9tZXNzYWdpbmdDb250ZXh0LmRpdihhLCBiLCBvdXQpO1xyXG59O1xyXG5cclxuUE5hQ2xDb250ZXh0LnByb3RvdHlwZS5uZWcgPSBmdW5jdGlvbihhLCBvdXQpIHtcclxuXHRyZXR1cm4gdGhpcy5fbWVzc2FnaW5nQ29udGV4dC5uZWcoYSwgb3V0KTtcclxufTtcclxuXHJcblBOYUNsQ29udGV4dC5wcm90b3R5cGUuYWJzID0gZnVuY3Rpb24oYSwgb3V0KSB7XHJcblx0cmV0dXJuIHRoaXMuX21lc3NhZ2luZ0NvbnRleHQuYWJzKGEsIG91dCk7XHJcbn07XHJcblxyXG5QTmFDbENvbnRleHQucHJvdG90eXBlLmV4cCA9IGZ1bmN0aW9uKGEsIG91dCkge1xyXG5cdHJldHVybiB0aGlzLl9tZXNzYWdpbmdDb250ZXh0LmV4cChhLCBvdXQpO1xyXG59O1xyXG5cclxuUE5hQ2xDb250ZXh0LnByb3RvdHlwZS5sb2cgPSBmdW5jdGlvbihhLCBvdXQpIHtcclxuXHRyZXR1cm4gdGhpcy5fbWVzc2FnaW5nQ29udGV4dC5sb2coYSwgb3V0KTtcclxufTtcclxuXHJcblBOYUNsQ29udGV4dC5wcm90b3R5cGUuc3FydCA9IGZ1bmN0aW9uKGEsIG91dCkge1xyXG5cdHJldHVybiB0aGlzLl9tZXNzYWdpbmdDb250ZXh0LnNxcnQoYSwgb3V0KTtcclxufTtcclxuXHJcblBOYUNsQ29udGV4dC5wcm90b3R5cGUuc3F1YXJlID0gZnVuY3Rpb24oYSwgb3V0KSB7XHJcblx0cmV0dXJuIHRoaXMuX21lc3NhZ2luZ0NvbnRleHQuc3F1YXJlKGEsIG91dCk7XHJcbn07XHJcblxyXG5QTmFDbENvbnRleHQucHJvdG90eXBlLm1pbiA9IGZ1bmN0aW9uKGEsIGF4aXMpIHtcclxuXHRyZXR1cm4gdGhpcy5fbWVzc2FnaW5nQ29udGV4dC5taW4oYSwgYXhpcyk7XHJcbn07XHJcblxyXG5QTmFDbENvbnRleHQucHJvdG90eXBlLm1heCA9IGZ1bmN0aW9uKGEsIGF4aXMpIHtcclxuXHRyZXR1cm4gdGhpcy5fbWVzc2FnaW5nQ29udGV4dC5tYXgoYSwgYXhpcyk7XHJcbn07XHJcblxyXG5QTmFDbENvbnRleHQucHJvdG90eXBlLnN1bSA9IGZ1bmN0aW9uKGEsIGF4aXMpIHtcclxuXHRyZXR1cm4gdGhpcy5fbWVzc2FnaW5nQ29udGV4dC5zdW0oYSwgYXhpcyk7XHJcbn07XHJcblxyXG5QTmFDbENvbnRleHQucHJvdG90eXBlLmRvdCA9IGZ1bmN0aW9uKGEsIGIsIG91dCkge1xyXG5cdHJldHVybiB0aGlzLl9tZXNzYWdpbmdDb250ZXh0LmRvdChhLCBiLCBvdXQpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBQTmFDbENvbnRleHQ7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxudmFyIG1lc3NhZ2VJZCA9IDE7XHJcbnZhciBhcnJheUlkID0gMTtcclxuXHJcbmV4cG9ydHMubmV3TWVzc2FnZUlkID0gZnVuY3Rpb24oKSB7XHJcblx0dmFyIGlkID0gbWVzc2FnZUlkO1xyXG5cdG1lc3NhZ2VJZCA9IChtZXNzYWdlSWQrMSl8MDtcclxuXHRyZXR1cm4gaWQ7XHJcbn07XHJcblxyXG5leHBvcnRzLm5ld0FycmF5SWQgPSBmdW5jdGlvbiAoKSB7XHJcblx0dmFyIGlkID0gYXJyYXlJZDtcclxuXHRhcnJheUlkID0gKGFycmF5SWQrMSl8MDtcclxuXHRyZXR1cm4gaWQ7XHJcbn07XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxuLyoqXHJcbiAqIFByb3ZpZGVzIGluZm9ybWF0aW9uIGFuZCBzdXBwb3J0IGZ1bmN0aW9uc1xyXG4gKlxyXG4gKiBAY2xhc3MgZnVyaW91c1xyXG4gKi9cclxuXHJcbnZhciBEYXRhVHlwZSA9IHJlcXVpcmUoXCIuL0RhdGFUeXBlXCIpO1xyXG52YXIgSlNDb250ZXh0ID0gcmVxdWlyZShcIi4vanMvSlNDb250ZXh0XCIpO1xyXG52YXIgV2ViV29ya2VyQ29udGV4dCA9IHJlcXVpcmUoXCIuL2pzL1dlYldvcmtlckNvbnRleHRcIik7XHJcbnZhciBQTmFDbENvbnRleHQgPSByZXF1aXJlKFwiLi9QTmFDbENvbnRleHRcIik7XHJcbnZhciBXZWJDTENvbnRleHQgPSByZXF1aXJlKFwiLi93ZWJjbC9XZWJDTENvbnRleHRcIik7XHJcblxyXG52YXIgY3VycmVudFNjcmlwdFVyaSA9IG51bGw7XHJcbnRyeSB7XHJcblx0Y3VycmVudFNjcmlwdFVyaSA9IGRvY3VtZW50LmN1cnJlbnRTY3JpcHQuc3JjO1xyXG59IGNhdGNoIChlKSB7XHJcblx0dHJ5IHtcclxuXHRcdHZhciBzY3JpcHRzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJzY3JpcHRcIik7XHJcblx0XHRjdXJyZW50U2NyaXB0VXJpID0gc2NyaXB0c1tzY3JpcHRzLmxlbmd0aCAtIDFdLnNyYztcclxuXHR9IGNhdGNoIChlKSB7XHJcblx0fVxyXG59XHJcbnZhciBjdXJyZW50U2NyaXB0RGlyID0gbnVsbDtcclxuaWYgKGN1cnJlbnRTY3JpcHRVcmkgIT09IG51bGwpIHtcclxuXHR2YXIgc2VwYXJhdG9yUG9zID0gY3VycmVudFNjcmlwdFVyaS5sYXN0SW5kZXhPZihcIi9cIik7XHJcblx0dmFyIGN1cnJlbnRTY3JpcHREaXIgPSBjdXJyZW50U2NyaXB0VXJpLnN1YnN0cigwLCBzZXBhcmF0b3JQb3MgKyAxKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEluaXRpYWxpemVzIGEgY29tcHV0YXRpb25hbCBjb250ZXh0LlxyXG4gKlxyXG4gKiBAc3RhdGljXHJcbiAqIEBtZXRob2QgaW5pdFxyXG4gKiBAYXN5bmNcclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IFtiYWNrZW5kXSAtIEEgc3RyaW5nIGlkZW50aWZpZXIgZm9yIHRoZSBiYWNrZW5kIHRvIHVzZS4gVGhlIGZvbGxvd2luZyB2YWx1ZXMgYXJlIHN1cHBvcnRlZDpcclxuICpcclxuICogICAgIDx0YWJsZT5cclxuICogICAgICAgICA8dHI+XHJcbiAqICAgICAgICAgICAgIDx0aD5CYWNrZW5kIElkZW50aWZpZXI8L3RoPlxyXG4gKiAgICAgICAgICAgICA8dGg+SW50ZXJwcmV0YXRpb248L3RoPlxyXG4gKiAgICAgICAgIDwvdHI+XHJcbiAqICAgICAgICAgPHRyPlxyXG4gKiAgICAgICAgICAgICA8dGQ+XCJqYXZhc2NyaXB0XCI8L3RkPlxyXG4gKiAgICAgICAgICAgICA8dGQ+SmF2YVNjcmlwdCBiYWNrZW5kLiBXb3JrcyBpbiBhbGwgYnJvd3NlcnMgYW5kIE5vZGUuanMsIGJ1dCBjYW4gbm90IGRlbGl2ZXIgb3B0aW1hbCBwZXJmb3JtYW5jZS48L3RkPlxyXG4gKiAgICAgICAgIDwvdHI+XHJcbiAqICAgICAgICAgPHRyPlxyXG4gKiAgICAgICAgICAgICA8dGQ+XCJwbmFjbFwiPC90ZD5cclxuICogICAgICAgICAgICAgPHRkPlBvcnRhYmxlIE5hdGl2ZSBDbGllbnQgKFBOYUNsKSBiYWNrZW5kLiBXb3JrcyBpbiBDaHJvbWl1bS1iYXNlZCBicm93c2Vycy4gQ2FuIGFjY2VsZXJhdGUgY29tcHV0YXRpb25zIHRocm91Z2ggdGhlIHVzZSBvZiBhZHZhbmNlZCBDUFUgb3B0aW1pemF0aW9uIHRlY2hub2xvZ2llcywgc3VjaCBhcyBtdWx0aS10aHJlYWRpbmcgYW5kIFNJTUQgaW5zdHJ1Y3Rpb25zLjwvdGQ+XHJcbiAqICAgICAgICAgPC90cj5cclxuICogICAgICAgICA8dHI+XHJcbiAqICAgICAgICAgICAgIDx0ZD5cIndlYmNsXCI8L3RkPlxyXG4gKiAgICAgICAgICAgICA8dGQ+V2ViQ0wgYmFja2VuZC4gV29ya3MgaW4gYnJvd3NlcnMgYW5kIE5vZGUuanMgd2hlbiBhIFdlYkNMIHBsdWdpbiBpcyBhdmFpbGFibGUuIENhbiB1c2UgZnVsbCBwb3dlciBvZiBDUFVzIGFuZCBHUFVzIHRvIGFjY2VsZXJhdGUgY29tcHV0YXRpb25zLjwvdGQ+XHJcbiAqICAgICAgICAgPC90cj5cclxuICogICAgIDwvdGFibGU+XHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gQmFja2VuZC1zcGVjaWZpYyBvcHRpb25zLlxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIEEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2hlbiB0aGUgYmFja2VuZCBmaW5pc2ggaW5pdGlhbGl6YXRpb24uXHJcbiAqIEBwYXJhbSB7Q29udGV4dH0gY2FsbGJhY2suY29udGV4dCAtIEEgcmVhZHkgdG8gdXNlIGNvbXB1dGF0aW9uYWwgY29udGV4dC5cclxuICovXHJcbnZhciBpbml0ID0gZnVuY3Rpb24oYmFja2VuZCwgb3B0aW9ucywgY2FsbGJhY2spIHtcclxuXHRpZiAodHlwZW9mIGNhbGxiYWNrID09PSBcInVuZGVmaW5lZFwiKSB7XHJcblx0XHRpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwidW5kZWZpbmVkXCIpIHtcclxuXHRcdFx0LyogQ2FsbGVkIHdpdGggb25lIHBhcmFtZXRlcjogY2FsbGJhY2sgKi9cclxuXHRcdFx0Y2FsbGJhY2sgPSBiYWNrZW5kO1xyXG5cdFx0XHRvcHRpb25zID0gdW5kZWZpbmVkO1xyXG5cdFx0XHRiYWNrZW5kID0gdW5kZWZpbmVkO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0LyogQ2FsbGVkIHdpdGggdHdvIHBhcmFtZXRlcnM6IGJhY2tlbmQgYW5kIGNhbGxiYWNrICovXHJcblx0XHRcdGNhbGxiYWNrID0gb3B0aW9ucztcclxuXHRcdFx0b3B0aW9ucyA9IHVuZGVmaW5lZDtcclxuXHRcdH1cclxuXHR9XHJcblx0aWYgKHR5cGVvZiBiYWNrZW5kID09PSBcInVuZGVmaW5lZFwiKSB7XHJcblx0XHRiYWNrZW5kID0gZ2V0RGVmYXVsdEJhY2tlbmQoKTtcclxuXHR9XHJcblx0aWYgKHR5cGVvZiBvcHRpb25zID09PSBcInVuZGVmaW5lZFwiKSB7XHJcblx0XHRvcHRpb25zID0ge307XHJcblx0fVxyXG5cdGlmIChiYWNrZW5kID09PSBcImphdmFzY3JpcHRcIikge1xyXG5cdFx0dmFyIGFzeW5jID0gb3B0aW9ucy5hc3luYztcclxuXHRcdGlmICh0eXBlb2YgYXN5bmMgPT09IFwidW5kZWZpbmVkXCIpIHtcclxuXHRcdFx0YXN5bmMgPSBXZWJXb3JrZXJDb250ZXh0LmlzU3VwcG9ydGVkKCk7XHJcblx0XHR9XHJcblx0XHRpZiAoYXN5bmMpIHtcclxuXHRcdFx0b3B0aW9ucy5iYXNlVXJsID0gY3VycmVudFNjcmlwdERpcjtcclxuXHRcdFx0cmV0dXJuIG5ldyBXZWJXb3JrZXJDb250ZXh0KG9wdGlvbnMsIGNhbGxiYWNrKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHJldHVybiBuZXcgSlNDb250ZXh0KG9wdGlvbnMsIGNhbGxiYWNrKTtcclxuXHRcdH1cclxuXHR9IGVsc2UgaWYgKGJhY2tlbmQgPT09IFwicG5hY2xcIikge1xyXG5cdFx0b3B0aW9ucy5iYXNlVXJsID0gY3VycmVudFNjcmlwdERpcjtcclxuXHRcdHJldHVybiBuZXcgUE5hQ2xDb250ZXh0KG9wdGlvbnMsIGNhbGxiYWNrKTtcclxuXHR9IGVsc2UgaWYgKGJhY2tlbmQgPT09IFwid2ViY2xcIikge1xyXG5cdFx0cmV0dXJuIG5ldyBXZWJDTENvbnRleHQob3B0aW9ucywgY2FsbGJhY2spO1xyXG5cdH0gZWxzZSB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBiYWNrZW5kOiBcIiArIGJhY2tlbmQpO1xyXG5cdH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBEZXRlY3RzIHRoZSBvcHRpbWFsIGJhY2tlbmQgc3VwcG9ydGVkIGJ5IHRoZSBicm93c2VyIG9yIEphdmFTY3JpcHQgZW5naW5lLlxyXG4gKlxyXG4gKiBAc3RhdGljXHJcbiAqIEBtZXRob2QgZ2V0RGVmYXVsdEJhY2tlbmRcclxuICpcclxuICogQHJldHVybiB7U3RyaW5nfSAtIERlZmF1bHQgYmFja2VuZCBpZGVudGlmaWVyIGZyb20gdGhlIGZvbGxvd2luZyB0YWJsZTpcclxuICpcclxuICogICAgIDx0YWJsZT5cclxuICogICAgICAgICA8dHI+XHJcbiAqICAgICAgICAgICAgIDx0aD5CYWNrZW5kIElkZW50aWZpZXI8L3RoPlxyXG4gKiAgICAgICAgICAgICA8dGg+SW50ZXJwcmV0YXRpb248L3RoPlxyXG4gKiAgICAgICAgIDwvdHI+XHJcbiAqICAgICAgICAgPHRyPlxyXG4gKiAgICAgICAgICAgICA8dGQ+XCJqYXZhc2NyaXB0XCI8L3RkPlxyXG4gKiAgICAgICAgICAgICA8dGQ+SmF2YVNjcmlwdCBiYWNrZW5kLiBXb3JrcyBpbiBhbGwgYnJvd3NlcnMgYW5kIE5vZGUuanMsIGJ1dCBjYW4gbm90IGRlbGl2ZXIgb3B0aW1hbCBwZXJmb3JtYW5jZS48L3RkPlxyXG4gKiAgICAgICAgIDwvdHI+XHJcbiAqICAgICAgICAgPHRyPlxyXG4gKiAgICAgICAgICAgICA8dGQ+XCJhc21qc1wiPC90ZD5cclxuICogICAgICAgICAgICAgPHRkPkFzbS5qcyBiYWNrZW5kLiBXb3JrcyBpbiBGaXJlZm94IDI5IGFuZCBsYXRlci4gQ2FuIGFjY2VsZXJhdGUgY29tcHV0YXRpb25zIHdpdGggYSBsaW1pdGVkIHVzZSBvZiBuYXRpdmUgQ1BVIGluc3RydWN0aW9ucy48L3RkPlxyXG4gKiAgICAgICAgIDwvdHI+XHJcbiAqICAgICAgICAgPHRyPlxyXG4gKiAgICAgICAgICAgICA8dGQ+XCJwbmFjbFwiPC90ZD5cclxuICogICAgICAgICAgICAgPHRkPlBvcnRhYmxlIE5hdGl2ZSBDbGllbnQgKFBOYUNsKSBiYWNrZW5kLiBXb3JrcyBpbiBDaHJvbWl1bS1iYXNlZCBicm93c2Vycy4gQ2FuIGFjY2VsZXJhdGUgY29tcHV0YXRpb25zIHRocm91Z2ggdGhlIHVzZSBvZiBhZHZhbmNlZCBDUFUgb3B0aW1pemF0aW9uIHRlY2hub2xvZ2llcywgc3VjaCBhcyBtdWx0aS10aHJlYWRpbmcgYW5kIFNJTUQgaW5zdHJ1Y3Rpb25zLjwvdGQ+XHJcbiAqICAgICAgICAgPC90cj5cclxuICogICAgICAgICA8dHI+XHJcbiAqICAgICAgICAgICAgIDx0ZD5cIndlYmNsXCI8L3RkPlxyXG4gKiAgICAgICAgICAgICA8dGQ+V2ViQ0wgYmFja2VuZC4gV29ya3MgaW4gYnJvd3NlcnMgYW5kIE5vZGUuanMgd2hlbiBhIFdlYkNMIHBsdWdpbiBpcyBhdmFpbGFibGUuIENhbiB1c2UgZnVsbCBwb3dlciBvZiBDUFVzIGFuZCBHUFVzIHRvIGFjY2VsZXJhdGUgY29tcHV0YXRpb25zLjwvdGQ+XHJcbiAqICAgICAgICAgPC90cj5cclxuICogICAgIDwvdGFibGU+XHJcbiAqL1xyXG52YXIgZ2V0RGVmYXVsdEJhY2tlbmQgPSBmdW5jdGlvbigpIHtcclxuXHRpZiAoV2ViQ0xDb250ZXh0LmlzVXNhYmxlKCkpIHtcclxuXHRcdHJldHVybiBcIndlYmNsXCI7XHJcblx0fSBlbHNlIGlmIChQTmFDbENvbnRleHQuaXNTdXBwb3J0ZWQoKSkge1xyXG5cdFx0cmV0dXJuIFwicG5hY2xcIjtcclxuXHR9IGVsc2Uge1xyXG5cdFx0cmV0dXJuIFwiamF2YXNjcmlwdFwiO1xyXG5cdH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBEZXRlY3RzIHdoaWNoIGJhY2tlbmRzIGFyZSBzdXBwb3J0ZWQgYnkgdGhlIHN5c3RlbS5cclxuICpcclxuICogQHN0YXRpY1xyXG4gKiBAbWV0aG9kIGdldFN1cHBvcnRlZEJhY2tlbmRzXHJcbiAqXHJcbiAqIEByZXR1cm4ge1N0cmluZ1tdfSAtIEFuIGFycmF5IG9mIHN1cHBvcnRlZCBiYWNrZW5kIGlkZW50aWZpZXJzIGluIHByaW9yaXR5IG9yZGVyIChwcmlvcml0aXplZCBiYWNrZW5kcyBmaXJzdCkuIFRoZSBmb2xsb3dpbmcgaWRlbnRpZmllcnMgY291bGQgYmUgcHJlc2VudDpcclxuICpcclxuICogICAgIDx0YWJsZT5cclxuICogICAgICAgICA8dHI+XHJcbiAqICAgICAgICAgICAgIDx0aD5CYWNrZW5kIElkZW50aWZpZXI8L3RoPlxyXG4gKiAgICAgICAgICAgICA8dGg+SW50ZXJwcmV0YXRpb248L3RoPlxyXG4gKiAgICAgICAgIDwvdHI+XHJcbiAqICAgICAgICAgPHRyPlxyXG4gKiAgICAgICAgICAgICA8dGQ+XCJqYXZhc2NyaXB0XCI8L3RkPlxyXG4gKiAgICAgICAgICAgICA8dGQ+SmF2YVNjcmlwdCBiYWNrZW5kLiBXb3JrcyBpbiBhbGwgYnJvd3NlcnMgYW5kIE5vZGUuanMsIGJ1dCBjYW4gbm90IGRlbGl2ZXIgb3B0aW1hbCBwZXJmb3JtYW5jZS48L3RkPlxyXG4gKiAgICAgICAgIDwvdHI+XHJcbiAqICAgICAgICAgPHRyPlxyXG4gKiAgICAgICAgICAgICA8dGQ+XCJhc21qc1wiPC90ZD5cclxuICogICAgICAgICAgICAgPHRkPkFzbS5qcyBiYWNrZW5kLiBXb3JrcyBpbiBGaXJlZm94IDI5IGFuZCBsYXRlci4gQ2FuIGFjY2VsZXJhdGUgY29tcHV0YXRpb25zIHdpdGggYSBsaW1pdGVkIHVzZSBvZiBuYXRpdmUgQ1BVIGluc3RydWN0aW9ucy48L3RkPlxyXG4gKiAgICAgICAgIDwvdHI+XHJcbiAqICAgICAgICAgPHRyPlxyXG4gKiAgICAgICAgICAgICA8dGQ+XCJwbmFjbFwiPC90ZD5cclxuICogICAgICAgICAgICAgPHRkPlBvcnRhYmxlIE5hdGl2ZSBDbGllbnQgKFBOYUNsKSBiYWNrZW5kLiBXb3JrcyBpbiBDaHJvbWl1bS1iYXNlZCBicm93c2Vycy4gQ2FuIGFjY2VsZXJhdGUgY29tcHV0YXRpb25zIHRocm91Z2ggdGhlIHVzZSBvZiBhZHZhbmNlZCBDUFUgb3B0aW1pemF0aW9uIHRlY2hub2xvZ2llcywgc3VjaCBhcyBtdWx0aS10aHJlYWRpbmcgYW5kIFNJTUQgaW5zdHJ1Y3Rpb25zLjwvdGQ+XHJcbiAqICAgICAgICAgPC90cj5cclxuICogICAgICAgICA8dHI+XHJcbiAqICAgICAgICAgICAgIDx0ZD5cIndlYmNsXCI8L3RkPlxyXG4gKiAgICAgICAgICAgICA8dGQ+V2ViQ0wgYmFja2VuZC4gV29ya3MgaW4gYnJvd3NlcnMgYW5kIE5vZGUuanMgd2hlbiBhIFdlYkNMIHBsdWdpbiBpcyBhdmFpbGFibGUuIENhbiB1c2UgZnVsbCBwb3dlciBvZiBDUFVzIGFuZCBHUFVzIHRvIGFjY2VsZXJhdGUgY29tcHV0YXRpb25zLjwvdGQ+XHJcbiAqICAgICAgICAgPC90cj5cclxuICogICAgIDwvdGFibGU+XHJcbiAqL1xyXG52YXIgZ2V0U3VwcG9ydGVkQmFja2VuZHMgPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgYmFja2VuZHMgPSBbXTtcclxuXHRpZiAoV2ViQ0xDb250ZXh0LmlzVXNhYmxlKCkpIHtcclxuXHRcdGJhY2tlbmRzLnB1c2goXCJ3ZWJjbFwiKTtcclxuXHR9XHJcblx0aWYgKFBOYUNsQ29udGV4dC5pc1N1cHBvcnRlZCgpKSB7XHJcblx0XHRiYWNrZW5kcy5wdXNoKFwicG5hY2xcIik7XHJcblx0fVxyXG5cdGlmIChoYXNGZWF0dXJlKFwiYXNtLmpzXCIpKSB7XHJcblx0XHRiYWNrZW5kcy5wdXNoKFwiYXNtLmpzXCIpO1xyXG5cdH1cclxuXHRiYWNrZW5kcy5wdXNoKFwiamF2YXNjcmlwdFwiKTtcclxuXHRyZXR1cm4gYmFja2VuZHM7XHJcbn07XHJcblxyXG4vKipcclxuICogUXVlcmllcyBwb3NzaWJsZSBiYWNrZW5kIG9wdGlvbnMgYXZhaWxhYmxlIG9uIHRoaXMgcGxhdGZvcm0uXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBiYWNrZW5kIC0gbmFtZSBvZiB0aGUgYmFja2VuZCB0byBxdWVyeSBvcHRpb25zIGZvci5cclxuICpcclxuICogQHN0YXRpY1xyXG4gKiBAbWV0aG9kIGdldEJhY2tlbmRPcHRpb25zXHJcbiAqXHJcbiAqIEByZXR1cm4ge09iamVjdH0gLSBBbiBvYmplY3QgdGhhdCBkZXNjcmliZXMgYXZhaWxhYmxlIG9wdGlvbnMuXHJcbiAqIFRoZSBuYW1lcyBvZiBvYmplY3QncyBwcm9wZXJ0aWVzIGNvcnJlc3BvbmQgdG8gYmFja2VuZCBvcHRpb24gbmFtZXMuXHJcbiAqIE9iamVjdCdzIHByb3BlcnRpZXMgaGF2ZSBhcnJheSB2YWx1ZXMgd2l0aCBwb3NzaWJsZSBvcHRpb24gdmFsdWVzLlxyXG4gKiBCZWxvdyBhcmUgdGhlIGJhY2tlbmQgb3B0aW9ucyBmb3IgdGhlIGJ1aWx0LWluIGJhY2tlbmRzOlxyXG4gKlxyXG4gKiAgICAgPHRhYmxlPlxyXG4gKiAgICAgICAgIDxjYXB0aW9uPk9wdGlvbnMgb2YgXCJqYXZhc2NyaXB0XCIgYW5kIFwiYXNtanNcIiBiYWNrZW5kczwvY2FwdGlvbj5cclxuICogICAgICAgICA8dHI+XHJcbiAqICAgICAgICAgICAgIDx0aD5PcHRpb24gbmFtZTwvdGg+XHJcbiAqICAgICAgICAgICAgIDx0aD5PcHRpb24gdmFsdWVzPC90aD5cclxuICogICAgICAgICAgICAgPHRoPkRlZmF1bHQgdmFsdWU8L3RoPlxyXG4gKiAgICAgICAgIDwvdHI+XHJcbiAqICAgICAgICAgPHRyPlxyXG4gKiAgICAgICAgICAgICA8dGQ+XCJhc3luY1wiPC90ZD5cclxuICogICAgICAgICAgICAgPHRkPlt0cnVlLCBmYWxzZV08L3RkPlxyXG4gKiAgICAgICAgICAgICA8dGQ+dHJ1ZTwvdGQ+XHJcbiAqICAgICAgICAgPC90cj5cclxuICogICAgIDwvdGFibGU+XHJcbiAqXHJcbiAqICAgICA8dGFibGU+XHJcbiAqICAgICAgICAgPGNhcHRpb24+T3B0aW9ucyBvZiBcInBuYWNsXCIgYmFja2VuZDwvY2FwdGlvbj5cclxuICogICAgICAgICA8dHI+XHJcbiAqICAgICAgICAgICAgIDx0aD5PcHRpb24gbmFtZTwvdGg+XHJcbiAqICAgICAgICAgICAgIDx0aD5PcHRpb24gdmFsdWVzPC90aD5cclxuICogICAgICAgICAgICAgPHRoPkRlZmF1bHQgdmFsdWU8L3RoPlxyXG4gKiAgICAgICAgIDwvdHI+XHJcbiAqICAgICAgICAgPHRyPlxyXG4gKiAgICAgICAgICAgICA8dGQ+XCJtYW5pZmVzdFwiPC90ZD5cclxuICogICAgICAgICAgICAgPHRkPnVuZGVmaW5lZDwvdGQ+XHJcbiAqICAgICAgICAgICAgIDx0ZD5VUkwgb2YgXCJmdXJpb3VzLm5tZlwiIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5IGFzIFwiZnVyaW91cy5qc1wiIGxpYnJhcnk8L3RkPlxyXG4gKiAgICAgICAgIDwvdHI+XHJcbiAqICAgICA8L3RhYmxlPlxyXG4gKlxyXG4gKiAgICAgPHRhYmxlPlxyXG4gKiAgICAgICAgIDxjYXB0aW9uPk9wdGlvbnMgb2YgXCJ3ZWJjbFwiIGJhY2tlbmQ8L2NhcHRpb24+XHJcbiAqICAgICAgICAgPHRyPlxyXG4gKiAgICAgICAgICAgICA8dGg+T3B0aW9uIG5hbWU8L3RoPlxyXG4gKiAgICAgICAgICAgICA8dGg+T3B0aW9uIHZhbHVlczwvdGg+XHJcbiAqICAgICAgICAgICAgIDx0aD5EZWZhdWx0IHZhbHVlPC90aD5cclxuICogICAgICAgICA8L3RyPlxyXG4gKiAgICAgICAgIDx0cj5cclxuICogICAgICAgICAgICAgPHRkPlwiZGV2aWNlXCI8L3RkPlxyXG4gKiAgICAgICAgICAgICA8dGQ+RGVwZW5kcyBvbiB0aGUgcGxhdGZvcm08L3RkPlxyXG4gKiAgICAgICAgICAgICA8dGQ+RGlzY3JldGUgR1BVIGRldmljZSwgaWYgYXZhaWxhYmxlLiBPdGhlcndpc2UgaW50ZWdyYXRlZCBHUFUgZGV2aWNlLCBpZiBhdmFpbGFibGUuIE90aGVyd2lzZSBDUFUgZGV2aWNlLjwvdGQ+XHJcbiAqICAgICAgICAgPC90cj5cclxuICogICAgIDwvdGFibGU+XHJcbiAqL1xyXG52YXIgZ2V0QmFja2VuZE9wdGlvbnMgPSBmdW5jdGlvbihiYWNrZW5kKSB7XHJcblx0aWYgKGJhY2tlbmQgPT09IFwiamF2YXNjcmlwdFwiKSB7XHJcblx0XHRpZiAoV2ViV29ya2VyQ29udGV4dC5pc1N1cHBvcnRlZCgpKSB7XHJcblx0XHRcdHJldHVybiB7XHJcblx0XHRcdFx0XCJhc3luY1wiOiBbdHJ1ZSwgZmFsc2VdXHJcblx0XHRcdH07XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRyZXR1cm4ge307XHJcblx0XHR9XHJcblx0fSBlbHNlIGlmIChiYWNrZW5kID09PSBcInBuYWNsXCIpIHtcclxuXHRcdHJldHVybiB7fTtcclxuXHR9IGVsc2UgaWYgKGJhY2tlbmQgPT09IFwid2ViY2xcIikge1xyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0XCJkZXZpY2VcIjogV2ViQ0xDb250ZXh0LmdldEF2YWlsYWJsZURldmljZXMoKVxyXG5cdFx0fTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgYmFja2VuZDogXCIgKyBiYWNrZW5kKTtcclxuXHR9XHJcbn07XHJcblxyXG4vKipcclxuICogUXVlcmllcyBkZWZhdWx0IGJhY2tlbmQgb3B0aW9ucyBvbiB0aGlzIHBsYXRmb3JtLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gYmFja2VuZCAtIG5hbWUgb2YgdGhlIGJhY2tlbmQgdG8gcXVlcnkgb3B0aW9ucyBmb3IuXHJcbiAqXHJcbiAqIEBzdGF0aWNcclxuICogQG1ldGhvZCBnZXRCYWNrZW5kT3B0aW9uc1xyXG4gKlxyXG4gKiBAcmV0dXJuIHtPYmplY3R9IC0gQW4gb2JqZWN0IHRoYXQgZGVzY3JpYmVzIGF2YWlsYWJsZSBvcHRpb25zLlxyXG4gKiBUaGUgbmFtZXMgb2Ygb2JqZWN0J3MgcHJvcGVydGllcyBjb3JyZXNwb25kIHRvIGJhY2tlbmQgb3B0aW9uIG5hbWVzLlxyXG4gKiBUaGUgdmFsdWVzIG9mIG9iamVjdCdzIHByb3BlcnRpZXMgY29ycmVzcG9uZCB0byBkZWZhdWx0IG9wdGlvbiB2YWx1ZXMuXHJcbiAqL1xyXG52YXIgZ2V0RGVmYXVsdEJhY2tlbmRPcHRpb25zID0gZnVuY3Rpb24oYmFja2VuZCkge1xyXG5cdGlmIChiYWNrZW5kID09PSBcImphdmFzY3JpcHRcIikge1xyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0XCJhc3luY1wiOiB0cnVlXHJcblx0XHR9O1xyXG5cdH0gZWxzZSBpZiAoYmFja2VuZCA9PT0gXCJwbmFjbFwiKSB7XHJcblx0XHRpZiAoUE5hQ2xDb250ZXh0LmlzU3VwcG9ydGVkKCkpIHtcclxuXHRcdFx0cmV0dXJuIHtcclxuXHRcdFx0XHRcIm1hbmlmZXN0XCI6IFBOYUNsQ29udGV4dC5nZXREZWZhdWx0TWFuaWZlc3RVUkwoKVxyXG5cdFx0XHR9O1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cmV0dXJuIHt9O1xyXG5cdFx0fVxyXG5cdH0gZWxzZSBpZiAoYmFja2VuZCA9PT0gXCJ3ZWJjbFwiKSB7XHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHRcImRldmljZVwiOiBXZWJDTENvbnRleHQuZ2V0RGVmYXVsdERldmljZSgpXHJcblx0XHR9O1xyXG5cdH0gZWxzZSB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBiYWNrZW5kOiBcIiArIGJhY2tlbmQpO1xyXG5cdH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBEZXRlY3RzIHdoZXRoZXIgdGhlIHJlcXVlc3RlZCBjb21wdXRpbmcgZmVhdHVyZSBpcyBhdmFpbGFibGVcclxuICpcclxuICogQHN0YXRpY1xyXG4gKiBAbWV0aG9kIGhhc0ZlYXR1cmVcclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSBhbiBpZGVudGlmaWVyIG9mIHRoZSBvcHRpb25hbCBmZWF0dXJlIHRvIGRldGVjdC4gVGhlIGZvbGxvd2luZyBpZGVudGlmaWVycyBhcmUgc3VwcG9ydGVkOlxyXG4gKlxyXG4gKiAgICAgPHRhYmxlPlxyXG4gKiAgICAgICAgIDx0cj5cclxuICogICAgICAgICAgICAgPHRoPkZlYXR1cmUgSWRlbnRpZmllcjwvdGg+XHJcbiAqICAgICAgICAgICAgIDx0aD5JbnRlcnByZXRhdGlvbjwvdGg+XHJcbiAqICAgICAgICAgPC90cj5cclxuICogICAgICAgICA8dHI+XHJcbiAqICAgICAgICAgICAgIDx0ZD5cIndlYndvcmtlcnNcIjwvdGQ+XHJcbiAqICAgICAgICAgICAgIDx0ZD5EZXRlY3QgaWYgdGhlIEphdmFTY3JpcHQgZW5naW5lIGNhbiBzcGF3biBkZWRpY2F0ZWQgV2ViIFdvcmtlcnMuPC90ZD5cclxuICogICAgICAgICA8L3RyPlxyXG4gKiAgICAgICAgIDx0cj5cclxuICogICAgICAgICAgICAgPHRkPlwiYXNtLmpzXCI8L3RkPlxyXG4gKiAgICAgICAgICAgICA8dGQ+RGV0ZWN0IGlmIHRoZSBKYXZhU2NyaXB0IGVuZ2luZSByZWNvZ25pemVzIEFzbS5qcyBkaXJlY3RpdmUuPC90ZD5cclxuICogICAgICAgICA8L3RyPlxyXG4gKiAgICAgICAgIDx0cj5cclxuICogICAgICAgICAgICAgPHRkPlwic2ltZC5qc1wiPC90ZD5cclxuICogICAgICAgICAgICAgPHRkPkRldGVjdCBpZiB0aGUgSmF2YVNjcmlwdCBlbmdpbmUgcHJvdmlkZSBTSU1ELmZsb2F0MzJ4NCwgU0lNRC5pbnQzMng0LCBGbG9hdDMyeDRBcnJheSwgYW5kIEludDMyeDRBcnJheSBvZiBTSU1ELmpzPC90ZD5cclxuICogICAgICAgICA8L3RyPlxyXG4gKiAgICAgICAgIDx0cj5cclxuICogICAgICAgICAgICAgPHRkPlwid2ViZ2xcIjwvdGQ+XHJcbiAqICAgICAgICAgICAgIDx0ZD5EZXRlY3QgaWYgdGhlIGVudmlyb25tZW50IHN1cHBvcnRzIFdlYkdMIChlaXRoZXIgZXhwZXJpbWVudGFsIG9yIHN0YWJsZSBpbXBsZW1lbnRhdGlvbik8L3RkPlxyXG4gKiAgICAgICAgIDwvdHI+XHJcbiAqICAgICAgICAgPHRyPlxyXG4gKiAgICAgICAgICAgICA8dGQ+XCJ3ZWJjbFwiPC90ZD5cclxuICogICAgICAgICAgICAgPHRkPkRldGVjdCBpZiB0aGUgZW52aXJvbm1lbnQgc3VwcG9ydHMgV2ViQ0w8L3RkPlxyXG4gKiAgICAgICAgIDwvdHI+XHJcbiAqICAgICAgICAgPHRyPlxyXG4gKiAgICAgICAgICAgICA8dGQ+XCJwbmFjbFwiPC90ZD5cclxuICogICAgICAgICAgICAgPHRkPkRldGVjdCBpZiBQb3J0YWJsZSBOYXRpdmUgQ2xpZW50IChQTmFDbCkgaXMgc3VwcG9ydGVkIGFuZCBlbmFibGVkPC90ZD5cclxuICogICAgICAgICA8L3RyPlxyXG4gKiAgICAgICAgIDx0cj5cclxuICogICAgICAgICAgICAgPHRkPlwibmFjbFwiPC90ZD5cclxuICogICAgICAgICAgICAgPHRkPkRldGVjdCBpZiBOYXRpdmUgQ2xpZW50IChOYUNsKSBpcyBzdXBwb3J0ZWQgYW5kIGVuYWJsZWQ8L3RkPlxyXG4gKiAgICAgICAgIDwvdHI+XHJcbiAqICAgICA8L3RhYmxlPlxyXG4gKlxyXG4gKiBAcmV0dXJuIHtCb29sZWFufSAtIHRydWUgaWYgdGhlIGZlYXR1cmUgaXMgc3VwcG9ydGVkLCBmYWxzZSBvdGhlcndpc2VcclxuICovXHJcbnZhciBoYXNGZWF0dXJlID0gZnVuY3Rpb24obmFtZSkge1xyXG5cdHN3aXRjaCAobmFtZSkge1xyXG5cdFx0Y2FzZSBcImFzbS5qc1wiOlxyXG5cdFx0XHR0cnkge1xyXG5cdFx0XHRcdHZhciB1c2VyQWdlbnQgPSB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudDtcclxuXHRcdFx0XHR2YXIgdXNlckFnZW50Q29tcG9uZW50cyA9IHVzZXJBZ2VudC5zcGxpdCgvXFxzKy8pO1xyXG5cdFx0XHRcdHZhciBmaXJlZm94UmVnZXhwID0gL1tGZl1pcmVmb3hcXC8oXFxkKykvZztcclxuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHVzZXJBZ2VudENvbXBvbmVudHMubGVuZ3RoOyArK2kpIHtcclxuXHRcdFx0XHRcdHZhciBjb21wb25lbnQgPSB1c2VyQWdlbnRDb21wb25lbnRzW2ldO1xyXG5cdFx0XHRcdFx0dmFyIG1hdGNoID0gZmlyZWZveFJlZ2V4cC5leGVjKGNvbXBvbmVudCk7XHJcblx0XHRcdFx0XHRpZiAobWF0Y2ggIT09IG51bGwpIHtcclxuXHRcdFx0XHRcdFx0dmFyIGZpcmVmb3hWZXJzaW9uID0gcGFyc2VJbnQobWF0Y2hbMV0pO1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gZmlyZWZveFZlcnNpb24gPj0gMjk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0fSBjYXRjaCAoZSkge1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdGNhc2UgXCJzaW1kLmpzXCI6XHJcblx0XHRcdHJldHVybiAodHlwZW9mIFNJTUQgIT09IFwidW5kZWZpbmVkXCIpICYmXHJcblx0XHRcdFx0KHR5cGVvZiBGbG9hdDMyeDRBcnJheSAhPT0gXCJ1bmRlZmluZWRcIikgJiZcclxuXHRcdFx0XHQodHlwZW9mIEludDMyeDRBcnJheSAhPT0gXCJ1bmRlZmluZWRcIik7XHJcblx0XHRjYXNlIFwid2Vid29ya2Vyc1wiOlxyXG5cdFx0XHRyZXR1cm4gKHR5cGVvZiBXb3JrZXIgIT09IFwidW5kZWZpbmVkXCIpO1xyXG5cdFx0Y2FzZSBcIndlYmdsXCI6XHJcblx0XHRcdHRyeSB7XHJcblx0XHRcdFx0dmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XHJcblx0XHRcdFx0dHJ5IHtcclxuXHRcdFx0XHRcdGlmIChjYW52YXMuZ2V0Q29udGV4dChcIndlYmdsXCIpICE9PSBudWxsKSB7XHJcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0gY2F0Y2ggKGUpIHtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0dHJ5IHtcclxuXHRcdFx0XHRcdGlmIChjYW52YXMuZ2V0Q29udGV4dChcImV4cGVyaW1lbnRhbC13ZWJnbFwiKSAhPT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9IGNhdGNoIChlKSB7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9IGNhdGNoIChlKSB7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0Y2FzZSBcIndlYmNsXCI6XHJcblx0XHRcdHJldHVybiBXZWJDTENvbnRleHQuaXNTdXBwb3J0ZWQoKTtcclxuXHRcdGNhc2UgXCJwbmFjbFwiOlxyXG5cdFx0XHRyZXR1cm4gUE5hQ2xDb250ZXh0LmlzU3VwcG9ydGVkKCk7XHJcblx0XHRjYXNlIFwibmFjbFwiOlxyXG5cdFx0XHR0cnkge1xyXG5cdFx0XHRcdHJldHVybiAodHlwZW9mIG5hdmlnYXRvci5taW1lVHlwZXNbXCJhcHBsaWNhdGlvbi94LW5hY2xcIl0pICE9PSBcInVuZGVmaW5lZFwiO1xyXG5cdFx0XHR9IGNhdGNoIChlKSB7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0ZGVmYXVsdDpcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBmZWF0dXJlOiBcIiArIG5hbWUpO1xyXG5cdH1cclxufTtcclxuXHJcbmV4cG9ydHMuaW5pdCA9IGluaXQ7XHJcbmV4cG9ydHMuaGFzRmVhdHVyZSA9IGhhc0ZlYXR1cmU7XHJcbmV4cG9ydHMuZ2V0RGVmYXVsdEJhY2tlbmQgPSBnZXREZWZhdWx0QmFja2VuZDtcclxuZXhwb3J0cy5nZXRTdXBwb3J0ZWRCYWNrZW5kcyA9IGdldFN1cHBvcnRlZEJhY2tlbmRzO1xyXG5leHBvcnRzLmdldEJhY2tlbmRPcHRpb25zID0gZ2V0QmFja2VuZE9wdGlvbnM7XHJcbmV4cG9ydHMuZ2V0RGVmYXVsdEJhY2tlbmRPcHRpb25zID0gZ2V0RGVmYXVsdEJhY2tlbmRPcHRpb25zO1xyXG5leHBvcnRzLkRhdGFUeXBlID0gRGF0YVR5cGU7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxudmFyIE5EQXJyYXkgPSByZXF1aXJlKFwiLi8uLi9OREFycmF5XCIpO1xyXG52YXIgRGF0YVR5cGUgPSByZXF1aXJlKFwiLi8uLi9EYXRhVHlwZVwiKTtcclxudmFyIHV0aWwgPSByZXF1aXJlKFwiLi8uLi91dGlsXCIpO1xyXG52YXIganNtYXRoID0gcmVxdWlyZShcIi4vanNtYXRoXCIpO1xyXG5cclxuLyoqXHJcbiAqIFByb3ZpZGVzIG1ldGhvZHMgZm9yIGNyZWF0aW9uLCBtYW5pcHVsYXRpb24sIGFuZCBkZXN0cnVjdGlvbiBvZiBOLWRpbWVuc2lvbmFsIGFycmF5cy5cclxuICogQXJpdGhtZXRpYyBvcGVyYXRpb25zIGFyZSBwb3NzaWJsZSBvbmx5IG9uIGFycmF5cyB0aGF0IGJlbG9uZyB0byB0aGUgc2FtZSBjb250ZXh0LlxyXG4gKlxyXG4gKiBAY2xhc3MgQ29udGV4dFxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbmZ1bmN0aW9uIEpTQ29udGV4dChvcHRpb25zLCBjYWxsYmFjaykge1xyXG5cdGNhbGxiYWNrKHRoaXMpO1xyXG59XHJcblxyXG4vKipcclxuICogQ29uc3RydWN0cyBhbiB1bmluaWFsaXplZCBOLWRpbWVuc2lvbmFsIGFycmF5LlxyXG4gKlxyXG4gKiBAbWV0aG9kIGVtcHR5XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBzaGFwZSAtIHRoZSBkaW1lbnNpb25zIG9mIHRoZSBhcnJheVxyXG4gKiBAcGFyYW0ge0RhdGFUeXBlfSBkYXRhVHlwZSAtIHRoZSB0eXBlIG9mIGVsZW1lbnRzIGluIHRoZSBhcnJheS5cclxuICovXHJcbkpTQ29udGV4dC5wcm90b3R5cGUuZW1wdHkgPSBmdW5jdGlvbihzaGFwZSwgZGF0YVR5cGUpIHtcclxuXHQvKiBUaGUgaXMgbm8gd2F5IHRvIGNyZWF0ZSB1bmluaXRpYWxpemVkIHR5cGVkIGFycmF5IGluIEphdmFTY3JpcHQgKi9cclxuXHRyZXR1cm4gdGhpcy56ZXJvcyhzaGFwZSwgZGF0YVR5cGUpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvbnN0cnVjdHMgYW4gTi1kaW1lbnNpb25hbCBhcnJheSB3aXRoIGVsZW1lbnRzIGluaXRpYWxpemVkIHRvIHplcm8uXHJcbiAqXHJcbiAqIEBtZXRob2QgemVyb3NcclxuICogQHBhcmFtIHtOdW1iZXJ9IHNoYXBlIC0gdGhlIGRpbWVuc2lvbnMgb2YgdGhlIGFycmF5XHJcbiAqIEBwYXJhbSB7RGF0YVR5cGV9IGRhdGFUeXBlIC0gdGhlIHR5cGUgb2YgZWxlbWVudHMgaW4gdGhlIGFycmF5LlxyXG4gKi9cclxuSlNDb250ZXh0LnByb3RvdHlwZS56ZXJvcyA9IGZ1bmN0aW9uKHNoYXBlLCBkYXRhVHlwZSkge1xyXG5cdHNoYXBlID0gdXRpbC5jaGVja1NoYXBlKHNoYXBlKTtcclxuXHRpZiAodHlwZW9mIGRhdGFUeXBlID09PSBcInVuZGVmaW5lZFwiKSB7XHJcblx0XHRkYXRhVHlwZSA9IG5ldyBEYXRhVHlwZShcImY2NFwiKTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0ZGF0YVR5cGUgPSB1dGlsLmNoZWNrRGF0YVR5cGUoZGF0YVR5cGUpO1xyXG5cdH1cclxuXHR2YXIgYXJyYXkgPSBuZXcgTkRBcnJheShzaGFwZSwgZGF0YVR5cGUsIHRoaXMpO1xyXG5cdGFycmF5Ll9kYXRhID0gbmV3IGRhdGFUeXBlLmFycmF5VHlwZShhcnJheS5sZW5ndGgpO1xyXG5cdHJldHVybiBhcnJheTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb25zdHJ1Y3RzIGFuIE4tZGltZW5zaW9uYWwgYXJyYXkgd2l0aCBlbGVtZW50cyBpbml0aWFsaXplZCB0byBvbmUuXHJcbiAqXHJcbiAqIEBtZXRob2Qgb25lc1xyXG4gKiBAcGFyYW0ge051bWJlcn0gc2hhcGUgLSB0aGUgZGltZW5zaW9ucyBvZiB0aGUgYXJyYXlcclxuICogQHBhcmFtIHtEYXRhVHlwZX0gZGF0YVR5cGUgLSB0aGUgdHlwZSBvZiBlbGVtZW50cyBpbiB0aGUgYXJyYXkuXHJcbiAqL1xyXG5KU0NvbnRleHQucHJvdG90eXBlLm9uZXMgPSBmdW5jdGlvbihzaGFwZSwgZGF0YVR5cGUpIHtcclxuXHQvKiBUaGUgaXMgbm8gd2F5IHRvIGNyZWF0ZSB1bmluaXRpYWxpemVkIHR5cGVkIGFycmF5IGluIEphdmFTY3JpcHQgKi9cclxuXHR2YXIgYXJyYXkgPSB0aGlzLnplcm9zKHNoYXBlLCBkYXRhVHlwZSk7XHJcblx0anNtYXRoLmZpbGwoYXJyYXkuX2RhdGEsIDEuMCk7XHJcblx0cmV0dXJuIGFycmF5O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvbnN0cnVjdHMgYW4gTi1kaW1lbnNpb25hbCBhcnJheSBvYmplY3Qgd2l0aCB0aGUgcHJvdmlkZWQgZGF0YS5cclxuICpcclxuICogQG1ldGhvZCBhcnJheVxyXG4gKiBAcGFyYW0ge051bWJlcltdfSBkYXRhIC0gdGhlIGFycmF5IGRhdGFcclxuICogQHBhcmFtIHtEYXRhVHlwZX0gZGF0YVR5cGUgLSB0aGUgdHlwZSBvZiBlbGVtZW50cyBpbiB0aGUgYXJyYXkuXHJcbiAqL1xyXG5KU0NvbnRleHQucHJvdG90eXBlLmFycmF5ID0gZnVuY3Rpb24oZGF0YSwgZGF0YVR5cGUpIHtcclxuXHRpZiAodHlwZW9mIGRhdGFUeXBlID09PSBcInVuZGVmaW5lZFwiKSB7XHJcblx0XHRkYXRhVHlwZSA9IG5ldyBEYXRhVHlwZShcImY2NFwiKTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0ZGF0YVR5cGUgPSB1dGlsLmNoZWNrRGF0YVR5cGUoZGF0YVR5cGUpO1xyXG5cdH1cclxuXHR2YXIgc2hhcGUgPSBbXTtcclxuXHR1dGlsLmRpc2NvdmVyQXJyYXlTaGFwZVJlY3Vyc2l2ZShkYXRhLCBzaGFwZSwgMCk7XHJcblx0dmFyIGFycmF5ID0gdGhpcy5lbXB0eShzaGFwZSwgZGF0YVR5cGUpO1xyXG5cdHV0aWwuY29weUFycmF5RGF0YVJlY3Vyc2l2ZShhcnJheS5fZGF0YSwgZGF0YSwgc2hhcGUsIDAsIDApO1xyXG5cdHJldHVybiBhcnJheTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBEZS1hbGxvY2F0ZXMgZGF0YSBhc3NvY2lhdGVkIHdpdGggdGhlIGFycmF5LlxyXG4gKlxyXG4gKiBAbWV0aG9kIF9pbnZhbGlkYXRlXHJcbiAqIEBwcml2YXRlXHJcbiAqXHJcbiAqIEBwYXJhbSB7TkRBcnJheX0gYXJyYXkgLSB0aGUgbi1kaW1lbnNpb25hbCBhcnJheSBvYmplY3Qgd2l0aCBkYXRhIHRvIGJlIGRlLWFsbG9jYXRlZC5cclxuICovXHJcbkpTQ29udGV4dC5wcm90b3R5cGUuX2ludmFsaWRhdGUgPSBmdW5jdGlvbihhcnJheSkge1xyXG5cdHV0aWwuY2hlY2tOREFycmF5KGFycmF5LCBcImFycmF5XCIpO1xyXG5cdGFycmF5Ll9kYXRhID0gbnVsbDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBGZXRjaGVzIE5EQXJyYXkgZGF0YSBhbmQgYXN5bmNocm9ub3VzbHkgcmV0dXJucyBpdCBhcyBKYXZhU2NyaXB0IHR5cGVkIGFycmF5cy5cclxuICpcclxuICogQG1ldGhvZCBmZXRjaFxyXG4gKiBAYXN5bmNcclxuICpcclxuICogQHBhcmFtIHtOREFycmF5fSBhcnJheXMqIC0gTkRBcnJheXMgdG8gZmV0Y2guXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gQSBjYWxsYmFjayB0byBiZSBjYWxsZWQgd2l0aCB0aGUgZGF0YSB3aGVuIGl0IGlzIGF2YWlsYWJsZS5cclxuICogQHBhcmFtIHtBcnJheUJ1ZmZlclZpZXd9IGNhbGxiYWNrLmFycmF5cyogLSB0eXBlZCBhcnJheXMgd2l0aCB0aGUgZGF0YS4gVGhlIGVsZW1lbnQgdHlwZSBvZiB0aGUgdHlwZWQgYXJyYXkgbWF0Y2hlcyB0aGUgZGF0YSB0eXBlIG9mIHRoZSBOREFycmF5LiBGb3IgemVyby1kaW1lbnNpb25hbCBhcnJheXMgdGhlIG91dHB1dCBpcyByZXR1cm5lZCBhcyBhIHR5cGVkIGFycmF5IHdpdGggYSBzaW5nbGUgZWxlbWVudC4gTXVsdGktZGltZW5zaW9uYWwgYXJyYXlzIGFyZSByZXR1cm5lZCBpbiByb3ctbWFqb3Igc3RvcmFnZSBmb3JtYXQuXHJcbiAqL1xyXG5KU0NvbnRleHQucHJvdG90eXBlLmZldGNoID0gZnVuY3Rpb24oKSB7XHJcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcihcIkNhbGxiYWNrIGFyZ3VtZW50IG1pc3NpbmdcIik7XHJcblx0fVxyXG5cdHZhciBjYWxsYmFjayA9IGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoIC0gMV07XHJcblx0LyogVmFsaWRhdGUgYXJndW1lbnRzICovXHJcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcihcIkF0IGxlYXN0IG9uZSBOREFycmF5IGFyZ3VtZW50IGV4cGVjdGVkXCIpO1xyXG5cdH1cclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGggLSAxOyArK2kpIHtcclxuXHRcdHV0aWwuY2hlY2tOREFycmF5KGFyZ3VtZW50c1tpXSwgXCJhcmd1bWVudCBcIiArIGkpO1xyXG5cdH1cclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGggLSAxOyArK2kpIHtcclxuXHRcdGFyZ3VtZW50c1tpXS5fZGVjUmVmKCk7XHJcblx0fVxyXG5cdHZhciBjYWxsYmFja0FyZ3VtZW50cyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XHJcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjYWxsYmFja0FyZ3VtZW50cy5sZW5ndGg7ICsraSkge1xyXG5cdFx0dmFyIGFycmF5ID0gYXJndW1lbnRzW2ldO1xyXG5cdFx0Y2FsbGJhY2tBcmd1bWVudHNbaV0gPSBuZXcgYXJyYXkuZGF0YVR5cGUuYXJyYXlUeXBlKGFycmF5Ll9kYXRhKTtcclxuXHR9XHJcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoIC0gMTsgKytpKSB7XHJcblx0XHRhcmd1bWVudHNbaV0uX3RyeUludmFsaWRhdGUoKTtcclxuXHR9XHJcblx0Y2FsbGJhY2suYXBwbHkobnVsbCwgY2FsbGJhY2tBcmd1bWVudHMpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEZldGNoZXMgTkRBcnJheSBkYXRhIGFuZCBhc3luY2hyb25vdXNseSByZXR1cm5zIGl0IGFzIEphdmFTY3JpcHQgYXJyYXlzIG9yIG51bWJlcnMuXHJcbiAqXHJcbiAqIEBtZXRob2QgZ2V0XHJcbiAqIEBhc3luY1xyXG4gKlxyXG4gKiBAcGFyYW0ge05EQXJyYXl9IGFycmF5cyogLSBOREFycmF5cyB0byBmZXRjaC5cclxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBBIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCB3aXRoIHRoZSBkYXRhIHdoZW4gaXQgaXMgYXZhaWxhYmxlLlxyXG4gKiBAcGFyYW0ge051bWJlcnxOdW1iZXJbXX0gY2FsbGJhY2suYXJyYXlzKiAtIEphdmFTY3JpcHQgbnVtYmVycyBvciBtdWx0aWRpbWVuc2lvbmFsIGFycmF5cyB3aXRoIHRoZSBkYXRhLiBUaGUgbnVtYmVyIGFuZCBvcmRlciBvZiBhcmd1bWVudHMgbWF0Y2hlcyB0aGUgTkRBcnJheXMgcGFzc2VkIHRvIHRoZSBtZXRob2QgY2FsbC5cclxuICovXHJcbkpTQ29udGV4dC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oKSB7XHJcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcihcIkNhbGxiYWNrIGFyZ3VtZW50IG1pc3NpbmdcIik7XHJcblx0fVxyXG5cdHZhciBjYWxsYmFjayA9IGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoIC0gMV07XHJcblx0LyogVmFsaWRhdGUgYXJndW1lbnRzICovXHJcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcihcIkF0IGxlYXN0IG9uZSBOREFycmF5IGFyZ3VtZW50IGV4cGVjdGVkXCIpO1xyXG5cdH1cclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGggLSAxOyArK2kpIHtcclxuXHRcdHV0aWwuY2hlY2tOREFycmF5KGFyZ3VtZW50c1tpXSwgXCJhcmd1bWVudCBcIiArIGkpO1xyXG5cdH1cclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGggLSAxOyArK2kpIHtcclxuXHRcdGFyZ3VtZW50c1tpXS5fZGVjUmVmKCk7XHJcblx0fVxyXG5cdHZhciBjYWxsYmFja0FyZ3VtZW50cyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XHJcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjYWxsYmFja0FyZ3VtZW50cy5sZW5ndGg7ICsraSkge1xyXG5cdFx0dmFyIGFycmF5ID0gYXJndW1lbnRzW2ldO1xyXG5cdFx0aWYgKGFycmF5LnNoYXBlLmxlbmd0aCA9PT0gMCkge1xyXG5cdFx0XHRjYWxsYmFja0FyZ3VtZW50c1tpXSA9IGFycmF5Ll9kYXRhWzBdO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dmFyIGpzYXJyYXkgPSBuZXcgQXJyYXkoYXJyYXkuc2hhcGVbMF0pO1xyXG5cdFx0XHR1dGlsLmNyZWF0ZUFycmF5UmVjdXJzaXZlKGFycmF5Ll9kYXRhLCBqc2FycmF5LCBhcnJheS5zaGFwZSwgMCwgMCk7XHJcblx0XHRcdGNhbGxiYWNrQXJndW1lbnRzW2ldID0ganNhcnJheTtcclxuXHRcdH1cclxuXHR9XHJcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoIC0gMTsgKytpKSB7XHJcblx0XHRhcmd1bWVudHNbaV0uX3RyeUludmFsaWRhdGUoKTtcclxuXHR9XHJcblx0Y2FsbGJhY2suYXBwbHkobnVsbCwgY2FsbGJhY2tBcmd1bWVudHMpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFdhaXRzIHVudGlsIHByZXZpb3VzIGNvbW1hbmRzIGZpbmlzaGVkIGV4ZWN1dGlvbiBhbmQgY2FsbHMgdGhlIGNhbGxiYWNrLlxyXG4gKlxyXG4gKiBAbWV0aG9kIGJhcnJpZXJcclxuICogQGFzeW5jXHJcbiAqXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gQSBjYWxsYmFjayB0byBiZSBjYWxsZWQgYWZ0ZXIgdGhlIHByZXZpb3VzIGNvbW1hbmRzIHJldGlyZS5cclxuICovXHJcbkpTQ29udGV4dC5wcm90b3R5cGUuYmFycmllciA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XHJcblx0Y2FsbGJhY2soKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGFub3RoZXIgYXJyYXkgd2l0aCB0aGUgc2FtZSBkYXRhLCBidXQgZGlmZmVyZW50IGRpbWVuc2lvbnMuXHJcbiAqXHJcbiAqIEBtZXRob2QgcmVzaGFwZVxyXG4gKiBAcGFyYW0geyhOREFycmF5fE51bWJlcil9IHNoYXBlIC0gZGltZW5zaW9ucyBvZiB0aGUgbmV3IGFycmF5LlxyXG4gKi9cclxuSlNDb250ZXh0LnByb3RvdHlwZS5yZXNoYXBlID0gZnVuY3Rpb24oYXJyYXksIHNoYXBlKSB7XHJcblx0c2hhcGUgPSB1dGlsLmNoZWNrU2hhcGUoc2hhcGUpO1xyXG5cdGlmICh1dGlsLmNvbXB1dGVMZW5ndGgoc2hhcGUpICE9PSBhcnJheS5sZW5ndGgpIHtcclxuXHRcdHRocm93IG5ldyBSYW5nZUVycm9yKFwiVGhlIHNoYXBlIGlzIG5vdCBjb21wYXRpYmxlIHdpdGggdGhlIGFycmF5XCIpO1xyXG5cdH1cclxuXHR2YXIgb3V0ID0gbmV3IE5EQXJyYXkoc2hhcGUsIGFycmF5LmRhdGFUeXBlLCB0aGlzKTtcclxuXHRpZiAoYXJyYXkuX2RlY1JlZigpKSB7XHJcblx0XHRvdXQuX2RhdGEgPSBuZXcgb3V0LmRhdGFUeXBlLmFycmF5VHlwZShvdXQubGVuZ3RoKTtcclxuXHRcdG91dC5fZGF0YS5zZXQoYXJyYXkuX2RhdGEpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRvdXQuX2RhdGEgPSBhcnJheS5fZGF0YTtcclxuXHRcdGFycmF5Ll90cnlJbnZhbGlkYXRlKCk7XHJcblx0fVxyXG5cdHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG4vKipcclxuICogRHVwbGljYXRlcyBhcnJheSBlbGVtZW50cyBhbG9uZyB0aGUgc3BlY2lmaWVkIGF4aXMuXHJcbiAqXHJcbiAqIEBtZXRob2QgcmVwZWF0XHJcbiAqIEBwYXJhbSB7TkRBcnJheX0gYSAtIHRoZSBpbnB1dCBhcnJheS5cclxuICogQHBhcmFtIHtOdW1iZXJ9IHJlcGVhdHMgLSB0aGUgbnVtYmVyIG9mIHRpbWVzIHRvIHJlcGVhdCBlYWNoIGVsZW1lbnQuXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBheGlzIC0gdGhlIGF4aXMgYWxvbmcgd2hpY2ggdGhlIGVsZW1lbnRzIHdpbGwgYmUgZHVwbGljYXRlZC5cclxuICogQHBhcmFtIHtOREFycmF5fSBbb3V0XSAtIGFuIG91dHB1dCBhcnJheSB0byBzdG9yZSB0aGUgcmVzdWx0LlxyXG4gKiBAcmV0dXJuIHtOREFycmF5fSAtIGFuIE4tZGltZW5zaW9uYWwgYXJyYXkgd2l0aCByZXBlYXRlZCBlbGVtZW50cyBvZiBhcnJheSAqKmEqKi5cclxuICovXHJcbkpTQ29udGV4dC5wcm90b3R5cGUucmVwZWF0ID0gZnVuY3Rpb24oYSwgcmVwZWF0cywgYXhpcywgb3V0KSB7XHJcblx0dXRpbC5jaGVja05EQXJyYXkoYSwgXCJhXCIpO1xyXG5cdHJlcGVhdHMgPSB1dGlsLmNoZWNrUmVwZWF0cyhyZXBlYXRzKTtcclxuXHRheGlzID0gdXRpbC5jaGVja0F4aXMoYXhpcywgYS5zaGFwZS5sZW5ndGgpO1xyXG5cdHZhciBzaGFwZUEgPSBhLnNoYXBlO1xyXG5cdHZhciBzaGFwZU91dCA9IHNoYXBlQS5zbGljZSgwKTtcclxuXHRzaGFwZU91dFtheGlzXSAqPSByZXBlYXRzO1xyXG5cdGEuX2RlY1JlZigpO1xyXG5cdHRyeSB7XHJcblx0XHRpZiAodHlwZW9mIG91dCA9PT0gXCJ1bmRlZmluZWRcIikge1xyXG5cdFx0XHRvdXQgPSB0aGlzLmVtcHR5KHNoYXBlT3V0LCBhLmRhdGFUeXBlKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHV0aWwuY2hlY2tOREFycmF5KG91dCwgXCJvdXRcIik7XHJcblx0XHRcdHV0aWwuY2hlY2tTaGFwZXNDb21wYXRpYmlsaXR5KG91dC5zaGFwZSwgc2hhcGVPdXQpO1xyXG5cdFx0XHR1dGlsLmNoZWNrRGF0YVR5cGVzQ29tcGF0aWJpbGl0eShhLmRhdGFUeXBlLCBvdXQuZGF0YVR5cGUpO1xyXG5cdFx0XHRvdXQuX2luY1JlZigpO1xyXG5cdFx0fVxyXG5cdFx0dmFyIG91dGVyU3RyaWRlID0gdXRpbC5jb21wdXRlT3V0ZXJTdHJpZGUoc2hhcGVBLCBheGlzKTtcclxuXHRcdHZhciBpbm5lclN0cmlkZSA9IHV0aWwuY29tcHV0ZUlubmVyU3RyaWRlKHNoYXBlQSwgYXhpcyk7XHJcblx0XHRqc21hdGgucmVwZWF0KGEuX2RhdGEsIG91dC5fZGF0YSwgb3V0ZXJTdHJpZGUsIGlubmVyU3RyaWRlLCBzaGFwZUFbYXhpc10sIHJlcGVhdHMpO1xyXG5cdH0gY2F0Y2ggKGUpIHtcclxuXHRcdGEuX2luY1JlZigpO1xyXG5cdFx0dGhyb3cgZTtcclxuXHR9XHJcblx0YS5fdHJ5SW52YWxpZGF0ZSgpO1xyXG5cdHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG52YXIgYmluYXJ5QXJpdGhPcCA9IGZ1bmN0aW9uKGEsIGIsIG91dCwgY29udGV4dCwgb3BlcmF0aW9uLCBvcGVyYXRpb25Db25zdCwgb3BlcmF0aW9uUmV2Q29uc3QpIHtcclxuXHR2YXIgc2hhcGVPdXQgPSBudWxsLCBkYXRhVHlwZU91dCA9IG51bGw7XHJcblx0aWYgKGEgaW5zdGFuY2VvZiBOREFycmF5KSB7XHJcblx0XHRzaGFwZU91dCA9IGEuc2hhcGU7XHJcblx0XHRkYXRhVHlwZU91dCA9IGEuZGF0YVR5cGU7XHJcblx0XHRpZiAoYiBpbnN0YW5jZW9mIE5EQXJyYXkpIHtcclxuXHRcdFx0dXRpbC5jaGVja1NoYXBlc0NvbXBhdGliaWxpdHkoYS5zaGFwZSwgYi5zaGFwZSk7XHJcblx0XHRcdHV0aWwuY2hlY2tEYXRhVHlwZXNDb21wYXRpYmlsaXR5KGEuZGF0YVR5cGUsIGIuZGF0YVR5cGUpO1xyXG5cdFx0fSBlbHNlIGlmICghdXRpbC5pc051bWJlcihiKSkge1xyXG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5zdXBwb3J0ZWQgdHlwZSBvZiBiXCIpO1xyXG5cdFx0fVxyXG5cdH0gZWxzZSBpZiAodXRpbC5pc051bWJlcihhKSkge1xyXG5cdFx0c2hhcGVPdXQgPSBiLnNoYXBlO1xyXG5cdFx0ZGF0YVR5cGVPdXQgPSBiLmRhdGFUeXBlO1xyXG5cdFx0dXRpbC5jaGVja05EQXJyYXkoYiwgXCJiXCIpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5zdXBwb3J0ZWQgdHlwZSBvZiBhXCIpO1xyXG5cdH1cclxuXHRpZiAoYSBpbnN0YW5jZW9mIE5EQXJyYXkpIHtcclxuXHRcdGEuX2RlY1JlZigpO1xyXG5cdH1cclxuXHRpZiAoYiBpbnN0YW5jZW9mIE5EQXJyYXkpIHtcclxuXHRcdGIuX2RlY1JlZigpO1xyXG5cdH1cclxuXHR0cnkge1xyXG5cdFx0aWYgKHR5cGVvZiBvdXQgPT09IFwidW5kZWZpbmVkXCIpIHtcclxuXHRcdFx0b3V0ID0gbmV3IE5EQXJyYXkoc2hhcGVPdXQsIGRhdGFUeXBlT3V0LCBjb250ZXh0KTtcclxuXHRcdFx0aWYgKChhIGluc3RhbmNlb2YgTkRBcnJheSkgJiYgIWEuX2hhc1JlZnMoKSkge1xyXG5cdFx0XHRcdG91dC5fZGF0YSA9IGEuX2RhdGE7XHJcblx0XHRcdH0gZWxzZSBpZiAoKGIgaW5zdGFuY2VvZiBOREFycmF5KSAmJiAhYi5faGFzUmVmcygpKSB7XHJcblx0XHRcdFx0b3V0Ll9kYXRhID0gYi5fZGF0YTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRvdXQuX2RhdGEgPSBuZXcgZGF0YVR5cGVPdXQuYXJyYXlUeXBlKG91dC5sZW5ndGgpO1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR1dGlsLmNoZWNrTkRBcnJheShvdXQsIFwib3V0XCIpO1xyXG5cdFx0XHR1dGlsLmNoZWNrU2hhcGVzQ29tcGF0aWJpbGl0eShzaGFwZU91dCwgb3V0LnNoYXBlKTtcclxuXHRcdFx0dXRpbC5jaGVja0RhdGFUeXBlc0NvbXBhdGliaWxpdHkoZGF0YVR5cGVPdXQsIG91dC5kYXRhVHlwZSk7XHJcblx0XHRcdG91dC5faW5jUmVmKCk7XHJcblx0XHR9XHJcblx0XHRpZiAoYSBpbnN0YW5jZW9mIE5EQXJyYXkpIHtcclxuXHRcdFx0aWYgKGIgaW5zdGFuY2VvZiBOREFycmF5KSB7XHJcblx0XHRcdFx0b3BlcmF0aW9uKGEuX2RhdGEsIGIuX2RhdGEsIG91dC5fZGF0YSk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0b3BlcmF0aW9uQ29uc3QoYS5fZGF0YSwgK2IsIG91dC5fZGF0YSk7XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdG9wZXJhdGlvblJldkNvbnN0KGIuX2RhdGEsICthLCBvdXQuX2RhdGEpO1xyXG5cdFx0fVxyXG5cdH0gY2F0Y2ggKGUpIHtcclxuXHRcdC8qIFJlc3RvcmUgdGhlIHByZXZpb3VzIHN0YXRlICovXHJcblx0XHRpZiAoYSBpbnN0YW5jZW9mIE5EQXJyYXkpIHtcclxuXHRcdFx0YS5faW5jUmVmKCk7XHJcblx0XHR9XHJcblx0XHRpZiAoYiBpbnN0YW5jZW9mIE5EQXJyYXkpIHtcclxuXHRcdFx0Yi5faW5jUmVmKCk7XHJcblx0XHR9XHJcblx0XHR0aHJvdyBlO1xyXG5cdH1cclxuXHRpZiAoYSBpbnN0YW5jZW9mIE5EQXJyYXkpIHtcclxuXHRcdGEuX3RyeUludmFsaWRhdGUoKTtcclxuXHR9XHJcblx0aWYgKGIgaW5zdGFuY2VvZiBOREFycmF5KSB7XHJcblx0XHRiLl90cnlJbnZhbGlkYXRlKCk7XHJcblx0fVxyXG5cdHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG52YXIgdW5hcnlBcml0aE9wID0gZnVuY3Rpb24oYSwgb3V0LCBjb250ZXh0LCBvcGVyYXRpb24pIHtcclxuXHR1dGlsLmNoZWNrTkRBcnJheShhLCBcImFcIik7XHJcblx0YS5fZGVjUmVmKCk7XHJcblx0dHJ5IHtcclxuXHRcdGlmICh0eXBlb2Ygb3V0ID09PSBcInVuZGVmaW5lZFwiKSB7XHJcblx0XHRcdG91dCA9IG5ldyBOREFycmF5KGEuc2hhcGUsIGEuZGF0YVR5cGUsIGNvbnRleHQpO1xyXG5cdFx0XHRpZiAoKGEgaW5zdGFuY2VvZiBOREFycmF5KSAmJiAhYS5faGFzUmVmcygpKSB7XHJcblx0XHRcdFx0b3V0Ll9kYXRhID0gYS5fZGF0YTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRvdXQuX2RhdGEgPSBuZXcgYS5kYXRhVHlwZS5hcnJheVR5cGUob3V0Lmxlbmd0aCk7XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHV0aWwuY2hlY2tOREFycmF5KG91dCwgXCJvdXRcIik7XHJcblx0XHRcdHV0aWwuY2hlY2tTaGFwZXNDb21wYXRpYmlsaXR5KGEuc2hhcGUsIG91dC5zaGFwZSk7XHJcblx0XHRcdHV0aWwuY2hlY2tEYXRhVHlwZXNDb21wYXRpYmlsaXR5KGEuZGF0YVR5cGUsIG91dC5kYXRhVHlwZSk7XHJcblx0XHRcdG91dC5faW5jUmVmKCk7XHJcblx0XHR9XHJcblx0XHRvcGVyYXRpb24oYS5fZGF0YSwgb3V0Ll9kYXRhKTtcclxuXHR9IGNhdGNoIChlKSB7XHJcblx0XHQvKiBSZXN0b3JlIHRoZSBwcmV2aW91cyBzdGF0ZSAqL1xyXG5cdFx0YS5faW5jUmVmKCk7XHJcblx0XHR0aHJvdyBlO1xyXG5cdH1cclxuXHRhLl90cnlJbnZhbGlkYXRlKCk7XHJcblx0cmV0dXJuIG91dDtcclxufTtcclxuXHJcbnZhciBheGlzUmVkdWNlT3AgPSBmdW5jdGlvbihhLCBheGlzLCBvdXQsIGNvbnRleHQsIG9wZXJhdGlvbiwgYXhpc09wZXJhdGlvbikge1xyXG5cdHV0aWwuY2hlY2tOREFycmF5KGEsIFwiYVwiKTtcclxuXHRpZiAodHlwZW9mIGF4aXMgPT09IFwidW5kZWZpbmVkXCIpIHtcclxuXHRcdGlmICh0eXBlb2Ygb3V0ID09PSBcInVuZGVmaW5lZFwiKSB7XHJcblx0XHRcdG91dCA9IGNvbnRleHQuZW1wdHkoW10sIGEuZGF0YVR5cGUpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dXRpbC5jaGVja05EQXJyYXkob3V0LCBcIm91dFwiKTtcclxuXHRcdFx0dXRpbC5jaGVja1NoYXBlc0NvbXBhdGliaWxpdHkoW10sIG91dC5zaGFwZSk7XHJcblx0XHRcdHV0aWwuY2hlY2tEYXRhVHlwZXNDb21wYXRpYmlsaXR5KGEuZGF0YVR5cGUsIG91dC5kYXRhVHlwZSk7XHJcblx0XHRcdG91dC5faW5jUmVmKCk7XHJcblx0XHR9XHJcblx0XHRvcGVyYXRpb24oYS5fZGF0YSwgb3V0Ll9kYXRhKTtcclxuXHRcdGEuX3RyeVJlbGVhc2UoKTtcclxuXHRcdHJldHVybiBvdXQ7XHJcblx0fSBlbHNlIHtcclxuXHRcdGF4aXMgPSB1dGlsLmNoZWNrQXhpcyhheGlzLCBhLnNoYXBlLmxlbmd0aCk7XHJcblx0XHR2YXIgc2hhcGVPdXQgPSB1dGlsLmNvbXB1dGVBeGlzUmVkdWN0aW9uT3V0U2hhcGUoYS5zaGFwZSwgYXhpcyk7XHJcblx0XHRpZiAodHlwZW9mIG91dCA9PT0gXCJ1bmRlZmluZWRcIikge1xyXG5cdFx0XHRvdXQgPSBjb250ZXh0LmVtcHR5KHNoYXBlT3V0LCBhLmRhdGFUeXBlKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHV0aWwuY2hlY2tOREFycmF5KG91dCwgXCJvdXRcIik7XHJcblx0XHRcdHV0aWwuY2hlY2tTaGFwZXNDb21wYXRpYmlsaXR5KFtdLCBvdXQuc2hhcGUpO1xyXG5cdFx0XHR1dGlsLmNoZWNrRGF0YVR5cGVzQ29tcGF0aWJpbGl0eShhLmRhdGFUeXBlLCBvdXQuZGF0YVR5cGUpO1xyXG5cdFx0XHRvdXQuX2luY1JlZigpO1xyXG5cdFx0fVxyXG5cdFx0YXhpc09wZXJhdGlvbihhLl9kYXRhLCBvdXQuX2RhdGEsXHJcblx0XHRcdHV0aWwuY29tcHV0ZU91dGVyU3RyaWRlKGEuc2hhcGUsIGF4aXMpLFxyXG5cdFx0XHR1dGlsLmNvbXB1dGVJbm5lclN0cmlkZShhLnNoYXBlLCBheGlzKSxcclxuXHRcdFx0YS5zaGFwZVtheGlzXSk7XHJcblx0XHRhLl90cnlSZWxlYXNlKCk7XHJcblx0XHRyZXR1cm4gb3V0O1xyXG5cdH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBBZGRzIG9uZSBudW1iZXIgb3IgYXJyYXkgd2l0aCBhbm90aGVyIG51bWJlciBvciBhcnJheS5cclxuICogQWRkaXRpb24gaXMgcGVyZm9ybWVkIGVsZW1lbnQtYnktZWxlbWVudC5cclxuICpcclxuICogQG1ldGhvZCBhZGRcclxuICogQHBhcmFtIHsoTkRBcnJheXxOdW1iZXIpfSBhIC0gb25lIG51bWJlciBvciBhcnJheSB0byBhZGQuIElmICoqYioqIGlzIGEgKk51bWJlciosICoqYSoqIG11c3QgYmUgYW4gKk5EQXJyYXkqLlxyXG4gKiBAcGFyYW0geyhOREFycmF5fE51bWJlcil9IGIgLSBhbm90aGVyIG51bWJlciBvciBhcnJheSB0byBhZGQuIElmICoqYSoqIGlzIGEgKk51bWJlciosICoqYioqIG11c3QgYmUgYW4gKk5EQXJyYXkqLlxyXG4gKiBAcGFyYW0ge05EQXJyYXl9IFtvdXRdIC0gdGhlIGFycmF5IHdoZXJlIHRoZSByZXN1bHQgaXMgdG8gYmUgc3RvcmVkLiBJZiBwcm92aWRlZCwgbXVzdCBtYXRjaCB0aGUgc2hhcGUgYW5kIGRhdGEgdHlwZSBvZiBpbnB1dCBhcnJheXMuXHJcbiAqIEByZXR1cm4ge05EQXJyYXl9IC0gdGhlIHJlc3VsdCBvZiBlbGVtZW50LXdpc2UgYWRkaXRpb24gb2YgKiphKiogYW5kICoqYioqLlxyXG4gKi9cclxuSlNDb250ZXh0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihhLCBiLCBvdXQpIHtcclxuXHRyZXR1cm4gYmluYXJ5QXJpdGhPcChhLCBiLCBvdXQsIHRoaXMsIGpzbWF0aC5hZGQsIGpzbWF0aC5hZGRDb25zdCwganNtYXRoLmFkZENvbnN0KTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBTdWJ0cmFjdHMgb25lIG51bWJlciBvciBhcnJheSBmcm9tIGFub3RoZXIgbnVtYmVyIG9yIGFycmF5LlxyXG4gKiBTdWJ0cmFjdGlvbiBpcyBwZXJmb3JtZWQgZWxlbWVudC1ieS1lbGVtZW50LlxyXG4gKlxyXG4gKiBAbWV0aG9kIHN1YlxyXG4gKiBAcGFyYW0geyhOREFycmF5fE51bWJlcil9IGEgLSB0aGUgbnVtYmVyIG9yIGFycmF5IHRvIHN1YnRyYWN0IGZyb20uIElmICoqYioqIGlzIGEgKk51bWJlciosICoqYSoqIG11c3QgYmUgYW4gKk5EQXJyYXkqLlxyXG4gKiBAcGFyYW0geyhOREFycmF5fE51bWJlcil9IGIgLSB0aGUgbnVtYmVyIG9yIGFycmF5IHRvIHN1YnRyYWN0LiBJZiAqKmEqKiBpcyBhICpOdW1iZXIqLCAqKmIqKiBtdXN0IGJlIGFuICpOREFycmF5Ki5cclxuICogQHBhcmFtIHtOREFycmF5fSBbb3V0XSAtIHRoZSBhcnJheSB3aGVyZSB0aGUgcmVzdWx0IGlzIHRvIGJlIHN0b3JlZC4gSWYgcHJvdmlkZWQsIG11c3QgbWF0Y2ggdGhlIHNoYXBlIGFuZCBkYXRhIHR5cGUgb2YgaW5wdXQgYXJyYXlzLlxyXG4gKiBAcmV0dXJuIHtOREFycmF5fSAtIHRoZSByZXN1bHQgb2YgZWxlbWVudC13aXNlIHN1YnRyYWN0aW9uIG9mICoqYioqIGZyb20gKiphKiouXHJcbiAqL1xyXG5KU0NvbnRleHQucHJvdG90eXBlLnN1YiA9IGZ1bmN0aW9uKGEsIGIsIG91dCkge1xyXG5cdHJldHVybiBiaW5hcnlBcml0aE9wKGEsIGIsIG91dCwgdGhpcywganNtYXRoLnN1YiwganNtYXRoLnN1YkNvbnN0LCBqc21hdGguc3ViUmV2Q29uc3QpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIE11bHRpcGxpZXMgb25lIG51bWJlciBvciBhcnJheSBieSBhbm90aGVyIG51bWJlciBvciBhcnJheS5cclxuICogTXVsdGlwbGljYXRpb24gaXMgcGVyZm9ybWVkIGVsZW1lbnQtYnktZWxlbWVudC5cclxuICpcclxuICogQG1ldGhvZCBtdWxcclxuICogQHBhcmFtIHsoTkRBcnJheXxOdW1iZXIpfSBhIC0gb25lIG51bWJlciBvciBhcnJheSB0byBtdWx0aXBseS4gSWYgKipiKiogaXMgYSAqTnVtYmVyKiwgKiphKiogbXVzdCBiZSBhbiAqTkRBcnJheSouXHJcbiAqIEBwYXJhbSB7KE5EQXJyYXl8TnVtYmVyKX0gYiAtIGFub3RoZXIgbnVtYmVyIG9yIGFycmF5IHRvIG11bHRpcGx5LiBJZiAqKmEqKiBpcyBhICpOdW1iZXIqLCAqKmIqKiBtdXN0IGJlIGFuICpOREFycmF5Ki5cclxuICogQHBhcmFtIHtOREFycmF5fSBbb3V0XSAtIHRoZSBhcnJheSB3aGVyZSB0aGUgcmVzdWx0IGlzIHRvIGJlIHN0b3JlZC4gSWYgcHJvdmlkZWQsIG11c3QgbWF0Y2ggdGhlIHNoYXBlIGFuZCBkYXRhIHR5cGUgb2YgaW5wdXQgYXJyYXlzLlxyXG4gKiBAcmV0dXJuIHtOREFycmF5fSAtIHRoZSByZXN1bHQgb2YgZWxlbWVudC13aXNlIG11bHRpcGxpY2F0aW9uIG9mICoqYSoqIGFuZCAqKmIqKi5cclxuICovXHJcbkpTQ29udGV4dC5wcm90b3R5cGUubXVsID0gZnVuY3Rpb24oYSwgYiwgb3V0KSB7XHJcblx0cmV0dXJuIGJpbmFyeUFyaXRoT3AoYSwgYiwgb3V0LCB0aGlzLCBqc21hdGgubXVsLCBqc21hdGgubXVsQ29uc3QsIGpzbWF0aC5tdWxDb25zdCk7XHJcbn07XHJcblxyXG4vKipcclxuICogRGl2aWRlcyBvbmUgbnVtYmVyIG9yIGFycmF5IGJ5IGFub3RoZXIgbnVtYmVyIG9yIGFycmF5LlxyXG4gKiBEaXZpc2lvbiBpcyBwZXJmb3JtZWQgZWxlbWVudC1ieS1lbGVtZW50LlxyXG4gKlxyXG4gKiBAbWV0aG9kIGRpdlxyXG4gKiBAcGFyYW0geyhOREFycmF5fE51bWJlcil9IGEgLSB0aGUgbnVtYmVyIG9yIGFycmF5IHRvIGRpdmlkZS4gSWYgKipiKiogaXMgYSAqTnVtYmVyKiwgKiphKiogbXVzdCBiZSBhbiAqTkRBcnJheSouXHJcbiAqIEBwYXJhbSB7KE5EQXJyYXl8TnVtYmVyKX0gYiAtIHRoZSBudW1iZXIgb3IgYXJyYXkgdG8gZGl2aWRlIGJ5LiBJZiAqKmEqKiBpcyBhICpOdW1iZXIqLCAqKmIqKiBtdXN0IGJlIGFuICpOREFycmF5Ki5cclxuICogQHBhcmFtIHtOREFycmF5fSBbb3V0XSAtIHRoZSBhcnJheSB3aGVyZSB0aGUgcmVzdWx0IGlzIHRvIGJlIHN0b3JlZC4gSWYgcHJvdmlkZWQsIG11c3QgbWF0Y2ggdGhlIHNoYXBlIGFuZCBkYXRhIHR5cGUgb2YgaW5wdXQgYXJyYXlzLlxyXG4gKiBAcmV0dXJuIHtOREFycmF5fSAtIHRoZSByZXN1bHQgb2YgZWxlbWVudC13aXNlIGRpdmlzaW9uIG9mICoqYSoqIGJ5ICoqYioqLlxyXG4gKi9cclxuSlNDb250ZXh0LnByb3RvdHlwZS5kaXYgPSBmdW5jdGlvbihhLCBiLCBvdXQpIHtcclxuXHRyZXR1cm4gYmluYXJ5QXJpdGhPcChhLCBiLCBvdXQsIHRoaXMsIGpzbWF0aC5kaXYsIGpzbWF0aC5kaXZDb25zdCwganNtYXRoLmRpdlJldkNvbnN0KTtcclxufTtcclxuXHJcbkpTQ29udGV4dC5wcm90b3R5cGUubWluID0gZnVuY3Rpb24oYSwgYXhpcywgb3V0KSB7XHJcblx0cmV0dXJuIGF4aXNSZWR1Y2VPcChhLCBheGlzLCBvdXQsIHRoaXMsIGpzbWF0aC5taW4sIGpzbWF0aC5heGlzTWluKTtcclxufTtcclxuXHJcbkpTQ29udGV4dC5wcm90b3R5cGUubWF4ID0gZnVuY3Rpb24oYSwgYXhpcywgb3V0KSB7XHJcblx0cmV0dXJuIGF4aXNSZWR1Y2VPcChhLCBheGlzLCBvdXQsIHRoaXMsIGpzbWF0aC5tYXgsIGpzbWF0aC5heGlzTWF4KTtcclxufTtcclxuXHJcbkpTQ29udGV4dC5wcm90b3R5cGUuc3VtID0gZnVuY3Rpb24oYSwgYXhpcywgb3V0KSB7XHJcblx0cmV0dXJuIGF4aXNSZWR1Y2VPcChhLCBheGlzLCBvdXQsIHRoaXMsIGpzbWF0aC5zdW0sIGpzbWF0aC5heGlzU3VtKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBOZWdhdGVzIGFycmF5IGVsZW1lbnRzLlxyXG4gKlxyXG4gKiBAbWV0aG9kIG5lZ1xyXG4gKiBAcGFyYW0ge05EQXJyYXl9IGEgLSB0aGUgYXJyYXkgb2YgZWxlbWVudHMgdG8gYmUgbmVnYXRlZC5cclxuICogQHBhcmFtIHtOREFycmF5fSBbb3V0XSAtIHRoZSBhcnJheSBmb3IgbmVnYXRlZCBlbGVtZW50cy4gSWYgc3VwcGxpZWQsIG11c3QgbWF0Y2ggdGhlIGRpbWVuc2lvbnMgYW5kIGRhdGEgdHlwZSBvZiB0aGUgKiphKiogYXJyYXkuXHJcbiAqL1xyXG5KU0NvbnRleHQucHJvdG90eXBlLm5lZyA9IGZ1bmN0aW9uKGEsIG91dCkge1xyXG5cdHJldHVybiB1bmFyeUFyaXRoT3AoYSwgb3V0LCB0aGlzLCBqc21hdGgubmVnKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb21wdXRlcyBhYnNvbHV0ZSB2YWx1ZSBvZiBhcnJheSBlbGVtZW50cy5cclxuICpcclxuICogQG1ldGhvZCBhYnNcclxuICogQHBhcmFtIHtOREFycmF5fSBhIC0gdGhlIGFycmF5IG9mIGlucHV0IGVsZW1lbnRzLlxyXG4gKiBAcGFyYW0ge05EQXJyYXl9IFtvdXRdIC0gdGhlIGFycmF5IGZvciBjb21wdXRlZCBhYnNvbHV0ZSB2YWx1ZXMuIElmIHN1cHBsaWVkLCBtdXN0IG1hdGNoIHRoZSBkaW1lbnNpb25zIGFuZCBkYXRhIHR5cGUgb2YgdGhlICoqYSoqIGFycmF5LlxyXG4gKi9cclxuSlNDb250ZXh0LnByb3RvdHlwZS5hYnMgPSBmdW5jdGlvbihhLCBvdXQpIHtcclxuXHRyZXR1cm4gdW5hcnlBcml0aE9wKGEsIG91dCwgdGhpcywganNtYXRoLmFicyk7XHJcbn07XHJcblxyXG4vKipcclxuICogRXhwb25lbnRpYXRlcyBhcnJheSBlbGVtZW50cy5cclxuICpcclxuICogQG1ldGhvZCBleHBcclxuICogQHBhcmFtIHtOREFycmF5fSBhIC0gdGhlIGFycmF5IG9mIGVsZW1lbnRzIHRvIGJlIGV4cG9uZW50aWF0ZWQuXHJcbiAqIEBwYXJhbSB7TkRBcnJheX0gW291dF0gLSB0aGUgYXJyYXkgZm9yIGV4cG9uZW50aWF0ZWQgZWxlbWVudHMuIElmIHN1cHBsaWVkLCBtdXN0IG1hdGNoIHRoZSBkaW1lbnNpb25zIGFuZCBkYXRhIHR5cGUgb2YgdGhlICoqYSoqIGFycmF5LlxyXG4gKi9cclxuSlNDb250ZXh0LnByb3RvdHlwZS5leHAgPSBmdW5jdGlvbihhLCBvdXQpIHtcclxuXHRyZXR1cm4gdW5hcnlBcml0aE9wKGEsIG91dCwgdGhpcywganNtYXRoLmV4cCk7XHJcbn07XHJcblxyXG4vKipcclxuICogQ29tcHV0ZXMgbG9nYXJpdGhtIG9mIGFycmF5IGVsZW1lbnRzLlxyXG4gKlxyXG4gKiBAbWV0aG9kIGxvZ1xyXG4gKiBAcGFyYW0ge05EQXJyYXl9IGEgLSB0aGUgYXJyYXkgb2YgaW5wdXQgZWxlbWVudHMuXHJcbiAqIEBwYXJhbSB7TkRBcnJheX0gW291dF0gLSB0aGUgYXJyYXkgZm9yIGNvbXB1dGVkIGxvZ2FyaXRobSB2YWx1ZXMuIElmIHN1cHBsaWVkLCBtdXN0IG1hdGNoIHRoZSBkaW1lbnNpb25zIGFuZCBkYXRhIHR5cGUgb2YgdGhlICoqYSoqIGFycmF5LlxyXG4gKi9cclxuSlNDb250ZXh0LnByb3RvdHlwZS5sb2cgPSBmdW5jdGlvbihhLCBvdXQpIHtcclxuXHRyZXR1cm4gdW5hcnlBcml0aE9wKGEsIG91dCwgdGhpcywganNtYXRoLmxvZyk7XHJcbn07XHJcblxyXG4vKipcclxuICogQ29tcHV0ZXMgc3F1YXJlIHJvb3Qgb2YgYXJyYXkgZWxlbWVudHMuXHJcbiAqXHJcbiAqIEBtZXRob2Qgc3FydFxyXG4gKiBAcGFyYW0ge05EQXJyYXl9IGEgLSB0aGUgYXJyYXkgb2YgaW5wdXQgZWxlbWVudHMuXHJcbiAqIEBwYXJhbSB7TkRBcnJheX0gW291dF0gLSB0aGUgYXJyYXkgZm9yIGNvbXB1dGVkIHNxdWFyZSByb290IHZhbHVlcy4gSWYgc3VwcGxpZWQsIG11c3QgbWF0Y2ggdGhlIGRpbWVuc2lvbnMgYW5kIGRhdGEgdHlwZSBvZiB0aGUgKiphKiogYXJyYXkuXHJcbiAqL1xyXG5KU0NvbnRleHQucHJvdG90eXBlLnNxcnQgPSBmdW5jdGlvbihhLCBvdXQpIHtcclxuXHRyZXR1cm4gdW5hcnlBcml0aE9wKGEsIG91dCwgdGhpcywganNtYXRoLnNxcnQpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFNxdWFyZXMgYXJyYXkgZWxlbWVudHMuXHJcbiAqXHJcbiAqIEBtZXRob2Qgc3F1YXJlXHJcbiAqIEBwYXJhbSB7TkRBcnJheX0gYSAtIHRoZSBhcnJheSBvZiBlbGVtZW50cyB0byBiZSBzcXVhcmVkLlxyXG4gKiBAcGFyYW0ge05EQXJyYXl9IFtvdXRdIC0gdGhlIGFycmF5IGZvciBzcXVhcmVkIGVsZW1lbnRzLiBJZiBzdXBwbGllZCwgbXVzdCBtYXRjaCB0aGUgZGltZW5zaW9ucyBhbmQgZGF0YSB0eXBlIG9mIHRoZSAqKmEqKiBhcnJheS5cclxuICovXHJcbkpTQ29udGV4dC5wcm90b3R5cGUuc3F1YXJlID0gZnVuY3Rpb24oYSwgb3V0KSB7XHJcblx0cmV0dXJuIHVuYXJ5QXJpdGhPcChhLCBvdXQsIHRoaXMsIGpzbWF0aC5zcXVhcmUpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvbXB1dGVzIHRoZSBkb3QgcHJvZHVjdCBvZiB0d28gTi1kaW1lbnNpb25hbCBhcnJheXMuXHJcbiAqXHJcbiAqIEBtZXRob2QgZG90XHJcbiAqIEBwYXJhbSB7TkRBcnJheX0gYSAtIHRoZSBmaXJzdCBpbnB1dCBhcnJheS5cclxuICogQHBhcmFtIHtOREFycmF5fSBiIC0gdGhlIHNlY29uZCBpbnB1dCBhcnJheS5cclxuICogQHBhcmFtIHtOREFycmF5fSBbb3V0XSAtIHRoZSBvdXRwdXQgYXJyYXkuIElmIHN1cHBsaWVkLCBtdXN0IG1hdGNoIHRoZSBkYXRhIHR5cGUgb2YgKiphKiogYW5kICoqYioqIGFycmF5cyBhbmQgaGF2ZSB0aGUgZXhwZWN0ZWQgc2hhcGUuIENhbiBub3QgYmUgdGhlIHNhbWUgYXJyYXkgYXMgKiphKiogb3IgKipiKiouXHJcbiAqIEByZXR1cm4ge05EQXJyYXl9IC0gdGhlIGFycmF5IHdpdGggdGhlIGRvdCBwcm9kdWN0IG9mICoqYSoqIGFuZCAqKmIqKi5cclxuICovXHJcbkpTQ29udGV4dC5wcm90b3R5cGUuZG90ID0gZnVuY3Rpb24oYSwgYiwgb3V0KSB7XHJcblx0dXRpbC5jaGVja05EQXJyYXkoYSwgXCJhXCIpO1xyXG5cdHV0aWwuY2hlY2tOREFycmF5KGIsIFwiYlwiKTtcclxuXHR1dGlsLmNoZWNrRGF0YVR5cGVzQ29tcGF0aWJpbGl0eShhLmRhdGFUeXBlLCBiLmRhdGFUeXBlKTtcclxuXHJcblx0LyogVGhlIGF4aXMgb2YgYiB1c2VkIGluIHJlZHVjdGlvbjogYXhpcyAwIGZvciAxRCBhcnJheSwgc2Vjb25kLXRvLWxhc3QgYXhpcyBmb3IgTkQgYXJyYXkgKi9cclxuXHR2YXIgYUF4aXMgPSBNYXRoLm1heChhLnNoYXBlLmxlbmd0aCAtIDEsIDApO1xyXG5cdHZhciBiQXhpcyA9IE1hdGgubWF4KGIuc2hhcGUubGVuZ3RoIC0gMiwgMCk7XHJcblx0dmFyIHJlZHVjdGlvbkRpbSA9IGEuc2hhcGVbYUF4aXNdO1xyXG5cdGlmIChyZWR1Y3Rpb25EaW0gIT09IGIuc2hhcGVbYkF4aXNdKSB7XHJcblx0XHR0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkFycmF5cyBoYXZlIGluY29tcGF0aWJsZSByZWR1Y3Rpb24gZGltZW5zaW9uc1wiKTtcclxuXHR9XHJcblx0dmFyIHNoYXBlT3V0ID0gW10sIHN0cmlkZUEgPSAxLCBvdXRlclN0cmlkZUIgPSAxLCBpbm5lclN0cmlkZUIgPSAxO1xyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgYUF4aXM7IGkrKykge1xyXG5cdFx0c2hhcGVPdXQucHVzaChhLnNoYXBlW2ldKTtcclxuXHRcdHN0cmlkZUEgKj0gYS5zaGFwZVtpXTtcclxuXHR9XHJcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBiLnNoYXBlLmxlbmd0aDsgaSsrKSB7XHJcblx0XHR2YXIgZGltID0gYi5zaGFwZVtpXTtcclxuXHRcdGlmIChpIDwgYkF4aXMpIHtcclxuXHRcdFx0b3V0ZXJTdHJpZGVCICo9IGRpbTtcclxuXHRcdFx0c2hhcGVPdXQucHVzaChkaW0pO1xyXG5cdFx0fSBlbHNlIGlmIChpID4gYkF4aXMpIHtcclxuXHRcdFx0aW5uZXJTdHJpZGVCICo9IGRpbTtcclxuXHRcdFx0c2hhcGVPdXQucHVzaChkaW0pO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRpZiAodHlwZW9mIG91dCA9PT0gXCJ1bmRlZmluZWRcIikge1xyXG5cdFx0b3V0ID0gdGhpcy5lbXB0eShzaGFwZU91dCwgYS5kYXRhVHlwZSk7XHJcblx0fSBlbHNlIGlmIChvdXQgaW5zdGFuY2VvZiBOREFycmF5KSB7XHJcblx0XHR1dGlsLmNoZWNrTkRBcnJheShvdXQsIFwib3V0XCIpO1xyXG5cdFx0dXRpbC5jaGVja1NoYXBlc0NvbXBhdGliaWxpdHkob3V0LnNoYXBlLCBzaGFwZU91dCk7XHJcblx0XHR1dGlsLmNoZWNrRGF0YVR5cGVzQ29tcGF0aWJpbGl0eShvdXQuZGF0YVR5cGUsIGEuZGF0YVR5cGUpO1xyXG5cdFx0dXRpbC5jaGVja0RpZmZlcmVudE5EQXJyYXlzKGEsIG91dCwgXCJhXCIsIFwib3V0XCIpO1xyXG5cdFx0dXRpbC5jaGVja0RpZmZlcmVudE5EQXJyYXlzKGIsIG91dCwgXCJiXCIsIFwib3V0XCIpO1xyXG5cdFx0b3V0Ll9pbmNSZWYoKTtcclxuXHR9XHJcblx0anNtYXRoLmRvdChhLl9kYXRhLCBiLl9kYXRhLCBvdXQuX2RhdGEsIHN0cmlkZUEsIG91dGVyU3RyaWRlQiwgaW5uZXJTdHJpZGVCLCByZWR1Y3Rpb25EaW0pO1xyXG5cdGEuX3RyeVJlbGVhc2UoKTtcclxuXHRiLl90cnlSZWxlYXNlKCk7XHJcblx0cmV0dXJuIG91dDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGFuIGFyaXRobWV0aWMgc2VxdWVuY2UuXHJcbiAqXHJcbiAqIEBtZXRob2QgbGluc3BhY2VcclxuICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0IC0gdGhlIHN0YXJ0aW5nIGVuZHBvaW50IG9mIHRoZSBzZXF1ZW5jZS4gTXVzdCBiZSBhIGZpbml0ZSBudW1iZXIuXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBzdG9wIC0gdGhlIGZpbmFsIGVuZHBvaW50IG9mIHRoZSBzZXF1ZW5jZS4gTXVzdCBiZSBhIGZpbml0ZSBudW1iZXIuXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbc2FtcGxlcz01MF0gLSB0aGUgbnVtYmVyIG9mIHNhbXBsZXMgaW4gdGhlIHNlcXVlbmN5LiBNdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlci5cclxuICogQHBhcmFtIHtCb29sZWFufSBbY2xvc2VkPXRydWVdIC0gYW4gaW5kaWNhdG9yIG9mIHdoZXRoZXIgdGhlIGZpbmFsIGVuZHBvaW50IChgc3RvcGAgYXJndW1lbnQpIHNob3VsZCBiZSBpbmNsdWRlZCBpbiB0aGUgc2VxdWVuY2UuXHJcbiAqL1xyXG5KU0NvbnRleHQucHJvdG90eXBlLmxpbnNwYWNlID0gZnVuY3Rpb24oc3RhcnQsIHN0b3AsIHNhbXBsZXMsIGNsb3NlZCkge1xyXG5cdGlmICghdXRpbC5pc1JlYWwoc3RhcnQpKSB7XHJcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKHN0YXJ0ICsgXCIgaXMgbm90IGEgcmVhbCBudW1iZXJcIik7XHJcblx0fVxyXG5cdGlmICghdXRpbC5pc1JlYWwoc3RvcCkpIHtcclxuXHRcdHRocm93IG5ldyBUeXBlRXJyb3Ioc3RvcCArIFwiIGlzIG5vdCBhIHJlYWwgbnVtYmVyXCIpO1xyXG5cdH1cclxuXHRpZiAodHlwZW9mIHNhbXBsZXMgPT09IFwidW5kZWZpbmVkXCIpIHtcclxuXHRcdC8qIERlZmF1bHQgdmFsdWUgaW4gTnVtUHkgKi9cclxuXHRcdHNhbXBsZXMgPSA1MDtcclxuXHR9IGVsc2UgaWYgKCF1dGlsLmlzSW50KHNhbXBsZXMpKSB7XHJcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKHNhbXBsZXMgKyBcIiBpcyBub3QgYW4gaW50ZWdlclwiKTtcclxuXHR9IGVsc2UgaWYgKHNhbXBsZXMgPD0gMCkge1xyXG5cdFx0dGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUaGUgbnVtYmVyIG9mIHNhbXBsZXMgbXVzdCBiZSBwb3NpdGl2ZVwiKTtcclxuXHR9XHJcblx0aWYgKHR5cGVvZiBjbG9zZWQgPT09IFwidW5kZWZpbmVkXCIpIHtcclxuXHRcdGNsb3NlZCA9IHRydWU7XHJcblx0fVxyXG5cdGlmIChjbG9zZWQgJiYgKHNhbXBsZXMgPT09IDEpKSB7XHJcblx0XHR0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlRoZSBudW1iZXIgb2Ygc2FtcGxlcyBtdXN0IGJlIGEgbGVhc3QgMiAoZm9yIHN0YXJ0IGFuZCBlbmQgcG9pbnRzKVwiKTtcclxuXHR9XHJcblx0dmFyIGFycmF5ID0gdGhpcy5lbXB0eShzYW1wbGVzLCBuZXcgRGF0YVR5cGUoXCJmNjRcIikpO1xyXG5cdHZhciBkYXRhID0gYXJyYXkuX2RhdGE7XHJcblx0dmFyIHJhbmdlID0gc3RvcCAtIHN0YXJ0O1xyXG5cdHZhciBuID0gKGNsb3NlZCkgPyBzYW1wbGVzIC0gMSA6IHNhbXBsZXM7XHJcblx0dmFyIHN0ZXAgPSByYW5nZSAvIG47XHJcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzYW1wbGVzOyBpKyspIHtcclxuXHRcdGRhdGFbaV0gPSBzdGFydCArIHN0ZXAgKiBpO1xyXG5cdH1cclxuXHRyZXR1cm4gYXJyYXk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEpTQ29udGV4dDtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG52YXIgUEJDb250ZXh0ID0gcmVxdWlyZShcIi4vLi4vUEJDb250ZXh0LmpzXCIpO1xyXG5cclxuZnVuY3Rpb24gV2ViV29ya2VyQ29udGV4dChvcHRpb25zLCBjYWxsYmFjaykge1xyXG5cdHZhciBzZWxmID0gdGhpcztcclxuXHR0aGlzLl93b3JrZXIgPSBuZXcgV29ya2VyKFdlYldvcmtlckNvbnRleHQuZ2V0V29ya2VyVVJMKG9wdGlvbnMuYmFzZVVybCkpO1xyXG5cdHRoaXMuX3dvcmtlci5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBmdW5jdGlvbihlKSB7XHJcblx0XHRzZWxmLl9tZXNzYWdpbmdDb250ZXh0Ll9vbk1lc3NhZ2UoZSk7XHJcblx0fSwgdHJ1ZSk7XHJcblx0dGhpcy5fbWVzc2FnaW5nQ29udGV4dCA9IG5ldyBQQkNvbnRleHQob3B0aW9ucywgZnVuY3Rpb24obWVzc2FnZSkge1xyXG5cdFx0c2VsZi5fd29ya2VyLnBvc3RNZXNzYWdlKG1lc3NhZ2UsIFttZXNzYWdlXSk7XHJcblx0fSwgY2FsbGJhY2spO1xyXG59XHJcblxyXG5XZWJXb3JrZXJDb250ZXh0LmlzU3VwcG9ydGVkID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHR5cGVvZiBXb3JrZXIgIT09IFwidW5kZWZpbmVkXCI7XHJcbn07XHJcblxyXG5XZWJXb3JrZXJDb250ZXh0LmdldFdvcmtlclVSTCA9IGZ1bmN0aW9uKGJhc2VVcmwpIHtcclxuXHRpZiAoYmFzZVVybCkge1xyXG5cdFx0cmV0dXJuIGJhc2VVcmwgKyBcImZ1cmlvdXMtd29ya2VyLm1pbi5qc1wiO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRyZXR1cm4gXCJmdXJpb3VzLXdvcmtlci5taW4uanNcIjtcclxuXHR9XHJcbn07XHJcblxyXG5XZWJXb3JrZXJDb250ZXh0LnByb3RvdHlwZS5lbXB0eSA9IGZ1bmN0aW9uKHNoYXBlLCBkYXRhVHlwZSkge1xyXG5cdHJldHVybiB0aGlzLl9tZXNzYWdpbmdDb250ZXh0LmVtcHR5KHNoYXBlLCBkYXRhVHlwZSk7XHJcbn07XHJcblxyXG5XZWJXb3JrZXJDb250ZXh0LnByb3RvdHlwZS56ZXJvcyA9IGZ1bmN0aW9uKHNoYXBlLCBkYXRhVHlwZSkge1xyXG5cdHJldHVybiB0aGlzLl9tZXNzYWdpbmdDb250ZXh0Lnplcm9zKHNoYXBlLCBkYXRhVHlwZSk7XHJcbn07XHJcblxyXG5XZWJXb3JrZXJDb250ZXh0LnByb3RvdHlwZS5vbmVzID0gZnVuY3Rpb24oc2hhcGUsIGRhdGFUeXBlKSB7XHJcblx0cmV0dXJuIHRoaXMuX21lc3NhZ2luZ0NvbnRleHQub25lcyhzaGFwZSwgZGF0YVR5cGUpO1xyXG59O1xyXG5cclxuV2ViV29ya2VyQ29udGV4dC5wcm90b3R5cGUuYXJyYXkgPSBmdW5jdGlvbihkYXRhLCBkYXRhVHlwZSkge1xyXG5cdHJldHVybiB0aGlzLl9tZXNzYWdpbmdDb250ZXh0LmFycmF5KGRhdGEsIGRhdGFUeXBlKTtcclxufTtcclxuXHJcbldlYldvcmtlckNvbnRleHQucHJvdG90eXBlLmxpbnNwYWNlID0gZnVuY3Rpb24oc3RhcnQsIHN0b3AsIHNhbXBsZXMsIGNsb3NlZCkge1xyXG5cdHJldHVybiB0aGlzLl9tZXNzYWdpbmdDb250ZXh0LmxpbnNwYWNlKHN0YXJ0LCBzdG9wLCBzYW1wbGVzLCBjbG9zZWQpO1xyXG59O1xyXG5cclxuV2ViV29ya2VyQ29udGV4dC5wcm90b3R5cGUucmVzaGFwZSA9IGZ1bmN0aW9uKGEsIHNoYXBlKSB7XHJcblx0cmV0dXJuIHRoaXMuX21lc3NhZ2luZ0NvbnRleHQucmVzaGFwZShhLCBzaGFwZSk7XHJcbn07XHJcblxyXG5XZWJXb3JrZXJDb250ZXh0LnByb3RvdHlwZS5yZXBlYXQgPSBmdW5jdGlvbihhLCByZXBlYXRzLCBheGlzLCBvdXQpIHtcclxuXHRyZXR1cm4gdGhpcy5fbWVzc2FnaW5nQ29udGV4dC5yZXBlYXQoYSwgcmVwZWF0cywgYXhpcywgb3V0KTtcclxufTtcclxuXHJcbldlYldvcmtlckNvbnRleHQucHJvdG90eXBlLl9pbnZhbGlkYXRlID0gZnVuY3Rpb24oYXJyYXkpIHtcclxuXHRyZXR1cm4gdGhpcy5fbWVzc2FnaW5nQ29udGV4dC5faW52YWxpZGF0ZShhcnJheSk7XHJcbn07XHJcblxyXG5XZWJXb3JrZXJDb250ZXh0LnByb3RvdHlwZS5mZXRjaCA9IGZ1bmN0aW9uKCkge1xyXG5cdHRoaXMuX21lc3NhZ2luZ0NvbnRleHQuZmV0Y2guYXBwbHkodGhpcy5fbWVzc2FnaW5nQ29udGV4dCwgYXJndW1lbnRzKTtcclxufTtcclxuXHJcbldlYldvcmtlckNvbnRleHQucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKCkge1xyXG5cdHRoaXMuX21lc3NhZ2luZ0NvbnRleHQuZ2V0LmFwcGx5KHRoaXMuX21lc3NhZ2luZ0NvbnRleHQsIGFyZ3VtZW50cyk7XHJcbn07XHJcblxyXG5XZWJXb3JrZXJDb250ZXh0LnByb3RvdHlwZS5pbmZvID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcclxuXHR0aGlzLl9tZXNzYWdpbmdDb250ZXh0LmluZm8oY2FsbGJhY2spO1xyXG59O1xyXG5cclxuV2ViV29ya2VyQ29udGV4dC5wcm90b3R5cGUuYmFycmllciA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XHJcblx0dGhpcy5fbWVzc2FnaW5nQ29udGV4dC5iYXJyaWVyKGNhbGxiYWNrKTtcclxufTtcclxuXHJcbldlYldvcmtlckNvbnRleHQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKGEsIGIsIG91dCkge1xyXG5cdHJldHVybiB0aGlzLl9tZXNzYWdpbmdDb250ZXh0LmFkZChhLCBiLCBvdXQpO1xyXG59O1xyXG5cclxuV2ViV29ya2VyQ29udGV4dC5wcm90b3R5cGUuc3ViID0gZnVuY3Rpb24oYSwgYiwgb3V0KSB7XHJcblx0cmV0dXJuIHRoaXMuX21lc3NhZ2luZ0NvbnRleHQuc3ViKGEsIGIsIG91dCk7XHJcbn07XHJcblxyXG5XZWJXb3JrZXJDb250ZXh0LnByb3RvdHlwZS5tdWwgPSBmdW5jdGlvbihhLCBiLCBvdXQpIHtcclxuXHRyZXR1cm4gdGhpcy5fbWVzc2FnaW5nQ29udGV4dC5tdWwoYSwgYiwgb3V0KTtcclxufTtcclxuXHJcbldlYldvcmtlckNvbnRleHQucHJvdG90eXBlLmRpdiA9IGZ1bmN0aW9uKGEsIGIsIG91dCkge1xyXG5cdHJldHVybiB0aGlzLl9tZXNzYWdpbmdDb250ZXh0LmRpdihhLCBiLCBvdXQpO1xyXG59O1xyXG5cclxuV2ViV29ya2VyQ29udGV4dC5wcm90b3R5cGUubmVnID0gZnVuY3Rpb24oYSwgb3V0KSB7XHJcblx0cmV0dXJuIHRoaXMuX21lc3NhZ2luZ0NvbnRleHQubmVnKGEsIG91dCk7XHJcbn07XHJcblxyXG5XZWJXb3JrZXJDb250ZXh0LnByb3RvdHlwZS5hYnMgPSBmdW5jdGlvbihhLCBvdXQpIHtcclxuXHRyZXR1cm4gdGhpcy5fbWVzc2FnaW5nQ29udGV4dC5hYnMoYSwgb3V0KTtcclxufTtcclxuXHJcbldlYldvcmtlckNvbnRleHQucHJvdG90eXBlLmV4cCA9IGZ1bmN0aW9uKGEsIG91dCkge1xyXG5cdHJldHVybiB0aGlzLl9tZXNzYWdpbmdDb250ZXh0LmV4cChhLCBvdXQpO1xyXG59O1xyXG5cclxuV2ViV29ya2VyQ29udGV4dC5wcm90b3R5cGUubG9nID0gZnVuY3Rpb24oYSwgb3V0KSB7XHJcblx0cmV0dXJuIHRoaXMuX21lc3NhZ2luZ0NvbnRleHQubG9nKGEsIG91dCk7XHJcbn07XHJcblxyXG5XZWJXb3JrZXJDb250ZXh0LnByb3RvdHlwZS5zcXJ0ID0gZnVuY3Rpb24oYSwgb3V0KSB7XHJcblx0cmV0dXJuIHRoaXMuX21lc3NhZ2luZ0NvbnRleHQuc3FydChhLCBvdXQpO1xyXG59O1xyXG5cclxuV2ViV29ya2VyQ29udGV4dC5wcm90b3R5cGUuc3F1YXJlID0gZnVuY3Rpb24oYSwgb3V0KSB7XHJcblx0cmV0dXJuIHRoaXMuX21lc3NhZ2luZ0NvbnRleHQuc3F1YXJlKGEsIG91dCk7XHJcbn07XHJcblxyXG5XZWJXb3JrZXJDb250ZXh0LnByb3RvdHlwZS5taW4gPSBmdW5jdGlvbihhLCBheGlzKSB7XHJcblx0cmV0dXJuIHRoaXMuX21lc3NhZ2luZ0NvbnRleHQubWluKGEsIGF4aXMpO1xyXG59O1xyXG5cclxuV2ViV29ya2VyQ29udGV4dC5wcm90b3R5cGUubWF4ID0gZnVuY3Rpb24oYSwgYXhpcykge1xyXG5cdHJldHVybiB0aGlzLl9tZXNzYWdpbmdDb250ZXh0Lm1heChhLCBheGlzKTtcclxufTtcclxuXHJcbldlYldvcmtlckNvbnRleHQucHJvdG90eXBlLnN1bSA9IGZ1bmN0aW9uKGEsIGF4aXMpIHtcclxuXHRyZXR1cm4gdGhpcy5fbWVzc2FnaW5nQ29udGV4dC5zdW0oYSwgYXhpcyk7XHJcbn07XHJcblxyXG5XZWJXb3JrZXJDb250ZXh0LnByb3RvdHlwZS5kb3QgPSBmdW5jdGlvbihhLCBiLCBvdXQpIHtcclxuXHRyZXR1cm4gdGhpcy5fbWVzc2FnaW5nQ29udGV4dC5kb3QoYSwgYiwgb3V0KTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gV2ViV29ya2VyQ29udGV4dDtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4vKipcclxuICogSmF2YVNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiBjb21wdXRhdGlvbmFsIG1ldGhvZHNcclxuICpcclxuICogQHByaXZhdGVcclxuICogQGNsYXNzIEpTTWF0aFxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBTZXRzIGFsbCBhcnJheSBlbGVtZW50cyB0byB0aGUgc3BlY2lmaWVkIHZhbHVlLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyVmlld30gZGF0YSAtIHRoZSBhcnJheSBkYXRhIGJ1ZmZlci5cclxuICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gdGhlIGNvbnN0YW50IHRvIGZpbGwgdGhlIGJ1ZmZlciB3aXRoLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAc3RhdGljXHJcbiAqIEBtZXRob2QgZmlsbFxyXG4gKi9cclxuZXhwb3J0cy5maWxsID0gZnVuY3Rpb24oZGF0YSwgdmFsdWUpIHtcclxuXHR2YXIgbiA9IGRhdGEubGVuZ3RoO1xyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKSB7XHJcblx0XHRkYXRhW2ldID0gdmFsdWU7XHJcblx0fVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEFkZHMgdHdvIGFycmF5cy5cclxuICpcclxuICogQHBhcmFtIHtBcnJheUJ1ZmZlclZpZXd9IGRhdGFBIC0gdGhlIGlucHV0IGF1Z2VuZCBhcnJheS5cclxuICogQHBhcmFtIHtBcnJheUJ1ZmZlclZpZXd9IGRhdGFCIC0gdGhlIGlucHV0IGFkZGVuZCBhcnJheS5cclxuICogQHBhcmFtIHtBcnJheUJ1ZmZlclZpZXd9IGRhdGFPdXQgLSB0aGUgb3V0cHV0IHN1bSBhcnJheS5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQHN0YXRpY1xyXG4gKiBAbWV0aG9kIGFkZFxyXG4gKi9cclxuZXhwb3J0cy5hZGQgPSBmdW5jdGlvbihkYXRhQSwgZGF0YUIsIGRhdGFPdXQpIHtcclxuXHR2YXIgbiA9IGRhdGFPdXQubGVuZ3RoO1xyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKSB7XHJcblx0XHRkYXRhT3V0W2ldID0gZGF0YUFbaV0gKyBkYXRhQltpXTtcclxuXHR9XHJcbn07XHJcblxyXG4vKipcclxuICogQWRkcyBhIGNvbnN0YW50IHRvIGFuIGFycmF5LlxyXG4gKlxyXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyVmlld30gZGF0YUEgLSB0aGUgaW5wdXQgYXVnZW5kIGFycmF5LlxyXG4gKiBAcGFyYW0ge051bWJlcn0gdmFsdWVCIC0gdGhlIGFkZGVuZCBjb25zdGFudC5cclxuICogQHBhcmFtIHtBcnJheUJ1ZmZlclZpZXd9IGRhdGFPdXQgLSB0aGUgb3V0cHV0IHN1bSBhcnJheS5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQHN0YXRpY1xyXG4gKiBAbWV0aG9kIGFkZENvbnN0XHJcbiAqL1xyXG5leHBvcnRzLmFkZENvbnN0ID0gZnVuY3Rpb24oZGF0YUEsIHZhbHVlQiwgZGF0YU91dCkge1xyXG5cdHZhciBuID0gZGF0YU91dC5sZW5ndGg7XHJcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpIHtcclxuXHRcdGRhdGFPdXRbaV0gPSBkYXRhQVtpXSArIHZhbHVlQjtcclxuXHR9XHJcbn07XHJcblxyXG4vKipcclxuICogU3VidHJhY3RzIHR3byBhcnJheXMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJWaWV3fSBkYXRhQSAtIHRoZSBpbnB1dCBtaW51ZW5kIGFycmF5LlxyXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyVmlld30gZGF0YUIgLSB0aGUgaW5wdXQgc3VidHJhaGVuZCBhcnJheS5cclxuICogQHBhcmFtIHtBcnJheUJ1ZmZlclZpZXd9IGRhdGFPdXQgLSB0aGUgb3V0cHV0IGRpZmZlcmVuY2UgYXJyYXkuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBzdGF0aWNcclxuICogQG1ldGhvZCBzdWJcclxuICovXHJcbmV4cG9ydHMuc3ViID0gZnVuY3Rpb24oZGF0YUEsIGRhdGFCLCBkYXRhT3V0KSB7XHJcblx0dmFyIG4gPSBkYXRhT3V0Lmxlbmd0aDtcclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSkge1xyXG5cdFx0ZGF0YU91dFtpXSA9IGRhdGFBW2ldIC0gZGF0YUJbaV07XHJcblx0fVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFN1YnRyYWN0cyBhIGNvbnN0YW50IGZyb20gYW4gYXJyYXkuXHJcbiAqXHJcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJWaWV3fSBkYXRhQSAtIHRoZSBpbnB1dCBtaW51ZW5kIGFycmF5LlxyXG4gKiBAcGFyYW0ge051bWJlcn0gdmFsdWVCIC0gdGhlIHN1YnRyYWhlbmQgY29uc3RhbnQuXHJcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJWaWV3fSBkYXRhT3V0IC0gdGhlIG91dHB1dCBkaWZmZXJlbmNlIGFycmF5LlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAc3RhdGljXHJcbiAqIEBtZXRob2Qgc3ViQ29uc3RcclxuICovXHJcbmV4cG9ydHMuc3ViQ29uc3QgPSBmdW5jdGlvbihkYXRhQSwgdmFsdWVCLCBkYXRhT3V0KSB7XHJcblx0dmFyIG4gPSBkYXRhT3V0Lmxlbmd0aDtcclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSkge1xyXG5cdFx0ZGF0YU91dFtpXSA9IGRhdGFBW2ldIC0gdmFsdWVCO1xyXG5cdH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBTdWJ0cmFjdHMgYW4gYXJyYXkgZnJvbSBhIGNvbnN0YW50LlxyXG4gKlxyXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyVmlld30gZGF0YUEgLSB0aGUgaW5wdXQgc3VidHJhaGVuZCBhcnJheS5cclxuICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlQiAtIHRoZSBtaW51ZW5kIGNvbnN0YW50LlxyXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyVmlld30gZGF0YU91dCAtIHRoZSBvdXRwdXQgZGlmZmVyZW5jZSBhcnJheS5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQHN0YXRpY1xyXG4gKiBAbWV0aG9kIHN1YlJldkNvbnN0XHJcbiAqL1xyXG5leHBvcnRzLnN1YlJldkNvbnN0ID0gZnVuY3Rpb24oZGF0YUEsIHZhbHVlQiwgZGF0YU91dCkge1xyXG5cdHZhciBuID0gZGF0YU91dC5sZW5ndGg7XHJcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpIHtcclxuXHRcdGRhdGFPdXRbaV0gPSB2YWx1ZUIgLSBkYXRhQVtpXTtcclxuXHR9XHJcbn07XHJcblxyXG4vKipcclxuICogTXVsdGlwbGllcyB0d28gYXJyYXlzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyVmlld30gZGF0YUEgLSB0aGUgaW5wdXQgbXVsdGlwbGljYW5kIGFycmF5LlxyXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyVmlld30gZGF0YUIgLSB0aGUgaW5wdXQgbXVsdGlwbGllciBhcnJheS5cclxuICogQHBhcmFtIHtBcnJheUJ1ZmZlclZpZXd9IGRhdGFPdXQgLSB0aGUgb3V0cHV0IHByb2R1Y3QgYXJyYXkuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBzdGF0aWNcclxuICogQG1ldGhvZCBtdWxcclxuICovXHJcbmV4cG9ydHMubXVsID0gZnVuY3Rpb24oZGF0YUEsIGRhdGFCLCBkYXRhT3V0KSB7XHJcblx0dmFyIG4gPSBkYXRhT3V0Lmxlbmd0aDtcclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSkge1xyXG5cdFx0ZGF0YU91dFtpXSA9IGRhdGFBW2ldICogZGF0YUJbaV07XHJcblx0fVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIE11bHRpcGxpZXMgYW4gYXJyYXkgYnkgYSBjb25zdGFudC5cclxuICpcclxuICogQHBhcmFtIHtBcnJheUJ1ZmZlclZpZXd9IGRhdGFBIC0gdGhlIGlucHV0IG11bHRpcGxpY2FuZCBhcnJheS5cclxuICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlQiAtIHRoZSBtdWx0aXBsaWVyIGNvbnN0YW50LlxyXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyVmlld30gZGF0YU91dCAtIHRoZSBvdXRwdXQgcHJvZHVjdCBhcnJheS5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQHN0YXRpY1xyXG4gKiBAbWV0aG9kIG11bENvbnN0XHJcbiAqL1xyXG5leHBvcnRzLm11bENvbnN0ID0gZnVuY3Rpb24oZGF0YUEsIHZhbHVlQiwgZGF0YU91dCkge1xyXG5cdHZhciBuID0gZGF0YU91dC5sZW5ndGg7XHJcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpIHtcclxuXHRcdGRhdGFPdXRbaV0gPSBkYXRhQVtpXSAqIHZhbHVlQjtcclxuXHR9XHJcbn07XHJcblxyXG4vKipcclxuICogRGl2aWRlcyB0d28gYXJyYXlzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyVmlld30gZGF0YUEgLSB0aGUgaW5wdXQgZGl2aWRlbmQgYXJyYXkuXHJcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJWaWV3fSBkYXRhQiAtIHRoZSBpbnB1dCBkaXZpc29yIGFycmF5LlxyXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyVmlld30gZGF0YU91dCAtIHRoZSBvdXRwdXQgcXVvdGllbnQgYXJyYXkuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBzdGF0aWNcclxuICogQG1ldGhvZCBkaXZcclxuICovXHJcbmV4cG9ydHMuZGl2ID0gZnVuY3Rpb24oZGF0YUEsIGRhdGFCLCBkYXRhT3V0KSB7XHJcblx0dmFyIG4gPSBkYXRhT3V0Lmxlbmd0aDtcclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSkge1xyXG5cdFx0ZGF0YU91dFtpXSA9IGRhdGFBW2ldIC8gZGF0YUJbaV07XHJcblx0fVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIERpdmlkZXMgYW4gYXJyYXkgYnkgYSBjb25zdGFudC5cclxuICpcclxuICogQHBhcmFtIHtBcnJheUJ1ZmZlclZpZXd9IGRhdGFBIC0gdGhlIGlucHV0IGRpdmlkZW5kIGFycmF5LlxyXG4gKiBAcGFyYW0ge051bWJlcn0gdmFsdWVCIC0gdGhlIGRpdmlzb3IgY29uc3RhbnQuXHJcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJWaWV3fSBkYXRhT3V0IC0gdGhlIG91dHB1dCBxdW90aWVudCBhcnJheS5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQHN0YXRpY1xyXG4gKiBAbWV0aG9kIGRpdkNvbnN0XHJcbiAqL1xyXG5leHBvcnRzLmRpdkNvbnN0ID0gZnVuY3Rpb24oZGF0YUEsIHZhbHVlQiwgZGF0YU91dCkge1xyXG5cdHZhciBuID0gZGF0YU91dC5sZW5ndGg7XHJcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpIHtcclxuXHRcdGRhdGFPdXRbaV0gPSBkYXRhQVtpXSAvIHZhbHVlQjtcclxuXHR9XHJcbn07XHJcblxyXG4vKipcclxuICogRGl2aWRlcyBhIGNvbnN0YW50IGJ5IGFuIGFycmF5LlxyXG4gKlxyXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyVmlld30gZGF0YUEgLSB0aGUgaW5wdXQgZGl2aXNvciBhcnJheS5cclxuICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlQiAtIHRoZSBkaXZpZGVuZCBjb25zdGFudC5cclxuICogQHBhcmFtIHtBcnJheUJ1ZmZlclZpZXd9IGRhdGFPdXQgLSB0aGUgb3V0cHV0IHF1b3RpZW50IGFycmF5LlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAc3RhdGljXHJcbiAqIEBtZXRob2QgZGl2UmV2Q29uc3RcclxuICovXHJcbmV4cG9ydHMuZGl2UmV2Q29uc3QgPSBmdW5jdGlvbihkYXRhQSwgdmFsdWVCLCBkYXRhT3V0KSB7XHJcblx0dmFyIG4gPSBkYXRhT3V0Lmxlbmd0aDtcclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSkge1xyXG5cdFx0ZGF0YU91dFtpXSA9IHZhbHVlQiAvIGRhdGFBW2ldO1xyXG5cdH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBOZWdhdGVzIGFuIGFycmF5LlxyXG4gKlxyXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyVmlld30gZGF0YUEgLSB0aGUgaW5wdXQgYXJyYXkuXHJcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJWaWV3fSBkYXRhT3V0IC0gdGhlIG91dHB1dCBhcnJheS5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQHN0YXRpY1xyXG4gKiBAbWV0aG9kIG5lZ1xyXG4gKi9cclxuZXhwb3J0cy5uZWcgPSBmdW5jdGlvbihkYXRhQSwgZGF0YU91dCkge1xyXG5cdHZhciBuID0gZGF0YU91dC5sZW5ndGg7XHJcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpIHtcclxuXHRcdGRhdGFPdXRbaV0gPSAtZGF0YUFbaV07XHJcblx0fVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvbXB1dGVzIGFic29sdXRlIHZhbHVlIG9mIGFycmF5IGVsZW1lbnRzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyVmlld30gZGF0YUEgLSB0aGUgaW5wdXQgYXJyYXkuXHJcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJWaWV3fSBkYXRhT3V0IC0gdGhlIG91dHB1dCBhcnJheS5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQHN0YXRpY1xyXG4gKiBAbWV0aG9kIGFic1xyXG4gKi9cclxuZXhwb3J0cy5hYnMgPSBmdW5jdGlvbihkYXRhQSwgZGF0YU91dCkge1xyXG5cdHZhciBuID0gZGF0YU91dC5sZW5ndGg7XHJcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpIHtcclxuXHRcdGRhdGFPdXRbaV0gPSBNYXRoLmFicyhkYXRhQVtpXSk7XHJcblx0fVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEV4cG9uZW50aWF0ZXMgYXJyYXkgZWxlbWVudHMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJWaWV3fSBkYXRhQSAtIHRoZSBpbnB1dCBhcnJheS5cclxuICogQHBhcmFtIHtBcnJheUJ1ZmZlclZpZXd9IGRhdGFPdXQgLSB0aGUgb3V0cHV0IGFycmF5LlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAc3RhdGljXHJcbiAqIEBtZXRob2QgZXhwXHJcbiAqL1xyXG5leHBvcnRzLmV4cCA9IGZ1bmN0aW9uKGRhdGFBLCBkYXRhT3V0KSB7XHJcblx0dmFyIG4gPSBkYXRhT3V0Lmxlbmd0aDtcclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSkge1xyXG5cdFx0ZGF0YU91dFtpXSA9IE1hdGguZXhwKGRhdGFBW2ldKTtcclxuXHR9XHJcbn07XHJcblxyXG4vKipcclxuICogQ29tcHV0ZXMgbG9nYXJpdGhtIG9mIGFycmF5IGVsZW1lbnRzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyVmlld30gZGF0YUEgLSB0aGUgaW5wdXQgYXJyYXkuXHJcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJWaWV3fSBkYXRhT3V0IC0gdGhlIG91dHB1dCBhcnJheS5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQHN0YXRpY1xyXG4gKiBAbWV0aG9kIGxvZ1xyXG4gKi9cclxuZXhwb3J0cy5sb2cgPSBmdW5jdGlvbihkYXRhQSwgZGF0YU91dCkge1xyXG5cdHZhciBuID0gZGF0YU91dC5sZW5ndGg7XHJcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpIHtcclxuXHRcdGRhdGFPdXRbaV0gPSBNYXRoLmxvZyhkYXRhQVtpXSk7XHJcblx0fVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvbXB1dGVzIHNxdWFyZSByb290IG9mIGFycmF5IGVsZW1lbnRzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyVmlld30gZGF0YUEgLSB0aGUgaW5wdXQgYXJyYXkuXHJcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJWaWV3fSBkYXRhT3V0IC0gdGhlIG91dHB1dCBhcnJheS5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQHN0YXRpY1xyXG4gKiBAbWV0aG9kIHNxcnRcclxuICovXHJcbmV4cG9ydHMuc3FydCA9IGZ1bmN0aW9uKGRhdGFBLCBkYXRhT3V0KSB7XHJcblx0dmFyIG4gPSBkYXRhT3V0Lmxlbmd0aDtcclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSkge1xyXG5cdFx0ZGF0YU91dFtpXSA9IE1hdGguc3FydChkYXRhQVtpXSk7XHJcblx0fVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFNxdWFyZXMgYXJyYXkgZWxlbWVudHMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJWaWV3fSBkYXRhQSAtIHRoZSBpbnB1dCBhcnJheS5cclxuICogQHBhcmFtIHtBcnJheUJ1ZmZlclZpZXd9IGRhdGFPdXQgLSB0aGUgb3V0cHV0IGFycmF5LlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAc3RhdGljXHJcbiAqIEBtZXRob2Qgc3F1YXJlXHJcbiAqL1xyXG5leHBvcnRzLnNxdWFyZSA9IGZ1bmN0aW9uKGRhdGFBLCBkYXRhT3V0KSB7XHJcblx0dmFyIG4gPSBkYXRhT3V0Lmxlbmd0aDtcclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSkge1xyXG5cdFx0dmFyIGEgPSBkYXRhQVtpXTtcclxuXHRcdGRhdGFPdXRbaV0gPSBhICogYTtcclxuXHR9XHJcbn07XHJcblxyXG4vKipcclxuICogQ29tcHV0ZXMgdGhlIG1pbmltdW0gdmFsdWUgb2YgZWxlbWVudHMgaW4gYW4gYXJyYXkuXHJcbiAqXHJcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJWaWV3fSBkYXRhQSAtIHRoZSBpbnB1dCBhcnJheSB0byBjb21wdXRlIG1pbmltdW0gb24uXHJcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJWaWV3fSBkYXRhT3V0IC0gdGhlIG91dHB1dCBhcnJheSB0byBzdG9yZSB0aGUgbWluaW11bSBhdC5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQHN0YXRpY1xyXG4gKiBAbWV0aG9kIG1pblxyXG4gKi9cclxuZXhwb3J0cy5taW4gPSBmdW5jdGlvbihkYXRhQSwgZGF0YU91dCkge1xyXG5cdC8qIENvbXB1dGF0aW9uIG9mIGFsbC1hcnJheSBtaW4gKi9cclxuXHR2YXIgbGVuZ3RoQSA9IGRhdGFBLmxlbmd0aDtcclxuXHR2YXIgcmVzdWx0ID0gZGF0YUFbMF07XHJcblx0Zm9yICh2YXIgaSA9IDE7IGkgPCBsZW5ndGhBOyArK2kpIHtcclxuXHRcdHJlc3VsdCA9IE1hdGgubWluKHJlc3VsdCwgZGF0YUFbaV0pO1xyXG5cdH1cclxuXHRkYXRhT3V0WzBdID0gcmVzdWx0O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvbXB1dGVzIHRoZSBtYXhpbXVtIHZhbHVlIG9mIGVsZW1lbnRzIGluIGFuIGFycmF5LlxyXG4gKlxyXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyVmlld30gZGF0YUEgLSB0aGUgaW5wdXQgYXJyYXkgdG8gY29tcHV0ZSBtYXhpbXVtIG9uLlxyXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyVmlld30gZGF0YU91dCAtIHRoZSBvdXRwdXQgYXJyYXkgdG8gc3RvcmUgdGhlIG1heGltdW0gYXQuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBzdGF0aWNcclxuICogQG1ldGhvZCBtYXhcclxuICovXHJcbmV4cG9ydHMubWF4ID0gZnVuY3Rpb24oZGF0YUEsIGRhdGFPdXQpIHtcclxuXHQvKiBDb21wdXRhdGlvbiBvZiBhbGwtYXJyYXkgbWluICovXHJcblx0dmFyIGxlbmd0aEEgPSBkYXRhQS5sZW5ndGg7XHJcblx0dmFyIHJlc3VsdCA9IGRhdGFBWzBdO1xyXG5cdGZvciAodmFyIGkgPSAxOyBpIDwgbGVuZ3RoQTsgKytpKSB7XHJcblx0XHRyZXN1bHQgPSBNYXRoLm1heChyZXN1bHQsIGRhdGFBW2ldKTtcclxuXHR9XHJcblx0ZGF0YU91dFswXSA9IHJlc3VsdDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb21wdXRlcyB0aGUgc3VtIG9mIGVsZW1lbnRzIGluIGFuIGFycmF5LlxyXG4gKlxyXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyVmlld30gZGF0YUEgLSB0aGUgaW5wdXQgYXJyYXkgd2l0aCBlbGVtZW50cyB0byBzdW0gdXAuXHJcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJWaWV3fSBkYXRhT3V0IC0gdGhlIG91dHB1dCBhcnJheSB0byBzdG9yZSB0aGUgc3VtIGF0LlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAc3RhdGljXHJcbiAqIEBtZXRob2QgbWluXHJcbiAqL1xyXG5leHBvcnRzLnN1bSA9IGZ1bmN0aW9uKGRhdGFBLCBkYXRhT3V0KSB7XHJcblx0dmFyIGxlbmd0aEEgPSBkYXRhQS5sZW5ndGg7XHJcblx0dmFyIHJlc3VsdCA9IDAuMDtcclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aEE7ICsraSkge1xyXG5cdFx0cmVzdWx0ICs9IGRhdGFBW2ldO1xyXG5cdH1cclxuXHRkYXRhT3V0WzBdID0gcmVzdWx0O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvbXB1dGVzIHRoZSBtaW5pbXVtIHZhbHVlIG9mIGVsZW1lbnRzIGFsb25nIGFuIGF4aXMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJWaWV3fSBkYXRhQSAtIHRoZSBpbnB1dCBhcnJheSB0byBjb21wdXRlIG1pbmltYSBvbi5cclxuICogQHBhcmFtIHtBcnJheUJ1ZmZlclZpZXd9IGRhdGFPdXQgLSB0aGUgb3V0cHV0IGFycmF5IHRvIHN0b3JlIHRoZSBtaW5pbWEgYXQuXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBvdXRlclN0cmlkZSAtIHRoZSBwcm9kdWN0IG9mIGlucHV0IGFycmF5IGRpbWVuc2lvbnMgcHJlY2VlZGluZyB0aGUgcmVkdWN0aW9uIGRpbWVuc2lvbi5cclxuICogQHBhcmFtIHtOdW1iZXJ9IGlubmVyU3RyaWRlIC0gdGhlIHByb2R1Y3Qgb2YgaW5wdXQgYXJyYXkgZGltZW5zaW9ucyBmb2xsb3dpbmcgdGhlIHJlZHVjdGlvbiBkaW1lbnNpb24uXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSByZWR1Y3Rpb25EaW0gLSB0aGUgbGVuZ3RoIG9mIGlucHV0IGFycmF5IGFsb25nIHRoZSByZWR1Y3Rpb24gZGltZW5zaW9uLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAc3RhdGljXHJcbiAqIEBtZXRob2QgYXhpc01pblxyXG4gKi9cclxuZXhwb3J0cy5heGlzTWluID0gZnVuY3Rpb24oZGF0YUEsIGRhdGFPdXQsIG91dGVyU3RyaWRlLCBpbm5lclN0cmlkZSwgcmVkdWN0aW9uRGltKSB7XHJcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBvdXRlclN0cmlkZTsgKytpKSB7XHJcblx0XHRmb3IgKHZhciBrID0gMDsgayA8IGlubmVyU3RyaWRlOyArK2spIHtcclxuXHRcdFx0dmFyIG9mZnNldCA9IGkgKiByZWR1Y3Rpb25EaW0gKiBpbm5lclN0cmlkZSArIGs7XHJcblx0XHRcdHZhciBjdXJyZW50TWluID0gZGF0YUFbb2Zmc2V0XTtcclxuXHRcdFx0Zm9yICh2YXIgaiA9IDE7IGogPCByZWR1Y3Rpb25EaW07ICsraikge1xyXG5cdFx0XHRcdG9mZnNldCArPSBpbm5lclN0cmlkZTtcclxuXHRcdFx0XHRjdXJyZW50TWluID0gTWF0aC5taW4oY3VycmVudE1pbiwgZGF0YUFbb2Zmc2V0XSk7XHJcblx0XHRcdH1cclxuXHRcdFx0ZGF0YU91dFtpICogaW5uZXJTdHJpZGUgKyBrXSA9IGN1cnJlbnRNaW47XHJcblx0XHR9XHJcblx0fVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvbXB1dGVzIHRoZSBtYXhpbXVtIHZhbHVlIG9mIGVsZW1lbnRzIGFsb25nIGFuIGF4aXMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJWaWV3fSBkYXRhQSAtIHRoZSBpbnB1dCBhcnJheSB0byBjb21wdXRlIG1heGltYSBvbi5cclxuICogQHBhcmFtIHtBcnJheUJ1ZmZlclZpZXd9IGRhdGFPdXQgLSB0aGUgb3V0cHV0IGFycmF5IHRvIHN0b3JlIHRoZSBtYXhpbWEgYXQuXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBvdXRlclN0cmlkZSAtIHRoZSBwcm9kdWN0IG9mIGlucHV0IGFycmF5IGRpbWVuc2lvbnMgcHJlY2VlZGluZyB0aGUgcmVkdWN0aW9uIGRpbWVuc2lvbi5cclxuICogQHBhcmFtIHtOdW1iZXJ9IGlubmVyU3RyaWRlIC0gdGhlIHByb2R1Y3Qgb2YgaW5wdXQgYXJyYXkgZGltZW5zaW9ucyBmb2xsb3dpbmcgdGhlIHJlZHVjdGlvbiBkaW1lbnNpb24uXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSByZWR1Y3Rpb25EaW0gLSB0aGUgbGVuZ3RoIG9mIGlucHV0IGFycmF5IGFsb25nIHRoZSByZWR1Y3Rpb24gZGltZW5zaW9uLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAc3RhdGljXHJcbiAqIEBtZXRob2QgYXhpc01heFxyXG4gKi9cclxuZXhwb3J0cy5heGlzTWF4ID0gZnVuY3Rpb24oZGF0YUEsIGRhdGFPdXQsIG91dGVyU3RyaWRlLCBpbm5lclN0cmlkZSwgcmVkdWN0aW9uRGltKSB7XHJcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBvdXRlclN0cmlkZTsgKytpKSB7XHJcblx0XHRmb3IgKHZhciBrID0gMDsgayA8IGlubmVyU3RyaWRlOyArK2spIHtcclxuXHRcdFx0dmFyIG9mZnNldCA9IGkgKiByZWR1Y3Rpb25EaW0gKiBpbm5lclN0cmlkZSArIGs7XHJcblx0XHRcdHZhciBjdXJyZW50TWF4ID0gZGF0YUFbb2Zmc2V0XTtcclxuXHRcdFx0Zm9yICh2YXIgaiA9IDE7IGogPCByZWR1Y3Rpb25EaW07ICsraikge1xyXG5cdFx0XHRcdG9mZnNldCArPSBpbm5lclN0cmlkZTtcclxuXHRcdFx0XHRjdXJyZW50TWF4ID0gTWF0aC5tYXgoY3VycmVudE1heCwgZGF0YUFbb2Zmc2V0XSk7XHJcblx0XHRcdH1cclxuXHRcdFx0ZGF0YU91dFtpICogaW5uZXJTdHJpZGUgKyBrXSA9IGN1cnJlbnRNYXg7XHJcblx0XHR9XHJcblx0fVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvbXB1dGVzIHRoZSBzdW0gb2YgZWxlbWVudHMgYWxvbmcgYW4gYXhpcy5cclxuICpcclxuICogQHBhcmFtIHtBcnJheUJ1ZmZlclZpZXd9IGRhdGFBIC0gdGhlIGlucHV0IGFycmF5IHRvIHN1bSB1cC5cclxuICogQHBhcmFtIHtBcnJheUJ1ZmZlclZpZXd9IGRhdGFPdXQgLSB0aGUgb3V0cHV0IGFycmF5IHRvIHN0b3JlIHRoZSBzdW1zIGF0LlxyXG4gKiBAcGFyYW0ge051bWJlcn0gb3V0ZXJTdHJpZGUgLSB0aGUgcHJvZHVjdCBvZiBpbnB1dCBhcnJheSBkaW1lbnNpb25zIHByZWNlZWRpbmcgdGhlIHJlZHVjdGlvbiBkaW1lbnNpb24uXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBpbm5lclN0cmlkZSAtIHRoZSBwcm9kdWN0IG9mIGlucHV0IGFycmF5IGRpbWVuc2lvbnMgZm9sbG93aW5nIHRoZSByZWR1Y3Rpb24gZGltZW5zaW9uLlxyXG4gKiBAcGFyYW0ge051bWJlcn0gcmVkdWN0aW9uRGltIC0gdGhlIGxlbmd0aCBvZiBpbnB1dCBhcnJheSBhbG9uZyB0aGUgcmVkdWN0aW9uIGRpbWVuc2lvbi5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQHN0YXRpY1xyXG4gKiBAbWV0aG9kIGF4aXNTdW1cclxuICovXHJcbmV4cG9ydHMuYXhpc1N1bSA9IGZ1bmN0aW9uKGRhdGFBLCBkYXRhT3V0LCBvdXRlclN0cmlkZSwgaW5uZXJTdHJpZGUsIHJlZHVjdGlvbkRpbSkge1xyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgb3V0ZXJTdHJpZGU7ICsraSkge1xyXG5cdFx0Zm9yICh2YXIgayA9IDA7IGsgPCBpbm5lclN0cmlkZTsgKytrKSB7XHJcblx0XHRcdHZhciBvZmZzZXQgPSBpICogcmVkdWN0aW9uRGltICogaW5uZXJTdHJpZGUgKyBrO1xyXG5cdFx0XHR2YXIgY3VycmVudFN1bSA9IGRhdGFBW29mZnNldF07XHJcblx0XHRcdGZvciAodmFyIGogPSAxOyBqIDwgcmVkdWN0aW9uRGltOyArK2opIHtcclxuXHRcdFx0XHRvZmZzZXQgKz0gaW5uZXJTdHJpZGU7XHJcblx0XHRcdFx0Y3VycmVudFN1bSArPSBkYXRhQVtvZmZzZXRdO1xyXG5cdFx0XHR9XHJcblx0XHRcdGRhdGFPdXRbaSAqIGlubmVyU3RyaWRlICsga10gPSBjdXJyZW50U3VtO1xyXG5cdFx0fVxyXG5cdH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb21wdXRlcyB0aGUgZG90IHByb2R1Y3Qgb2YgdHdvIE4tZGltZW5zaW9uYWwgYXJyYXlzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyVmlld30gZGF0YUEgLSBhbiBpbnB1dCBtdWx0aXBsaWNhbmQgYXJyYXkuXHJcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJWaWV3fSBkYXRhQiAtIGFuIGlucHV0IG11bHRpcGxpZXIgYXJyYXkuXHJcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJWaWV3fSBkYXRhT3V0IC0gdGhlIG91dHB1dCBwcm9kdWN0IGFycmF5LlxyXG4gKiBAcGFyYW0ge051bWJlcn0gc3RyaWRlQSAtIHRoZSBwcm9kdWN0IG9mIHRoZSB0aGUgbXVsdGlwbGljYW5kIGRpbWVuc2lvbnMgcHJlY2VlZGluZyB0aGUgcmVkdWN0aW9uIGRpbWVuc2lvbi5cclxuICogQHBhcmFtIHtOdW1iZXJ9IG91dGVyU3RyaWRlQiAtIHRoZSBwcm9kdWN0IG9mIHRoZSBtdWx0aXBsaWVyIGRpbWVuc2lvbnMgcHJlY2VlZGluZyB0aGUgcmVkdWN0aW9uIGRpbWVuc2lvbi5cclxuICogQHBhcmFtIHtOdW1iZXJ9IGlubmVyU3RyaWRlQiAtIHRoZSBwcm9kdWN0IG9mIHRoZSBtdWx0aXBsaWVyIGRpbWVuc2lvbnMgZm9sbG93aW5nIHRoZSByZWR1Y3Rpb24gZGltZW5zaW9uLlxyXG4gKiBAcGFyYW0ge051bWJlcn0gcmVkdWN0aW9uRGltIC0gdGhlIGxlbmd0aCBvZiBpbnB1dHMgYXJyYXlzIGFsb25nIHRoZSByZWR1Y3Rpb24gZGltZW5zaW9uLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAc3RhdGljXHJcbiAqIEBtZXRob2QgZG90XHJcbiAqL1xyXG5leHBvcnRzLmRvdCA9IGZ1bmN0aW9uKGRhdGFBLCBkYXRhQiwgZGF0YU91dCwgc3RyaWRlQSwgb3V0ZXJTdHJpZGVCLCBpbm5lclN0cmlkZUIsIHJlZHVjdGlvbkRpbSkge1xyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgc3RyaWRlQTsgKytpKSB7XHJcblx0XHRmb3IgKHZhciBqID0gMDsgaiA8IHJlZHVjdGlvbkRpbTsgKytqKSB7XHJcblx0XHRcdGZvciAodmFyIGsgPSAwOyBrIDwgb3V0ZXJTdHJpZGVCOyArK2spIHtcclxuXHRcdFx0XHRmb3IgKHZhciBsID0gMDsgbCA8IGlubmVyU3RyaWRlQjsgKytsKSB7XHJcblx0XHRcdFx0XHRkYXRhT3V0WyhpKm91dGVyU3RyaWRlQiArIGspICogaW5uZXJTdHJpZGVCICsgbF0gKz0gZGF0YUFbaSpyZWR1Y3Rpb25EaW0ral0gKiBkYXRhQlsoaypyZWR1Y3Rpb25EaW0raikqaW5uZXJTdHJpZGVCK2xdO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXBsaWNhdGVzIGFycmF5IGVsZW1lbnRzIGFsb25nIGFuIGF4aXMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJWaWV3fSBkYXRhQSAtIHRoZSBpbnB1dCBhcnJheS5cclxuICogQHBhcmFtIHtBcnJheUJ1ZmZlclZpZXd9IGRhdGFPdXQgLSB0aGUgb3V0cHV0IGFycmF5IGZvciByZXBlYXRlZCBlbGVtZW50cy5cclxuICogQHBhcmFtIHtOdW1iZXJ9IG91dGVyU3RyaWRlIC0gdGhlIHByb2R1Y3Qgb2YgaW5wdXQgYXJyYXkgZGltZW5zaW9ucyBwcmVjZWVkaW5nIHRoZSBleHBhbnNpb24gZGltZW5zaW9uLlxyXG4gKiBAcGFyYW0ge051bWJlcn0gaW5uZXJTdHJpZGUgLSB0aGUgcHJvZHVjdCBvZiBpbnB1dCBhcnJheSBkaW1lbnNpb25zIGZvbGxvd2luZyB0aGUgZXhwYW5zaW9uIGRpbWVuc2lvbi5cclxuICogQHBhcmFtIHtOdW1iZXJ9IGV4cGFuc2lvbkRpbSAtIHRoZSBsZW5ndGggb2YgaW5wdXQgYXJyYXkgYWxvbmcgdGhlIGV4cGFuc2lvbiBkaW1lbnNpb24uXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSByZXBlYXRzIC0gdGhlIG51bWJlciBvZiB0aW1lcyBlYWNoIGVsZW1lbnQgd2lsbCBiZSByZXBsaWNhdGVkLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAc3RhdGljXHJcbiAqIEBtZXRob2QgcmVwZWF0XHJcbiAqL1xyXG5leHBvcnRzLnJlcGVhdCA9IGZ1bmN0aW9uKGRhdGFBLCBkYXRhT3V0LCBvdXRlclN0cmlkZSwgaW5uZXJTdHJpZGUsIGV4cGFuc2lvbkRpbSwgcmVwZWF0cykge1xyXG5cdGlmIChpbm5lclN0cmlkZSA8IHJlcGVhdHMpIHtcclxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgb3V0ZXJTdHJpZGU7ICsraSkge1xyXG5cdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGV4cGFuc2lvbkRpbTsgKytqKSB7XHJcblx0XHRcdFx0Zm9yICh2YXIgayA9IDA7IGsgPCBpbm5lclN0cmlkZTsgKytrKSB7XHJcblx0XHRcdFx0XHR2YXIgdmFsdWVBID0gZGF0YUFbKGkgKiBleHBhbnNpb25EaW0gKyBqKSAqIGlubmVyU3RyaWRlICsga107XHJcblx0XHRcdFx0XHRmb3IgKHZhciBjID0gMDsgYyA8IHJlcGVhdHM7ICsrYykge1xyXG5cdFx0XHRcdFx0XHRkYXRhT3V0WygoaSAqIGV4cGFuc2lvbkRpbSArIGopICogcmVwZWF0cyArIGMpICogaW5uZXJTdHJpZGUgKyBrXSA9IHZhbHVlQTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9IGVsc2Uge1xyXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBvdXRlclN0cmlkZTsgKytpKSB7XHJcblx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgZXhwYW5zaW9uRGltOyArK2opIHtcclxuXHRcdFx0XHR2YXIgcm93QSA9IGRhdGFBLnN1YmFycmF5KChpICogZXhwYW5zaW9uRGltICsgaikgKiBpbm5lclN0cmlkZSwgKGkgKiBleHBhbnNpb25EaW0gKyBqICsgMSkgKiBpbm5lclN0cmlkZSk7XHJcblx0XHRcdFx0Zm9yICh2YXIgYyA9IDA7IGMgPCByZXBlYXRzOyArK2MpIHtcclxuXHRcdFx0XHRcdGRhdGFPdXQuc2V0KHJvd0EsICgoaSAqIGV4cGFuc2lvbkRpbSArIGopICogcmVwZWF0cyArIGMpICogaW5uZXJTdHJpZGUpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxufTtcclxuIiwiXG52YXIgcHJvdG9idWZqcyA9IHJlcXVpcmUoXCJwcm90b2J1ZmpzXCIpO1xucHJvdG9idWZqcy5jb252ZXJ0RmllbGRzVG9DYW1lbENhc2UgPSB0cnVlO1xudmFyIHJlcXVlc3RzUHJvdG8gPSBcInBhY2thZ2UgZnVyaW91cztcXHJcXG5cXHJcXG5vcHRpb24gb3B0aW1pemVfZm9yID0gTElURV9SVU5USU1FO1xcclxcblxcclxcbmVudW0gRGF0YVR5cGUge1xcclxcblxcdEZMT0FUNjQgPSAwO1xcclxcblxcdEZMT0FUMzIgPSAxO1xcclxcbn1cXHJcXG5cXHJcXG5tZXNzYWdlIFJlcXVlc3Qge1xcclxcblxcdGVudW0gVHlwZSB7XFxyXFxuXFx0XFx0RU1QVFlfQVJSQVkgICAgICAgICAgICAgID0gIDA7XFxyXFxuXFx0XFx0REFUQV9BUlJBWSAgICAgICAgICAgICAgID0gIDE7XFxyXFxuXFx0XFx0Q09OU1RfQVJSQVkgICAgICAgICAgICAgID0gIDI7XFxyXFxuXFx0XFx0TElOU1BBQ0UgICAgICAgICAgICAgICAgID0gIDM7XFxyXFxuXFx0XFx0UkVTSEFQRSAgICAgICAgICAgICAgICAgID0gIDQ7XFxyXFxuXFx0XFx0UkVQRUFUICAgICAgICAgICAgICAgICAgID0gIDU7XFxyXFxuXFx0XFx0REVBTExPQ0FURSAgICAgICAgICAgICAgID0gIDY7XFxyXFxuXFx0XFx0RkVUQ0ggICAgICAgICAgICAgICAgICAgID0gIDc7XFxyXFxuXFx0XFx0QkFSUklFUiAgICAgICAgICAgICAgICAgID0gIDg7XFxyXFxuXFx0XFx0SU5GTyAgICAgICAgICAgICAgICAgICAgID0gIDk7XFxyXFxuXFx0XFx0QklOQVJZX09QRVJBVElPTiAgICAgICAgID0gMTA7XFxyXFxuXFx0XFx0QklOQVJZX0NPTlNUX09QRVJBVElPTiAgID0gMTE7XFxyXFxuXFx0XFx0VU5BUllfT1BFUkFUSU9OICAgICAgICAgID0gMTI7XFxyXFxuXFx0XFx0UkVEVUNUSU9OX09QRVJBVElPTiAgICAgID0gMTM7XFxyXFxuXFx0XFx0QVhJU19SRURVQ1RJT05fT1BFUkFUSU9OID0gMTQ7XFxyXFxuXFx0XFx0RE9UX09QRVJBVElPTiAgICAgICAgICAgID0gMTU7XFxyXFxuXFx0fVxcclxcblxcdHJlcXVpcmVkIGZpeGVkMzIgICAgICAgICAgICAgICAgICAgICBpZCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAgMTtcXHJcXG5cXHRyZXF1aXJlZCBUeXBlICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSAgICAgICAgICAgICAgICAgICAgICAgICAgID0gIDI7XFxyXFxuXFxyXFxuXFx0b3B0aW9uYWwgRW1wdHlBcnJheVJlcXVlc3QgICAgICAgICAgIGVtcHR5X2FycmF5X3JlcXVlc3QgICAgICAgICAgICA9ICAzO1xcclxcblxcdG9wdGlvbmFsIERhdGFBcnJheVJlcXVlc3QgICAgICAgICAgICBkYXRhX2FycmF5X3JlcXVlc3QgICAgICAgICAgICAgPSAgNDtcXHJcXG5cXHRvcHRpb25hbCBDb25zdEFycmF5UmVxdWVzdCAgICAgICAgICAgY29uc3RfYXJyYXlfcmVxdWVzdCAgICAgICAgICAgID0gIDU7XFxyXFxuXFx0b3B0aW9uYWwgTGluc3BhY2VSZXF1ZXN0ICAgICAgICAgICAgIGxpbnNwYWNlX3JlcXVlc3QgICAgICAgICAgICAgICA9ICA2O1xcclxcblxcdG9wdGlvbmFsIFJlc2hhcGVSZXF1ZXN0ICAgICAgICAgICAgICByZXNoYXBlX3JlcXVlc3QgICAgICAgICAgICAgICAgPSAgNztcXHJcXG5cXHRvcHRpb25hbCBSZXBlYXRSZXF1ZXN0ICAgICAgICAgICAgICAgcmVwZWF0X3JlcXVlc3QgICAgICAgICAgICAgICAgID0gIDg7XFxyXFxuXFx0b3B0aW9uYWwgRGVhbGxvY2F0ZVJlcXVlc3QgICAgICAgICAgIGRlYWxsb2NhdGVfcmVxdWVzdCAgICAgICAgICAgICA9ICA5O1xcclxcblxcdG9wdGlvbmFsIEZldGNoUmVxdWVzdCAgICAgICAgICAgICAgICBmZXRjaF9yZXF1ZXN0ICAgICAgICAgICAgICAgICAgPSAxMDtcXHJcXG5cXHRvcHRpb25hbCBCaW5hcnlPcGVyYXRpb25SZXF1ZXN0ICAgICAgYmluYXJ5X29wZXJhdGlvbl9yZXF1ZXN0ICAgICAgID0gMTE7XFxyXFxuXFx0b3B0aW9uYWwgQmluYXJ5Q29uc3RPcGVyYXRpb25SZXF1ZXN0IGJpbmFyeV9jb25zdF9vcGVyYXRpb25fcmVxdWVzdCA9IDEyO1xcclxcblxcdG9wdGlvbmFsIFVuYXJ5T3BlcmF0aW9uUmVxdWVzdCAgICAgICB1bmFyeV9vcGVyYXRpb25fcmVxdWVzdCAgICAgICAgPSAxMztcXHJcXG5cXHRvcHRpb25hbCBSZWR1Y3Rpb25SZXF1ZXN0ICAgICAgICAgICAgcmVkdWN0aW9uX3JlcXVlc3QgICAgICAgICAgICAgID0gMTQ7XFxyXFxuXFx0b3B0aW9uYWwgQXhpc1JlZHVjdGlvblJlcXVlc3QgICAgICAgIGF4aXNfcmVkdWN0aW9uX3JlcXVlc3QgICAgICAgICA9IDE1O1xcclxcblxcdG9wdGlvbmFsIERvdE9wZXJhdGlvblJlcXVlc3QgICAgICAgICBkb3Rfb3BlcmF0aW9uX3JlcXVlc3QgICAgICAgICAgPSAxNjtcXHJcXG59XFxyXFxuXFxyXFxubWVzc2FnZSBFbXB0eUFycmF5UmVxdWVzdCB7XFxyXFxuXFx0cmVxdWlyZWQgZml4ZWQzMiAgaWRfb3V0ICAgICAgPSAxO1xcclxcblxcdHJlcGVhdGVkIHVpbnQzMiAgIHNoYXBlICAgICAgID0gMiBbcGFja2VkPXRydWVdO1xcclxcblxcdHJlcXVpcmVkIERhdGFUeXBlIGRhdGFfdHlwZSAgID0gMztcXHJcXG59XFxyXFxuXFxyXFxubWVzc2FnZSBEYXRhQXJyYXlSZXF1ZXN0IHtcXHJcXG5cXHRyZXF1aXJlZCBmaXhlZDMyICBpZF9vdXQgICAgICA9IDE7XFxyXFxuXFx0cmVwZWF0ZWQgdWludDMyICAgc2hhcGUgICAgICAgPSAyIFtwYWNrZWQ9dHJ1ZV07XFxyXFxuXFx0cmVxdWlyZWQgRGF0YVR5cGUgZGF0YV90eXBlICAgPSAzO1xcclxcblxcdHJlcXVpcmVkIGJ5dGVzICAgIGRhdGFfYnVmZmVyID0gNDtcXHJcXG59XFxyXFxuXFxyXFxubWVzc2FnZSBDb25zdEFycmF5UmVxdWVzdCB7XFxyXFxuXFx0cmVxdWlyZWQgZml4ZWQzMiAgaWRfb3V0ICAgICAgPSAxO1xcclxcblxcdHJlcGVhdGVkIHVpbnQzMiAgIHNoYXBlICAgICAgID0gMiBbcGFja2VkPXRydWVdO1xcclxcblxcdHJlcXVpcmVkIERhdGFUeXBlIGRhdGFfdHlwZSAgID0gMztcXHJcXG5cXHRyZXF1aXJlZCBkb3VibGUgICBmaWxsX3ZhbHVlICA9IDQ7XFxyXFxufVxcclxcblxcclxcbm1lc3NhZ2UgTGluc3BhY2VSZXF1ZXN0IHtcXHJcXG5cXHRyZXF1aXJlZCBzZml4ZWQzMiAgaWRfb3V0ICAgICA9IDE7XFxyXFxuXFx0cmVxdWlyZWQgZG91YmxlICAgIHN0YXJ0ICAgICAgPSAyO1xcclxcblxcdHJlcXVpcmVkIGRvdWJsZSAgICBzdG9wICAgICAgID0gMztcXHJcXG5cXHRyZXF1aXJlZCB1aW50MzIgICAgc2FtcGxlcyAgICA9IDQ7XFxyXFxuXFx0cmVxdWlyZWQgYm9vbCAgICAgIGNsb3NlZCAgICAgPSA1O1xcclxcblxcdHJlcXVpcmVkIERhdGFUeXBlICBkYXRhX3R5cGUgID0gNjtcXHJcXG59XFxyXFxuXFxyXFxubWVzc2FnZSBSZXNoYXBlUmVxdWVzdCB7XFxyXFxuXFx0cmVxdWlyZWQgc2ZpeGVkMzIgIGlkX2EgICAgICA9IDE7XFxyXFxuXFx0cmVxdWlyZWQgZml4ZWQzMiAgIGlkX291dCAgICA9IDI7XFxyXFxuXFx0cmVwZWF0ZWQgdWludDMyICAgIHNoYXBlX291dCA9IDMgW3BhY2tlZD10cnVlXTtcXHJcXG59XFxyXFxuXFxyXFxubWVzc2FnZSBSZXBlYXRSZXF1ZXN0IHtcXHJcXG5cXHRyZXF1aXJlZCBzZml4ZWQzMiBpZF9hICAgID0gMTtcXHJcXG5cXHRyZXF1aXJlZCBmaXhlZDMyICBpZF9vdXQgID0gMjtcXHJcXG5cXHRyZXF1aXJlZCB1aW50MzIgICBheGlzICAgID0gMztcXHJcXG5cXHRyZXF1aXJlZCB1aW50MzIgICByZXBlYXRzID0gNDtcXHJcXG59XFxyXFxuXFxyXFxubWVzc2FnZSBEZWFsbG9jYXRlUmVxdWVzdCB7XFxyXFxuXFx0cmVxdWlyZWQgZml4ZWQzMiBpZF9hID0gMTtcXHJcXG59XFxyXFxuXFxyXFxubWVzc2FnZSBGZXRjaFJlcXVlc3Qge1xcclxcblxcdHJlcXVpcmVkIHNmaXhlZDMyIGlkX2EgPSAxO1xcclxcbn1cXHJcXG5cXHJcXG5tZXNzYWdlIEJpbmFyeU9wZXJhdGlvblJlcXVlc3Qge1xcclxcblxcdGVudW0gVHlwZSB7XFxyXFxuXFx0XFx0QUREID0gMDtcXHJcXG5cXHRcXHRTVUIgPSAxO1xcclxcblxcdFxcdE1VTCA9IDI7XFxyXFxuXFx0XFx0RElWID0gMztcXHJcXG5cXHR9XFxyXFxuXFx0cmVxdWlyZWQgVHlwZSAgICAgdHlwZSAgID0gMTtcXHJcXG5cXHRyZXF1aXJlZCBzZml4ZWQzMiBpZF9hICAgPSAyO1xcclxcblxcdHJlcXVpcmVkIHNmaXhlZDMyIGlkX2IgICA9IDM7XFxyXFxuXFx0cmVxdWlyZWQgZml4ZWQzMiAgaWRfb3V0ID0gNDtcXHJcXG59XFxyXFxuXFxyXFxubWVzc2FnZSBCaW5hcnlDb25zdE9wZXJhdGlvblJlcXVlc3Qge1xcclxcblxcdGVudW0gVHlwZSB7XFxyXFxuXFx0XFx0QUREQyAgPSAwO1xcclxcblxcdFxcdFNVQkMgID0gMTtcXHJcXG5cXHRcXHRTVUJSQyA9IDI7XFxyXFxuXFx0XFx0TVVMQyAgPSAzO1xcclxcblxcdFxcdERJVkMgID0gNDtcXHJcXG5cXHRcXHRESVZSQyA9IDU7XFxyXFxuXFx0fVxcclxcblxcdHJlcXVpcmVkIFR5cGUgICAgIHR5cGUgICAgPSAxO1xcclxcblxcdHJlcXVpcmVkIHNmaXhlZDMyIGlkX2EgICAgPSAyO1xcclxcblxcdHJlcXVpcmVkIGRvdWJsZSAgIHZhbHVlX2IgPSAzO1xcclxcblxcdHJlcXVpcmVkIGZpeGVkMzIgIGlkX291dCAgPSA0O1xcclxcbn1cXHJcXG5cXHJcXG5tZXNzYWdlIFVuYXJ5T3BlcmF0aW9uUmVxdWVzdCB7XFxyXFxuXFx0ZW51bSBUeXBlIHtcXHJcXG5cXHRcXHRORUcgICAgPSAwO1xcclxcblxcdFxcdEFCUyAgICA9IDE7XFxyXFxuXFx0XFx0RVhQICAgID0gMjtcXHJcXG5cXHRcXHRMT0cgICAgPSAzO1xcclxcblxcdFxcdFNRUlQgICA9IDQ7XFxyXFxuXFx0XFx0U1FVQVJFID0gNTtcXHJcXG5cXHR9XFxyXFxuXFx0cmVxdWlyZWQgVHlwZSAgICAgdHlwZSAgID0gMTtcXHJcXG5cXHRyZXF1aXJlZCBzZml4ZWQzMiBpZF9hICAgPSAyO1xcclxcblxcdHJlcXVpcmVkIGZpeGVkMzIgIGlkX291dCA9IDM7XFxyXFxufVxcclxcblxcclxcbm1lc3NhZ2UgUmVkdWN0aW9uUmVxdWVzdCB7XFxyXFxuXFx0ZW51bSBUeXBlIHtcXHJcXG5cXHRcXHRTVU0gPSAwO1xcclxcblxcdFxcdE1JTiA9IDE7XFxyXFxuXFx0XFx0TUFYID0gMjtcXHJcXG5cXHR9XFxyXFxuXFx0cmVxdWlyZWQgVHlwZSAgICAgdHlwZSAgID0gMTtcXHJcXG5cXHRyZXF1aXJlZCBzZml4ZWQzMiBpZF9hICAgPSAyO1xcclxcblxcdHJlcXVpcmVkIGZpeGVkMzIgIGlkX291dCA9IDM7XFxyXFxufVxcclxcblxcclxcbm1lc3NhZ2UgQXhpc1JlZHVjdGlvblJlcXVlc3Qge1xcclxcblxcdGVudW0gVHlwZSB7XFxyXFxuXFx0XFx0U1VNID0gMDtcXHJcXG5cXHRcXHRNSU4gPSAxO1xcclxcblxcdFxcdE1BWCA9IDI7XFxyXFxuXFx0fVxcclxcblxcdHJlcXVpcmVkIFR5cGUgICAgIHR5cGUgICA9IDE7XFxyXFxuXFx0cmVxdWlyZWQgc2ZpeGVkMzIgaWRfYSAgID0gMjtcXHJcXG5cXHRyZXF1aXJlZCB1aW50MzIgICBheGlzICAgPSAzO1xcclxcblxcdHJlcXVpcmVkIGZpeGVkMzIgIGlkX291dCA9IDQ7XFxyXFxufVxcclxcblxcclxcbm1lc3NhZ2UgRG90T3BlcmF0aW9uUmVxdWVzdCB7XFxyXFxuXFx0cmVxdWlyZWQgc2ZpeGVkMzIgaWRfYSAgID0gMTtcXHJcXG5cXHRyZXF1aXJlZCBzZml4ZWQzMiBpZF9iICAgPSAyO1xcclxcblxcdHJlcXVpcmVkIGZpeGVkMzIgIGlkX291dCA9IDM7XFxyXFxufVxcclxcblwiO1xubW9kdWxlLmV4cG9ydHMgPSBwcm90b2J1ZmpzLmxvYWRQcm90byhyZXF1ZXN0c1Byb3RvKS5idWlsZChcImZ1cmlvdXNcIik7XG4iLCJcbnZhciBwcm90b2J1ZmpzID0gcmVxdWlyZShcInByb3RvYnVmanNcIik7XG5wcm90b2J1ZmpzLmNvbnZlcnRGaWVsZHNUb0NhbWVsQ2FzZSA9IHRydWU7XG52YXIgcmVzcG9uc2VzUHJvdG8gPSBcInBhY2thZ2UgZnVyaW91cztcXHJcXG5cXHJcXG5vcHRpb24gb3B0aW1pemVfZm9yID0gTElURV9SVU5USU1FO1xcclxcblxcclxcbm1lc3NhZ2UgUmVzcG9uc2Uge1xcclxcblxcdGVudW0gVHlwZSB7XFxyXFxuXFx0XFx0RkVUQ0ggICA9IDA7XFxyXFxuXFx0XFx0RVJST1IgICA9IDE7XFxyXFxuXFx0XFx0SU5JVCAgICA9IDI7XFxyXFxuXFx0XFx0QkFSUklFUiA9IDM7XFxyXFxuXFx0XFx0SU5GTyAgICA9IDQ7XFxyXFxuXFx0fVxcclxcblxcdHJlcXVpcmVkIGZpeGVkMzIgICAgICAgICBpZCAgICAgICAgICAgICAgID0gMTtcXHJcXG5cXHRyZXF1aXJlZCBUeXBlICAgICAgICAgICAgdHlwZSAgICAgICAgICAgICA9IDI7XFxyXFxuXFxyXFxuXFx0b3B0aW9uYWwgRmV0Y2hSZXNwb25zZSAgIGZldGNoX3Jlc3BvbnNlICAgPSAzO1xcclxcblxcdG9wdGlvbmFsIEVycm9yUmVzcG9uc2UgICBlcnJvcl9yZXNwb25zZSAgID0gNDtcXHJcXG5cXHRvcHRpb25hbCBJbml0UmVzcG9uc2UgICAgaW5pdF9yZXNwb25zZSAgICA9IDU7XFxyXFxuXFx0b3B0aW9uYWwgSW5mb1Jlc3BvbnNlICAgIGluZm9fcmVzcG9uc2UgICAgPSA3O1xcclxcbn1cXHJcXG5cXHJcXG5tZXNzYWdlIEZldGNoUmVzcG9uc2Uge1xcclxcblxcdHJlcXVpcmVkIGJ5dGVzIGRhdGFfYnVmZmVyID0gMTtcXHJcXG59XFxyXFxuXFxyXFxubWVzc2FnZSBFcnJvclJlc3BvbnNlIHtcXHJcXG5cXHRlbnVtIFR5cGUge1xcclxcblxcdFxcdFJVTlRJTUUgID0gMDtcXHJcXG5cXHRcXHRBUkdVTUVOVCA9IDE7XFxyXFxuXFx0XFx0UEFSU0UgICAgPSAyO1xcclxcblxcdH1cXHJcXG5cXHRyZXF1aXJlZCBUeXBlICAgdHlwZSAgICAgICAgPSAxO1xcclxcblxcdG9wdGlvbmFsIHN0cmluZyBkZXNjcmlwdGlvbiA9IDI7XFxyXFxufVxcclxcblxcclxcbm1lc3NhZ2UgSW5pdFJlc3BvbnNlIHtcXHJcXG5cXHRvcHRpb25hbCB1aW50MzIgY29uY3VycmVuY3kgPSAxO1xcclxcbn1cXHJcXG5cXHJcXG5tZXNzYWdlIEluZm9SZXNwb25zZSB7XFxyXFxufVxcclxcblwiO1xubW9kdWxlLmV4cG9ydHMgPSBwcm90b2J1ZmpzLmxvYWRQcm90byhyZXNwb25zZXNQcm90bykuYnVpbGQoXCJmdXJpb3VzXCIpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4vKipcclxuICogUHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9uc1xyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAY2xhc3MgdXRpbFxyXG4gKi9cclxuXHJcbnZhciBpc051bWJlciA9IGZ1bmN0aW9uKG4pIHtcclxuXHRyZXR1cm4gbiA9PT0gK247XHJcbn07XHJcbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcclxuXHJcbnZhciBpc1JlYWwgPSBmdW5jdGlvbihuKSB7XHJcblx0cmV0dXJuIChuID09PSArbikgJiYgKGlzRmluaXRlKG4pKTtcclxufTtcclxuZXhwb3J0cy5pc1JlYWwgPSBpc1JlYWw7XHJcblxyXG52YXIgaXNJbnQgPSBmdW5jdGlvbihuKSB7XHJcblx0cmV0dXJuIG4gPT09IChufDApO1xyXG59O1xyXG5leHBvcnRzLmlzSW50ID0gaXNJbnQ7XHJcblxyXG5leHBvcnRzLmlzUG9zaXRpdmVJbnQgPSBmdW5jdGlvbihuKSB7XHJcblx0cmV0dXJuIChuID09PSArbikgJiYgKG4gPT09IChufDApKSAmJiAobiA+IDApO1xyXG59O1xyXG5cclxuZXhwb3J0cy5pc05vbk5lZ2F0aXZlSW50ID0gZnVuY3Rpb24obikge1xyXG5cdHJldHVybiAobiA9PT0gK24pICYmIChuID09PSAobnwwKSkgJiYgKG4gPj0gMCk7XHJcbn07XHJcblxyXG52YXIgaXNBcnJheSA9IGZ1bmN0aW9uKGxpc3QpIHtcclxuXHRyZXR1cm4gbGlzdCBpbnN0YW5jZW9mIEFycmF5O1xyXG59O1xyXG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xyXG5cclxuZXhwb3J0cy5pc0ludEFycmF5ID0gZnVuY3Rpb24obGlzdCkge1xyXG5cdGlmIChleHBvcnRzLmlzQXJyYXkobGlzdCkpIHtcclxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRpZiAoIWV4cG9ydHMuaXNJbnQobGlzdFtpXSkpIHtcclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiB0cnVlO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fVxyXG59O1xyXG5cclxuZXhwb3J0cy5pc1Bvc2l0aXZlSW50QXJyYXkgPSBmdW5jdGlvbihsaXN0KSB7XHJcblx0aWYgKGV4cG9ydHMuaXNBcnJheShsaXN0KSkge1xyXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdGlmICghZXhwb3J0cy5pc1Bvc2l0aXZlSW50KGxpc3RbaV0pKSB7XHJcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH1cclxufTtcclxuXHJcbmV4cG9ydHMuYXNJbnRBcnJheSA9IGZ1bmN0aW9uIChsaXN0KSB7XHJcblx0aWYgKGV4cG9ydHMuaXNJbnQobGlzdCkpIHtcclxuXHRcdHJldHVybiBbbGlzdF07XHJcblx0fSBlbHNlIGlmIChleHBvcnRzLmlzSW50QXJyYXkobGlzdCkpIHtcclxuXHRcdHJldHVybiBsaXN0O1xyXG5cdH0gZWxzZSB7XHJcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKGxpc3QgKyBcIiBjYW4gbm90IGJlIGNvbnZlcnRlZCB0byBpbnRlZ2VyIGFycmF5XCIpO1xyXG5cdH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb21wYXJlcyBmb3IgZXF1YWxpdHkgdHdvIGFycmF5cyBvZiBwcmltaXRpdmUgdHlwZXMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7TnVtYmVyW119IGFycmF5QSAtIHRoZSBmaXJzdCBhcnJheSB0byBjb21wYXJlLlxyXG4gKiBAcGFyYW0ge051bWJlcltdfSBhcnJheUIgLSB0aGUgc2Vjb25kIGFycmF5IHRvIGNvbXBhcmUuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqICAgICBpZiAoIXV0aWwuYXJyYXlFcXVhbHMoYS5zaGFwZSwgYi5zaGFwZSkpIHtcclxuICpcdCAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhIGFuZCBiIGhhdmUgaW5jb21wYXRpYmxlIHNoYXBlc1wiKTtcclxuICogICAgIH1cclxuICpcclxuICogQHByaXZhdGVcclxuICogQHN0YXRpY1xyXG4gKiBAbWV0aG9kIGFycmF5RXF1YWxzXHJcbiAqL1xyXG5leHBvcnRzLmFycmF5RXF1YWxzID0gZnVuY3Rpb24oYXJyYXlBLCBhcnJheUIpIHtcclxuXHRpZiAoYXJyYXlBID09PSBhcnJheUIpIHtcclxuXHRcdHJldHVybiB0cnVlO1xyXG5cdH1cclxuXHRpZiAoYXJyYXlBLmxlbmd0aCAhPT0gYXJyYXlCLmxlbmd0aCkge1xyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH1cclxuXHR2YXIgbiA9IGFycmF5QS5sZW5ndGg7XHJcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpIHtcclxuXHRcdGlmIChhcnJheUFbaV0gIT09IGFycmF5QltpXSkge1xyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblx0fVxyXG5cdHJldHVybiB0cnVlO1xyXG59O1xyXG5cclxuZXhwb3J0cy5yb3VuZFVwID0gZnVuY3Rpb24gKG51bWJlciwgbXVsdGlwbGUpIHtcclxuXHRyZXR1cm4gTWF0aC5jZWlsKG51bWJlciAvIG11bHRpcGxlKSAqIG11bHRpcGxlO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFZhbGlkYXRlIHRoZSBzaGFwZSBhcmd1bWVudC5cclxuICogVGhyb3dzIGFuIGVycm9yIGlmIHRoZSBhcmd1bWVudCByZXByZXNlbnRzIGEgdmFsaWQgc2hhcGUuXHJcbiAqIFJldHVybnMgdGhlIHNoYXBlIGFzIGFuIGludGVnZXIgYXJyYXkuXHJcbiAqXHJcbiAqIEBwYXJhbSB7KE51bWJlcnxOdW1iZXJbXSl9IHNoYXBlIC0gdGhlIHNoYXBlIGFyZ3VtZW50IHRvIHZhbGlkYXRlLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiAgICAgc2hhcGUgPSB1dGlsLmNoZWNrU2hhcGUoc2hhcGUpO1xyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAc3RhdGljXHJcbiAqIEBtZXRob2QgY2hlY2tTaGFwZVxyXG4gKi9cclxudmFyIGNoZWNrU2hhcGUgPSBmdW5jdGlvbihzaGFwZSkge1xyXG5cdGlmIChpc051bWJlcihzaGFwZSkpIHtcclxuXHRcdHJldHVybiBjaGVja1NoYXBlKFtzaGFwZV0pO1xyXG5cdH0gZWxzZSBpZiAoaXNBcnJheShzaGFwZSkpIHtcclxuXHRcdHZhciBuID0gc2hhcGUubGVuZ3RoO1xyXG5cdFx0dmFyIG91dFNoYXBlID0gbmV3IEFycmF5KG4pO1xyXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcclxuXHRcdFx0aWYgKCFpc051bWJlcihzaGFwZVtpXSkpIHtcclxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJTaGFwZSBoYXMgbm9uLW51bWVyaWMgZGltZW5zaW9uc1wiKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAoIWlzSW50KHNoYXBlW2ldKSkge1xyXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIlNoYXBlIG11c3QgaGF2ZSBpbnRlZ2VyIGRpbWVuc2lvbnNcIik7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKHNoYXBlW2ldIDwgMSkge1xyXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIkRlZ2VuZXJhdGUgc2hhcGVcIik7XHJcblx0XHRcdH1cclxuXHRcdFx0b3V0U2hhcGVbaV0gPSBzaGFwZVtpXXwwO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIG91dFNoYXBlO1xyXG5cdH0gZWxzZSB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJTaGFwZSBtdXN0IGJlIGFuIGludGVnZXIgb3IgaW50ZWdlciBhcnJheVwiKTtcclxuXHR9XHJcbn07XHJcbmV4cG9ydHMuY2hlY2tTaGFwZSA9IGNoZWNrU2hhcGU7XHJcblxyXG4vKipcclxuICogQ2hlY2tzIHRoYXQgdGhlIHR3byBzaGFwZXMgYXJlIHNpbWlsYXIuXHJcbiAqIFRocm93cyBhbiBlcnJvciBpZiB0aGUgdHdvIHNoYXBlcyBhcmUgZGlmZmVyZW50LlxyXG4gKiBJZiB0aGUgZGF0YSB0eXBlcyBhcmUgY29tcGF0aWJsZSwgdGhlIGZ1bmN0aW9uIGRvZXMgbm90aGluZy5cclxuICpcclxuICogQHBhcmFtIHtOdW1iZXJbXX0gc2hhcGVBIC0gb25lIHZhbGlkIHNoYXBlIHRvIGNvbXBhcmUuXHJcbiAqIEBwYXJhbSB7TnVtYmVyW119IHNoYXBlQiAtIGFub3RoZXIgdmFsaWQgc2hhcGUgdG8gY29tcGFyZS5cclxuICpcclxuICogQGV4YW1wbGVcclxuICogICAgIHV0aWwuY2hlY2tTaGFwZXNDb21wYXRpYmlsaXR5KGEuc2hhcGUsIGIuc2hhcGUpO1xyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAc3RhdGljXHJcbiAqIEBtZXRob2QgY2hlY2tTaGFwZXNDb21wYXRpYmlsaXR5XHJcbiAqL1xyXG5leHBvcnRzLmNoZWNrU2hhcGVzQ29tcGF0aWJpbGl0eSA9IGZ1bmN0aW9uKHNoYXBlQSwgc2hhcGVCKSB7XHJcblx0aWYgKHNoYXBlQS5sZW5ndGggIT0gc2hhcGVCLmxlbmd0aCkge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiVGhlIHNoYXBlcyBoYXZlIGRpZmZlcmVudCBkaW1lbnNpb25zXCIpO1xyXG5cdH1cclxuXHR2YXIgbiA9IHNoYXBlQS5sZW5ndGg7XHJcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcclxuXHRcdGlmIChzaGFwZUFbaV0gIT0gc2hhcGVCW2ldKSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcihcIlRoZSBzaGFwZXMgYXJlIGRpZmZlcmVudFwiKTtcclxuXHRcdH1cclxuXHR9XHJcbn07XHJcblxyXG4vKipcclxuICogQ29tcHV0ZXMgYXJyYXkgbGVuZ3RoIGZyb20gaXRzIHNoYXBlLlxyXG4gKlxyXG4gKiBAcGFyYW0ge051bWJlcltdfSBzaGFwZSAtIGFuIGFycmF5IHNoYXBlLiAgVGhlIHNoYXBlIG11c3QgYmUgdmFsaWQgdy5yLnQuICoqY2hlY2tTaGFwZSoqIGZ1bmN0aW9uLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiAgICAgdmFyIGxlbmd0aCA9IHV0aWwuY29tcHV0ZUxlbmd0aChzaGFwZSk7XHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBzdGF0aWNcclxuICogQG1ldGhvZCBjb21wdXRlTGVuZ3RoXHJcbiAqL1xyXG5leHBvcnRzLmNvbXB1dGVMZW5ndGggPSBmdW5jdGlvbihzaGFwZSkge1xyXG5cdHZhciBsZW5ndGggPSAxO1xyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgc2hhcGUubGVuZ3RoOyArK2kpIHtcclxuXHRcdGxlbmd0aCAqPSBzaGFwZVtpXTtcclxuXHR9XHJcblx0cmV0dXJuIGxlbmd0aDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDaGVja3MgdGhlIHRoZSBhcmd1bWVudCByZXByZXNlbnRzIGEgZGF0YSB0eXBlLlxyXG4gKiBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlIGFyZ3VtZW50IGlzIG5vdCBvZiBEYXRhVHlwZSB0eXBlLlxyXG4gKiBJZiB0aGUgYXJndW1lbnQgaXMgYSBEYXRhVHlwZSBvYmplY3QsIHRoZSBmdW5jdGlvbiBkb2VzIG5vdGhpbmcuXHJcbiAqXHJcbiAqIEBwYXJhbSB7RGF0YVR5cGV9IGRhdGFUeXBlIC0gdGhlIGV4cGVjdGVkbHkgZGF0YSB0eXBlIG9iamVjdCB0byB2YWxpZGF0ZS5cclxuICogQHJldHVybiB7RGF0YVR5cGV9IC0gYSBkYXRhIHR5cGUgb2JqZWN0IGVxdWl2YWxlbnQgdG8gdGhlIGFyZ3VtZW50LlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiAgICAgZGF0YVR5cGUgPSB1dGlsLmNoZWNrRGF0YVR5cGUoZGF0YVR5cGUpO1xyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAc3RhdGljXHJcbiAqIEBtZXRob2QgY2hlY2tEYXRhVHlwZVxyXG4gKi9cclxuZXhwb3J0cy5jaGVja0RhdGFUeXBlID0gZnVuY3Rpb24oZGF0YVR5cGUpIHtcclxuXHR2YXIgRGF0YVR5cGUgPSByZXF1aXJlKFwiLi9EYXRhVHlwZVwiKTtcclxuXHRpZiAoIShkYXRhVHlwZSBpbnN0YW5jZW9mIERhdGFUeXBlKSkge1xyXG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihcImRhdGFUeXBlIGlzIG5vdCBhbiBpbnN0YW5jZSBvZiBEYXRhVHlwZVwiKTtcclxuXHR9XHJcblx0cmV0dXJuIGRhdGFUeXBlO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENoZWNrcyB0aGF0IHRoZSB0d28gZGF0YSB0eXBlcyBhcmUgY29tcGF0aWJsZS5cclxuICogVGhyb3dzIGFuIGVycm9yIGlmIHRoZSBkYXRhIHR5cGVzIGRvIG5vdCBtYXRjaC5cclxuICogSWYgdGhlIGRhdGEgdHlwZXMgYXJlIGNvbXBhdGlibGUsIHRoZSBmdW5jdGlvbiBkb2VzIG5vdGhpbmcuXHJcbiAqXHJcbiAqIEBwYXJhbSB7RGF0YVR5cGV9IGRhdGFUeXBlQSAtIHRoZSBmaXJzdCBkYXRhIHR5cGUuXHJcbiAqIEBwYXJhbSB7RGF0YVR5cGV9IGRhdGFUeXBlQiAtIHRoZSBzZWNvbmQgZGF0YSB0eXBlLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiAgICAgdXRpbC5jaGVja0RhdGFUeXBlc0NvbXBhdGliaWxpdHkoYS5kYXRhVHlwZSwgYi5kYXRhVHlwZSk7XHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBzdGF0aWNcclxuICogQG1ldGhvZCBjaGVja0RhdGFUeXBlc0NvbXBhdGliaWxpdHlcclxuICovXHJcbmV4cG9ydHMuY2hlY2tEYXRhVHlwZXNDb21wYXRpYmlsaXR5ID0gZnVuY3Rpb24oZGF0YVR5cGVBLCBkYXRhVHlwZUIpIHtcclxuXHRpZiAoIWRhdGFUeXBlQS5lcXVhbHMoZGF0YVR5cGVCKSkge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiVGhlIGRhdGEgdHlwZXMgYXJlIG5vdCBjb21wYXRpYmxlXCIpO1xyXG5cdH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBWYWxpZGF0ZXMgYW4gTkRBcnJheSBwYXJhbWV0ZXIuXHJcbiAqIFRocm93cyBhbiBlcnJvciBpZiB0aGUgZXhwZWN0ZWQgTkRBcnJheSBhcmd1bWVudCBoYXMgb3RoZXIgdHlwZSBvciBpZiBpdCBoYXMgYmVlbiBpbnZhbGlkYXRlZC5cclxuICogSWYgdGhlIGFyZ3VtZW50IGlzIGEgdmFsaWQgTkRBcnJheSwgdGhlIGZ1bmN0aW9uIGRvZXMgbm90aGluZy5cclxuICpcclxuICogQHBhcmFtIHtOREFycmF5fSBhcnJheSAtIHRoZSBleHBlY3RlZGx5IE5EQXJyYXkgYXJndW1lbnQgdG8gYmUgdmFsaWRhdGVkLlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFuYW1lIC0gdGhlIG5hbWUgb2YgdGhlIE5EQXJyYXkgYXJndW1lbnQgdG8gYmUgdXNlZCBpbiBlcnJvciBtZXNzYWdlcy5cclxuICpcclxuICogQGV4YW1wbGVcclxuICogICAgIHV0aWwuY2hlY2tOREFycmF5KG91dCwgXCJvdXRcIik7XHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBzdGF0aWNcclxuICogQG1ldGhvZCBjaGVja05EQXJyYXlcclxuICovXHJcbmV4cG9ydHMuY2hlY2tOREFycmF5ID0gZnVuY3Rpb24oYXJyYXksIHZhcm5hbWUpIHtcclxuXHR2YXIgTkRBcnJheSA9IHJlcXVpcmUoXCIuL05EQXJyYXlcIik7XHJcblx0aWYgKCEoYXJyYXkgaW5zdGFuY2VvZiBOREFycmF5KSkge1xyXG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcih2YXJuYW1lICsgXCIgaXMgbm90IGFuIE5EQXJyYXlcIik7XHJcblx0fVxyXG5cdGlmICghYXJyYXkuaXNWYWxpZCgpKSB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IodmFybmFtZSArIFwiIGlzIGFuIGludmFsaWRhdGVkIGFycmF5XCIpO1xyXG5cdH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBDaGVja3MgdGhhdCB0aGUgdHdvIGFycmF5cyBhcmUgZGlmZmVyZW50LlxyXG4gKiBUaHJvd3MgYW4gZXJyb3IgaWYgdGhleSByZWZlciB0byB0aGUgc2FtZSBvYmplY3QuXHJcbiAqIElmIHRoZSBhcnJheXMgYXJlIGRpZmZlcmVudCwgdGhlIGZ1bmN0aW9uIGRvZXMgbm90aGluZy5cclxuICpcclxuICogQHBhcmFtIHtOREFycmF5fSBhIC0gdGhlIGZpcnN0IGFycmF5IHRvIGNoZWNrLiBNdXN0IGJlIGFuIE5EQXJyYXkgb2JqZWN0LlxyXG4gKiBAcGFyYW0ge05EQXJyYXl9IGIgLSB0aGUgc2Vjb25kIGFycmF5IHRvIGNoZWNrLiBNdXN0IGJlIGFuIE5EQXJyYXkgb2JqZWN0LlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFybmFtZUEgLSBuYW1lIG9mIHRoZSBmaXJzdCBhcnJheSB2YXJpYWJsZS4gVGhpcyBuYW1lIG1heSBiZSB1c2VkIGluIGFuIGVycm9yIG1lc3NhZ2UuXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YXJuYW1lQiAtIG5hbWUgb2YgdGhlIHNlY29uZCBhcnJheSB2YXJpYWJsZS4gVGhpcyBuYW1lIG1heSBiZSB1c2VkIGluIGFuIGVycm9yIG1lc3NhZ2UuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqICAgICB1dGlsLmNoZWNrRGlmZmVyZW50TkRBcnJheXMoYSwgb3V0LCBcImFcIiwgXCJvdXRcIik7XHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBzdGF0aWNcclxuICogQG1ldGhvZCBjaGVja0RpZmZlcmVudE5EQXJyYXlzXHJcbiAqL1xyXG5leHBvcnRzLmNoZWNrRGlmZmVyZW50TkRBcnJheXMgPSBmdW5jdGlvbihhLCBiLCB2YXJuYW1lQSwgdmFybmFtZUIpIHtcclxuXHRpZiAoYSA9PT0gYikge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiVGhlIGFycmF5cyBcIiArIHZhcm5hbWVBICsgXCIgYW5kIFwiICsgdmFybmFtZUIgKyBcIiBtdXN0IGJlIGRpZmZlcmVudFwiKTtcclxuXHR9XHJcbn07XHJcblxyXG4vKipcclxuICogVmFsaWRhdGVzICoqcmVwZWF0cyoqIHBhcmFtZXRlciBmb3IgcmVwZWF0aXRpb24vdGlsaW5nIG9mIGFycmF5IGFsb25nIGFuIGF4aXMuXHJcbiAqIFRocm93cyBhbiBlcnJvciBpZiAqKnJlcGVhdHMqKiBpcyBub3QgYW4gaW50ZWdlciBvciBpZiAqKnJlcGVhdHMqKiBpcyBzbWFsbGVyIHRoYW4gMi5cclxuICogSWYgKipyZXBlYXRzKiogaXMgdmFsaWQsIHRoZSBmdW5jdGlvbiBkb2VzIG5vdGhpbmcuXHJcbiAqXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSByZXBlYXRzIC0gdGhlIHJlcGVhdHMgYXJndW1lbnQgdG8gYmUgdmVyaWZpZWQuXHJcbiAqIEByZXR1cm4ge051bWJlcn0gLSAqKnJlcGVhdHMqKiBjYXN0ZWQgdG8gaW50ZWdlci5cclxuICpcclxuICogQGV4YW1wbGVcclxuICogICAgIHJlcGVhdHMgPSB1dGlsLmNoZWNrUmVwZWF0cyhyZXBlYXRzKTtcclxuICpcclxuICogQHByaXZhdGVcclxuICogQHN0YXRpY1xyXG4gKiBAbWV0aG9kIGNoZWNrUmVwZWF0c1xyXG4gKi9cclxuZXhwb3J0cy5jaGVja1JlcGVhdHMgPSBmdW5jdGlvbihyZXBlYXRzKSB7XHJcblx0aWYgKCFpc0ludChyZXBlYXRzKSkge1xyXG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihcIlJlcGVhdHMgaXMgbm90IGFuIGludGVnZXJcIik7XHJcblx0fVxyXG5cdGlmIChyZXBlYXRzIDw9IDEpIHtcclxuXHRcdHRocm93IG5ldyBSYW5nZUVycm9yKFwiUmVwZWF0cyBzaG91bGQgYmUgZ3JlYXRlciB0aGFuIDFcIik7XHJcblx0fVxyXG5cdHJldHVybiByZXBlYXRzfDA7XHJcbn07XHJcblxyXG4vKipcclxuICogVmFsaWRhdGVzIGF4aXMgcGFyYW1ldGVyIGZvciByZWR1Y3Rpb25zIGFsb25nIGFuIGF4aXMuXHJcbiAqIFRocm93cyBhbiBlcnJvciBpZiBheGlzIGlzIG5vdCBhbiBpbnRlZ2VyLCBpZiBheGlzIGlzIG5lZ2F0aXZlLCBvciBheGlzIGV4Y2VlZHMgdGhlIG51bWJlciBvZiBkaW1lbnNpb25zLlxyXG4gKiBJZiBheGlzIGlzIHZhbGlkLCB0aGUgZnVuY3Rpb24gZG9lcyBub3RoaW5nLlxyXG4gKlxyXG4gKiBAcGFyYW0ge051bWJlcn0gYXhpcyAtIHRoZSBheGlzIGFyZ3VtZW50IHRvIGJlIHZlcmlmaWVkLlxyXG4gKiBAcGFyYW0ge051bWJlcn0gbnVtRGltZW5zaW9ucyAtIHRoZSBudW1iZXIgb2YgZGltZW5zaW9ucyBpbiB0aGUgYXJyYXkgYmVpbmcgcmVkdWNlZC5cclxuICogQHJldHVybiB7TnVtYmVyfSAtIGF4aXMgY2FzdGVkIHRvIGludGVnZXIuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqICAgICBheGlzID0gdXRpbC5jaGVja0F4aXMoYXhpcywgbmRhcnJheS5zaGFwZS5sZW5ndGgpO1xyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAc3RhdGljXHJcbiAqIEBtZXRob2RcclxuICovXHJcbmV4cG9ydHMuY2hlY2tBeGlzID0gZnVuY3Rpb24oYXhpcywgbnVtRGltZW5zaW9ucykge1xyXG5cdGlmICghaXNJbnQoYXhpcykpIHtcclxuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoXCJBeGlzIGlzIG5vdCBhbiBpbnRlZ2VyXCIpO1xyXG5cdH1cclxuXHRpZiAoYXhpcyA8IDApIHtcclxuXHRcdHRocm93IG5ldyBSYW5nZUVycm9yKFwiQXhpcyBpcyBuZWdhdGl2ZVwiKTtcclxuXHR9XHJcblx0LyogRS5nLiAzLWRpbWVuc2lvbmFsIGFycmF5IGhhcyBheGVzIDAsIDEsIDIgKGJ1dCBub3QgMyEpICovXHJcblx0aWYgKGF4aXMgPj0gbnVtRGltZW5zaW9ucykge1xyXG5cdFx0dGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJBeGlzIG91dCBvZiByYW5nZVwiKTtcclxuXHR9XHJcblx0cmV0dXJuIGF4aXN8MDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBWYWxpZGF0ZXMgdGhlIHNoYXBlIG9mIG91dHB1dCBhcnJheSBmb3IgcmVkdWN0aW9ucyBhbG9uZyBhbiBheGlzLlxyXG4gKiBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlIHNoYXBlIG9mIHRoZSBvdXRwdXQgYXJyYXkgZG9lcyBtYXRjaCB0aGUgc2hhcGUgb2YgaW5wdXQgYXJyYXkgYWZ0ZXIgcmVkdWN0aW9uIGFsb25nIHRoZSBheGlzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge051bWJlcltdfSBpblNoYXBlIC0gdGhlIHNoYXBlIG9mIHRoZSBpbnB1dCBhcnJheS5cclxuICogQHBhcmFtIHtOdW1iZXJbXX0gb3V0U2hhcGUgLSB0aGUgc2hhcGUgb2YgdGhlIG91dHB1dCBhcnJheSB0byBiZSB2YWxpZGF0ZWQuXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBheGlzIC0gdGhlIGF4aXMgZm9yIHJlZHVjdGlvbiBvZiBpbnB1dCBhcnJheS4gTXVzdCBiZSB2YWxpZCB3LnIudC4gaW5TaGFwZS5cclxuICpcclxuICogQGV4YW1wbGVcclxuICogICAgIHV0aWwuY2hlY2tBeGlzUmVkdWN0aW9uT3V0U2hhcGUoaW5BcnJheS5zaGFwZSwgb3V0QXJyYXkuc2hhcGUsIGF4aXMpO1xyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAc3RhdGljXHJcbiAqIEBtZXRob2RcclxuICovXHJcbmV4cG9ydHMuY2hlY2tBeGlzUmVkdWN0aW9uT3V0U2hhcGUgPSBmdW5jdGlvbihpblNoYXBlLCBvdXRTaGFwZSwgYXhpcykge1xyXG5cdGlmIChpblNoYXBlLmxlbmd0aCAhPT0gb3V0U2hhcGUubGVuZ3RoICsgMSkge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiT3V0cHV0IGFycmF5IGhhcyBpbnZhbGlkIG51bWJlciBvZiBkaW1lbnNpb25zIGZvciB0aGlzIG9wZXJhdGlvblwiKTtcclxuXHR9XHJcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBheGlzOyArK2kpIHtcclxuXHRcdGlmIChpblNoYXBlW2ldICE9PSBvdXRTaGFwZVtpXSkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJPdXRwdXQgYXJyYXkgaGFzIGludmFsaWQgc2hhcGUgZm9yIHRoaXMgb3BlcmF0aW9uXCIpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRmb3IgKHZhciBpID0gYXhpcyArIDE7IGkgPCBpblNoYXBlLmxlbmd0aDsgKytpKSB7XHJcblx0XHRpZiAoaW5TaGFwZVtpXSAhPT0gb3V0U2hhcGVbaS0xXSkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJPdXRwdXQgYXJyYXkgaGFzIGludmFsaWQgc2hhcGUgZm9yIHRoaXMgb3BlcmF0aW9uXCIpO1xyXG5cdFx0fVxyXG5cdH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb21wdXRlcyB0aGUgc2hhcGUgb2YgYW4gYXJyYXkgYWZ0ZXIgcmVkdWN0aW9uIGFsb25nIGFuIGF4aXMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7TnVtYmVyW119IGluU2hhcGUgLSB0aGUgc2hhcGUgb2YgdGhlIGlucHV0IGFycmF5LlxyXG4gKiBAcGFyYW0ge051bWJlcn0gYXhpcyAtIHRoZSBheGlzIGZvciByZWR1Y3Rpb24gb2YgaW5wdXQgYXJyYXkuIE11c3QgYmUgdmFsaWQgdy5yLnQuIGluU2hhcGUuXHJcbiAqIEByZXR1cm4ge051bWJlcltdfSAtIHRoZSBzaGFwZSBvZiB0aGUgb3V0cHV0IGFycmF5LlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiAgICAgdmFyIG91dFNoYXBlID0gdXRpbC5nZXRBeGlzUmVkdWN0aW9uT3V0U2hhcGUoaW5BcnJheS5zaGFwZSwgYXhpcyk7XHJcbiAqICAgICB2YXIgb3V0QXJyYXkgPSBuZXcgTkRBcnJheShvdXRTaGFwZSwgaW5BcnJheS5kYXRhVHlwZSwgY29udGV4dCk7XHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBzdGF0aWNcclxuICogQG1ldGhvZFxyXG4gKi9cclxuZXhwb3J0cy5jb21wdXRlQXhpc1JlZHVjdGlvbk91dFNoYXBlID0gZnVuY3Rpb24oaW5TaGFwZSwgYXhpcykge1xyXG5cdHZhciBvdXRTaGFwZSA9IFtdO1xyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgaW5TaGFwZS5sZW5ndGg7ICsraSkge1xyXG5cdFx0aWYgKGkgIT09IGF4aXMpIHtcclxuXHRcdFx0b3V0U2hhcGUucHVzaChpblNoYXBlW2ldKTtcclxuXHRcdH1cclxuXHR9XHJcblx0cmV0dXJuIG91dFNoYXBlO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvbXB1dGVzIHRoZSBwcm9kdWN0IG9mIGFycmF5IGRpbWVuc2lvbnMgYmVmb3JlIHRoZSBheGlzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge051bWJlcltdfSBzaGFwZSAtIHRoZSBzaGFwZSBvZiB0aGUgYXJyYXkuXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBheGlzIC0gdGhlIGF4aXMgdXNlZCBpbiBhbiBvcGVyYXRpb24uIE11c3QgYmUgdmFsaWQgdy5yLnQuIHNoYXBlLlxyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IC0gdGhlIHByb2R1Y3Qgb2YgYXJyYXkgZGltZW5zaW9ucyBiZWZvcmUgYXhpcy5cclxuICpcclxuICogQGV4YW1wbGVcclxuICogICAgIC8vIDUtZGltZW5zaW9uYWwgYXJyYXlcclxuICogICAgIHZhciBuZGFycmF5ID0gY29udGV4dC5lbXB0eShbMiwgMywgNCwgNSwgNl0pO1xyXG4gKiAgICAgLy8gUmV0dXJucyA2ID0gMiozXHJcbiAqICAgICB2YXIgb3V0ZXJTdHJpZGUgPSBjb21wdXRlT3V0ZXJTdHJpZGUobmRhcnJheSwgMik7XHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBzdGF0aWNcclxuICogQG1ldGhvZFxyXG4gKi9cclxuZXhwb3J0cy5jb21wdXRlT3V0ZXJTdHJpZGUgPSBmdW5jdGlvbihzaGFwZSwgYXhpcykge1xyXG5cdHZhciBvdXRlclN0cmlkZSA9IDE7XHJcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBheGlzOyArK2kpIHtcclxuXHRcdG91dGVyU3RyaWRlICo9IHNoYXBlW2ldO1xyXG5cdH1cclxuXHRyZXR1cm4gb3V0ZXJTdHJpZGU7XHJcbn07XHJcblxyXG4vKipcclxuICogQ29tcHV0ZXMgdGhlIHByb2R1Y3Qgb2YgYXJyYXkgZGltZW5zaW9ucyBhZnRlciB0aGUgYXhpcy5cclxuICpcclxuICogQHBhcmFtIHtOdW1iZXJbXX0gc2hhcGUgLSB0aGUgc2hhcGUgb2YgdGhlIGFycmF5LlxyXG4gKiBAcGFyYW0ge051bWJlcn0gYXhpcyAtIHRoZSBheGlzIHVzZWQgaW4gYW4gb3BlcmF0aW9uLiBNdXN0IGJlIHZhbGlkIHcuci50LiBzaGFwZS5cclxuICogQHJldHVybiB7TnVtYmVyfSAtIHRoZSBwcm9kdWN0IG9mIGFycmF5IGRpbWVuc2lvbnMgYWZ0ZXIgYXhpcy5cclxuICpcclxuICogQGV4YW1wbGVcclxuICogICAgIC8vIDUtZGltZW5zaW9uYWwgYXJyYXlcclxuICogICAgIHZhciBuZGFycmF5ID0gY29udGV4dC5lbXB0eShbMiwgMywgNCwgNSwgNl0pO1xyXG4gKiAgICAgLy8gUmV0dXJucyA2ID0gMiozXHJcbiAqICAgICB2YXIgaW5uZXJTdHJpZGUgPSBjb21wdXRlSW5uZXJTdHJpZGUobmRhcnJheSwgMik7XHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBzdGF0aWNcclxuICogQG1ldGhvZFxyXG4gKi9cclxuZXhwb3J0cy5jb21wdXRlSW5uZXJTdHJpZGUgPSBmdW5jdGlvbihzaGFwZSwgYXhpcykge1xyXG5cdHZhciBpbm5lclN0cmlkZSA9IDE7XHJcblx0Zm9yICh2YXIgaSA9IGF4aXMgKyAxOyBpIDwgc2hhcGUubGVuZ3RoOyArK2kpIHtcclxuXHRcdGlubmVyU3RyaWRlICo9IHNoYXBlW2ldO1xyXG5cdH1cclxuXHRyZXR1cm4gaW5uZXJTdHJpZGU7XHJcbn07XHJcblxyXG52YXIgZGlzY292ZXJBcnJheVNoYXBlUmVjdXJzaXZlID0gZnVuY3Rpb24oZGF0YSwgc2hhcGUsIGxldmVsKSB7XHJcblx0aWYgKGlzQXJyYXkoZGF0YSkpIHtcclxuXHRcdGlmIChzaGFwZS5sZW5ndGggPD0gbGV2ZWwpIHtcclxuXHRcdFx0LyogRGlzY292ZXJlZCBhIG5ldyBsZXZlbCBvZiBzdWItYXJyYXlzLiBSZWNvcmQgaXRzIGRpbWVuc2lvbi4gKi9cclxuXHRcdFx0c2hhcGUucHVzaChkYXRhLmxlbmd0aCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHQvKiBPbmx5IGNoZWNrIGRpbWVuc2lvbiAqL1xyXG5cdFx0XHRpZiAoc2hhcGVbbGV2ZWxdICE9IGRhdGEubGVuZ3RoKSB7XHJcblx0XHRcdFx0dGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJTdWItYXJyYXkgXCIgKyBkYXRhICsgXCIgZG9lcyBub3QgbWF0Y2ggdGhlIGV4cGVjdGVkIGRpbWVuc2lvbiBvZiBcIiArIHNoYXBlW2xldmVsXSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRkaXNjb3ZlckFycmF5U2hhcGVSZWN1cnNpdmUoZGF0YVtpXSwgc2hhcGUsIGxldmVsICsgMSk7XHJcblx0XHR9XHJcblx0fSBlbHNlIHtcclxuXHRcdGlmIChsZXZlbCAhPSBzaGFwZS5sZW5ndGgpIHtcclxuXHRcdFx0dGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJTdWItYXJyYXkgW1wiICsgZGF0YSArIFwiXSBkb2VzIG5vdCBtYXRjaCB0aGUgZXhwZWN0ZWQgZGltZW5zaW9uIG9mIFwiICsgc2hhcGVbbGV2ZWxdKTtcclxuXHRcdH1cclxuXHRcdGlmICghaXNOdW1iZXIoZGF0YSkpIHtcclxuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihcIk5vbi1udW1lcmljIGVsZW1lbnQ6IFwiICsgZGF0YSk7XHJcblx0XHR9XHJcblx0fVxyXG59O1xyXG5leHBvcnRzLmRpc2NvdmVyQXJyYXlTaGFwZVJlY3Vyc2l2ZSA9IGRpc2NvdmVyQXJyYXlTaGFwZVJlY3Vyc2l2ZTtcclxuXHJcbnZhciBjb3B5QXJyYXlEYXRhUmVjdXJzaXZlID0gZnVuY3Rpb24oZGF0YUJ1ZmZlciwgZGF0YUFycmF5LCBzaGFwZSwgbGV2ZWwsIG9mZnNldCkge1xyXG5cdHZhciBuID0gc2hhcGVbbGV2ZWxdO1xyXG5cdGlmIChsZXZlbCA9PT0gc2hhcGUubGVuZ3RoIC0gMSkge1xyXG5cdFx0ZGF0YUJ1ZmZlci5zZXQoZGF0YUFycmF5LCBvZmZzZXQgKiBuKTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcclxuXHRcdFx0Y29weUFycmF5RGF0YVJlY3Vyc2l2ZShkYXRhQnVmZmVyLCBkYXRhQXJyYXlbaV0sIHNoYXBlLCBsZXZlbCArIDEsIG9mZnNldCAqIG4gICsgaSk7XHJcblx0XHR9XHJcblx0fVxyXG59O1xyXG5leHBvcnRzLmNvcHlBcnJheURhdGFSZWN1cnNpdmUgPSBjb3B5QXJyYXlEYXRhUmVjdXJzaXZlO1xyXG5cclxudmFyIGNyZWF0ZUFycmF5UmVjdXJzaXZlID0gZnVuY3Rpb24oZGF0YUJ1ZmZlciwgZGF0YUFycmF5LCBzaGFwZSwgbGV2ZWwsIG9mZnNldCkge1xyXG5cdHZhciBuID0gc2hhcGVbbGV2ZWxdO1xyXG5cdGlmIChsZXZlbCA9PT0gc2hhcGUubGVuZ3RoIC0gMSkge1xyXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcclxuXHRcdFx0ZGF0YUFycmF5W2ldID0gZGF0YUJ1ZmZlcltvZmZzZXQgKiBuICsgaV07XHJcblx0XHR9XHJcblx0fSBlbHNlIHtcclxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XHJcblx0XHRcdGRhdGFBcnJheVtpXSA9IG5ldyBBcnJheShzaGFwZVtsZXZlbCArIDFdKTtcclxuXHRcdFx0Y3JlYXRlQXJyYXlSZWN1cnNpdmUoZGF0YUJ1ZmZlciwgZGF0YUFycmF5W2ldLCBzaGFwZSwgbGV2ZWwgKyAxLCBvZmZzZXQgKiBuICArIGkpO1xyXG5cdFx0fVxyXG5cdH1cclxufTtcclxuZXhwb3J0cy5jcmVhdGVBcnJheVJlY3Vyc2l2ZSA9IGNyZWF0ZUFycmF5UmVjdXJzaXZlO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbnZhciBOREFycmF5ID0gcmVxdWlyZShcIi4uL05EQXJyYXlcIik7XHJcbnZhciBEYXRhVHlwZSA9IHJlcXVpcmUoXCIuLi9EYXRhVHlwZVwiKTtcclxudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcclxuXHJcblxyXG4vKiBCdWdneSBpbiBDaHJvbWl1bS1XZWJDTCAqL1xyXG52YXIgdXNlQnVmZmVyQ3JlYXRpb25XaXRoSW5pdCA9IGZhbHNlO1xyXG5cclxudmFyIGlzTm9kZVdlYkNMID0gZmFsc2U7XHJcbnZhciBjbCA9IHZvaWQgMDtcclxudmFyIGF2YWlsYWJsZURldmljZXMgPSBudWxsO1xyXG52YXIgYXZhaWxhYmxlRGV2aWNlc0Rlc2NyaXB0aW9ucyA9IG51bGw7XHJcbnZhciBkZWZhdWx0RGV2aWNlSW5kZXggPSAtMTtcclxuXHJcbi8qKlxyXG4gKiBJZiB0aGUgZ2xvYmFsIGNsIHZhcmlhYmxlIGlzIHVuZGVmaW5lZCwgdGhpcyBtZXRob2Qgd291bGQgaW5pdGlhbGl6ZSBpdCB3aXRoIGEgV2ViQ0wgaW5zdGFuY2UuXHJcbiAqIFdvcmtzIGZvciBib3RoIGJyb3dzZXIgYW5kIE5vZGUuanNcclxuICpcclxuICogQHByaXZhdGVcclxuICogQHN0YXRpY1xyXG4gKiBAbWV0aG9kIGluaXRXZWJDTFxyXG4gKiBAcmV0dXJuIHtXZWJDTH0gLSBhbiBpbnN0YW5jZSBvZiBXZWJDTCBvYmplY3QgZnJvbSBXZWJDTCBzcGVjaWZpY2F0aW9uLiBJZiBXZWJDTCBpcyBub3Qgc3VwcG9ydGVkLCByZXR1cm4gbnVsbC5cclxuICovXHJcbnZhciBpbml0V2ViQ0wgPSBmdW5jdGlvbigpIHtcclxuXHRpZiAodHlwZW9mIGNsID09PSBcInVuZGVmaW5lZFwiKSB7XHJcblx0XHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIikge1xyXG5cdFx0XHRjbCA9ICh0eXBlb2Ygd2luZG93LndlYmNsICE9PSBcInVuZGVmaW5lZFwiKSA/IHdpbmRvdy53ZWJjbCA6IG51bGw7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0cnkge1xyXG5cdFx0XHRcdGNsID0gcmVxdWlyZShcIm5vZGUtd2ViY2xcIik7XHJcblx0XHRcdFx0aXNOb2RlV2ViQ0wgPSB0cnVlO1xyXG5cdFx0XHR9IGNhdGNoIChlKSB7XHJcblx0XHRcdFx0Y2wgPSBudWxsO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cdHJldHVybiBjbDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGFuIGVtcHR5IFdlYkNMRXZlbnQuXHJcbiAqIFdvcmtzIGZvciBib3RoIGJyb3dzZXIgYW5kIE5vZGUuanNcclxuICpcclxuICogQHByaXZhdGVcclxuICogQHN0YXRpY1xyXG4gKiBAbWV0aG9kIGNyZWF0ZUV2ZW50XHJcbiAqIEByZXR1cm4ge1dlYkNMRXZlbnR9IC0gYW4gZW1wdHkgaW5zdGFuY2Ugb2YgV2ViQ0xFdmVudC5cclxuICovXHJcbnZhciBjcmVhdGVFdmVudCA9IGZ1bmN0aW9uKCkge1xyXG5cdGlmIChpc05vZGVXZWJDTCkge1xyXG5cdFx0cmV0dXJuIG5ldyBjbC5XZWJDTEV2ZW50KCk7XHJcblx0fSBlbHNlIHtcclxuXHRcdHJldHVybiBuZXcgV2ViQ0xFdmVudCgpO1xyXG5cdH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBUcmllcyB0byByZWxlYXNlIGEgV2ViQ0wgcmVzb3VyY2UgYW5kIGlnbm9yZXMgYW55IGVycm9ycyBpbiB0aGUgcHJvY2Vzcy5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQG1ldGhvZCB0cnlSbGVhc2VcclxuICogQHBhcmFtIHtPYmplY3R9IHdlYmNsT2JqZWN0IC0gYSBXZWJDTCBvYmplY3QuXHJcbiAqIEByZXR1cm4ge0Jvb2xlYW59IC0gdHJ1ZSBpZiB0aGUgb2JqZWN0IHdhcyBzdWNjZXNzZnVsbHkgcmVsZWFzZWQgYW5kIGZhbHNlIG90aGVyd2lzZS5cclxuICovXHJcbnZhciB0cnlSZWxlYXNlID0gZnVuY3Rpb24od2ViY2xSZXNvdXJjZSkge1xyXG5cdGlmICh3ZWJjbFJlc291cmNlICE9PSBudWxsKSB7XHJcblx0XHR0cnkge1xyXG5cdFx0XHR3ZWJjbFJlc291cmNlLnJlbGVhc2UoKTtcclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHR9IGNhdGNoIChlKSB7XHJcblx0XHRcdC8qIFNpbGVudGx5IGlnbm9yZSAqL1xyXG5cdFx0fVxyXG5cdH1cclxuXHRyZXR1cm4gZmFsc2U7XHJcbn07XHJcblxyXG4vKipcclxuICogQ2hlY2tzIGlmIGEgV2ViQ0wgZGV2aWNlIHN1cHBvcnRzIEtIUl9mcDY0IGV4dGVuc2lvbi5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQG1ldGhvZCBpc0ZQNjRDYXBhYmxlXHJcbiAqIEBwYXJhbSB7V2ViQ0xEZXZpY2V9IGRldmljZSAtIHRoZSBkZXZpY2UgdG8gY2hlY2sgZm9yIEtIUl9mcDY0IHN1cHBvcnQuXHJcbiAqIEByZXR1cm4ge0Jvb2xlYW59IC0gdHJ1ZSBpZiB0aGUgZGV2aWNlIHN1cHBvcnRzIEtIUl9mcDY0IGFuZCBmYWxzZSBvdGhlcndpc2UuXHJcbiAqL1xyXG52YXIgaXNGUDY0Q2FwYWJsZSA9IGZ1bmN0aW9uKGRldmljZSkge1xyXG5cdHZhciBleHRlbnNpb25zID0gZGV2aWNlLmdldFN1cHBvcnRlZEV4dGVuc2lvbnMoKTtcclxuXHRpZiAoZXh0ZW5zaW9ucy5pbmRleE9mKFwiS0hSX2ZwNjRcIikgPT09IC0xKSB7XHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fVxyXG5cdC8qXHJcblx0ICogRHVlIHRvIGEgYnVnIFdlYktpdC1XZWJDTCBtYXkgcmVwb3J0IEtIUl9mcDY0IGV2ZW4gaWYgaXQgaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgdW5kZXJseWluZyBPcGVuQ0wgZGV2aWNlLlxyXG5cdCAqIFNlZSBidWcgaHR0cHM6Ly9naXRodWIuY29tL1NSQS1TaWxpY29uVmFsbGV5L3dlYmtpdC13ZWJjbC9pc3N1ZXMvNTM2XHJcblx0ICovXHJcblx0dmFyIHRlc3RTb3VyY2UgPSBcImtlcm5lbCB2b2lkIGZvbyhnbG9iYWwgZG91YmxlKiBiYXIpIHsgfVwiO1xyXG5cdHZhciBjb250ZXh0ID0gbnVsbCwgcHJvZ3JhbSA9IG51bGw7XHJcblx0dHJ5IHtcclxuXHRcdGNvbnRleHQgPSBjbC5jcmVhdGVDb250ZXh0KGRldmljZSk7XHJcblx0XHRwcm9ncmFtID0gY29udGV4dC5jcmVhdGVQcm9ncmFtKHRlc3RTb3VyY2UpO1xyXG5cdFx0cHJvZ3JhbS5idWlsZCgpO1xyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fSBjYXRjaCAoZSkge1xyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH0gZmluYWxseSB7XHJcblx0XHR0cnlSZWxlYXNlKHByb2dyYW0pO1xyXG5cdFx0dHJ5UmVsZWFzZShjb250ZXh0KTtcclxuXHR9XHJcbn07XHJcblxyXG4vKipcclxuICogSW5pdGlhbGlzZXMgYW5kIHJldHVybnMgYSBsaXN0IG9mIFdlYkNMIGRldmljZXMgc3VpdGFibGUgZm9yIGNvbXB1dGF0aW9uLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAc3RhdGljXHJcbiAqIEBtZXRob2QgZ2V0QXZhaWxhYmxlRGV2aWNlc1xyXG4gKiBAcmV0dXJuIHtXZWJDTERldmljZVtdfSAtIGEgbGlzdCBvZiBHUFUgYW5kIENQVSBXZWJDTCBkZXZpY2VzIHRoYXQgc3VwcG9ydCBLSFJfRlA2NCAobWF5IGJlIGVtcHR5KS5cclxuICovXHJcbnZhciBnZXRBdmFpbGFibGVEZXZpY2VzID0gZnVuY3Rpb24oKSB7XHJcblx0aWYgKGF2YWlsYWJsZURldmljZXMgPT09IG51bGwpIHtcclxuXHRcdGF2YWlsYWJsZURldmljZXMgPSBbXTtcclxuXHRcdHZhciB3ZWJjbCA9IGluaXRXZWJDTCgpO1xyXG5cdFx0aWYgKHdlYmNsICE9PSBudWxsKSB7XHJcblx0XHRcdHZhciBwbGF0Zm9ybXMgPSBjbC5nZXRQbGF0Zm9ybXMoKTtcclxuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBwbGF0Zm9ybXMubGVuZ3RoOyArK2kpIHtcclxuXHRcdFx0XHR2YXIgcGxhdGZvcm0gPSBwbGF0Zm9ybXNbaV07XHJcblx0XHRcdFx0dmFyIGRldmljZXMgPSBwbGF0Zm9ybS5nZXREZXZpY2VzKGNsLkRFVklDRV9UWVBFX0FMTCk7XHJcblx0XHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBkZXZpY2VzLmxlbmd0aDsgKytqKSB7XHJcblx0XHRcdFx0XHR2YXIgZGV2aWNlID0gZGV2aWNlc1tqXTtcclxuXHRcdFx0XHRcdGlmIChpc0ZQNjRDYXBhYmxlKGRldmljZSkpIHtcclxuXHRcdFx0XHRcdFx0YXZhaWxhYmxlRGV2aWNlcy5wdXNoKGRldmljZSk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRnZW5lcmF0ZUF2YWlsYWJsZURldmljZXNEZXNjcmlwdGlvbnMoKTtcclxuXHR9XHJcblx0cmV0dXJuIGF2YWlsYWJsZURldmljZXM7XHJcbn07XHJcblxyXG52YXIgZ2VuZXJhdGVBdmFpbGFibGVEZXZpY2VzRGVzY3JpcHRpb25zID0gZnVuY3Rpb24oKSB7XHJcblx0YXZhaWxhYmxlRGV2aWNlc0Rlc2NyaXB0aW9ucyA9IFtdO1xyXG5cdC8qIElmIGRldmljZXMgbmFtZXMgYXJlIGF2YWlsYWJsZSwgdXNlIHRoZW0gKi9cclxuXHR2YXIgaGF2ZU5hbWVzID0gdHJ1ZTtcclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGF2YWlsYWJsZURldmljZXMubGVuZ3RoOyArK2kpIHtcclxuXHRcdHZhciBkZXZpY2UgPSBhdmFpbGFibGVEZXZpY2VzW2ldO1xyXG5cdFx0dmFyIG5hbWUgPSBkZXZpY2UuZ2V0SW5mbyhjbC5ERVZJQ0VfTkFNRSk7XHJcblx0XHRpZiAoKG5hbWUgPT09IG51bGwpIHx8IChuYW1lID09PSBcIlwiKSkge1xyXG5cdFx0XHRoYXZlTmFtZXMgPSBmYWxzZTtcclxuXHRcdFx0YnJlYWs7XHJcblx0XHR9XHJcblx0XHRhdmFpbGFibGVEZXZpY2VzRGVzY3JpcHRpb25zW2ldID0gbmFtZTtcclxuXHR9XHJcblx0aWYgKCFoYXZlTmFtZXMpIHtcclxuXHRcdC8qIEF0IGxlYXN0IHNvbWUgbmFtZXMgYXJlIG5vdCBhdmFpbGFibGU6IHRyeSB0byBhc3NpZ24gbmFtZXMgYmFzZWQgb24gY2xhc3NpZmljYXRpb24gKGUuZy4gXCJDUFVcIiwgXCJkR1BVXCIsIFwiaUdQVVwiKSAqL1xyXG5cdFx0dmFyIGNwdUNvdW50ID0gMCwgaWdwdUNvdW50ID0gMCwgZGdwdUNvdW50ID0gMDtcclxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYXZhaWxhYmxlRGV2aWNlcy5sZW5ndGg7ICsraSkge1xyXG5cdFx0XHR2YXIgZGV2aWNlID0gYXZhaWxhYmxlRGV2aWNlc1tpXTtcclxuXHRcdFx0dmFyIGNsYXNzaWZpY2F0aW9uID0gY2xhc3NpZnlEZXZpY2UoZGV2aWNlKTtcclxuXHRcdFx0aWYgKGNsYXNzaWZpY2F0aW9uID09PSBcImNwdVwiKSB7XHJcblx0XHRcdFx0KytjcHVDb3VudDtcclxuXHRcdFx0XHRhdmFpbGFibGVEZXZpY2VzRGVzY3JpcHRpb25zW2ldID0gXCJDUFVcIjtcclxuXHRcdFx0fSBlbHNlIGlmIChjbGFzc2lmaWNhdGlvbiA9PT0gXCJpZ3B1XCIpIHtcclxuXHRcdFx0XHQrK2lncHVDb3VudDtcclxuXHRcdFx0XHRhdmFpbGFibGVEZXZpY2VzRGVzY3JpcHRpb25zW2ldID0gXCJpR1BVXCI7XHJcblx0XHRcdH0gZWxzZSBpZiAoY2xhc3NpZmljYXRpb24gPT09IFwiZGdwdVwiKSB7XHJcblx0XHRcdFx0KytkZ3B1Q291bnQ7XHJcblx0XHRcdFx0YXZhaWxhYmxlRGV2aWNlc0Rlc2NyaXB0aW9uc1tpXSA9IFwiZEdQVVwiO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIkltcG9zc2libGUgZGV2aWNlIGNsYXNzaWZpY2F0aW9uOiBcIiArIGNsYXNzaWZpY2F0aW9uKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0aWYgKChjcHVDb3VudCA+IDEpIHx8IChpZ3B1Q291bnQgPiAxKSB8fCAoZGdwdUNvdW50ID4gMSkpIHtcclxuXHRcdFx0LyogV2UgaGF2ZSBtdWx0aXBsZSBkZXZpY2VzIG9mIHRoZSBzYW1lIHR5cGUuIE5lZWQgdG8gdXNlIG1vcmUgY29tcGxpY2F0ZWQgbmFtaW5nIHNjaGVtZSAqL1xyXG5cdFx0XHR2YXIgY3B1SW5kZXggPSAwLCBpZ3B1SW5kZXggPSAwLCBkZ3B1SW5kZXggPSAwO1xyXG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGF2YWlsYWJsZURldmljZXMubGVuZ3RoOyArK2kpIHtcclxuXHRcdFx0XHR2YXIgZGV2aWNlID0gYXZhaWxhYmxlRGV2aWNlc1tpXTtcclxuXHRcdFx0XHR2YXIgY2xhc3NpZmljYXRpb24gPSBjbGFzc2lmeURldmljZShkZXZpY2UpO1xyXG5cdFx0XHRcdGlmIChjbGFzc2lmaWNhdGlvbiA9PT0gXCJjcHVcIikge1xyXG5cdFx0XHRcdFx0aWYgKGNwdUNvdW50ID4gMSkge1xyXG5cdFx0XHRcdFx0XHQrK2NwdUluZGV4O1xyXG5cdFx0XHRcdFx0XHRhdmFpbGFibGVEZXZpY2VzRGVzY3JpcHRpb25zW2ldID0gXCJDUFUgI1wiICsgY3B1SW5kZXg7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fSBlbHNlIGlmIChjbGFzc2lmaWNhdGlvbiA9PT0gXCJpZ3B1XCIpIHtcclxuXHRcdFx0XHRcdGlmIChpZ3B1Q291bnQgPiAxKSB7XHJcblx0XHRcdFx0XHRcdCsraWdwdUluZGV4O1xyXG5cdFx0XHRcdFx0XHRhdmFpbGFibGVEZXZpY2VzRGVzY3JpcHRpb25zW2ldID0gXCJpR1BVICNcIiArIGlncHVJbmRleDtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9IGVsc2UgaWYgKGNsYXNzaWZpY2F0aW9uID09PSBcImRncHVcIikge1xyXG5cdFx0XHRcdFx0aWYgKGRncHVDb3VudCA+IDEpIHtcclxuXHRcdFx0XHRcdFx0KytkZ3B1Q291bnQ7XHJcblx0XHRcdFx0XHRcdGF2YWlsYWJsZURldmljZXNEZXNjcmlwdGlvbnNbaV0gPSBcImRHUFUgI1wiICsgZGdwdUluZGV4O1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJJbXBvc3NpYmxlIGRldmljZSBjbGFzc2lmaWNhdGlvbjogXCIgKyBjbGFzc2lmaWNhdGlvbik7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIENsYXNzaWZpZXMgV2ViQ0wgZGV2aWNlIHRvIG9uZSBvZiBmb3VyIGNhdGVnb3JpZXM6XHJcbiAqIC0gXCJjcHVcIiBmb3IgQ1BVIGRldmljZXMuXHJcbiAqIC0gXCJpZ3B1XCIgZm9yIEdQVXMgaW50ZWdyYXRlZCB3aXRoIENQVSBwYWNrYWdlIG9yIGNoaXBzZXQuXHJcbiAqIC0gXCJkZ3B1XCIgZm9yIGRpc2NyZXRlIEdQVXMuXHJcbiAqIC0gXCJ1bmtub3duXCIgZm9yIG90aGVyIHR5cGVzIG9mIGRldmljZXMgKGUuZy4gRlBHQXMpXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBtZXRob2QgY2xhc3NpZnlEZXZpY2VcclxuICogQHBhcmFtIHtXZWJDTERldmljZX0gZGV2aWNlIC0gdGhlIFdlYkNMIGRldmljZSB0byBjbGFzc2lmeS5cclxuICogQHJldHVybiB7U3RyaW5nfSAtIG9uZSBvZiB0aGUgc3RyaW5ncyBkZXNjcmliZWQgYWJvdmUuXHJcbiAqL1xyXG52YXIgY2xhc3NpZnlEZXZpY2UgPSBmdW5jdGlvbihkZXZpY2UpIHtcclxuXHR0cnkge1xyXG5cdFx0dmFyIGRldmljZVR5cGUgPSBkZXZpY2UuZ2V0SW5mbyhjbC5ERVZJQ0VfVFlQRSk7XHJcblx0XHRpZiAoZGV2aWNlVHlwZSA9PT0gY2wuREVWSUNFX1RZUEVfQ1BVKSB7XHJcblx0XHRcdHJldHVybiBcImNwdVwiO1xyXG5cdFx0fSBlbHNlIGlmIChkZXZpY2VUeXBlID09PSBjbC5ERVZJQ0VfVFlQRV9HUFUpIHtcclxuXHRcdFx0dmFyIGlzSG9zdFVuaWZpZWRNZW1vcnkgPSBkZXZpY2UuZ2V0SW5mbyhjbC5ERVZJQ0VfSE9TVF9VTklGSUVEX01FTU9SWSk7XHJcblx0XHRcdHJldHVybiAoaXNIb3N0VW5pZmllZE1lbW9yeSA/IFwiaWdwdVwiIDogXCJkZ3B1XCIpO1xyXG5cdFx0fVxyXG5cdH0gY2F0Y2ggKGUpIHtcclxuXHR9XHJcblx0cmV0dXJuIFwidW5rbm93blwiO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFNlbGVjdHMgdGhlIG9wdGltYWwgV2ViQ0wgZGV2aWNlIGFtb25nIHRoZSBhdmFpbGFibGUgZGV2aWNlcy5cclxuICogVGhlIHByaW9yaXR5IG9mIGRldmljZXM6IFwiZGdwdVwiID4gXCJpZ3B1XCIgPiBcImNwdVwiXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBtZXRob2QgZ2V0RGVmYXVsdERldmljZUluZGV4XHJcbiAqIEByZXR1cm4ge1dlYkNMRGV2aWNlfSAtIHRoZSBzZWxlY3RlZCBkZXZpY2UgZnJvbSB0aGUgbGlzdC5cclxuICovXHJcbnZhciBnZXREZWZhdWx0RGV2aWNlSW5kZXggPSBmdW5jdGlvbigpIHtcclxuXHRpZiAoZGVmYXVsdERldmljZUluZGV4ID09PSAtMSkge1xyXG5cdFx0dmFyIGF2YWlsYWJsZURldmljZXMgPSBnZXRBdmFpbGFibGVEZXZpY2VzKCk7XHJcblx0XHRpZiAoYXZhaWxhYmxlRGV2aWNlcy5sZW5ndGggPT09IDApIHtcclxuXHRcdFx0ZGVmYXVsdERldmljZUluZGV4ID0gLTI7XHJcblx0XHRcdHJldHVybiBkZWZhdWx0RGV2aWNlSW5kZXg7XHJcblx0XHR9XHJcblx0XHR2YXIgZGV2aWNlQ2xhc3NpZmljYXRpb25zID0gW107XHJcblx0XHQvKiBTZWFyY2ggZm9yIFwiZGdwdVwiICovXHJcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGF2YWlsYWJsZURldmljZXMubGVuZ3RoOyArK2kpIHtcclxuXHRcdFx0dmFyIGRldmljZSA9IGF2YWlsYWJsZURldmljZXNbaV07XHJcblx0XHRcdHZhciBkZXZpY2VDbGFzcyA9IGNsYXNzaWZ5RGV2aWNlKGRldmljZSk7XHJcblx0XHRcdGlmIChkZXZpY2VDbGFzcyA9PT0gXCJkZ3B1XCIpIHtcclxuXHRcdFx0XHRkZWZhdWx0RGV2aWNlSW5kZXggPSBpO1xyXG5cdFx0XHRcdHJldHVybiBpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGRldmljZUNsYXNzaWZpY2F0aW9ucy5wdXNoKGRldmljZUNsYXNzKTtcclxuXHRcdH1cclxuXHRcdC8qIFNlYXJjaCBmb3IgXCJpZ3B1XCIgKi9cclxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYXZhaWxhYmxlRGV2aWNlcy5sZW5ndGg7ICsraSkge1xyXG5cdFx0XHRpZiAoZGV2aWNlQ2xhc3NpZmljYXRpb25zW2ldID09PSBcImlncHVcIikge1xyXG5cdFx0XHRcdGRlZmF1bHREZXZpY2VJbmRleCA9IGk7XHJcblx0XHRcdFx0cmV0dXJuIGk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdC8qIFNlYXJjaCBmb3IgXCJjcHVcIiAqL1xyXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhdmFpbGFibGVEZXZpY2VzLmxlbmd0aDsgKytpKSB7XHJcblx0XHRcdGlmIChkZXZpY2VDbGFzc2lmaWNhdGlvbnNbaV0gPT09IFwiY3B1XCIpIHtcclxuXHRcdFx0XHRkZWZhdWx0RGV2aWNlSW5kZXggPSBpO1xyXG5cdFx0XHRcdHJldHVybiBpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cdHJldHVybiBkZWZhdWx0RGV2aWNlSW5kZXg7XHJcbn07XHJcblxyXG52YXIgY3JlYXRlS2VybmVscyA9IGZ1bmN0aW9uKHByb2dyYW0pIHtcclxuXHR2YXIga2VybmVscyA9IHtcclxuXHRcdHNldDoge1xyXG5cdFx0XHRmMzI6IHByb2dyYW0uY3JlYXRlS2VybmVsKFwic2V0X2YzMlwiKSxcclxuXHRcdFx0ZjY0OiBwcm9ncmFtLmNyZWF0ZUtlcm5lbChcInNldF9mNjRcIilcclxuXHRcdH0sXHJcblx0XHRsaW5zcGFjZToge1xyXG5cdFx0XHRmMzI6IHByb2dyYW0uY3JlYXRlS2VybmVsKFwibGluc3BhY2VfZjMyXCIpLFxyXG5cdFx0XHRmNjQ6IHByb2dyYW0uY3JlYXRlS2VybmVsKFwibGluc3BhY2VfZjY0XCIpXHJcblx0XHR9LFxyXG5cdFx0cmVwZWF0OiB7XHJcblx0XHRcdGYzMjogcHJvZ3JhbS5jcmVhdGVLZXJuZWwoXCJyZXBlYXRfZjMyXCIpLFxyXG5cdFx0XHRmNjQ6IHByb2dyYW0uY3JlYXRlS2VybmVsKFwicmVwZWF0X2Y2NFwiKVxyXG5cdFx0fSxcclxuXHRcdGFkZDoge1xyXG5cdFx0XHRmMzI6IHByb2dyYW0uY3JlYXRlS2VybmVsKFwiYWRkX2YzMlwiKSxcclxuXHRcdFx0ZjY0OiBwcm9ncmFtLmNyZWF0ZUtlcm5lbChcImFkZF9mNjRcIilcclxuXHRcdH0sXHJcblx0XHRzdWI6IHtcclxuXHRcdFx0ZjMyOiBwcm9ncmFtLmNyZWF0ZUtlcm5lbChcInN1Yl9mMzJcIiksXHJcblx0XHRcdGY2NDogcHJvZ3JhbS5jcmVhdGVLZXJuZWwoXCJzdWJfZjY0XCIpXHJcblx0XHR9LFxyXG5cdFx0bXVsOiB7XHJcblx0XHRcdGYzMjogcHJvZ3JhbS5jcmVhdGVLZXJuZWwoXCJtdWxfZjMyXCIpLFxyXG5cdFx0XHRmNjQ6IHByb2dyYW0uY3JlYXRlS2VybmVsKFwibXVsX2Y2NFwiKVxyXG5cdFx0fSxcclxuXHRcdGRpdjoge1xyXG5cdFx0XHRmMzI6IHByb2dyYW0uY3JlYXRlS2VybmVsKFwiZGl2X2YzMlwiKSxcclxuXHRcdFx0ZjY0OiBwcm9ncmFtLmNyZWF0ZUtlcm5lbChcImRpdl9mNjRcIilcclxuXHRcdH0sXHJcblx0XHRhZGRjOiB7XHJcblx0XHRcdGYzMjogcHJvZ3JhbS5jcmVhdGVLZXJuZWwoXCJhZGRjX2YzMlwiKSxcclxuXHRcdFx0ZjY0OiBwcm9ncmFtLmNyZWF0ZUtlcm5lbChcImFkZGNfZjY0XCIpXHJcblx0XHR9LFxyXG5cdFx0c3ViYzoge1xyXG5cdFx0XHRmMzI6IHByb2dyYW0uY3JlYXRlS2VybmVsKFwic3ViY19mMzJcIiksXHJcblx0XHRcdGY2NDogcHJvZ3JhbS5jcmVhdGVLZXJuZWwoXCJzdWJjX2Y2NFwiKVxyXG5cdFx0fSxcclxuXHRcdHN1YnJjOiB7XHJcblx0XHRcdGYzMjogcHJvZ3JhbS5jcmVhdGVLZXJuZWwoXCJzdWJyY19mMzJcIiksXHJcblx0XHRcdGY2NDogcHJvZ3JhbS5jcmVhdGVLZXJuZWwoXCJzdWJyY19mNjRcIilcclxuXHRcdH0sXHJcblx0XHRtdWxjOiB7XHJcblx0XHRcdGYzMjogcHJvZ3JhbS5jcmVhdGVLZXJuZWwoXCJtdWxjX2YzMlwiKSxcclxuXHRcdFx0ZjY0OiBwcm9ncmFtLmNyZWF0ZUtlcm5lbChcIm11bGNfZjY0XCIpXHJcblx0XHR9LFxyXG5cdFx0ZGl2Yzoge1xyXG5cdFx0XHRmMzI6IHByb2dyYW0uY3JlYXRlS2VybmVsKFwiZGl2Y19mMzJcIiksXHJcblx0XHRcdGY2NDogcHJvZ3JhbS5jcmVhdGVLZXJuZWwoXCJkaXZjX2Y2NFwiKVxyXG5cdFx0fSxcclxuXHRcdGRpdnJjOiB7XHJcblx0XHRcdGYzMjogcHJvZ3JhbS5jcmVhdGVLZXJuZWwoXCJkaXZyY19mMzJcIiksXHJcblx0XHRcdGY2NDogcHJvZ3JhbS5jcmVhdGVLZXJuZWwoXCJkaXZyY19mNjRcIilcclxuXHRcdH0sXHJcblx0XHRuZWc6IHtcclxuXHRcdFx0ZjMyOiBwcm9ncmFtLmNyZWF0ZUtlcm5lbChcIm5lZ19mMzJcIiksXHJcblx0XHRcdGY2NDogcHJvZ3JhbS5jcmVhdGVLZXJuZWwoXCJuZWdfZjY0XCIpXHJcblx0XHR9LFxyXG5cdFx0YWJzOiB7XHJcblx0XHRcdGYzMjogcHJvZ3JhbS5jcmVhdGVLZXJuZWwoXCJhYnNfZjMyXCIpLFxyXG5cdFx0XHRmNjQ6IHByb2dyYW0uY3JlYXRlS2VybmVsKFwiYWJzX2Y2NFwiKVxyXG5cdFx0fSxcclxuXHRcdGV4cDoge1xyXG5cdFx0XHRmMzI6IHByb2dyYW0uY3JlYXRlS2VybmVsKFwiZXhwX2YzMlwiKSxcclxuXHRcdFx0ZjY0OiBwcm9ncmFtLmNyZWF0ZUtlcm5lbChcImV4cF9mNjRcIilcclxuXHRcdH0sXHJcblx0XHRsb2c6IHtcclxuXHRcdFx0ZjMyOiBwcm9ncmFtLmNyZWF0ZUtlcm5lbChcImxvZ19mMzJcIiksXHJcblx0XHRcdGY2NDogcHJvZ3JhbS5jcmVhdGVLZXJuZWwoXCJsb2dfZjY0XCIpXHJcblx0XHR9LFxyXG5cdFx0c3FydDoge1xyXG5cdFx0XHRmMzI6IHByb2dyYW0uY3JlYXRlS2VybmVsKFwic3FydF9mMzJcIiksXHJcblx0XHRcdGY2NDogcHJvZ3JhbS5jcmVhdGVLZXJuZWwoXCJzcXJ0X2Y2NFwiKVxyXG5cdFx0fSxcclxuXHRcdHNxdWFyZToge1xyXG5cdFx0XHRmMzI6IHByb2dyYW0uY3JlYXRlS2VybmVsKFwic3F1YXJlX2YzMlwiKSxcclxuXHRcdFx0ZjY0OiBwcm9ncmFtLmNyZWF0ZUtlcm5lbChcInNxdWFyZV9mNjRcIilcclxuXHRcdH0sXHJcblx0XHRzdW06IHtcclxuXHRcdFx0ZjMyOiBwcm9ncmFtLmNyZWF0ZUtlcm5lbChcInN1bV9mMzJfZ3B1XCIpLFxyXG5cdFx0XHRmNjQ6IHByb2dyYW0uY3JlYXRlS2VybmVsKFwic3VtX2Y2NF9ncHVcIilcclxuXHRcdH0sXHJcblx0XHRtaW46IHtcclxuXHRcdFx0ZjMyOiBwcm9ncmFtLmNyZWF0ZUtlcm5lbChcIm1pbl9mMzJfZ3B1XCIpLFxyXG5cdFx0XHRmNjQ6IHByb2dyYW0uY3JlYXRlS2VybmVsKFwibWluX2Y2NF9ncHVcIilcclxuXHRcdH0sXHJcblx0XHRtYXg6IHtcclxuXHRcdFx0ZjMyOiBwcm9ncmFtLmNyZWF0ZUtlcm5lbChcIm1heF9mMzJfZ3B1XCIpLFxyXG5cdFx0XHRmNjQ6IHByb2dyYW0uY3JlYXRlS2VybmVsKFwibWF4X2Y2NF9ncHVcIilcclxuXHRcdH0sXHJcblx0XHRhc3VtOiB7XHJcblx0XHRcdGYzMjogcHJvZ3JhbS5jcmVhdGVLZXJuZWwoXCJhc3VtX2YzMlwiKSxcclxuXHRcdFx0ZjY0OiBwcm9ncmFtLmNyZWF0ZUtlcm5lbChcImFzdW1fZjY0XCIpXHJcblx0XHR9LFxyXG5cdFx0YW1pbjoge1xyXG5cdFx0XHRmMzI6IHByb2dyYW0uY3JlYXRlS2VybmVsKFwiYW1pbl9mMzJcIiksXHJcblx0XHRcdGY2NDogcHJvZ3JhbS5jcmVhdGVLZXJuZWwoXCJhbWluX2Y2NFwiKVxyXG5cdFx0fSxcclxuXHRcdGFtYXg6IHtcclxuXHRcdFx0ZjMyOiBwcm9ncmFtLmNyZWF0ZUtlcm5lbChcImFtYXhfZjMyXCIpLFxyXG5cdFx0XHRmNjQ6IHByb2dyYW0uY3JlYXRlS2VybmVsKFwiYW1heF9mNjRcIilcclxuXHRcdH0sXHJcblx0XHRkb3Q6IHtcclxuXHRcdFx0ZjMyOiBwcm9ncmFtLmNyZWF0ZUtlcm5lbChcImRvdF9mMzJcIiksXHJcblx0XHRcdGY2NDogcHJvZ3JhbS5jcmVhdGVLZXJuZWwoXCJkb3RfZjY0XCIpXHJcblx0XHR9XHJcblx0fTtcclxuXHRyZXR1cm4ga2VybmVscztcclxufTtcclxuXHJcbmZ1bmN0aW9uIFdlYkNMQ29udGV4dChvcHRpb25zLCBjYWxsYmFjaykge1xyXG5cdGluaXRXZWJDTCgpO1xyXG5cdHZhciBiaW5hcnlLZXJuZWxzU291cmNlID0gXCJrZXJuZWwgdm9pZCBhZGRfZjMyKFxcclxcblxcdHVpbnQgbGVuZ3RoLFxcclxcblxcdGdsb2JhbCBmbG9hdCogYSxcXHJcXG5cXHRnbG9iYWwgZmxvYXQqIGIsXFxyXFxuXFx0Z2xvYmFsIGZsb2F0KiBvdXQpXFxyXFxue1xcclxcblxcdGNvbnN0IHVpbnQgaWQgPSBnZXRfZ2xvYmFsX2lkKDApO1xcclxcblxcdGlmIChpZCA8IGxlbmd0aCkge1xcclxcblxcdFxcdG91dFtpZF0gPSBhW2lkXSArIGJbaWRdO1xcclxcblxcdH1cXHJcXG59XFxyXFxua2VybmVsIHZvaWQgYWRkX2Y2NChcXHJcXG5cXHR1aW50IGxlbmd0aCxcXHJcXG5cXHRnbG9iYWwgZG91YmxlKiBhLFxcclxcblxcdGdsb2JhbCBkb3VibGUqIGIsXFxyXFxuXFx0Z2xvYmFsIGRvdWJsZSogb3V0KVxcclxcbntcXHJcXG5cXHRjb25zdCB1aW50IGlkID0gZ2V0X2dsb2JhbF9pZCgwKTtcXHJcXG5cXHRpZiAoaWQgPCBsZW5ndGgpIHtcXHJcXG5cXHRcXHRvdXRbaWRdID0gYVtpZF0gKyBiW2lkXTtcXHJcXG5cXHR9XFxyXFxufVxcclxcbmtlcm5lbCB2b2lkIHN1Yl9mMzIoXFxyXFxuXFx0dWludCBsZW5ndGgsXFxyXFxuXFx0Z2xvYmFsIGZsb2F0KiBhLFxcclxcblxcdGdsb2JhbCBmbG9hdCogYixcXHJcXG5cXHRnbG9iYWwgZmxvYXQqIG91dClcXHJcXG57XFxyXFxuXFx0Y29uc3QgdWludCBpZCA9IGdldF9nbG9iYWxfaWQoMCk7XFxyXFxuXFx0aWYgKGlkIDwgbGVuZ3RoKSB7XFxyXFxuXFx0XFx0b3V0W2lkXSA9IGFbaWRdIC0gYltpZF07XFxyXFxuXFx0fVxcclxcbn1cXHJcXG5rZXJuZWwgdm9pZCBzdWJfZjY0KFxcclxcblxcdHVpbnQgbGVuZ3RoLFxcclxcblxcdGdsb2JhbCBkb3VibGUqIGEsXFxyXFxuXFx0Z2xvYmFsIGRvdWJsZSogYixcXHJcXG5cXHRnbG9iYWwgZG91YmxlKiBvdXQpXFxyXFxue1xcclxcblxcdGNvbnN0IHVpbnQgaWQgPSBnZXRfZ2xvYmFsX2lkKDApO1xcclxcblxcdGlmIChpZCA8IGxlbmd0aCkge1xcclxcblxcdFxcdG91dFtpZF0gPSBhW2lkXSAtIGJbaWRdO1xcclxcblxcdH1cXHJcXG59XFxyXFxua2VybmVsIHZvaWQgbXVsX2YzMihcXHJcXG5cXHR1aW50IGxlbmd0aCxcXHJcXG5cXHRnbG9iYWwgZmxvYXQqIGEsXFxyXFxuXFx0Z2xvYmFsIGZsb2F0KiBiLFxcclxcblxcdGdsb2JhbCBmbG9hdCogb3V0KVxcclxcbntcXHJcXG5cXHRjb25zdCB1aW50IGlkID0gZ2V0X2dsb2JhbF9pZCgwKTtcXHJcXG5cXHRpZiAoaWQgPCBsZW5ndGgpIHtcXHJcXG5cXHRcXHRvdXRbaWRdID0gYVtpZF0gKiBiW2lkXTtcXHJcXG5cXHR9XFxyXFxufVxcclxcbmtlcm5lbCB2b2lkIG11bF9mNjQoXFxyXFxuXFx0dWludCBsZW5ndGgsXFxyXFxuXFx0Z2xvYmFsIGRvdWJsZSogYSxcXHJcXG5cXHRnbG9iYWwgZG91YmxlKiBiLFxcclxcblxcdGdsb2JhbCBkb3VibGUqIG91dClcXHJcXG57XFxyXFxuXFx0Y29uc3QgdWludCBpZCA9IGdldF9nbG9iYWxfaWQoMCk7XFxyXFxuXFx0aWYgKGlkIDwgbGVuZ3RoKSB7XFxyXFxuXFx0XFx0b3V0W2lkXSA9IGFbaWRdICogYltpZF07XFxyXFxuXFx0fVxcclxcbn1cXHJcXG5rZXJuZWwgdm9pZCBkaXZfZjMyKFxcclxcblxcdHVpbnQgbGVuZ3RoLFxcclxcblxcdGdsb2JhbCBmbG9hdCogYSxcXHJcXG5cXHRnbG9iYWwgZmxvYXQqIGIsXFxyXFxuXFx0Z2xvYmFsIGZsb2F0KiBvdXQpXFxyXFxue1xcclxcblxcdGNvbnN0IHVpbnQgaWQgPSBnZXRfZ2xvYmFsX2lkKDApO1xcclxcblxcdGlmIChpZCA8IGxlbmd0aCkge1xcclxcblxcdFxcdG91dFtpZF0gPSBhW2lkXSAvIGJbaWRdO1xcclxcblxcdH1cXHJcXG59XFxyXFxua2VybmVsIHZvaWQgZGl2X2Y2NChcXHJcXG5cXHR1aW50IGxlbmd0aCxcXHJcXG5cXHRnbG9iYWwgZG91YmxlKiBhLFxcclxcblxcdGdsb2JhbCBkb3VibGUqIGIsXFxyXFxuXFx0Z2xvYmFsIGRvdWJsZSogb3V0KVxcclxcbntcXHJcXG5cXHRjb25zdCB1aW50IGlkID0gZ2V0X2dsb2JhbF9pZCgwKTtcXHJcXG5cXHRpZiAoaWQgPCBsZW5ndGgpIHtcXHJcXG5cXHRcXHRvdXRbaWRdID0gYVtpZF0gLyBiW2lkXTtcXHJcXG5cXHR9XFxyXFxufVxcclxcbmtlcm5lbCB2b2lkIGFkZGNfZjMyKFxcclxcblxcdHVpbnQgbGVuZ3RoLFxcclxcblxcdGdsb2JhbCBmbG9hdCogYSxcXHJcXG5cXHRmbG9hdCBiLFxcclxcblxcdGdsb2JhbCBmbG9hdCogb3V0KVxcclxcbntcXHJcXG5cXHRjb25zdCB1aW50IGlkID0gZ2V0X2dsb2JhbF9pZCgwKTtcXHJcXG5cXHRpZiAoaWQgPCBsZW5ndGgpIHtcXHJcXG5cXHRcXHRvdXRbaWRdID0gYVtpZF0gKyBiO1xcclxcblxcdH1cXHJcXG59XFxyXFxua2VybmVsIHZvaWQgYWRkY19mNjQoXFxyXFxuXFx0dWludCBsZW5ndGgsXFxyXFxuXFx0Z2xvYmFsIGRvdWJsZSogYSxcXHJcXG5cXHRkb3VibGUgYixcXHJcXG5cXHRnbG9iYWwgZG91YmxlKiBvdXQpXFxyXFxue1xcclxcblxcdGNvbnN0IHVpbnQgaWQgPSBnZXRfZ2xvYmFsX2lkKDApO1xcclxcblxcdGlmIChpZCA8IGxlbmd0aCkge1xcclxcblxcdFxcdG91dFtpZF0gPSBhW2lkXSArIGI7XFxyXFxuXFx0fVxcclxcbn1cXHJcXG5rZXJuZWwgdm9pZCBzdWJjX2YzMihcXHJcXG5cXHR1aW50IGxlbmd0aCxcXHJcXG5cXHRnbG9iYWwgZmxvYXQqIGEsXFxyXFxuXFx0ZmxvYXQgYixcXHJcXG5cXHRnbG9iYWwgZmxvYXQqIG91dClcXHJcXG57XFxyXFxuXFx0Y29uc3QgdWludCBpZCA9IGdldF9nbG9iYWxfaWQoMCk7XFxyXFxuXFx0aWYgKGlkIDwgbGVuZ3RoKSB7XFxyXFxuXFx0XFx0b3V0W2lkXSA9IGFbaWRdIC0gYjtcXHJcXG5cXHR9XFxyXFxufVxcclxcbmtlcm5lbCB2b2lkIHN1YmNfZjY0KFxcclxcblxcdHVpbnQgbGVuZ3RoLFxcclxcblxcdGdsb2JhbCBkb3VibGUqIGEsXFxyXFxuXFx0ZG91YmxlIGIsXFxyXFxuXFx0Z2xvYmFsIGRvdWJsZSogb3V0KVxcclxcbntcXHJcXG5cXHRjb25zdCB1aW50IGlkID0gZ2V0X2dsb2JhbF9pZCgwKTtcXHJcXG5cXHRpZiAoaWQgPCBsZW5ndGgpIHtcXHJcXG5cXHRcXHRvdXRbaWRdID0gYVtpZF0gLSBiO1xcclxcblxcdH1cXHJcXG59XFxyXFxua2VybmVsIHZvaWQgc3VicmNfZjMyKFxcclxcblxcdHVpbnQgbGVuZ3RoLFxcclxcblxcdGdsb2JhbCBmbG9hdCogYSxcXHJcXG5cXHRmbG9hdCBiLFxcclxcblxcdGdsb2JhbCBmbG9hdCogb3V0KVxcclxcbntcXHJcXG5cXHRjb25zdCB1aW50IGlkID0gZ2V0X2dsb2JhbF9pZCgwKTtcXHJcXG5cXHRpZiAoaWQgPCBsZW5ndGgpIHtcXHJcXG5cXHRcXHRvdXRbaWRdID0gYiAvIGFbaWRdO1xcclxcblxcdH1cXHJcXG59XFxyXFxua2VybmVsIHZvaWQgc3VicmNfZjY0KFxcclxcblxcdHVpbnQgbGVuZ3RoLFxcclxcblxcdGdsb2JhbCBkb3VibGUqIGEsXFxyXFxuXFx0ZG91YmxlIGIsXFxyXFxuXFx0Z2xvYmFsIGRvdWJsZSogb3V0KVxcclxcbntcXHJcXG5cXHRjb25zdCB1aW50IGlkID0gZ2V0X2dsb2JhbF9pZCgwKTtcXHJcXG5cXHRpZiAoaWQgPCBsZW5ndGgpIHtcXHJcXG5cXHRcXHRvdXRbaWRdID0gYiAvIGFbaWRdO1xcclxcblxcdH1cXHJcXG59XFxyXFxua2VybmVsIHZvaWQgbXVsY19mMzIoXFxyXFxuXFx0dWludCBsZW5ndGgsXFxyXFxuXFx0Z2xvYmFsIGZsb2F0KiBhLFxcclxcblxcdGZsb2F0IGIsXFxyXFxuXFx0Z2xvYmFsIGZsb2F0KiBvdXQpXFxyXFxue1xcclxcblxcdGNvbnN0IHVpbnQgaWQgPSBnZXRfZ2xvYmFsX2lkKDApO1xcclxcblxcdGlmIChpZCA8IGxlbmd0aCkge1xcclxcblxcdFxcdG91dFtpZF0gPSBhW2lkXSAqIGI7XFxyXFxuXFx0fVxcclxcbn1cXHJcXG5rZXJuZWwgdm9pZCBtdWxjX2Y2NChcXHJcXG5cXHR1aW50IGxlbmd0aCxcXHJcXG5cXHRnbG9iYWwgZG91YmxlKiBhLFxcclxcblxcdGRvdWJsZSBiLFxcclxcblxcdGdsb2JhbCBkb3VibGUqIG91dClcXHJcXG57XFxyXFxuXFx0Y29uc3QgdWludCBpZCA9IGdldF9nbG9iYWxfaWQoMCk7XFxyXFxuXFx0aWYgKGlkIDwgbGVuZ3RoKSB7XFxyXFxuXFx0XFx0b3V0W2lkXSA9IGFbaWRdICogYjtcXHJcXG5cXHR9XFxyXFxufVxcclxcbmtlcm5lbCB2b2lkIGRpdmNfZjMyKFxcclxcblxcdHVpbnQgbGVuZ3RoLFxcclxcblxcdGdsb2JhbCBmbG9hdCogYSxcXHJcXG5cXHRmbG9hdCBiLFxcclxcblxcdGdsb2JhbCBmbG9hdCogb3V0KVxcclxcbntcXHJcXG5cXHRjb25zdCB1aW50IGlkID0gZ2V0X2dsb2JhbF9pZCgwKTtcXHJcXG5cXHRpZiAoaWQgPCBsZW5ndGgpIHtcXHJcXG5cXHRcXHRvdXRbaWRdID0gYVtpZF0gLyBiO1xcclxcblxcdH1cXHJcXG59XFxyXFxua2VybmVsIHZvaWQgZGl2Y19mNjQoXFxyXFxuXFx0dWludCBsZW5ndGgsXFxyXFxuXFx0Z2xvYmFsIGRvdWJsZSogYSxcXHJcXG5cXHRkb3VibGUgYixcXHJcXG5cXHRnbG9iYWwgZG91YmxlKiBvdXQpXFxyXFxue1xcclxcblxcdGNvbnN0IHVpbnQgaWQgPSBnZXRfZ2xvYmFsX2lkKDApO1xcclxcblxcdGlmIChpZCA8IGxlbmd0aCkge1xcclxcblxcdFxcdG91dFtpZF0gPSBhW2lkXSAvIGI7XFxyXFxuXFx0fVxcclxcbn1cXHJcXG5rZXJuZWwgdm9pZCBkaXZyY19mMzIoXFxyXFxuXFx0dWludCBsZW5ndGgsXFxyXFxuXFx0Z2xvYmFsIGZsb2F0KiBhLFxcclxcblxcdGZsb2F0IGIsXFxyXFxuXFx0Z2xvYmFsIGZsb2F0KiBvdXQpXFxyXFxue1xcclxcblxcdGNvbnN0IHVpbnQgaWQgPSBnZXRfZ2xvYmFsX2lkKDApO1xcclxcblxcdGlmIChpZCA8IGxlbmd0aCkge1xcclxcblxcdFxcdG91dFtpZF0gPSBiIC8gYVtpZF07XFxyXFxuXFx0fVxcclxcbn1cXHJcXG5rZXJuZWwgdm9pZCBkaXZyY19mNjQoXFxyXFxuXFx0dWludCBsZW5ndGgsXFxyXFxuXFx0Z2xvYmFsIGRvdWJsZSogYSxcXHJcXG5cXHRkb3VibGUgYixcXHJcXG5cXHRnbG9iYWwgZG91YmxlKiBvdXQpXFxyXFxue1xcclxcblxcdGNvbnN0IHVpbnQgaWQgPSBnZXRfZ2xvYmFsX2lkKDApO1xcclxcblxcdGlmIChpZCA8IGxlbmd0aCkge1xcclxcblxcdFxcdG91dFtpZF0gPSBiIC8gYVtpZF07XFxyXFxuXFx0fVxcclxcbn1cXHJcXG5cIjtcclxuXHR2YXIgdW5hcnlLZXJuZWxzU291cmNlID0gXCJrZXJuZWwgdm9pZCBuZWdfZjMyKFxcclxcblxcdHVpbnQgbGVuZ3RoLFxcclxcblxcdGdsb2JhbCBmbG9hdCogYSxcXHJcXG5cXHRnbG9iYWwgZmxvYXQqIG91dClcXHJcXG57XFxyXFxuXFx0Y29uc3QgdWludCBpZCA9IGdldF9nbG9iYWxfaWQoMCk7XFxyXFxuXFx0aWYgKGlkIDwgbGVuZ3RoKSB7XFxyXFxuXFx0XFx0b3V0W2lkXSA9IC1hW2lkXTtcXHJcXG5cXHR9XFxyXFxufVxcclxcbmtlcm5lbCB2b2lkIG5lZ19mNjQoXFxyXFxuXFx0dWludCBsZW5ndGgsXFxyXFxuXFx0Z2xvYmFsIGRvdWJsZSogYSxcXHJcXG5cXHRnbG9iYWwgZG91YmxlKiBvdXQpXFxyXFxue1xcclxcblxcdGNvbnN0IHVpbnQgaWQgPSBnZXRfZ2xvYmFsX2lkKDApO1xcclxcblxcdGlmIChpZCA8IGxlbmd0aCkge1xcclxcblxcdFxcdG91dFtpZF0gPSAtYVtpZF07XFxyXFxuXFx0fVxcclxcbn1cXHJcXG5rZXJuZWwgdm9pZCBhYnNfZjMyKFxcclxcblxcdHVpbnQgbGVuZ3RoLFxcclxcblxcdGdsb2JhbCBmbG9hdCogYSxcXHJcXG5cXHRnbG9iYWwgZmxvYXQqIG91dClcXHJcXG57XFxyXFxuXFx0Y29uc3QgdWludCBpZCA9IGdldF9nbG9iYWxfaWQoMCk7XFxyXFxuXFx0aWYgKGlkIDwgbGVuZ3RoKSB7XFxyXFxuXFx0XFx0b3V0W2lkXSA9IGZhYnMoYVtpZF0pO1xcclxcblxcdH1cXHJcXG59XFxyXFxua2VybmVsIHZvaWQgYWJzX2Y2NChcXHJcXG5cXHR1aW50IGxlbmd0aCxcXHJcXG5cXHRnbG9iYWwgZG91YmxlKiBhLFxcclxcblxcdGdsb2JhbCBkb3VibGUqIG91dClcXHJcXG57XFxyXFxuXFx0Y29uc3QgdWludCBpZCA9IGdldF9nbG9iYWxfaWQoMCk7XFxyXFxuXFx0aWYgKGlkIDwgbGVuZ3RoKSB7XFxyXFxuXFx0XFx0b3V0W2lkXSA9IGZhYnMoYVtpZF0pO1xcclxcblxcdH1cXHJcXG59XFxyXFxua2VybmVsIHZvaWQgZXhwX2YzMihcXHJcXG5cXHR1aW50IGxlbmd0aCxcXHJcXG5cXHRnbG9iYWwgZmxvYXQqIGEsXFxyXFxuXFx0Z2xvYmFsIGZsb2F0KiBvdXQpXFxyXFxue1xcclxcblxcdGNvbnN0IHVpbnQgaWQgPSBnZXRfZ2xvYmFsX2lkKDApO1xcclxcblxcdGlmIChpZCA8IGxlbmd0aCkge1xcclxcblxcdFxcdG91dFtpZF0gPSBleHAoYVtpZF0pO1xcclxcblxcdH1cXHJcXG59XFxyXFxua2VybmVsIHZvaWQgZXhwX2Y2NChcXHJcXG5cXHR1aW50IGxlbmd0aCxcXHJcXG5cXHRnbG9iYWwgZG91YmxlKiBhLFxcclxcblxcdGdsb2JhbCBkb3VibGUqIG91dClcXHJcXG57XFxyXFxuXFx0Y29uc3QgdWludCBpZCA9IGdldF9nbG9iYWxfaWQoMCk7XFxyXFxuXFx0aWYgKGlkIDwgbGVuZ3RoKSB7XFxyXFxuXFx0XFx0b3V0W2lkXSA9IGV4cChhW2lkXSk7XFxyXFxuXFx0fVxcclxcbn1cXHJcXG5rZXJuZWwgdm9pZCBsb2dfZjMyKFxcclxcblxcdHVpbnQgbGVuZ3RoLFxcclxcblxcdGdsb2JhbCBmbG9hdCogYSxcXHJcXG5cXHRnbG9iYWwgZmxvYXQqIG91dClcXHJcXG57XFxyXFxuXFx0Y29uc3QgdWludCBpZCA9IGdldF9nbG9iYWxfaWQoMCk7XFxyXFxuXFx0aWYgKGlkIDwgbGVuZ3RoKSB7XFxyXFxuXFx0XFx0b3V0W2lkXSA9IGxvZyhhW2lkXSk7XFxyXFxuXFx0fVxcclxcbn1cXHJcXG5rZXJuZWwgdm9pZCBsb2dfZjY0KFxcclxcblxcdHVpbnQgbGVuZ3RoLFxcclxcblxcdGdsb2JhbCBkb3VibGUqIGEsXFxyXFxuXFx0Z2xvYmFsIGRvdWJsZSogb3V0KVxcclxcbntcXHJcXG5cXHRjb25zdCB1aW50IGlkID0gZ2V0X2dsb2JhbF9pZCgwKTtcXHJcXG5cXHRpZiAoaWQgPCBsZW5ndGgpIHtcXHJcXG5cXHRcXHRvdXRbaWRdID0gbG9nKGFbaWRdKTtcXHJcXG5cXHR9XFxyXFxufVxcclxcbmtlcm5lbCB2b2lkIHNxcnRfZjMyKFxcclxcblxcdHVpbnQgbGVuZ3RoLFxcclxcblxcdGdsb2JhbCBmbG9hdCogYSxcXHJcXG5cXHRnbG9iYWwgZmxvYXQqIG91dClcXHJcXG57XFxyXFxuXFx0Y29uc3QgdWludCBpZCA9IGdldF9nbG9iYWxfaWQoMCk7XFxyXFxuXFx0aWYgKGlkIDwgbGVuZ3RoKSB7XFxyXFxuXFx0XFx0b3V0W2lkXSA9IHNxcnQoYVtpZF0pO1xcclxcblxcdH1cXHJcXG59XFxyXFxua2VybmVsIHZvaWQgc3FydF9mNjQoXFxyXFxuXFx0dWludCBsZW5ndGgsXFxyXFxuXFx0Z2xvYmFsIGRvdWJsZSogYSxcXHJcXG5cXHRnbG9iYWwgZG91YmxlKiBvdXQpXFxyXFxue1xcclxcblxcdGNvbnN0IHVpbnQgaWQgPSBnZXRfZ2xvYmFsX2lkKDApO1xcclxcblxcdGlmIChpZCA8IGxlbmd0aCkge1xcclxcblxcdFxcdG91dFtpZF0gPSBzcXJ0KGFbaWRdKTtcXHJcXG5cXHR9XFxyXFxufVxcclxcbmtlcm5lbCB2b2lkIHNxdWFyZV9mMzIoXFxyXFxuXFx0dWludCBsZW5ndGgsXFxyXFxuXFx0Z2xvYmFsIGZsb2F0KiBhLFxcclxcblxcdGdsb2JhbCBmbG9hdCogb3V0KVxcclxcbntcXHJcXG5cXHRjb25zdCB1aW50IGlkID0gZ2V0X2dsb2JhbF9pZCgwKTtcXHJcXG5cXHRpZiAoaWQgPCBsZW5ndGgpIHtcXHJcXG5cXHRcXHRjb25zdCBmbG9hdCBhVmFsID0gYVtpZF07IFxcclxcblxcdFxcdG91dFtpZF0gPSBhVmFsICogYVZhbDtcXHJcXG5cXHR9XFxyXFxufVxcclxcbmtlcm5lbCB2b2lkIHNxdWFyZV9mNjQoXFxyXFxuXFx0dWludCBsZW5ndGgsXFxyXFxuXFx0Z2xvYmFsIGRvdWJsZSogYSxcXHJcXG5cXHRnbG9iYWwgZG91YmxlKiBvdXQpXFxyXFxue1xcclxcblxcdGNvbnN0IHVpbnQgaWQgPSBnZXRfZ2xvYmFsX2lkKDApO1xcclxcblxcdGlmIChpZCA8IGxlbmd0aCkge1xcclxcblxcdFxcdGNvbnN0IGRvdWJsZSBhVmFsID0gYVtpZF07XFxyXFxuXFx0XFx0b3V0W2lkXSA9IGFWYWwgKiBhVmFsO1xcclxcblxcdH1cXHJcXG59XFxyXFxuXCI7XHJcblx0dmFyIHJlZHVjdGlvbktlcm5lbHNTb3VyY2UgPSBcImtlcm5lbCB2b2lkIHN1bV9mMzJfZ3B1KFxcclxcblxcdHVpbnQgbGVuZ3RoLFxcclxcblxcdGdsb2JhbCBmbG9hdCogYSxcXHJcXG5cXHRsb2NhbCBmbG9hdCogc2NyYXRjaCxcXHJcXG5cXHRnbG9iYWwgZmxvYXQqIG91dClcXHJcXG57XFxyXFxuXFx0Y29uc3QgdWludCBnbG9iYWxTaXplID0gZ2V0X2dsb2JhbF9zaXplKDApO1xcclxcblxcdHVpbnQgZ2xvYmFsSW5kZXggPSBnZXRfZ2xvYmFsX2lkKDApO1xcclxcblxcdGZsb2F0IGFjY3VtdWxhdG9yID0gMC4wZjtcXHJcXG5cXHR3aGlsZSAoZ2xvYmFsSW5kZXggPCBsZW5ndGgpIHtcXHJcXG5cXHRcXHRhY2N1bXVsYXRvciArPSBhW2dsb2JhbEluZGV4XTtcXHJcXG5cXHRcXHRnbG9iYWxJbmRleCArPSBnbG9iYWxTaXplO1xcclxcblxcdH1cXHJcXG5cXHJcXG5cXHR1aW50IGxvY2FsSW5kZXggPSBnZXRfbG9jYWxfaWQoMCk7XFxyXFxuXFx0c2NyYXRjaFtsb2NhbEluZGV4XSA9IGFjY3VtdWxhdG9yO1xcclxcblxcdGJhcnJpZXIoQ0xLX0xPQ0FMX01FTV9GRU5DRSk7XFxyXFxuXFx0Zm9yICh1aW50IG9mZnNldCA9IGdldF9sb2NhbF9zaXplKDApIC8gMjsgb2Zmc2V0ICE9IDA7IG9mZnNldCA+Pj0gMSkge1xcclxcblxcdFxcdGlmIChsb2NhbEluZGV4IDwgb2Zmc2V0KSB7XFxyXFxuXFx0XFx0XFx0c2NyYXRjaFtsb2NhbEluZGV4XSArPSBzY3JhdGNoW2xvY2FsSW5kZXggKyBvZmZzZXRdO1xcclxcblxcdFxcdH1cXHJcXG5cXHRcXHRiYXJyaWVyKENMS19MT0NBTF9NRU1fRkVOQ0UpO1xcclxcblxcdH1cXHJcXG5cXHRpZiAobG9jYWxJbmRleCA9PSAwKSB7XFxyXFxuXFx0XFx0b3V0W2dldF9ncm91cF9pZCgwKV0gPSBzY3JhdGNoWzBdO1xcclxcblxcdH1cXHJcXG59XFxyXFxuXFxyXFxua2VybmVsIHZvaWQgc3VtX2Y2NF9ncHUoXFxyXFxuXFx0dWludCBsZW5ndGgsXFxyXFxuXFx0Z2xvYmFsIGRvdWJsZSogYSxcXHJcXG5cXHRsb2NhbCBkb3VibGUqIHNjcmF0Y2gsXFxyXFxuXFx0Z2xvYmFsIGRvdWJsZSogb3V0KVxcclxcbntcXHJcXG5cXHRjb25zdCB1aW50IGdsb2JhbFNpemUgPSBnZXRfZ2xvYmFsX3NpemUoMCk7XFxyXFxuXFx0dWludCBnbG9iYWxJbmRleCA9IGdldF9nbG9iYWxfaWQoMCk7XFxyXFxuXFx0ZG91YmxlIGFjY3VtdWxhdG9yID0gMC4wO1xcclxcblxcdHdoaWxlIChnbG9iYWxJbmRleCA8IGxlbmd0aCkge1xcclxcblxcdFxcdGFjY3VtdWxhdG9yICs9IGFbZ2xvYmFsSW5kZXhdO1xcclxcblxcdFxcdGdsb2JhbEluZGV4ICs9IGdsb2JhbFNpemU7XFxyXFxuXFx0fVxcclxcblxcclxcblxcdHVpbnQgbG9jYWxJbmRleCA9IGdldF9sb2NhbF9pZCgwKTtcXHJcXG5cXHRzY3JhdGNoW2xvY2FsSW5kZXhdID0gYWNjdW11bGF0b3I7XFxyXFxuXFx0YmFycmllcihDTEtfTE9DQUxfTUVNX0ZFTkNFKTtcXHJcXG5cXHRmb3IgKHVpbnQgb2Zmc2V0ID0gZ2V0X2xvY2FsX3NpemUoMCkgLyAyOyBvZmZzZXQgIT0gMDsgb2Zmc2V0ID4+PSAxKSB7XFxyXFxuXFx0XFx0aWYgKGxvY2FsSW5kZXggPCBvZmZzZXQpIHtcXHJcXG5cXHRcXHRcXHRzY3JhdGNoW2xvY2FsSW5kZXhdICs9IHNjcmF0Y2hbbG9jYWxJbmRleCArIG9mZnNldF07XFxyXFxuXFx0XFx0fVxcclxcblxcdFxcdGJhcnJpZXIoQ0xLX0xPQ0FMX01FTV9GRU5DRSk7XFxyXFxuXFx0fVxcclxcblxcdGlmIChsb2NhbEluZGV4ID09IDApIHtcXHJcXG5cXHRcXHRvdXRbZ2V0X2dyb3VwX2lkKDApXSA9IHNjcmF0Y2hbMF07XFxyXFxuXFx0fVxcclxcbn1cXHJcXG5cXHJcXG5rZXJuZWwgdm9pZCBtaW5fZjMyX2dwdShcXHJcXG5cXHR1aW50IGxlbmd0aCxcXHJcXG5cXHRnbG9iYWwgZmxvYXQqIGEsXFxyXFxuXFx0bG9jYWwgZmxvYXQqIHNjcmF0Y2gsXFxyXFxuXFx0Z2xvYmFsIGZsb2F0KiBvdXQpXFxyXFxue1xcclxcblxcdGNvbnN0IHVpbnQgZ2xvYmFsU2l6ZSA9IGdldF9nbG9iYWxfc2l6ZSgwKTtcXHJcXG5cXHR1aW50IGdsb2JhbEluZGV4ID0gZ2V0X2dsb2JhbF9pZCgwKTtcXHJcXG5cXHRmbG9hdCBhY2N1bXVsYXRvciA9IElORklOSVRZO1xcclxcblxcdHdoaWxlIChnbG9iYWxJbmRleCA8IGxlbmd0aCkge1xcclxcblxcdFxcdGFjY3VtdWxhdG9yID0gbWluKGFjY3VtdWxhdG9yLCBhW2dsb2JhbEluZGV4XSk7XFxyXFxuXFx0XFx0Z2xvYmFsSW5kZXggKz0gZ2xvYmFsU2l6ZTtcXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0dWludCBsb2NhbEluZGV4ID0gZ2V0X2xvY2FsX2lkKDApO1xcclxcblxcdHNjcmF0Y2hbbG9jYWxJbmRleF0gPSBhY2N1bXVsYXRvcjtcXHJcXG5cXHRiYXJyaWVyKENMS19MT0NBTF9NRU1fRkVOQ0UpO1xcclxcblxcdGZvciAodWludCBvZmZzZXQgPSBnZXRfbG9jYWxfc2l6ZSgwKSAvIDI7IG9mZnNldCAhPSAwOyBvZmZzZXQgPj49IDEpIHtcXHJcXG5cXHRcXHRpZiAobG9jYWxJbmRleCA8IG9mZnNldCkge1xcclxcblxcdFxcdFxcdHNjcmF0Y2hbbG9jYWxJbmRleF0gPSBtaW4oc2NyYXRjaFtsb2NhbEluZGV4XSwgc2NyYXRjaFtsb2NhbEluZGV4ICsgb2Zmc2V0XSk7XFxyXFxuXFx0XFx0fVxcclxcblxcdFxcdGJhcnJpZXIoQ0xLX0xPQ0FMX01FTV9GRU5DRSk7XFxyXFxuXFx0fVxcclxcblxcdGlmIChsb2NhbEluZGV4ID09IDApIHtcXHJcXG5cXHRcXHRvdXRbZ2V0X2dyb3VwX2lkKDApXSA9IHNjcmF0Y2hbMF07XFxyXFxuXFx0fVxcclxcbn1cXHJcXG5cXHJcXG5rZXJuZWwgdm9pZCBtaW5fZjY0X2dwdShcXHJcXG5cXHR1aW50IGxlbmd0aCxcXHJcXG5cXHRnbG9iYWwgZG91YmxlKiBhLFxcclxcblxcdGxvY2FsIGRvdWJsZSogc2NyYXRjaCxcXHJcXG5cXHRnbG9iYWwgZG91YmxlKiBvdXQpXFxyXFxue1xcclxcblxcdGNvbnN0IHVpbnQgZ2xvYmFsU2l6ZSA9IGdldF9nbG9iYWxfc2l6ZSgwKTtcXHJcXG5cXHR1aW50IGdsb2JhbEluZGV4ID0gZ2V0X2dsb2JhbF9pZCgwKTtcXHJcXG5cXHRkb3VibGUgYWNjdW11bGF0b3IgPSBJTkZJTklUWTtcXHJcXG5cXHR3aGlsZSAoZ2xvYmFsSW5kZXggPCBsZW5ndGgpIHtcXHJcXG5cXHRcXHRhY2N1bXVsYXRvciA9IG1pbihhY2N1bXVsYXRvciwgYVtnbG9iYWxJbmRleF0pO1xcclxcblxcdFxcdGdsb2JhbEluZGV4ICs9IGdsb2JhbFNpemU7XFxyXFxuXFx0fVxcclxcblxcclxcblxcdHVpbnQgbG9jYWxJbmRleCA9IGdldF9sb2NhbF9pZCgwKTtcXHJcXG5cXHRzY3JhdGNoW2xvY2FsSW5kZXhdID0gYWNjdW11bGF0b3I7XFxyXFxuXFx0YmFycmllcihDTEtfTE9DQUxfTUVNX0ZFTkNFKTtcXHJcXG5cXHRmb3IgKHVpbnQgb2Zmc2V0ID0gZ2V0X2xvY2FsX3NpemUoMCkgLyAyOyBvZmZzZXQgIT0gMDsgb2Zmc2V0ID4+PSAxKSB7XFxyXFxuXFx0XFx0aWYgKGxvY2FsSW5kZXggPCBvZmZzZXQpIHtcXHJcXG5cXHRcXHRcXHRzY3JhdGNoW2xvY2FsSW5kZXhdID0gbWluKHNjcmF0Y2hbbG9jYWxJbmRleF0sIHNjcmF0Y2hbbG9jYWxJbmRleCArIG9mZnNldF0pO1xcclxcblxcdFxcdH1cXHJcXG5cXHRcXHRiYXJyaWVyKENMS19MT0NBTF9NRU1fRkVOQ0UpO1xcclxcblxcdH1cXHJcXG5cXHRpZiAobG9jYWxJbmRleCA9PSAwKSB7XFxyXFxuXFx0XFx0b3V0W2dldF9ncm91cF9pZCgwKV0gPSBzY3JhdGNoWzBdO1xcclxcblxcdH1cXHJcXG59XFxyXFxuXFxyXFxua2VybmVsIHZvaWQgbWF4X2YzMl9ncHUoXFxyXFxuXFx0dWludCBsZW5ndGgsXFxyXFxuXFx0Z2xvYmFsIGZsb2F0KiBhLFxcclxcblxcdGxvY2FsIGZsb2F0KiBzY3JhdGNoLFxcclxcblxcdGdsb2JhbCBmbG9hdCogb3V0KVxcclxcbntcXHJcXG5cXHRjb25zdCB1aW50IGdsb2JhbFNpemUgPSBnZXRfZ2xvYmFsX3NpemUoMCk7XFxyXFxuXFx0dWludCBnbG9iYWxJbmRleCA9IGdldF9nbG9iYWxfaWQoMCk7XFxyXFxuXFx0ZmxvYXQgYWNjdW11bGF0b3IgPSAtSU5GSU5JVFk7XFxyXFxuXFx0d2hpbGUgKGdsb2JhbEluZGV4IDwgbGVuZ3RoKSB7XFxyXFxuXFx0XFx0YWNjdW11bGF0b3IgPSBtYXgoYWNjdW11bGF0b3IsIGFbZ2xvYmFsSW5kZXhdKTtcXHJcXG5cXHRcXHRnbG9iYWxJbmRleCArPSBnbG9iYWxTaXplO1xcclxcblxcdH1cXHJcXG5cXHJcXG5cXHR1aW50IGxvY2FsSW5kZXggPSBnZXRfbG9jYWxfaWQoMCk7XFxyXFxuXFx0c2NyYXRjaFtsb2NhbEluZGV4XSA9IGFjY3VtdWxhdG9yO1xcclxcblxcdGJhcnJpZXIoQ0xLX0xPQ0FMX01FTV9GRU5DRSk7XFxyXFxuXFx0Zm9yICh1aW50IG9mZnNldCA9IGdldF9sb2NhbF9zaXplKDApIC8gMjsgb2Zmc2V0ICE9IDA7IG9mZnNldCA+Pj0gMSkge1xcclxcblxcdFxcdGlmIChsb2NhbEluZGV4IDwgb2Zmc2V0KSB7XFxyXFxuXFx0XFx0XFx0c2NyYXRjaFtsb2NhbEluZGV4XSA9IG1heChzY3JhdGNoW2xvY2FsSW5kZXhdLCBzY3JhdGNoW2xvY2FsSW5kZXggKyBvZmZzZXRdKTtcXHJcXG5cXHRcXHR9XFxyXFxuXFx0XFx0YmFycmllcihDTEtfTE9DQUxfTUVNX0ZFTkNFKTtcXHJcXG5cXHR9XFxyXFxuXFx0aWYgKGxvY2FsSW5kZXggPT0gMCkge1xcclxcblxcdFxcdG91dFtnZXRfZ3JvdXBfaWQoMCldID0gc2NyYXRjaFswXTtcXHJcXG5cXHR9XFxyXFxufVxcclxcblxcclxcbmtlcm5lbCB2b2lkIG1heF9mNjRfZ3B1KFxcclxcblxcdHVpbnQgbGVuZ3RoLFxcclxcblxcdGdsb2JhbCBkb3VibGUqIGEsXFxyXFxuXFx0bG9jYWwgZG91YmxlKiBzY3JhdGNoLFxcclxcblxcdGdsb2JhbCBkb3VibGUqIG91dClcXHJcXG57XFxyXFxuXFx0Y29uc3QgdWludCBnbG9iYWxTaXplID0gZ2V0X2dsb2JhbF9zaXplKDApO1xcclxcblxcdHVpbnQgZ2xvYmFsSW5kZXggPSBnZXRfZ2xvYmFsX2lkKDApO1xcclxcblxcdGRvdWJsZSBhY2N1bXVsYXRvciA9IC1JTkZJTklUWTtcXHJcXG5cXHR3aGlsZSAoZ2xvYmFsSW5kZXggPCBsZW5ndGgpIHtcXHJcXG5cXHRcXHRhY2N1bXVsYXRvciA9IG1heChhY2N1bXVsYXRvciwgYVtnbG9iYWxJbmRleF0pO1xcclxcblxcdFxcdGdsb2JhbEluZGV4ICs9IGdsb2JhbFNpemU7XFxyXFxuXFx0fVxcclxcblxcclxcblxcdHVpbnQgbG9jYWxJbmRleCA9IGdldF9sb2NhbF9pZCgwKTtcXHJcXG5cXHRzY3JhdGNoW2xvY2FsSW5kZXhdID0gYWNjdW11bGF0b3I7XFxyXFxuXFx0YmFycmllcihDTEtfTE9DQUxfTUVNX0ZFTkNFKTtcXHJcXG5cXHRmb3IgKHVpbnQgb2Zmc2V0ID0gZ2V0X2xvY2FsX3NpemUoMCkgLyAyOyBvZmZzZXQgIT0gMDsgb2Zmc2V0ID4+PSAxKSB7XFxyXFxuXFx0XFx0aWYgKGxvY2FsSW5kZXggPCBvZmZzZXQpIHtcXHJcXG5cXHRcXHRcXHRzY3JhdGNoW2xvY2FsSW5kZXhdID0gbWF4KHNjcmF0Y2hbbG9jYWxJbmRleF0sIHNjcmF0Y2hbbG9jYWxJbmRleCArIG9mZnNldF0pO1xcclxcblxcdFxcdH1cXHJcXG5cXHRcXHRiYXJyaWVyKENMS19MT0NBTF9NRU1fRkVOQ0UpO1xcclxcblxcdH1cXHJcXG5cXHRpZiAobG9jYWxJbmRleCA9PSAwKSB7XFxyXFxuXFx0XFx0b3V0W2dldF9ncm91cF9pZCgwKV0gPSBzY3JhdGNoWzBdO1xcclxcblxcdH1cXHJcXG59XFxyXFxuXCI7XHJcblx0dmFyIGF4aXNSZWR1Y3Rpb25LZXJuZWxzU291cmNlID0gXCJrZXJuZWwgdm9pZCBhc3VtX2YzMihcXHJcXG5cXHR1aW50IHJlZHVjdGlvbkRpbSxcXHJcXG5cXHRnbG9iYWwgZmxvYXQqIGEsXFxyXFxuXFx0Z2xvYmFsIGZsb2F0KiBvdXQpXFxyXFxue1xcclxcblxcdGNvbnN0IHVpbnQgaW5uZXJTdHJpZGUgPSBnZXRfZ2xvYmFsX3NpemUoMSk7XFxyXFxuXFx0Y29uc3QgdWludCBpID0gZ2V0X2dsb2JhbF9pZCgwKTtcXHJcXG5cXHRjb25zdCB1aW50IGsgPSBnZXRfZ2xvYmFsX2lkKDEpO1xcclxcblxcdGEgKz0gaSAqIHJlZHVjdGlvbkRpbSAqIGlubmVyU3RyaWRlICsgaztcXHJcXG5cXHRmbG9hdCBhY2N1bXVsYXRvciA9ICphO1xcclxcblxcdHdoaWxlICgtLXJlZHVjdGlvbkRpbSkge1xcclxcblxcdFxcdGEgKz0gaW5uZXJTdHJpZGU7XFxyXFxuXFx0XFx0YWNjdW11bGF0b3IgKz0gKmE7XFxyXFxuXFx0fVxcclxcblxcdG91dFtpICogaW5uZXJTdHJpZGUgKyBrXSA9IGFjY3VtdWxhdG9yO1xcclxcbn1cXHJcXG5cXHJcXG5rZXJuZWwgdm9pZCBhc3VtX2Y2NChcXHJcXG5cXHR1aW50IHJlZHVjdGlvbkRpbSxcXHJcXG5cXHRnbG9iYWwgZG91YmxlKiBhLFxcclxcblxcdGdsb2JhbCBkb3VibGUqIG91dClcXHJcXG57XFxyXFxuXFx0Y29uc3QgdWludCBpbm5lclN0cmlkZSA9IGdldF9nbG9iYWxfc2l6ZSgxKTtcXHJcXG5cXHRjb25zdCB1aW50IGkgPSBnZXRfZ2xvYmFsX2lkKDApO1xcclxcblxcdGNvbnN0IHVpbnQgayA9IGdldF9nbG9iYWxfaWQoMSk7XFxyXFxuXFx0YSArPSBpICogcmVkdWN0aW9uRGltICogaW5uZXJTdHJpZGUgKyBrO1xcclxcblxcdGRvdWJsZSBhY2N1bXVsYXRvciA9ICphO1xcclxcblxcdHdoaWxlICgtLXJlZHVjdGlvbkRpbSkge1xcclxcblxcdFxcdGEgKz0gaW5uZXJTdHJpZGU7XFxyXFxuXFx0XFx0YWNjdW11bGF0b3IgKz0gKmE7XFxyXFxuXFx0fVxcclxcblxcdG91dFtpICogaW5uZXJTdHJpZGUgKyBrXSA9IGFjY3VtdWxhdG9yO1xcclxcbn1cXHJcXG5cXHJcXG5rZXJuZWwgdm9pZCBhbWluX2YzMihcXHJcXG5cXHR1aW50IHJlZHVjdGlvbkRpbSxcXHJcXG5cXHRnbG9iYWwgZmxvYXQqIGEsXFxyXFxuXFx0Z2xvYmFsIGZsb2F0KiBvdXQpXFxyXFxue1xcclxcblxcdGNvbnN0IHVpbnQgaW5uZXJTdHJpZGUgPSBnZXRfZ2xvYmFsX3NpemUoMSk7XFxyXFxuXFx0Y29uc3QgdWludCBpID0gZ2V0X2dsb2JhbF9pZCgwKTtcXHJcXG5cXHRjb25zdCB1aW50IGsgPSBnZXRfZ2xvYmFsX2lkKDEpO1xcclxcblxcdGEgKz0gaSAqIHJlZHVjdGlvbkRpbSAqIGlubmVyU3RyaWRlICsgaztcXHJcXG5cXHRmbG9hdCBhY2N1bXVsYXRvciA9ICphO1xcclxcblxcdHdoaWxlICgtLXJlZHVjdGlvbkRpbSkge1xcclxcblxcdFxcdGEgKz0gaW5uZXJTdHJpZGU7XFxyXFxuXFx0XFx0YWNjdW11bGF0b3IgPSBtaW4oYWNjdW11bGF0b3IsICphKTtcXHJcXG5cXHR9XFxyXFxuXFx0b3V0W2kgKiBpbm5lclN0cmlkZSArIGtdID0gYWNjdW11bGF0b3I7XFxyXFxufVxcclxcblxcclxcbmtlcm5lbCB2b2lkIGFtaW5fZjY0KFxcclxcblxcdHVpbnQgcmVkdWN0aW9uRGltLFxcclxcblxcdGdsb2JhbCBkb3VibGUqIGEsXFxyXFxuXFx0Z2xvYmFsIGRvdWJsZSogb3V0KVxcclxcbntcXHJcXG5cXHRjb25zdCB1aW50IGlubmVyU3RyaWRlID0gZ2V0X2dsb2JhbF9zaXplKDEpO1xcclxcblxcdGNvbnN0IHVpbnQgaSA9IGdldF9nbG9iYWxfaWQoMCk7XFxyXFxuXFx0Y29uc3QgdWludCBrID0gZ2V0X2dsb2JhbF9pZCgxKTtcXHJcXG5cXHRhICs9IGkgKiByZWR1Y3Rpb25EaW0gKiBpbm5lclN0cmlkZSArIGs7XFxyXFxuXFx0ZG91YmxlIGFjY3VtdWxhdG9yID0gKmE7XFxyXFxuXFx0d2hpbGUgKC0tcmVkdWN0aW9uRGltKSB7XFxyXFxuXFx0XFx0YSArPSBpbm5lclN0cmlkZTtcXHJcXG5cXHRcXHRhY2N1bXVsYXRvciA9IG1pbihhY2N1bXVsYXRvciwgKmEpO1xcclxcblxcdH1cXHJcXG5cXHRvdXRbaSAqIGlubmVyU3RyaWRlICsga10gPSBhY2N1bXVsYXRvcjtcXHJcXG59XFxyXFxuXFxyXFxua2VybmVsIHZvaWQgYW1heF9mMzIoXFxyXFxuXFx0dWludCByZWR1Y3Rpb25EaW0sXFxyXFxuXFx0Z2xvYmFsIGZsb2F0KiBhLFxcclxcblxcdGdsb2JhbCBmbG9hdCogb3V0KVxcclxcbntcXHJcXG5cXHRjb25zdCB1aW50IGlubmVyU3RyaWRlID0gZ2V0X2dsb2JhbF9zaXplKDEpO1xcclxcblxcdGNvbnN0IHVpbnQgaSA9IGdldF9nbG9iYWxfaWQoMCk7XFxyXFxuXFx0Y29uc3QgdWludCBrID0gZ2V0X2dsb2JhbF9pZCgxKTtcXHJcXG5cXHRhICs9IGkgKiByZWR1Y3Rpb25EaW0gKiBpbm5lclN0cmlkZSArIGs7XFxyXFxuXFx0ZmxvYXQgYWNjdW11bGF0b3IgPSAqYTtcXHJcXG5cXHR3aGlsZSAoLS1yZWR1Y3Rpb25EaW0pIHtcXHJcXG5cXHRcXHRhICs9IGlubmVyU3RyaWRlO1xcclxcblxcdFxcdGFjY3VtdWxhdG9yID0gbWF4KGFjY3VtdWxhdG9yLCAqYSk7XFxyXFxuXFx0fVxcclxcblxcdG91dFtpICogaW5uZXJTdHJpZGUgKyBrXSA9IGFjY3VtdWxhdG9yO1xcclxcbn1cXHJcXG5cXHJcXG5rZXJuZWwgdm9pZCBhbWF4X2Y2NChcXHJcXG5cXHR1aW50IHJlZHVjdGlvbkRpbSxcXHJcXG5cXHRnbG9iYWwgZG91YmxlKiBhLFxcclxcblxcdGdsb2JhbCBkb3VibGUqIG91dClcXHJcXG57XFxyXFxuXFx0Y29uc3QgdWludCBpbm5lclN0cmlkZSA9IGdldF9nbG9iYWxfc2l6ZSgxKTtcXHJcXG5cXHRjb25zdCB1aW50IGkgPSBnZXRfZ2xvYmFsX2lkKDApO1xcclxcblxcdGNvbnN0IHVpbnQgayA9IGdldF9nbG9iYWxfaWQoMSk7XFxyXFxuXFx0YSArPSBpICogcmVkdWN0aW9uRGltICogaW5uZXJTdHJpZGUgKyBrO1xcclxcblxcdGRvdWJsZSBhY2N1bXVsYXRvciA9ICphO1xcclxcblxcdHdoaWxlICgtLXJlZHVjdGlvbkRpbSkge1xcclxcblxcdFxcdGEgKz0gaW5uZXJTdHJpZGU7XFxyXFxuXFx0XFx0YWNjdW11bGF0b3IgPSBtYXgoYWNjdW11bGF0b3IsICphKTtcXHJcXG5cXHR9XFxyXFxuXFx0b3V0W2kgKiBpbm5lclN0cmlkZSArIGtdID0gYWNjdW11bGF0b3I7XFxyXFxufVxcclxcblwiO1xyXG5cdHZhciBwcm9kdWN0S2VybmVsc1NvdXJjZSA9IFwia2VybmVsIHZvaWQgZG90X2YzMihcXHJcXG5cXHR1aW50IHJlZHVjdGlvbkRpbSxcXHJcXG5cXHRnbG9iYWwgZmxvYXQqIGEsXFxyXFxuXFx0Z2xvYmFsIGZsb2F0KiBiLFxcclxcblxcdGdsb2JhbCBmbG9hdCogb3V0KVxcclxcbntcXHJcXG5cXHRjb25zdCB1aW50IGkgPSBnZXRfZ2xvYmFsX2lkKDApO1xcclxcblxcdGNvbnN0IHVpbnQgayA9IGdldF9nbG9iYWxfaWQoMSk7XFxyXFxuXFx0Y29uc3QgdWludCBsID0gZ2V0X2dsb2JhbF9pZCgyKTtcXHJcXG5cXHRjb25zdCB1aW50IG91dGVyU3RyaWRlQiA9IGdldF9nbG9iYWxfc2l6ZSgxKTtcXHJcXG5cXHRjb25zdCB1aW50IGlubmVyU3RyaWRlQiA9IGdldF9nbG9iYWxfc2l6ZSgyKTtcXHJcXG5cXHJcXG5cXHRmbG9hdCBhY2N1bXVsYXRvciA9IDAuMGY7XFxyXFxuXFx0Zm9yICh1aW50IGogPSAwOyBqIDwgcmVkdWN0aW9uRGltOyArK2opIHtcXHJcXG5cXHRcXHRhY2N1bXVsYXRvciArPSBhW2kqcmVkdWN0aW9uRGltK2pdICogYlsoaypyZWR1Y3Rpb25EaW0raikqaW5uZXJTdHJpZGVCK2xdO1xcclxcblxcdH1cXHJcXG5cXHRvdXRbKGkqb3V0ZXJTdHJpZGVCICsgaykgKiBpbm5lclN0cmlkZUIgKyBsXSA9IGFjY3VtdWxhdG9yO1xcclxcbn1cXHJcXG5cXHJcXG5rZXJuZWwgdm9pZCBkb3RfZjY0KFxcclxcblxcdHVpbnQgcmVkdWN0aW9uRGltLFxcclxcblxcdGdsb2JhbCBkb3VibGUqIGEsXFxyXFxuXFx0Z2xvYmFsIGRvdWJsZSogYixcXHJcXG5cXHRnbG9iYWwgZG91YmxlKiBvdXQpXFxyXFxue1xcclxcblxcdGNvbnN0IHVpbnQgaSA9IGdldF9nbG9iYWxfaWQoMCk7XFxyXFxuXFx0Y29uc3QgdWludCBrID0gZ2V0X2dsb2JhbF9pZCgxKTtcXHJcXG5cXHRjb25zdCB1aW50IGwgPSBnZXRfZ2xvYmFsX2lkKDIpO1xcclxcblxcdGNvbnN0IHVpbnQgb3V0ZXJTdHJpZGVCID0gZ2V0X2dsb2JhbF9zaXplKDEpO1xcclxcblxcdGNvbnN0IHVpbnQgaW5uZXJTdHJpZGVCID0gZ2V0X2dsb2JhbF9zaXplKDIpO1xcclxcblxcclxcblxcdGRvdWJsZSBhY2N1bXVsYXRvciA9IDAuMDtcXHJcXG5cXHRmb3IgKHVpbnQgaiA9IDA7IGogPCByZWR1Y3Rpb25EaW07ICsraikge1xcclxcblxcdFxcdGFjY3VtdWxhdG9yICs9IGFbaSpyZWR1Y3Rpb25EaW0ral0gKiBiWyhrKnJlZHVjdGlvbkRpbStqKSppbm5lclN0cmlkZUIrbF07XFxyXFxuXFx0fVxcclxcblxcdG91dFsoaSpvdXRlclN0cmlkZUIgKyBrKSAqIGlubmVyU3RyaWRlQiArIGxdID0gYWNjdW11bGF0b3I7XFxyXFxufVxcclxcblwiO1xyXG5cdHZhciB1dGlsS2VybmVsc1NvdXJjZSA9IFwia2VybmVsIHZvaWQgc2V0X2YzMihcXHJcXG5cXHR1aW50IGxlbmd0aCxcXHJcXG5cXHRnbG9iYWwgZmxvYXQqIG91dCxcXHJcXG5cXHRmbG9hdCB2YWx1ZSlcXHJcXG57XFxyXFxuXFx0Y29uc3QgdWludCBpZCA9IGdldF9nbG9iYWxfaWQoMCk7XFxyXFxuXFx0aWYgKGlkIDwgbGVuZ3RoKSB7XFxyXFxuXFx0XFx0b3V0W2lkXSA9IHZhbHVlO1xcclxcblxcdH1cXHJcXG59XFxyXFxua2VybmVsIHZvaWQgc2V0X2Y2NChcXHJcXG5cXHR1aW50IGxlbmd0aCxcXHJcXG5cXHRnbG9iYWwgZG91YmxlKiBvdXQsXFxyXFxuXFx0ZG91YmxlIHZhbHVlKVxcclxcbntcXHJcXG5cXHRjb25zdCB1aW50IGlkID0gZ2V0X2dsb2JhbF9pZCgwKTtcXHJcXG5cXHRpZiAoaWQgPCBsZW5ndGgpIHtcXHJcXG5cXHRcXHRvdXRbaWRdID0gdmFsdWU7XFxyXFxuXFx0fVxcclxcbn1cXHJcXG5cXHJcXG5rZXJuZWwgdm9pZCBsaW5zcGFjZV9mMzIoXFxyXFxuXFx0dWludCBsZW5ndGgsXFxyXFxuXFx0Z2xvYmFsIGZsb2F0KiBvdXQsXFxyXFxuXFx0ZmxvYXQgc3RhcnQsXFxyXFxuXFx0ZmxvYXQgc3RlcClcXHJcXG57XFxyXFxuXFx0Y29uc3QgdWludCBpZCA9IGdldF9nbG9iYWxfaWQoMCk7XFxyXFxuXFx0aWYgKGlkIDwgbGVuZ3RoKSB7XFxyXFxuXFx0XFx0b3V0W2lkXSA9IHN0YXJ0ICsgc3RlcCAqICgoZmxvYXQpIGlkKTtcXHJcXG5cXHR9XFxyXFxufVxcclxcbmtlcm5lbCB2b2lkIGxpbnNwYWNlX2Y2NChcXHJcXG5cXHR1aW50IGxlbmd0aCxcXHJcXG5cXHRnbG9iYWwgZG91YmxlKiBvdXQsXFxyXFxuXFx0ZG91YmxlIHN0YXJ0LFxcclxcblxcdGRvdWJsZSBzdGVwKVxcclxcbntcXHJcXG5cXHRjb25zdCB1aW50IGlkID0gZ2V0X2dsb2JhbF9pZCgwKTtcXHJcXG5cXHRpZiAoaWQgPCBsZW5ndGgpIHtcXHJcXG5cXHRcXHRvdXRbaWRdID0gc3RhcnQgKyBzdGVwICogKChkb3VibGUpIGlkKTtcXHJcXG5cXHR9XFxyXFxufVxcclxcblxcclxcbmtlcm5lbCB2b2lkIHJlcGVhdF9mMzIoXFxyXFxuXFx0dWludCBleHBhbnNpb25EaW0sXFxyXFxuXFx0dWludCBpbm5lclN0cmlkZSxcXHJcXG5cXHR1aW50IHJlcGVhdHMsXFxyXFxuXFx0Z2xvYmFsIGZsb2F0ICpyZXN0cmljdCBhLFxcclxcblxcdGdsb2JhbCBmbG9hdCAqcmVzdHJpY3Qgb3V0KVxcclxcbntcXHJcXG5cXHRjb25zdCB1aW50IGkgPSBnZXRfZ2xvYmFsX2lkKDApO1xcclxcblxcdGNvbnN0IHVpbnQgaiA9IGdldF9nbG9iYWxfaWQoMSk7XFxyXFxuXFx0Y29uc3QgdWludCBrID0gZ2V0X2dsb2JhbF9pZCgyKTtcXHJcXG5cXHRjb25zdCBmbG9hdCB2YWx1ZSA9IGFbKGkgKiBleHBhbnNpb25EaW0gKyBqKSAqIGlubmVyU3RyaWRlICsga107XFxyXFxuXFx0dWludCBvZmZzZXRPdXQgPSAoaSAqIGV4cGFuc2lvbkRpbSArIGopICogcmVwZWF0cyAqIGlubmVyU3RyaWRlICsgaztcXHJcXG5cXHRmb3IgKHVpbnQgYyA9IDA7IGMgPCByZXBlYXRzOyArK2MpIHtcXHJcXG5cXHRcXHRvdXRbb2Zmc2V0T3V0XSA9IHZhbHVlO1xcclxcblxcdFxcdG9mZnNldE91dCArPSBpbm5lclN0cmlkZTtcXHJcXG5cXHR9XFxyXFxufVxcclxcbmtlcm5lbCB2b2lkIHJlcGVhdF9mNjQoXFxyXFxuXFx0dWludCBleHBhbnNpb25EaW0sXFxyXFxuXFx0dWludCBpbm5lclN0cmlkZSxcXHJcXG5cXHR1aW50IHJlcGVhdHMsXFxyXFxuXFx0Z2xvYmFsIGRvdWJsZSAqcmVzdHJpY3QgYSxcXHJcXG5cXHRnbG9iYWwgZG91YmxlICpyZXN0cmljdCBvdXQpXFxyXFxue1xcclxcblxcdGNvbnN0IHVpbnQgaSA9IGdldF9nbG9iYWxfaWQoMCk7XFxyXFxuXFx0Y29uc3QgdWludCBqID0gZ2V0X2dsb2JhbF9pZCgxKTtcXHJcXG5cXHRjb25zdCB1aW50IGsgPSBnZXRfZ2xvYmFsX2lkKDIpO1xcclxcblxcdGNvbnN0IGRvdWJsZSB2YWx1ZSA9IGFbKGkgKiBleHBhbnNpb25EaW0gKyBqKSAqIGlubmVyU3RyaWRlICsga107XFxyXFxuXFx0dWludCBvZmZzZXRPdXQgPSAoaSAqIGV4cGFuc2lvbkRpbSArIGopICogcmVwZWF0cyAqIGlubmVyU3RyaWRlICsgaztcXHJcXG5cXHRmb3IgKHVpbnQgYyA9IDA7IGMgPCByZXBlYXRzOyArK2MpIHtcXHJcXG5cXHRcXHRvdXRbb2Zmc2V0T3V0XSA9IHZhbHVlO1xcclxcblxcdFxcdG9mZnNldE91dCArPSBpbm5lclN0cmlkZTtcXHJcXG5cXHR9XFxyXFxufVxcclxcblwiO1xyXG5cdHZhciBzb3VyY2UgPSBiaW5hcnlLZXJuZWxzU291cmNlICsgdW5hcnlLZXJuZWxzU291cmNlICsgXHJcblx0XHRyZWR1Y3Rpb25LZXJuZWxzU291cmNlICsgYXhpc1JlZHVjdGlvbktlcm5lbHNTb3VyY2UgKyBcclxuXHRcdHByb2R1Y3RLZXJuZWxzU291cmNlICsgdXRpbEtlcm5lbHNTb3VyY2U7XHJcblxyXG5cdHZhciBhc3luY0NhbGxiYWNrcyA9IG9wdGlvbnMuYXN5bmNDYWxsYmFja3M7XHJcblx0aWYgKHR5cGVvZiBhc3luY0NhbGxiYWNrcyA9PT0gXCJ1bmRlZmluZWRcIikge1xyXG5cdFx0LyogQ3VycmVudGx5IG9ubHkgTm9kZS1XZWJDTCBzdXBwb3J0cyBhc3luY2hyb25vdXMgY2FsbGJhY2tzICovXHJcblx0XHR0aGlzLmFzeW5jQ2FsbGJhY2tzID0gaXNOb2RlV2ViQ0w7XHJcblx0fSBlbHNlIHtcclxuXHRcdHRoaXMuYXN5bmNDYWxsYmFja3MgPSAhIWFzeW5jQ2FsbGJhY2tzO1xyXG5cdH1cclxuXHR2YXIgZGV2aWNlTmFtZSA9IG9wdGlvbnMuZGV2aWNlO1xyXG5cdGlmIChkZXZpY2VOYW1lKSB7XHJcblx0XHR2YXIgZGV2aWNlSW5kZXggPSBhdmFpbGFibGVEZXZpY2VzRGVzY3JpcHRpb25zLmluZGV4T2YoZGV2aWNlTmFtZSk7XHJcblx0XHRpZiAoZGV2aWNlSW5kZXggPT09IC0xKSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgV2ViQ0wgZGV2aWNlIG5hbWU6IFwiICsgZGV2aWNlTmFtZSk7XHJcblx0XHR9XHJcblx0XHR0aGlzLmRldmljZSA9IGF2YWlsYWJsZURldmljZXNbZGV2aWNlSW5kZXhdO1xyXG5cdH0gZWxzZSB7XHJcblx0XHR2YXIgZGV2aWNlSW5kZXggPSBnZXREZWZhdWx0RGV2aWNlSW5kZXgoKTtcclxuXHRcdGlmIChkZXZpY2VJbmRleCA8IDApIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiTm8gc3VpdGFibGUgV2ViQ0wgZGV2aWNlIGZvdW5kXCIpO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5kZXZpY2UgPSBhdmFpbGFibGVEZXZpY2VzW2RldmljZUluZGV4XTtcclxuXHR9XHJcblx0dGhpcy5kZXZpY2UuZW5hYmxlRXh0ZW5zaW9uKFwiS0hSX2ZwNjRcIik7XHJcblx0dGhpcy5kZXZpY2VJbmZvID0ge1xyXG5cdFx0ZGV2aWNlQ2xhc3M6IGNsYXNzaWZ5RGV2aWNlKHRoaXMuZGV2aWNlKSxcclxuXHRcdGxvY2FsTWVtb3J5U2l6ZTogdGhpcy5kZXZpY2UuZ2V0SW5mbyhjbC5ERVZJQ0VfTE9DQUxfTUVNX1NJWkUpLFxyXG5cdFx0bWF4Q29tcHV0ZVVuaXRzOiB0aGlzLmRldmljZS5nZXRJbmZvKGNsLkRFVklDRV9NQVhfQ09NUFVURV9VTklUUyksXHJcblx0XHRtYXhXb3JrR3JvdXBTaXplOiB0aGlzLmRldmljZS5nZXRJbmZvKGNsLkRFVklDRV9NQVhfV09SS19HUk9VUF9TSVpFKSxcclxuXHRcdG1heFdvcmtJdGVtU2l6ZXM6IHRoaXMuZGV2aWNlLmdldEluZm8oY2wuREVWSUNFX01BWF9XT1JLX0lURU1fU0laRVMpXHJcblx0fTtcclxuXHR0aGlzLmNvbnRleHQgPSBjbC5jcmVhdGVDb250ZXh0KHRoaXMuZGV2aWNlKTtcclxuXHR0aGlzLnF1ZXVlID0gdGhpcy5jb250ZXh0LmNyZWF0ZUNvbW1hbmRRdWV1ZSh0aGlzLmRldmljZSk7XHJcblx0dGhpcy5wcm9ncmFtID0gdGhpcy5jb250ZXh0LmNyZWF0ZVByb2dyYW0oc291cmNlKTtcclxuXHR0cnkge1xyXG5cdFx0LyogQ2hyb21pdW0tV2ViQ0wgcmVxdWlyZXMgYSBsaXN0IG9mIGRldmljZXMgKi9cclxuXHRcdHRoaXMucHJvZ3JhbS5idWlsZChbdGhpcy5kZXZpY2VdKTtcclxuXHR9IGNhdGNoIChlKSB7XHJcblx0XHRpZiAoZS5uYW1lID09PSBcIklOVkFMSURfREVWSUNFXCIpIHtcclxuXHRcdFx0LyogTm9raWEtV2ViQ0wgb25seSB3b3JrcyB3aXRoIG5vIGFyZ3VtZW50cyB0byBXZWJDTFByb2dyYW0uYnVpbGQgKi9cclxuXHRcdFx0dGhpcy5wcm9ncmFtLmJ1aWxkKCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aHJvdyBlO1xyXG5cdFx0fVxyXG5cdH1cclxuXHR0aGlzLmtlcm5lbHMgPSBjcmVhdGVLZXJuZWxzKHRoaXMucHJvZ3JhbSk7XHJcblx0LyogQ29udGV4dCBpcyByZWFkeSBmb3IgY29tcHV0YXRpb25zICovXHJcblx0Y2FsbGJhY2sodGhpcyk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBuYW1lcyBvZiBkZXZpY2VzIHRoYXQgY2FuIGJlIHVzZWQgZm9yIGNvbXB1dGF0aW9uLlxyXG4gKiBBbnkgb2YgdGhlc2UgbmFtZXMgY2FuIGJlIHBhc3NlZCBhcyBhIFwiZGV2aWNlXCIgb3B0aW9uIHdoZW4gY3JlYXRpbmcgYSBXZWJDTCBjb250ZXh0LlxyXG4gKlxyXG4gKiBAc3RhdGljXHJcbiAqIEBtZXRob2QgZ2V0QXZhaWxhYmxlRGV2aWNlc1xyXG4gKiBAcmV0dXJuIHtTdHJpbmdbXX0gLSBhIHBvc3NpYmx5IGVtcHR5IGxpc3Qgb2YgYXZhaWxhYmxlIGRldmljZSBuYW1lcy5cclxuICovXHJcbldlYkNMQ29udGV4dC5nZXRBdmFpbGFibGVEZXZpY2VzID0gZnVuY3Rpb24oKSB7XHJcblx0aWYgKFdlYkNMQ29udGV4dC5pc1VzYWJsZSgpKSB7XHJcblx0XHRyZXR1cm4gYXZhaWxhYmxlRGV2aWNlc0Rlc2NyaXB0aW9ucztcclxuXHR9IGVsc2Uge1xyXG5cdFx0cmV0dXJuIFtdO1xyXG5cdH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBuYW1lIG9mIHRoZSBkZWZhdWx0IGRldmljZSB1c2VkIGZvciBjb21wdXRhdGlvbi5cclxuICpcclxuICogQHN0YXRpY1xyXG4gKiBAbWV0aG9kIGdldERlZmF1bHREZXZpY2VcclxuICogQHJldHVybiB7U3RyaW5nfSAtIHRoZSBuYW1lIG9mIHRoZSBkZWZhdWx0IFdlYkNMIGRldmljZSBvciBudWxsIGlmIG5vIHN1aXRhYmxlIGRldmljZSBhdmFpbGFibGUuXHJcbiAqL1xyXG5XZWJDTENvbnRleHQuZ2V0RGVmYXVsdERldmljZSA9IGZ1bmN0aW9uKCkge1xyXG5cdHZhciBkZXZpY2VJbmRleCA9IGdldERlZmF1bHREZXZpY2VJbmRleCgpO1xyXG5cdGlmIChkZXZpY2VJbmRleCA8IDApIHtcclxuXHRcdHJldHVybiBudWxsO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRyZXR1cm4gYXZhaWxhYmxlRGV2aWNlc0Rlc2NyaXB0aW9uc1tkZXZpY2VJbmRleF07XHJcblx0fVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIENoZWNrcyBpZiBXZWJDTCBpcyBzdXBwb3J0ZWQgYnkgdGhlIGVudmlyb25tZW50LlxyXG4gKlxyXG4gKiBAc3RhdGljXHJcbiAqIEBtZXRob2QgaXNTdXBwb3J0ZWRcclxuICogQHJldHVybiB7Qm9vbGVhbn0gLSB0cnVlIGlmIFdlYkNMIGlzIHN1cHBvcnRlZCBvbiB0aGlzIHN5c3RlbSBhbmQgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gKi9cclxuV2ViQ0xDb250ZXh0LmlzU3VwcG9ydGVkID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIGluaXRXZWJDTCgpICE9PSBudWxsO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENoZWNrcyBpZiBXZWJDTCBjYW4gYmUgdXNlZCBmb3IgY29tcHV0YXRpb24uXHJcbiAqIFdlYkNMIGlzIHVzYWJsZSBmb3IgY29tcHV0YXRpb25zIGlmIGl0IGlzIHN1cHBvcnRlZCBieSBKUyBlbmdpbmUgKG9yIE5vZGUuanMpIGFuZCB0aGVyZSBpcyBhdCBsZWFzdCBvbmUgQ1BVIG9yIEdQVSBkZXZpY2Ugd2l0aCBLSFJfZnA2NCBleHRlbnNpb24uXHJcbiAqXHJcbiAqIEBzdGF0aWNcclxuICogQG1ldGhvZCBpc1VzYWJsZVxyXG4gKiBAcmV0dXJuIHtCb29sZWFufSAtIHRydWUgaWYgV2ViQ0wgaXMgdXNhYmxlIG9uIHRoaXMgc3lzdGVtIGFuZCBmYWxzZSBvdGhlcndpc2UuXHJcbiAqL1xyXG5XZWJDTENvbnRleHQuaXNVc2FibGUgPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgd2ViY2wgPSBpbml0V2ViQ0woKTtcclxuXHRpZiAod2ViY2wgPT09IG51bGwpIHtcclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHR9XHJcblx0dmFyIGF2YWlsYWJsZURldmljZXMgPSBnZXRBdmFpbGFibGVEZXZpY2VzKCk7XHJcblx0cmV0dXJuIGF2YWlsYWJsZURldmljZXMubGVuZ3RoICE9PSAwO1xyXG59O1xyXG5cclxuV2ViQ0xDb250ZXh0LnByb3RvdHlwZS5lbXB0eSA9IGZ1bmN0aW9uKHNoYXBlLCBkYXRhVHlwZSkge1xyXG5cdHNoYXBlID0gdXRpbC5jaGVja1NoYXBlKHNoYXBlKTtcclxuXHRpZiAodHlwZW9mIGRhdGFUeXBlID09PSBcInVuZGVmaW5lZFwiKSB7XHJcblx0XHRkYXRhVHlwZSA9IG5ldyBEYXRhVHlwZShcImY2NFwiKTtcclxuXHR9IGVsc2UgaWYgKCEoZGF0YVR5cGUgaW5zdGFuY2VvZiBEYXRhVHlwZSkpIHtcclxuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoZGF0YVR5cGUgKyBcIiBpcyBub3QgYW4gaW5zdGFuY2Ugb2YgRGF0YVR5cGVcIik7XHJcblx0fVxyXG5cdHZhciBhcnJheSA9IG5ldyBOREFycmF5KHNoYXBlLCBkYXRhVHlwZSwgdGhpcyk7XHJcblx0YXJyYXkuX2J1ZmZlciA9IHRoaXMuY29udGV4dC5jcmVhdGVCdWZmZXIoY2wuTUVNX1JFQURfV1JJVEUsIGFycmF5Lmxlbmd0aCAqIGRhdGFUeXBlLnNpemUpO1xyXG5cdHJldHVybiBhcnJheTtcclxufTtcclxuXHJcbldlYkNMQ29udGV4dC5wcm90b3R5cGUuemVyb3MgPSBmdW5jdGlvbihzaGFwZSwgZGF0YVR5cGUpIHtcclxuXHRzaGFwZSA9IHV0aWwuY2hlY2tTaGFwZShzaGFwZSk7XHJcblx0aWYgKHR5cGVvZiBkYXRhVHlwZSA9PT0gXCJ1bmRlZmluZWRcIikge1xyXG5cdFx0ZGF0YVR5cGUgPSBuZXcgRGF0YVR5cGUoXCJmNjRcIik7XHJcblx0fSBlbHNlIGlmICghKGRhdGFUeXBlIGluc3RhbmNlb2YgRGF0YVR5cGUpKSB7XHJcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKGRhdGFUeXBlICsgXCIgaXMgbm90IGFuIGluc3RhbmNlIG9mIERhdGFUeXBlXCIpO1xyXG5cdH1cclxuXHR2YXIgYXJyYXkgPSBuZXcgTkRBcnJheShzaGFwZSwgZGF0YVR5cGUsIHRoaXMpO1xyXG5cdGFycmF5Ll9idWZmZXIgPSB0aGlzLmNvbnRleHQuY3JlYXRlQnVmZmVyKGNsLk1FTV9SRUFEX1dSSVRFLCBhcnJheS5sZW5ndGggKiBkYXRhVHlwZS5zaXplKTtcclxuXHR2YXIga2VybmVsID0gdGhpcy5rZXJuZWxzLnNldFtkYXRhVHlwZS50eXBlXTtcclxuXHRrZXJuZWwuc2V0QXJnKDAsIG5ldyBVaW50MzJBcnJheShbYXJyYXkubGVuZ3RoXSkpO1xyXG5cdGtlcm5lbC5zZXRBcmcoMSwgYXJyYXkuX2J1ZmZlcik7XHJcblx0a2VybmVsLnNldEFyZygyLCBuZXcgZGF0YVR5cGUuYXJyYXlUeXBlKFswLjBdKSk7XHJcblx0dGhpcy5xdWV1ZS5lbnF1ZXVlTkRSYW5nZUtlcm5lbChrZXJuZWwsIDEsIG51bGwsIFthcnJheS5sZW5ndGhdKTtcclxuXHRyZXR1cm4gYXJyYXk7XHJcbn07XHJcblxyXG5XZWJDTENvbnRleHQucHJvdG90eXBlLm9uZXMgPSBmdW5jdGlvbihzaGFwZSwgZGF0YVR5cGUpIHtcclxuXHRzaGFwZSA9IHV0aWwuY2hlY2tTaGFwZShzaGFwZSk7XHJcblx0aWYgKHR5cGVvZiBkYXRhVHlwZSA9PT0gXCJ1bmRlZmluZWRcIikge1xyXG5cdFx0ZGF0YVR5cGUgPSBuZXcgRGF0YVR5cGUoXCJmNjRcIik7XHJcblx0fSBlbHNlIGlmICghKGRhdGFUeXBlIGluc3RhbmNlb2YgRGF0YVR5cGUpKSB7XHJcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKGRhdGFUeXBlICsgXCIgaXMgbm90IGFuIGluc3RhbmNlIG9mIERhdGFUeXBlXCIpO1xyXG5cdH1cclxuXHR2YXIgYXJyYXkgPSBuZXcgTkRBcnJheShzaGFwZSwgZGF0YVR5cGUsIHRoaXMpO1xyXG5cdGFycmF5Ll9idWZmZXIgPSB0aGlzLmNvbnRleHQuY3JlYXRlQnVmZmVyKGNsLk1FTV9SRUFEX1dSSVRFLCBhcnJheS5sZW5ndGggKiBkYXRhVHlwZS5zaXplKTtcclxuXHR2YXIga2VybmVsID0gdGhpcy5rZXJuZWxzLnNldFtkYXRhVHlwZS50eXBlXTtcclxuXHRrZXJuZWwuc2V0QXJnKDAsIG5ldyBVaW50MzJBcnJheShbYXJyYXkubGVuZ3RoXSkpO1xyXG5cdGtlcm5lbC5zZXRBcmcoMSwgYXJyYXkuX2J1ZmZlcik7XHJcblx0a2VybmVsLnNldEFyZygyLCBuZXcgZGF0YVR5cGUuYXJyYXlUeXBlKFsxLjBdKSk7XHJcblx0dGhpcy5xdWV1ZS5lbnF1ZXVlTkRSYW5nZUtlcm5lbChrZXJuZWwsIDEsIG51bGwsIFthcnJheS5sZW5ndGhdKTtcclxuXHRyZXR1cm4gYXJyYXk7XHJcbn07XHJcblxyXG5XZWJDTENvbnRleHQucHJvdG90eXBlLmFycmF5ID0gZnVuY3Rpb24oZGF0YSwgZGF0YVR5cGUpIHtcclxuXHRpZiAodHlwZW9mIGRhdGFUeXBlID09PSBcInVuZGVmaW5lZFwiKSB7XHJcblx0XHRkYXRhVHlwZSA9IG5ldyBEYXRhVHlwZShcImY2NFwiKTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0ZGF0YVR5cGUgPSB1dGlsLmNoZWNrRGF0YVR5cGUoZGF0YVR5cGUpO1xyXG5cdH1cclxuXHR2YXIgc2hhcGUgPSBbXTtcclxuXHR1dGlsLmRpc2NvdmVyQXJyYXlTaGFwZVJlY3Vyc2l2ZShkYXRhLCBzaGFwZSwgMCk7XHJcblx0dmFyIGFycmF5ID0gbmV3IE5EQXJyYXkoc2hhcGUsIGRhdGFUeXBlLCB0aGlzKTtcclxuXHR2YXIgYnVmZmVyID0gbmV3IGRhdGFUeXBlLmFycmF5VHlwZShhcnJheS5sZW5ndGgpO1xyXG5cdHV0aWwuY29weUFycmF5RGF0YVJlY3Vyc2l2ZShidWZmZXIsIGRhdGEsIHNoYXBlLCAwLCAwKTtcclxuXHRpZiAodXNlQnVmZmVyQ3JlYXRpb25XaXRoSW5pdCkge1xyXG5cdFx0YXJyYXkuX2J1ZmZlciA9IHRoaXMuY29udGV4dC5jcmVhdGVCdWZmZXIoY2wuTUVNX1JFQURfV1JJVEUsIGJ1ZmZlci5ieXRlTGVuZ3RoLCBidWZmZXIpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRhcnJheS5fYnVmZmVyID0gdGhpcy5jb250ZXh0LmNyZWF0ZUJ1ZmZlcihjbC5NRU1fUkVBRF9XUklURSwgYnVmZmVyLmJ5dGVMZW5ndGgpO1xyXG5cdFx0dGhpcy5xdWV1ZS5lbnF1ZXVlV3JpdGVCdWZmZXIoYXJyYXkuX2J1ZmZlciwgZmFsc2UsIDAsIGJ1ZmZlci5ieXRlTGVuZ3RoLCBidWZmZXIpO1xyXG5cdH1cclxuXHRyZXR1cm4gYXJyYXk7XHJcbn07XHJcblxyXG5XZWJDTENvbnRleHQucHJvdG90eXBlLmxpbnNwYWNlID0gZnVuY3Rpb24oc3RhcnQsIHN0b3AsIHNhbXBsZXMsIGNsb3NlZCkge1xyXG5cdGlmICghdXRpbC5pc1JlYWwoc3RhcnQpKSB7XHJcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKHN0YXJ0ICsgXCIgaXMgbm90IGEgcmVhbCBudW1iZXJcIik7XHJcblx0fVxyXG5cdGlmICghdXRpbC5pc1JlYWwoc3RvcCkpIHtcclxuXHRcdHRocm93IG5ldyBUeXBlRXJyb3Ioc3RvcCArIFwiIGlzIG5vdCBhIHJlYWwgbnVtYmVyXCIpO1xyXG5cdH1cclxuXHRpZiAodHlwZW9mIHNhbXBsZXMgPT09IFwidW5kZWZpbmVkXCIpIHtcclxuXHRcdC8qIERlZmF1bHQgdmFsdWUgaW4gTnVtUHkgKi9cclxuXHRcdHNhbXBsZXMgPSA1MDtcclxuXHR9IGVsc2UgaWYgKCF1dGlsLmlzSW50KHNhbXBsZXMpKSB7XHJcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKHNhbXBsZXMgKyBcIiBpcyBub3QgYW4gaW50ZWdlclwiKTtcclxuXHR9IGVsc2UgaWYgKHNhbXBsZXMgPD0gMCkge1xyXG5cdFx0dGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUaGUgbnVtYmVyIG9mIHNhbXBsZXMgbXVzdCBiZSBwb3NpdGl2ZVwiKTtcclxuXHR9XHJcblx0aWYgKHR5cGVvZiBjbG9zZWQgPT09IFwidW5kZWZpbmVkXCIpIHtcclxuXHRcdGNsb3NlZCA9IHRydWU7XHJcblx0fVxyXG5cdGlmIChjbG9zZWQgJiYgKHNhbXBsZXMgPT09IDEpKSB7XHJcblx0XHR0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlRoZSBudW1iZXIgb2Ygc2FtcGxlcyBtdXN0IGJlIGEgbGVhc3QgMiAoZm9yIHN0YXJ0IGFuZCBlbmQgcG9pbnRzKVwiKTtcclxuXHR9XHJcblxyXG5cdHZhciBkYXRhVHlwZSA9IG5ldyBEYXRhVHlwZShcImY2NFwiKTtcclxuXHR2YXIgYXJyYXkgPSBuZXcgTkRBcnJheShzYW1wbGVzLCBkYXRhVHlwZSwgdGhpcyk7XHJcblx0YXJyYXkuX2J1ZmZlciA9IHRoaXMuY29udGV4dC5jcmVhdGVCdWZmZXIoY2wuTUVNX1JFQURfV1JJVEUsIHNhbXBsZXMgKiBkYXRhVHlwZS5zaXplKTtcclxuXHJcblx0dmFyIHJhbmdlID0gc3RvcCAtIHN0YXJ0O1xyXG5cdHZhciBuID0gKGNsb3NlZCkgPyBzYW1wbGVzIC0gMSA6IHNhbXBsZXM7XHJcblx0dmFyIHN0ZXAgPSByYW5nZSAvIG47XHJcblxyXG5cdHZhciBrZXJuZWwgPSB0aGlzLmtlcm5lbHMubGluc3BhY2VbZGF0YVR5cGUudHlwZV07XHJcblx0a2VybmVsLnNldEFyZygwLCBuZXcgVWludDMyQXJyYXkoW2FycmF5Lmxlbmd0aF0pKTtcclxuXHRrZXJuZWwuc2V0QXJnKDEsIGFycmF5Ll9idWZmZXIpO1xyXG5cdGtlcm5lbC5zZXRBcmcoMiwgbmV3IGRhdGFUeXBlLmFycmF5VHlwZShbc3RhcnRdKSk7XHJcblx0a2VybmVsLnNldEFyZygzLCBuZXcgZGF0YVR5cGUuYXJyYXlUeXBlKFtzdGVwXSkpO1xyXG5cdHRoaXMucXVldWUuZW5xdWV1ZU5EUmFuZ2VLZXJuZWwoa2VybmVsLCAxLCBudWxsLCBbYXJyYXkubGVuZ3RoXSk7XHJcblxyXG5cdHJldHVybiBhcnJheTtcclxufTtcclxuXHJcbldlYkNMQ29udGV4dC5wcm90b3R5cGUuX2ludmFsaWRhdGUgPSBmdW5jdGlvbihhcnJheSkge1xyXG5cdGlmIChhcnJheS5fYnVmZmVyICE9PSBudWxsKSB7XHJcblx0XHQvKiBXb3JrLWFyb3VuZCBmb3IgQ2hyb21pdW0tV2ViQ0wgdGhhdCBjdXJyZW50bHkgbGFja3MgV2ViQ0xNZW1PYmplY3QucmVsZWFzZSBtZXRob2QgKi9cclxuXHRcdGlmICh0eXBlb2YgYXJyYXkuX2J1ZmZlci5yZWxlYXNlICE9PSBcInVuZGVmaW5lZFwiKSB7XHJcblx0XHRcdGFycmF5Ll9idWZmZXIucmVsZWFzZSgpO1xyXG5cdFx0fVxyXG5cdFx0YXJyYXkuX2J1ZmZlciA9IG51bGw7XHJcblx0fVxyXG59O1xyXG5cclxuV2ViQ0xDb250ZXh0LnByb3RvdHlwZS5mZXRjaCA9IGZ1bmN0aW9uKCkge1xyXG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJDYWxsYmFjayBhcmd1bWVudCBtaXNzaW5nXCIpO1xyXG5cdH1cclxuXHR2YXIgY2FsbGJhY2sgPSBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aCAtIDFdO1xyXG5cdC8qIFZhbGlkYXRlIGFyZ3VtZW50cyAqL1xyXG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJBdCBsZWFzdCBvbmUgTkRBcnJheSBhcmd1bWVudCBleHBlY3RlZFwiKTtcclxuXHR9XHJcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoIC0gMTsgaSsrKSB7XHJcblx0XHRpZiAoIShhcmd1bWVudHNbaV0gaW5zdGFuY2VvZiBOREFycmF5KSkge1xyXG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKFwiQXJndW1lbnQgXCIgKyBpICsgXCIgaXMgbm90IGFuIE5EQXJyYXlcIik7XHJcblx0XHR9XHJcblx0fVxyXG5cdHZhciBjYWxsYmFja1dhaXRBcmd1bWVudHMgPSBhcmd1bWVudHMubGVuZ3RoIC0gMTtcclxuXHR2YXIgY2FsbGJhY2tBcmd1bWVudHMgPSBuZXcgQXJyYXkoY2FsbGJhY2tXYWl0QXJndW1lbnRzKTtcclxuXHRpZiAodGhpcy5hc3luY0NhbGxiYWNrcykge1xyXG5cdFx0dmFyIGFzeW5jRXZlbnRzID0gW107XHJcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGNhbGxiYWNrV2FpdEFyZ3VtZW50czsgaSsrKSB7XHJcblx0XHRcdHZhciBhcnJheSA9IGFyZ3VtZW50c1tpXTtcclxuXHRcdFx0KGZ1bmN0aW9uKHF1ZXVlLCBpLCBzaGFwZSwgQXJyYXlUeXBlKSB7XHJcblx0XHRcdFx0dmFyIGJ1ZmZlciA9IG5ldyBBcnJheVR5cGUoYXJyYXkubGVuZ3RoKTtcclxuXHRcdFx0XHR2YXIgcmVhZEZpbmlzaEV2ZW50ID0gY3JlYXRlRXZlbnQoKTtcclxuXHRcdFx0XHRhc3luY0V2ZW50cy5wdXNoKHJlYWRGaW5pc2hFdmVudCk7XHJcblx0XHRcdFx0cXVldWUuZW5xdWV1ZVJlYWRCdWZmZXIoYXJyYXkuX2J1ZmZlciwgZmFsc2UsIDAsIGJ1ZmZlci5ieXRlTGVuZ3RoLCBidWZmZXIsIG51bGwsIHJlYWRGaW5pc2hFdmVudCk7XHJcblx0XHRcdFx0cmVhZEZpbmlzaEV2ZW50LnNldENhbGxiYWNrKGNsLkNPTVBMRVRFLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRcdHJlYWRGaW5pc2hFdmVudC5yZWxlYXNlKCk7XHJcblx0XHRcdFx0XHRjYWxsYmFja0FyZ3VtZW50c1tpXSA9IGJ1ZmZlcjtcclxuXHRcdFx0XHRcdGlmICgtLWNhbGxiYWNrV2FpdEFyZ3VtZW50cyA9PT0gMCkge1xyXG5cdFx0XHRcdFx0XHRjYWxsYmFjay5hcHBseShudWxsLCBjYWxsYmFja0FyZ3VtZW50cyk7XHJcblx0XHRcdFx0XHRcdC8qIE9wZW5DTCBzdGFuZGFyZDogY29tbWFuZHMgZW5xdWV1ZWQgaW4gYSBjYWxsYmFjayB3b24ndCBzdGFydCB1bnRpbCBjbEZsdXNoICovXHJcblx0XHRcdFx0XHRcdHF1ZXVlLmZsdXNoKCk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH0pKHRoaXMucXVldWUsIGksIGFycmF5LnNoYXBlLCBhcnJheS5kYXRhVHlwZS5hcnJheVR5cGUpO1xyXG5cdFx0XHQvKiBUaGlzIGxpbmUgbW9zdGx5IHNlcmlhbGl6ZXMgZXhlY3V0aW9uLiBVbmZvcnR1bmF0ZWx5LCB3aXRob3V0IGl0IG5vdGhpbmcgd29ya3MgKi9cclxuXHRcdFx0Y2wud2FpdEZvckV2ZW50cyhhc3luY0V2ZW50cyk7XHJcblx0XHR9XHJcblx0fSBlbHNlIHtcclxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgY2FsbGJhY2tXYWl0QXJndW1lbnRzOyBpKyspIHtcclxuXHRcdFx0dmFyIGFycmF5ID0gYXJndW1lbnRzW2ldO1xyXG5cdFx0XHR2YXIgYnVmZmVyID0gbmV3IGFycmF5LmRhdGFUeXBlLmFycmF5VHlwZShhcnJheS5sZW5ndGgpO1xyXG5cdFx0XHR0aGlzLnF1ZXVlLmVucXVldWVSZWFkQnVmZmVyKGFycmF5Ll9idWZmZXIsIHRydWUsIDAsIGJ1ZmZlci5ieXRlTGVuZ3RoLCBidWZmZXIpO1xyXG5cdFx0XHRjYWxsYmFja0FyZ3VtZW50c1tpXSA9IGJ1ZmZlcjtcclxuXHRcdH1cclxuXHRcdGNhbGxiYWNrLmFwcGx5KG51bGwsIGNhbGxiYWNrQXJndW1lbnRzKTtcclxuXHR9XHJcbn07XHJcblxyXG5XZWJDTENvbnRleHQucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKCkge1xyXG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJDYWxsYmFjayBhcmd1bWVudCBtaXNzaW5nXCIpO1xyXG5cdH1cclxuXHR2YXIgY2FsbGJhY2sgPSBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aCAtIDFdO1xyXG5cdC8qIFZhbGlkYXRlIGFyZ3VtZW50cyAqL1xyXG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJBdCBsZWFzdCBvbmUgTkRBcnJheSBhcmd1bWVudCBleHBlY3RlZFwiKTtcclxuXHR9XHJcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoIC0gMTsgaSsrKSB7XHJcblx0XHRpZiAoIShhcmd1bWVudHNbaV0gaW5zdGFuY2VvZiBOREFycmF5KSkge1xyXG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKFwiQXJndW1lbnQgXCIgKyBpICsgXCIgaXMgbm90IGFuIE5EQXJyYXlcIik7XHJcblx0XHR9XHJcblx0fVxyXG5cdHZhciBjYWxsYmFja1dhaXRBcmd1bWVudHMgPSBhcmd1bWVudHMubGVuZ3RoIC0gMTtcclxuXHR2YXIgY2FsbGJhY2tBcmd1bWVudHMgPSBuZXcgQXJyYXkoY2FsbGJhY2tXYWl0QXJndW1lbnRzKTtcclxuXHRpZiAodGhpcy5hc3luY0NhbGxiYWNrcykge1xyXG5cdFx0dmFyIGFzeW5jRXZlbnRzID0gW107XHJcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGNhbGxiYWNrV2FpdEFyZ3VtZW50czsgaSsrKSB7XHJcblx0XHRcdHZhciBhcnJheSA9IGFyZ3VtZW50c1tpXTtcclxuXHRcdFx0KGZ1bmN0aW9uKHF1ZXVlLCBpLCBzaGFwZSwgQXJyYXlUeXBlKSB7XHJcblx0XHRcdFx0dmFyIGJ1ZmZlciA9IG5ldyBBcnJheVR5cGUoYXJyYXkubGVuZ3RoKTtcclxuXHRcdFx0XHR2YXIgcmVhZEZpbmlzaEV2ZW50ID0gY3JlYXRlRXZlbnQoKTtcclxuXHRcdFx0XHRhc3luY0V2ZW50cy5wdXNoKHJlYWRGaW5pc2hFdmVudCk7XHJcblx0XHRcdFx0cXVldWUuZW5xdWV1ZVJlYWRCdWZmZXIoYXJyYXkuX2J1ZmZlciwgZmFsc2UsIDAsIGJ1ZmZlci5ieXRlTGVuZ3RoLCBidWZmZXIsIG51bGwsIHJlYWRGaW5pc2hFdmVudCk7XHJcblx0XHRcdFx0aWYgKHNoYXBlLmxlbmd0aCA9PT0gMCkge1xyXG5cdFx0XHRcdFx0cmVhZEZpbmlzaEV2ZW50LnNldENhbGxiYWNrKGNsLkNPTVBMRVRFLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRcdFx0cmVhZEZpbmlzaEV2ZW50LnJlbGVhc2UoKTtcclxuXHRcdFx0XHRcdFx0Y2FsbGJhY2tBcmd1bWVudHNbaV0gPSBidWZmZXJbMF07XHJcblx0XHRcdFx0XHRcdGlmICgtLWNhbGxiYWNrV2FpdEFyZ3VtZW50cyA9PT0gMCkge1xyXG5cdFx0XHRcdFx0XHRcdGNhbGxiYWNrLmFwcGx5KG51bGwsIGNhbGxiYWNrQXJndW1lbnRzKTtcclxuXHRcdFx0XHRcdFx0XHQvKiBPcGVuQ0wgc3RhbmRhcmQ6IGNvbW1hbmRzIGVucXVldWVkIGluIGEgY2FsbGJhY2sgd29uJ3Qgc3RhcnQgdW50aWwgY2xGbHVzaCAqL1xyXG5cdFx0XHRcdFx0XHRcdHF1ZXVlLmZsdXNoKCk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRyZWFkRmluaXNoRXZlbnQuc2V0Q2FsbGJhY2soY2wuQ09NUExFVEUsIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0XHRyZWFkRmluaXNoRXZlbnQucmVsZWFzZSgpO1xyXG5cdFx0XHRcdFx0XHR2YXIganNhcnJheSA9IG5ldyBBcnJheShzaGFwZVswXSk7XHJcblx0XHRcdFx0XHRcdHV0aWwuY3JlYXRlQXJyYXlSZWN1cnNpdmUobmV3IEFycmF5VHlwZShidWZmZXIpLCBqc2FycmF5LCBzaGFwZSwgMCwgMCk7XHJcblx0XHRcdFx0XHRcdGNhbGxiYWNrQXJndW1lbnRzW2ldID0ganNhcnJheTtcclxuXHRcdFx0XHRcdFx0aWYgKC0tY2FsbGJhY2tXYWl0QXJndW1lbnRzID09PSAwKSB7XHJcblx0XHRcdFx0XHRcdFx0Y2FsbGJhY2suYXBwbHkobnVsbCwgY2FsbGJhY2tBcmd1bWVudHMpO1xyXG5cdFx0XHRcdFx0XHRcdC8qIE9wZW5DTCBzdGFuZGFyZDogY29tbWFuZHMgZW5xdWV1ZWQgaW4gYSBjYWxsYmFjayB3b24ndCBzdGFydCB1bnRpbCBjbEZsdXNoICovXHJcblx0XHRcdFx0XHRcdFx0cXVldWUuZmx1c2goKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9KSh0aGlzLnF1ZXVlLCBpLCBhcnJheS5zaGFwZSwgYXJyYXkuZGF0YVR5cGUuYXJyYXlUeXBlKTtcclxuXHRcdFx0LyogVGhpcyBsaW5lIG1vc3RseSBzZXJpYWxpemVzIGV4ZWN1dGlvbi4gVW5mb3J0dW5hdGVseSwgd2l0aG91dCBpdCBub3RoaW5nIHdvcmtzICovXHJcblx0XHRcdGNsLndhaXRGb3JFdmVudHMoYXN5bmNFdmVudHMpO1xyXG5cdFx0fVxyXG5cdH0gZWxzZSB7XHJcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGNhbGxiYWNrV2FpdEFyZ3VtZW50czsgaSsrKSB7XHJcblx0XHRcdHZhciBhcnJheSA9IGFyZ3VtZW50c1tpXTtcclxuXHRcdFx0dmFyIGJ1ZmZlciA9IG5ldyBhcnJheS5kYXRhVHlwZS5hcnJheVR5cGUoYXJyYXkubGVuZ3RoKTtcclxuXHRcdFx0dGhpcy5xdWV1ZS5lbnF1ZXVlUmVhZEJ1ZmZlcihhcnJheS5fYnVmZmVyLCB0cnVlLCAwLCBidWZmZXIuYnl0ZUxlbmd0aCwgYnVmZmVyKTtcclxuXHRcdFx0aWYgKGFycmF5LnNoYXBlLmxlbmd0aCA9PT0gMCkge1xyXG5cdFx0XHRcdGNhbGxiYWNrQXJndW1lbnRzW2ldID0gYnVmZmVyWzBdO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHZhciBqc2FycmF5ID0gbmV3IEFycmF5KGFycmF5LnNoYXBlWzBdKTtcclxuXHRcdFx0XHR1dGlsLmNyZWF0ZUFycmF5UmVjdXJzaXZlKG5ldyBhcnJheS5kYXRhVHlwZS5hcnJheVR5cGUoYnVmZmVyKSwganNhcnJheSwgYXJyYXkuc2hhcGUsIDAsIDApO1xyXG5cdFx0XHRcdGNhbGxiYWNrQXJndW1lbnRzW2ldID0ganNhcnJheTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0Y2FsbGJhY2suYXBwbHkobnVsbCwgY2FsbGJhY2tBcmd1bWVudHMpO1xyXG5cdH1cclxufTtcclxuXHJcbldlYkNMQ29udGV4dC5wcm90b3R5cGUuYmFycmllciA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XHJcblx0dmFyIGJhcnJpZXJFdmVudCA9IGNyZWF0ZUV2ZW50KCk7XHJcblx0dGhpcy5xdWV1ZS5lbnF1ZXVlTWFya2VyKGJhcnJpZXJFdmVudCk7XHJcblx0aWYgKHRoaXMuYXN5bmNDYWxsYmFja3MpIHtcclxuXHRcdHZhciBxdWV1ZSA9IHRoaXMucXVldWU7XHJcblx0XHRiYXJyaWVyRXZlbnQuc2V0Q2FsbGJhY2soY2wuQ09NUExFVEUsIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRiYXJyaWVyRXZlbnQucmVsZWFzZSgpO1xyXG5cdFx0XHRjYWxsYmFjaygpO1xyXG5cdFx0XHQvKiBPcGVuQ0wgc3RhbmRhcmQ6IGNvbW1hbmRzIGVucXVldWVkIGluIGEgY2FsbGJhY2sgd29uJ3Qgc3RhcnQgdW50aWwgY2xGbHVzaCAqL1xyXG5cdFx0XHRxdWV1ZS5mbHVzaCgpO1xyXG5cdFx0fSk7XHJcblx0XHRjbC53YWl0Rm9yRXZlbnRzKFtiYXJyaWVyRXZlbnRdKTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0Y2wud2FpdEZvckV2ZW50cyhbYmFycmllckV2ZW50XSk7XHJcblx0XHRjYWxsYmFjaygpO1xyXG5cdH1cclxufTtcclxuXHJcbldlYkNMQ29udGV4dC5wcm90b3R5cGUucmVzaGFwZSA9IGZ1bmN0aW9uKGEsIHNoYXBlKSB7XHJcblx0c2hhcGUgPSB1dGlsLmNoZWNrU2hhcGUoc2hhcGUpO1xyXG5cdGlmICh1dGlsLmNvbXB1dGVMZW5ndGgoc2hhcGUpICE9PSBhLmxlbmd0aCkge1xyXG5cdFx0dGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUaGUgc2hhcGUgaXMgbm90IGNvbXBhdGlibGUgd2l0aCB0aGUgYXJyYXlcIik7XHJcblx0fVxyXG5cdHZhciBvdXQgPSBuZXcgTkRBcnJheShzaGFwZSwgYS5kYXRhVHlwZSwgdGhpcyk7XHJcblx0aWYgKGEuX2RlY1JlZigpKSB7XHJcblx0XHRvdXQuX2J1ZmZlciA9IHRoaXMuY29udGV4dC5jcmVhdGVCdWZmZXIod2ViY2wuTUVNX1JFQURfV1JJVEUsIG91dC5sZW5ndGggKiBvdXQuZGF0YVR5cGUuc2l6ZSk7XHJcblx0XHR0aGlzLnF1ZXVlLmVucXVldWVDb3B5QnVmZmVyKGEuX2J1ZmZlciwgb3V0Ll9idWZmZXIsIDAsIDAsIG91dC5sZW5ndGggKiBvdXQuZGF0YVR5cGUuc2l6ZSk7XHJcblx0fSBlbHNlIHtcclxuXHRcdG91dC5fYnVmZmVyID0gYS5fYnVmZmVyO1xyXG5cdFx0YS5fYnVmZmVyID0gbnVsbDtcclxuXHR9XHJcblx0cmV0dXJuIG91dDtcclxufTtcclxuXHJcbldlYkNMQ29udGV4dC5wcm90b3R5cGUucmVwZWF0ID0gZnVuY3Rpb24oYSwgcmVwZWF0cywgYXhpcywgb3V0KSB7XHJcblx0dXRpbC5jaGVja05EQXJyYXkoYSwgXCJhXCIpO1xyXG5cdHJlcGVhdHMgPSB1dGlsLmNoZWNrUmVwZWF0cyhyZXBlYXRzKTtcclxuXHRheGlzID0gdXRpbC5jaGVja0F4aXMoYXhpcywgYS5zaGFwZS5sZW5ndGgpO1xyXG5cdHZhciBzaGFwZUEgPSBhLnNoYXBlO1xyXG5cdHZhciBzaGFwZU91dCA9IHNoYXBlQS5zbGljZSgwKTtcclxuXHRzaGFwZU91dFtheGlzXSAqPSByZXBlYXRzO1xyXG5cdGEuX2RlY1JlZigpO1xyXG5cdHRyeSB7XHJcblx0XHRpZiAodHlwZW9mIG91dCA9PT0gXCJ1bmRlZmluZWRcIikge1xyXG5cdFx0XHRvdXQgPSBuZXcgTkRBcnJheShzaGFwZU91dCwgYS5kYXRhVHlwZSwgdGhpcyk7XHJcblx0XHRcdG91dC5fYnVmZmVyID0gdGhpcy5jb250ZXh0LmNyZWF0ZUJ1ZmZlcihjbC5NRU1fUkVBRF9XUklURSwgb3V0Lmxlbmd0aCAqIG91dC5kYXRhVHlwZS5zaXplKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHV0aWwuY2hlY2tOREFycmF5KG91dCwgXCJvdXRcIik7XHJcblx0XHRcdHV0aWwuY2hlY2tTaGFwZXNDb21wYXRpYmlsaXR5KG91dC5zaGFwZSwgc2hhcGVPdXQpO1xyXG5cdFx0XHR1dGlsLmNoZWNrRGF0YVR5cGVzQ29tcGF0aWJpbGl0eShhLmRhdGFUeXBlLCBvdXQuZGF0YVR5cGUpO1xyXG5cdFx0XHRvdXQuX2luY1JlZigpO1xyXG5cdFx0fVxyXG5cdFx0dmFyIG91dGVyU3RyaWRlID0gdXRpbC5jb21wdXRlT3V0ZXJTdHJpZGUoc2hhcGVBLCBheGlzKTtcclxuXHRcdHZhciBleHBhbnNpb25EaW0gPSBzaGFwZUFbYXhpc107XHJcblx0XHR2YXIgaW5uZXJTdHJpZGUgPSB1dGlsLmNvbXB1dGVJbm5lclN0cmlkZShzaGFwZUEsIGF4aXMpO1xyXG5cdFx0dmFyIGtlcm5lbCA9IHRoaXMua2VybmVscy5yZXBlYXRbYS5kYXRhVHlwZS50eXBlXTtcclxuXHRcdGtlcm5lbC5zZXRBcmcoMCwgbmV3IFVpbnQzMkFycmF5KFtleHBhbnNpb25EaW1dKSk7XHJcblx0XHRrZXJuZWwuc2V0QXJnKDEsIG5ldyBVaW50MzJBcnJheShbaW5uZXJTdHJpZGVdKSk7XHJcblx0XHRrZXJuZWwuc2V0QXJnKDIsIG5ldyBVaW50MzJBcnJheShbcmVwZWF0c10pKTtcclxuXHRcdGtlcm5lbC5zZXRBcmcoMywgYS5fYnVmZmVyKTtcclxuXHRcdGtlcm5lbC5zZXRBcmcoNCwgb3V0Ll9idWZmZXIpO1xyXG5cdFx0dGhpcy5xdWV1ZS5lbnF1ZXVlTkRSYW5nZUtlcm5lbChrZXJuZWwsIDMsIG51bGwsIFtvdXRlclN0cmlkZSwgZXhwYW5zaW9uRGltLCBpbm5lclN0cmlkZV0pO1xyXG5cdH0gY2F0Y2ggKGUpIHtcclxuXHRcdGEuX2luY1JlZigpO1xyXG5cdFx0dGhyb3cgZTtcclxuXHR9XHJcblx0YS5fdHJ5SW52YWxpZGF0ZSgpO1xyXG5cdHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG52YXIgYmluYXJ5QXJpdGhPcCA9IGZ1bmN0aW9uKGEsIGIsIG91dCwgZnVyaW91c0NvbnRleHQsIGJpbmFyeU9wS2VybmVscywgYmluYXJ5Q29uc3RPcEtlcm5lbHMsIGJpbmFyeVJldkNvbnN0S2VybmVscykge1xyXG5cdHZhciBzaGFwZU91dCA9IG51bGwsIGRhdGFUeXBlT3V0ID0gbnVsbDtcclxuXHR2YXIgYnVmZmVyQSA9IG51bGwsIGJ1ZmZlckIgPSBudWxsO1xyXG5cdGlmIChhIGluc3RhbmNlb2YgTkRBcnJheSkge1xyXG5cdFx0YnVmZmVyQSA9IGEuX2J1ZmZlcjtcclxuXHRcdHNoYXBlT3V0ID0gYS5zaGFwZTtcclxuXHRcdGRhdGFUeXBlT3V0ID0gYS5kYXRhVHlwZTtcclxuXHRcdGlmIChiIGluc3RhbmNlb2YgTkRBcnJheSkge1xyXG5cdFx0XHRidWZmZXJCID0gYi5fYnVmZmVyO1xyXG5cdFx0XHR1dGlsLmNoZWNrU2hhcGVzQ29tcGF0aWJpbGl0eShhLnNoYXBlLCBiLnNoYXBlKTtcclxuXHRcdFx0dXRpbC5jaGVja0RhdGFUeXBlc0NvbXBhdGliaWxpdHkoYS5kYXRhVHlwZSwgYi5kYXRhVHlwZSk7XHJcblx0XHR9IGVsc2UgaWYgKCF1dGlsLmlzTnVtYmVyKGIpKSB7XHJcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoXCJVbnN1cHBvcnRlZCB0eXBlIG9mIGJcIik7XHJcblx0XHR9XHJcblx0fSBlbHNlIGlmICh1dGlsLmlzTnVtYmVyKGEpKSB7XHJcblx0XHR1dGlsLmNoZWNrTkRBcnJheShiLCBcImJcIik7XHJcblx0XHRidWZmZXJCID0gYi5fYnVmZmVyO1xyXG5cdFx0c2hhcGVPdXQgPSBiLnNoYXBlO1xyXG5cdFx0ZGF0YVR5cGVPdXQgPSBiLmRhdGFUeXBlO1xyXG5cdH0gZWxzZSB7XHJcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5zdXBwb3J0ZWQgdHlwZSBvZiBhXCIpO1xyXG5cdH1cclxuXHRpZiAoYSBpbnN0YW5jZW9mIE5EQXJyYXkpIHtcclxuXHRcdGEuX2RlY1JlZigpO1xyXG5cdH1cclxuXHRpZiAoYiBpbnN0YW5jZW9mIE5EQXJyYXkpIHtcclxuXHRcdGIuX2RlY1JlZigpO1xyXG5cdH1cclxuXHR0cnkge1xyXG5cdFx0aWYgKHR5cGVvZiBvdXQgPT09IFwidW5kZWZpbmVkXCIpIHtcclxuXHRcdFx0b3V0ID0gbmV3IE5EQXJyYXkoc2hhcGVPdXQsIGRhdGFUeXBlT3V0LCBmdXJpb3VzQ29udGV4dCk7XHJcblx0XHRcdGlmICgoYSBpbnN0YW5jZW9mIE5EQXJyYXkpICYmICFhLl9oYXNSZWZzKCkpIHtcclxuXHRcdFx0XHRvdXQuX2J1ZmZlciA9IGEuX2J1ZmZlcjtcclxuXHRcdFx0XHRhLl9idWZmZXIgPSBudWxsO1xyXG5cdFx0XHR9IGVsc2UgaWYgKChiIGluc3RhbmNlb2YgTkRBcnJheSkgJiYgIWIuX2hhc1JlZnMoKSkge1xyXG5cdFx0XHRcdG91dC5fYnVmZmVyID0gYi5fYnVmZmVyO1xyXG5cdFx0XHRcdGIuX2J1ZmZlciA9IG51bGw7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0b3V0Ll9idWZmZXIgPSBmdXJpb3VzQ29udGV4dC5jb250ZXh0LmNyZWF0ZUJ1ZmZlcihjbC5NRU1fUkVBRF9XUklURSwgb3V0Lmxlbmd0aCAqIG91dC5kYXRhVHlwZS5zaXplKTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dXRpbC5jaGVja05EQXJyYXkob3V0LCBcIm91dFwiKTtcclxuXHRcdFx0dXRpbC5jaGVja1NoYXBlc0NvbXBhdGliaWxpdHkoc2hhcGVPdXQsIG91dC5zaGFwZSk7XHJcblx0XHRcdHV0aWwuY2hlY2tEYXRhVHlwZXNDb21wYXRpYmlsaXR5KGRhdGFUeXBlT3V0LCBvdXQuZGF0YVR5cGUpO1xyXG5cdFx0XHRvdXQuX2luY1JlZigpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKGEgaW5zdGFuY2VvZiBOREFycmF5KSB7XHJcblx0XHRcdGlmIChiIGluc3RhbmNlb2YgTkRBcnJheSkge1xyXG5cdFx0XHRcdHZhciBrZXJuZWwgPSBiaW5hcnlPcEtlcm5lbHNbZGF0YVR5cGVPdXQudHlwZV07XHJcblx0XHRcdFx0a2VybmVsLnNldEFyZygwLCBuZXcgVWludDMyQXJyYXkoW291dC5sZW5ndGhdKSk7XHJcblx0XHRcdFx0a2VybmVsLnNldEFyZygxLCBidWZmZXJBKTtcclxuXHRcdFx0XHRrZXJuZWwuc2V0QXJnKDIsIGJ1ZmZlckIpO1xyXG5cdFx0XHRcdGtlcm5lbC5zZXRBcmcoMywgb3V0Ll9idWZmZXIpO1xyXG5cdFx0XHRcdGZ1cmlvdXNDb250ZXh0LnF1ZXVlLmVucXVldWVORFJhbmdlS2VybmVsKGtlcm5lbCwgMSwgbnVsbCwgW291dC5sZW5ndGhdKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR2YXIga2VybmVsID0gYmluYXJ5Q29uc3RPcEtlcm5lbHNbZGF0YVR5cGVPdXQudHlwZV07XHJcblx0XHRcdFx0a2VybmVsLnNldEFyZygwLCBuZXcgVWludDMyQXJyYXkoW291dC5sZW5ndGhdKSk7XHJcblx0XHRcdFx0a2VybmVsLnNldEFyZygxLCBidWZmZXJBKTtcclxuXHRcdFx0XHRrZXJuZWwuc2V0QXJnKDIsIG5ldyBkYXRhVHlwZU91dC5hcnJheVR5cGUoW2JdKSk7XHJcblx0XHRcdFx0a2VybmVsLnNldEFyZygzLCBvdXQuX2J1ZmZlcik7XHJcblx0XHRcdFx0ZnVyaW91c0NvbnRleHQucXVldWUuZW5xdWV1ZU5EUmFuZ2VLZXJuZWwoa2VybmVsLCAxLCBudWxsLCBbb3V0Lmxlbmd0aF0pO1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR2YXIga2VybmVsID0gYmluYXJ5UmV2Q29uc3RLZXJuZWxzW2RhdGFUeXBlT3V0LnR5cGVdO1xyXG5cdFx0XHRrZXJuZWwuc2V0QXJnKDAsIG5ldyBVaW50MzJBcnJheShbb3V0Lmxlbmd0aF0pKTtcclxuXHRcdFx0a2VybmVsLnNldEFyZygxLCBidWZmZXJCKTtcclxuXHRcdFx0a2VybmVsLnNldEFyZygyLCBuZXcgZGF0YVR5cGVPdXQuYXJyYXlUeXBlKFthXSkpO1xyXG5cdFx0XHRrZXJuZWwuc2V0QXJnKDMsIG91dC5fYnVmZmVyKTtcclxuXHRcdFx0ZnVyaW91c0NvbnRleHQucXVldWUuZW5xdWV1ZU5EUmFuZ2VLZXJuZWwoa2VybmVsLCAxLCBudWxsLCBbb3V0Lmxlbmd0aF0pO1xyXG5cdFx0fVxyXG5cdH0gY2F0Y2ggKGUpIHtcclxuXHRcdC8qIFJlc3RvcmUgdGhlIHByZXZpb3VzIHN0YXRlICovXHJcblx0XHRpZiAoYSBpbnN0YW5jZW9mIE5EQXJyYXkpIHtcclxuXHRcdFx0YS5faW5jUmVmKCk7XHJcblx0XHR9XHJcblx0XHRpZiAoYiBpbnN0YW5jZW9mIE5EQXJyYXkpIHtcclxuXHRcdFx0Yi5faW5jUmVmKCk7XHJcblx0XHR9XHJcblx0XHR0aHJvdyBlO1xyXG5cdH1cclxuXHRpZiAoYSBpbnN0YW5jZW9mIE5EQXJyYXkpIHtcclxuXHRcdGEuX3RyeUludmFsaWRhdGUoKTtcclxuXHR9XHJcblx0aWYgKGIgaW5zdGFuY2VvZiBOREFycmF5KSB7XHJcblx0XHRiLl90cnlJbnZhbGlkYXRlKCk7XHJcblx0fVxyXG5cdHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG52YXIgdW5hcnlBcml0aE9wID0gZnVuY3Rpb24oYSwgb3V0LCBmdXJpb3VzQ29udGV4dCwgdW5hcnlPcEtlcm5lbHMpIHtcclxuXHR1dGlsLmNoZWNrTkRBcnJheShhLCBcImFcIik7XHJcblx0YS5fZGVjUmVmKCk7XHJcblx0dmFyIGJ1ZmZlckEgPSBhLl9idWZmZXI7XHJcblx0dHJ5IHtcclxuXHRcdGlmICh0eXBlb2Ygb3V0ID09PSBcInVuZGVmaW5lZFwiKSB7XHJcblx0XHRcdG91dCA9IG5ldyBOREFycmF5KGEuc2hhcGUsIGEuZGF0YVR5cGUsIGZ1cmlvdXNDb250ZXh0KTtcclxuXHRcdFx0aWYgKChhIGluc3RhbmNlb2YgTkRBcnJheSkgJiYgIWEuX2hhc1JlZnMoKSkge1xyXG5cdFx0XHRcdG91dC5fYnVmZmVyID0gYS5fYnVmZmVyO1xyXG5cdFx0XHRcdGEuX2J1ZmZlciA9IG51bGw7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0b3V0Ll9idWZmZXIgPSBmdXJpb3VzQ29udGV4dC5jb250ZXh0LmNyZWF0ZUJ1ZmZlcihjbC5NRU1fUkVBRF9XUklURSwgb3V0Lmxlbmd0aCAqIG91dC5kYXRhVHlwZS5zaXplKTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dXRpbC5jaGVja05EQXJyYXkob3V0LCBcIm91dFwiKTtcclxuXHRcdFx0dXRpbC5jaGVja1NoYXBlc0NvbXBhdGliaWxpdHkoYS5zaGFwZSwgb3V0LnNoYXBlKTtcclxuXHRcdFx0dXRpbC5jaGVja0RhdGFUeXBlc0NvbXBhdGliaWxpdHkoYS5kYXRhVHlwZSwgb3V0LmRhdGFUeXBlKTtcclxuXHRcdFx0b3V0Ll9pbmNSZWYoKTtcclxuXHRcdH1cclxuXHRcdHZhciBrZXJuZWwgPSB1bmFyeU9wS2VybmVsc1thLmRhdGFUeXBlLnR5cGVdO1xyXG5cdFx0a2VybmVsLnNldEFyZygwLCBuZXcgVWludDMyQXJyYXkoW291dC5sZW5ndGhdKSk7XHJcblx0XHRrZXJuZWwuc2V0QXJnKDEsIGJ1ZmZlckEpO1xyXG5cdFx0a2VybmVsLnNldEFyZygyLCBvdXQuX2J1ZmZlcik7XHJcblx0XHRmdXJpb3VzQ29udGV4dC5xdWV1ZS5lbnF1ZXVlTkRSYW5nZUtlcm5lbChrZXJuZWwsIDEsIG51bGwsIFtvdXQubGVuZ3RoXSk7XHJcblx0fSBjYXRjaCAoZSkge1xyXG5cdFx0LyogUmVzdG9yZSB0aGUgcHJldmlvdXMgc3RhdGUgKi9cclxuXHRcdGEuX2luY1JlZigpO1xyXG5cdFx0dGhyb3cgZTtcclxuXHR9XHJcblx0YS5fdHJ5SW52YWxpZGF0ZSgpO1xyXG5cdHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG52YXIgYXhpc1JlZHVjZU9wID0gZnVuY3Rpb24oYSwgYXhpcywgb3V0LCBmdXJpb3VzQ29udGV4dCwgcmVkdWNlS2VybmVscywgYXhpc1JlZHVjZUtlcm5lbHMpIHtcclxuXHR1dGlsLmNoZWNrTkRBcnJheShhLCBcImFcIik7XHJcblx0aWYgKHR5cGVvZiBheGlzID09PSBcInVuZGVmaW5lZFwiKSB7XHJcblx0XHRpZiAodHlwZW9mIG91dCA9PT0gXCJ1bmRlZmluZWRcIikge1xyXG5cdFx0XHRvdXQgPSBuZXcgTkRBcnJheShbXSwgYS5kYXRhVHlwZSwgZnVyaW91c0NvbnRleHQpO1xyXG5cdFx0XHRvdXQuX2J1ZmZlciA9IGZ1cmlvdXNDb250ZXh0LmNvbnRleHQuY3JlYXRlQnVmZmVyKGNsLk1FTV9SRUFEX1dSSVRFLCBhLmRhdGFUeXBlLnNpemUpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dXRpbC5jaGVja05EQXJyYXkob3V0LCBcIm91dFwiKTtcclxuXHRcdFx0dXRpbC5jaGVja1NoYXBlc0NvbXBhdGliaWxpdHkoW10sIG91dC5zaGFwZSk7XHJcblx0XHRcdHV0aWwuY2hlY2tEYXRhVHlwZXNDb21wYXRpYmlsaXR5KGEuZGF0YVR5cGUsIG91dC5kYXRhVHlwZSk7XHJcblx0XHRcdG91dC5faW5jUmVmKCk7XHJcblx0XHR9XHJcblx0XHR2YXIgbGVuZ3RoQSA9IGEubGVuZ3RoO1xyXG5cdFx0dmFyIG1heFdvcmtJdGVtc1BlckNVID0gTWF0aC5taW4oXHJcblx0XHRcdE1hdGgubWluKGZ1cmlvdXNDb250ZXh0LmRldmljZUluZm8ubWF4V29ya0dyb3VwU2l6ZSxcclxuXHRcdFx0XHRmdXJpb3VzQ29udGV4dC5kZXZpY2VJbmZvLm1heFdvcmtJdGVtU2l6ZXNbMF0pLCBcclxuXHRcdFx0ZnVyaW91c0NvbnRleHQuZGV2aWNlSW5mby5sb2NhbE1lbW9yeVNpemUgLyBhLmRhdGFUeXBlLnNpemUpO1xyXG5cdFx0LyogVGhlIG1pbmltYWwgYW1tb3VudCBvZiBwYXJhbGxlbGlzbSB0aGF0IGp1c3RpZmllcyBzd2l0Y2hpbmcgdG8gdHdvLXBhc3MgcmVkdWN0aW9uICovXHJcblx0XHR2YXIgcGFyYWxsZWxpc2F0aW9uVGhyZXNob2xkID0gMTY7XHJcblx0XHR2YXIga2VybmVsID0gcmVkdWNlS2VybmVsc1thLmRhdGFUeXBlLnR5cGVdO1xyXG5cdFx0aWYgKGxlbmd0aEEgPCBtYXhXb3JrSXRlbXNQZXJDVSAqIHBhcmFsbGVsaXNhdGlvblRocmVzaG9sZCkge1xyXG5cdFx0XHQvKiBPbmUgcmVkdWN0aW9uIGlzIGVub3VnaCAqL1xyXG5cdFx0XHRrZXJuZWwuc2V0QXJnKDAsIG5ldyBVaW50MzJBcnJheShbbGVuZ3RoQV0pKTtcclxuXHRcdFx0a2VybmVsLnNldEFyZygxLCBhLl9idWZmZXIpO1xyXG5cdFx0XHRrZXJuZWwuc2V0QXJnKDIsIG5ldyBVaW50MzJBcnJheShbbWF4V29ya0l0ZW1zUGVyQ1UgKiBhLmRhdGFUeXBlLnNpemVdKSk7XHJcblx0XHRcdGtlcm5lbC5zZXRBcmcoMywgb3V0Ll9idWZmZXIpO1xyXG5cdFx0XHQvKiBJbXBvcnRhbnQ6IHVzZSBvbmx5IG9uZSB3b3JrIGdyb3VwICovXHJcblx0XHRcdGZ1cmlvdXNDb250ZXh0LnF1ZXVlLmVucXVldWVORFJhbmdlS2VybmVsKGtlcm5lbCwgMSwgbnVsbCwgW21heFdvcmtJdGVtc1BlckNVXSwgW21heFdvcmtJdGVtc1BlckNVXSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHQvKiBUd28tc3RlcCByZWR1Y3Rpb24gKi9cclxuXHRcdFx0dmFyIG1heENvbXB1dGVVbml0cyA9IGZ1cmlvdXNDb250ZXh0LmRldmljZUluZm8ubWF4Q29tcHV0ZVVuaXRzO1xyXG5cdFx0XHR2YXIgd29ya0dyb3VwU2l6ZU11bHRpcGxlID0ga2VybmVsLmdldFdvcmtHcm91cEluZm8oZnVyaW91c0NvbnRleHQuZGV2aWNlLCBjbC5LRVJORUxfUFJFRkVSUkVEX1dPUktfR1JPVVBfU0laRV9NVUxUSVBMRSk7XHJcblx0XHRcdHZhciB0ZW1wQnVmZmVyID0gZnVyaW91c0NvbnRleHQuY29udGV4dC5jcmVhdGVCdWZmZXIoY2wuTUVNX1JFQURfV1JJVEUsIG1heENvbXB1dGVVbml0cyAqIGEuZGF0YVR5cGUuc2l6ZSk7XHJcblxyXG5cdFx0XHRrZXJuZWwuc2V0QXJnKDAsIG5ldyBVaW50MzJBcnJheShbbGVuZ3RoQV0pKTtcclxuXHRcdFx0a2VybmVsLnNldEFyZygxLCBhLl9idWZmZXIpO1xyXG5cdFx0XHRrZXJuZWwuc2V0QXJnKDIsIG5ldyBVaW50MzJBcnJheShbbWF4V29ya0l0ZW1zUGVyQ1UgKiBhLmRhdGFUeXBlLnNpemVdKSk7XHJcblx0XHRcdGtlcm5lbC5zZXRBcmcoMywgdGVtcEJ1ZmZlcik7XHJcblx0XHRcdGZ1cmlvdXNDb250ZXh0LnF1ZXVlLmVucXVldWVORFJhbmdlS2VybmVsKGtlcm5lbCwgMSwgbnVsbCxcclxuXHRcdFx0XHRbbWF4V29ya0l0ZW1zUGVyQ1UgKiBtYXhDb21wdXRlVW5pdHNdLFxyXG5cdFx0XHRcdFttYXhXb3JrSXRlbXNQZXJDVV0pO1xyXG5cclxuXHRcdFx0dmFyIHdvcmtHcm91cFNpemUgPSBNYXRoLm1pbihtYXhXb3JrSXRlbXNQZXJDVSxcclxuXHRcdFx0XHR1dGlsLnJvdW5kVXAobWF4Q29tcHV0ZVVuaXRzLCB3b3JrR3JvdXBTaXplTXVsdGlwbGUpKTtcclxuXHRcdFx0a2VybmVsLnNldEFyZygwLCBuZXcgVWludDMyQXJyYXkoW21heENvbXB1dGVVbml0c10pKTtcclxuXHRcdFx0a2VybmVsLnNldEFyZygxLCB0ZW1wQnVmZmVyKTtcclxuXHRcdFx0a2VybmVsLnNldEFyZygyLCBuZXcgVWludDMyQXJyYXkoW3dvcmtHcm91cFNpemUgKiBhLmRhdGFUeXBlLnNpemVdKSk7XHJcblx0XHRcdGtlcm5lbC5zZXRBcmcoMywgb3V0Ll9idWZmZXIpO1xyXG5cdFx0XHQvKiBJbXBvcnRhbnQ6IHVzZSBvbmx5IG9uZSB3b3JrIGdyb3VwICovXHJcblx0XHRcdGZ1cmlvdXNDb250ZXh0LnF1ZXVlLmVucXVldWVORFJhbmdlS2VybmVsKGtlcm5lbCwgMSwgbnVsbCxcclxuXHRcdFx0XHRbd29ya0dyb3VwU2l6ZV0sXHJcblx0XHRcdFx0W3dvcmtHcm91cFNpemVdKTtcclxuXHJcblx0XHRcdHRlbXBCdWZmZXIucmVsZWFzZSgpO1xyXG5cdFx0fVxyXG5cdFx0YS5fdHJ5UmVsZWFzZSgpO1xyXG5cdFx0cmV0dXJuIG91dDtcclxuXHR9IGVsc2Uge1xyXG5cdFx0YXhpcyA9IHV0aWwuY2hlY2tBeGlzKGF4aXMsIGEuc2hhcGUubGVuZ3RoKTtcclxuXHRcdHZhciBzaGFwZU91dCA9IHV0aWwuY29tcHV0ZUF4aXNSZWR1Y3Rpb25PdXRTaGFwZShhLnNoYXBlLCBheGlzKTtcclxuXHRcdGlmICh0eXBlb2Ygb3V0ID09PSBcInVuZGVmaW5lZFwiKSB7XHJcblx0XHRcdG91dCA9IG5ldyBOREFycmF5KHNoYXBlT3V0LCBhLmRhdGFUeXBlLCBmdXJpb3VzQ29udGV4dCk7XHJcblx0XHRcdG91dC5fYnVmZmVyID0gZnVyaW91c0NvbnRleHQuY29udGV4dC5jcmVhdGVCdWZmZXIoY2wuTUVNX1JFQURfV1JJVEUsIGEuZGF0YVR5cGUuc2l6ZSAqIG91dC5sZW5ndGgpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dXRpbC5jaGVja05EQXJyYXkob3V0LCBcIm91dFwiKTtcclxuXHRcdFx0dXRpbC5jaGVja1NoYXBlc0NvbXBhdGliaWxpdHkoW10sIG91dC5zaGFwZSk7XHJcblx0XHRcdHV0aWwuY2hlY2tEYXRhVHlwZXNDb21wYXRpYmlsaXR5KGEuZGF0YVR5cGUsIG91dC5kYXRhVHlwZSk7XHJcblx0XHRcdG91dC5faW5jUmVmKCk7XHJcblx0XHR9XHJcblx0XHR2YXIgb3V0ZXJTdHJpZGUgPSB1dGlsLmNvbXB1dGVPdXRlclN0cmlkZShhLnNoYXBlLCBheGlzKTtcclxuXHRcdHZhciByZWR1Y3Rpb25EaW0gPSBhLnNoYXBlW2F4aXNdO1xyXG5cdFx0dmFyIGlubmVyU3RyaWRlID0gdXRpbC5jb21wdXRlSW5uZXJTdHJpZGUoYS5zaGFwZSwgYXhpcyk7XHJcblx0XHR2YXIga2VybmVsID0gYXhpc1JlZHVjZUtlcm5lbHNbYS5kYXRhVHlwZS50eXBlXTtcclxuXHRcdGtlcm5lbC5zZXRBcmcoMCwgbmV3IFVpbnQzMkFycmF5KFtyZWR1Y3Rpb25EaW1dKSk7XHJcblx0XHRrZXJuZWwuc2V0QXJnKDEsIGEuX2J1ZmZlcik7XHJcblx0XHRrZXJuZWwuc2V0QXJnKDIsIG91dC5fYnVmZmVyKTtcclxuXHRcdGZ1cmlvdXNDb250ZXh0LnF1ZXVlLmVucXVldWVORFJhbmdlS2VybmVsKGtlcm5lbCwgMiwgbnVsbCxcclxuXHRcdFx0W291dGVyU3RyaWRlLCBpbm5lclN0cmlkZV0pO1xyXG5cdFx0YS5fdHJ5UmVsZWFzZSgpO1xyXG5cdFx0cmV0dXJuIG91dDtcclxuXHR9XHJcbn07XHJcblxyXG5cclxuV2ViQ0xDb250ZXh0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihhLCBiLCBvdXQpIHtcclxuXHRyZXR1cm4gYmluYXJ5QXJpdGhPcChhLCBiLCBvdXQsIHRoaXMsIHRoaXMua2VybmVscy5hZGQsIHRoaXMua2VybmVscy5hZGRjLCB0aGlzLmtlcm5lbHMuYWRkYyk7XHJcbn07XHJcblxyXG5XZWJDTENvbnRleHQucHJvdG90eXBlLnN1YiA9IGZ1bmN0aW9uKGEsIGIsIG91dCkge1xyXG5cdHJldHVybiBiaW5hcnlBcml0aE9wKGEsIGIsIG91dCwgdGhpcywgdGhpcy5rZXJuZWxzLnN1YiwgdGhpcy5rZXJuZWxzLnN1YmMsIHRoaXMua2VybmVscy5zdWJyYyk7XHJcbn07XHJcblxyXG5XZWJDTENvbnRleHQucHJvdG90eXBlLm11bCA9IGZ1bmN0aW9uKGEsIGIsIG91dCkge1xyXG5cdHJldHVybiBiaW5hcnlBcml0aE9wKGEsIGIsIG91dCwgdGhpcywgdGhpcy5rZXJuZWxzLm11bCwgdGhpcy5rZXJuZWxzLm11bGMsIHRoaXMua2VybmVscy5tdWxjKTtcclxufTtcclxuXHJcbldlYkNMQ29udGV4dC5wcm90b3R5cGUuZGl2ID0gZnVuY3Rpb24oYSwgYiwgb3V0KSB7XHJcblx0cmV0dXJuIGJpbmFyeUFyaXRoT3AoYSwgYiwgb3V0LCB0aGlzLCB0aGlzLmtlcm5lbHMuZGl2LCB0aGlzLmtlcm5lbHMuZGl2YywgdGhpcy5rZXJuZWxzLmRpdnJjKTtcclxufTtcclxuXHJcbldlYkNMQ29udGV4dC5wcm90b3R5cGUubmVnID0gZnVuY3Rpb24oYSwgb3V0KSB7XHJcblx0cmV0dXJuIHVuYXJ5QXJpdGhPcChhLCBvdXQsIHRoaXMsIHRoaXMua2VybmVscy5uZWcpO1xyXG59O1xyXG5cclxuV2ViQ0xDb250ZXh0LnByb3RvdHlwZS5hYnMgPSBmdW5jdGlvbihhLCBvdXQpIHtcclxuXHRyZXR1cm4gdW5hcnlBcml0aE9wKGEsIG91dCwgdGhpcywgdGhpcy5rZXJuZWxzLmFicyk7XHJcbn07XHJcblxyXG5XZWJDTENvbnRleHQucHJvdG90eXBlLmV4cCA9IGZ1bmN0aW9uKGEsIG91dCkge1xyXG5cdHJldHVybiB1bmFyeUFyaXRoT3AoYSwgb3V0LCB0aGlzLCB0aGlzLmtlcm5lbHMuZXhwKTtcclxufTtcclxuXHJcbldlYkNMQ29udGV4dC5wcm90b3R5cGUubG9nID0gZnVuY3Rpb24oYSwgb3V0KSB7XHJcblx0cmV0dXJuIHVuYXJ5QXJpdGhPcChhLCBvdXQsIHRoaXMsIHRoaXMua2VybmVscy5sb2cpO1xyXG59O1xyXG5cclxuV2ViQ0xDb250ZXh0LnByb3RvdHlwZS5zcXJ0ID0gZnVuY3Rpb24oYSwgb3V0KSB7XHJcblx0cmV0dXJuIHVuYXJ5QXJpdGhPcChhLCBvdXQsIHRoaXMsIHRoaXMua2VybmVscy5zcXJ0KTtcclxufTtcclxuXHJcbldlYkNMQ29udGV4dC5wcm90b3R5cGUuc3F1YXJlID0gZnVuY3Rpb24oYSwgb3V0KSB7XHJcblx0cmV0dXJuIHVuYXJ5QXJpdGhPcChhLCBvdXQsIHRoaXMsIHRoaXMua2VybmVscy5zcXVhcmUpO1xyXG59O1xyXG5cclxuV2ViQ0xDb250ZXh0LnByb3RvdHlwZS5taW4gPSBmdW5jdGlvbihhLCBheGlzLCBvdXQpIHtcclxuXHRyZXR1cm4gYXhpc1JlZHVjZU9wKGEsIGF4aXMsIG91dCwgdGhpcywgdGhpcy5rZXJuZWxzLm1pbiwgdGhpcy5rZXJuZWxzLmFtaW4pO1xyXG59O1xyXG5cclxuV2ViQ0xDb250ZXh0LnByb3RvdHlwZS5tYXggPSBmdW5jdGlvbihhLCBheGlzLCBvdXQpIHtcclxuXHRyZXR1cm4gYXhpc1JlZHVjZU9wKGEsIGF4aXMsIG91dCwgdGhpcywgdGhpcy5rZXJuZWxzLm1heCwgdGhpcy5rZXJuZWxzLmFtYXgpO1xyXG59O1xyXG5cclxuV2ViQ0xDb250ZXh0LnByb3RvdHlwZS5zdW0gPSBmdW5jdGlvbihhLCBheGlzLCBvdXQpIHtcclxuXHRyZXR1cm4gYXhpc1JlZHVjZU9wKGEsIGF4aXMsIG91dCwgdGhpcywgdGhpcy5rZXJuZWxzLnN1bSwgdGhpcy5rZXJuZWxzLmFzdW0pO1xyXG59O1xyXG5cclxuV2ViQ0xDb250ZXh0LnByb3RvdHlwZS5kb3QgPSBmdW5jdGlvbihhLCBiLCBvdXQpIHtcclxuXHR1dGlsLmNoZWNrTkRBcnJheShhLCBcImFcIik7XHJcblx0dXRpbC5jaGVja05EQXJyYXkoYiwgXCJiXCIpO1xyXG5cdHV0aWwuY2hlY2tEYXRhVHlwZXNDb21wYXRpYmlsaXR5KGEuZGF0YVR5cGUsIGIuZGF0YVR5cGUpO1xyXG5cclxuXHQvKiBUaGUgYXhpcyBvZiBiIHVzZWQgaW4gcmVkdWN0aW9uOiBheGlzIDAgZm9yIDFEIGFycmF5LCBzZWNvbmQtdG8tbGFzdCBheGlzIGZvciBORCBhcnJheSAqL1xyXG5cdHZhciBhQXhpcyA9IE1hdGgubWF4KGEuc2hhcGUubGVuZ3RoIC0gMSwgMCk7XHJcblx0dmFyIGJBeGlzID0gTWF0aC5tYXgoYi5zaGFwZS5sZW5ndGggLSAyLCAwKTtcclxuXHR2YXIgcmVkdWN0aW9uRGltID0gYS5zaGFwZVthQXhpc107XHJcblx0aWYgKHJlZHVjdGlvbkRpbSAhPT0gYi5zaGFwZVtiQXhpc10pIHtcclxuXHRcdHRocm93IG5ldyBSYW5nZUVycm9yKFwiQXJyYXlzIGhhdmUgaW5jb21wYXRpYmxlIHJlZHVjdGlvbiBkaW1lbnNpb25zXCIpO1xyXG5cdH1cclxuXHR2YXIgc2hhcGVPdXQgPSBbXSwgc3RyaWRlQSA9IDEsIG91dGVyU3RyaWRlQiA9IDEsIGlubmVyU3RyaWRlQiA9IDE7XHJcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhQXhpczsgaSsrKSB7XHJcblx0XHRzaGFwZU91dC5wdXNoKGEuc2hhcGVbaV0pO1xyXG5cdFx0c3RyaWRlQSAqPSBhLnNoYXBlW2ldO1xyXG5cdH1cclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGIuc2hhcGUubGVuZ3RoOyBpKyspIHtcclxuXHRcdHZhciBkaW0gPSBiLnNoYXBlW2ldO1xyXG5cdFx0aWYgKGkgPCBiQXhpcykge1xyXG5cdFx0XHRvdXRlclN0cmlkZUIgKj0gZGltO1xyXG5cdFx0XHRzaGFwZU91dC5wdXNoKGRpbSk7XHJcblx0XHR9IGVsc2UgaWYgKGkgPiBiQXhpcykge1xyXG5cdFx0XHRpbm5lclN0cmlkZUIgKj0gZGltO1xyXG5cdFx0XHRzaGFwZU91dC5wdXNoKGRpbSk7XHJcblx0XHR9XHJcblx0fVxyXG5cdGlmICh0eXBlb2Ygb3V0ID09PSBcInVuZGVmaW5lZFwiKSB7XHJcblx0XHRvdXQgPSB0aGlzLmVtcHR5KHNoYXBlT3V0LCBhLmRhdGFUeXBlKTtcclxuXHR9IGVsc2UgaWYgKG91dCBpbnN0YW5jZW9mIE5EQXJyYXkpIHtcclxuXHRcdHV0aWwuY2hlY2tOREFycmF5KG91dCwgXCJvdXRcIik7XHJcblx0XHR1dGlsLmNoZWNrU2hhcGVzQ29tcGF0aWJpbGl0eShvdXQuc2hhcGUsIHNoYXBlT3V0KTtcclxuXHRcdHV0aWwuY2hlY2tEYXRhVHlwZXNDb21wYXRpYmlsaXR5KG91dC5kYXRhVHlwZSwgYS5kYXRhVHlwZSk7XHJcblx0XHR1dGlsLmNoZWNrRGlmZmVyZW50TkRBcnJheXMoYSwgb3V0LCBcImFcIiwgXCJvdXRcIik7XHJcblx0XHR1dGlsLmNoZWNrRGlmZmVyZW50TkRBcnJheXMoYiwgb3V0LCBcImJcIiwgXCJvdXRcIik7XHJcblx0XHRvdXQuX2luY1JlZigpO1xyXG5cdH1cclxuXHR2YXIga2VybmVsID0gdGhpcy5rZXJuZWxzLmRvdFtvdXQuZGF0YVR5cGUudHlwZV07XHJcblx0a2VybmVsLnNldEFyZygwLCBuZXcgVWludDMyQXJyYXkoW3JlZHVjdGlvbkRpbV0pKTtcclxuXHRrZXJuZWwuc2V0QXJnKDEsIGEuX2J1ZmZlcik7XHJcblx0a2VybmVsLnNldEFyZygyLCBiLl9idWZmZXIpO1xyXG5cdGtlcm5lbC5zZXRBcmcoMywgb3V0Ll9idWZmZXIpO1xyXG5cdHRoaXMucXVldWUuZW5xdWV1ZU5EUmFuZ2VLZXJuZWwoa2VybmVsLCAzLCBudWxsLFxyXG5cdFx0W3N0cmlkZUEsIG91dGVyU3RyaWRlQiwgaW5uZXJTdHJpZGVCXSk7XHJcblx0YS5fdHJ5UmVsZWFzZSgpO1xyXG5cdGIuX3RyeVJlbGVhc2UoKTtcclxuXHRyZXR1cm4gb3V0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBXZWJDTENvbnRleHQ7XHJcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvY2hhaScpO1xuIiwiLyohXG4gKiBjaGFpXG4gKiBDb3B5cmlnaHQoYykgMjAxMS0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxudmFyIHVzZWQgPSBbXVxuICAsIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vKiFcbiAqIENoYWkgdmVyc2lvblxuICovXG5cbmV4cG9ydHMudmVyc2lvbiA9ICcxLjkuMSc7XG5cbi8qIVxuICogQXNzZXJ0aW9uIEVycm9yXG4gKi9cblxuZXhwb3J0cy5Bc3NlcnRpb25FcnJvciA9IHJlcXVpcmUoJ2Fzc2VydGlvbi1lcnJvcicpO1xuXG4vKiFcbiAqIFV0aWxzIGZvciBwbHVnaW5zIChub3QgZXhwb3J0ZWQpXG4gKi9cblxudmFyIHV0aWwgPSByZXF1aXJlKCcuL2NoYWkvdXRpbHMnKTtcblxuLyoqXG4gKiAjIC51c2UoZnVuY3Rpb24pXG4gKlxuICogUHJvdmlkZXMgYSB3YXkgdG8gZXh0ZW5kIHRoZSBpbnRlcm5hbHMgb2YgQ2hhaVxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259XG4gKiBAcmV0dXJucyB7dGhpc30gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMudXNlID0gZnVuY3Rpb24gKGZuKSB7XG4gIGlmICghfnVzZWQuaW5kZXhPZihmbikpIHtcbiAgICBmbih0aGlzLCB1dGlsKTtcbiAgICB1c2VkLnB1c2goZm4pO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKiFcbiAqIENvbmZpZ3VyYXRpb25cbiAqL1xuXG52YXIgY29uZmlnID0gcmVxdWlyZSgnLi9jaGFpL2NvbmZpZycpO1xuZXhwb3J0cy5jb25maWcgPSBjb25maWc7XG5cbi8qIVxuICogUHJpbWFyeSBgQXNzZXJ0aW9uYCBwcm90b3R5cGVcbiAqL1xuXG52YXIgYXNzZXJ0aW9uID0gcmVxdWlyZSgnLi9jaGFpL2Fzc2VydGlvbicpO1xuZXhwb3J0cy51c2UoYXNzZXJ0aW9uKTtcblxuLyohXG4gKiBDb3JlIEFzc2VydGlvbnNcbiAqL1xuXG52YXIgY29yZSA9IHJlcXVpcmUoJy4vY2hhaS9jb3JlL2Fzc2VydGlvbnMnKTtcbmV4cG9ydHMudXNlKGNvcmUpO1xuXG4vKiFcbiAqIEV4cGVjdCBpbnRlcmZhY2VcbiAqL1xuXG52YXIgZXhwZWN0ID0gcmVxdWlyZSgnLi9jaGFpL2ludGVyZmFjZS9leHBlY3QnKTtcbmV4cG9ydHMudXNlKGV4cGVjdCk7XG5cbi8qIVxuICogU2hvdWxkIGludGVyZmFjZVxuICovXG5cbnZhciBzaG91bGQgPSByZXF1aXJlKCcuL2NoYWkvaW50ZXJmYWNlL3Nob3VsZCcpO1xuZXhwb3J0cy51c2Uoc2hvdWxkKTtcblxuLyohXG4gKiBBc3NlcnQgaW50ZXJmYWNlXG4gKi9cblxudmFyIGFzc2VydCA9IHJlcXVpcmUoJy4vY2hhaS9pbnRlcmZhY2UvYXNzZXJ0Jyk7XG5leHBvcnRzLnVzZShhc3NlcnQpO1xuIiwiLyohXG4gKiBjaGFpXG4gKiBodHRwOi8vY2hhaWpzLmNvbVxuICogQ29weXJpZ2h0KGMpIDIwMTEtMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbnZhciBjb25maWcgPSByZXF1aXJlKCcuL2NvbmZpZycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChfY2hhaSwgdXRpbCkge1xuICAvKiFcbiAgICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAgICovXG5cbiAgdmFyIEFzc2VydGlvbkVycm9yID0gX2NoYWkuQXNzZXJ0aW9uRXJyb3JcbiAgICAsIGZsYWcgPSB1dGlsLmZsYWc7XG5cbiAgLyohXG4gICAqIE1vZHVsZSBleHBvcnQuXG4gICAqL1xuXG4gIF9jaGFpLkFzc2VydGlvbiA9IEFzc2VydGlvbjtcblxuICAvKiFcbiAgICogQXNzZXJ0aW9uIENvbnN0cnVjdG9yXG4gICAqXG4gICAqIENyZWF0ZXMgb2JqZWN0IGZvciBjaGFpbmluZy5cbiAgICpcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuXG4gIGZ1bmN0aW9uIEFzc2VydGlvbiAob2JqLCBtc2csIHN0YWNrKSB7XG4gICAgZmxhZyh0aGlzLCAnc3NmaScsIHN0YWNrIHx8IGFyZ3VtZW50cy5jYWxsZWUpO1xuICAgIGZsYWcodGhpcywgJ29iamVjdCcsIG9iaik7XG4gICAgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG4gIH1cblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQXNzZXJ0aW9uLCAnaW5jbHVkZVN0YWNrJywge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ0Fzc2VydGlvbi5pbmNsdWRlU3RhY2sgaXMgZGVwcmVjYXRlZCwgdXNlIGNoYWkuY29uZmlnLmluY2x1ZGVTdGFjayBpbnN0ZWFkLicpO1xuICAgICAgcmV0dXJuIGNvbmZpZy5pbmNsdWRlU3RhY2s7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ0Fzc2VydGlvbi5pbmNsdWRlU3RhY2sgaXMgZGVwcmVjYXRlZCwgdXNlIGNoYWkuY29uZmlnLmluY2x1ZGVTdGFjayBpbnN0ZWFkLicpO1xuICAgICAgY29uZmlnLmluY2x1ZGVTdGFjayA9IHZhbHVlO1xuICAgIH1cbiAgfSk7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFzc2VydGlvbiwgJ3Nob3dEaWZmJywge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ0Fzc2VydGlvbi5zaG93RGlmZiBpcyBkZXByZWNhdGVkLCB1c2UgY2hhaS5jb25maWcuc2hvd0RpZmYgaW5zdGVhZC4nKTtcbiAgICAgIHJldHVybiBjb25maWcuc2hvd0RpZmY7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ0Fzc2VydGlvbi5zaG93RGlmZiBpcyBkZXByZWNhdGVkLCB1c2UgY2hhaS5jb25maWcuc2hvd0RpZmYgaW5zdGVhZC4nKTtcbiAgICAgIGNvbmZpZy5zaG93RGlmZiA9IHZhbHVlO1xuICAgIH1cbiAgfSk7XG5cbiAgQXNzZXJ0aW9uLmFkZFByb3BlcnR5ID0gZnVuY3Rpb24gKG5hbWUsIGZuKSB7XG4gICAgdXRpbC5hZGRQcm9wZXJ0eSh0aGlzLnByb3RvdHlwZSwgbmFtZSwgZm4pO1xuICB9O1xuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QgPSBmdW5jdGlvbiAobmFtZSwgZm4pIHtcbiAgICB1dGlsLmFkZE1ldGhvZCh0aGlzLnByb3RvdHlwZSwgbmFtZSwgZm4pO1xuICB9O1xuXG4gIEFzc2VydGlvbi5hZGRDaGFpbmFibGVNZXRob2QgPSBmdW5jdGlvbiAobmFtZSwgZm4sIGNoYWluaW5nQmVoYXZpb3IpIHtcbiAgICB1dGlsLmFkZENoYWluYWJsZU1ldGhvZCh0aGlzLnByb3RvdHlwZSwgbmFtZSwgZm4sIGNoYWluaW5nQmVoYXZpb3IpO1xuICB9O1xuXG4gIEFzc2VydGlvbi5vdmVyd3JpdGVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChuYW1lLCBmbikge1xuICAgIHV0aWwub3ZlcndyaXRlUHJvcGVydHkodGhpcy5wcm90b3R5cGUsIG5hbWUsIGZuKTtcbiAgfTtcblxuICBBc3NlcnRpb24ub3ZlcndyaXRlTWV0aG9kID0gZnVuY3Rpb24gKG5hbWUsIGZuKSB7XG4gICAgdXRpbC5vdmVyd3JpdGVNZXRob2QodGhpcy5wcm90b3R5cGUsIG5hbWUsIGZuKTtcbiAgfTtcblxuICBBc3NlcnRpb24ub3ZlcndyaXRlQ2hhaW5hYmxlTWV0aG9kID0gZnVuY3Rpb24gKG5hbWUsIGZuLCBjaGFpbmluZ0JlaGF2aW9yKSB7XG4gICAgdXRpbC5vdmVyd3JpdGVDaGFpbmFibGVNZXRob2QodGhpcy5wcm90b3R5cGUsIG5hbWUsIGZuLCBjaGFpbmluZ0JlaGF2aW9yKTtcbiAgfTtcblxuICAvKiFcbiAgICogIyMjIC5hc3NlcnQoZXhwcmVzc2lvbiwgbWVzc2FnZSwgbmVnYXRlTWVzc2FnZSwgZXhwZWN0ZWQsIGFjdHVhbClcbiAgICpcbiAgICogRXhlY3V0ZXMgYW4gZXhwcmVzc2lvbiBhbmQgY2hlY2sgZXhwZWN0YXRpb25zLiBUaHJvd3MgQXNzZXJ0aW9uRXJyb3IgZm9yIHJlcG9ydGluZyBpZiB0ZXN0IGRvZXNuJ3QgcGFzcy5cbiAgICpcbiAgICogQG5hbWUgYXNzZXJ0XG4gICAqIEBwYXJhbSB7UGhpbG9zb3BoaWNhbH0gZXhwcmVzc2lvbiB0byBiZSB0ZXN0ZWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgdG8gZGlzcGxheSBpZiBmYWlsc1xuICAgKiBAcGFyYW0ge1N0cmluZ30gbmVnYXRlZE1lc3NhZ2UgdG8gZGlzcGxheSBpZiBuZWdhdGVkIGV4cHJlc3Npb24gZmFpbHNcbiAgICogQHBhcmFtIHtNaXhlZH0gZXhwZWN0ZWQgdmFsdWUgKHJlbWVtYmVyIHRvIGNoZWNrIGZvciBuZWdhdGlvbilcbiAgICogQHBhcmFtIHtNaXhlZH0gYWN0dWFsIChvcHRpb25hbCkgd2lsbCBkZWZhdWx0IHRvIGB0aGlzLm9iamBcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuXG4gIEFzc2VydGlvbi5wcm90b3R5cGUuYXNzZXJ0ID0gZnVuY3Rpb24gKGV4cHIsIG1zZywgbmVnYXRlTXNnLCBleHBlY3RlZCwgX2FjdHVhbCwgc2hvd0RpZmYpIHtcbiAgICB2YXIgb2sgPSB1dGlsLnRlc3QodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAodHJ1ZSAhPT0gc2hvd0RpZmYpIHNob3dEaWZmID0gZmFsc2U7XG4gICAgaWYgKHRydWUgIT09IGNvbmZpZy5zaG93RGlmZikgc2hvd0RpZmYgPSBmYWxzZTtcblxuICAgIGlmICghb2spIHtcbiAgICAgIHZhciBtc2cgPSB1dGlsLmdldE1lc3NhZ2UodGhpcywgYXJndW1lbnRzKVxuICAgICAgICAsIGFjdHVhbCA9IHV0aWwuZ2V0QWN0dWFsKHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB0aHJvdyBuZXcgQXNzZXJ0aW9uRXJyb3IobXNnLCB7XG4gICAgICAgICAgYWN0dWFsOiBhY3R1YWxcbiAgICAgICAgLCBleHBlY3RlZDogZXhwZWN0ZWRcbiAgICAgICAgLCBzaG93RGlmZjogc2hvd0RpZmZcbiAgICAgIH0sIChjb25maWcuaW5jbHVkZVN0YWNrKSA/IHRoaXMuYXNzZXJ0IDogZmxhZyh0aGlzLCAnc3NmaScpKTtcbiAgICB9XG4gIH07XG5cbiAgLyohXG4gICAqICMjIyAuX29ialxuICAgKlxuICAgKiBRdWljayByZWZlcmVuY2UgdG8gc3RvcmVkIGBhY3R1YWxgIHZhbHVlIGZvciBwbHVnaW4gZGV2ZWxvcGVycy5cbiAgICpcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBc3NlcnRpb24ucHJvdG90eXBlLCAnX29iaicsXG4gICAgeyBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZsYWcodGhpcywgJ29iamVjdCcpO1xuICAgICAgfVxuICAgICwgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgIGZsYWcodGhpcywgJ29iamVjdCcsIHZhbCk7XG4gICAgICB9XG4gIH0pO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuXG4gIC8qKlxuICAgKiAjIyMgY29uZmlnLmluY2x1ZGVTdGFja1xuICAgKlxuICAgKiBVc2VyIGNvbmZpZ3VyYWJsZSBwcm9wZXJ0eSwgaW5mbHVlbmNlcyB3aGV0aGVyIHN0YWNrIHRyYWNlXG4gICAqIGlzIGluY2x1ZGVkIGluIEFzc2VydGlvbiBlcnJvciBtZXNzYWdlLiBEZWZhdWx0IG9mIGZhbHNlXG4gICAqIHN1cHByZXNzZXMgc3RhY2sgdHJhY2UgaW4gdGhlIGVycm9yIG1lc3NhZ2UuXG4gICAqXG4gICAqICAgICBjaGFpLmNvbmZpZy5pbmNsdWRlU3RhY2sgPSB0cnVlOyAgLy8gZW5hYmxlIHN0YWNrIG9uIGVycm9yXG4gICAqXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn1cbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgIGluY2x1ZGVTdGFjazogZmFsc2UsXG5cbiAgLyoqXG4gICAqICMjIyBjb25maWcuc2hvd0RpZmZcbiAgICpcbiAgICogVXNlciBjb25maWd1cmFibGUgcHJvcGVydHksIGluZmx1ZW5jZXMgd2hldGhlciBvciBub3RcbiAgICogdGhlIGBzaG93RGlmZmAgZmxhZyBzaG91bGQgYmUgaW5jbHVkZWQgaW4gdGhlIHRocm93blxuICAgKiBBc3NlcnRpb25FcnJvcnMuIGBmYWxzZWAgd2lsbCBhbHdheXMgYmUgYGZhbHNlYDsgYHRydWVgXG4gICAqIHdpbGwgYmUgdHJ1ZSB3aGVuIHRoZSBhc3NlcnRpb24gaGFzIHJlcXVlc3RlZCBhIGRpZmZcbiAgICogYmUgc2hvd24uXG4gICAqXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn1cbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgc2hvd0RpZmY6IHRydWUsXG5cbiAgLyoqXG4gICAqICMjIyBjb25maWcudHJ1bmNhdGVUaHJlc2hvbGRcbiAgICpcbiAgICogVXNlciBjb25maWd1cmFibGUgcHJvcGVydHksIHNldHMgbGVuZ3RoIHRocmVzaG9sZCBmb3IgYWN0dWFsIGFuZFxuICAgKiBleHBlY3RlZCB2YWx1ZXMgaW4gYXNzZXJ0aW9uIGVycm9ycy4gSWYgdGhpcyB0aHJlc2hvbGQgaXMgZXhjZWVkZWQsXG4gICAqIHRoZSB2YWx1ZSBpcyB0cnVuY2F0ZWQuXG4gICAqXG4gICAqIFNldCBpdCB0byB6ZXJvIGlmIHlvdSB3YW50IHRvIGRpc2FibGUgdHJ1bmNhdGluZyBhbHRvZ2V0aGVyLlxuICAgKlxuICAgKiAgICAgY2hhaS5jb25maWcudHJ1bmNhdGVUaHJlc2hvbGQgPSAwOyAgLy8gZGlzYWJsZSB0cnVuY2F0aW5nXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICB0cnVuY2F0ZVRocmVzaG9sZDogNDBcblxufTtcbiIsIi8qIVxuICogY2hhaVxuICogaHR0cDovL2NoYWlqcy5jb21cbiAqIENvcHlyaWdodChjKSAyMDExLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjaGFpLCBfKSB7XG4gIHZhciBBc3NlcnRpb24gPSBjaGFpLkFzc2VydGlvblxuICAgICwgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nXG4gICAgLCBmbGFnID0gXy5mbGFnO1xuXG4gIC8qKlxuICAgKiAjIyMgTGFuZ3VhZ2UgQ2hhaW5zXG4gICAqXG4gICAqIFRoZSBmb2xsb3dpbmcgYXJlIHByb3ZpZGVkIGFzIGNoYWluYWJsZSBnZXR0ZXJzIHRvXG4gICAqIGltcHJvdmUgdGhlIHJlYWRhYmlsaXR5IG9mIHlvdXIgYXNzZXJ0aW9ucy4gVGhleVxuICAgKiBkbyBub3QgcHJvdmlkZSB0ZXN0aW5nIGNhcGFiaWxpdGllcyB1bmxlc3MgdGhleVxuICAgKiBoYXZlIGJlZW4gb3ZlcndyaXR0ZW4gYnkgYSBwbHVnaW4uXG4gICAqXG4gICAqICoqQ2hhaW5zKipcbiAgICpcbiAgICogLSB0b1xuICAgKiAtIGJlXG4gICAqIC0gYmVlblxuICAgKiAtIGlzXG4gICAqIC0gdGhhdFxuICAgKiAtIGFuZFxuICAgKiAtIGhhc1xuICAgKiAtIGhhdmVcbiAgICogLSB3aXRoXG4gICAqIC0gYXRcbiAgICogLSBvZlxuICAgKiAtIHNhbWVcbiAgICpcbiAgICogQG5hbWUgbGFuZ3VhZ2UgY2hhaW5zXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIFsgJ3RvJywgJ2JlJywgJ2JlZW4nXG4gICwgJ2lzJywgJ2FuZCcsICdoYXMnLCAnaGF2ZSdcbiAgLCAnd2l0aCcsICd0aGF0JywgJ2F0J1xuICAsICdvZicsICdzYW1lJyBdLmZvckVhY2goZnVuY3Rpb24gKGNoYWluKSB7XG4gICAgQXNzZXJ0aW9uLmFkZFByb3BlcnR5KGNoYWluLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9KTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqICMjIyAubm90XG4gICAqXG4gICAqIE5lZ2F0ZXMgYW55IG9mIGFzc2VydGlvbnMgZm9sbG93aW5nIGluIHRoZSBjaGFpbi5cbiAgICpcbiAgICogICAgIGV4cGVjdChmb28pLnRvLm5vdC5lcXVhbCgnYmFyJyk7XG4gICAqICAgICBleHBlY3QoZ29vZEZuKS50by5ub3QudGhyb3coRXJyb3IpO1xuICAgKiAgICAgZXhwZWN0KHsgZm9vOiAnYmF6JyB9KS50by5oYXZlLnByb3BlcnR5KCdmb28nKVxuICAgKiAgICAgICAuYW5kLm5vdC5lcXVhbCgnYmFyJyk7XG4gICAqXG4gICAqIEBuYW1lIG5vdFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkUHJvcGVydHkoJ25vdCcsIGZ1bmN0aW9uICgpIHtcbiAgICBmbGFnKHRoaXMsICduZWdhdGUnLCB0cnVlKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqICMjIyAuZGVlcFxuICAgKlxuICAgKiBTZXRzIHRoZSBgZGVlcGAgZmxhZywgbGF0ZXIgdXNlZCBieSB0aGUgYGVxdWFsYCBhbmRcbiAgICogYHByb3BlcnR5YCBhc3NlcnRpb25zLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KGZvbykudG8uZGVlcC5lcXVhbCh7IGJhcjogJ2JheicgfSk7XG4gICAqICAgICBleHBlY3QoeyBmb286IHsgYmFyOiB7IGJhejogJ3F1dXgnIH0gfSB9KVxuICAgKiAgICAgICAudG8uaGF2ZS5kZWVwLnByb3BlcnR5KCdmb28uYmFyLmJheicsICdxdXV4Jyk7XG4gICAqXG4gICAqIEBuYW1lIGRlZXBcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQXNzZXJ0aW9uLmFkZFByb3BlcnR5KCdkZWVwJywgZnVuY3Rpb24gKCkge1xuICAgIGZsYWcodGhpcywgJ2RlZXAnLCB0cnVlKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqICMjIyAuYSh0eXBlKVxuICAgKlxuICAgKiBUaGUgYGFgIGFuZCBgYW5gIGFzc2VydGlvbnMgYXJlIGFsaWFzZXMgdGhhdCBjYW4gYmVcbiAgICogdXNlZCBlaXRoZXIgYXMgbGFuZ3VhZ2UgY2hhaW5zIG9yIHRvIGFzc2VydCBhIHZhbHVlJ3NcbiAgICogdHlwZS5cbiAgICpcbiAgICogICAgIC8vIHR5cGVvZlxuICAgKiAgICAgZXhwZWN0KCd0ZXN0JykudG8uYmUuYSgnc3RyaW5nJyk7XG4gICAqICAgICBleHBlY3QoeyBmb286ICdiYXInIH0pLnRvLmJlLmFuKCdvYmplY3QnKTtcbiAgICogICAgIGV4cGVjdChudWxsKS50by5iZS5hKCdudWxsJyk7XG4gICAqICAgICBleHBlY3QodW5kZWZpbmVkKS50by5iZS5hbigndW5kZWZpbmVkJyk7XG4gICAqXG4gICAqICAgICAvLyBsYW5ndWFnZSBjaGFpblxuICAgKiAgICAgZXhwZWN0KGZvbykudG8uYmUuYW4uaW5zdGFuY2VvZihGb28pO1xuICAgKlxuICAgKiBAbmFtZSBhXG4gICAqIEBhbGlhcyBhblxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGFuICh0eXBlLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB0eXBlID0gdHlwZS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKVxuICAgICAgLCBhcnRpY2xlID0gflsgJ2EnLCAnZScsICdpJywgJ28nLCAndScgXS5pbmRleE9mKHR5cGUuY2hhckF0KDApKSA/ICdhbiAnIDogJ2EgJztcblxuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICB0eXBlID09PSBfLnR5cGUob2JqKVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSAnICsgYXJ0aWNsZSArIHR5cGVcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gbm90IHRvIGJlICcgKyBhcnRpY2xlICsgdHlwZVxuICAgICk7XG4gIH1cblxuICBBc3NlcnRpb24uYWRkQ2hhaW5hYmxlTWV0aG9kKCdhbicsIGFuKTtcbiAgQXNzZXJ0aW9uLmFkZENoYWluYWJsZU1ldGhvZCgnYScsIGFuKTtcblxuICAvKipcbiAgICogIyMjIC5pbmNsdWRlKHZhbHVlKVxuICAgKlxuICAgKiBUaGUgYGluY2x1ZGVgIGFuZCBgY29udGFpbmAgYXNzZXJ0aW9ucyBjYW4gYmUgdXNlZCBhcyBlaXRoZXIgcHJvcGVydHlcbiAgICogYmFzZWQgbGFuZ3VhZ2UgY2hhaW5zIG9yIGFzIG1ldGhvZHMgdG8gYXNzZXJ0IHRoZSBpbmNsdXNpb24gb2YgYW4gb2JqZWN0XG4gICAqIGluIGFuIGFycmF5IG9yIGEgc3Vic3RyaW5nIGluIGEgc3RyaW5nLiBXaGVuIHVzZWQgYXMgbGFuZ3VhZ2UgY2hhaW5zLFxuICAgKiB0aGV5IHRvZ2dsZSB0aGUgYGNvbnRhaW5gIGZsYWcgZm9yIHRoZSBga2V5c2AgYXNzZXJ0aW9uLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KFsxLDIsM10pLnRvLmluY2x1ZGUoMik7XG4gICAqICAgICBleHBlY3QoJ2Zvb2JhcicpLnRvLmNvbnRhaW4oJ2ZvbycpO1xuICAgKiAgICAgZXhwZWN0KHsgZm9vOiAnYmFyJywgaGVsbG86ICd1bml2ZXJzZScgfSkudG8uaW5jbHVkZS5rZXlzKCdmb28nKTtcbiAgICpcbiAgICogQG5hbWUgaW5jbHVkZVxuICAgKiBAYWxpYXMgY29udGFpblxuICAgKiBAcGFyYW0ge09iamVjdHxTdHJpbmd8TnVtYmVyfSBvYmpcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBmdW5jdGlvbiBpbmNsdWRlQ2hhaW5pbmdCZWhhdmlvciAoKSB7XG4gICAgZmxhZyh0aGlzLCAnY29udGFpbnMnLCB0cnVlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluY2x1ZGUgKHZhbCwgbXNnKSB7XG4gICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpO1xuICAgIHZhciBleHBlY3RlZCA9IGZhbHNlO1xuICAgIGlmIChfLnR5cGUob2JqKSA9PT0gJ2FycmF5JyAmJiBfLnR5cGUodmFsKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGZvciAodmFyIGkgaW4gb2JqKSB7XG4gICAgICAgIGlmIChfLmVxbChvYmpbaV0sIHZhbCkpIHtcbiAgICAgICAgICBleHBlY3RlZCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKF8udHlwZSh2YWwpID09PSAnb2JqZWN0Jykge1xuICAgICAgaWYgKCFmbGFnKHRoaXMsICduZWdhdGUnKSkge1xuICAgICAgICBmb3IgKHZhciBrIGluIHZhbCkgbmV3IEFzc2VydGlvbihvYmopLnByb3BlcnR5KGssIHZhbFtrXSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBzdWJzZXQgPSB7fVxuICAgICAgZm9yICh2YXIgayBpbiB2YWwpIHN1YnNldFtrXSA9IG9ialtrXVxuICAgICAgZXhwZWN0ZWQgPSBfLmVxbChzdWJzZXQsIHZhbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cGVjdGVkID0gb2JqICYmIH5vYmouaW5kZXhPZih2YWwpXG4gICAgfVxuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICBleHBlY3RlZFxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBpbmNsdWRlICcgKyBfLmluc3BlY3QodmFsKVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgaW5jbHVkZSAnICsgXy5pbnNwZWN0KHZhbCkpO1xuICB9XG5cbiAgQXNzZXJ0aW9uLmFkZENoYWluYWJsZU1ldGhvZCgnaW5jbHVkZScsIGluY2x1ZGUsIGluY2x1ZGVDaGFpbmluZ0JlaGF2aW9yKTtcbiAgQXNzZXJ0aW9uLmFkZENoYWluYWJsZU1ldGhvZCgnY29udGFpbicsIGluY2x1ZGUsIGluY2x1ZGVDaGFpbmluZ0JlaGF2aW9yKTtcblxuICAvKipcbiAgICogIyMjIC5va1xuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyB0cnV0aHkuXG4gICAqXG4gICAqICAgICBleHBlY3QoJ2V2ZXJ0aGluZycpLnRvLmJlLm9rO1xuICAgKiAgICAgZXhwZWN0KDEpLnRvLmJlLm9rO1xuICAgKiAgICAgZXhwZWN0KGZhbHNlKS50by5ub3QuYmUub2s7XG4gICAqICAgICBleHBlY3QodW5kZWZpbmVkKS50by5ub3QuYmUub2s7XG4gICAqICAgICBleHBlY3QobnVsbCkudG8ubm90LmJlLm9rO1xuICAgKlxuICAgKiBAbmFtZSBva1xuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkUHJvcGVydHkoJ29rJywgZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICBmbGFnKHRoaXMsICdvYmplY3QnKVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSB0cnV0aHknXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIGZhbHN5Jyk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiAjIyMgLnRydWVcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaXMgYHRydWVgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KHRydWUpLnRvLmJlLnRydWU7XG4gICAqICAgICBleHBlY3QoMSkudG8ubm90LmJlLnRydWU7XG4gICAqXG4gICAqIEBuYW1lIHRydWVcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQXNzZXJ0aW9uLmFkZFByb3BlcnR5KCd0cnVlJywgZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICB0cnVlID09PSBmbGFnKHRoaXMsICdvYmplY3QnKVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSB0cnVlJ1xuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSBmYWxzZSdcbiAgICAgICwgdGhpcy5uZWdhdGUgPyBmYWxzZSA6IHRydWVcbiAgICApO1xuICB9KTtcblxuICAvKipcbiAgICogIyMjIC5mYWxzZVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyBgZmFsc2VgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KGZhbHNlKS50by5iZS5mYWxzZTtcbiAgICogICAgIGV4cGVjdCgwKS50by5ub3QuYmUuZmFsc2U7XG4gICAqXG4gICAqIEBuYW1lIGZhbHNlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEFzc2VydGlvbi5hZGRQcm9wZXJ0eSgnZmFsc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIGZhbHNlID09PSBmbGFnKHRoaXMsICdvYmplY3QnKVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSBmYWxzZSdcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgdHJ1ZSdcbiAgICAgICwgdGhpcy5uZWdhdGUgPyB0cnVlIDogZmFsc2VcbiAgICApO1xuICB9KTtcblxuICAvKipcbiAgICogIyMjIC5udWxsXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIGBudWxsYC5cbiAgICpcbiAgICogICAgIGV4cGVjdChudWxsKS50by5iZS5udWxsO1xuICAgKiAgICAgZXhwZWN0KHVuZGVmaW5lZCkubm90LnRvLmJlLm51bGw7XG4gICAqXG4gICAqIEBuYW1lIG51bGxcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQXNzZXJ0aW9uLmFkZFByb3BlcnR5KCdudWxsJywgZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICBudWxsID09PSBmbGFnKHRoaXMsICdvYmplY3QnKVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSBudWxsJ1xuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSBub3QgdG8gYmUgbnVsbCdcbiAgICApO1xuICB9KTtcblxuICAvKipcbiAgICogIyMjIC51bmRlZmluZWRcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaXMgYHVuZGVmaW5lZGAuXG4gICAqXG4gICAqICAgICBleHBlY3QodW5kZWZpbmVkKS50by5iZS51bmRlZmluZWQ7XG4gICAqICAgICBleHBlY3QobnVsbCkudG8ubm90LmJlLnVuZGVmaW5lZDtcbiAgICpcbiAgICogQG5hbWUgdW5kZWZpbmVkXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEFzc2VydGlvbi5hZGRQcm9wZXJ0eSgndW5kZWZpbmVkJywgZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICB1bmRlZmluZWQgPT09IGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIHVuZGVmaW5lZCdcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gbm90IHRvIGJlIHVuZGVmaW5lZCdcbiAgICApO1xuICB9KTtcblxuICAvKipcbiAgICogIyMjIC5leGlzdFxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyBuZWl0aGVyIGBudWxsYCBub3IgYHVuZGVmaW5lZGAuXG4gICAqXG4gICAqICAgICB2YXIgZm9vID0gJ2hpJ1xuICAgKiAgICAgICAsIGJhciA9IG51bGxcbiAgICogICAgICAgLCBiYXo7XG4gICAqXG4gICAqICAgICBleHBlY3QoZm9vKS50by5leGlzdDtcbiAgICogICAgIGV4cGVjdChiYXIpLnRvLm5vdC5leGlzdDtcbiAgICogICAgIGV4cGVjdChiYXopLnRvLm5vdC5leGlzdDtcbiAgICpcbiAgICogQG5hbWUgZXhpc3RcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQXNzZXJ0aW9uLmFkZFByb3BlcnR5KCdleGlzdCcsIGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgbnVsbCAhPSBmbGFnKHRoaXMsICdvYmplY3QnKVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBleGlzdCdcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGV4aXN0J1xuICAgICk7XG4gIH0pO1xuXG5cbiAgLyoqXG4gICAqICMjIyAuZW1wdHlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQncyBsZW5ndGggaXMgYDBgLiBGb3IgYXJyYXlzLCBpdCBjaGVja3NcbiAgICogdGhlIGBsZW5ndGhgIHByb3BlcnR5LiBGb3Igb2JqZWN0cywgaXQgZ2V0cyB0aGUgY291bnQgb2ZcbiAgICogZW51bWVyYWJsZSBrZXlzLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KFtdKS50by5iZS5lbXB0eTtcbiAgICogICAgIGV4cGVjdCgnJykudG8uYmUuZW1wdHk7XG4gICAqICAgICBleHBlY3Qoe30pLnRvLmJlLmVtcHR5O1xuICAgKlxuICAgKiBAbmFtZSBlbXB0eVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkUHJvcGVydHkoJ2VtcHR5JywgZnVuY3Rpb24gKCkge1xuICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKVxuICAgICAgLCBleHBlY3RlZCA9IG9iajtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikgfHwgJ3N0cmluZycgPT09IHR5cGVvZiBvYmplY3QpIHtcbiAgICAgIGV4cGVjdGVkID0gb2JqLmxlbmd0aDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSB7XG4gICAgICBleHBlY3RlZCA9IE9iamVjdC5rZXlzKG9iaikubGVuZ3RoO1xuICAgIH1cblxuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAhZXhwZWN0ZWRcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgZW1wdHknXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IG5vdCB0byBiZSBlbXB0eSdcbiAgICApO1xuICB9KTtcblxuICAvKipcbiAgICogIyMjIC5hcmd1bWVudHNcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaXMgYW4gYXJndW1lbnRzIG9iamVjdC5cbiAgICpcbiAgICogICAgIGZ1bmN0aW9uIHRlc3QgKCkge1xuICAgKiAgICAgICBleHBlY3QoYXJndW1lbnRzKS50by5iZS5hcmd1bWVudHM7XG4gICAqICAgICB9XG4gICAqXG4gICAqIEBuYW1lIGFyZ3VtZW50c1xuICAgKiBAYWxpYXMgQXJndW1lbnRzXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGNoZWNrQXJndW1lbnRzICgpIHtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0JylcbiAgICAgICwgdHlwZSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopO1xuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAnW29iamVjdCBBcmd1bWVudHNdJyA9PT0gdHlwZVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSBhcmd1bWVudHMgYnV0IGdvdCAnICsgdHlwZVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgYmUgYXJndW1lbnRzJ1xuICAgICk7XG4gIH1cblxuICBBc3NlcnRpb24uYWRkUHJvcGVydHkoJ2FyZ3VtZW50cycsIGNoZWNrQXJndW1lbnRzKTtcbiAgQXNzZXJ0aW9uLmFkZFByb3BlcnR5KCdBcmd1bWVudHMnLCBjaGVja0FyZ3VtZW50cyk7XG5cbiAgLyoqXG4gICAqICMjIyAuZXF1YWwodmFsdWUpXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIHN0cmljdGx5IGVxdWFsIChgPT09YCkgdG8gYHZhbHVlYC5cbiAgICogQWx0ZXJuYXRlbHksIGlmIHRoZSBgZGVlcGAgZmxhZyBpcyBzZXQsIGFzc2VydHMgdGhhdFxuICAgKiB0aGUgdGFyZ2V0IGlzIGRlZXBseSBlcXVhbCB0byBgdmFsdWVgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KCdoZWxsbycpLnRvLmVxdWFsKCdoZWxsbycpO1xuICAgKiAgICAgZXhwZWN0KDQyKS50by5lcXVhbCg0Mik7XG4gICAqICAgICBleHBlY3QoMSkudG8ubm90LmVxdWFsKHRydWUpO1xuICAgKiAgICAgZXhwZWN0KHsgZm9vOiAnYmFyJyB9KS50by5ub3QuZXF1YWwoeyBmb286ICdiYXInIH0pO1xuICAgKiAgICAgZXhwZWN0KHsgZm9vOiAnYmFyJyB9KS50by5kZWVwLmVxdWFsKHsgZm9vOiAnYmFyJyB9KTtcbiAgICpcbiAgICogQG5hbWUgZXF1YWxcbiAgICogQGFsaWFzIGVxdWFsc1xuICAgKiBAYWxpYXMgZXFcbiAgICogQGFsaWFzIGRlZXAuZXF1YWxcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBmdW5jdGlvbiBhc3NlcnRFcXVhbCAodmFsLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0Jyk7XG4gICAgaWYgKGZsYWcodGhpcywgJ2RlZXAnKSkge1xuICAgICAgcmV0dXJuIHRoaXMuZXFsKHZhbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgIHZhbCA9PT0gb2JqXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gZXF1YWwgI3tleHB9J1xuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBlcXVhbCAje2V4cH0nXG4gICAgICAgICwgdmFsXG4gICAgICAgICwgdGhpcy5fb2JqXG4gICAgICAgICwgdHJ1ZVxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdlcXVhbCcsIGFzc2VydEVxdWFsKTtcbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnZXF1YWxzJywgYXNzZXJ0RXF1YWwpO1xuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdlcScsIGFzc2VydEVxdWFsKTtcblxuICAvKipcbiAgICogIyMjIC5lcWwodmFsdWUpXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIGRlZXBseSBlcXVhbCB0byBgdmFsdWVgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KHsgZm9vOiAnYmFyJyB9KS50by5lcWwoeyBmb286ICdiYXInIH0pO1xuICAgKiAgICAgZXhwZWN0KFsgMSwgMiwgMyBdKS50by5lcWwoWyAxLCAyLCAzIF0pO1xuICAgKlxuICAgKiBAbmFtZSBlcWxcbiAgICogQGFsaWFzIGVxbHNcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBmdW5jdGlvbiBhc3NlcnRFcWwob2JqLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgXy5lcWwob2JqLCBmbGFnKHRoaXMsICdvYmplY3QnKSlcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gZGVlcGx5IGVxdWFsICN7ZXhwfSdcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGRlZXBseSBlcXVhbCAje2V4cH0nXG4gICAgICAsIG9ialxuICAgICAgLCB0aGlzLl9vYmpcbiAgICAgICwgdHJ1ZVxuICAgICk7XG4gIH1cblxuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdlcWwnLCBhc3NlcnRFcWwpO1xuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdlcWxzJywgYXNzZXJ0RXFsKTtcblxuICAvKipcbiAgICogIyMjIC5hYm92ZSh2YWx1ZSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaXMgZ3JlYXRlciB0aGFuIGB2YWx1ZWAuXG4gICAqXG4gICAqICAgICBleHBlY3QoMTApLnRvLmJlLmFib3ZlKDUpO1xuICAgKlxuICAgKiBDYW4gYWxzbyBiZSB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggYGxlbmd0aGAgdG9cbiAgICogYXNzZXJ0IGEgbWluaW11bSBsZW5ndGguIFRoZSBiZW5lZml0IGJlaW5nIGFcbiAgICogbW9yZSBpbmZvcm1hdGl2ZSBlcnJvciBtZXNzYWdlIHRoYW4gaWYgdGhlIGxlbmd0aFxuICAgKiB3YXMgc3VwcGxpZWQgZGlyZWN0bHkuXG4gICAqXG4gICAqICAgICBleHBlY3QoJ2ZvbycpLnRvLmhhdmUubGVuZ3RoLmFib3ZlKDIpO1xuICAgKiAgICAgZXhwZWN0KFsgMSwgMiwgMyBdKS50by5oYXZlLmxlbmd0aC5hYm92ZSgyKTtcbiAgICpcbiAgICogQG5hbWUgYWJvdmVcbiAgICogQGFsaWFzIGd0XG4gICAqIEBhbGlhcyBncmVhdGVyVGhhblxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBmdW5jdGlvbiBhc3NlcnRBYm92ZSAobiwgbXNnKSB7XG4gICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpO1xuICAgIGlmIChmbGFnKHRoaXMsICdkb0xlbmd0aCcpKSB7XG4gICAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnKS50by5oYXZlLnByb3BlcnR5KCdsZW5ndGgnKTtcbiAgICAgIHZhciBsZW4gPSBvYmoubGVuZ3RoO1xuICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICAgbGVuID4gblxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGhhdmUgYSBsZW5ndGggYWJvdmUgI3tleHB9IGJ1dCBnb3QgI3thY3R9J1xuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBoYXZlIGEgbGVuZ3RoIGFib3ZlICN7ZXhwfSdcbiAgICAgICAgLCBuXG4gICAgICAgICwgbGVuXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgICBvYmogPiBuXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgYWJvdmUgJyArIG5cbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSBhdCBtb3N0ICcgKyBuXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2Fib3ZlJywgYXNzZXJ0QWJvdmUpO1xuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdndCcsIGFzc2VydEFib3ZlKTtcbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnZ3JlYXRlclRoYW4nLCBhc3NlcnRBYm92ZSk7XG5cbiAgLyoqXG4gICAqICMjIyAubGVhc3QodmFsdWUpXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byBgdmFsdWVgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KDEwKS50by5iZS5hdC5sZWFzdCgxMCk7XG4gICAqXG4gICAqIENhbiBhbHNvIGJlIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCBgbGVuZ3RoYCB0b1xuICAgKiBhc3NlcnQgYSBtaW5pbXVtIGxlbmd0aC4gVGhlIGJlbmVmaXQgYmVpbmcgYVxuICAgKiBtb3JlIGluZm9ybWF0aXZlIGVycm9yIG1lc3NhZ2UgdGhhbiBpZiB0aGUgbGVuZ3RoXG4gICAqIHdhcyBzdXBwbGllZCBkaXJlY3RseS5cbiAgICpcbiAgICogICAgIGV4cGVjdCgnZm9vJykudG8uaGF2ZS5sZW5ndGgub2YuYXQubGVhc3QoMik7XG4gICAqICAgICBleHBlY3QoWyAxLCAyLCAzIF0pLnRvLmhhdmUubGVuZ3RoLm9mLmF0LmxlYXN0KDMpO1xuICAgKlxuICAgKiBAbmFtZSBsZWFzdFxuICAgKiBAYWxpYXMgZ3RlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGFzc2VydExlYXN0IChuLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0Jyk7XG4gICAgaWYgKGZsYWcodGhpcywgJ2RvTGVuZ3RoJykpIHtcbiAgICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2cpLnRvLmhhdmUucHJvcGVydHkoJ2xlbmd0aCcpO1xuICAgICAgdmFyIGxlbiA9IG9iai5sZW5ndGg7XG4gICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgICBsZW4gPj0gblxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGhhdmUgYSBsZW5ndGggYXQgbGVhc3QgI3tleHB9IGJ1dCBnb3QgI3thY3R9J1xuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGhhdmUgYSBsZW5ndGggYmVsb3cgI3tleHB9J1xuICAgICAgICAsIG5cbiAgICAgICAgLCBsZW5cbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgIG9iaiA+PSBuXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgYXQgbGVhc3QgJyArIG5cbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSBiZWxvdyAnICsgblxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdsZWFzdCcsIGFzc2VydExlYXN0KTtcbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnZ3RlJywgYXNzZXJ0TGVhc3QpO1xuXG4gIC8qKlxuICAgKiAjIyMgLmJlbG93KHZhbHVlKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyBsZXNzIHRoYW4gYHZhbHVlYC5cbiAgICpcbiAgICogICAgIGV4cGVjdCg1KS50by5iZS5iZWxvdygxMCk7XG4gICAqXG4gICAqIENhbiBhbHNvIGJlIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCBgbGVuZ3RoYCB0b1xuICAgKiBhc3NlcnQgYSBtYXhpbXVtIGxlbmd0aC4gVGhlIGJlbmVmaXQgYmVpbmcgYVxuICAgKiBtb3JlIGluZm9ybWF0aXZlIGVycm9yIG1lc3NhZ2UgdGhhbiBpZiB0aGUgbGVuZ3RoXG4gICAqIHdhcyBzdXBwbGllZCBkaXJlY3RseS5cbiAgICpcbiAgICogICAgIGV4cGVjdCgnZm9vJykudG8uaGF2ZS5sZW5ndGguYmVsb3coNCk7XG4gICAqICAgICBleHBlY3QoWyAxLCAyLCAzIF0pLnRvLmhhdmUubGVuZ3RoLmJlbG93KDQpO1xuICAgKlxuICAgKiBAbmFtZSBiZWxvd1xuICAgKiBAYWxpYXMgbHRcbiAgICogQGFsaWFzIGxlc3NUaGFuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGFzc2VydEJlbG93IChuLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0Jyk7XG4gICAgaWYgKGZsYWcodGhpcywgJ2RvTGVuZ3RoJykpIHtcbiAgICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2cpLnRvLmhhdmUucHJvcGVydHkoJ2xlbmd0aCcpO1xuICAgICAgdmFyIGxlbiA9IG9iai5sZW5ndGg7XG4gICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgICBsZW4gPCBuXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gaGF2ZSBhIGxlbmd0aCBiZWxvdyAje2V4cH0gYnV0IGdvdCAje2FjdH0nXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGhhdmUgYSBsZW5ndGggYmVsb3cgI3tleHB9J1xuICAgICAgICAsIG5cbiAgICAgICAgLCBsZW5cbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgIG9iaiA8IG5cbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSBiZWxvdyAnICsgblxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIGF0IGxlYXN0ICcgKyBuXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2JlbG93JywgYXNzZXJ0QmVsb3cpO1xuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdsdCcsIGFzc2VydEJlbG93KTtcbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnbGVzc1RoYW4nLCBhc3NlcnRCZWxvdyk7XG5cbiAgLyoqXG4gICAqICMjIyAubW9zdCh2YWx1ZSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGB2YWx1ZWAuXG4gICAqXG4gICAqICAgICBleHBlY3QoNSkudG8uYmUuYXQubW9zdCg1KTtcbiAgICpcbiAgICogQ2FuIGFsc28gYmUgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIGBsZW5ndGhgIHRvXG4gICAqIGFzc2VydCBhIG1heGltdW0gbGVuZ3RoLiBUaGUgYmVuZWZpdCBiZWluZyBhXG4gICAqIG1vcmUgaW5mb3JtYXRpdmUgZXJyb3IgbWVzc2FnZSB0aGFuIGlmIHRoZSBsZW5ndGhcbiAgICogd2FzIHN1cHBsaWVkIGRpcmVjdGx5LlxuICAgKlxuICAgKiAgICAgZXhwZWN0KCdmb28nKS50by5oYXZlLmxlbmd0aC5vZi5hdC5tb3N0KDQpO1xuICAgKiAgICAgZXhwZWN0KFsgMSwgMiwgMyBdKS50by5oYXZlLmxlbmd0aC5vZi5hdC5tb3N0KDMpO1xuICAgKlxuICAgKiBAbmFtZSBtb3N0XG4gICAqIEBhbGlhcyBsdGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gYXNzZXJ0TW9zdCAobiwgbXNnKSB7XG4gICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpO1xuICAgIGlmIChmbGFnKHRoaXMsICdkb0xlbmd0aCcpKSB7XG4gICAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnKS50by5oYXZlLnByb3BlcnR5KCdsZW5ndGgnKTtcbiAgICAgIHZhciBsZW4gPSBvYmoubGVuZ3RoO1xuICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICAgbGVuIDw9IG5cbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBoYXZlIGEgbGVuZ3RoIGF0IG1vc3QgI3tleHB9IGJ1dCBnb3QgI3thY3R9J1xuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGhhdmUgYSBsZW5ndGggYWJvdmUgI3tleHB9J1xuICAgICAgICAsIG5cbiAgICAgICAgLCBsZW5cbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgIG9iaiA8PSBuXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgYXQgbW9zdCAnICsgblxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIGFib3ZlICcgKyBuXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ21vc3QnLCBhc3NlcnRNb3N0KTtcbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnbHRlJywgYXNzZXJ0TW9zdCk7XG5cbiAgLyoqXG4gICAqICMjIyAud2l0aGluKHN0YXJ0LCBmaW5pc2gpXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIHdpdGhpbiBhIHJhbmdlLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KDcpLnRvLmJlLndpdGhpbig1LDEwKTtcbiAgICpcbiAgICogQ2FuIGFsc28gYmUgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIGBsZW5ndGhgIHRvXG4gICAqIGFzc2VydCBhIGxlbmd0aCByYW5nZS4gVGhlIGJlbmVmaXQgYmVpbmcgYVxuICAgKiBtb3JlIGluZm9ybWF0aXZlIGVycm9yIG1lc3NhZ2UgdGhhbiBpZiB0aGUgbGVuZ3RoXG4gICAqIHdhcyBzdXBwbGllZCBkaXJlY3RseS5cbiAgICpcbiAgICogICAgIGV4cGVjdCgnZm9vJykudG8uaGF2ZS5sZW5ndGgud2l0aGluKDIsNCk7XG4gICAqICAgICBleHBlY3QoWyAxLCAyLCAzIF0pLnRvLmhhdmUubGVuZ3RoLndpdGhpbigyLDQpO1xuICAgKlxuICAgKiBAbmFtZSB3aXRoaW5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0IGxvd2VyYm91bmQgaW5jbHVzaXZlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBmaW5pc2ggdXBwZXJib3VuZCBpbmNsdXNpdmVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkTWV0aG9kKCd3aXRoaW4nLCBmdW5jdGlvbiAoc3RhcnQsIGZpbmlzaCwgbXNnKSB7XG4gICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgICAsIHJhbmdlID0gc3RhcnQgKyAnLi4nICsgZmluaXNoO1xuICAgIGlmIChmbGFnKHRoaXMsICdkb0xlbmd0aCcpKSB7XG4gICAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnKS50by5oYXZlLnByb3BlcnR5KCdsZW5ndGgnKTtcbiAgICAgIHZhciBsZW4gPSBvYmoubGVuZ3RoO1xuICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICAgbGVuID49IHN0YXJ0ICYmIGxlbiA8PSBmaW5pc2hcbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBoYXZlIGEgbGVuZ3RoIHdpdGhpbiAnICsgcmFuZ2VcbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgaGF2ZSBhIGxlbmd0aCB3aXRoaW4gJyArIHJhbmdlXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgICBvYmogPj0gc3RhcnQgJiYgb2JqIDw9IGZpbmlzaFxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIHdpdGhpbiAnICsgcmFuZ2VcbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgYmUgd2l0aGluICcgKyByYW5nZVxuICAgICAgKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiAjIyMgLmluc3RhbmNlb2YoY29uc3RydWN0b3IpXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIGFuIGluc3RhbmNlIG9mIGBjb25zdHJ1Y3RvcmAuXG4gICAqXG4gICAqICAgICB2YXIgVGVhID0gZnVuY3Rpb24gKG5hbWUpIHsgdGhpcy5uYW1lID0gbmFtZTsgfVxuICAgKiAgICAgICAsIENoYWkgPSBuZXcgVGVhKCdjaGFpJyk7XG4gICAqXG4gICAqICAgICBleHBlY3QoQ2hhaSkudG8uYmUuYW4uaW5zdGFuY2VvZihUZWEpO1xuICAgKiAgICAgZXhwZWN0KFsgMSwgMiwgMyBdKS50by5iZS5pbnN0YW5jZW9mKEFycmF5KTtcbiAgICpcbiAgICogQG5hbWUgaW5zdGFuY2VvZlxuICAgKiBAcGFyYW0ge0NvbnN0cnVjdG9yfSBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBhbGlhcyBpbnN0YW5jZU9mXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGFzc2VydEluc3RhbmNlT2YgKGNvbnN0cnVjdG9yLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB2YXIgbmFtZSA9IF8uZ2V0TmFtZShjb25zdHJ1Y3Rvcik7XG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIGZsYWcodGhpcywgJ29iamVjdCcpIGluc3RhbmNlb2YgY29uc3RydWN0b3JcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgYW4gaW5zdGFuY2Ugb2YgJyArIG5hbWVcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGJlIGFuIGluc3RhbmNlIG9mICcgKyBuYW1lXG4gICAgKTtcbiAgfTtcblxuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdpbnN0YW5jZW9mJywgYXNzZXJ0SW5zdGFuY2VPZik7XG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2luc3RhbmNlT2YnLCBhc3NlcnRJbnN0YW5jZU9mKTtcblxuICAvKipcbiAgICogIyMjIC5wcm9wZXJ0eShuYW1lLCBbdmFsdWVdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBoYXMgYSBwcm9wZXJ0eSBgbmFtZWAsIG9wdGlvbmFsbHkgYXNzZXJ0aW5nIHRoYXRcbiAgICogdGhlIHZhbHVlIG9mIHRoYXQgcHJvcGVydHkgaXMgc3RyaWN0bHkgZXF1YWwgdG8gIGB2YWx1ZWAuXG4gICAqIElmIHRoZSBgZGVlcGAgZmxhZyBpcyBzZXQsIHlvdSBjYW4gdXNlIGRvdC0gYW5kIGJyYWNrZXQtbm90YXRpb24gZm9yIGRlZXBcbiAgICogcmVmZXJlbmNlcyBpbnRvIG9iamVjdHMgYW5kIGFycmF5cy5cbiAgICpcbiAgICogICAgIC8vIHNpbXBsZSByZWZlcmVuY2luZ1xuICAgKiAgICAgdmFyIG9iaiA9IHsgZm9vOiAnYmFyJyB9O1xuICAgKiAgICAgZXhwZWN0KG9iaikudG8uaGF2ZS5wcm9wZXJ0eSgnZm9vJyk7XG4gICAqICAgICBleHBlY3Qob2JqKS50by5oYXZlLnByb3BlcnR5KCdmb28nLCAnYmFyJyk7XG4gICAqXG4gICAqICAgICAvLyBkZWVwIHJlZmVyZW5jaW5nXG4gICAqICAgICB2YXIgZGVlcE9iaiA9IHtcbiAgICogICAgICAgICBncmVlbjogeyB0ZWE6ICdtYXRjaGEnIH1cbiAgICogICAgICAgLCB0ZWFzOiBbICdjaGFpJywgJ21hdGNoYScsIHsgdGVhOiAna29uYWNoYScgfSBdXG4gICAqICAgICB9O1xuXG4gICAqICAgICBleHBlY3QoZGVlcE9iaikudG8uaGF2ZS5kZWVwLnByb3BlcnR5KCdncmVlbi50ZWEnLCAnbWF0Y2hhJyk7XG4gICAqICAgICBleHBlY3QoZGVlcE9iaikudG8uaGF2ZS5kZWVwLnByb3BlcnR5KCd0ZWFzWzFdJywgJ21hdGNoYScpO1xuICAgKiAgICAgZXhwZWN0KGRlZXBPYmopLnRvLmhhdmUuZGVlcC5wcm9wZXJ0eSgndGVhc1syXS50ZWEnLCAna29uYWNoYScpO1xuICAgKlxuICAgKiBZb3UgY2FuIGFsc28gdXNlIGFuIGFycmF5IGFzIHRoZSBzdGFydGluZyBwb2ludCBvZiBhIGBkZWVwLnByb3BlcnR5YFxuICAgKiBhc3NlcnRpb24sIG9yIHRyYXZlcnNlIG5lc3RlZCBhcnJheXMuXG4gICAqXG4gICAqICAgICB2YXIgYXJyID0gW1xuICAgKiAgICAgICAgIFsgJ2NoYWknLCAnbWF0Y2hhJywgJ2tvbmFjaGEnIF1cbiAgICogICAgICAgLCBbIHsgdGVhOiAnY2hhaScgfVxuICAgKiAgICAgICAgICwgeyB0ZWE6ICdtYXRjaGEnIH1cbiAgICogICAgICAgICAsIHsgdGVhOiAna29uYWNoYScgfSBdXG4gICAqICAgICBdO1xuICAgKlxuICAgKiAgICAgZXhwZWN0KGFycikudG8uaGF2ZS5kZWVwLnByb3BlcnR5KCdbMF1bMV0nLCAnbWF0Y2hhJyk7XG4gICAqICAgICBleHBlY3QoYXJyKS50by5oYXZlLmRlZXAucHJvcGVydHkoJ1sxXVsyXS50ZWEnLCAna29uYWNoYScpO1xuICAgKlxuICAgKiBGdXJ0aGVybW9yZSwgYHByb3BlcnR5YCBjaGFuZ2VzIHRoZSBzdWJqZWN0IG9mIHRoZSBhc3NlcnRpb25cbiAgICogdG8gYmUgdGhlIHZhbHVlIG9mIHRoYXQgcHJvcGVydHkgZnJvbSB0aGUgb3JpZ2luYWwgb2JqZWN0LiBUaGlzXG4gICAqIHBlcm1pdHMgZm9yIGZ1cnRoZXIgY2hhaW5hYmxlIGFzc2VydGlvbnMgb24gdGhhdCBwcm9wZXJ0eS5cbiAgICpcbiAgICogICAgIGV4cGVjdChvYmopLnRvLmhhdmUucHJvcGVydHkoJ2ZvbycpXG4gICAqICAgICAgIC50aGF0LmlzLmEoJ3N0cmluZycpO1xuICAgKiAgICAgZXhwZWN0KGRlZXBPYmopLnRvLmhhdmUucHJvcGVydHkoJ2dyZWVuJylcbiAgICogICAgICAgLnRoYXQuaXMuYW4oJ29iamVjdCcpXG4gICAqICAgICAgIC50aGF0LmRlZXAuZXF1YWxzKHsgdGVhOiAnbWF0Y2hhJyB9KTtcbiAgICogICAgIGV4cGVjdChkZWVwT2JqKS50by5oYXZlLnByb3BlcnR5KCd0ZWFzJylcbiAgICogICAgICAgLnRoYXQuaXMuYW4oJ2FycmF5JylcbiAgICogICAgICAgLndpdGguZGVlcC5wcm9wZXJ0eSgnWzJdJylcbiAgICogICAgICAgICAudGhhdC5kZWVwLmVxdWFscyh7IHRlYTogJ2tvbmFjaGEnIH0pO1xuICAgKlxuICAgKiBAbmFtZSBwcm9wZXJ0eVxuICAgKiBAYWxpYXMgZGVlcC5wcm9wZXJ0eVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZSAob3B0aW9uYWwpXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQHJldHVybnMgdmFsdWUgb2YgcHJvcGVydHkgZm9yIGNoYWluaW5nXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ3Byb3BlcnR5JywgZnVuY3Rpb24gKG5hbWUsIHZhbCwgbXNnKSB7XG4gICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG5cbiAgICB2YXIgZGVzY3JpcHRvciA9IGZsYWcodGhpcywgJ2RlZXAnKSA/ICdkZWVwIHByb3BlcnR5ICcgOiAncHJvcGVydHkgJ1xuICAgICAgLCBuZWdhdGUgPSBmbGFnKHRoaXMsICduZWdhdGUnKVxuICAgICAgLCBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKVxuICAgICAgLCB2YWx1ZSA9IGZsYWcodGhpcywgJ2RlZXAnKVxuICAgICAgICA/IF8uZ2V0UGF0aFZhbHVlKG5hbWUsIG9iailcbiAgICAgICAgOiBvYmpbbmFtZV07XG5cbiAgICBpZiAobmVnYXRlICYmIHVuZGVmaW5lZCAhPT0gdmFsKSB7XG4gICAgICBpZiAodW5kZWZpbmVkID09PSB2YWx1ZSkge1xuICAgICAgICBtc2cgPSAobXNnICE9IG51bGwpID8gbXNnICsgJzogJyA6ICcnO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnICsgXy5pbnNwZWN0KG9iaikgKyAnIGhhcyBubyAnICsgZGVzY3JpcHRvciArIF8uaW5zcGVjdChuYW1lKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgIHVuZGVmaW5lZCAhPT0gdmFsdWVcbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBoYXZlIGEgJyArIGRlc2NyaXB0b3IgKyBfLmluc3BlY3QobmFtZSlcbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgaGF2ZSAnICsgZGVzY3JpcHRvciArIF8uaW5zcGVjdChuYW1lKSk7XG4gICAgfVxuXG4gICAgaWYgKHVuZGVmaW5lZCAhPT0gdmFsKSB7XG4gICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgICB2YWwgPT09IHZhbHVlXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gaGF2ZSBhICcgKyBkZXNjcmlwdG9yICsgXy5pbnNwZWN0KG5hbWUpICsgJyBvZiAje2V4cH0sIGJ1dCBnb3QgI3thY3R9J1xuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBoYXZlIGEgJyArIGRlc2NyaXB0b3IgKyBfLmluc3BlY3QobmFtZSkgKyAnIG9mICN7YWN0fSdcbiAgICAgICAgLCB2YWxcbiAgICAgICAgLCB2YWx1ZVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBmbGFnKHRoaXMsICdvYmplY3QnLCB2YWx1ZSk7XG4gIH0pO1xuXG5cbiAgLyoqXG4gICAqICMjIyAub3duUHJvcGVydHkobmFtZSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaGFzIGFuIG93biBwcm9wZXJ0eSBgbmFtZWAuXG4gICAqXG4gICAqICAgICBleHBlY3QoJ3Rlc3QnKS50by5oYXZlLm93blByb3BlcnR5KCdsZW5ndGgnKTtcbiAgICpcbiAgICogQG5hbWUgb3duUHJvcGVydHlcbiAgICogQGFsaWFzIGhhdmVPd25Qcm9wZXJ0eVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGFzc2VydE93blByb3BlcnR5IChuYW1lLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0Jyk7XG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIG9iai5oYXNPd25Qcm9wZXJ0eShuYW1lKVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBoYXZlIG93biBwcm9wZXJ0eSAnICsgXy5pbnNwZWN0KG5hbWUpXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBoYXZlIG93biBwcm9wZXJ0eSAnICsgXy5pbnNwZWN0KG5hbWUpXG4gICAgKTtcbiAgfVxuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ293blByb3BlcnR5JywgYXNzZXJ0T3duUHJvcGVydHkpO1xuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdoYXZlT3duUHJvcGVydHknLCBhc3NlcnRPd25Qcm9wZXJ0eSk7XG5cbiAgLyoqXG4gICAqICMjIyAubGVuZ3RoKHZhbHVlKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCdzIGBsZW5ndGhgIHByb3BlcnR5IGhhc1xuICAgKiB0aGUgZXhwZWN0ZWQgdmFsdWUuXG4gICAqXG4gICAqICAgICBleHBlY3QoWyAxLCAyLCAzXSkudG8uaGF2ZS5sZW5ndGgoMyk7XG4gICAqICAgICBleHBlY3QoJ2Zvb2JhcicpLnRvLmhhdmUubGVuZ3RoKDYpO1xuICAgKlxuICAgKiBDYW4gYWxzbyBiZSB1c2VkIGFzIGEgY2hhaW4gcHJlY3Vyc29yIHRvIGEgdmFsdWVcbiAgICogY29tcGFyaXNvbiBmb3IgdGhlIGxlbmd0aCBwcm9wZXJ0eS5cbiAgICpcbiAgICogICAgIGV4cGVjdCgnZm9vJykudG8uaGF2ZS5sZW5ndGguYWJvdmUoMik7XG4gICAqICAgICBleHBlY3QoWyAxLCAyLCAzIF0pLnRvLmhhdmUubGVuZ3RoLmFib3ZlKDIpO1xuICAgKiAgICAgZXhwZWN0KCdmb28nKS50by5oYXZlLmxlbmd0aC5iZWxvdyg0KTtcbiAgICogICAgIGV4cGVjdChbIDEsIDIsIDMgXSkudG8uaGF2ZS5sZW5ndGguYmVsb3coNCk7XG4gICAqICAgICBleHBlY3QoJ2ZvbycpLnRvLmhhdmUubGVuZ3RoLndpdGhpbigyLDQpO1xuICAgKiAgICAgZXhwZWN0KFsgMSwgMiwgMyBdKS50by5oYXZlLmxlbmd0aC53aXRoaW4oMiw0KTtcbiAgICpcbiAgICogQG5hbWUgbGVuZ3RoXG4gICAqIEBhbGlhcyBsZW5ndGhPZlxuICAgKiBAcGFyYW0ge051bWJlcn0gbGVuZ3RoXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gYXNzZXJ0TGVuZ3RoQ2hhaW4gKCkge1xuICAgIGZsYWcodGhpcywgJ2RvTGVuZ3RoJywgdHJ1ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBhc3NlcnRMZW5ndGggKG4sIG1zZykge1xuICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKTtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnKS50by5oYXZlLnByb3BlcnR5KCdsZW5ndGgnKTtcbiAgICB2YXIgbGVuID0gb2JqLmxlbmd0aDtcblxuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICBsZW4gPT0gblxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBoYXZlIGEgbGVuZ3RoIG9mICN7ZXhwfSBidXQgZ290ICN7YWN0fSdcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGhhdmUgYSBsZW5ndGggb2YgI3thY3R9J1xuICAgICAgLCBuXG4gICAgICAsIGxlblxuICAgICk7XG4gIH1cblxuICBBc3NlcnRpb24uYWRkQ2hhaW5hYmxlTWV0aG9kKCdsZW5ndGgnLCBhc3NlcnRMZW5ndGgsIGFzc2VydExlbmd0aENoYWluKTtcbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnbGVuZ3RoT2YnLCBhc3NlcnRMZW5ndGgsIGFzc2VydExlbmd0aENoYWluKTtcblxuICAvKipcbiAgICogIyMjIC5tYXRjaChyZWdleHApXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IG1hdGNoZXMgYSByZWd1bGFyIGV4cHJlc3Npb24uXG4gICAqXG4gICAqICAgICBleHBlY3QoJ2Zvb2JhcicpLnRvLm1hdGNoKC9eZm9vLyk7XG4gICAqXG4gICAqIEBuYW1lIG1hdGNoXG4gICAqIEBwYXJhbSB7UmVnRXhwfSBSZWd1bGFyRXhwcmVzc2lvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ21hdGNoJywgZnVuY3Rpb24gKHJlLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0Jyk7XG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIHJlLmV4ZWMob2JqKVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBtYXRjaCAnICsgcmVcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gbm90IHRvIG1hdGNoICcgKyByZVxuICAgICk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiAjIyMgLnN0cmluZyhzdHJpbmcpXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgc3RyaW5nIHRhcmdldCBjb250YWlucyBhbm90aGVyIHN0cmluZy5cbiAgICpcbiAgICogICAgIGV4cGVjdCgnZm9vYmFyJykudG8uaGF2ZS5zdHJpbmcoJ2JhcicpO1xuICAgKlxuICAgKiBAbmFtZSBzdHJpbmdcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZ1xuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ3N0cmluZycsIGZ1bmN0aW9uIChzdHIsIG1zZykge1xuICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKTtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnKS5pcy5hKCdzdHJpbmcnKTtcblxuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICB+b2JqLmluZGV4T2Yoc3RyKVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBjb250YWluICcgKyBfLmluc3BlY3Qoc3RyKVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgY29udGFpbiAnICsgXy5pbnNwZWN0KHN0cilcbiAgICApO1xuICB9KTtcblxuXG4gIC8qKlxuICAgKiAjIyMgLmtleXMoa2V5MSwgW2tleTJdLCBbLi4uXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaGFzIGV4YWN0bHkgdGhlIGdpdmVuIGtleXMsIG9yXG4gICAqIGFzc2VydHMgdGhlIGluY2x1c2lvbiBvZiBzb21lIGtleXMgd2hlbiB1c2luZyB0aGVcbiAgICogYGluY2x1ZGVgIG9yIGBjb250YWluYCBtb2RpZmllcnMuXG4gICAqXG4gICAqICAgICBleHBlY3QoeyBmb286IDEsIGJhcjogMiB9KS50by5oYXZlLmtleXMoWydmb28nLCAnYmFyJ10pO1xuICAgKiAgICAgZXhwZWN0KHsgZm9vOiAxLCBiYXI6IDIsIGJhejogMyB9KS50by5jb250YWluLmtleXMoJ2ZvbycsICdiYXInKTtcbiAgICpcbiAgICogQG5hbWUga2V5c1xuICAgKiBAYWxpYXMga2V5XG4gICAqIEBwYXJhbSB7U3RyaW5nLi4ufEFycmF5fSBrZXlzXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGFzc2VydEtleXMgKGtleXMpIHtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0JylcbiAgICAgICwgc3RyXG4gICAgICAsIG9rID0gdHJ1ZTtcblxuICAgIGtleXMgPSBrZXlzIGluc3RhbmNlb2YgQXJyYXlcbiAgICAgID8ga2V5c1xuICAgICAgOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXG4gICAgaWYgKCFrZXlzLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKCdrZXlzIHJlcXVpcmVkJyk7XG5cbiAgICB2YXIgYWN0dWFsID0gT2JqZWN0LmtleXMob2JqKVxuICAgICAgLCBsZW4gPSBrZXlzLmxlbmd0aDtcblxuICAgIC8vIEluY2x1c2lvblxuICAgIG9rID0ga2V5cy5ldmVyeShmdW5jdGlvbihrZXkpe1xuICAgICAgcmV0dXJuIH5hY3R1YWwuaW5kZXhPZihrZXkpO1xuICAgIH0pO1xuXG4gICAgLy8gU3RyaWN0XG4gICAgaWYgKCFmbGFnKHRoaXMsICduZWdhdGUnKSAmJiAhZmxhZyh0aGlzLCAnY29udGFpbnMnKSkge1xuICAgICAgb2sgPSBvayAmJiBrZXlzLmxlbmd0aCA9PSBhY3R1YWwubGVuZ3RoO1xuICAgIH1cblxuICAgIC8vIEtleSBzdHJpbmdcbiAgICBpZiAobGVuID4gMSkge1xuICAgICAga2V5cyA9IGtleXMubWFwKGZ1bmN0aW9uKGtleSl7XG4gICAgICAgIHJldHVybiBfLmluc3BlY3Qoa2V5KTtcbiAgICAgIH0pO1xuICAgICAgdmFyIGxhc3QgPSBrZXlzLnBvcCgpO1xuICAgICAgc3RyID0ga2V5cy5qb2luKCcsICcpICsgJywgYW5kICcgKyBsYXN0O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBfLmluc3BlY3Qoa2V5c1swXSk7XG4gICAgfVxuXG4gICAgLy8gRm9ybVxuICAgIHN0ciA9IChsZW4gPiAxID8gJ2tleXMgJyA6ICdrZXkgJykgKyBzdHI7XG5cbiAgICAvLyBIYXZlIC8gaW5jbHVkZVxuICAgIHN0ciA9IChmbGFnKHRoaXMsICdjb250YWlucycpID8gJ2NvbnRhaW4gJyA6ICdoYXZlICcpICsgc3RyO1xuXG4gICAgLy8gQXNzZXJ0aW9uXG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIG9rXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvICcgKyBzdHJcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90ICcgKyBzdHJcbiAgICApO1xuICB9XG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgna2V5cycsIGFzc2VydEtleXMpO1xuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdrZXknLCBhc3NlcnRLZXlzKTtcblxuICAvKipcbiAgICogIyMjIC50aHJvdyhjb25zdHJ1Y3RvcilcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSBmdW5jdGlvbiB0YXJnZXQgd2lsbCB0aHJvdyBhIHNwZWNpZmljIGVycm9yLCBvciBzcGVjaWZpYyB0eXBlIG9mIGVycm9yXG4gICAqIChhcyBkZXRlcm1pbmVkIHVzaW5nIGBpbnN0YW5jZW9mYCksIG9wdGlvbmFsbHkgd2l0aCBhIFJlZ0V4cCBvciBzdHJpbmcgaW5jbHVzaW9uIHRlc3RcbiAgICogZm9yIHRoZSBlcnJvcidzIG1lc3NhZ2UuXG4gICAqXG4gICAqICAgICB2YXIgZXJyID0gbmV3IFJlZmVyZW5jZUVycm9yKCdUaGlzIGlzIGEgYmFkIGZ1bmN0aW9uLicpO1xuICAgKiAgICAgdmFyIGZuID0gZnVuY3Rpb24gKCkgeyB0aHJvdyBlcnI7IH1cbiAgICogICAgIGV4cGVjdChmbikudG8udGhyb3coUmVmZXJlbmNlRXJyb3IpO1xuICAgKiAgICAgZXhwZWN0KGZuKS50by50aHJvdyhFcnJvcik7XG4gICAqICAgICBleHBlY3QoZm4pLnRvLnRocm93KC9iYWQgZnVuY3Rpb24vKTtcbiAgICogICAgIGV4cGVjdChmbikudG8ubm90LnRocm93KCdnb29kIGZ1bmN0aW9uJyk7XG4gICAqICAgICBleHBlY3QoZm4pLnRvLnRocm93KFJlZmVyZW5jZUVycm9yLCAvYmFkIGZ1bmN0aW9uLyk7XG4gICAqICAgICBleHBlY3QoZm4pLnRvLnRocm93KGVycik7XG4gICAqICAgICBleHBlY3QoZm4pLnRvLm5vdC50aHJvdyhuZXcgUmFuZ2VFcnJvcignT3V0IG9mIHJhbmdlLicpKTtcbiAgICpcbiAgICogUGxlYXNlIG5vdGUgdGhhdCB3aGVuIGEgdGhyb3cgZXhwZWN0YXRpb24gaXMgbmVnYXRlZCwgaXQgd2lsbCBjaGVjayBlYWNoXG4gICAqIHBhcmFtZXRlciBpbmRlcGVuZGVudGx5LCBzdGFydGluZyB3aXRoIGVycm9yIGNvbnN0cnVjdG9yIHR5cGUuIFRoZSBhcHByb3ByaWF0ZSB3YXlcbiAgICogdG8gY2hlY2sgZm9yIHRoZSBleGlzdGVuY2Ugb2YgYSB0eXBlIG9mIGVycm9yIGJ1dCBmb3IgYSBtZXNzYWdlIHRoYXQgZG9lcyBub3QgbWF0Y2hcbiAgICogaXMgdG8gdXNlIGBhbmRgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KGZuKS50by50aHJvdyhSZWZlcmVuY2VFcnJvcilcbiAgICogICAgICAgIC5hbmQubm90LnRocm93KC9nb29kIGZ1bmN0aW9uLyk7XG4gICAqXG4gICAqIEBuYW1lIHRocm93XG4gICAqIEBhbGlhcyB0aHJvd3NcbiAgICogQGFsaWFzIFRocm93XG4gICAqIEBwYXJhbSB7RXJyb3JDb25zdHJ1Y3Rvcn0gY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtTdHJpbmd8UmVnRXhwfSBleHBlY3RlZCBlcnJvciBtZXNzYWdlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9FcnJvciNFcnJvcl90eXBlc1xuICAgKiBAcmV0dXJucyBlcnJvciBmb3IgY2hhaW5pbmcgKG51bGwgaWYgbm8gZXJyb3IpXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGFzc2VydFRocm93cyAoY29uc3RydWN0b3IsIGVyck1zZywgbXNnKSB7XG4gICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpO1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2cpLmlzLmEoJ2Z1bmN0aW9uJyk7XG5cbiAgICB2YXIgdGhyb3duID0gZmFsc2VcbiAgICAgICwgZGVzaXJlZEVycm9yID0gbnVsbFxuICAgICAgLCBuYW1lID0gbnVsbFxuICAgICAgLCB0aHJvd25FcnJvciA9IG51bGw7XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgZXJyTXNnID0gbnVsbDtcbiAgICAgIGNvbnN0cnVjdG9yID0gbnVsbDtcbiAgICB9IGVsc2UgaWYgKGNvbnN0cnVjdG9yICYmIChjb25zdHJ1Y3RvciBpbnN0YW5jZW9mIFJlZ0V4cCB8fCAnc3RyaW5nJyA9PT0gdHlwZW9mIGNvbnN0cnVjdG9yKSkge1xuICAgICAgZXJyTXNnID0gY29uc3RydWN0b3I7XG4gICAgICBjb25zdHJ1Y3RvciA9IG51bGw7XG4gICAgfSBlbHNlIGlmIChjb25zdHJ1Y3RvciAmJiBjb25zdHJ1Y3RvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICBkZXNpcmVkRXJyb3IgPSBjb25zdHJ1Y3RvcjtcbiAgICAgIGNvbnN0cnVjdG9yID0gbnVsbDtcbiAgICAgIGVyck1zZyA9IG51bGw7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgY29uc3RydWN0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG5hbWUgPSBjb25zdHJ1Y3Rvci5wcm90b3R5cGUubmFtZSB8fCBjb25zdHJ1Y3Rvci5uYW1lO1xuICAgICAgaWYgKG5hbWUgPT09ICdFcnJvcicgJiYgY29uc3RydWN0b3IgIT09IEVycm9yKSB7XG4gICAgICAgIG5hbWUgPSAobmV3IGNvbnN0cnVjdG9yKCkpLm5hbWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0cnVjdG9yID0gbnVsbDtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgb2JqKCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAvLyBmaXJzdCwgY2hlY2sgZGVzaXJlZCBlcnJvclxuICAgICAgaWYgKGRlc2lyZWRFcnJvcikge1xuICAgICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgICAgIGVyciA9PT0gZGVzaXJlZEVycm9yXG4gICAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byB0aHJvdyAje2V4cH0gYnV0ICN7YWN0fSB3YXMgdGhyb3duJ1xuICAgICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IHRocm93ICN7ZXhwfSdcbiAgICAgICAgICAsIChkZXNpcmVkRXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGRlc2lyZWRFcnJvci50b1N0cmluZygpIDogZGVzaXJlZEVycm9yKVxuICAgICAgICAgICwgKGVyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyLnRvU3RyaW5nKCkgOiBlcnIpXG4gICAgICAgICk7XG5cbiAgICAgICAgZmxhZyh0aGlzLCAnb2JqZWN0JywgZXJyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIC8vIG5leHQsIGNoZWNrIGNvbnN0cnVjdG9yXG4gICAgICBpZiAoY29uc3RydWN0b3IpIHtcbiAgICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICAgICBlcnIgaW5zdGFuY2VvZiBjb25zdHJ1Y3RvclxuICAgICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gdGhyb3cgI3tleHB9IGJ1dCAje2FjdH0gd2FzIHRocm93bidcbiAgICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCB0aHJvdyAje2V4cH0gYnV0ICN7YWN0fSB3YXMgdGhyb3duJ1xuICAgICAgICAgICwgbmFtZVxuICAgICAgICAgICwgKGVyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyLnRvU3RyaW5nKCkgOiBlcnIpXG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKCFlcnJNc2cpIHtcbiAgICAgICAgICBmbGFnKHRoaXMsICdvYmplY3QnLCBlcnIpO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIG5leHQsIGNoZWNrIG1lc3NhZ2VcbiAgICAgIHZhciBtZXNzYWdlID0gJ29iamVjdCcgPT09IF8udHlwZShlcnIpICYmIFwibWVzc2FnZVwiIGluIGVyclxuICAgICAgICA/IGVyci5tZXNzYWdlXG4gICAgICAgIDogJycgKyBlcnI7XG5cbiAgICAgIGlmICgobWVzc2FnZSAhPSBudWxsKSAmJiBlcnJNc2cgJiYgZXJyTXNnIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgICAgZXJyTXNnLmV4ZWMobWVzc2FnZSlcbiAgICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIHRocm93IGVycm9yIG1hdGNoaW5nICN7ZXhwfSBidXQgZ290ICN7YWN0fSdcbiAgICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIHRocm93IGVycm9yIG5vdCBtYXRjaGluZyAje2V4cH0nXG4gICAgICAgICAgLCBlcnJNc2dcbiAgICAgICAgICAsIG1lc3NhZ2VcbiAgICAgICAgKTtcblxuICAgICAgICBmbGFnKHRoaXMsICdvYmplY3QnLCBlcnIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0gZWxzZSBpZiAoKG1lc3NhZ2UgIT0gbnVsbCkgJiYgZXJyTXNnICYmICdzdHJpbmcnID09PSB0eXBlb2YgZXJyTXNnKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgICAgfm1lc3NhZ2UuaW5kZXhPZihlcnJNc2cpXG4gICAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byB0aHJvdyBlcnJvciBpbmNsdWRpbmcgI3tleHB9IGJ1dCBnb3QgI3thY3R9J1xuICAgICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gdGhyb3cgZXJyb3Igbm90IGluY2x1ZGluZyAje2FjdH0nXG4gICAgICAgICAgLCBlcnJNc2dcbiAgICAgICAgICAsIG1lc3NhZ2VcbiAgICAgICAgKTtcblxuICAgICAgICBmbGFnKHRoaXMsICdvYmplY3QnLCBlcnIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93biA9IHRydWU7XG4gICAgICAgIHRocm93bkVycm9yID0gZXJyO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBhY3R1YWxseUdvdCA9ICcnXG4gICAgICAsIGV4cGVjdGVkVGhyb3duID0gbmFtZSAhPT0gbnVsbFxuICAgICAgICA/IG5hbWVcbiAgICAgICAgOiBkZXNpcmVkRXJyb3JcbiAgICAgICAgICA/ICcje2V4cH0nIC8vXy5pbnNwZWN0KGRlc2lyZWRFcnJvcilcbiAgICAgICAgICA6ICdhbiBlcnJvcic7XG5cbiAgICBpZiAodGhyb3duKSB7XG4gICAgICBhY3R1YWxseUdvdCA9ICcgYnV0ICN7YWN0fSB3YXMgdGhyb3duJ1xuICAgIH1cblxuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICB0aHJvd24gPT09IHRydWVcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gdGhyb3cgJyArIGV4cGVjdGVkVGhyb3duICsgYWN0dWFsbHlHb3RcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IHRocm93ICcgKyBleHBlY3RlZFRocm93biArIGFjdHVhbGx5R290XG4gICAgICAsIChkZXNpcmVkRXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGRlc2lyZWRFcnJvci50b1N0cmluZygpIDogZGVzaXJlZEVycm9yKVxuICAgICAgLCAodGhyb3duRXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IHRocm93bkVycm9yLnRvU3RyaW5nKCkgOiB0aHJvd25FcnJvcilcbiAgICApO1xuXG4gICAgZmxhZyh0aGlzLCAnb2JqZWN0JywgdGhyb3duRXJyb3IpO1xuICB9O1xuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ3Rocm93JywgYXNzZXJ0VGhyb3dzKTtcbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgndGhyb3dzJywgYXNzZXJ0VGhyb3dzKTtcbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnVGhyb3cnLCBhc3NlcnRUaHJvd3MpO1xuXG4gIC8qKlxuICAgKiAjIyMgLnJlc3BvbmRUbyhtZXRob2QpXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgb2JqZWN0IG9yIGNsYXNzIHRhcmdldCB3aWxsIHJlc3BvbmQgdG8gYSBtZXRob2QuXG4gICAqXG4gICAqICAgICBLbGFzcy5wcm90b3R5cGUuYmFyID0gZnVuY3Rpb24oKXt9O1xuICAgKiAgICAgZXhwZWN0KEtsYXNzKS50by5yZXNwb25kVG8oJ2JhcicpO1xuICAgKiAgICAgZXhwZWN0KG9iaikudG8ucmVzcG9uZFRvKCdiYXInKTtcbiAgICpcbiAgICogVG8gY2hlY2sgaWYgYSBjb25zdHJ1Y3RvciB3aWxsIHJlc3BvbmQgdG8gYSBzdGF0aWMgZnVuY3Rpb24sXG4gICAqIHNldCB0aGUgYGl0c2VsZmAgZmxhZy5cbiAgICpcbiAgICogICAgIEtsYXNzLmJheiA9IGZ1bmN0aW9uKCl7fTtcbiAgICogICAgIGV4cGVjdChLbGFzcykuaXRzZWxmLnRvLnJlc3BvbmRUbygnYmF6Jyk7XG4gICAqXG4gICAqIEBuYW1lIHJlc3BvbmRUb1xuICAgKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgncmVzcG9uZFRvJywgZnVuY3Rpb24gKG1ldGhvZCwgbXNnKSB7XG4gICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgICAsIGl0c2VsZiA9IGZsYWcodGhpcywgJ2l0c2VsZicpXG4gICAgICAsIGNvbnRleHQgPSAoJ2Z1bmN0aW9uJyA9PT0gXy50eXBlKG9iaikgJiYgIWl0c2VsZilcbiAgICAgICAgPyBvYmoucHJvdG90eXBlW21ldGhvZF1cbiAgICAgICAgOiBvYmpbbWV0aG9kXTtcblxuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAnZnVuY3Rpb24nID09PSB0eXBlb2YgY29udGV4dFxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byByZXNwb25kIHRvICcgKyBfLmluc3BlY3QobWV0aG9kKVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgcmVzcG9uZCB0byAnICsgXy5pbnNwZWN0KG1ldGhvZClcbiAgICApO1xuICB9KTtcblxuICAvKipcbiAgICogIyMjIC5pdHNlbGZcbiAgICpcbiAgICogU2V0cyB0aGUgYGl0c2VsZmAgZmxhZywgbGF0ZXIgdXNlZCBieSB0aGUgYHJlc3BvbmRUb2AgYXNzZXJ0aW9uLlxuICAgKlxuICAgKiAgICAgZnVuY3Rpb24gRm9vKCkge31cbiAgICogICAgIEZvby5iYXIgPSBmdW5jdGlvbigpIHt9XG4gICAqICAgICBGb28ucHJvdG90eXBlLmJheiA9IGZ1bmN0aW9uKCkge31cbiAgICpcbiAgICogICAgIGV4cGVjdChGb28pLml0c2VsZi50by5yZXNwb25kVG8oJ2JhcicpO1xuICAgKiAgICAgZXhwZWN0KEZvbykuaXRzZWxmLm5vdC50by5yZXNwb25kVG8oJ2JheicpO1xuICAgKlxuICAgKiBAbmFtZSBpdHNlbGZcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQXNzZXJ0aW9uLmFkZFByb3BlcnR5KCdpdHNlbGYnLCBmdW5jdGlvbiAoKSB7XG4gICAgZmxhZyh0aGlzLCAnaXRzZWxmJywgdHJ1ZSk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiAjIyMgLnNhdGlzZnkobWV0aG9kKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBwYXNzZXMgYSBnaXZlbiB0cnV0aCB0ZXN0LlxuICAgKlxuICAgKiAgICAgZXhwZWN0KDEpLnRvLnNhdGlzZnkoZnVuY3Rpb24obnVtKSB7IHJldHVybiBudW0gPiAwOyB9KTtcbiAgICpcbiAgICogQG5hbWUgc2F0aXNmeVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBtYXRjaGVyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnc2F0aXNmeScsIGZ1bmN0aW9uIChtYXRjaGVyLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0Jyk7XG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIG1hdGNoZXIob2JqKVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBzYXRpc2Z5ICcgKyBfLm9iakRpc3BsYXkobWF0Y2hlcilcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IHNhdGlzZnknICsgXy5vYmpEaXNwbGF5KG1hdGNoZXIpXG4gICAgICAsIHRoaXMubmVnYXRlID8gZmFsc2UgOiB0cnVlXG4gICAgICAsIG1hdGNoZXIob2JqKVxuICAgICk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiAjIyMgLmNsb3NlVG8oZXhwZWN0ZWQsIGRlbHRhKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyBlcXVhbCBgZXhwZWN0ZWRgLCB0byB3aXRoaW4gYSArLy0gYGRlbHRhYCByYW5nZS5cbiAgICpcbiAgICogICAgIGV4cGVjdCgxLjUpLnRvLmJlLmNsb3NlVG8oMSwgMC41KTtcbiAgICpcbiAgICogQG5hbWUgY2xvc2VUb1xuICAgKiBAcGFyYW0ge051bWJlcn0gZXhwZWN0ZWRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGRlbHRhXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnY2xvc2VUbycsIGZ1bmN0aW9uIChleHBlY3RlZCwgZGVsdGEsIG1zZykge1xuICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKTtcbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgTWF0aC5hYnMob2JqIC0gZXhwZWN0ZWQpIDw9IGRlbHRhXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIGNsb3NlIHRvICcgKyBleHBlY3RlZCArICcgKy8tICcgKyBkZWx0YVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSBub3QgdG8gYmUgY2xvc2UgdG8gJyArIGV4cGVjdGVkICsgJyArLy0gJyArIGRlbHRhXG4gICAgKTtcbiAgfSk7XG5cbiAgZnVuY3Rpb24gaXNTdWJzZXRPZihzdWJzZXQsIHN1cGVyc2V0LCBjbXApIHtcbiAgICByZXR1cm4gc3Vic2V0LmV2ZXJ5KGZ1bmN0aW9uKGVsZW0pIHtcbiAgICAgIGlmICghY21wKSByZXR1cm4gc3VwZXJzZXQuaW5kZXhPZihlbGVtKSAhPT0gLTE7XG5cbiAgICAgIHJldHVybiBzdXBlcnNldC5zb21lKGZ1bmN0aW9uKGVsZW0yKSB7XG4gICAgICAgIHJldHVybiBjbXAoZWxlbSwgZWxlbTIpO1xuICAgICAgfSk7XG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiAjIyMgLm1lbWJlcnMoc2V0KVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyBhIHN1cGVyc2V0IG9mIGBzZXRgLFxuICAgKiBvciB0aGF0IHRoZSB0YXJnZXQgYW5kIGBzZXRgIGhhdmUgdGhlIHNhbWUgc3RyaWN0bHktZXF1YWwgKD09PSkgbWVtYmVycy5cbiAgICogQWx0ZXJuYXRlbHksIGlmIHRoZSBgZGVlcGAgZmxhZyBpcyBzZXQsIHNldCBtZW1iZXJzIGFyZSBjb21wYXJlZCBmb3IgZGVlcFxuICAgKiBlcXVhbGl0eS5cbiAgICpcbiAgICogICAgIGV4cGVjdChbMSwgMiwgM10pLnRvLmluY2x1ZGUubWVtYmVycyhbMywgMl0pO1xuICAgKiAgICAgZXhwZWN0KFsxLCAyLCAzXSkudG8ubm90LmluY2x1ZGUubWVtYmVycyhbMywgMiwgOF0pO1xuICAgKlxuICAgKiAgICAgZXhwZWN0KFs0LCAyXSkudG8uaGF2ZS5tZW1iZXJzKFsyLCA0XSk7XG4gICAqICAgICBleHBlY3QoWzUsIDJdKS50by5ub3QuaGF2ZS5tZW1iZXJzKFs1LCAyLCAxXSk7XG4gICAqXG4gICAqICAgICBleHBlY3QoW3sgaWQ6IDEgfV0pLnRvLmRlZXAuaW5jbHVkZS5tZW1iZXJzKFt7IGlkOiAxIH1dKTtcbiAgICpcbiAgICogQG5hbWUgbWVtYmVyc1xuICAgKiBAcGFyYW0ge0FycmF5fSBzZXRcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdtZW1iZXJzJywgZnVuY3Rpb24gKHN1YnNldCwgbXNnKSB7XG4gICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpO1xuXG4gICAgbmV3IEFzc2VydGlvbihvYmopLnRvLmJlLmFuKCdhcnJheScpO1xuICAgIG5ldyBBc3NlcnRpb24oc3Vic2V0KS50by5iZS5hbignYXJyYXknKTtcblxuICAgIHZhciBjbXAgPSBmbGFnKHRoaXMsICdkZWVwJykgPyBfLmVxbCA6IHVuZGVmaW5lZDtcblxuICAgIGlmIChmbGFnKHRoaXMsICdjb250YWlucycpKSB7XG4gICAgICByZXR1cm4gdGhpcy5hc3NlcnQoXG4gICAgICAgICAgaXNTdWJzZXRPZihzdWJzZXQsIG9iaiwgY21wKVxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIGEgc3VwZXJzZXQgb2YgI3thY3R9J1xuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBiZSBhIHN1cGVyc2V0IG9mICN7YWN0fSdcbiAgICAgICAgLCBvYmpcbiAgICAgICAgLCBzdWJzZXRcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIGlzU3Vic2V0T2Yob2JqLCBzdWJzZXQsIGNtcCkgJiYgaXNTdWJzZXRPZihzdWJzZXQsIG9iaiwgY21wKVxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGhhdmUgdGhlIHNhbWUgbWVtYmVycyBhcyAje2FjdH0nXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGhhdmUgdGhlIHNhbWUgbWVtYmVycyBhcyAje2FjdH0nXG4gICAgICAgICwgb2JqXG4gICAgICAgICwgc3Vic2V0XG4gICAgKTtcbiAgfSk7XG59O1xuIiwiLyohXG4gKiBjaGFpXG4gKiBDb3B5cmlnaHQoYykgMjAxMS0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjaGFpLCB1dGlsKSB7XG5cbiAgLyohXG4gICAqIENoYWkgZGVwZW5kZW5jaWVzLlxuICAgKi9cblxuICB2YXIgQXNzZXJ0aW9uID0gY2hhaS5Bc3NlcnRpb25cbiAgICAsIGZsYWcgPSB1dGlsLmZsYWc7XG5cbiAgLyohXG4gICAqIE1vZHVsZSBleHBvcnQuXG4gICAqL1xuXG4gIC8qKlxuICAgKiAjIyMgYXNzZXJ0KGV4cHJlc3Npb24sIG1lc3NhZ2UpXG4gICAqXG4gICAqIFdyaXRlIHlvdXIgb3duIHRlc3QgZXhwcmVzc2lvbnMuXG4gICAqXG4gICAqICAgICBhc3NlcnQoJ2ZvbycgIT09ICdiYXInLCAnZm9vIGlzIG5vdCBiYXInKTtcbiAgICogICAgIGFzc2VydChBcnJheS5pc0FycmF5KFtdKSwgJ2VtcHR5IGFycmF5cyBhcmUgYXJyYXlzJyk7XG4gICAqXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGV4cHJlc3Npb24gdG8gdGVzdCBmb3IgdHJ1dGhpbmVzc1xuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSB0byBkaXNwbGF5IG9uIGVycm9yXG4gICAqIEBuYW1lIGFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICB2YXIgYXNzZXJ0ID0gY2hhaS5hc3NlcnQgPSBmdW5jdGlvbiAoZXhwcmVzcywgZXJybXNnKSB7XG4gICAgdmFyIHRlc3QgPSBuZXcgQXNzZXJ0aW9uKG51bGwsIG51bGwsIGNoYWkuYXNzZXJ0KTtcbiAgICB0ZXN0LmFzc2VydChcbiAgICAgICAgZXhwcmVzc1xuICAgICAgLCBlcnJtc2dcbiAgICAgICwgJ1sgbmVnYXRpb24gbWVzc2FnZSB1bmF2YWlsYWJsZSBdJ1xuICAgICk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBbbWVzc2FnZV0sIFtvcGVyYXRvcl0pXG4gICAqXG4gICAqIFRocm93IGEgZmFpbHVyZS4gTm9kZS5qcyBgYXNzZXJ0YCBtb2R1bGUtY29tcGF0aWJsZS5cbiAgICpcbiAgICogQG5hbWUgZmFpbFxuICAgKiBAcGFyYW0ge01peGVkfSBhY3R1YWxcbiAgICogQHBhcmFtIHtNaXhlZH0gZXhwZWN0ZWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQHBhcmFtIHtTdHJpbmd9IG9wZXJhdG9yXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5mYWlsID0gZnVuY3Rpb24gKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsIG9wZXJhdG9yKSB7XG4gICAgbWVzc2FnZSA9IG1lc3NhZ2UgfHwgJ2Fzc2VydC5mYWlsKCknO1xuICAgIHRocm93IG5ldyBjaGFpLkFzc2VydGlvbkVycm9yKG1lc3NhZ2UsIHtcbiAgICAgICAgYWN0dWFsOiBhY3R1YWxcbiAgICAgICwgZXhwZWN0ZWQ6IGV4cGVjdGVkXG4gICAgICAsIG9wZXJhdG9yOiBvcGVyYXRvclxuICAgIH0sIGFzc2VydC5mYWlsKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5vayhvYmplY3QsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGlzIHRydXRoeS5cbiAgICpcbiAgICogICAgIGFzc2VydC5vaygnZXZlcnl0aGluZycsICdldmVyeXRoaW5nIGlzIG9rJyk7XG4gICAqICAgICBhc3NlcnQub2soZmFsc2UsICd0aGlzIHdpbGwgZmFpbCcpO1xuICAgKlxuICAgKiBAbmFtZSBva1xuICAgKiBAcGFyYW0ge01peGVkfSBvYmplY3QgdG8gdGVzdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQub2sgPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnKS5pcy5vaztcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5ub3RPayhvYmplY3QsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGlzIGZhbHN5LlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lm5vdE9rKCdldmVyeXRoaW5nJywgJ3RoaXMgd2lsbCBmYWlsJyk7XG4gICAqICAgICBhc3NlcnQubm90T2soZmFsc2UsICd0aGlzIHdpbGwgcGFzcycpO1xuICAgKlxuICAgKiBAbmFtZSBub3RPa1xuICAgKiBAcGFyYW0ge01peGVkfSBvYmplY3QgdG8gdGVzdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQubm90T2sgPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnKS5pcy5ub3Qub2s7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuZXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIG5vbi1zdHJpY3QgZXF1YWxpdHkgKGA9PWApIG9mIGBhY3R1YWxgIGFuZCBgZXhwZWN0ZWRgLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LmVxdWFsKDMsICczJywgJz09IGNvZXJjZXMgdmFsdWVzIHRvIHN0cmluZ3MnKTtcbiAgICpcbiAgICogQG5hbWUgZXF1YWxcbiAgICogQHBhcmFtIHtNaXhlZH0gYWN0dWFsXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGV4cGVjdGVkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5lcXVhbCA9IGZ1bmN0aW9uIChhY3QsIGV4cCwgbXNnKSB7XG4gICAgdmFyIHRlc3QgPSBuZXcgQXNzZXJ0aW9uKGFjdCwgbXNnLCBhc3NlcnQuZXF1YWwpO1xuXG4gICAgdGVzdC5hc3NlcnQoXG4gICAgICAgIGV4cCA9PSBmbGFnKHRlc3QsICdvYmplY3QnKVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBlcXVhbCAje2V4cH0nXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBlcXVhbCAje2FjdH0nXG4gICAgICAsIGV4cFxuICAgICAgLCBhY3RcbiAgICApO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLm5vdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyBub24tc3RyaWN0IGluZXF1YWxpdHkgKGAhPWApIG9mIGBhY3R1YWxgIGFuZCBgZXhwZWN0ZWRgLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lm5vdEVxdWFsKDMsIDQsICd0aGVzZSBudW1iZXJzIGFyZSBub3QgZXF1YWwnKTtcbiAgICpcbiAgICogQG5hbWUgbm90RXF1YWxcbiAgICogQHBhcmFtIHtNaXhlZH0gYWN0dWFsXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGV4cGVjdGVkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5ub3RFcXVhbCA9IGZ1bmN0aW9uIChhY3QsIGV4cCwgbXNnKSB7XG4gICAgdmFyIHRlc3QgPSBuZXcgQXNzZXJ0aW9uKGFjdCwgbXNnLCBhc3NlcnQubm90RXF1YWwpO1xuXG4gICAgdGVzdC5hc3NlcnQoXG4gICAgICAgIGV4cCAhPSBmbGFnKHRlc3QsICdvYmplY3QnKVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgZXF1YWwgI3tleHB9J1xuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBlcXVhbCAje2FjdH0nXG4gICAgICAsIGV4cFxuICAgICAgLCBhY3RcbiAgICApO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLnN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyBzdHJpY3QgZXF1YWxpdHkgKGA9PT1gKSBvZiBgYWN0dWFsYCBhbmQgYGV4cGVjdGVkYC5cbiAgICpcbiAgICogICAgIGFzc2VydC5zdHJpY3RFcXVhbCh0cnVlLCB0cnVlLCAndGhlc2UgYm9vbGVhbnMgYXJlIHN0cmljdGx5IGVxdWFsJyk7XG4gICAqXG4gICAqIEBuYW1lIHN0cmljdEVxdWFsXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGFjdHVhbFxuICAgKiBAcGFyYW0ge01peGVkfSBleHBlY3RlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuc3RyaWN0RXF1YWwgPSBmdW5jdGlvbiAoYWN0LCBleHAsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oYWN0LCBtc2cpLnRvLmVxdWFsKGV4cCk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAubm90U3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHN0cmljdCBpbmVxdWFsaXR5IChgIT09YCkgb2YgYGFjdHVhbGAgYW5kIGBleHBlY3RlZGAuXG4gICAqXG4gICAqICAgICBhc3NlcnQubm90U3RyaWN0RXF1YWwoMywgJzMnLCAnbm8gY29lcmNpb24gZm9yIHN0cmljdCBlcXVhbGl0eScpO1xuICAgKlxuICAgKiBAbmFtZSBub3RTdHJpY3RFcXVhbFxuICAgKiBAcGFyYW0ge01peGVkfSBhY3R1YWxcbiAgICogQHBhcmFtIHtNaXhlZH0gZXhwZWN0ZWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm5vdFN0cmljdEVxdWFsID0gZnVuY3Rpb24gKGFjdCwgZXhwLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKGFjdCwgbXNnKS50by5ub3QuZXF1YWwoZXhwKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYGFjdHVhbGAgaXMgZGVlcGx5IGVxdWFsIHRvIGBleHBlY3RlZGAuXG4gICAqXG4gICAqICAgICBhc3NlcnQuZGVlcEVxdWFsKHsgdGVhOiAnZ3JlZW4nIH0sIHsgdGVhOiAnZ3JlZW4nIH0pO1xuICAgKlxuICAgKiBAbmFtZSBkZWVwRXF1YWxcbiAgICogQHBhcmFtIHtNaXhlZH0gYWN0dWFsXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGV4cGVjdGVkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5kZWVwRXF1YWwgPSBmdW5jdGlvbiAoYWN0LCBleHAsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oYWN0LCBtc2cpLnRvLmVxbChleHApO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLm5vdERlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydCB0aGF0IGBhY3R1YWxgIGlzIG5vdCBkZWVwbHkgZXF1YWwgdG8gYGV4cGVjdGVkYC5cbiAgICpcbiAgICogICAgIGFzc2VydC5ub3REZWVwRXF1YWwoeyB0ZWE6ICdncmVlbicgfSwgeyB0ZWE6ICdqYXNtaW5lJyB9KTtcbiAgICpcbiAgICogQG5hbWUgbm90RGVlcEVxdWFsXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGFjdHVhbFxuICAgKiBAcGFyYW0ge01peGVkfSBleHBlY3RlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQubm90RGVlcEVxdWFsID0gZnVuY3Rpb24gKGFjdCwgZXhwLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKGFjdCwgbXNnKS50by5ub3QuZXFsKGV4cCk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNUcnVlKHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgIGlzIHRydWUuXG4gICAqXG4gICAqICAgICB2YXIgdGVhU2VydmVkID0gdHJ1ZTtcbiAgICogICAgIGFzc2VydC5pc1RydWUodGVhU2VydmVkLCAndGhlIHRlYSBoYXMgYmVlbiBzZXJ2ZWQnKTtcbiAgICpcbiAgICogQG5hbWUgaXNUcnVlXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc1RydWUgPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnKS5pc1sndHJ1ZSddO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzRmFsc2UodmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAgaXMgZmFsc2UuXG4gICAqXG4gICAqICAgICB2YXIgdGVhU2VydmVkID0gZmFsc2U7XG4gICAqICAgICBhc3NlcnQuaXNGYWxzZSh0ZWFTZXJ2ZWQsICdubyB0ZWEgeWV0PyBobW0uLi4nKTtcbiAgICpcbiAgICogQG5hbWUgaXNGYWxzZVxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNGYWxzZSA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2cpLmlzWydmYWxzZSddO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzTnVsbCh2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBpcyBudWxsLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LmlzTnVsbChlcnIsICd0aGVyZSB3YXMgbm8gZXJyb3InKTtcbiAgICpcbiAgICogQG5hbWUgaXNOdWxsXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc051bGwgPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnKS50by5lcXVhbChudWxsKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc05vdE51bGwodmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAgaXMgbm90IG51bGwuXG4gICAqXG4gICAqICAgICB2YXIgdGVhID0gJ3Rhc3R5IGNoYWknO1xuICAgKiAgICAgYXNzZXJ0LmlzTm90TnVsbCh0ZWEsICdncmVhdCwgdGltZSBmb3IgdGVhIScpO1xuICAgKlxuICAgKiBAbmFtZSBpc05vdE51bGxcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzTm90TnVsbCA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2cpLnRvLm5vdC5lcXVhbChudWxsKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc1VuZGVmaW5lZCh2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBpcyBgdW5kZWZpbmVkYC5cbiAgICpcbiAgICogICAgIHZhciB0ZWE7XG4gICAqICAgICBhc3NlcnQuaXNVbmRlZmluZWQodGVhLCAnbm8gdGVhIGRlZmluZWQnKTtcbiAgICpcbiAgICogQG5hbWUgaXNVbmRlZmluZWRcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzVW5kZWZpbmVkID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZykudG8uZXF1YWwodW5kZWZpbmVkKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc0RlZmluZWQodmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAgaXMgbm90IGB1bmRlZmluZWRgLlxuICAgKlxuICAgKiAgICAgdmFyIHRlYSA9ICdjdXAgb2YgY2hhaSc7XG4gICAqICAgICBhc3NlcnQuaXNEZWZpbmVkKHRlYSwgJ3RlYSBoYXMgYmVlbiBkZWZpbmVkJyk7XG4gICAqXG4gICAqIEBuYW1lIGlzRGVmaW5lZFxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNEZWZpbmVkID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZykudG8ubm90LmVxdWFsKHVuZGVmaW5lZCk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNGdW5jdGlvbih2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLlxuICAgKlxuICAgKiAgICAgZnVuY3Rpb24gc2VydmVUZWEoKSB7IHJldHVybiAnY3VwIG9mIHRlYSc7IH07XG4gICAqICAgICBhc3NlcnQuaXNGdW5jdGlvbihzZXJ2ZVRlYSwgJ2dyZWF0LCB3ZSBjYW4gaGF2ZSB0ZWEgbm93Jyk7XG4gICAqXG4gICAqIEBuYW1lIGlzRnVuY3Rpb25cbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzRnVuY3Rpb24gPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnKS50by5iZS5hKCdmdW5jdGlvbicpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzTm90RnVuY3Rpb24odmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAgaXMgX25vdF8gYSBmdW5jdGlvbi5cbiAgICpcbiAgICogICAgIHZhciBzZXJ2ZVRlYSA9IFsgJ2hlYXQnLCAncG91cicsICdzaXAnIF07XG4gICAqICAgICBhc3NlcnQuaXNOb3RGdW5jdGlvbihzZXJ2ZVRlYSwgJ2dyZWF0LCB3ZSBoYXZlIGxpc3RlZCB0aGUgc3RlcHMnKTtcbiAgICpcbiAgICogQG5hbWUgaXNOb3RGdW5jdGlvblxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNOb3RGdW5jdGlvbiA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2cpLnRvLm5vdC5iZS5hKCdmdW5jdGlvbicpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzT2JqZWN0KHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgIGlzIGFuIG9iamVjdCAoYXMgcmV2ZWFsZWQgYnlcbiAgICogYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgKS5cbiAgICpcbiAgICogICAgIHZhciBzZWxlY3Rpb24gPSB7IG5hbWU6ICdDaGFpJywgc2VydmU6ICd3aXRoIHNwaWNlcycgfTtcbiAgICogICAgIGFzc2VydC5pc09iamVjdChzZWxlY3Rpb24sICd0ZWEgc2VsZWN0aW9uIGlzIGFuIG9iamVjdCcpO1xuICAgKlxuICAgKiBAbmFtZSBpc09iamVjdFxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNPYmplY3QgPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnKS50by5iZS5hKCdvYmplY3QnKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc05vdE9iamVjdCh2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBpcyBfbm90XyBhbiBvYmplY3QuXG4gICAqXG4gICAqICAgICB2YXIgc2VsZWN0aW9uID0gJ2NoYWknXG4gICAqICAgICBhc3NlcnQuaXNOb3RPYmplY3Qoc2VsZWN0aW9uLCAndGVhIHNlbGVjdGlvbiBpcyBub3QgYW4gb2JqZWN0Jyk7XG4gICAqICAgICBhc3NlcnQuaXNOb3RPYmplY3QobnVsbCwgJ251bGwgaXMgbm90IGFuIG9iamVjdCcpO1xuICAgKlxuICAgKiBAbmFtZSBpc05vdE9iamVjdFxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNOb3RPYmplY3QgPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnKS50by5ub3QuYmUuYSgnb2JqZWN0Jyk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNBcnJheSh2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBpcyBhbiBhcnJheS5cbiAgICpcbiAgICogICAgIHZhciBtZW51ID0gWyAnZ3JlZW4nLCAnY2hhaScsICdvb2xvbmcnIF07XG4gICAqICAgICBhc3NlcnQuaXNBcnJheShtZW51LCAnd2hhdCBraW5kIG9mIHRlYSBkbyB3ZSB3YW50PycpO1xuICAgKlxuICAgKiBAbmFtZSBpc0FycmF5XG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc0FycmF5ID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZykudG8uYmUuYW4oJ2FycmF5Jyk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNOb3RBcnJheSh2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBpcyBfbm90XyBhbiBhcnJheS5cbiAgICpcbiAgICogICAgIHZhciBtZW51ID0gJ2dyZWVufGNoYWl8b29sb25nJztcbiAgICogICAgIGFzc2VydC5pc05vdEFycmF5KG1lbnUsICd3aGF0IGtpbmQgb2YgdGVhIGRvIHdlIHdhbnQ/Jyk7XG4gICAqXG4gICAqIEBuYW1lIGlzTm90QXJyYXlcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzTm90QXJyYXkgPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnKS50by5ub3QuYmUuYW4oJ2FycmF5Jyk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNTdHJpbmcodmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAgaXMgYSBzdHJpbmcuXG4gICAqXG4gICAqICAgICB2YXIgdGVhT3JkZXIgPSAnY2hhaSc7XG4gICAqICAgICBhc3NlcnQuaXNTdHJpbmcodGVhT3JkZXIsICdvcmRlciBwbGFjZWQnKTtcbiAgICpcbiAgICogQG5hbWUgaXNTdHJpbmdcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzU3RyaW5nID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZykudG8uYmUuYSgnc3RyaW5nJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNOb3RTdHJpbmcodmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAgaXMgX25vdF8gYSBzdHJpbmcuXG4gICAqXG4gICAqICAgICB2YXIgdGVhT3JkZXIgPSA0O1xuICAgKiAgICAgYXNzZXJ0LmlzTm90U3RyaW5nKHRlYU9yZGVyLCAnb3JkZXIgcGxhY2VkJyk7XG4gICAqXG4gICAqIEBuYW1lIGlzTm90U3RyaW5nXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc05vdFN0cmluZyA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2cpLnRvLm5vdC5iZS5hKCdzdHJpbmcnKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc051bWJlcih2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBpcyBhIG51bWJlci5cbiAgICpcbiAgICogICAgIHZhciBjdXBzID0gMjtcbiAgICogICAgIGFzc2VydC5pc051bWJlcihjdXBzLCAnaG93IG1hbnkgY3VwcycpO1xuICAgKlxuICAgKiBAbmFtZSBpc051bWJlclxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzTnVtYmVyID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZykudG8uYmUuYSgnbnVtYmVyJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNOb3ROdW1iZXIodmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAgaXMgX25vdF8gYSBudW1iZXIuXG4gICAqXG4gICAqICAgICB2YXIgY3VwcyA9ICcyIGN1cHMgcGxlYXNlJztcbiAgICogICAgIGFzc2VydC5pc05vdE51bWJlcihjdXBzLCAnaG93IG1hbnkgY3VwcycpO1xuICAgKlxuICAgKiBAbmFtZSBpc05vdE51bWJlclxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNOb3ROdW1iZXIgPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnKS50by5ub3QuYmUuYSgnbnVtYmVyJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNCb29sZWFuKHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgIGlzIGEgYm9vbGVhbi5cbiAgICpcbiAgICogICAgIHZhciB0ZWFSZWFkeSA9IHRydWVcbiAgICogICAgICAgLCB0ZWFTZXJ2ZWQgPSBmYWxzZTtcbiAgICpcbiAgICogICAgIGFzc2VydC5pc0Jvb2xlYW4odGVhUmVhZHksICdpcyB0aGUgdGVhIHJlYWR5Jyk7XG4gICAqICAgICBhc3NlcnQuaXNCb29sZWFuKHRlYVNlcnZlZCwgJ2hhcyB0ZWEgYmVlbiBzZXJ2ZWQnKTtcbiAgICpcbiAgICogQG5hbWUgaXNCb29sZWFuXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc0Jvb2xlYW4gPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnKS50by5iZS5hKCdib29sZWFuJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNOb3RCb29sZWFuKHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgIGlzIF9ub3RfIGEgYm9vbGVhbi5cbiAgICpcbiAgICogICAgIHZhciB0ZWFSZWFkeSA9ICd5ZXAnXG4gICAqICAgICAgICwgdGVhU2VydmVkID0gJ25vcGUnO1xuICAgKlxuICAgKiAgICAgYXNzZXJ0LmlzTm90Qm9vbGVhbih0ZWFSZWFkeSwgJ2lzIHRoZSB0ZWEgcmVhZHknKTtcbiAgICogICAgIGFzc2VydC5pc05vdEJvb2xlYW4odGVhU2VydmVkLCAnaGFzIHRlYSBiZWVuIHNlcnZlZCcpO1xuICAgKlxuICAgKiBAbmFtZSBpc05vdEJvb2xlYW5cbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzTm90Qm9vbGVhbiA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2cpLnRvLm5vdC5iZS5hKCdib29sZWFuJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAudHlwZU9mKHZhbHVlLCBuYW1lLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgJ3MgdHlwZSBpcyBgbmFtZWAsIGFzIGRldGVybWluZWQgYnlcbiAgICogYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LnR5cGVPZih7IHRlYTogJ2NoYWknIH0sICdvYmplY3QnLCAnd2UgaGF2ZSBhbiBvYmplY3QnKTtcbiAgICogICAgIGFzc2VydC50eXBlT2YoWydjaGFpJywgJ2phc21pbmUnXSwgJ2FycmF5JywgJ3dlIGhhdmUgYW4gYXJyYXknKTtcbiAgICogICAgIGFzc2VydC50eXBlT2YoJ3RlYScsICdzdHJpbmcnLCAnd2UgaGF2ZSBhIHN0cmluZycpO1xuICAgKiAgICAgYXNzZXJ0LnR5cGVPZigvdGVhLywgJ3JlZ2V4cCcsICd3ZSBoYXZlIGEgcmVndWxhciBleHByZXNzaW9uJyk7XG4gICAqICAgICBhc3NlcnQudHlwZU9mKG51bGwsICdudWxsJywgJ3dlIGhhdmUgYSBudWxsJyk7XG4gICAqICAgICBhc3NlcnQudHlwZU9mKHVuZGVmaW5lZCwgJ3VuZGVmaW5lZCcsICd3ZSBoYXZlIGFuIHVuZGVmaW5lZCcpO1xuICAgKlxuICAgKiBAbmFtZSB0eXBlT2ZcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LnR5cGVPZiA9IGZ1bmN0aW9uICh2YWwsIHR5cGUsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2cpLnRvLmJlLmEodHlwZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAubm90VHlwZU9mKHZhbHVlLCBuYW1lLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgJ3MgdHlwZSBpcyBfbm90XyBgbmFtZWAsIGFzIGRldGVybWluZWQgYnlcbiAgICogYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lm5vdFR5cGVPZigndGVhJywgJ251bWJlcicsICdzdHJpbmdzIGFyZSBub3QgbnVtYmVycycpO1xuICAgKlxuICAgKiBAbmFtZSBub3RUeXBlT2ZcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVvZiBuYW1lXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5ub3RUeXBlT2YgPSBmdW5jdGlvbiAodmFsLCB0eXBlLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnKS50by5ub3QuYmUuYSh0eXBlKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pbnN0YW5jZU9mKG9iamVjdCwgY29uc3RydWN0b3IsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAgaXMgYW4gaW5zdGFuY2Ugb2YgYGNvbnN0cnVjdG9yYC5cbiAgICpcbiAgICogICAgIHZhciBUZWEgPSBmdW5jdGlvbiAobmFtZSkgeyB0aGlzLm5hbWUgPSBuYW1lOyB9XG4gICAqICAgICAgICwgY2hhaSA9IG5ldyBUZWEoJ2NoYWknKTtcbiAgICpcbiAgICogICAgIGFzc2VydC5pbnN0YW5jZU9mKGNoYWksIFRlYSwgJ2NoYWkgaXMgYW4gaW5zdGFuY2Ugb2YgdGVhJyk7XG4gICAqXG4gICAqIEBuYW1lIGluc3RhbmNlT2ZcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgKiBAcGFyYW0ge0NvbnN0cnVjdG9yfSBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaW5zdGFuY2VPZiA9IGZ1bmN0aW9uICh2YWwsIHR5cGUsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2cpLnRvLmJlLmluc3RhbmNlT2YodHlwZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAubm90SW5zdGFuY2VPZihvYmplY3QsIGNvbnN0cnVjdG9yLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgYHZhbHVlYCBpcyBub3QgYW4gaW5zdGFuY2Ugb2YgYGNvbnN0cnVjdG9yYC5cbiAgICpcbiAgICogICAgIHZhciBUZWEgPSBmdW5jdGlvbiAobmFtZSkgeyB0aGlzLm5hbWUgPSBuYW1lOyB9XG4gICAqICAgICAgICwgY2hhaSA9IG5ldyBTdHJpbmcoJ2NoYWknKTtcbiAgICpcbiAgICogICAgIGFzc2VydC5ub3RJbnN0YW5jZU9mKGNoYWksIFRlYSwgJ2NoYWkgaXMgbm90IGFuIGluc3RhbmNlIG9mIHRlYScpO1xuICAgKlxuICAgKiBAbmFtZSBub3RJbnN0YW5jZU9mXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtIHtDb25zdHJ1Y3Rvcn0gY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm5vdEluc3RhbmNlT2YgPSBmdW5jdGlvbiAodmFsLCB0eXBlLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnKS50by5ub3QuYmUuaW5zdGFuY2VPZih0eXBlKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pbmNsdWRlKGhheXN0YWNrLCBuZWVkbGUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBoYXlzdGFja2AgaW5jbHVkZXMgYG5lZWRsZWAuIFdvcmtzXG4gICAqIGZvciBzdHJpbmdzIGFuZCBhcnJheXMuXG4gICAqXG4gICAqICAgICBhc3NlcnQuaW5jbHVkZSgnZm9vYmFyJywgJ2JhcicsICdmb29iYXIgY29udGFpbnMgc3RyaW5nIFwiYmFyXCInKTtcbiAgICogICAgIGFzc2VydC5pbmNsdWRlKFsgMSwgMiwgMyBdLCAzLCAnYXJyYXkgY29udGFpbnMgdmFsdWUnKTtcbiAgICpcbiAgICogQG5hbWUgaW5jbHVkZVxuICAgKiBAcGFyYW0ge0FycmF5fFN0cmluZ30gaGF5c3RhY2tcbiAgICogQHBhcmFtIHtNaXhlZH0gbmVlZGxlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pbmNsdWRlID0gZnVuY3Rpb24gKGV4cCwgaW5jLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKGV4cCwgbXNnLCBhc3NlcnQuaW5jbHVkZSkuaW5jbHVkZShpbmMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLm5vdEluY2x1ZGUoaGF5c3RhY2ssIG5lZWRsZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYGhheXN0YWNrYCBkb2VzIG5vdCBpbmNsdWRlIGBuZWVkbGVgLiBXb3Jrc1xuICAgKiBmb3Igc3RyaW5ncyBhbmQgYXJyYXlzLlxuICAgKmlcbiAgICogICAgIGFzc2VydC5ub3RJbmNsdWRlKCdmb29iYXInLCAnYmF6JywgJ3N0cmluZyBub3QgaW5jbHVkZSBzdWJzdHJpbmcnKTtcbiAgICogICAgIGFzc2VydC5ub3RJbmNsdWRlKFsgMSwgMiwgMyBdLCA0LCAnYXJyYXkgbm90IGluY2x1ZGUgY29udGFpbiB2YWx1ZScpO1xuICAgKlxuICAgKiBAbmFtZSBub3RJbmNsdWRlXG4gICAqIEBwYXJhbSB7QXJyYXl8U3RyaW5nfSBoYXlzdGFja1xuICAgKiBAcGFyYW0ge01peGVkfSBuZWVkbGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm5vdEluY2x1ZGUgPSBmdW5jdGlvbiAoZXhwLCBpbmMsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oZXhwLCBtc2csIGFzc2VydC5ub3RJbmNsdWRlKS5ub3QuaW5jbHVkZShpbmMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLm1hdGNoKHZhbHVlLCByZWdleHAsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAgbWF0Y2hlcyB0aGUgcmVndWxhciBleHByZXNzaW9uIGByZWdleHBgLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lm1hdGNoKCdmb29iYXInLCAvXmZvby8sICdyZWdleHAgbWF0Y2hlcycpO1xuICAgKlxuICAgKiBAbmFtZSBtYXRjaFxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1JlZ0V4cH0gcmVnZXhwXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5tYXRjaCA9IGZ1bmN0aW9uIChleHAsIHJlLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKGV4cCwgbXNnKS50by5tYXRjaChyZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAubm90TWF0Y2godmFsdWUsIHJlZ2V4cCwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBkb2VzIG5vdCBtYXRjaCB0aGUgcmVndWxhciBleHByZXNzaW9uIGByZWdleHBgLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lm5vdE1hdGNoKCdmb29iYXInLCAvXmZvby8sICdyZWdleHAgZG9lcyBub3QgbWF0Y2gnKTtcbiAgICpcbiAgICogQG5hbWUgbm90TWF0Y2hcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtSZWdFeHB9IHJlZ2V4cFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQubm90TWF0Y2ggPSBmdW5jdGlvbiAoZXhwLCByZSwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihleHAsIG1zZykudG8ubm90Lm1hdGNoKHJlKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5wcm9wZXJ0eShvYmplY3QsIHByb3BlcnR5LCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBoYXMgYSBwcm9wZXJ0eSBuYW1lZCBieSBgcHJvcGVydHlgLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LnByb3BlcnR5KHsgdGVhOiB7IGdyZWVuOiAnbWF0Y2hhJyB9fSwgJ3RlYScpO1xuICAgKlxuICAgKiBAbmFtZSBwcm9wZXJ0eVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQucHJvcGVydHkgPSBmdW5jdGlvbiAob2JqLCBwcm9wLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnKS50by5oYXZlLnByb3BlcnR5KHByb3ApO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLm5vdFByb3BlcnR5KG9iamVjdCwgcHJvcGVydHksIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGRvZXMgX25vdF8gaGF2ZSBhIHByb3BlcnR5IG5hbWVkIGJ5IGBwcm9wZXJ0eWAuXG4gICAqXG4gICAqICAgICBhc3NlcnQubm90UHJvcGVydHkoeyB0ZWE6IHsgZ3JlZW46ICdtYXRjaGEnIH19LCAnY29mZmVlJyk7XG4gICAqXG4gICAqIEBuYW1lIG5vdFByb3BlcnR5XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5ub3RQcm9wZXJ0eSA9IGZ1bmN0aW9uIChvYmosIHByb3AsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2cpLnRvLm5vdC5oYXZlLnByb3BlcnR5KHByb3ApO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmRlZXBQcm9wZXJ0eShvYmplY3QsIHByb3BlcnR5LCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBoYXMgYSBwcm9wZXJ0eSBuYW1lZCBieSBgcHJvcGVydHlgLCB3aGljaCBjYW4gYmUgYVxuICAgKiBzdHJpbmcgdXNpbmcgZG90LSBhbmQgYnJhY2tldC1ub3RhdGlvbiBmb3IgZGVlcCByZWZlcmVuY2UuXG4gICAqXG4gICAqICAgICBhc3NlcnQuZGVlcFByb3BlcnR5KHsgdGVhOiB7IGdyZWVuOiAnbWF0Y2hhJyB9fSwgJ3RlYS5ncmVlbicpO1xuICAgKlxuICAgKiBAbmFtZSBkZWVwUHJvcGVydHlcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHlcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmRlZXBQcm9wZXJ0eSA9IGZ1bmN0aW9uIChvYmosIHByb3AsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2cpLnRvLmhhdmUuZGVlcC5wcm9wZXJ0eShwcm9wKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5ub3REZWVwUHJvcGVydHkob2JqZWN0LCBwcm9wZXJ0eSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYG9iamVjdGAgZG9lcyBfbm90XyBoYXZlIGEgcHJvcGVydHkgbmFtZWQgYnkgYHByb3BlcnR5YCwgd2hpY2hcbiAgICogY2FuIGJlIGEgc3RyaW5nIHVzaW5nIGRvdC0gYW5kIGJyYWNrZXQtbm90YXRpb24gZm9yIGRlZXAgcmVmZXJlbmNlLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lm5vdERlZXBQcm9wZXJ0eSh7IHRlYTogeyBncmVlbjogJ21hdGNoYScgfX0sICd0ZWEub29sb25nJyk7XG4gICAqXG4gICAqIEBuYW1lIG5vdERlZXBQcm9wZXJ0eVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQubm90RGVlcFByb3BlcnR5ID0gZnVuY3Rpb24gKG9iaiwgcHJvcCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihvYmosIG1zZykudG8ubm90LmhhdmUuZGVlcC5wcm9wZXJ0eShwcm9wKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5wcm9wZXJ0eVZhbChvYmplY3QsIHByb3BlcnR5LCB2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYG9iamVjdGAgaGFzIGEgcHJvcGVydHkgbmFtZWQgYnkgYHByb3BlcnR5YCB3aXRoIHZhbHVlIGdpdmVuXG4gICAqIGJ5IGB2YWx1ZWAuXG4gICAqXG4gICAqICAgICBhc3NlcnQucHJvcGVydHlWYWwoeyB0ZWE6ICdpcyBnb29kJyB9LCAndGVhJywgJ2lzIGdvb2QnKTtcbiAgICpcbiAgICogQG5hbWUgcHJvcGVydHlWYWxcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHlcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LnByb3BlcnR5VmFsID0gZnVuY3Rpb24gKG9iaiwgcHJvcCwgdmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnKS50by5oYXZlLnByb3BlcnR5KHByb3AsIHZhbCk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAucHJvcGVydHlOb3RWYWwob2JqZWN0LCBwcm9wZXJ0eSwgdmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGhhcyBhIHByb3BlcnR5IG5hbWVkIGJ5IGBwcm9wZXJ0eWAsIGJ1dCB3aXRoIGEgdmFsdWVcbiAgICogZGlmZmVyZW50IGZyb20gdGhhdCBnaXZlbiBieSBgdmFsdWVgLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LnByb3BlcnR5Tm90VmFsKHsgdGVhOiAnaXMgZ29vZCcgfSwgJ3RlYScsICdpcyBiYWQnKTtcbiAgICpcbiAgICogQG5hbWUgcHJvcGVydHlOb3RWYWxcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHlcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LnByb3BlcnR5Tm90VmFsID0gZnVuY3Rpb24gKG9iaiwgcHJvcCwgdmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnKS50by5ub3QuaGF2ZS5wcm9wZXJ0eShwcm9wLCB2YWwpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmRlZXBQcm9wZXJ0eVZhbChvYmplY3QsIHByb3BlcnR5LCB2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYG9iamVjdGAgaGFzIGEgcHJvcGVydHkgbmFtZWQgYnkgYHByb3BlcnR5YCB3aXRoIHZhbHVlIGdpdmVuXG4gICAqIGJ5IGB2YWx1ZWAuIGBwcm9wZXJ0eWAgY2FuIHVzZSBkb3QtIGFuZCBicmFja2V0LW5vdGF0aW9uIGZvciBkZWVwXG4gICAqIHJlZmVyZW5jZS5cbiAgICpcbiAgICogICAgIGFzc2VydC5kZWVwUHJvcGVydHlWYWwoeyB0ZWE6IHsgZ3JlZW46ICdtYXRjaGEnIH19LCAndGVhLmdyZWVuJywgJ21hdGNoYScpO1xuICAgKlxuICAgKiBAbmFtZSBkZWVwUHJvcGVydHlWYWxcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHlcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmRlZXBQcm9wZXJ0eVZhbCA9IGZ1bmN0aW9uIChvYmosIHByb3AsIHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihvYmosIG1zZykudG8uaGF2ZS5kZWVwLnByb3BlcnR5KHByb3AsIHZhbCk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuZGVlcFByb3BlcnR5Tm90VmFsKG9iamVjdCwgcHJvcGVydHksIHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBoYXMgYSBwcm9wZXJ0eSBuYW1lZCBieSBgcHJvcGVydHlgLCBidXQgd2l0aCBhIHZhbHVlXG4gICAqIGRpZmZlcmVudCBmcm9tIHRoYXQgZ2l2ZW4gYnkgYHZhbHVlYC4gYHByb3BlcnR5YCBjYW4gdXNlIGRvdC0gYW5kXG4gICAqIGJyYWNrZXQtbm90YXRpb24gZm9yIGRlZXAgcmVmZXJlbmNlLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LmRlZXBQcm9wZXJ0eU5vdFZhbCh7IHRlYTogeyBncmVlbjogJ21hdGNoYScgfX0sICd0ZWEuZ3JlZW4nLCAna29uYWNoYScpO1xuICAgKlxuICAgKiBAbmFtZSBkZWVwUHJvcGVydHlOb3RWYWxcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHlcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmRlZXBQcm9wZXJ0eU5vdFZhbCA9IGZ1bmN0aW9uIChvYmosIHByb3AsIHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihvYmosIG1zZykudG8ubm90LmhhdmUuZGVlcC5wcm9wZXJ0eShwcm9wLCB2YWwpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmxlbmd0aE9mKG9iamVjdCwgbGVuZ3RoLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBoYXMgYSBgbGVuZ3RoYCBwcm9wZXJ0eSB3aXRoIHRoZSBleHBlY3RlZCB2YWx1ZS5cbiAgICpcbiAgICogICAgIGFzc2VydC5sZW5ndGhPZihbMSwyLDNdLCAzLCAnYXJyYXkgaGFzIGxlbmd0aCBvZiAzJyk7XG4gICAqICAgICBhc3NlcnQubGVuZ3RoT2YoJ2Zvb2JhcicsIDUsICdzdHJpbmcgaGFzIGxlbmd0aCBvZiA2Jyk7XG4gICAqXG4gICAqIEBuYW1lIGxlbmd0aE9mXG4gICAqIEBwYXJhbSB7TWl4ZWR9IG9iamVjdFxuICAgKiBAcGFyYW0ge051bWJlcn0gbGVuZ3RoXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5sZW5ndGhPZiA9IGZ1bmN0aW9uIChleHAsIGxlbiwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihleHAsIG1zZykudG8uaGF2ZS5sZW5ndGgobGVuKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC50aHJvd3MoZnVuY3Rpb24sIFtjb25zdHJ1Y3Rvci9zdHJpbmcvcmVnZXhwXSwgW3N0cmluZy9yZWdleHBdLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgZnVuY3Rpb25gIHdpbGwgdGhyb3cgYW4gZXJyb3IgdGhhdCBpcyBhbiBpbnN0YW5jZSBvZlxuICAgKiBgY29uc3RydWN0b3JgLCBvciBhbHRlcm5hdGVseSB0aGF0IGl0IHdpbGwgdGhyb3cgYW4gZXJyb3Igd2l0aCBtZXNzYWdlXG4gICAqIG1hdGNoaW5nIGByZWdleHBgLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LnRocm93KGZuLCAnZnVuY3Rpb24gdGhyb3dzIGEgcmVmZXJlbmNlIGVycm9yJyk7XG4gICAqICAgICBhc3NlcnQudGhyb3coZm4sIC9mdW5jdGlvbiB0aHJvd3MgYSByZWZlcmVuY2UgZXJyb3IvKTtcbiAgICogICAgIGFzc2VydC50aHJvdyhmbiwgUmVmZXJlbmNlRXJyb3IpO1xuICAgKiAgICAgYXNzZXJ0LnRocm93KGZuLCBSZWZlcmVuY2VFcnJvciwgJ2Z1bmN0aW9uIHRocm93cyBhIHJlZmVyZW5jZSBlcnJvcicpO1xuICAgKiAgICAgYXNzZXJ0LnRocm93KGZuLCBSZWZlcmVuY2VFcnJvciwgL2Z1bmN0aW9uIHRocm93cyBhIHJlZmVyZW5jZSBlcnJvci8pO1xuICAgKlxuICAgKiBAbmFtZSB0aHJvd3NcbiAgICogQGFsaWFzIHRocm93XG4gICAqIEBhbGlhcyBUaHJvd1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jdGlvblxuICAgKiBAcGFyYW0ge0Vycm9yQ29uc3RydWN0b3J9IGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7UmVnRXhwfSByZWdleHBcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9FcnJvciNFcnJvcl90eXBlc1xuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuVGhyb3cgPSBmdW5jdGlvbiAoZm4sIGVycnQsIGVycnMsIG1zZykge1xuICAgIGlmICgnc3RyaW5nJyA9PT0gdHlwZW9mIGVycnQgfHwgZXJydCBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgZXJycyA9IGVycnQ7XG4gICAgICBlcnJ0ID0gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgYXNzZXJ0RXJyID0gbmV3IEFzc2VydGlvbihmbiwgbXNnKS50by5UaHJvdyhlcnJ0LCBlcnJzKTtcbiAgICByZXR1cm4gZmxhZyhhc3NlcnRFcnIsICdvYmplY3QnKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5kb2VzTm90VGhyb3coZnVuY3Rpb24sIFtjb25zdHJ1Y3Rvci9yZWdleHBdLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgZnVuY3Rpb25gIHdpbGwgX25vdF8gdGhyb3cgYW4gZXJyb3IgdGhhdCBpcyBhbiBpbnN0YW5jZSBvZlxuICAgKiBgY29uc3RydWN0b3JgLCBvciBhbHRlcm5hdGVseSB0aGF0IGl0IHdpbGwgbm90IHRocm93IGFuIGVycm9yIHdpdGggbWVzc2FnZVxuICAgKiBtYXRjaGluZyBgcmVnZXhwYC5cbiAgICpcbiAgICogICAgIGFzc2VydC5kb2VzTm90VGhyb3coZm4sIEVycm9yLCAnZnVuY3Rpb24gZG9lcyBub3QgdGhyb3cnKTtcbiAgICpcbiAgICogQG5hbWUgZG9lc05vdFRocm93XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7RXJyb3JDb25zdHJ1Y3Rvcn0gY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtSZWdFeHB9IHJlZ2V4cFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0Vycm9yI0Vycm9yX3R5cGVzXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5kb2VzTm90VGhyb3cgPSBmdW5jdGlvbiAoZm4sIHR5cGUsIG1zZykge1xuICAgIGlmICgnc3RyaW5nJyA9PT0gdHlwZW9mIHR5cGUpIHtcbiAgICAgIG1zZyA9IHR5cGU7XG4gICAgICB0eXBlID0gbnVsbDtcbiAgICB9XG5cbiAgICBuZXcgQXNzZXJ0aW9uKGZuLCBtc2cpLnRvLm5vdC5UaHJvdyh0eXBlKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5vcGVyYXRvcih2YWwxLCBvcGVyYXRvciwgdmFsMiwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBDb21wYXJlcyB0d28gdmFsdWVzIHVzaW5nIGBvcGVyYXRvcmAuXG4gICAqXG4gICAqICAgICBhc3NlcnQub3BlcmF0b3IoMSwgJzwnLCAyLCAnZXZlcnl0aGluZyBpcyBvaycpO1xuICAgKiAgICAgYXNzZXJ0Lm9wZXJhdG9yKDEsICc+JywgMiwgJ3RoaXMgd2lsbCBmYWlsJyk7XG4gICAqXG4gICAqIEBuYW1lIG9wZXJhdG9yXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbDFcbiAgICogQHBhcmFtIHtTdHJpbmd9IG9wZXJhdG9yXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbDJcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm9wZXJhdG9yID0gZnVuY3Rpb24gKHZhbCwgb3BlcmF0b3IsIHZhbDIsIG1zZykge1xuICAgIGlmICghflsnPT0nLCAnPT09JywgJz4nLCAnPj0nLCAnPCcsICc8PScsICchPScsICchPT0nXS5pbmRleE9mKG9wZXJhdG9yKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG9wZXJhdG9yIFwiJyArIG9wZXJhdG9yICsgJ1wiJyk7XG4gICAgfVxuICAgIHZhciB0ZXN0ID0gbmV3IEFzc2VydGlvbihldmFsKHZhbCArIG9wZXJhdG9yICsgdmFsMiksIG1zZyk7XG4gICAgdGVzdC5hc3NlcnQoXG4gICAgICAgIHRydWUgPT09IGZsYWcodGVzdCwgJ29iamVjdCcpXG4gICAgICAsICdleHBlY3RlZCAnICsgdXRpbC5pbnNwZWN0KHZhbCkgKyAnIHRvIGJlICcgKyBvcGVyYXRvciArICcgJyArIHV0aWwuaW5zcGVjdCh2YWwyKVxuICAgICAgLCAnZXhwZWN0ZWQgJyArIHV0aWwuaW5zcGVjdCh2YWwpICsgJyB0byBub3QgYmUgJyArIG9wZXJhdG9yICsgJyAnICsgdXRpbC5pbnNwZWN0KHZhbDIpICk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuY2xvc2VUbyhhY3R1YWwsIGV4cGVjdGVkLCBkZWx0YSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyBlcXVhbCBgZXhwZWN0ZWRgLCB0byB3aXRoaW4gYSArLy0gYGRlbHRhYCByYW5nZS5cbiAgICpcbiAgICogICAgIGFzc2VydC5jbG9zZVRvKDEuNSwgMSwgMC41LCAnbnVtYmVycyBhcmUgY2xvc2UnKTtcbiAgICpcbiAgICogQG5hbWUgY2xvc2VUb1xuICAgKiBAcGFyYW0ge051bWJlcn0gYWN0dWFsXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBleHBlY3RlZFxuICAgKiBAcGFyYW0ge051bWJlcn0gZGVsdGFcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmNsb3NlVG8gPSBmdW5jdGlvbiAoYWN0LCBleHAsIGRlbHRhLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKGFjdCwgbXNnKS50by5iZS5jbG9zZVRvKGV4cCwgZGVsdGEpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLnNhbWVNZW1iZXJzKHNldDEsIHNldDIsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBzZXQxYCBhbmQgYHNldDJgIGhhdmUgdGhlIHNhbWUgbWVtYmVycy5cbiAgICogT3JkZXIgaXMgbm90IHRha2VuIGludG8gYWNjb3VudC5cbiAgICpcbiAgICogICAgIGFzc2VydC5zYW1lTWVtYmVycyhbIDEsIDIsIDMgXSwgWyAyLCAxLCAzIF0sICdzYW1lIG1lbWJlcnMnKTtcbiAgICpcbiAgICogQG5hbWUgc2FtZU1lbWJlcnNcbiAgICogQHBhcmFtIHtBcnJheX0gc3VwZXJzZXRcbiAgICogQHBhcmFtIHtBcnJheX0gc3Vic2V0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5zYW1lTWVtYmVycyA9IGZ1bmN0aW9uIChzZXQxLCBzZXQyLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHNldDEsIG1zZykudG8uaGF2ZS5zYW1lLm1lbWJlcnMoc2V0Mik7XG4gIH1cblxuICAvKipcbiAgICogIyMjIC5pbmNsdWRlTWVtYmVycyhzdXBlcnNldCwgc3Vic2V0LCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgc3Vic2V0YCBpcyBpbmNsdWRlZCBpbiBgc3VwZXJzZXRgLlxuICAgKiBPcmRlciBpcyBub3QgdGFrZW4gaW50byBhY2NvdW50LlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LmluY2x1ZGVNZW1iZXJzKFsgMSwgMiwgMyBdLCBbIDIsIDEgXSwgJ2luY2x1ZGUgbWVtYmVycycpO1xuICAgKlxuICAgKiBAbmFtZSBpbmNsdWRlTWVtYmVyc1xuICAgKiBAcGFyYW0ge0FycmF5fSBzdXBlcnNldFxuICAgKiBAcGFyYW0ge0FycmF5fSBzdWJzZXRcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmluY2x1ZGVNZW1iZXJzID0gZnVuY3Rpb24gKHN1cGVyc2V0LCBzdWJzZXQsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oc3VwZXJzZXQsIG1zZykudG8uaW5jbHVkZS5tZW1iZXJzKHN1YnNldCk7XG4gIH1cblxuICAvKiFcbiAgICogVW5kb2N1bWVudGVkIC8gdW50ZXN0ZWRcbiAgICovXG5cbiAgYXNzZXJ0LmlmRXJyb3IgPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnKS50by5ub3QuYmUub2s7XG4gIH07XG5cbiAgLyohXG4gICAqIEFsaWFzZXMuXG4gICAqL1xuXG4gIChmdW5jdGlvbiBhbGlhcyhuYW1lLCBhcyl7XG4gICAgYXNzZXJ0W2FzXSA9IGFzc2VydFtuYW1lXTtcbiAgICByZXR1cm4gYWxpYXM7XG4gIH0pXG4gICgnVGhyb3cnLCAndGhyb3cnKVxuICAoJ1Rocm93JywgJ3Rocm93cycpO1xufTtcbiIsIi8qIVxuICogY2hhaVxuICogQ29weXJpZ2h0KGMpIDIwMTEtMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNoYWksIHV0aWwpIHtcbiAgY2hhaS5leHBlY3QgPSBmdW5jdGlvbiAodmFsLCBtZXNzYWdlKSB7XG4gICAgcmV0dXJuIG5ldyBjaGFpLkFzc2VydGlvbih2YWwsIG1lc3NhZ2UpO1xuICB9O1xufTtcblxuIiwiLyohXG4gKiBjaGFpXG4gKiBDb3B5cmlnaHQoYykgMjAxMS0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY2hhaSwgdXRpbCkge1xuICB2YXIgQXNzZXJ0aW9uID0gY2hhaS5Bc3NlcnRpb247XG5cbiAgZnVuY3Rpb24gbG9hZFNob3VsZCAoKSB7XG4gICAgLy8gZXhwbGljaXRseSBkZWZpbmUgdGhpcyBtZXRob2QgYXMgZnVuY3Rpb24gYXMgdG8gaGF2ZSBpdCdzIG5hbWUgdG8gaW5jbHVkZSBhcyBgc3NmaWBcbiAgICBmdW5jdGlvbiBzaG91bGRHZXR0ZXIoKSB7XG4gICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIFN0cmluZyB8fCB0aGlzIGluc3RhbmNlb2YgTnVtYmVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgQXNzZXJ0aW9uKHRoaXMuY29uc3RydWN0b3IodGhpcyksIG51bGwsIHNob3VsZEdldHRlcik7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMgaW5zdGFuY2VvZiBCb29sZWFuKSB7XG4gICAgICAgIHJldHVybiBuZXcgQXNzZXJ0aW9uKHRoaXMgPT0gdHJ1ZSwgbnVsbCwgc2hvdWxkR2V0dGVyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgQXNzZXJ0aW9uKHRoaXMsIG51bGwsIHNob3VsZEdldHRlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNob3VsZFNldHRlcih2YWx1ZSkge1xuICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFpanMvY2hhaS9pc3N1ZXMvODY6IHRoaXMgbWFrZXNcbiAgICAgIC8vIGB3aGF0ZXZlci5zaG91bGQgPSBzb21lVmFsdWVgIGFjdHVhbGx5IHNldCBgc29tZVZhbHVlYCwgd2hpY2ggaXNcbiAgICAgIC8vIGVzcGVjaWFsbHkgdXNlZnVsIGZvciBgZ2xvYmFsLnNob3VsZCA9IHJlcXVpcmUoJ2NoYWknKS5zaG91bGQoKWAuXG4gICAgICAvL1xuICAgICAgLy8gTm90ZSB0aGF0IHdlIGhhdmUgdG8gdXNlIFtbRGVmaW5lUHJvcGVydHldXSBpbnN0ZWFkIG9mIFtbUHV0XV1cbiAgICAgIC8vIHNpbmNlIG90aGVyd2lzZSB3ZSB3b3VsZCB0cmlnZ2VyIHRoaXMgdmVyeSBzZXR0ZXIhXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3Nob3VsZCcsIHtcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgLy8gbW9kaWZ5IE9iamVjdC5wcm90b3R5cGUgdG8gaGF2ZSBgc2hvdWxkYFxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPYmplY3QucHJvdG90eXBlLCAnc2hvdWxkJywge1xuICAgICAgc2V0OiBzaG91bGRTZXR0ZXJcbiAgICAgICwgZ2V0OiBzaG91bGRHZXR0ZXJcbiAgICAgICwgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG5cbiAgICB2YXIgc2hvdWxkID0ge307XG5cbiAgICBzaG91bGQuZXF1YWwgPSBmdW5jdGlvbiAodmFsMSwgdmFsMiwgbXNnKSB7XG4gICAgICBuZXcgQXNzZXJ0aW9uKHZhbDEsIG1zZykudG8uZXF1YWwodmFsMik7XG4gICAgfTtcblxuICAgIHNob3VsZC5UaHJvdyA9IGZ1bmN0aW9uIChmbiwgZXJydCwgZXJycywgbXNnKSB7XG4gICAgICBuZXcgQXNzZXJ0aW9uKGZuLCBtc2cpLnRvLlRocm93KGVycnQsIGVycnMpO1xuICAgIH07XG5cbiAgICBzaG91bGQuZXhpc3QgPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2cpLnRvLmV4aXN0O1xuICAgIH1cblxuICAgIC8vIG5lZ2F0aW9uXG4gICAgc2hvdWxkLm5vdCA9IHt9XG5cbiAgICBzaG91bGQubm90LmVxdWFsID0gZnVuY3Rpb24gKHZhbDEsIHZhbDIsIG1zZykge1xuICAgICAgbmV3IEFzc2VydGlvbih2YWwxLCBtc2cpLnRvLm5vdC5lcXVhbCh2YWwyKTtcbiAgICB9O1xuXG4gICAgc2hvdWxkLm5vdC5UaHJvdyA9IGZ1bmN0aW9uIChmbiwgZXJydCwgZXJycywgbXNnKSB7XG4gICAgICBuZXcgQXNzZXJ0aW9uKGZuLCBtc2cpLnRvLm5vdC5UaHJvdyhlcnJ0LCBlcnJzKTtcbiAgICB9O1xuXG4gICAgc2hvdWxkLm5vdC5leGlzdCA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZykudG8ubm90LmV4aXN0O1xuICAgIH1cblxuICAgIHNob3VsZFsndGhyb3cnXSA9IHNob3VsZFsnVGhyb3cnXTtcbiAgICBzaG91bGQubm90Wyd0aHJvdyddID0gc2hvdWxkLm5vdFsnVGhyb3cnXTtcblxuICAgIHJldHVybiBzaG91bGQ7XG4gIH07XG5cbiAgY2hhaS5zaG91bGQgPSBsb2FkU2hvdWxkO1xuICBjaGFpLlNob3VsZCA9IGxvYWRTaG91bGQ7XG59O1xuIiwiLyohXG4gKiBDaGFpIC0gYWRkQ2hhaW5pbmdNZXRob2QgdXRpbGl0eVxuICogQ29weXJpZ2h0KGMpIDIwMTItMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qIVxuICogTW9kdWxlIGRlcGVuZGVuY2llc1xuICovXG5cbnZhciB0cmFuc2ZlckZsYWdzID0gcmVxdWlyZSgnLi90cmFuc2ZlckZsYWdzJyk7XG52YXIgZmxhZyA9IHJlcXVpcmUoJy4vZmxhZycpO1xudmFyIGNvbmZpZyA9IHJlcXVpcmUoJy4uL2NvbmZpZycpO1xuXG4vKiFcbiAqIE1vZHVsZSB2YXJpYWJsZXNcbiAqL1xuXG4vLyBDaGVjayB3aGV0aGVyIGBfX3Byb3RvX19gIGlzIHN1cHBvcnRlZFxudmFyIGhhc1Byb3RvU3VwcG9ydCA9ICdfX3Byb3RvX18nIGluIE9iamVjdDtcblxuLy8gV2l0aG91dCBgX19wcm90b19fYCBzdXBwb3J0LCB0aGlzIG1vZHVsZSB3aWxsIG5lZWQgdG8gYWRkIHByb3BlcnRpZXMgdG8gYSBmdW5jdGlvbi5cbi8vIEhvd2V2ZXIsIHNvbWUgRnVuY3Rpb24ucHJvdG90eXBlIG1ldGhvZHMgY2Fubm90IGJlIG92ZXJ3cml0dGVuLFxuLy8gYW5kIHRoZXJlIHNlZW1zIG5vIGVhc3kgY3Jvc3MtcGxhdGZvcm0gd2F5IHRvIGRldGVjdCB0aGVtIChAc2VlIGNoYWlqcy9jaGFpL2lzc3Vlcy82OSkuXG52YXIgZXhjbHVkZU5hbWVzID0gL14oPzpsZW5ndGh8bmFtZXxhcmd1bWVudHN8Y2FsbGVyKSQvO1xuXG4vLyBDYWNoZSBgRnVuY3Rpb25gIHByb3BlcnRpZXNcbnZhciBjYWxsICA9IEZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsLFxuICAgIGFwcGx5ID0gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5O1xuXG4vKipcbiAqICMjIyBhZGRDaGFpbmFibGVNZXRob2QgKGN0eCwgbmFtZSwgbWV0aG9kLCBjaGFpbmluZ0JlaGF2aW9yKVxuICpcbiAqIEFkZHMgYSBtZXRob2QgdG8gYW4gb2JqZWN0LCBzdWNoIHRoYXQgdGhlIG1ldGhvZCBjYW4gYWxzbyBiZSBjaGFpbmVkLlxuICpcbiAqICAgICB1dGlscy5hZGRDaGFpbmFibGVNZXRob2QoY2hhaS5Bc3NlcnRpb24ucHJvdG90eXBlLCAnZm9vJywgZnVuY3Rpb24gKHN0cikge1xuICogICAgICAgdmFyIG9iaiA9IHV0aWxzLmZsYWcodGhpcywgJ29iamVjdCcpO1xuICogICAgICAgbmV3IGNoYWkuQXNzZXJ0aW9uKG9iaikudG8uYmUuZXF1YWwoc3RyKTtcbiAqICAgICB9KTtcbiAqXG4gKiBDYW4gYWxzbyBiZSBhY2Nlc3NlZCBkaXJlY3RseSBmcm9tIGBjaGFpLkFzc2VydGlvbmAuXG4gKlxuICogICAgIGNoYWkuQXNzZXJ0aW9uLmFkZENoYWluYWJsZU1ldGhvZCgnZm9vJywgZm4sIGNoYWluaW5nQmVoYXZpb3IpO1xuICpcbiAqIFRoZSByZXN1bHQgY2FuIHRoZW4gYmUgdXNlZCBhcyBib3RoIGEgbWV0aG9kIGFzc2VydGlvbiwgZXhlY3V0aW5nIGJvdGggYG1ldGhvZGAgYW5kXG4gKiBgY2hhaW5pbmdCZWhhdmlvcmAsIG9yIGFzIGEgbGFuZ3VhZ2UgY2hhaW4sIHdoaWNoIG9ubHkgZXhlY3V0ZXMgYGNoYWluaW5nQmVoYXZpb3JgLlxuICpcbiAqICAgICBleHBlY3QoZm9vU3RyKS50by5iZS5mb28oJ2JhcicpO1xuICogICAgIGV4cGVjdChmb29TdHIpLnRvLmJlLmZvby5lcXVhbCgnZm9vJyk7XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGN0eCBvYmplY3QgdG8gd2hpY2ggdGhlIG1ldGhvZCBpcyBhZGRlZFxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgb2YgbWV0aG9kIHRvIGFkZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gbWV0aG9kIGZ1bmN0aW9uIHRvIGJlIHVzZWQgZm9yIGBuYW1lYCwgd2hlbiBjYWxsZWRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNoYWluaW5nQmVoYXZpb3IgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIGV2ZXJ5IHRpbWUgdGhlIHByb3BlcnR5IGlzIGFjY2Vzc2VkXG4gKiBAbmFtZSBhZGRDaGFpbmFibGVNZXRob2RcbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY3R4LCBuYW1lLCBtZXRob2QsIGNoYWluaW5nQmVoYXZpb3IpIHtcbiAgaWYgKHR5cGVvZiBjaGFpbmluZ0JlaGF2aW9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgY2hhaW5pbmdCZWhhdmlvciA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgfVxuXG4gIHZhciBjaGFpbmFibGVCZWhhdmlvciA9IHtcbiAgICAgIG1ldGhvZDogbWV0aG9kXG4gICAgLCBjaGFpbmluZ0JlaGF2aW9yOiBjaGFpbmluZ0JlaGF2aW9yXG4gIH07XG5cbiAgLy8gc2F2ZSB0aGUgbWV0aG9kcyBzbyB3ZSBjYW4gb3ZlcndyaXRlIHRoZW0gbGF0ZXIsIGlmIHdlIG5lZWQgdG8uXG4gIGlmICghY3R4Ll9fbWV0aG9kcykge1xuICAgIGN0eC5fX21ldGhvZHMgPSB7fTtcbiAgfVxuICBjdHguX19tZXRob2RzW25hbWVdID0gY2hhaW5hYmxlQmVoYXZpb3I7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0eCwgbmFtZSxcbiAgICB7IGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICBjaGFpbmFibGVCZWhhdmlvci5jaGFpbmluZ0JlaGF2aW9yLmNhbGwodGhpcyk7XG5cbiAgICAgICAgdmFyIGFzc2VydCA9IGZ1bmN0aW9uIGFzc2VydCgpIHtcbiAgICAgICAgICB2YXIgb2xkX3NzZmkgPSBmbGFnKHRoaXMsICdzc2ZpJyk7XG4gICAgICAgICAgaWYgKG9sZF9zc2ZpICYmIGNvbmZpZy5pbmNsdWRlU3RhY2sgPT09IGZhbHNlKVxuICAgICAgICAgICAgZmxhZyh0aGlzLCAnc3NmaScsIGFzc2VydCk7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IGNoYWluYWJsZUJlaGF2aW9yLm1ldGhvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IHRoaXMgOiByZXN1bHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gVXNlIGBfX3Byb3RvX19gIGlmIGF2YWlsYWJsZVxuICAgICAgICBpZiAoaGFzUHJvdG9TdXBwb3J0KSB7XG4gICAgICAgICAgLy8gSW5oZXJpdCBhbGwgcHJvcGVydGllcyBmcm9tIHRoZSBvYmplY3QgYnkgcmVwbGFjaW5nIHRoZSBgRnVuY3Rpb25gIHByb3RvdHlwZVxuICAgICAgICAgIHZhciBwcm90b3R5cGUgPSBhc3NlcnQuX19wcm90b19fID0gT2JqZWN0LmNyZWF0ZSh0aGlzKTtcbiAgICAgICAgICAvLyBSZXN0b3JlIHRoZSBgY2FsbGAgYW5kIGBhcHBseWAgbWV0aG9kcyBmcm9tIGBGdW5jdGlvbmBcbiAgICAgICAgICBwcm90b3R5cGUuY2FsbCA9IGNhbGw7XG4gICAgICAgICAgcHJvdG90eXBlLmFwcGx5ID0gYXBwbHk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCByZWRlZmluZSBhbGwgcHJvcGVydGllcyAoc2xvdyEpXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhciBhc3NlcnRlck5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoY3R4KTtcbiAgICAgICAgICBhc3NlcnRlck5hbWVzLmZvckVhY2goZnVuY3Rpb24gKGFzc2VydGVyTmFtZSkge1xuICAgICAgICAgICAgaWYgKCFleGNsdWRlTmFtZXMudGVzdChhc3NlcnRlck5hbWUpKSB7XG4gICAgICAgICAgICAgIHZhciBwZCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY3R4LCBhc3NlcnRlck5hbWUpO1xuICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYXNzZXJ0LCBhc3NlcnRlck5hbWUsIHBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyYW5zZmVyRmxhZ3ModGhpcywgYXNzZXJ0KTtcbiAgICAgICAgcmV0dXJuIGFzc2VydDtcbiAgICAgIH1cbiAgICAsIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn07XG4iLCIvKiFcbiAqIENoYWkgLSBhZGRNZXRob2QgdXRpbGl0eVxuICogQ29weXJpZ2h0KGMpIDIwMTItMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbnZhciBjb25maWcgPSByZXF1aXJlKCcuLi9jb25maWcnKTtcblxuLyoqXG4gKiAjIyMgLmFkZE1ldGhvZCAoY3R4LCBuYW1lLCBtZXRob2QpXG4gKlxuICogQWRkcyBhIG1ldGhvZCB0byB0aGUgcHJvdG90eXBlIG9mIGFuIG9iamVjdC5cbiAqXG4gKiAgICAgdXRpbHMuYWRkTWV0aG9kKGNoYWkuQXNzZXJ0aW9uLnByb3RvdHlwZSwgJ2ZvbycsIGZ1bmN0aW9uIChzdHIpIHtcbiAqICAgICAgIHZhciBvYmogPSB1dGlscy5mbGFnKHRoaXMsICdvYmplY3QnKTtcbiAqICAgICAgIG5ldyBjaGFpLkFzc2VydGlvbihvYmopLnRvLmJlLmVxdWFsKHN0cik7XG4gKiAgICAgfSk7XG4gKlxuICogQ2FuIGFsc28gYmUgYWNjZXNzZWQgZGlyZWN0bHkgZnJvbSBgY2hhaS5Bc3NlcnRpb25gLlxuICpcbiAqICAgICBjaGFpLkFzc2VydGlvbi5hZGRNZXRob2QoJ2ZvbycsIGZuKTtcbiAqXG4gKiBUaGVuIGNhbiBiZSB1c2VkIGFzIGFueSBvdGhlciBhc3NlcnRpb24uXG4gKlxuICogICAgIGV4cGVjdChmb29TdHIpLnRvLmJlLmZvbygnYmFyJyk7XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGN0eCBvYmplY3QgdG8gd2hpY2ggdGhlIG1ldGhvZCBpcyBhZGRlZFxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgb2YgbWV0aG9kIHRvIGFkZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gbWV0aG9kIGZ1bmN0aW9uIHRvIGJlIHVzZWQgZm9yIG5hbWVcbiAqIEBuYW1lIGFkZE1ldGhvZFxuICogQGFwaSBwdWJsaWNcbiAqL1xudmFyIGZsYWcgPSByZXF1aXJlKCcuL2ZsYWcnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY3R4LCBuYW1lLCBtZXRob2QpIHtcbiAgY3R4W25hbWVdID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvbGRfc3NmaSA9IGZsYWcodGhpcywgJ3NzZmknKTtcbiAgICBpZiAob2xkX3NzZmkgJiYgY29uZmlnLmluY2x1ZGVTdGFjayA9PT0gZmFsc2UpXG4gICAgICBmbGFnKHRoaXMsICdzc2ZpJywgY3R4W25hbWVdKTtcbiAgICB2YXIgcmVzdWx0ID0gbWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgcmV0dXJuIHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gdGhpcyA6IHJlc3VsdDtcbiAgfTtcbn07XG4iLCIvKiFcbiAqIENoYWkgLSBhZGRQcm9wZXJ0eSB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyoqXG4gKiAjIyMgYWRkUHJvcGVydHkgKGN0eCwgbmFtZSwgZ2V0dGVyKVxuICpcbiAqIEFkZHMgYSBwcm9wZXJ0eSB0byB0aGUgcHJvdG90eXBlIG9mIGFuIG9iamVjdC5cbiAqXG4gKiAgICAgdXRpbHMuYWRkUHJvcGVydHkoY2hhaS5Bc3NlcnRpb24ucHJvdG90eXBlLCAnZm9vJywgZnVuY3Rpb24gKCkge1xuICogICAgICAgdmFyIG9iaiA9IHV0aWxzLmZsYWcodGhpcywgJ29iamVjdCcpO1xuICogICAgICAgbmV3IGNoYWkuQXNzZXJ0aW9uKG9iaikudG8uYmUuaW5zdGFuY2VvZihGb28pO1xuICogICAgIH0pO1xuICpcbiAqIENhbiBhbHNvIGJlIGFjY2Vzc2VkIGRpcmVjdGx5IGZyb20gYGNoYWkuQXNzZXJ0aW9uYC5cbiAqXG4gKiAgICAgY2hhaS5Bc3NlcnRpb24uYWRkUHJvcGVydHkoJ2ZvbycsIGZuKTtcbiAqXG4gKiBUaGVuIGNhbiBiZSB1c2VkIGFzIGFueSBvdGhlciBhc3NlcnRpb24uXG4gKlxuICogICAgIGV4cGVjdChteUZvbykudG8uYmUuZm9vO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjdHggb2JqZWN0IHRvIHdoaWNoIHRoZSBwcm9wZXJ0eSBpcyBhZGRlZFxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgb2YgcHJvcGVydHkgdG8gYWRkXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBnZXR0ZXIgZnVuY3Rpb24gdG8gYmUgdXNlZCBmb3IgbmFtZVxuICogQG5hbWUgYWRkUHJvcGVydHlcbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY3R4LCBuYW1lLCBnZXR0ZXIpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0eCwgbmFtZSxcbiAgICB7IGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gZ2V0dGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IHRoaXMgOiByZXN1bHQ7XG4gICAgICB9XG4gICAgLCBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59O1xuIiwiLyohXG4gKiBDaGFpIC0gZmxhZyB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyoqXG4gKiAjIyMgZmxhZyhvYmplY3QgLGtleSwgW3ZhbHVlXSlcbiAqXG4gKiBHZXQgb3Igc2V0IGEgZmxhZyB2YWx1ZSBvbiBhbiBvYmplY3QuIElmIGFcbiAqIHZhbHVlIGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgc2V0LCBlbHNlIGl0IHdpbGxcbiAqIHJldHVybiB0aGUgY3VycmVudGx5IHNldCB2YWx1ZSBvciBgdW5kZWZpbmVkYCBpZlxuICogdGhlIHZhbHVlIGlzIG5vdCBzZXQuXG4gKlxuICogICAgIHV0aWxzLmZsYWcodGhpcywgJ2ZvbycsICdiYXInKTsgLy8gc2V0dGVyXG4gKiAgICAgdXRpbHMuZmxhZyh0aGlzLCAnZm9vJyk7IC8vIGdldHRlciwgcmV0dXJucyBgYmFyYFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgKGNvbnN0cnVjdGVkIEFzc2VydGlvblxuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICogQHBhcmFtIHtNaXhlZH0gdmFsdWUgKG9wdGlvbmFsKVxuICogQG5hbWUgZmxhZ1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqLCBrZXksIHZhbHVlKSB7XG4gIHZhciBmbGFncyA9IG9iai5fX2ZsYWdzIHx8IChvYmouX19mbGFncyA9IE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgIGZsYWdzW2tleV0gPSB2YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmxhZ3Nba2V5XTtcbiAgfVxufTtcbiIsIi8qIVxuICogQ2hhaSAtIGdldEFjdHVhbCB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyoqXG4gKiAjIGdldEFjdHVhbChvYmplY3QsIFthY3R1YWxdKVxuICpcbiAqIFJldHVybnMgdGhlIGBhY3R1YWxgIHZhbHVlIGZvciBhbiBBc3NlcnRpb25cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IChjb25zdHJ1Y3RlZCBBc3NlcnRpb24pXG4gKiBAcGFyYW0ge0FyZ3VtZW50c30gY2hhaS5Bc3NlcnRpb24ucHJvdG90eXBlLmFzc2VydCBhcmd1bWVudHNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmosIGFyZ3MpIHtcbiAgcmV0dXJuIGFyZ3MubGVuZ3RoID4gNCA/IGFyZ3NbNF0gOiBvYmouX29iajtcbn07XG4iLCIvKiFcbiAqIENoYWkgLSBnZXRFbnVtZXJhYmxlUHJvcGVydGllcyB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyoqXG4gKiAjIyMgLmdldEVudW1lcmFibGVQcm9wZXJ0aWVzKG9iamVjdClcbiAqXG4gKiBUaGlzIGFsbG93cyB0aGUgcmV0cmlldmFsIG9mIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYW4gb2JqZWN0LFxuICogaW5oZXJpdGVkIG9yIG5vdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKiBAbmFtZSBnZXRFbnVtZXJhYmxlUHJvcGVydGllc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldEVudW1lcmFibGVQcm9wZXJ0aWVzKG9iamVjdCkge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvciAodmFyIG5hbWUgaW4gb2JqZWN0KSB7XG4gICAgcmVzdWx0LnB1c2gobmFtZSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG4iLCIvKiFcbiAqIENoYWkgLSBtZXNzYWdlIGNvbXBvc2l0aW9uIHV0aWxpdHlcbiAqIENvcHlyaWdodChjKSAyMDEyLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4vKiFcbiAqIE1vZHVsZSBkZXBlbmRhbmNpZXNcbiAqL1xuXG52YXIgZmxhZyA9IHJlcXVpcmUoJy4vZmxhZycpXG4gICwgZ2V0QWN0dWFsID0gcmVxdWlyZSgnLi9nZXRBY3R1YWwnKVxuICAsIGluc3BlY3QgPSByZXF1aXJlKCcuL2luc3BlY3QnKVxuICAsIG9iakRpc3BsYXkgPSByZXF1aXJlKCcuL29iakRpc3BsYXknKTtcblxuLyoqXG4gKiAjIyMgLmdldE1lc3NhZ2Uob2JqZWN0LCBtZXNzYWdlLCBuZWdhdGVNZXNzYWdlKVxuICpcbiAqIENvbnN0cnVjdCB0aGUgZXJyb3IgbWVzc2FnZSBiYXNlZCBvbiBmbGFnc1xuICogYW5kIHRlbXBsYXRlIHRhZ3MuIFRlbXBsYXRlIHRhZ3Mgd2lsbCByZXR1cm5cbiAqIGEgc3RyaW5naWZpZWQgaW5zcGVjdGlvbiBvZiB0aGUgb2JqZWN0IHJlZmVyZW5jZWQuXG4gKlxuICogTWVzc2FnZSB0ZW1wbGF0ZSB0YWdzOlxuICogLSBgI3t0aGlzfWAgY3VycmVudCBhc3NlcnRlZCBvYmplY3RcbiAqIC0gYCN7YWN0fWAgYWN0dWFsIHZhbHVlXG4gKiAtIGAje2V4cH1gIGV4cGVjdGVkIHZhbHVlXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCAoY29uc3RydWN0ZWQgQXNzZXJ0aW9uKVxuICogQHBhcmFtIHtBcmd1bWVudHN9IGNoYWkuQXNzZXJ0aW9uLnByb3RvdHlwZS5hc3NlcnQgYXJndW1lbnRzXG4gKiBAbmFtZSBnZXRNZXNzYWdlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iaiwgYXJncykge1xuICB2YXIgbmVnYXRlID0gZmxhZyhvYmosICduZWdhdGUnKVxuICAgICwgdmFsID0gZmxhZyhvYmosICdvYmplY3QnKVxuICAgICwgZXhwZWN0ZWQgPSBhcmdzWzNdXG4gICAgLCBhY3R1YWwgPSBnZXRBY3R1YWwob2JqLCBhcmdzKVxuICAgICwgbXNnID0gbmVnYXRlID8gYXJnc1syXSA6IGFyZ3NbMV1cbiAgICAsIGZsYWdNc2cgPSBmbGFnKG9iaiwgJ21lc3NhZ2UnKTtcblxuICBtc2cgPSBtc2cgfHwgJyc7XG4gIG1zZyA9IG1zZ1xuICAgIC5yZXBsYWNlKC8je3RoaXN9L2csIG9iakRpc3BsYXkodmFsKSlcbiAgICAucmVwbGFjZSgvI3thY3R9L2csIG9iakRpc3BsYXkoYWN0dWFsKSlcbiAgICAucmVwbGFjZSgvI3tleHB9L2csIG9iakRpc3BsYXkoZXhwZWN0ZWQpKTtcblxuICByZXR1cm4gZmxhZ01zZyA/IGZsYWdNc2cgKyAnOiAnICsgbXNnIDogbXNnO1xufTtcbiIsIi8qIVxuICogQ2hhaSAtIGdldE5hbWUgdXRpbGl0eVxuICogQ29weXJpZ2h0KGMpIDIwMTItMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qKlxuICogIyBnZXROYW1lKGZ1bmMpXG4gKlxuICogR2V0cyB0aGUgbmFtZSBvZiBhIGZ1bmN0aW9uLCBpbiBhIGNyb3NzLWJyb3dzZXIgd2F5LlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGEgZnVuY3Rpb24gKHVzdWFsbHkgYSBjb25zdHJ1Y3RvcilcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChmdW5jKSB7XG4gIGlmIChmdW5jLm5hbWUpIHJldHVybiBmdW5jLm5hbWU7XG5cbiAgdmFyIG1hdGNoID0gL15cXHM/ZnVuY3Rpb24gKFteKF0qKVxcKC8uZXhlYyhmdW5jKTtcbiAgcmV0dXJuIG1hdGNoICYmIG1hdGNoWzFdID8gbWF0Y2hbMV0gOiBcIlwiO1xufTtcbiIsIi8qIVxuICogQ2hhaSAtIGdldFBhdGhWYWx1ZSB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vbG9naWNhbHBhcmFkb3gvZmlsdHJcbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qKlxuICogIyMjIC5nZXRQYXRoVmFsdWUocGF0aCwgb2JqZWN0KVxuICpcbiAqIFRoaXMgYWxsb3dzIHRoZSByZXRyaWV2YWwgb2YgdmFsdWVzIGluIGFuXG4gKiBvYmplY3QgZ2l2ZW4gYSBzdHJpbmcgcGF0aC5cbiAqXG4gKiAgICAgdmFyIG9iaiA9IHtcbiAqICAgICAgICAgcHJvcDE6IHtcbiAqICAgICAgICAgICAgIGFycjogWydhJywgJ2InLCAnYyddXG4gKiAgICAgICAgICAgLCBzdHI6ICdIZWxsbydcbiAqICAgICAgICAgfVxuICogICAgICAgLCBwcm9wMjoge1xuICogICAgICAgICAgICAgYXJyOiBbIHsgbmVzdGVkOiAnVW5pdmVyc2UnIH0gXVxuICogICAgICAgICAgICwgc3RyOiAnSGVsbG8gYWdhaW4hJ1xuICogICAgICAgICB9XG4gKiAgICAgfVxuICpcbiAqIFRoZSBmb2xsb3dpbmcgd291bGQgYmUgdGhlIHJlc3VsdHMuXG4gKlxuICogICAgIGdldFBhdGhWYWx1ZSgncHJvcDEuc3RyJywgb2JqKTsgLy8gSGVsbG9cbiAqICAgICBnZXRQYXRoVmFsdWUoJ3Byb3AxLmF0dFsyXScsIG9iaik7IC8vIGJcbiAqICAgICBnZXRQYXRoVmFsdWUoJ3Byb3AyLmFyclswXS5uZXN0ZWQnLCBvYmopOyAvLyBVbml2ZXJzZVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gKiBAcmV0dXJucyB7T2JqZWN0fSB2YWx1ZSBvciBgdW5kZWZpbmVkYFxuICogQG5hbWUgZ2V0UGF0aFZhbHVlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnZhciBnZXRQYXRoVmFsdWUgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChwYXRoLCBvYmopIHtcbiAgdmFyIHBhcnNlZCA9IHBhcnNlUGF0aChwYXRoKTtcbiAgcmV0dXJuIF9nZXRQYXRoVmFsdWUocGFyc2VkLCBvYmopO1xufTtcblxuLyohXG4gKiAjIyBwYXJzZVBhdGgocGF0aClcbiAqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdXNlZCB0byBwYXJzZSBzdHJpbmcgb2JqZWN0XG4gKiBwYXRocy4gVXNlIGluIGNvbmp1bmN0aW9uIHdpdGggYF9nZXRQYXRoVmFsdWVgLlxuICpcbiAqICAgICAgdmFyIHBhcnNlZCA9IHBhcnNlUGF0aCgnbXlvYmplY3QucHJvcGVydHkuc3VicHJvcCcpO1xuICpcbiAqICMjIyBQYXRoczpcbiAqXG4gKiAqIENhbiBiZSBhcyBuZWFyIGluZmluaXRlbHkgZGVlcCBhbmQgbmVzdGVkXG4gKiAqIEFycmF5cyBhcmUgYWxzbyB2YWxpZCB1c2luZyB0aGUgZm9ybWFsIGBteW9iamVjdC5kb2N1bWVudFszXS5wcm9wZXJ0eWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAqIEByZXR1cm5zIHtPYmplY3R9IHBhcnNlZFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGFyc2VQYXRoIChwYXRoKSB7XG4gIHZhciBzdHIgPSBwYXRoLnJlcGxhY2UoL1xcWy9nLCAnLlsnKVxuICAgICwgcGFydHMgPSBzdHIubWF0Y2goLyhcXFxcXFwufFteLl0rPykrL2cpO1xuICByZXR1cm4gcGFydHMubWFwKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHZhciByZSA9IC9cXFsoXFxkKylcXF0kL1xuICAgICAgLCBtQXJyID0gcmUuZXhlYyh2YWx1ZSlcbiAgICBpZiAobUFycikgcmV0dXJuIHsgaTogcGFyc2VGbG9hdChtQXJyWzFdKSB9O1xuICAgIGVsc2UgcmV0dXJuIHsgcDogdmFsdWUgfTtcbiAgfSk7XG59O1xuXG4vKiFcbiAqICMjIF9nZXRQYXRoVmFsdWUocGFyc2VkLCBvYmopXG4gKlxuICogSGVscGVyIGNvbXBhbmlvbiBmdW5jdGlvbiBmb3IgYC5wYXJzZVBhdGhgIHRoYXQgcmV0dXJuc1xuICogdGhlIHZhbHVlIGxvY2F0ZWQgYXQgdGhlIHBhcnNlZCBhZGRyZXNzLlxuICpcbiAqICAgICAgdmFyIHZhbHVlID0gZ2V0UGF0aFZhbHVlKHBhcnNlZCwgb2JqKTtcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFyc2VkIGRlZmluaXRpb24gZnJvbSBgcGFyc2VQYXRoYC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgdG8gc2VhcmNoIGFnYWluc3RcbiAqIEByZXR1cm5zIHtPYmplY3R8VW5kZWZpbmVkfSB2YWx1ZVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gX2dldFBhdGhWYWx1ZSAocGFyc2VkLCBvYmopIHtcbiAgdmFyIHRtcCA9IG9ialxuICAgICwgcmVzO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHBhcnNlZC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIgcGFydCA9IHBhcnNlZFtpXTtcbiAgICBpZiAodG1wKSB7XG4gICAgICBpZiAoJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBwYXJ0LnApXG4gICAgICAgIHRtcCA9IHRtcFtwYXJ0LnBdO1xuICAgICAgZWxzZSBpZiAoJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBwYXJ0LmkpXG4gICAgICAgIHRtcCA9IHRtcFtwYXJ0LmldO1xuICAgICAgaWYgKGkgPT0gKGwgLSAxKSkgcmVzID0gdG1wO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXMgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXM7XG59O1xuIiwiLyohXG4gKiBDaGFpIC0gZ2V0UHJvcGVydGllcyB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyoqXG4gKiAjIyMgLmdldFByb3BlcnRpZXMob2JqZWN0KVxuICpcbiAqIFRoaXMgYWxsb3dzIHRoZSByZXRyaWV2YWwgb2YgcHJvcGVydHkgbmFtZXMgb2YgYW4gb2JqZWN0LCBlbnVtZXJhYmxlIG9yIG5vdCxcbiAqIGluaGVyaXRlZCBvciBub3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICogQHJldHVybnMge0FycmF5fVxuICogQG5hbWUgZ2V0UHJvcGVydGllc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldFByb3BlcnRpZXMob2JqZWN0KSB7XG4gIHZhciByZXN1bHQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhzdWJqZWN0KTtcblxuICBmdW5jdGlvbiBhZGRQcm9wZXJ0eShwcm9wZXJ0eSkge1xuICAgIGlmIChyZXN1bHQuaW5kZXhPZihwcm9wZXJ0eSkgPT09IC0xKSB7XG4gICAgICByZXN1bHQucHVzaChwcm9wZXJ0eSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHN1YmplY3QpO1xuICB3aGlsZSAocHJvdG8gIT09IG51bGwpIHtcbiAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhwcm90bykuZm9yRWFjaChhZGRQcm9wZXJ0eSk7XG4gICAgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG8pO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG4iLCIvKiFcbiAqIGNoYWlcbiAqIENvcHlyaWdodChjKSAyMDExIEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyohXG4gKiBNYWluIGV4cG9ydHNcbiAqL1xuXG52YXIgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8qIVxuICogdGVzdCB1dGlsaXR5XG4gKi9cblxuZXhwb3J0cy50ZXN0ID0gcmVxdWlyZSgnLi90ZXN0Jyk7XG5cbi8qIVxuICogdHlwZSB1dGlsaXR5XG4gKi9cblxuZXhwb3J0cy50eXBlID0gcmVxdWlyZSgnLi90eXBlJyk7XG5cbi8qIVxuICogbWVzc2FnZSB1dGlsaXR5XG4gKi9cblxuZXhwb3J0cy5nZXRNZXNzYWdlID0gcmVxdWlyZSgnLi9nZXRNZXNzYWdlJyk7XG5cbi8qIVxuICogYWN0dWFsIHV0aWxpdHlcbiAqL1xuXG5leHBvcnRzLmdldEFjdHVhbCA9IHJlcXVpcmUoJy4vZ2V0QWN0dWFsJyk7XG5cbi8qIVxuICogSW5zcGVjdCB1dGlsXG4gKi9cblxuZXhwb3J0cy5pbnNwZWN0ID0gcmVxdWlyZSgnLi9pbnNwZWN0Jyk7XG5cbi8qIVxuICogT2JqZWN0IERpc3BsYXkgdXRpbFxuICovXG5cbmV4cG9ydHMub2JqRGlzcGxheSA9IHJlcXVpcmUoJy4vb2JqRGlzcGxheScpO1xuXG4vKiFcbiAqIEZsYWcgdXRpbGl0eVxuICovXG5cbmV4cG9ydHMuZmxhZyA9IHJlcXVpcmUoJy4vZmxhZycpO1xuXG4vKiFcbiAqIEZsYWcgdHJhbnNmZXJyaW5nIHV0aWxpdHlcbiAqL1xuXG5leHBvcnRzLnRyYW5zZmVyRmxhZ3MgPSByZXF1aXJlKCcuL3RyYW5zZmVyRmxhZ3MnKTtcblxuLyohXG4gKiBEZWVwIGVxdWFsIHV0aWxpdHlcbiAqL1xuXG5leHBvcnRzLmVxbCA9IHJlcXVpcmUoJ2RlZXAtZXFsJyk7XG5cbi8qIVxuICogRGVlcCBwYXRoIHZhbHVlXG4gKi9cblxuZXhwb3J0cy5nZXRQYXRoVmFsdWUgPSByZXF1aXJlKCcuL2dldFBhdGhWYWx1ZScpO1xuXG4vKiFcbiAqIEZ1bmN0aW9uIG5hbWVcbiAqL1xuXG5leHBvcnRzLmdldE5hbWUgPSByZXF1aXJlKCcuL2dldE5hbWUnKTtcblxuLyohXG4gKiBhZGQgUHJvcGVydHlcbiAqL1xuXG5leHBvcnRzLmFkZFByb3BlcnR5ID0gcmVxdWlyZSgnLi9hZGRQcm9wZXJ0eScpO1xuXG4vKiFcbiAqIGFkZCBNZXRob2RcbiAqL1xuXG5leHBvcnRzLmFkZE1ldGhvZCA9IHJlcXVpcmUoJy4vYWRkTWV0aG9kJyk7XG5cbi8qIVxuICogb3ZlcndyaXRlIFByb3BlcnR5XG4gKi9cblxuZXhwb3J0cy5vdmVyd3JpdGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vb3ZlcndyaXRlUHJvcGVydHknKTtcblxuLyohXG4gKiBvdmVyd3JpdGUgTWV0aG9kXG4gKi9cblxuZXhwb3J0cy5vdmVyd3JpdGVNZXRob2QgPSByZXF1aXJlKCcuL292ZXJ3cml0ZU1ldGhvZCcpO1xuXG4vKiFcbiAqIEFkZCBhIGNoYWluYWJsZSBtZXRob2RcbiAqL1xuXG5leHBvcnRzLmFkZENoYWluYWJsZU1ldGhvZCA9IHJlcXVpcmUoJy4vYWRkQ2hhaW5hYmxlTWV0aG9kJyk7XG5cbi8qIVxuICogT3ZlcndyaXRlIGNoYWluYWJsZSBtZXRob2RcbiAqL1xuXG5leHBvcnRzLm92ZXJ3cml0ZUNoYWluYWJsZU1ldGhvZCA9IHJlcXVpcmUoJy4vb3ZlcndyaXRlQ2hhaW5hYmxlTWV0aG9kJyk7XG5cbiIsIi8vIFRoaXMgaXMgKGFsbW9zdCkgZGlyZWN0bHkgZnJvbSBOb2RlLmpzIHV0aWxzXG4vLyBodHRwczovL2dpdGh1Yi5jb20vam95ZW50L25vZGUvYmxvYi9mOGMzMzVkMGNhZjQ3ZjE2ZDMxNDEzZjg5YWEyOGVkYTM4NzhlM2FhL2xpYi91dGlsLmpzXG5cbnZhciBnZXROYW1lID0gcmVxdWlyZSgnLi9nZXROYW1lJyk7XG52YXIgZ2V0UHJvcGVydGllcyA9IHJlcXVpcmUoJy4vZ2V0UHJvcGVydGllcycpO1xudmFyIGdldEVudW1lcmFibGVQcm9wZXJ0aWVzID0gcmVxdWlyZSgnLi9nZXRFbnVtZXJhYmxlUHJvcGVydGllcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGluc3BlY3Q7XG5cbi8qKlxuICogRWNob3MgdGhlIHZhbHVlIG9mIGEgdmFsdWUuIFRyeXMgdG8gcHJpbnQgdGhlIHZhbHVlIG91dFxuICogaW4gdGhlIGJlc3Qgd2F5IHBvc3NpYmxlIGdpdmVuIHRoZSBkaWZmZXJlbnQgdHlwZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIHByaW50IG91dC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gc2hvd0hpZGRlbiBGbGFnIHRoYXQgc2hvd3MgaGlkZGVuIChub3QgZW51bWVyYWJsZSlcbiAqICAgIHByb3BlcnRpZXMgb2Ygb2JqZWN0cy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBkZXB0aCBEZXB0aCBpbiB3aGljaCB0byBkZXNjZW5kIGluIG9iamVjdC4gRGVmYXVsdCBpcyAyLlxuICogQHBhcmFtIHtCb29sZWFufSBjb2xvcnMgRmxhZyB0byB0dXJuIG9uIEFOU0kgZXNjYXBlIGNvZGVzIHRvIGNvbG9yIHRoZVxuICogICAgb3V0cHV0LiBEZWZhdWx0IGlzIGZhbHNlIChubyBjb2xvcmluZykuXG4gKi9cbmZ1bmN0aW9uIGluc3BlY3Qob2JqLCBzaG93SGlkZGVuLCBkZXB0aCwgY29sb3JzKSB7XG4gIHZhciBjdHggPSB7XG4gICAgc2hvd0hpZGRlbjogc2hvd0hpZGRlbixcbiAgICBzZWVuOiBbXSxcbiAgICBzdHlsaXplOiBmdW5jdGlvbiAoc3RyKSB7IHJldHVybiBzdHI7IH1cbiAgfTtcbiAgcmV0dXJuIGZvcm1hdFZhbHVlKGN0eCwgb2JqLCAodHlwZW9mIGRlcHRoID09PSAndW5kZWZpbmVkJyA/IDIgOiBkZXB0aCkpO1xufVxuXG4vLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS8xMDQ0MTI4L1xudmFyIGdldE91dGVySFRNTCA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgaWYgKCdvdXRlckhUTUwnIGluIGVsZW1lbnQpIHJldHVybiBlbGVtZW50Lm91dGVySFRNTDtcbiAgdmFyIG5zID0gXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCI7XG4gIHZhciBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobnMsICdfJyk7XG4gIHZhciBlbGVtUHJvdG8gPSAod2luZG93LkhUTUxFbGVtZW50IHx8IHdpbmRvdy5FbGVtZW50KS5wcm90b3R5cGU7XG4gIHZhciB4bWxTZXJpYWxpemVyID0gbmV3IFhNTFNlcmlhbGl6ZXIoKTtcbiAgdmFyIGh0bWw7XG4gIGlmIChkb2N1bWVudC54bWxWZXJzaW9uKSB7XG4gICAgcmV0dXJuIHhtbFNlcmlhbGl6ZXIuc2VyaWFsaXplVG9TdHJpbmcoZWxlbWVudCk7XG4gIH0gZWxzZSB7XG4gICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGVsZW1lbnQuY2xvbmVOb2RlKGZhbHNlKSk7XG4gICAgaHRtbCA9IGNvbnRhaW5lci5pbm5lckhUTUwucmVwbGFjZSgnPjwnLCAnPicgKyBlbGVtZW50LmlubmVySFRNTCArICc8Jyk7XG4gICAgY29udGFpbmVyLmlubmVySFRNTCA9ICcnO1xuICAgIHJldHVybiBodG1sO1xuICB9XG59O1xuXG4vLyBSZXR1cm5zIHRydWUgaWYgb2JqZWN0IGlzIGEgRE9NIGVsZW1lbnQuXG52YXIgaXNET01FbGVtZW50ID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICBpZiAodHlwZW9mIEhUTUxFbGVtZW50ID09PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBvYmplY3QgaW5zdGFuY2VvZiBIVE1MRWxlbWVudDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gb2JqZWN0ICYmXG4gICAgICB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJlxuICAgICAgb2JqZWN0Lm5vZGVUeXBlID09PSAxICYmXG4gICAgICB0eXBlb2Ygb2JqZWN0Lm5vZGVOYW1lID09PSAnc3RyaW5nJztcbiAgfVxufTtcblxuZnVuY3Rpb24gZm9ybWF0VmFsdWUoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzKSB7XG4gIC8vIFByb3ZpZGUgYSBob29rIGZvciB1c2VyLXNwZWNpZmllZCBpbnNwZWN0IGZ1bmN0aW9ucy5cbiAgLy8gQ2hlY2sgdGhhdCB2YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCBhbiBpbnNwZWN0IGZ1bmN0aW9uIG9uIGl0XG4gIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUuaW5zcGVjdCA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgLy8gRmlsdGVyIG91dCB0aGUgdXRpbCBtb2R1bGUsIGl0J3MgaW5zcGVjdCBmdW5jdGlvbiBpcyBzcGVjaWFsXG4gICAgICB2YWx1ZS5pbnNwZWN0ICE9PSBleHBvcnRzLmluc3BlY3QgJiZcbiAgICAgIC8vIEFsc28gZmlsdGVyIG91dCBhbnkgcHJvdG90eXBlIG9iamVjdHMgdXNpbmcgdGhlIGNpcmN1bGFyIGNoZWNrLlxuICAgICAgISh2YWx1ZS5jb25zdHJ1Y3RvciAmJiB2YWx1ZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgPT09IHZhbHVlKSkge1xuICAgIHZhciByZXQgPSB2YWx1ZS5pbnNwZWN0KHJlY3Vyc2VUaW1lcyk7XG4gICAgaWYgKHR5cGVvZiByZXQgIT09ICdzdHJpbmcnKSB7XG4gICAgICByZXQgPSBmb3JtYXRWYWx1ZShjdHgsIHJldCwgcmVjdXJzZVRpbWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8vIFByaW1pdGl2ZSB0eXBlcyBjYW5ub3QgaGF2ZSBwcm9wZXJ0aWVzXG4gIHZhciBwcmltaXRpdmUgPSBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSk7XG4gIGlmIChwcmltaXRpdmUpIHtcbiAgICByZXR1cm4gcHJpbWl0aXZlO1xuICB9XG5cbiAgLy8gSWYgaXQncyBET00gZWxlbSwgZ2V0IG91dGVyIEhUTUwuXG4gIGlmIChpc0RPTUVsZW1lbnQodmFsdWUpKSB7XG4gICAgcmV0dXJuIGdldE91dGVySFRNTCh2YWx1ZSk7XG4gIH1cblxuICAvLyBMb29rIHVwIHRoZSBrZXlzIG9mIHRoZSBvYmplY3QuXG4gIHZhciB2aXNpYmxlS2V5cyA9IGdldEVudW1lcmFibGVQcm9wZXJ0aWVzKHZhbHVlKTtcbiAgdmFyIGtleXMgPSBjdHguc2hvd0hpZGRlbiA/IGdldFByb3BlcnRpZXModmFsdWUpIDogdmlzaWJsZUtleXM7XG5cbiAgLy8gU29tZSB0eXBlIG9mIG9iamVjdCB3aXRob3V0IHByb3BlcnRpZXMgY2FuIGJlIHNob3J0Y3V0dGVkLlxuICAvLyBJbiBJRSwgZXJyb3JzIGhhdmUgYSBzaW5nbGUgYHN0YWNrYCBwcm9wZXJ0eSwgb3IgaWYgdGhleSBhcmUgdmFuaWxsYSBgRXJyb3JgLFxuICAvLyBhIGBzdGFja2AgcGx1cyBgZGVzY3JpcHRpb25gIHByb3BlcnR5OyBpZ25vcmUgdGhvc2UgZm9yIGNvbnNpc3RlbmN5LlxuICBpZiAoa2V5cy5sZW5ndGggPT09IDAgfHwgKGlzRXJyb3IodmFsdWUpICYmIChcbiAgICAgIChrZXlzLmxlbmd0aCA9PT0gMSAmJiBrZXlzWzBdID09PSAnc3RhY2snKSB8fFxuICAgICAgKGtleXMubGVuZ3RoID09PSAyICYmIGtleXNbMF0gPT09ICdkZXNjcmlwdGlvbicgJiYga2V5c1sxXSA9PT0gJ3N0YWNrJylcbiAgICAgKSkpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgbmFtZSA9IGdldE5hbWUodmFsdWUpO1xuICAgICAgdmFyIG5hbWVTdWZmaXggPSBuYW1lID8gJzogJyArIG5hbWUgOiAnJztcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW0Z1bmN0aW9uJyArIG5hbWVTdWZmaXggKyAnXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfVxuICAgIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoRGF0ZS5wcm90b3R5cGUudG9VVENTdHJpbmcuY2FsbCh2YWx1ZSksICdkYXRlJyk7XG4gICAgfVxuICAgIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgYmFzZSA9ICcnLCBhcnJheSA9IGZhbHNlLCBicmFjZXMgPSBbJ3snLCAnfSddO1xuXG4gIC8vIE1ha2UgQXJyYXkgc2F5IHRoYXQgdGhleSBhcmUgQXJyYXlcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgYXJyYXkgPSB0cnVlO1xuICAgIGJyYWNlcyA9IFsnWycsICddJ107XG4gIH1cblxuICAvLyBNYWtlIGZ1bmN0aW9ucyBzYXkgdGhhdCB0aGV5IGFyZSBmdW5jdGlvbnNcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBuYW1lID0gZ2V0TmFtZSh2YWx1ZSk7XG4gICAgdmFyIG5hbWVTdWZmaXggPSBuYW1lID8gJzogJyArIG5hbWUgOiAnJztcbiAgICBiYXNlID0gJyBbRnVuY3Rpb24nICsgbmFtZVN1ZmZpeCArICddJztcbiAgfVxuXG4gIC8vIE1ha2UgUmVnRXhwcyBzYXkgdGhhdCB0aGV5IGFyZSBSZWdFeHBzXG4gIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZGF0ZXMgd2l0aCBwcm9wZXJ0aWVzIGZpcnN0IHNheSB0aGUgZGF0ZVxuICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBEYXRlLnByb3RvdHlwZS50b1VUQ1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZXJyb3Igd2l0aCBtZXNzYWdlIGZpcnN0IHNheSB0aGUgZXJyb3JcbiAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCAmJiAoIWFycmF5IHx8IHZhbHVlLmxlbmd0aCA9PSAwKSkge1xuICAgIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgYnJhY2VzWzFdO1xuICB9XG5cbiAgaWYgKHJlY3Vyc2VUaW1lcyA8IDApIHtcbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tPYmplY3RdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cblxuICBjdHguc2Vlbi5wdXNoKHZhbHVlKTtcblxuICB2YXIgb3V0cHV0O1xuICBpZiAoYXJyYXkpIHtcbiAgICBvdXRwdXQgPSBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKTtcbiAgfSBlbHNlIHtcbiAgICBvdXRwdXQgPSBrZXlzLm1hcChmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KTtcbiAgICB9KTtcbiAgfVxuXG4gIGN0eC5zZWVuLnBvcCgpO1xuXG4gIHJldHVybiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpIHtcbiAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCd1bmRlZmluZWQnLCAndW5kZWZpbmVkJyk7XG5cbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgdmFyIHNpbXBsZSA9ICdcXCcnICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpLnJlcGxhY2UoL15cInxcIiQvZywgJycpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKSArICdcXCcnO1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKHNpbXBsZSwgJ3N0cmluZycpO1xuXG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnbnVtYmVyJyk7XG5cbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnYm9vbGVhbicpO1xuICB9XG4gIC8vIEZvciBzb21lIHJlYXNvbiB0eXBlb2YgbnVsbCBpcyBcIm9iamVjdFwiLCBzbyBzcGVjaWFsIGNhc2UgaGVyZS5cbiAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCdudWxsJywgJ251bGwnKTtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEVycm9yKHZhbHVlKSB7XG4gIHJldHVybiAnWycgKyBFcnJvci5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgKyAnXSc7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cykge1xuICB2YXIgb3V0cHV0ID0gW107XG4gIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgU3RyaW5nKGkpKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBTdHJpbmcoaSksIHRydWUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0LnB1c2goJycpO1xuICAgIH1cbiAgfVxuICBrZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgaWYgKCFrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIGtleSwgdHJ1ZSkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSkge1xuICB2YXIgbmFtZSwgc3RyO1xuICBpZiAodmFsdWUuX19sb29rdXBHZXR0ZXJfXykge1xuICAgIGlmICh2YWx1ZS5fX2xvb2t1cEdldHRlcl9fKGtleSkpIHtcbiAgICAgIGlmICh2YWx1ZS5fX2xvb2t1cFNldHRlcl9fKGtleSkpIHtcbiAgICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXIvU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodmFsdWUuX19sb29rdXBTZXR0ZXJfXyhrZXkpKSB7XG4gICAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICh2aXNpYmxlS2V5cy5pbmRleE9mKGtleSkgPCAwKSB7XG4gICAgbmFtZSA9ICdbJyArIGtleSArICddJztcbiAgfVxuICBpZiAoIXN0cikge1xuICAgIGlmIChjdHguc2Vlbi5pbmRleE9mKHZhbHVlW2tleV0pIDwgMCkge1xuICAgICAgaWYgKHJlY3Vyc2VUaW1lcyA9PT0gbnVsbCkge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIHZhbHVlW2tleV0sIG51bGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCB2YWx1ZVtrZXldLCByZWN1cnNlVGltZXMgLSAxKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHIuaW5kZXhPZignXFxuJykgPiAtMSkge1xuICAgICAgICBpZiAoYXJyYXkpIHtcbiAgICAgICAgICBzdHIgPSBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJykuc3Vic3RyKDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0ciA9ICdcXG4nICsgc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0NpcmN1bGFyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmICh0eXBlb2YgbmFtZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAoYXJyYXkgJiYga2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgbmFtZSA9IEpTT04uc3RyaW5naWZ5KCcnICsga2V5KTtcbiAgICBpZiAobmFtZS5tYXRjaCgvXlwiKFthLXpBLVpfXVthLXpBLVpfMC05XSopXCIkLykpIHtcbiAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cigxLCBuYW1lLmxlbmd0aCAtIDIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICduYW1lJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oXlwifFwiJCkvZywgXCInXCIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICdzdHJpbmcnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmFtZSArICc6ICcgKyBzdHI7XG59XG5cblxuZnVuY3Rpb24gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpIHtcbiAgdmFyIG51bUxpbmVzRXN0ID0gMDtcbiAgdmFyIGxlbmd0aCA9IG91dHB1dC5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgY3VyKSB7XG4gICAgbnVtTGluZXNFc3QrKztcbiAgICBpZiAoY3VyLmluZGV4T2YoJ1xcbicpID49IDApIG51bUxpbmVzRXN0Kys7XG4gICAgcmV0dXJuIHByZXYgKyBjdXIubGVuZ3RoICsgMTtcbiAgfSwgMCk7XG5cbiAgaWYgKGxlbmd0aCA+IDYwKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArXG4gICAgICAgICAgIChiYXNlID09PSAnJyA/ICcnIDogYmFzZSArICdcXG4gJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBvdXRwdXQuam9pbignLFxcbiAgJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBicmFjZXNbMV07XG4gIH1cblxuICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArICcgJyArIG91dHB1dC5qb2luKCcsICcpICsgJyAnICsgYnJhY2VzWzFdO1xufVxuXG5mdW5jdGlvbiBpc0FycmF5KGFyKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGFyKSB8fFxuICAgICAgICAgKHR5cGVvZiBhciA9PT0gJ29iamVjdCcgJiYgb2JqZWN0VG9TdHJpbmcoYXIpID09PSAnW29iamVjdCBBcnJheV0nKTtcbn1cblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIHR5cGVvZiByZSA9PT0gJ29iamVjdCcgJiYgb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cblxuZnVuY3Rpb24gaXNEYXRlKGQpIHtcbiAgcmV0dXJuIHR5cGVvZiBkID09PSAnb2JqZWN0JyAmJiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgcmV0dXJuIHR5cGVvZiBlID09PSAnb2JqZWN0JyAmJiBvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJztcbn1cblxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufVxuIiwiLyohXG4gKiBDaGFpIC0gZmxhZyB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyohXG4gKiBNb2R1bGUgZGVwZW5kYW5jaWVzXG4gKi9cblxudmFyIGluc3BlY3QgPSByZXF1aXJlKCcuL2luc3BlY3QnKTtcbnZhciBjb25maWcgPSByZXF1aXJlKCcuLi9jb25maWcnKTtcblxuLyoqXG4gKiAjIyMgLm9iakRpc3BsYXkgKG9iamVjdClcbiAqXG4gKiBEZXRlcm1pbmVzIGlmIGFuIG9iamVjdCBvciBhbiBhcnJheSBtYXRjaGVzXG4gKiBjcml0ZXJpYSB0byBiZSBpbnNwZWN0ZWQgaW4tbGluZSBmb3IgZXJyb3JcbiAqIG1lc3NhZ2VzIG9yIHNob3VsZCBiZSB0cnVuY2F0ZWQuXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gamF2YXNjcmlwdCBvYmplY3QgdG8gaW5zcGVjdFxuICogQG5hbWUgb2JqRGlzcGxheVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIHN0ciA9IGluc3BlY3Qob2JqKVxuICAgICwgdHlwZSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopO1xuXG4gIGlmIChjb25maWcudHJ1bmNhdGVUaHJlc2hvbGQgJiYgc3RyLmxlbmd0aCA+PSBjb25maWcudHJ1bmNhdGVUaHJlc2hvbGQpIHtcbiAgICBpZiAodHlwZSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJykge1xuICAgICAgcmV0dXJuICFvYmoubmFtZSB8fCBvYmoubmFtZSA9PT0gJydcbiAgICAgICAgPyAnW0Z1bmN0aW9uXSdcbiAgICAgICAgOiAnW0Z1bmN0aW9uOiAnICsgb2JqLm5hbWUgKyAnXSc7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICByZXR1cm4gJ1sgQXJyYXkoJyArIG9iai5sZW5ndGggKyAnKSBdJztcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdbb2JqZWN0IE9iamVjdF0nKSB7XG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iailcbiAgICAgICAgLCBrc3RyID0ga2V5cy5sZW5ndGggPiAyXG4gICAgICAgICAgPyBrZXlzLnNwbGljZSgwLCAyKS5qb2luKCcsICcpICsgJywgLi4uJ1xuICAgICAgICAgIDoga2V5cy5qb2luKCcsICcpO1xuICAgICAgcmV0dXJuICd7IE9iamVjdCAoJyArIGtzdHIgKyAnKSB9JztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxufTtcbiIsIi8qIVxuICogQ2hhaSAtIG92ZXJ3cml0ZUNoYWluYWJsZU1ldGhvZCB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyoqXG4gKiAjIyMgb3ZlcndyaXRlQ2hhaW5hYmxlTWV0aG9kIChjdHgsIG5hbWUsIGZuKVxuICpcbiAqIE92ZXJ3aXRlcyBhbiBhbHJlYWR5IGV4aXN0aW5nIGNoYWluYWJsZSBtZXRob2RcbiAqIGFuZCBwcm92aWRlcyBhY2Nlc3MgdG8gdGhlIHByZXZpb3VzIGZ1bmN0aW9uIG9yXG4gKiBwcm9wZXJ0eS4gIE11c3QgcmV0dXJuIGZ1bmN0aW9ucyB0byBiZSB1c2VkIGZvclxuICogbmFtZS5cbiAqXG4gKiAgICAgdXRpbHMub3ZlcndyaXRlQ2hhaW5hYmxlTWV0aG9kKGNoYWkuQXNzZXJ0aW9uLnByb3RvdHlwZSwgJ2xlbmd0aCcsXG4gKiAgICAgICBmdW5jdGlvbiAoX3N1cGVyKSB7XG4gKiAgICAgICB9XG4gKiAgICAgLCBmdW5jdGlvbiAoX3N1cGVyKSB7XG4gKiAgICAgICB9XG4gKiAgICAgKTtcbiAqXG4gKiBDYW4gYWxzbyBiZSBhY2Nlc3NlZCBkaXJlY3RseSBmcm9tIGBjaGFpLkFzc2VydGlvbmAuXG4gKlxuICogICAgIGNoYWkuQXNzZXJ0aW9uLm92ZXJ3cml0ZUNoYWluYWJsZU1ldGhvZCgnZm9vJywgZm4sIGZuKTtcbiAqXG4gKiBUaGVuIGNhbiBiZSB1c2VkIGFzIGFueSBvdGhlciBhc3NlcnRpb24uXG4gKlxuICogICAgIGV4cGVjdChteUZvbykudG8uaGF2ZS5sZW5ndGgoMyk7XG4gKiAgICAgZXhwZWN0KG15Rm9vKS50by5oYXZlLmxlbmd0aC5hYm92ZSgzKTtcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY3R4IG9iamVjdCB3aG9zZSBtZXRob2QgLyBwcm9wZXJ0eSBpcyB0byBiZSBvdmVyd3JpdHRlblxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgb2YgbWV0aG9kIC8gcHJvcGVydHkgdG8gb3ZlcndyaXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBtZXRob2QgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgZnVuY3Rpb24gdG8gYmUgdXNlZCBmb3IgbmFtZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2hhaW5pbmdCZWhhdmlvciBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBmdW5jdGlvbiB0byBiZSB1c2VkIGZvciBwcm9wZXJ0eVxuICogQG5hbWUgb3ZlcndyaXRlQ2hhaW5hYmxlTWV0aG9kXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGN0eCwgbmFtZSwgbWV0aG9kLCBjaGFpbmluZ0JlaGF2aW9yKSB7XG4gIHZhciBjaGFpbmFibGVCZWhhdmlvciA9IGN0eC5fX21ldGhvZHNbbmFtZV07XG5cbiAgdmFyIF9jaGFpbmluZ0JlaGF2aW9yID0gY2hhaW5hYmxlQmVoYXZpb3IuY2hhaW5pbmdCZWhhdmlvcjtcbiAgY2hhaW5hYmxlQmVoYXZpb3IuY2hhaW5pbmdCZWhhdmlvciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVzdWx0ID0gY2hhaW5pbmdCZWhhdmlvcihfY2hhaW5pbmdCZWhhdmlvcikuY2FsbCh0aGlzKTtcbiAgICByZXR1cm4gcmVzdWx0ID09PSB1bmRlZmluZWQgPyB0aGlzIDogcmVzdWx0O1xuICB9O1xuXG4gIHZhciBfbWV0aG9kID0gY2hhaW5hYmxlQmVoYXZpb3IubWV0aG9kO1xuICBjaGFpbmFibGVCZWhhdmlvci5tZXRob2QgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJlc3VsdCA9IG1ldGhvZChfbWV0aG9kKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IHRoaXMgOiByZXN1bHQ7XG4gIH07XG59O1xuIiwiLyohXG4gKiBDaGFpIC0gb3ZlcndyaXRlTWV0aG9kIHV0aWxpdHlcbiAqIENvcHlyaWdodChjKSAyMDEyLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4vKipcbiAqICMjIyBvdmVyd3JpdGVNZXRob2QgKGN0eCwgbmFtZSwgZm4pXG4gKlxuICogT3ZlcndpdGVzIGFuIGFscmVhZHkgZXhpc3RpbmcgbWV0aG9kIGFuZCBwcm92aWRlc1xuICogYWNjZXNzIHRvIHByZXZpb3VzIGZ1bmN0aW9uLiBNdXN0IHJldHVybiBmdW5jdGlvblxuICogdG8gYmUgdXNlZCBmb3IgbmFtZS5cbiAqXG4gKiAgICAgdXRpbHMub3ZlcndyaXRlTWV0aG9kKGNoYWkuQXNzZXJ0aW9uLnByb3RvdHlwZSwgJ2VxdWFsJywgZnVuY3Rpb24gKF9zdXBlcikge1xuICogICAgICAgcmV0dXJuIGZ1bmN0aW9uIChzdHIpIHtcbiAqICAgICAgICAgdmFyIG9iaiA9IHV0aWxzLmZsYWcodGhpcywgJ29iamVjdCcpO1xuICogICAgICAgICBpZiAob2JqIGluc3RhbmNlb2YgRm9vKSB7XG4gKiAgICAgICAgICAgbmV3IGNoYWkuQXNzZXJ0aW9uKG9iai52YWx1ZSkudG8uZXF1YWwoc3RyKTtcbiAqICAgICAgICAgfSBlbHNlIHtcbiAqICAgICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAqICAgICAgICAgfVxuICogICAgICAgfVxuICogICAgIH0pO1xuICpcbiAqIENhbiBhbHNvIGJlIGFjY2Vzc2VkIGRpcmVjdGx5IGZyb20gYGNoYWkuQXNzZXJ0aW9uYC5cbiAqXG4gKiAgICAgY2hhaS5Bc3NlcnRpb24ub3ZlcndyaXRlTWV0aG9kKCdmb28nLCBmbik7XG4gKlxuICogVGhlbiBjYW4gYmUgdXNlZCBhcyBhbnkgb3RoZXIgYXNzZXJ0aW9uLlxuICpcbiAqICAgICBleHBlY3QobXlGb28pLnRvLmVxdWFsKCdiYXInKTtcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY3R4IG9iamVjdCB3aG9zZSBtZXRob2QgaXMgdG8gYmUgb3ZlcndyaXR0ZW5cbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIG9mIG1ldGhvZCB0byBvdmVyd3JpdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG1ldGhvZCBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBmdW5jdGlvbiB0byBiZSB1c2VkIGZvciBuYW1lXG4gKiBAbmFtZSBvdmVyd3JpdGVNZXRob2RcbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY3R4LCBuYW1lLCBtZXRob2QpIHtcbiAgdmFyIF9tZXRob2QgPSBjdHhbbmFtZV1cbiAgICAsIF9zdXBlciA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XG5cbiAgaWYgKF9tZXRob2QgJiYgJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIF9tZXRob2QpXG4gICAgX3N1cGVyID0gX21ldGhvZDtcblxuICBjdHhbbmFtZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJlc3VsdCA9IG1ldGhvZChfc3VwZXIpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgcmV0dXJuIHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gdGhpcyA6IHJlc3VsdDtcbiAgfVxufTtcbiIsIi8qIVxuICogQ2hhaSAtIG92ZXJ3cml0ZVByb3BlcnR5IHV0aWxpdHlcbiAqIENvcHlyaWdodChjKSAyMDEyLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4vKipcbiAqICMjIyBvdmVyd3JpdGVQcm9wZXJ0eSAoY3R4LCBuYW1lLCBmbilcbiAqXG4gKiBPdmVyd2l0ZXMgYW4gYWxyZWFkeSBleGlzdGluZyBwcm9wZXJ0eSBnZXR0ZXIgYW5kIHByb3ZpZGVzXG4gKiBhY2Nlc3MgdG8gcHJldmlvdXMgdmFsdWUuIE11c3QgcmV0dXJuIGZ1bmN0aW9uIHRvIHVzZSBhcyBnZXR0ZXIuXG4gKlxuICogICAgIHV0aWxzLm92ZXJ3cml0ZVByb3BlcnR5KGNoYWkuQXNzZXJ0aW9uLnByb3RvdHlwZSwgJ29rJywgZnVuY3Rpb24gKF9zdXBlcikge1xuICogICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAqICAgICAgICAgdmFyIG9iaiA9IHV0aWxzLmZsYWcodGhpcywgJ29iamVjdCcpO1xuICogICAgICAgICBpZiAob2JqIGluc3RhbmNlb2YgRm9vKSB7XG4gKiAgICAgICAgICAgbmV3IGNoYWkuQXNzZXJ0aW9uKG9iai5uYW1lKS50by5lcXVhbCgnYmFyJyk7XG4gKiAgICAgICAgIH0gZWxzZSB7XG4gKiAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gKiAgICAgICAgIH1cbiAqICAgICAgIH1cbiAqICAgICB9KTtcbiAqXG4gKlxuICogQ2FuIGFsc28gYmUgYWNjZXNzZWQgZGlyZWN0bHkgZnJvbSBgY2hhaS5Bc3NlcnRpb25gLlxuICpcbiAqICAgICBjaGFpLkFzc2VydGlvbi5vdmVyd3JpdGVQcm9wZXJ0eSgnZm9vJywgZm4pO1xuICpcbiAqIFRoZW4gY2FuIGJlIHVzZWQgYXMgYW55IG90aGVyIGFzc2VydGlvbi5cbiAqXG4gKiAgICAgZXhwZWN0KG15Rm9vKS50by5iZS5vaztcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY3R4IG9iamVjdCB3aG9zZSBwcm9wZXJ0eSBpcyB0byBiZSBvdmVyd3JpdHRlblxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgb2YgcHJvcGVydHkgdG8gb3ZlcndyaXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBnZXR0ZXIgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgZ2V0dGVyIGZ1bmN0aW9uIHRvIGJlIHVzZWQgZm9yIG5hbWVcbiAqIEBuYW1lIG92ZXJ3cml0ZVByb3BlcnR5XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGN0eCwgbmFtZSwgZ2V0dGVyKSB7XG4gIHZhciBfZ2V0ID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjdHgsIG5hbWUpXG4gICAgLCBfc3VwZXIgPSBmdW5jdGlvbiAoKSB7fTtcblxuICBpZiAoX2dldCAmJiAnZnVuY3Rpb24nID09PSB0eXBlb2YgX2dldC5nZXQpXG4gICAgX3N1cGVyID0gX2dldC5nZXRcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3R4LCBuYW1lLFxuICAgIHsgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBnZXR0ZXIoX3N1cGVyKS5jYWxsKHRoaXMpO1xuICAgICAgICByZXR1cm4gcmVzdWx0ID09PSB1bmRlZmluZWQgPyB0aGlzIDogcmVzdWx0O1xuICAgICAgfVxuICAgICwgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufTtcbiIsIi8qIVxuICogQ2hhaSAtIHRlc3QgdXRpbGl0eVxuICogQ29weXJpZ2h0KGMpIDIwMTItMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qIVxuICogTW9kdWxlIGRlcGVuZGFuY2llc1xuICovXG5cbnZhciBmbGFnID0gcmVxdWlyZSgnLi9mbGFnJyk7XG5cbi8qKlxuICogIyB0ZXN0KG9iamVjdCwgZXhwcmVzc2lvbilcbiAqXG4gKiBUZXN0IGFuZCBvYmplY3QgZm9yIGV4cHJlc3Npb24uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCAoY29uc3RydWN0ZWQgQXNzZXJ0aW9uKVxuICogQHBhcmFtIHtBcmd1bWVudHN9IGNoYWkuQXNzZXJ0aW9uLnByb3RvdHlwZS5hc3NlcnQgYXJndW1lbnRzXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqLCBhcmdzKSB7XG4gIHZhciBuZWdhdGUgPSBmbGFnKG9iaiwgJ25lZ2F0ZScpXG4gICAgLCBleHByID0gYXJnc1swXTtcbiAgcmV0dXJuIG5lZ2F0ZSA/ICFleHByIDogZXhwcjtcbn07XG4iLCIvKiFcbiAqIENoYWkgLSB0cmFuc2ZlckZsYWdzIHV0aWxpdHlcbiAqIENvcHlyaWdodChjKSAyMDEyLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4vKipcbiAqICMjIyB0cmFuc2ZlckZsYWdzKGFzc2VydGlvbiwgb2JqZWN0LCBpbmNsdWRlQWxsID0gdHJ1ZSlcbiAqXG4gKiBUcmFuc2ZlciBhbGwgdGhlIGZsYWdzIGZvciBgYXNzZXJ0aW9uYCB0byBgb2JqZWN0YC4gSWZcbiAqIGBpbmNsdWRlQWxsYCBpcyBzZXQgdG8gYGZhbHNlYCwgdGhlbiB0aGUgYmFzZSBDaGFpXG4gKiBhc3NlcnRpb24gZmxhZ3MgKG5hbWVseSBgb2JqZWN0YCwgYHNzZmlgLCBhbmQgYG1lc3NhZ2VgKVxuICogd2lsbCBub3QgYmUgdHJhbnNmZXJyZWQuXG4gKlxuICpcbiAqICAgICB2YXIgbmV3QXNzZXJ0aW9uID0gbmV3IEFzc2VydGlvbigpO1xuICogICAgIHV0aWxzLnRyYW5zZmVyRmxhZ3MoYXNzZXJ0aW9uLCBuZXdBc3NlcnRpb24pO1xuICpcbiAqICAgICB2YXIgYW5vdGhlckFzc2VyaXRvbiA9IG5ldyBBc3NlcnRpb24obXlPYmopO1xuICogICAgIHV0aWxzLnRyYW5zZmVyRmxhZ3MoYXNzZXJ0aW9uLCBhbm90aGVyQXNzZXJ0aW9uLCBmYWxzZSk7XG4gKlxuICogQHBhcmFtIHtBc3NlcnRpb259IGFzc2VydGlvbiB0aGUgYXNzZXJ0aW9uIHRvIHRyYW5zZmVyIHRoZSBmbGFncyBmcm9tXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IHRoZSBvYmplY3QgdG8gdHJhbnNmZXIgdGhlIGZsYWdzIHRvbzsgdXN1YWxseSBhIG5ldyBhc3NlcnRpb25cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaW5jbHVkZUFsbFxuICogQG5hbWUgZ2V0QWxsRmxhZ3NcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFzc2VydGlvbiwgb2JqZWN0LCBpbmNsdWRlQWxsKSB7XG4gIHZhciBmbGFncyA9IGFzc2VydGlvbi5fX2ZsYWdzIHx8IChhc3NlcnRpb24uX19mbGFncyA9IE9iamVjdC5jcmVhdGUobnVsbCkpO1xuXG4gIGlmICghb2JqZWN0Ll9fZmxhZ3MpIHtcbiAgICBvYmplY3QuX19mbGFncyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH1cblxuICBpbmNsdWRlQWxsID0gYXJndW1lbnRzLmxlbmd0aCA9PT0gMyA/IGluY2x1ZGVBbGwgOiB0cnVlO1xuXG4gIGZvciAodmFyIGZsYWcgaW4gZmxhZ3MpIHtcbiAgICBpZiAoaW5jbHVkZUFsbCB8fFxuICAgICAgICAoZmxhZyAhPT0gJ29iamVjdCcgJiYgZmxhZyAhPT0gJ3NzZmknICYmIGZsYWcgIT0gJ21lc3NhZ2UnKSkge1xuICAgICAgb2JqZWN0Ll9fZmxhZ3NbZmxhZ10gPSBmbGFnc1tmbGFnXTtcbiAgICB9XG4gIH1cbn07XG4iLCIvKiFcbiAqIENoYWkgLSB0eXBlIHV0aWxpdHlcbiAqIENvcHlyaWdodChjKSAyMDEyLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4vKiFcbiAqIERldGVjdGFibGUgamF2YXNjcmlwdCBuYXRpdmVzXG4gKi9cblxudmFyIG5hdGl2ZXMgPSB7XG4gICAgJ1tvYmplY3QgQXJndW1lbnRzXSc6ICdhcmd1bWVudHMnXG4gICwgJ1tvYmplY3QgQXJyYXldJzogJ2FycmF5J1xuICAsICdbb2JqZWN0IERhdGVdJzogJ2RhdGUnXG4gICwgJ1tvYmplY3QgRnVuY3Rpb25dJzogJ2Z1bmN0aW9uJ1xuICAsICdbb2JqZWN0IE51bWJlcl0nOiAnbnVtYmVyJ1xuICAsICdbb2JqZWN0IFJlZ0V4cF0nOiAncmVnZXhwJ1xuICAsICdbb2JqZWN0IFN0cmluZ10nOiAnc3RyaW5nJ1xufTtcblxuLyoqXG4gKiAjIyMgdHlwZShvYmplY3QpXG4gKlxuICogQmV0dGVyIGltcGxlbWVudGF0aW9uIG9mIGB0eXBlb2ZgIGRldGVjdGlvbiB0aGF0IGNhblxuICogYmUgdXNlZCBjcm9zcy1icm93c2VyLiBIYW5kbGVzIHRoZSBpbmNvbnNpc3RlbmNpZXMgb2ZcbiAqIEFycmF5LCBgbnVsbGAsIGFuZCBgdW5kZWZpbmVkYCBkZXRlY3Rpb24uXG4gKlxuICogICAgIHV0aWxzLnR5cGUoe30pIC8vICdvYmplY3QnXG4gKiAgICAgdXRpbHMudHlwZShudWxsKSAvLyBgbnVsbCdcbiAqICAgICB1dGlscy50eXBlKHVuZGVmaW5lZCkgLy8gYHVuZGVmaW5lZGBcbiAqICAgICB1dGlscy50eXBlKFtdKSAvLyBgYXJyYXlgXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gb2JqZWN0IHRvIGRldGVjdCB0eXBlIG9mXG4gKiBAbmFtZSB0eXBlXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIHN0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopO1xuICBpZiAobmF0aXZlc1tzdHJdKSByZXR1cm4gbmF0aXZlc1tzdHJdO1xuICBpZiAob2JqID09PSBudWxsKSByZXR1cm4gJ251bGwnO1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHJldHVybiAndW5kZWZpbmVkJztcbiAgaWYgKG9iaiA9PT0gT2JqZWN0KG9iaikpIHJldHVybiAnb2JqZWN0JztcbiAgcmV0dXJuIHR5cGVvZiBvYmo7XG59O1xuIiwiLyohXG4gKiBhc3NlcnRpb24tZXJyb3JcbiAqIENvcHlyaWdodChjKSAyMDEzIEpha2UgTHVlciA8amFrZUBxdWFsaWFuY3kuY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyohXG4gKiBSZXR1cm4gYSBmdW5jdGlvbiB0aGF0IHdpbGwgY29weSBwcm9wZXJ0aWVzIGZyb21cbiAqIG9uZSBvYmplY3QgdG8gYW5vdGhlciBleGNsdWRpbmcgYW55IG9yaWdpbmFsbHlcbiAqIGxpc3RlZC4gUmV0dXJuZWQgZnVuY3Rpb24gd2lsbCBjcmVhdGUgYSBuZXcgYHt9YC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXhjbHVkZWQgcHJvcGVydGllcyAuLi5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5cbmZ1bmN0aW9uIGV4Y2x1ZGUgKCkge1xuICB2YXIgZXhjbHVkZXMgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cbiAgZnVuY3Rpb24gZXhjbHVkZVByb3BzIChyZXMsIG9iaikge1xuICAgIE9iamVjdC5rZXlzKG9iaikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBpZiAoIX5leGNsdWRlcy5pbmRleE9mKGtleSkpIHJlc1trZXldID0gb2JqW2tleV07XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gZXh0ZW5kRXhjbHVkZSAoKSB7XG4gICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cylcbiAgICAgICwgaSA9IDBcbiAgICAgICwgcmVzID0ge307XG5cbiAgICBmb3IgKDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGV4Y2x1ZGVQcm9wcyhyZXMsIGFyZ3NbaV0pO1xuICAgIH1cblxuICAgIHJldHVybiByZXM7XG4gIH07XG59O1xuXG4vKiFcbiAqIFByaW1hcnkgRXhwb3J0c1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gQXNzZXJ0aW9uRXJyb3I7XG5cbi8qKlxuICogIyMjIEFzc2VydGlvbkVycm9yXG4gKlxuICogQW4gZXh0ZW5zaW9uIG9mIHRoZSBKYXZhU2NyaXB0IGBFcnJvcmAgY29uc3RydWN0b3IgZm9yXG4gKiBhc3NlcnRpb24gYW5kIHZhbGlkYXRpb24gc2NlbmFyaW9zLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcGVydGllcyB0byBpbmNsdWRlIChvcHRpb25hbClcbiAqIEBwYXJhbSB7Y2FsbGVlfSBzdGFydCBzdGFjayBmdW5jdGlvbiAob3B0aW9uYWwpXG4gKi9cblxuZnVuY3Rpb24gQXNzZXJ0aW9uRXJyb3IgKG1lc3NhZ2UsIF9wcm9wcywgc3NmKSB7XG4gIHZhciBleHRlbmQgPSBleGNsdWRlKCduYW1lJywgJ21lc3NhZ2UnLCAnc3RhY2snLCAnY29uc3RydWN0b3InLCAndG9KU09OJylcbiAgICAsIHByb3BzID0gZXh0ZW5kKF9wcm9wcyB8fCB7fSk7XG5cbiAgLy8gZGVmYXVsdCB2YWx1ZXNcbiAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSB8fCAnVW5zcGVjaWZpZWQgQXNzZXJ0aW9uRXJyb3InO1xuICB0aGlzLnNob3dEaWZmID0gZmFsc2U7XG5cbiAgLy8gY29weSBmcm9tIHByb3BlcnRpZXNcbiAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XG4gICAgdGhpc1trZXldID0gcHJvcHNba2V5XTtcbiAgfVxuXG4gIC8vIGNhcHR1cmUgc3RhY2sgdHJhY2VcbiAgc3NmID0gc3NmIHx8IGFyZ3VtZW50cy5jYWxsZWU7XG4gIGlmIChzc2YgJiYgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBzc2YpO1xuICB9XG59XG5cbi8qIVxuICogSW5oZXJpdCBmcm9tIEVycm9yLnByb3RvdHlwZVxuICovXG5cbkFzc2VydGlvbkVycm9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKTtcblxuLyohXG4gKiBTdGF0aWNhbGx5IHNldCBuYW1lXG4gKi9cblxuQXNzZXJ0aW9uRXJyb3IucHJvdG90eXBlLm5hbWUgPSAnQXNzZXJ0aW9uRXJyb3InO1xuXG4vKiFcbiAqIEVuc3VyZSBjb3JyZWN0IGNvbnN0cnVjdG9yXG4gKi9cblxuQXNzZXJ0aW9uRXJyb3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQXNzZXJ0aW9uRXJyb3I7XG5cbi8qKlxuICogQWxsb3cgZXJyb3JzIHRvIGJlIGNvbnZlcnRlZCB0byBKU09OIGZvciBzdGF0aWMgdHJhbnNmZXIuXG4gKlxuICogQHBhcmFtIHtCb29sZWFufSBpbmNsdWRlIHN0YWNrIChkZWZhdWx0OiBgdHJ1ZWApXG4gKiBAcmV0dXJuIHtPYmplY3R9IG9iamVjdCB0aGF0IGNhbiBiZSBgSlNPTi5zdHJpbmdpZnlgXG4gKi9cblxuQXNzZXJ0aW9uRXJyb3IucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIChzdGFjaykge1xuICB2YXIgZXh0ZW5kID0gZXhjbHVkZSgnY29uc3RydWN0b3InLCAndG9KU09OJywgJ3N0YWNrJylcbiAgICAsIHByb3BzID0gZXh0ZW5kKHsgbmFtZTogdGhpcy5uYW1lIH0sIHRoaXMpO1xuXG4gIC8vIGluY2x1ZGUgc3RhY2sgaWYgZXhpc3RzIGFuZCBub3QgdHVybmVkIG9mZlxuICBpZiAoZmFsc2UgIT09IHN0YWNrICYmIHRoaXMuc3RhY2spIHtcbiAgICBwcm9wcy5zdGFjayA9IHRoaXMuc3RhY2s7XG4gIH1cblxuICByZXR1cm4gcHJvcHM7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9lcWwnKTtcbiIsIi8qIVxuICogZGVlcC1lcWxcbiAqIENvcHlyaWdodChjKSAyMDEzIEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyohXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzXG4gKi9cblxudmFyIHR5cGUgPSByZXF1aXJlKCd0eXBlLWRldGVjdCcpO1xuXG4vKiFcbiAqIEJ1ZmZlci5pc0J1ZmZlciBicm93c2VyIHNoaW1cbiAqL1xuXG52YXIgQnVmZmVyO1xudHJ5IHsgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyOyB9XG5jYXRjaChleCkge1xuICBCdWZmZXIgPSB7fTtcbiAgQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24oKSB7IHJldHVybiBmYWxzZTsgfVxufVxuXG4vKiFcbiAqIFByaW1hcnkgRXhwb3J0XG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBkZWVwRXF1YWw7XG5cbi8qKlxuICogQXNzZXJ0IHN1cGVyLXN0cmljdCAoZWdhbCkgZXF1YWxpdHkgYmV0d2VlblxuICogdHdvIG9iamVjdHMgb2YgYW55IHR5cGUuXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gYVxuICogQHBhcmFtIHtNaXhlZH0gYlxuICogQHBhcmFtIHtBcnJheX0gbWVtb2lzZWQgKG9wdGlvbmFsKVxuICogQHJldHVybiB7Qm9vbGVhbn0gZXF1YWwgbWF0Y2hcbiAqL1xuXG5mdW5jdGlvbiBkZWVwRXF1YWwoYSwgYiwgbSkge1xuICBpZiAoc2FtZVZhbHVlKGEsIGIpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSBpZiAoJ2RhdGUnID09PSB0eXBlKGEpKSB7XG4gICAgcmV0dXJuIGRhdGVFcXVhbChhLCBiKTtcbiAgfSBlbHNlIGlmICgncmVnZXhwJyA9PT0gdHlwZShhKSkge1xuICAgIHJldHVybiByZWdleHBFcXVhbChhLCBiKTtcbiAgfSBlbHNlIGlmIChCdWZmZXIuaXNCdWZmZXIoYSkpIHtcbiAgICByZXR1cm4gYnVmZmVyRXF1YWwoYSwgYik7XG4gIH0gZWxzZSBpZiAoJ2FyZ3VtZW50cycgPT09IHR5cGUoYSkpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzRXF1YWwoYSwgYiwgbSk7XG4gIH0gZWxzZSBpZiAoIXR5cGVFcXVhbChhLCBiKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIGlmICgoJ29iamVjdCcgIT09IHR5cGUoYSkgJiYgJ29iamVjdCcgIT09IHR5cGUoYikpXG4gICYmICgnYXJyYXknICE9PSB0eXBlKGEpICYmICdhcnJheScgIT09IHR5cGUoYikpKSB7XG4gICAgcmV0dXJuIHNhbWVWYWx1ZShhLCBiKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gb2JqZWN0RXF1YWwoYSwgYiwgbSk7XG4gIH1cbn1cblxuLyohXG4gKiBTdHJpY3QgKGVnYWwpIGVxdWFsaXR5IHRlc3QuIEVuc3VyZXMgdGhhdCBOYU4gYWx3YXlzXG4gKiBlcXVhbHMgTmFOIGFuZCBgLTBgIGRvZXMgbm90IGVxdWFsIGArMGAuXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gYVxuICogQHBhcmFtIHtNaXhlZH0gYlxuICogQHJldHVybiB7Qm9vbGVhbn0gZXF1YWwgbWF0Y2hcbiAqL1xuXG5mdW5jdGlvbiBzYW1lVmFsdWUoYSwgYikge1xuICBpZiAoYSA9PT0gYikgcmV0dXJuIGEgIT09IDAgfHwgMSAvIGEgPT09IDEgLyBiO1xuICByZXR1cm4gYSAhPT0gYSAmJiBiICE9PSBiO1xufVxuXG4vKiFcbiAqIENvbXBhcmUgdGhlIHR5cGVzIG9mIHR3byBnaXZlbiBvYmplY3RzIGFuZFxuICogcmV0dXJuIGlmIHRoZXkgYXJlIGVxdWFsLiBOb3RlIHRoYXQgYW4gQXJyYXlcbiAqIGhhcyBhIHR5cGUgb2YgYGFycmF5YCAobm90IGBvYmplY3RgKSBhbmQgYXJndW1lbnRzXG4gKiBoYXZlIGEgdHlwZSBvZiBgYXJndW1lbnRzYCAobm90IGBhcnJheWAvYG9iamVjdGApLlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IGFcbiAqIEBwYXJhbSB7TWl4ZWR9IGJcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHJlc3VsdFxuICovXG5cbmZ1bmN0aW9uIHR5cGVFcXVhbChhLCBiKSB7XG4gIHJldHVybiB0eXBlKGEpID09PSB0eXBlKGIpO1xufVxuXG4vKiFcbiAqIENvbXBhcmUgdHdvIERhdGUgb2JqZWN0cyBieSBhc3NlcnRpbmcgdGhhdFxuICogdGhlIHRpbWUgdmFsdWVzIGFyZSBlcXVhbCB1c2luZyBgc2F2ZVZhbHVlYC5cbiAqXG4gKiBAcGFyYW0ge0RhdGV9IGFcbiAqIEBwYXJhbSB7RGF0ZX0gYlxuICogQHJldHVybiB7Qm9vbGVhbn0gcmVzdWx0XG4gKi9cblxuZnVuY3Rpb24gZGF0ZUVxdWFsKGEsIGIpIHtcbiAgaWYgKCdkYXRlJyAhPT0gdHlwZShiKSkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gc2FtZVZhbHVlKGEuZ2V0VGltZSgpLCBiLmdldFRpbWUoKSk7XG59XG5cbi8qIVxuICogQ29tcGFyZSB0d28gcmVndWxhciBleHByZXNzaW9ucyBieSBjb252ZXJ0aW5nIHRoZW1cbiAqIHRvIHN0cmluZyBhbmQgY2hlY2tpbmcgZm9yIGBzYW1lVmFsdWVgLlxuICpcbiAqIEBwYXJhbSB7UmVnRXhwfSBhXG4gKiBAcGFyYW0ge1JlZ0V4cH0gYlxuICogQHJldHVybiB7Qm9vbGVhbn0gcmVzdWx0XG4gKi9cblxuZnVuY3Rpb24gcmVnZXhwRXF1YWwoYSwgYikge1xuICBpZiAoJ3JlZ2V4cCcgIT09IHR5cGUoYikpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIHNhbWVWYWx1ZShhLnRvU3RyaW5nKCksIGIudG9TdHJpbmcoKSk7XG59XG5cbi8qIVxuICogQXNzZXJ0IGRlZXAgZXF1YWxpdHkgb2YgdHdvIGBhcmd1bWVudHNgIG9iamVjdHMuXG4gKiBVbmZvcnR1bmF0ZWx5LCB0aGVzZSBtdXN0IGJlIHNsaWNlZCB0byBhcnJheXNcbiAqIHByaW9yIHRvIHRlc3QgdG8gZW5zdXJlIG5vIGJhZCBiZWhhdmlvci5cbiAqXG4gKiBAcGFyYW0ge0FyZ3VtZW50c30gYVxuICogQHBhcmFtIHtBcmd1bWVudHN9IGJcbiAqIEBwYXJhbSB7QXJyYXl9IG1lbW9pemUgKG9wdGlvbmFsKVxuICogQHJldHVybiB7Qm9vbGVhbn0gcmVzdWx0XG4gKi9cblxuZnVuY3Rpb24gYXJndW1lbnRzRXF1YWwoYSwgYiwgbSkge1xuICBpZiAoJ2FyZ3VtZW50cycgIT09IHR5cGUoYikpIHJldHVybiBmYWxzZTtcbiAgYSA9IFtdLnNsaWNlLmNhbGwoYSk7XG4gIGIgPSBbXS5zbGljZS5jYWxsKGIpO1xuICByZXR1cm4gZGVlcEVxdWFsKGEsIGIsIG0pO1xufVxuXG4vKiFcbiAqIEdldCBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2YgYSBnaXZlbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGFcbiAqIEByZXR1cm4ge0FycmF5fSBwcm9wZXJ0eSBuYW1lc1xuICovXG5cbmZ1bmN0aW9uIGVudW1lcmFibGUoYSkge1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBhKSByZXMucHVzaChrZXkpO1xuICByZXR1cm4gcmVzO1xufVxuXG4vKiFcbiAqIFNpbXBsZSBlcXVhbGl0eSBmb3IgZmxhdCBpdGVyYWJsZSBvYmplY3RzXG4gKiBzdWNoIGFzIEFycmF5cyBvciBOb2RlLmpzIGJ1ZmZlcnMuXG4gKlxuICogQHBhcmFtIHtJdGVyYWJsZX0gYVxuICogQHBhcmFtIHtJdGVyYWJsZX0gYlxuICogQHJldHVybiB7Qm9vbGVhbn0gcmVzdWx0XG4gKi9cblxuZnVuY3Rpb24gaXRlcmFibGVFcXVhbChhLCBiKSB7XG4gIGlmIChhLmxlbmd0aCAhPT0gIGIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG5cbiAgdmFyIGkgPSAwO1xuICB2YXIgbWF0Y2ggPSB0cnVlO1xuXG4gIGZvciAoOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICBtYXRjaCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1hdGNoO1xufVxuXG4vKiFcbiAqIEV4dGVuc2lvbiB0byBgaXRlcmFibGVFcXVhbGAgc3BlY2lmaWNhbGx5XG4gKiBmb3IgTm9kZS5qcyBCdWZmZXJzLlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBhXG4gKiBAcGFyYW0ge01peGVkfSBiXG4gKiBAcmV0dXJuIHtCb29sZWFufSByZXN1bHRcbiAqL1xuXG5mdW5jdGlvbiBidWZmZXJFcXVhbChhLCBiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBpdGVyYWJsZUVxdWFsKGEsIGIpO1xufVxuXG4vKiFcbiAqIEJsb2NrIGZvciBgb2JqZWN0RXF1YWxgIGVuc3VyaW5nIG5vbi1leGlzdGluZ1xuICogdmFsdWVzIGRvbid0IGdldCBpbi5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSBvYmplY3RcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHJlc3VsdFxuICovXG5cbmZ1bmN0aW9uIGlzVmFsdWUoYSkge1xuICByZXR1cm4gYSAhPT0gbnVsbCAmJiBhICE9PSB1bmRlZmluZWQ7XG59XG5cbi8qIVxuICogUmVjdXJzaXZlbHkgY2hlY2sgdGhlIGVxdWFsaXR5IG9mIHR3byBvYmplY3RzLlxuICogT25jZSBiYXNpYyBzYW1lbmVzcyBoYXMgYmVlbiBlc3RhYmxpc2hlZCBpdCB3aWxsXG4gKiBkZWZlciB0byBgZGVlcEVxdWFsYCBmb3IgZWFjaCBlbnVtZXJhYmxlIGtleVxuICogaW4gdGhlIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSBhXG4gKiBAcGFyYW0ge01peGVkfSBiXG4gKiBAcmV0dXJuIHtCb29sZWFufSByZXN1bHRcbiAqL1xuXG5mdW5jdGlvbiBvYmplY3RFcXVhbChhLCBiLCBtKSB7XG4gIGlmICghaXNWYWx1ZShhKSB8fCAhaXNWYWx1ZShiKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChhLnByb3RvdHlwZSAhPT0gYi5wcm90b3R5cGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgaTtcbiAgaWYgKG0pIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKChtW2ldWzBdID09PSBhICYmIG1baV1bMV0gPT09IGIpXG4gICAgICB8fCAgKG1baV1bMF0gPT09IGIgJiYgbVtpXVsxXSA9PT0gYSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG0gPSBbXTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgdmFyIGthID0gZW51bWVyYWJsZShhKTtcbiAgICB2YXIga2IgPSBlbnVtZXJhYmxlKGIpO1xuICB9IGNhdGNoIChleCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGthLnNvcnQoKTtcbiAga2Iuc29ydCgpO1xuXG4gIGlmICghaXRlcmFibGVFcXVhbChrYSwga2IpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgbS5wdXNoKFsgYSwgYiBdKTtcblxuICB2YXIga2V5O1xuICBmb3IgKGkgPSBrYS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGtleSA9IGthW2ldO1xuICAgIGlmICghZGVlcEVxdWFsKGFba2V5XSwgYltrZXldLCBtKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi90eXBlJyk7XG4iLCIvKiFcbiAqIHR5cGUtZGV0ZWN0XG4gKiBDb3B5cmlnaHQoYykgMjAxMyBqYWtlIGx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qIVxuICogUHJpbWFyeSBFeHBvcnRzXG4gKi9cblxudmFyIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGdldFR5cGU7XG5cbi8qIVxuICogRGV0ZWN0YWJsZSBqYXZhc2NyaXB0IG5hdGl2ZXNcbiAqL1xuXG52YXIgbmF0aXZlcyA9IHtcbiAgICAnW29iamVjdCBBcnJheV0nOiAnYXJyYXknXG4gICwgJ1tvYmplY3QgUmVnRXhwXSc6ICdyZWdleHAnXG4gICwgJ1tvYmplY3QgRnVuY3Rpb25dJzogJ2Z1bmN0aW9uJ1xuICAsICdbb2JqZWN0IEFyZ3VtZW50c10nOiAnYXJndW1lbnRzJ1xuICAsICdbb2JqZWN0IERhdGVdJzogJ2RhdGUnXG59O1xuXG4vKipcbiAqICMjIyB0eXBlT2YgKG9iailcbiAqXG4gKiBVc2Ugc2V2ZXJhbCBkaWZmZXJlbnQgdGVjaG5pcXVlcyB0byBkZXRlcm1pbmVcbiAqIHRoZSB0eXBlIG9mIG9iamVjdCBiZWluZyB0ZXN0ZWQuXG4gKlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IG9iamVjdFxuICogQHJldHVybiB7U3RyaW5nfSBvYmplY3QgdHlwZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBnZXRUeXBlIChvYmopIHtcbiAgdmFyIHN0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopO1xuICBpZiAobmF0aXZlc1tzdHJdKSByZXR1cm4gbmF0aXZlc1tzdHJdO1xuICBpZiAob2JqID09PSBudWxsKSByZXR1cm4gJ251bGwnO1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHJldHVybiAndW5kZWZpbmVkJztcbiAgaWYgKG9iaiA9PT0gT2JqZWN0KG9iaikpIHJldHVybiAnb2JqZWN0JztcbiAgcmV0dXJuIHR5cGVvZiBvYmo7XG59XG5cbmV4cG9ydHMuTGlicmFyeSA9IExpYnJhcnk7XG5cbi8qKlxuICogIyMjIExpYnJhcnlcbiAqXG4gKiBDcmVhdGUgYSByZXBvc2l0b3J5IGZvciBjdXN0b20gdHlwZSBkZXRlY3Rpb24uXG4gKlxuICogYGBganNcbiAqIHZhciBsaWIgPSBuZXcgdHlwZS5MaWJyYXJ5O1xuICogYGBgXG4gKlxuICovXG5cbmZ1bmN0aW9uIExpYnJhcnkgKCkge1xuICB0aGlzLnRlc3RzID0ge307XG59XG5cbi8qKlxuICogIyMjIyAub2YgKG9iailcbiAqXG4gKiBFeHBvc2UgcmVwbGFjZW1lbnQgYHR5cGVvZmAgZGV0ZWN0aW9uIHRvIHRoZSBsaWJyYXJ5LlxuICpcbiAqIGBgYGpzXG4gKiBpZiAoJ3N0cmluZycgPT09IGxpYi5vZignaGVsbG8gd29ybGQnKSkge1xuICogICAvLyAuLi5cbiAqIH1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IG9iamVjdCB0byB0ZXN0XG4gKiBAcmV0dXJuIHtTdHJpbmd9IHR5cGVcbiAqL1xuXG5MaWJyYXJ5LnByb3RvdHlwZS5vZiA9IGdldFR5cGU7XG5cbi8qKlxuICogIyMjIyAuZGVmaW5lICh0eXBlLCB0ZXN0KVxuICpcbiAqIEFkZCBhIHRlc3QgdG8gZm9yIHRoZSBgLnRlc3QoKWAgYXNzZXJ0aW9uLlxuICpcbiAqIENhbiBiZSBkZWZpbmVkIGFzIGEgcmVndWxhciBleHByZXNzaW9uOlxuICpcbiAqIGBgYGpzXG4gKiBsaWIuZGVmaW5lKCdpbnQnLCAvXlswLTldKyQvKTtcbiAqIGBgYFxuICpcbiAqIC4uLiBvciBhcyBhIGZ1bmN0aW9uOlxuICpcbiAqIGBgYGpzXG4gKiBsaWIuZGVmaW5lKCdibG4nLCBmdW5jdGlvbiAob2JqKSB7XG4gKiAgIGlmICgnYm9vbGVhbicgPT09IGxpYi5vZihvYmopKSByZXR1cm4gdHJ1ZTtcbiAqICAgdmFyIGJsbnMgPSBbICd5ZXMnLCAnbm8nLCAndHJ1ZScsICdmYWxzZScsIDEsIDAgXTtcbiAqICAgaWYgKCdzdHJpbmcnID09PSBsaWIub2Yob2JqKSkgb2JqID0gb2JqLnRvTG93ZXJDYXNlKCk7XG4gKiAgIHJldHVybiAhISB+Ymxucy5pbmRleE9mKG9iaik7XG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKiBAcGFyYW0ge1JlZ0V4cHxGdW5jdGlvbn0gdGVzdFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5MaWJyYXJ5LnByb3RvdHlwZS5kZWZpbmUgPSBmdW5jdGlvbiAodHlwZSwgdGVzdCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkgcmV0dXJuIHRoaXMudGVzdHNbdHlwZV07XG4gIHRoaXMudGVzdHNbdHlwZV0gPSB0ZXN0O1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogIyMjIyAudGVzdCAob2JqLCB0ZXN0KVxuICpcbiAqIEFzc2VydCB0aGF0IGFuIG9iamVjdCBpcyBvZiB0eXBlLiBXaWxsIGZpcnN0XG4gKiBjaGVjayBuYXRpdmVzLCBhbmQgaWYgdGhhdCBkb2VzIG5vdCBwYXNzIGl0IHdpbGxcbiAqIHVzZSB0aGUgdXNlciBkZWZpbmVkIGN1c3RvbSB0ZXN0cy5cbiAqXG4gKiBgYGBqc1xuICogYXNzZXJ0KGxpYi50ZXN0KCcxJywgJ2ludCcpKTtcbiAqIGFzc2VydChsaWIudGVzdCgneWVzJywgJ2JsbicpKTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IG9iamVjdFxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHJlc3VsdFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5MaWJyYXJ5LnByb3RvdHlwZS50ZXN0ID0gZnVuY3Rpb24gKG9iaiwgdHlwZSkge1xuICBpZiAodHlwZSA9PT0gZ2V0VHlwZShvYmopKSByZXR1cm4gdHJ1ZTtcbiAgdmFyIHRlc3QgPSB0aGlzLnRlc3RzW3R5cGVdO1xuXG4gIGlmICh0ZXN0ICYmICdyZWdleHAnID09PSBnZXRUeXBlKHRlc3QpKSB7XG4gICAgcmV0dXJuIHRlc3QudGVzdChvYmopO1xuICB9IGVsc2UgaWYgKHRlc3QgJiYgJ2Z1bmN0aW9uJyA9PT0gZ2V0VHlwZSh0ZXN0KSkge1xuICAgIHJldHVybiB0ZXN0KG9iaik7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKCdUeXBlIHRlc3QgXCInICsgdHlwZSArICdcIiBub3QgZGVmaW5lZCBvciBpbnZhbGlkLicpO1xuICB9XG59O1xuIixudWxsLCIvKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxmZXJvc3NAZmVyb3NzLm9yZz4gPGh0dHA6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG5cbnZhciBiYXNlNjQgPSByZXF1aXJlKCdiYXNlNjQtanMnKVxudmFyIGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0JylcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyXG5cbi8qKlxuICogSWYgYFRZUEVEX0FSUkFZX1NVUFBPUlRgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgVXNlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiAobW9zdCBjb21wYXRpYmxlLCBldmVuIElFNilcbiAqXG4gKiBCcm93c2VycyB0aGF0IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssIENocm9tZSA3KywgU2FmYXJpIDUuMSssXG4gKiBPcGVyYSAxMS42KywgaU9TIDQuMisuXG4gKlxuICogTm90ZTpcbiAqXG4gKiAtIEltcGxlbWVudGF0aW9uIG11c3Qgc3VwcG9ydCBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgIGluc3RhbmNlcy5cbiAqICAgRmlyZWZveCA0LTI5IGxhY2tlZCBzdXBwb3J0LCBmaXhlZCBpbiBGaXJlZm94IDMwKy5cbiAqICAgU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzguXG4gKlxuICogIC0gQ2hyb21lIDktMTAgaXMgbWlzc2luZyB0aGUgYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbi5cbiAqXG4gKiAgLSBJRTEwIGhhcyBhIGJyb2tlbiBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYXJyYXlzIG9mXG4gKiAgICBpbmNvcnJlY3QgbGVuZ3RoIGluIHNvbWUgc2l0dWF0aW9ucy5cbiAqXG4gKiBXZSBkZXRlY3QgdGhlc2UgYnVnZ3kgYnJvd3NlcnMgYW5kIHNldCBgVFlQRURfQVJSQVlfU1VQUE9SVGAgdG8gYGZhbHNlYCBzbyB0aGV5IHdpbGxcbiAqIGdldCB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uLCB3aGljaCBpcyBzbG93ZXIgYnV0IHdpbGwgd29yayBjb3JyZWN0bHkuXG4gKi9cbnZhciBUWVBFRF9BUlJBWV9TVVBQT1JUID0gKGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICB2YXIgYnVmID0gbmV3IEFycmF5QnVmZmVyKDApXG4gICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KGJ1ZilcbiAgICBhcnIuZm9vID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfVxuICAgIHJldHVybiA0MiA9PT0gYXJyLmZvbygpICYmIC8vIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkXG4gICAgICAgIHR5cGVvZiBhcnIuc3ViYXJyYXkgPT09ICdmdW5jdGlvbicgJiYgLy8gY2hyb21lIDktMTAgbGFjayBgc3ViYXJyYXlgXG4gICAgICAgIG5ldyBVaW50OEFycmF5KDEpLnN1YmFycmF5KDEsIDEpLmJ5dGVMZW5ndGggPT09IDAgLy8gaWUxMCBoYXMgYnJva2VuIGBzdWJhcnJheWBcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59KSgpXG5cbi8qKlxuICogQ2xhc3M6IEJ1ZmZlclxuICogPT09PT09PT09PT09PVxuICpcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgYXJlIGF1Z21lbnRlZFxuICogd2l0aCBmdW5jdGlvbiBwcm9wZXJ0aWVzIGZvciBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgQVBJIGZ1bmN0aW9ucy4gV2UgdXNlXG4gKiBgVWludDhBcnJheWAgc28gdGhhdCBzcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdCByZXR1cm5zXG4gKiBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBCeSBhdWdtZW50aW5nIHRoZSBpbnN0YW5jZXMsIHdlIGNhbiBhdm9pZCBtb2RpZnlpbmcgdGhlIGBVaW50OEFycmF5YFxuICogcHJvdG90eXBlLlxuICovXG5mdW5jdGlvbiBCdWZmZXIgKHN1YmplY3QsIGVuY29kaW5nLCBub1plcm8pIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEJ1ZmZlcikpXG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoc3ViamVjdCwgZW5jb2RpbmcsIG5vWmVybylcblxuICB2YXIgdHlwZSA9IHR5cGVvZiBzdWJqZWN0XG5cbiAgLy8gRmluZCB0aGUgbGVuZ3RoXG4gIHZhciBsZW5ndGhcbiAgaWYgKHR5cGUgPT09ICdudW1iZXInKVxuICAgIGxlbmd0aCA9IHN1YmplY3QgPiAwID8gc3ViamVjdCA+Pj4gMCA6IDBcbiAgZWxzZSBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAoZW5jb2RpbmcgPT09ICdiYXNlNjQnKVxuICAgICAgc3ViamVjdCA9IGJhc2U2NGNsZWFuKHN1YmplY3QpXG4gICAgbGVuZ3RoID0gQnVmZmVyLmJ5dGVMZW5ndGgoc3ViamVjdCwgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ29iamVjdCcgJiYgc3ViamVjdCAhPT0gbnVsbCkgeyAvLyBhc3N1bWUgb2JqZWN0IGlzIGFycmF5LWxpa2VcbiAgICBpZiAoc3ViamVjdC50eXBlID09PSAnQnVmZmVyJyAmJiBpc0FycmF5KHN1YmplY3QuZGF0YSkpXG4gICAgICBzdWJqZWN0ID0gc3ViamVjdC5kYXRhXG4gICAgbGVuZ3RoID0gK3N1YmplY3QubGVuZ3RoID4gMCA/IE1hdGguZmxvb3IoK3N1YmplY3QubGVuZ3RoKSA6IDBcbiAgfSBlbHNlXG4gICAgdGhyb3cgbmV3IEVycm9yKCdGaXJzdCBhcmd1bWVudCBuZWVkcyB0byBiZSBhIG51bWJlciwgYXJyYXkgb3Igc3RyaW5nLicpXG5cbiAgdmFyIGJ1ZlxuICBpZiAoVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFByZWZlcnJlZDogUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICBidWYgPSBCdWZmZXIuX2F1Z21lbnQobmV3IFVpbnQ4QXJyYXkobGVuZ3RoKSlcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIFRISVMgaW5zdGFuY2Ugb2YgQnVmZmVyIChjcmVhdGVkIGJ5IGBuZXdgKVxuICAgIGJ1ZiA9IHRoaXNcbiAgICBidWYubGVuZ3RoID0gbGVuZ3RoXG4gICAgYnVmLl9pc0J1ZmZlciA9IHRydWVcbiAgfVxuXG4gIHZhciBpXG4gIGlmIChUWVBFRF9BUlJBWV9TVVBQT1JUICYmIHR5cGVvZiBzdWJqZWN0LmJ5dGVMZW5ndGggPT09ICdudW1iZXInKSB7XG4gICAgLy8gU3BlZWQgb3B0aW1pemF0aW9uIC0tIHVzZSBzZXQgaWYgd2UncmUgY29weWluZyBmcm9tIGEgdHlwZWQgYXJyYXlcbiAgICBidWYuX3NldChzdWJqZWN0KVxuICB9IGVsc2UgaWYgKGlzQXJyYXlpc2goc3ViamVjdCkpIHtcbiAgICAvLyBUcmVhdCBhcnJheS1pc2ggb2JqZWN0cyBhcyBhIGJ5dGUgYXJyYXlcbiAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKHN1YmplY3QpKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspXG4gICAgICAgIGJ1ZltpXSA9IHN1YmplY3QucmVhZFVJbnQ4KGkpXG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKylcbiAgICAgICAgYnVmW2ldID0gKChzdWJqZWN0W2ldICUgMjU2KSArIDI1NikgJSAyNTZcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICBidWYud3JpdGUoc3ViamVjdCwgMCwgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicgJiYgIVRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgIW5vWmVybykge1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgYnVmW2ldID0gMFxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBidWZcbn1cblxuLy8gU1RBVElDIE1FVEhPRFNcbi8vID09PT09PT09PT09PT09XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICdyYXcnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiAoYikge1xuICByZXR1cm4gISEoYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyKVxufVxuXG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGZ1bmN0aW9uIChzdHIsIGVuY29kaW5nKSB7XG4gIHZhciByZXRcbiAgc3RyID0gc3RyLnRvU3RyaW5nKClcbiAgc3dpdGNoIChlbmNvZGluZyB8fCAndXRmOCcpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgICAgcmV0ID0gc3RyLmxlbmd0aCAvIDJcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgICAgcmV0ID0gdXRmOFRvQnl0ZXMoc3RyKS5sZW5ndGhcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAncmF3JzpcbiAgICAgIHJldCA9IHN0ci5sZW5ndGhcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIHJldCA9IGJhc2U2NFRvQnl0ZXMoc3RyKS5sZW5ndGhcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldCA9IHN0ci5sZW5ndGggKiAyXG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2RpbmcnKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIChsaXN0LCB0b3RhbExlbmd0aCkge1xuICBhc3NlcnQoaXNBcnJheShsaXN0KSwgJ1VzYWdlOiBCdWZmZXIuY29uY2F0KGxpc3RbLCBsZW5ndGhdKScpXG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoMClcbiAgfSBlbHNlIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBsaXN0WzBdXG4gIH1cblxuICB2YXIgaVxuICBpZiAodG90YWxMZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIHRvdGFsTGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB0b3RhbExlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIHZhciBidWYgPSBuZXcgQnVmZmVyKHRvdGFsTGVuZ3RoKVxuICB2YXIgcG9zID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpdGVtID0gbGlzdFtpXVxuICAgIGl0ZW0uY29weShidWYsIHBvcylcbiAgICBwb3MgKz0gaXRlbS5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgYXNzZXJ0KEJ1ZmZlci5pc0J1ZmZlcihhKSAmJiBCdWZmZXIuaXNCdWZmZXIoYiksICdBcmd1bWVudHMgbXVzdCBiZSBCdWZmZXJzJylcbiAgdmFyIHggPSBhLmxlbmd0aFxuICB2YXIgeSA9IGIubGVuZ3RoXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbiAmJiBhW2ldID09PSBiW2ldOyBpKyspIHt9XG4gIGlmIChpICE9PSBsZW4pIHtcbiAgICB4ID0gYVtpXVxuICAgIHkgPSBiW2ldXG4gIH1cbiAgaWYgKHggPCB5KSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKHkgPCB4KSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuICByZXR1cm4gMFxufVxuXG4vLyBCVUZGRVIgSU5TVEFOQ0UgTUVUSE9EU1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICAvLyBtdXN0IGJlIGFuIGV2ZW4gbnVtYmVyIG9mIGRpZ2l0c1xuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuICBhc3NlcnQoc3RyTGVuICUgMiA9PT0gMCwgJ0ludmFsaWQgaGV4IHN0cmluZycpXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIHZhciBieXRlID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGFzc2VydCghaXNOYU4oYnl0ZSksICdJbnZhbGlkIGhleCBzdHJpbmcnKVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IGJ5dGVcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgY2hhcnNXcml0dGVuID0gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxuICByZXR1cm4gY2hhcnNXcml0dGVuXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgY2hhcnNXcml0dGVuID0gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbiAgcmV0dXJuIGNoYXJzV3JpdHRlblxufVxuXG5mdW5jdGlvbiBiaW5hcnlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgY2hhcnNXcml0dGVuID0gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG4gIHJldHVybiBjaGFyc1dyaXR0ZW5cbn1cblxuZnVuY3Rpb24gdXRmMTZsZVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIGNoYXJzV3JpdHRlbiA9IGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbiAgcmV0dXJuIGNoYXJzV3JpdHRlblxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIFN1cHBvcnQgYm90aCAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpXG4gIC8vIGFuZCB0aGUgbGVnYWN5IChzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBpZiAoIWlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIH0gZWxzZSB7ICAvLyBsZWdhY3lcbiAgICB2YXIgc3dhcCA9IGVuY29kaW5nXG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBvZmZzZXQgPSBsZW5ndGhcbiAgICBsZW5ndGggPSBzd2FwXG4gIH1cblxuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG4gIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nIHx8ICd1dGY4JykudG9Mb3dlckNhc2UoKVxuXG4gIHZhciByZXRcbiAgc3dpdGNoIChlbmNvZGluZykge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgICByZXQgPSBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgICByZXQgPSB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYXNjaWknOlxuICAgICAgcmV0ID0gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdiaW5hcnknOlxuICAgICAgcmV0ID0gYmluYXJ5V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIHJldCA9IGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXQgPSB1dGYxNmxlV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZycpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuXG4gIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nIHx8ICd1dGY4JykudG9Mb3dlckNhc2UoKVxuICBzdGFydCA9IE51bWJlcihzdGFydCkgfHwgMFxuICBlbmQgPSAoZW5kID09PSB1bmRlZmluZWQpID8gc2VsZi5sZW5ndGggOiBOdW1iZXIoZW5kKVxuXG4gIC8vIEZhc3RwYXRoIGVtcHR5IHN0cmluZ3NcbiAgaWYgKGVuZCA9PT0gc3RhcnQpXG4gICAgcmV0dXJuICcnXG5cbiAgdmFyIHJldFxuICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICAgIHJldCA9IGhleFNsaWNlKHNlbGYsIHN0YXJ0LCBlbmQpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIHJldCA9IHV0ZjhTbGljZShzZWxmLCBzdGFydCwgZW5kKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgICByZXQgPSBhc2NpaVNsaWNlKHNlbGYsIHN0YXJ0LCBlbmQpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICByZXQgPSBiaW5hcnlTbGljZShzZWxmLCBzdGFydCwgZW5kKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgcmV0ID0gYmFzZTY0U2xpY2Uoc2VsZiwgc3RhcnQsIGVuZClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldCA9IHV0ZjE2bGVTbGljZShzZWxmLCBzdGFydCwgZW5kKVxuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nJylcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKGIpIHtcbiAgYXNzZXJ0KEJ1ZmZlci5pc0J1ZmZlcihiKSwgJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYikgPT09IDBcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gKGIpIHtcbiAgYXNzZXJ0KEJ1ZmZlci5pc0J1ZmZlcihiKSwgJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYilcbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKHRhcmdldCwgdGFyZ2V0X3N0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIHZhciBzb3VyY2UgPSB0aGlzXG5cbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKCF0YXJnZXRfc3RhcnQpIHRhcmdldF9zdGFydCA9IDBcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVyblxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCBzb3VyY2UubGVuZ3RoID09PSAwKSByZXR1cm5cblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGFzc2VydChlbmQgPj0gc3RhcnQsICdzb3VyY2VFbmQgPCBzb3VyY2VTdGFydCcpXG4gIGFzc2VydCh0YXJnZXRfc3RhcnQgPj0gMCAmJiB0YXJnZXRfc3RhcnQgPCB0YXJnZXQubGVuZ3RoLFxuICAgICAgJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBhc3NlcnQoc3RhcnQgPj0gMCAmJiBzdGFydCA8IHNvdXJjZS5sZW5ndGgsICdzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgYXNzZXJ0KGVuZCA+PSAwICYmIGVuZCA8PSBzb3VyY2UubGVuZ3RoLCAnc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aClcbiAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldF9zdGFydCA8IGVuZCAtIHN0YXJ0KVxuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRfc3RhcnQgKyBzdGFydFxuXG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydFxuXG4gIGlmIChsZW4gPCAxMDAgfHwgIVRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldF9zdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0Ll9zZXQodGhpcy5zdWJhcnJheShzdGFydCwgc3RhcnQgKyBsZW4pLCB0YXJnZXRfc3RhcnQpXG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXMgPSAnJ1xuICB2YXIgdG1wID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgaWYgKGJ1ZltpXSA8PSAweDdGKSB7XG4gICAgICByZXMgKz0gZGVjb2RlVXRmOENoYXIodG1wKSArIFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICAgICAgdG1wID0gJydcbiAgICB9IGVsc2Uge1xuICAgICAgdG1wICs9ICclJyArIGJ1ZltpXS50b1N0cmluZygxNilcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzICsgZGVjb2RlVXRmOENoYXIodG1wKVxufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGJpbmFyeVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIGFzY2lpU2xpY2UoYnVmLCBzdGFydCwgZW5kKVxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgdmFyIG91dCA9ICcnXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgb3V0ICs9IHRvSGV4KGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxuICB2YXIgcmVzID0gJydcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgYnl0ZXNbaSArIDFdICogMjU2KVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IH5+c3RhcnRcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB+fmVuZFxuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCArPSBsZW47XG4gICAgaWYgKHN0YXJ0IDwgMClcbiAgICAgIHN0YXJ0ID0gMFxuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XG4gICAgc3RhcnQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlblxuICAgIGlmIChlbmQgPCAwKVxuICAgICAgZW5kID0gMFxuICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xuICAgIGVuZCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KVxuICAgIGVuZCA9IHN0YXJ0XG5cbiAgaWYgKFRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICByZXR1cm4gQnVmZmVyLl9hdWdtZW50KHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZCkpXG4gIH0gZWxzZSB7XG4gICAgdmFyIHNsaWNlTGVuID0gZW5kIC0gc3RhcnRcbiAgICB2YXIgbmV3QnVmID0gbmV3IEJ1ZmZlcihzbGljZUxlbiwgdW5kZWZpbmVkLCB0cnVlKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2xpY2VMZW47IGkrKykge1xuICAgICAgbmV3QnVmW2ldID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICAgIHJldHVybiBuZXdCdWZcbiAgfVxufVxuXG4vLyBgZ2V0YCB3aWxsIGJlIHJlbW92ZWQgaW4gTm9kZSAwLjEzK1xuQnVmZmVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gIGNvbnNvbGUubG9nKCcuZ2V0KCkgaXMgZGVwcmVjYXRlZC4gQWNjZXNzIHVzaW5nIGFycmF5IGluZGV4ZXMgaW5zdGVhZC4nKVxuICByZXR1cm4gdGhpcy5yZWFkVUludDgob2Zmc2V0KVxufVxuXG4vLyBgc2V0YCB3aWxsIGJlIHJlbW92ZWQgaW4gTm9kZSAwLjEzK1xuQnVmZmVyLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAodiwgb2Zmc2V0KSB7XG4gIGNvbnNvbGUubG9nKCcuc2V0KCkgaXMgZGVwcmVjYXRlZC4gQWNjZXNzIHVzaW5nIGFycmF5IGluZGV4ZXMgaW5zdGVhZC4nKVxuICByZXR1cm4gdGhpcy53cml0ZVVJbnQ4KHYsIG9mZnNldClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0IDwgdGhpcy5sZW5ndGgsICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gIH1cblxuICBpZiAob2Zmc2V0ID49IHRoaXMubGVuZ3RoKVxuICAgIHJldHVyblxuXG4gIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuZnVuY3Rpb24gcmVhZFVJbnQxNiAoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyAxIDwgYnVmLmxlbmd0aCwgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIHZhciB2YWxcbiAgaWYgKGxpdHRsZUVuZGlhbikge1xuICAgIHZhbCA9IGJ1ZltvZmZzZXRdXG4gICAgaWYgKG9mZnNldCArIDEgPCBsZW4pXG4gICAgICB2YWwgfD0gYnVmW29mZnNldCArIDFdIDw8IDhcbiAgfSBlbHNlIHtcbiAgICB2YWwgPSBidWZbb2Zmc2V0XSA8PCA4XG4gICAgaWYgKG9mZnNldCArIDEgPCBsZW4pXG4gICAgICB2YWwgfD0gYnVmW29mZnNldCArIDFdXG4gIH1cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkVUludDE2KHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRVSW50MTYodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHJlYWRVSW50MzIgKGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMyA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICB2YXIgdmFsXG4gIGlmIChsaXR0bGVFbmRpYW4pIHtcbiAgICBpZiAob2Zmc2V0ICsgMiA8IGxlbilcbiAgICAgIHZhbCA9IGJ1ZltvZmZzZXQgKyAyXSA8PCAxNlxuICAgIGlmIChvZmZzZXQgKyAxIDwgbGVuKVxuICAgICAgdmFsIHw9IGJ1ZltvZmZzZXQgKyAxXSA8PCA4XG4gICAgdmFsIHw9IGJ1ZltvZmZzZXRdXG4gICAgaWYgKG9mZnNldCArIDMgPCBsZW4pXG4gICAgICB2YWwgPSB2YWwgKyAoYnVmW29mZnNldCArIDNdIDw8IDI0ID4+PiAwKVxuICB9IGVsc2Uge1xuICAgIGlmIChvZmZzZXQgKyAxIDwgbGVuKVxuICAgICAgdmFsID0gYnVmW29mZnNldCArIDFdIDw8IDE2XG4gICAgaWYgKG9mZnNldCArIDIgPCBsZW4pXG4gICAgICB2YWwgfD0gYnVmW29mZnNldCArIDJdIDw8IDhcbiAgICBpZiAob2Zmc2V0ICsgMyA8IGxlbilcbiAgICAgIHZhbCB8PSBidWZbb2Zmc2V0ICsgM11cbiAgICB2YWwgPSB2YWwgKyAoYnVmW29mZnNldF0gPDwgMjQgPj4+IDApXG4gIH1cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkVUludDMyKHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRVSW50MzIodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0IDwgdGhpcy5sZW5ndGgsICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gIH1cblxuICBpZiAob2Zmc2V0ID49IHRoaXMubGVuZ3RoKVxuICAgIHJldHVyblxuXG4gIHZhciBuZWcgPSB0aGlzW29mZnNldF0gJiAweDgwXG4gIGlmIChuZWcpXG4gICAgcmV0dXJuICgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMVxuICBlbHNlXG4gICAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5mdW5jdGlvbiByZWFkSW50MTYgKGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMSA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICB2YXIgdmFsID0gcmVhZFVJbnQxNihidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCB0cnVlKVxuICB2YXIgbmVnID0gdmFsICYgMHg4MDAwXG4gIGlmIChuZWcpXG4gICAgcmV0dXJuICgweGZmZmYgLSB2YWwgKyAxKSAqIC0xXG4gIGVsc2VcbiAgICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZEludDE2KHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZEludDE2KHRoaXMsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiByZWFkSW50MzIgKGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMyA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICB2YXIgdmFsID0gcmVhZFVJbnQzMihidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCB0cnVlKVxuICB2YXIgbmVnID0gdmFsICYgMHg4MDAwMDAwMFxuICBpZiAobmVnKVxuICAgIHJldHVybiAoMHhmZmZmZmZmZiAtIHZhbCArIDEpICogLTFcbiAgZWxzZVxuICAgIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkSW50MzIodGhpcywgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkSW50MzIodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHJlYWRGbG9hdCAoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMyA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gIH1cblxuICByZXR1cm4gaWVlZTc1NC5yZWFkKGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRGbG9hdCh0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRGbG9hdCh0aGlzLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gcmVhZERvdWJsZSAoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICsgNyA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gIH1cblxuICByZXR1cm4gaWVlZTc1NC5yZWFkKGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkRG91YmxlKHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWREb3VibGUodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsICdtaXNzaW5nIHZhbHVlJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgPCB0aGlzLmxlbmd0aCwgJ3RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gICAgdmVyaWZ1aW50KHZhbHVlLCAweGZmKVxuICB9XG5cbiAgaWYgKG9mZnNldCA+PSB0aGlzLmxlbmd0aCkgcmV0dXJuXG5cbiAgdGhpc1tvZmZzZXRdID0gdmFsdWVcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuZnVuY3Rpb24gd3JpdGVVSW50MTYgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsICdtaXNzaW5nIHZhbHVlJylcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMSA8IGJ1Zi5sZW5ndGgsICd0cnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICAgIHZlcmlmdWludCh2YWx1ZSwgMHhmZmZmKVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihsZW4gLSBvZmZzZXQsIDIpOyBpIDwgajsgaSsrKSB7XG4gICAgYnVmW29mZnNldCArIGldID1cbiAgICAgICAgKHZhbHVlICYgKDB4ZmYgPDwgKDggKiAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSkpKSA+Pj5cbiAgICAgICAgICAgIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpICogOFxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZVVJbnQzMiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCwgJ21pc3NpbmcgdmFsdWUnKVxuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyAzIDwgYnVmLmxlbmd0aCwgJ3RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gICAgdmVyaWZ1aW50KHZhbHVlLCAweGZmZmZmZmZmKVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihsZW4gLSBvZmZzZXQsIDQpOyBpIDwgajsgaSsrKSB7XG4gICAgYnVmW29mZnNldCArIGldID1cbiAgICAgICAgKHZhbHVlID4+PiAobGl0dGxlRW5kaWFuID8gaSA6IDMgLSBpKSAqIDgpICYgMHhmZlxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsICdtaXNzaW5nIHZhbHVlJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgPCB0aGlzLmxlbmd0aCwgJ1RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gICAgdmVyaWZzaW50KHZhbHVlLCAweDdmLCAtMHg4MClcbiAgfVxuXG4gIGlmIChvZmZzZXQgPj0gdGhpcy5sZW5ndGgpXG4gICAgcmV0dXJuXG5cbiAgaWYgKHZhbHVlID49IDApXG4gICAgdGhpcy53cml0ZVVJbnQ4KHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KVxuICBlbHNlXG4gICAgdGhpcy53cml0ZVVJbnQ4KDB4ZmYgKyB2YWx1ZSArIDEsIG9mZnNldCwgbm9Bc3NlcnQpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbmZ1bmN0aW9uIHdyaXRlSW50MTYgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsICdtaXNzaW5nIHZhbHVlJylcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMSA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICAgIHZlcmlmc2ludCh2YWx1ZSwgMHg3ZmZmLCAtMHg4MDAwKVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgaWYgKHZhbHVlID49IDApXG4gICAgd3JpdGVVSW50MTYoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KVxuICBlbHNlXG4gICAgd3JpdGVVSW50MTYoYnVmLCAweGZmZmYgKyB2YWx1ZSArIDEsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydClcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVJbnQzMiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCwgJ21pc3NpbmcgdmFsdWUnKVxuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyAzIDwgYnVmLmxlbmd0aCwgJ1RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gICAgdmVyaWZzaW50KHZhbHVlLCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIGlmICh2YWx1ZSA+PSAwKVxuICAgIHdyaXRlVUludDMyKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydClcbiAgZWxzZVxuICAgIHdyaXRlVUludDMyKGJ1ZiwgMHhmZmZmZmZmZiArIHZhbHVlICsgMSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLCAnbWlzc2luZyB2YWx1ZScpXG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDMgPCBidWYubGVuZ3RoLCAnVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgICB2ZXJpZklFRUU3NTQodmFsdWUsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLCAnbWlzc2luZyB2YWx1ZScpXG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDcgPCBidWYubGVuZ3RoLFxuICAgICAgICAnVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgICB2ZXJpZklFRUU3NTQodmFsdWUsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbi8vIGZpbGwodmFsdWUsIHN0YXJ0PTAsIGVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gKHZhbHVlLCBzdGFydCwgZW5kKSB7XG4gIGlmICghdmFsdWUpIHZhbHVlID0gMFxuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQpIGVuZCA9IHRoaXMubGVuZ3RoXG5cbiAgYXNzZXJ0KGVuZCA+PSBzdGFydCwgJ2VuZCA8IHN0YXJ0JylcblxuICAvLyBGaWxsIDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVyblxuICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVyblxuXG4gIGFzc2VydChzdGFydCA+PSAwICYmIHN0YXJ0IDwgdGhpcy5sZW5ndGgsICdzdGFydCBvdXQgb2YgYm91bmRzJylcbiAgYXNzZXJ0KGVuZCA+PSAwICYmIGVuZCA8PSB0aGlzLmxlbmd0aCwgJ2VuZCBvdXQgb2YgYm91bmRzJylcblxuICB2YXIgaVxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgIHRoaXNbaV0gPSB2YWx1ZVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYnl0ZXMgPSB1dGY4VG9CeXRlcyh2YWx1ZS50b1N0cmluZygpKVxuICAgIHZhciBsZW4gPSBieXRlcy5sZW5ndGhcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICB0aGlzW2ldID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBvdXQgPSBbXVxuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIG91dFtpXSA9IHRvSGV4KHRoaXNbaV0pXG4gICAgaWYgKGkgPT09IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMpIHtcbiAgICAgIG91dFtpICsgMV0gPSAnLi4uJ1xuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbiAgcmV0dXJuICc8QnVmZmVyICcgKyBvdXQuam9pbignICcpICsgJz4nXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBgQXJyYXlCdWZmZXJgIHdpdGggdGhlICpjb3BpZWQqIG1lbW9yeSBvZiB0aGUgYnVmZmVyIGluc3RhbmNlLlxuICogQWRkZWQgaW4gTm9kZSAwLjEyLiBPbmx5IGF2YWlsYWJsZSBpbiBicm93c2VycyB0aGF0IHN1cHBvcnQgQXJyYXlCdWZmZXIuXG4gKi9cbkJ1ZmZlci5wcm90b3R5cGUudG9BcnJheUJ1ZmZlciA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmIChUWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgICByZXR1cm4gKG5ldyBCdWZmZXIodGhpcykpLmJ1ZmZlclxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYnVmID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5sZW5ndGgpXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYnVmLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIGJ1ZltpXSA9IHRoaXNbaV1cbiAgICAgIH1cbiAgICAgIHJldHVybiBidWYuYnVmZmVyXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignQnVmZmVyLnRvQXJyYXlCdWZmZXIgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXInKVxuICB9XG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxudmFyIEJQID0gQnVmZmVyLnByb3RvdHlwZVxuXG4vKipcbiAqIEF1Z21lbnQgYSBVaW50OEFycmF5ICppbnN0YW5jZSogKG5vdCB0aGUgVWludDhBcnJheSBjbGFzcyEpIHdpdGggQnVmZmVyIG1ldGhvZHNcbiAqL1xuQnVmZmVyLl9hdWdtZW50ID0gZnVuY3Rpb24gKGFycikge1xuICBhcnIuX2lzQnVmZmVyID0gdHJ1ZVxuXG4gIC8vIHNhdmUgcmVmZXJlbmNlIHRvIG9yaWdpbmFsIFVpbnQ4QXJyYXkgZ2V0L3NldCBtZXRob2RzIGJlZm9yZSBvdmVyd3JpdGluZ1xuICBhcnIuX2dldCA9IGFyci5nZXRcbiAgYXJyLl9zZXQgPSBhcnIuc2V0XG5cbiAgLy8gZGVwcmVjYXRlZCwgd2lsbCBiZSByZW1vdmVkIGluIG5vZGUgMC4xMytcbiAgYXJyLmdldCA9IEJQLmdldFxuICBhcnIuc2V0ID0gQlAuc2V0XG5cbiAgYXJyLndyaXRlID0gQlAud3JpdGVcbiAgYXJyLnRvU3RyaW5nID0gQlAudG9TdHJpbmdcbiAgYXJyLnRvTG9jYWxlU3RyaW5nID0gQlAudG9TdHJpbmdcbiAgYXJyLnRvSlNPTiA9IEJQLnRvSlNPTlxuICBhcnIuZXF1YWxzID0gQlAuZXF1YWxzXG4gIGFyci5jb21wYXJlID0gQlAuY29tcGFyZVxuICBhcnIuY29weSA9IEJQLmNvcHlcbiAgYXJyLnNsaWNlID0gQlAuc2xpY2VcbiAgYXJyLnJlYWRVSW50OCA9IEJQLnJlYWRVSW50OFxuICBhcnIucmVhZFVJbnQxNkxFID0gQlAucmVhZFVJbnQxNkxFXG4gIGFyci5yZWFkVUludDE2QkUgPSBCUC5yZWFkVUludDE2QkVcbiAgYXJyLnJlYWRVSW50MzJMRSA9IEJQLnJlYWRVSW50MzJMRVxuICBhcnIucmVhZFVJbnQzMkJFID0gQlAucmVhZFVJbnQzMkJFXG4gIGFyci5yZWFkSW50OCA9IEJQLnJlYWRJbnQ4XG4gIGFyci5yZWFkSW50MTZMRSA9IEJQLnJlYWRJbnQxNkxFXG4gIGFyci5yZWFkSW50MTZCRSA9IEJQLnJlYWRJbnQxNkJFXG4gIGFyci5yZWFkSW50MzJMRSA9IEJQLnJlYWRJbnQzMkxFXG4gIGFyci5yZWFkSW50MzJCRSA9IEJQLnJlYWRJbnQzMkJFXG4gIGFyci5yZWFkRmxvYXRMRSA9IEJQLnJlYWRGbG9hdExFXG4gIGFyci5yZWFkRmxvYXRCRSA9IEJQLnJlYWRGbG9hdEJFXG4gIGFyci5yZWFkRG91YmxlTEUgPSBCUC5yZWFkRG91YmxlTEVcbiAgYXJyLnJlYWREb3VibGVCRSA9IEJQLnJlYWREb3VibGVCRVxuICBhcnIud3JpdGVVSW50OCA9IEJQLndyaXRlVUludDhcbiAgYXJyLndyaXRlVUludDE2TEUgPSBCUC53cml0ZVVJbnQxNkxFXG4gIGFyci53cml0ZVVJbnQxNkJFID0gQlAud3JpdGVVSW50MTZCRVxuICBhcnIud3JpdGVVSW50MzJMRSA9IEJQLndyaXRlVUludDMyTEVcbiAgYXJyLndyaXRlVUludDMyQkUgPSBCUC53cml0ZVVJbnQzMkJFXG4gIGFyci53cml0ZUludDggPSBCUC53cml0ZUludDhcbiAgYXJyLndyaXRlSW50MTZMRSA9IEJQLndyaXRlSW50MTZMRVxuICBhcnIud3JpdGVJbnQxNkJFID0gQlAud3JpdGVJbnQxNkJFXG4gIGFyci53cml0ZUludDMyTEUgPSBCUC53cml0ZUludDMyTEVcbiAgYXJyLndyaXRlSW50MzJCRSA9IEJQLndyaXRlSW50MzJCRVxuICBhcnIud3JpdGVGbG9hdExFID0gQlAud3JpdGVGbG9hdExFXG4gIGFyci53cml0ZUZsb2F0QkUgPSBCUC53cml0ZUZsb2F0QkVcbiAgYXJyLndyaXRlRG91YmxlTEUgPSBCUC53cml0ZURvdWJsZUxFXG4gIGFyci53cml0ZURvdWJsZUJFID0gQlAud3JpdGVEb3VibGVCRVxuICBhcnIuZmlsbCA9IEJQLmZpbGxcbiAgYXJyLmluc3BlY3QgPSBCUC5pbnNwZWN0XG4gIGFyci50b0FycmF5QnVmZmVyID0gQlAudG9BcnJheUJ1ZmZlclxuXG4gIHJldHVybiBhcnJcbn1cblxudmFyIElOVkFMSURfQkFTRTY0X1JFID0gL1teK1xcLzAtOUEtel0vZ1xuXG5mdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHJpbmd0cmltKHN0cikucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSdcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHN0cmluZ3RyaW0gKHN0cikge1xuICBpZiAoc3RyLnRyaW0pIHJldHVybiBzdHIudHJpbSgpXG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpXG59XG5cbmZ1bmN0aW9uIGlzQXJyYXkgKHN1YmplY3QpIHtcbiAgcmV0dXJuIChBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChzdWJqZWN0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzdWJqZWN0KSA9PT0gJ1tvYmplY3QgQXJyYXldJ1xuICB9KShzdWJqZWN0KVxufVxuXG5mdW5jdGlvbiBpc0FycmF5aXNoIChzdWJqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5KHN1YmplY3QpIHx8IEJ1ZmZlci5pc0J1ZmZlcihzdWJqZWN0KSB8fFxuICAgICAgc3ViamVjdCAmJiB0eXBlb2Ygc3ViamVjdCA9PT0gJ29iamVjdCcgJiZcbiAgICAgIHR5cGVvZiBzdWJqZWN0Lmxlbmd0aCA9PT0gJ251bWJlcidcbn1cblxuZnVuY3Rpb24gdG9IZXggKG4pIHtcbiAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpXG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KVxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIHZhciBiID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBpZiAoYiA8PSAweDdGKSB7XG4gICAgICBieXRlQXJyYXkucHVzaChiKVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc3RhcnQgPSBpXG4gICAgICBpZiAoYiA+PSAweEQ4MDAgJiYgYiA8PSAweERGRkYpIGkrK1xuICAgICAgdmFyIGggPSBlbmNvZGVVUklDb21wb25lbnQoc3RyLnNsaWNlKHN0YXJ0LCBpKzEpKS5zdWJzdHIoMSkuc3BsaXQoJyUnKVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBoLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGJ5dGVBcnJheS5wdXNoKHBhcnNlSW50KGhbal0sIDE2KSlcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBjLCBoaSwgbG9cbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoc3RyKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSlcbiAgICAgIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gZGVjb2RlVXRmOENoYXIgKHN0cikge1xuICB0cnkge1xuICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoc3RyKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSgweEZGRkQpIC8vIFVURiA4IGludmFsaWQgY2hhclxuICB9XG59XG5cbi8qXG4gKiBXZSBoYXZlIHRvIG1ha2Ugc3VyZSB0aGF0IHRoZSB2YWx1ZSBpcyBhIHZhbGlkIGludGVnZXIuIFRoaXMgbWVhbnMgdGhhdCBpdFxuICogaXMgbm9uLW5lZ2F0aXZlLiBJdCBoYXMgbm8gZnJhY3Rpb25hbCBjb21wb25lbnQgYW5kIHRoYXQgaXQgZG9lcyBub3RcbiAqIGV4Y2VlZCB0aGUgbWF4aW11bSBhbGxvd2VkIHZhbHVlLlxuICovXG5mdW5jdGlvbiB2ZXJpZnVpbnQgKHZhbHVlLCBtYXgpIHtcbiAgYXNzZXJ0KHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicsICdjYW5ub3Qgd3JpdGUgYSBub24tbnVtYmVyIGFzIGEgbnVtYmVyJylcbiAgYXNzZXJ0KHZhbHVlID49IDAsICdzcGVjaWZpZWQgYSBuZWdhdGl2ZSB2YWx1ZSBmb3Igd3JpdGluZyBhbiB1bnNpZ25lZCB2YWx1ZScpXG4gIGFzc2VydCh2YWx1ZSA8PSBtYXgsICd2YWx1ZSBpcyBsYXJnZXIgdGhhbiBtYXhpbXVtIHZhbHVlIGZvciB0eXBlJylcbiAgYXNzZXJ0KE1hdGguZmxvb3IodmFsdWUpID09PSB2YWx1ZSwgJ3ZhbHVlIGhhcyBhIGZyYWN0aW9uYWwgY29tcG9uZW50Jylcbn1cblxuZnVuY3Rpb24gdmVyaWZzaW50ICh2YWx1ZSwgbWF4LCBtaW4pIHtcbiAgYXNzZXJ0KHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicsICdjYW5ub3Qgd3JpdGUgYSBub24tbnVtYmVyIGFzIGEgbnVtYmVyJylcbiAgYXNzZXJ0KHZhbHVlIDw9IG1heCwgJ3ZhbHVlIGxhcmdlciB0aGFuIG1heGltdW0gYWxsb3dlZCB2YWx1ZScpXG4gIGFzc2VydCh2YWx1ZSA+PSBtaW4sICd2YWx1ZSBzbWFsbGVyIHRoYW4gbWluaW11bSBhbGxvd2VkIHZhbHVlJylcbiAgYXNzZXJ0KE1hdGguZmxvb3IodmFsdWUpID09PSB2YWx1ZSwgJ3ZhbHVlIGhhcyBhIGZyYWN0aW9uYWwgY29tcG9uZW50Jylcbn1cblxuZnVuY3Rpb24gdmVyaWZJRUVFNzU0ICh2YWx1ZSwgbWF4LCBtaW4pIHtcbiAgYXNzZXJ0KHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicsICdjYW5ub3Qgd3JpdGUgYSBub24tbnVtYmVyIGFzIGEgbnVtYmVyJylcbiAgYXNzZXJ0KHZhbHVlIDw9IG1heCwgJ3ZhbHVlIGxhcmdlciB0aGFuIG1heGltdW0gYWxsb3dlZCB2YWx1ZScpXG4gIGFzc2VydCh2YWx1ZSA+PSBtaW4sICd2YWx1ZSBzbWFsbGVyIHRoYW4gbWluaW11bSBhbGxvd2VkIHZhbHVlJylcbn1cblxuZnVuY3Rpb24gYXNzZXJ0ICh0ZXN0LCBtZXNzYWdlKSB7XG4gIGlmICghdGVzdCkgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UgfHwgJ0ZhaWxlZCBhc3NlcnRpb24nKVxufVxuIiwidmFyIGxvb2t1cCA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJztcblxuOyhmdW5jdGlvbiAoZXhwb3J0cykge1xuXHQndXNlIHN0cmljdCc7XG5cbiAgdmFyIEFyciA9ICh0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgPyBVaW50OEFycmF5XG4gICAgOiBBcnJheVxuXG5cdHZhciBQTFVTICAgPSAnKycuY2hhckNvZGVBdCgwKVxuXHR2YXIgU0xBU0ggID0gJy8nLmNoYXJDb2RlQXQoMClcblx0dmFyIE5VTUJFUiA9ICcwJy5jaGFyQ29kZUF0KDApXG5cdHZhciBMT1dFUiAgPSAnYScuY2hhckNvZGVBdCgwKVxuXHR2YXIgVVBQRVIgID0gJ0EnLmNoYXJDb2RlQXQoMClcblxuXHRmdW5jdGlvbiBkZWNvZGUgKGVsdCkge1xuXHRcdHZhciBjb2RlID0gZWx0LmNoYXJDb2RlQXQoMClcblx0XHRpZiAoY29kZSA9PT0gUExVUylcblx0XHRcdHJldHVybiA2MiAvLyAnKydcblx0XHRpZiAoY29kZSA9PT0gU0xBU0gpXG5cdFx0XHRyZXR1cm4gNjMgLy8gJy8nXG5cdFx0aWYgKGNvZGUgPCBOVU1CRVIpXG5cdFx0XHRyZXR1cm4gLTEgLy9ubyBtYXRjaFxuXHRcdGlmIChjb2RlIDwgTlVNQkVSICsgMTApXG5cdFx0XHRyZXR1cm4gY29kZSAtIE5VTUJFUiArIDI2ICsgMjZcblx0XHRpZiAoY29kZSA8IFVQUEVSICsgMjYpXG5cdFx0XHRyZXR1cm4gY29kZSAtIFVQUEVSXG5cdFx0aWYgKGNvZGUgPCBMT1dFUiArIDI2KVxuXHRcdFx0cmV0dXJuIGNvZGUgLSBMT1dFUiArIDI2XG5cdH1cblxuXHRmdW5jdGlvbiBiNjRUb0J5dGVBcnJheSAoYjY0KSB7XG5cdFx0dmFyIGksIGosIGwsIHRtcCwgcGxhY2VIb2xkZXJzLCBhcnJcblxuXHRcdGlmIChiNjQubGVuZ3RoICUgNCA+IDApIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXG5cdFx0fVxuXG5cdFx0Ly8gdGhlIG51bWJlciBvZiBlcXVhbCBzaWducyAocGxhY2UgaG9sZGVycylcblx0XHQvLyBpZiB0aGVyZSBhcmUgdHdvIHBsYWNlaG9sZGVycywgdGhhbiB0aGUgdHdvIGNoYXJhY3RlcnMgYmVmb3JlIGl0XG5cdFx0Ly8gcmVwcmVzZW50IG9uZSBieXRlXG5cdFx0Ly8gaWYgdGhlcmUgaXMgb25seSBvbmUsIHRoZW4gdGhlIHRocmVlIGNoYXJhY3RlcnMgYmVmb3JlIGl0IHJlcHJlc2VudCAyIGJ5dGVzXG5cdFx0Ly8gdGhpcyBpcyBqdXN0IGEgY2hlYXAgaGFjayB0byBub3QgZG8gaW5kZXhPZiB0d2ljZVxuXHRcdHZhciBsZW4gPSBiNjQubGVuZ3RoXG5cdFx0cGxhY2VIb2xkZXJzID0gJz0nID09PSBiNjQuY2hhckF0KGxlbiAtIDIpID8gMiA6ICc9JyA9PT0gYjY0LmNoYXJBdChsZW4gLSAxKSA/IDEgOiAwXG5cblx0XHQvLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGFcblx0XHRhcnIgPSBuZXcgQXJyKGI2NC5sZW5ndGggKiAzIC8gNCAtIHBsYWNlSG9sZGVycylcblxuXHRcdC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcblx0XHRsID0gcGxhY2VIb2xkZXJzID4gMCA/IGI2NC5sZW5ndGggLSA0IDogYjY0Lmxlbmd0aFxuXG5cdFx0dmFyIEwgPSAwXG5cblx0XHRmdW5jdGlvbiBwdXNoICh2KSB7XG5cdFx0XHRhcnJbTCsrXSA9IHZcblx0XHR9XG5cblx0XHRmb3IgKGkgPSAwLCBqID0gMDsgaSA8IGw7IGkgKz0gNCwgaiArPSAzKSB7XG5cdFx0XHR0bXAgPSAoZGVjb2RlKGI2NC5jaGFyQXQoaSkpIDw8IDE4KSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMSkpIDw8IDEyKSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMikpIDw8IDYpIHwgZGVjb2RlKGI2NC5jaGFyQXQoaSArIDMpKVxuXHRcdFx0cHVzaCgodG1wICYgMHhGRjAwMDApID4+IDE2KVxuXHRcdFx0cHVzaCgodG1wICYgMHhGRjAwKSA+PiA4KVxuXHRcdFx0cHVzaCh0bXAgJiAweEZGKVxuXHRcdH1cblxuXHRcdGlmIChwbGFjZUhvbGRlcnMgPT09IDIpIHtcblx0XHRcdHRtcCA9IChkZWNvZGUoYjY0LmNoYXJBdChpKSkgPDwgMikgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDEpKSA+PiA0KVxuXHRcdFx0cHVzaCh0bXAgJiAweEZGKVxuXHRcdH0gZWxzZSBpZiAocGxhY2VIb2xkZXJzID09PSAxKSB7XG5cdFx0XHR0bXAgPSAoZGVjb2RlKGI2NC5jaGFyQXQoaSkpIDw8IDEwKSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMSkpIDw8IDQpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAyKSkgPj4gMilcblx0XHRcdHB1c2goKHRtcCA+PiA4KSAmIDB4RkYpXG5cdFx0XHRwdXNoKHRtcCAmIDB4RkYpXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGFyclxuXHR9XG5cblx0ZnVuY3Rpb24gdWludDhUb0Jhc2U2NCAodWludDgpIHtcblx0XHR2YXIgaSxcblx0XHRcdGV4dHJhQnl0ZXMgPSB1aW50OC5sZW5ndGggJSAzLCAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuXHRcdFx0b3V0cHV0ID0gXCJcIixcblx0XHRcdHRlbXAsIGxlbmd0aFxuXG5cdFx0ZnVuY3Rpb24gZW5jb2RlIChudW0pIHtcblx0XHRcdHJldHVybiBsb29rdXAuY2hhckF0KG51bSlcblx0XHR9XG5cblx0XHRmdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuXHRcdFx0cmV0dXJuIGVuY29kZShudW0gPj4gMTggJiAweDNGKSArIGVuY29kZShudW0gPj4gMTIgJiAweDNGKSArIGVuY29kZShudW0gPj4gNiAmIDB4M0YpICsgZW5jb2RlKG51bSAmIDB4M0YpXG5cdFx0fVxuXG5cdFx0Ly8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuXHRcdGZvciAoaSA9IDAsIGxlbmd0aCA9IHVpbnQ4Lmxlbmd0aCAtIGV4dHJhQnl0ZXM7IGkgPCBsZW5ndGg7IGkgKz0gMykge1xuXHRcdFx0dGVtcCA9ICh1aW50OFtpXSA8PCAxNikgKyAodWludDhbaSArIDFdIDw8IDgpICsgKHVpbnQ4W2kgKyAyXSlcblx0XHRcdG91dHB1dCArPSB0cmlwbGV0VG9CYXNlNjQodGVtcClcblx0XHR9XG5cblx0XHQvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG5cdFx0c3dpdGNoIChleHRyYUJ5dGVzKSB7XG5cdFx0XHRjYXNlIDE6XG5cdFx0XHRcdHRlbXAgPSB1aW50OFt1aW50OC5sZW5ndGggLSAxXVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKHRlbXAgPj4gMilcblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSgodGVtcCA8PCA0KSAmIDB4M0YpXG5cdFx0XHRcdG91dHB1dCArPSAnPT0nXG5cdFx0XHRcdGJyZWFrXG5cdFx0XHRjYXNlIDI6XG5cdFx0XHRcdHRlbXAgPSAodWludDhbdWludDgubGVuZ3RoIC0gMl0gPDwgOCkgKyAodWludDhbdWludDgubGVuZ3RoIC0gMV0pXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUodGVtcCA+PiAxMClcblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSgodGVtcCA+PiA0KSAmIDB4M0YpXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUoKHRlbXAgPDwgMikgJiAweDNGKVxuXHRcdFx0XHRvdXRwdXQgKz0gJz0nXG5cdFx0XHRcdGJyZWFrXG5cdFx0fVxuXG5cdFx0cmV0dXJuIG91dHB1dFxuXHR9XG5cblx0ZXhwb3J0cy50b0J5dGVBcnJheSA9IGI2NFRvQnl0ZUFycmF5XG5cdGV4cG9ydHMuZnJvbUJ5dGVBcnJheSA9IHVpbnQ4VG9CYXNlNjRcbn0odHlwZW9mIGV4cG9ydHMgPT09ICd1bmRlZmluZWQnID8gKHRoaXMuYmFzZTY0anMgPSB7fSkgOiBleHBvcnRzKSlcbiIsImV4cG9ydHMucmVhZCA9IGZ1bmN0aW9uKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sXG4gICAgICBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxLFxuICAgICAgZU1heCA9ICgxIDw8IGVMZW4pIC0gMSxcbiAgICAgIGVCaWFzID0gZU1heCA+PiAxLFxuICAgICAgbkJpdHMgPSAtNyxcbiAgICAgIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMCxcbiAgICAgIGQgPSBpc0xFID8gLTEgOiAxLFxuICAgICAgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXTtcblxuICBpICs9IGQ7XG5cbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSk7XG4gIHMgPj49ICgtbkJpdHMpO1xuICBuQml0cyArPSBlTGVuO1xuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gZSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KTtcblxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKTtcbiAgZSA+Pj0gKC1uQml0cyk7XG4gIG5CaXRzICs9IG1MZW47XG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSBtICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpO1xuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhcztcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpO1xuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbik7XG4gICAgZSA9IGUgLSBlQmlhcztcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKTtcbn07XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbihidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSwgYyxcbiAgICAgIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDEsXG4gICAgICBlTWF4ID0gKDEgPDwgZUxlbikgLSAxLFxuICAgICAgZUJpYXMgPSBlTWF4ID4+IDEsXG4gICAgICBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMCksXG4gICAgICBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSksXG4gICAgICBkID0gaXNMRSA/IDEgOiAtMSxcbiAgICAgIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDA7XG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSk7XG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDA7XG4gICAgZSA9IGVNYXg7XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpO1xuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLTtcbiAgICAgIGMgKj0gMjtcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKys7XG4gICAgICBjIC89IDI7XG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMDtcbiAgICAgIGUgPSBlTWF4O1xuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAodmFsdWUgKiBjIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKTtcbiAgICAgIGUgPSBlICsgZUJpYXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKTtcbiAgICAgIGUgPSAwO1xuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpO1xuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG07XG4gIGVMZW4gKz0gbUxlbjtcbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KTtcblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjg7XG59O1xuIiwiKGZ1bmN0aW9uIChwcm9jZXNzKXtcbi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyByZXNvbHZlcyAuIGFuZCAuLiBlbGVtZW50cyBpbiBhIHBhdGggYXJyYXkgd2l0aCBkaXJlY3RvcnkgbmFtZXMgdGhlcmVcbi8vIG11c3QgYmUgbm8gc2xhc2hlcywgZW1wdHkgZWxlbWVudHMsIG9yIGRldmljZSBuYW1lcyAoYzpcXCkgaW4gdGhlIGFycmF5XG4vLyAoc28gYWxzbyBubyBsZWFkaW5nIGFuZCB0cmFpbGluZyBzbGFzaGVzIC0gaXQgZG9lcyBub3QgZGlzdGluZ3Vpc2hcbi8vIHJlbGF0aXZlIGFuZCBhYnNvbHV0ZSBwYXRocylcbmZ1bmN0aW9uIG5vcm1hbGl6ZUFycmF5KHBhcnRzLCBhbGxvd0Fib3ZlUm9vdCkge1xuICAvLyBpZiB0aGUgcGF0aCB0cmllcyB0byBnbyBhYm92ZSB0aGUgcm9vdCwgYHVwYCBlbmRzIHVwID4gMFxuICB2YXIgdXAgPSAwO1xuICBmb3IgKHZhciBpID0gcGFydHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgbGFzdCA9IHBhcnRzW2ldO1xuICAgIGlmIChsYXN0ID09PSAnLicpIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2UgaWYgKGxhc3QgPT09ICcuLicpIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICAgIHVwKys7XG4gICAgfSBlbHNlIGlmICh1cCkge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgICAgdXAtLTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGUgcGF0aCBpcyBhbGxvd2VkIHRvIGdvIGFib3ZlIHRoZSByb290LCByZXN0b3JlIGxlYWRpbmcgLi5zXG4gIGlmIChhbGxvd0Fib3ZlUm9vdCkge1xuICAgIGZvciAoOyB1cC0tOyB1cCkge1xuICAgICAgcGFydHMudW5zaGlmdCgnLi4nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcGFydHM7XG59XG5cbi8vIFNwbGl0IGEgZmlsZW5hbWUgaW50byBbcm9vdCwgZGlyLCBiYXNlbmFtZSwgZXh0XSwgdW5peCB2ZXJzaW9uXG4vLyAncm9vdCcgaXMganVzdCBhIHNsYXNoLCBvciBub3RoaW5nLlxudmFyIHNwbGl0UGF0aFJlID1cbiAgICAvXihcXC8/fCkoW1xcc1xcU10qPykoKD86XFwuezEsMn18W15cXC9dKz98KShcXC5bXi5cXC9dKnwpKSg/OltcXC9dKikkLztcbnZhciBzcGxpdFBhdGggPSBmdW5jdGlvbihmaWxlbmFtZSkge1xuICByZXR1cm4gc3BsaXRQYXRoUmUuZXhlYyhmaWxlbmFtZSkuc2xpY2UoMSk7XG59O1xuXG4vLyBwYXRoLnJlc29sdmUoW2Zyb20gLi4uXSwgdG8pXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLnJlc29sdmUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJlc29sdmVkUGF0aCA9ICcnLFxuICAgICAgcmVzb2x2ZWRBYnNvbHV0ZSA9IGZhbHNlO1xuXG4gIGZvciAodmFyIGkgPSBhcmd1bWVudHMubGVuZ3RoIC0gMTsgaSA+PSAtMSAmJiAhcmVzb2x2ZWRBYnNvbHV0ZTsgaS0tKSB7XG4gICAgdmFyIHBhdGggPSAoaSA+PSAwKSA/IGFyZ3VtZW50c1tpXSA6IHByb2Nlc3MuY3dkKCk7XG5cbiAgICAvLyBTa2lwIGVtcHR5IGFuZCBpbnZhbGlkIGVudHJpZXNcbiAgICBpZiAodHlwZW9mIHBhdGggIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgdG8gcGF0aC5yZXNvbHZlIG11c3QgYmUgc3RyaW5ncycpO1xuICAgIH0gZWxzZSBpZiAoIXBhdGgpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHJlc29sdmVkUGF0aCA9IHBhdGggKyAnLycgKyByZXNvbHZlZFBhdGg7XG4gICAgcmVzb2x2ZWRBYnNvbHV0ZSA9IHBhdGguY2hhckF0KDApID09PSAnLyc7XG4gIH1cblxuICAvLyBBdCB0aGlzIHBvaW50IHRoZSBwYXRoIHNob3VsZCBiZSByZXNvbHZlZCB0byBhIGZ1bGwgYWJzb2x1dGUgcGF0aCwgYnV0XG4gIC8vIGhhbmRsZSByZWxhdGl2ZSBwYXRocyB0byBiZSBzYWZlIChtaWdodCBoYXBwZW4gd2hlbiBwcm9jZXNzLmN3ZCgpIGZhaWxzKVxuXG4gIC8vIE5vcm1hbGl6ZSB0aGUgcGF0aFxuICByZXNvbHZlZFBhdGggPSBub3JtYWxpemVBcnJheShmaWx0ZXIocmVzb2x2ZWRQYXRoLnNwbGl0KCcvJyksIGZ1bmN0aW9uKHApIHtcbiAgICByZXR1cm4gISFwO1xuICB9KSwgIXJlc29sdmVkQWJzb2x1dGUpLmpvaW4oJy8nKTtcblxuICByZXR1cm4gKChyZXNvbHZlZEFic29sdXRlID8gJy8nIDogJycpICsgcmVzb2x2ZWRQYXRoKSB8fCAnLic7XG59O1xuXG4vLyBwYXRoLm5vcm1hbGl6ZShwYXRoKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5ub3JtYWxpemUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHZhciBpc0Fic29sdXRlID0gZXhwb3J0cy5pc0Fic29sdXRlKHBhdGgpLFxuICAgICAgdHJhaWxpbmdTbGFzaCA9IHN1YnN0cihwYXRoLCAtMSkgPT09ICcvJztcblxuICAvLyBOb3JtYWxpemUgdGhlIHBhdGhcbiAgcGF0aCA9IG5vcm1hbGl6ZUFycmF5KGZpbHRlcihwYXRoLnNwbGl0KCcvJyksIGZ1bmN0aW9uKHApIHtcbiAgICByZXR1cm4gISFwO1xuICB9KSwgIWlzQWJzb2x1dGUpLmpvaW4oJy8nKTtcblxuICBpZiAoIXBhdGggJiYgIWlzQWJzb2x1dGUpIHtcbiAgICBwYXRoID0gJy4nO1xuICB9XG4gIGlmIChwYXRoICYmIHRyYWlsaW5nU2xhc2gpIHtcbiAgICBwYXRoICs9ICcvJztcbiAgfVxuXG4gIHJldHVybiAoaXNBYnNvbHV0ZSA/ICcvJyA6ICcnKSArIHBhdGg7XG59O1xuXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLmlzQWJzb2x1dGUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHJldHVybiBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nO1xufTtcblxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5qb2luID0gZnVuY3Rpb24oKSB7XG4gIHZhciBwYXRocyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG4gIHJldHVybiBleHBvcnRzLm5vcm1hbGl6ZShmaWx0ZXIocGF0aHMsIGZ1bmN0aW9uKHAsIGluZGV4KSB7XG4gICAgaWYgKHR5cGVvZiBwICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIHRvIHBhdGguam9pbiBtdXN0IGJlIHN0cmluZ3MnKTtcbiAgICB9XG4gICAgcmV0dXJuIHA7XG4gIH0pLmpvaW4oJy8nKSk7XG59O1xuXG5cbi8vIHBhdGgucmVsYXRpdmUoZnJvbSwgdG8pXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLnJlbGF0aXZlID0gZnVuY3Rpb24oZnJvbSwgdG8pIHtcbiAgZnJvbSA9IGV4cG9ydHMucmVzb2x2ZShmcm9tKS5zdWJzdHIoMSk7XG4gIHRvID0gZXhwb3J0cy5yZXNvbHZlKHRvKS5zdWJzdHIoMSk7XG5cbiAgZnVuY3Rpb24gdHJpbShhcnIpIHtcbiAgICB2YXIgc3RhcnQgPSAwO1xuICAgIGZvciAoOyBzdGFydCA8IGFyci5sZW5ndGg7IHN0YXJ0KyspIHtcbiAgICAgIGlmIChhcnJbc3RhcnRdICE9PSAnJykgYnJlYWs7XG4gICAgfVxuXG4gICAgdmFyIGVuZCA9IGFyci5sZW5ndGggLSAxO1xuICAgIGZvciAoOyBlbmQgPj0gMDsgZW5kLS0pIHtcbiAgICAgIGlmIChhcnJbZW5kXSAhPT0gJycpIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChzdGFydCA+IGVuZCkgcmV0dXJuIFtdO1xuICAgIHJldHVybiBhcnIuc2xpY2Uoc3RhcnQsIGVuZCAtIHN0YXJ0ICsgMSk7XG4gIH1cblxuICB2YXIgZnJvbVBhcnRzID0gdHJpbShmcm9tLnNwbGl0KCcvJykpO1xuICB2YXIgdG9QYXJ0cyA9IHRyaW0odG8uc3BsaXQoJy8nKSk7XG5cbiAgdmFyIGxlbmd0aCA9IE1hdGgubWluKGZyb21QYXJ0cy5sZW5ndGgsIHRvUGFydHMubGVuZ3RoKTtcbiAgdmFyIHNhbWVQYXJ0c0xlbmd0aCA9IGxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGlmIChmcm9tUGFydHNbaV0gIT09IHRvUGFydHNbaV0pIHtcbiAgICAgIHNhbWVQYXJ0c0xlbmd0aCA9IGk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICB2YXIgb3V0cHV0UGFydHMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IHNhbWVQYXJ0c0xlbmd0aDsgaSA8IGZyb21QYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgIG91dHB1dFBhcnRzLnB1c2goJy4uJyk7XG4gIH1cblxuICBvdXRwdXRQYXJ0cyA9IG91dHB1dFBhcnRzLmNvbmNhdCh0b1BhcnRzLnNsaWNlKHNhbWVQYXJ0c0xlbmd0aCkpO1xuXG4gIHJldHVybiBvdXRwdXRQYXJ0cy5qb2luKCcvJyk7XG59O1xuXG5leHBvcnRzLnNlcCA9ICcvJztcbmV4cG9ydHMuZGVsaW1pdGVyID0gJzonO1xuXG5leHBvcnRzLmRpcm5hbWUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHZhciByZXN1bHQgPSBzcGxpdFBhdGgocGF0aCksXG4gICAgICByb290ID0gcmVzdWx0WzBdLFxuICAgICAgZGlyID0gcmVzdWx0WzFdO1xuXG4gIGlmICghcm9vdCAmJiAhZGlyKSB7XG4gICAgLy8gTm8gZGlybmFtZSB3aGF0c29ldmVyXG4gICAgcmV0dXJuICcuJztcbiAgfVxuXG4gIGlmIChkaXIpIHtcbiAgICAvLyBJdCBoYXMgYSBkaXJuYW1lLCBzdHJpcCB0cmFpbGluZyBzbGFzaFxuICAgIGRpciA9IGRpci5zdWJzdHIoMCwgZGlyLmxlbmd0aCAtIDEpO1xuICB9XG5cbiAgcmV0dXJuIHJvb3QgKyBkaXI7XG59O1xuXG5cbmV4cG9ydHMuYmFzZW5hbWUgPSBmdW5jdGlvbihwYXRoLCBleHQpIHtcbiAgdmFyIGYgPSBzcGxpdFBhdGgocGF0aClbMl07XG4gIC8vIFRPRE86IG1ha2UgdGhpcyBjb21wYXJpc29uIGNhc2UtaW5zZW5zaXRpdmUgb24gd2luZG93cz9cbiAgaWYgKGV4dCAmJiBmLnN1YnN0cigtMSAqIGV4dC5sZW5ndGgpID09PSBleHQpIHtcbiAgICBmID0gZi5zdWJzdHIoMCwgZi5sZW5ndGggLSBleHQubGVuZ3RoKTtcbiAgfVxuICByZXR1cm4gZjtcbn07XG5cblxuZXhwb3J0cy5leHRuYW1lID0gZnVuY3Rpb24ocGF0aCkge1xuICByZXR1cm4gc3BsaXRQYXRoKHBhdGgpWzNdO1xufTtcblxuZnVuY3Rpb24gZmlsdGVyICh4cywgZikge1xuICAgIGlmICh4cy5maWx0ZXIpIHJldHVybiB4cy5maWx0ZXIoZik7XG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGYoeHNbaV0sIGksIHhzKSkgcmVzLnB1c2goeHNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuXG4vLyBTdHJpbmcucHJvdG90eXBlLnN1YnN0ciAtIG5lZ2F0aXZlIGluZGV4IGRvbid0IHdvcmsgaW4gSUU4XG52YXIgc3Vic3RyID0gJ2FiJy5zdWJzdHIoLTEpID09PSAnYidcbiAgICA/IGZ1bmN0aW9uIChzdHIsIHN0YXJ0LCBsZW4pIHsgcmV0dXJuIHN0ci5zdWJzdHIoc3RhcnQsIGxlbikgfVxuICAgIDogZnVuY3Rpb24gKHN0ciwgc3RhcnQsIGxlbikge1xuICAgICAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IHN0ci5sZW5ndGggKyBzdGFydDtcbiAgICAgICAgcmV0dXJuIHN0ci5zdWJzdHIoc3RhcnQsIGxlbik7XG4gICAgfVxuO1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcIitOc2NObVwiKSkiLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcblxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG5wcm9jZXNzLm5leHRUaWNrID0gKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY2FuU2V0SW1tZWRpYXRlID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcbiAgICAmJiB3aW5kb3cuc2V0SW1tZWRpYXRlO1xuICAgIHZhciBjYW5Qb3N0ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcbiAgICAmJiB3aW5kb3cucG9zdE1lc3NhZ2UgJiYgd2luZG93LmFkZEV2ZW50TGlzdGVuZXJcbiAgICA7XG5cbiAgICBpZiAoY2FuU2V0SW1tZWRpYXRlKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZikgeyByZXR1cm4gd2luZG93LnNldEltbWVkaWF0ZShmKSB9O1xuICAgIH1cblxuICAgIGlmIChjYW5Qb3N0KSB7XG4gICAgICAgIHZhciBxdWV1ZSA9IFtdO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgdmFyIHNvdXJjZSA9IGV2LnNvdXJjZTtcbiAgICAgICAgICAgIGlmICgoc291cmNlID09PSB3aW5kb3cgfHwgc291cmNlID09PSBudWxsKSAmJiBldi5kYXRhID09PSAncHJvY2Vzcy10aWNrJykge1xuICAgICAgICAgICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIGlmIChxdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmbiA9IHF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGZuKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0cnVlKTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gbmV4dFRpY2soZm4pIHtcbiAgICAgICAgICAgIHF1ZXVlLnB1c2goZm4pO1xuICAgICAgICAgICAgd2luZG93LnBvc3RNZXNzYWdlKCdwcm9jZXNzLXRpY2snLCAnKicpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0VGljayhmbikge1xuICAgICAgICBzZXRUaW1lb3V0KGZuLCAwKTtcbiAgICB9O1xufSkoKTtcblxucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59XG5cbi8vIFRPRE8oc2h0eWxtYW4pXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbiIsIi8qXHJcbiBDb3B5cmlnaHQgMjAxMyBEYW5pZWwgV2lydHogPGRjb2RlQGRjb2RlLmlvPlxyXG5cclxuIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuXHJcbiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcbiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAbGljZW5zZSBQcm90b0J1Zi5qcyAoYykgMjAxMyBEYW5pZWwgV2lydHogPGRjb2RlQGRjb2RlLmlvPlxyXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wXHJcbiAqIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Rjb2RlSU8vUHJvdG9CdWYuanMgZm9yIGRldGFpbHNcclxuICovXHJcbihmdW5jdGlvbihnbG9iYWwpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG5cclxuICAgIGZ1bmN0aW9uIGluaXQoQnl0ZUJ1ZmZlcikge1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgUHJvdG9CdWYgbmFtZXNwYWNlLlxyXG4gICAgICAgICAqIEBleHBvcnRzIFByb3RvQnVmXHJcbiAgICAgICAgICogQG5hbWVzcGFjZVxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgUHJvdG9CdWYgPSB7fTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUHJvdG9CdWYuanMgdmVyc2lvbi5cclxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAgICAgICAqIEBjb25zdFxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBQcm90b0J1Zi5WRVJTSU9OID0gXCIzLjIuMVwiO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBXaXJlIHR5cGVzLlxyXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZyxudW1iZXI+fVxyXG4gICAgICAgICAqIEBjb25zdFxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBQcm90b0J1Zi5XSVJFX1RZUEVTID0ge307XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFZhcmludCB3aXJlIHR5cGUuXHJcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUHJvdG9CdWYuV0lSRV9UWVBFUy5WQVJJTlQgPSAwO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBGaXhlZCA2NCBiaXRzIHdpcmUgdHlwZS5cclxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICAgICAqIEBjb25zdFxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBQcm90b0J1Zi5XSVJFX1RZUEVTLkJJVFM2NCA9IDE7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIExlbmd0aCBkZWxpbWl0ZWQgd2lyZSB0eXBlLlxyXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgICAgICogQGNvbnN0XHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFByb3RvQnVmLldJUkVfVFlQRVMuTERFTElNID0gMjtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU3RhcnQgZ3JvdXAgd2lyZSB0eXBlLlxyXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgICAgICogQGNvbnN0XHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFByb3RvQnVmLldJUkVfVFlQRVMuU1RBUlRHUk9VUCA9IDM7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEVuZCBncm91cCB3aXJlIHR5cGUuXHJcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAgICAgKiBAY29uc3RcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUHJvdG9CdWYuV0lSRV9UWVBFUy5FTkRHUk9VUCA9IDQ7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEZpeGVkIDMyIGJpdHMgd2lyZSB0eXBlLlxyXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgICAgICogQGNvbnN0XHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFByb3RvQnVmLldJUkVfVFlQRVMuQklUUzMyID0gNTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUGFja2FibGUgd2lyZSB0eXBlcy5cclxuICAgICAgICAgKiBAdHlwZSB7IUFycmF5LjxudW1iZXI+fVxyXG4gICAgICAgICAqIEBjb25zdFxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBQcm90b0J1Zi5QQUNLQUJMRV9XSVJFX1RZUEVTID0gW1xyXG4gICAgICAgICAgICBQcm90b0J1Zi5XSVJFX1RZUEVTLlZBUklOVCxcclxuICAgICAgICAgICAgUHJvdG9CdWYuV0lSRV9UWVBFUy5CSVRTNjQsXHJcbiAgICAgICAgICAgIFByb3RvQnVmLldJUkVfVFlQRVMuQklUUzMyXHJcbiAgICAgICAgXTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVHlwZXMuXHJcbiAgICAgICAgICogQGRpY3RcclxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcse25hbWU6IHN0cmluZywgd2lyZVR5cGU6IG51bWJlcn0+fVxyXG4gICAgICAgICAqIEBjb25zdFxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBQcm90b0J1Zi5UWVBFUyA9IHtcclxuICAgICAgICAgICAgLy8gQWNjb3JkaW5nIHRvIHRoZSBwcm90b2J1ZiBzcGVjLlxyXG4gICAgICAgICAgICBcImludDMyXCI6IHtcclxuICAgICAgICAgICAgICAgIG5hbWU6IFwiaW50MzJcIixcclxuICAgICAgICAgICAgICAgIHdpcmVUeXBlOiBQcm90b0J1Zi5XSVJFX1RZUEVTLlZBUklOVFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBcInVpbnQzMlwiOiB7XHJcbiAgICAgICAgICAgICAgICBuYW1lOiBcInVpbnQzMlwiLFxyXG4gICAgICAgICAgICAgICAgd2lyZVR5cGU6IFByb3RvQnVmLldJUkVfVFlQRVMuVkFSSU5UXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIFwic2ludDMyXCI6IHtcclxuICAgICAgICAgICAgICAgIG5hbWU6IFwic2ludDMyXCIsXHJcbiAgICAgICAgICAgICAgICB3aXJlVHlwZTogUHJvdG9CdWYuV0lSRV9UWVBFUy5WQVJJTlRcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgXCJpbnQ2NFwiOiB7XHJcbiAgICAgICAgICAgICAgICBuYW1lOiBcImludDY0XCIsXHJcbiAgICAgICAgICAgICAgICB3aXJlVHlwZTogUHJvdG9CdWYuV0lSRV9UWVBFUy5WQVJJTlRcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgXCJ1aW50NjRcIjoge1xyXG4gICAgICAgICAgICAgICAgbmFtZTogXCJ1aW50NjRcIixcclxuICAgICAgICAgICAgICAgIHdpcmVUeXBlOiBQcm90b0J1Zi5XSVJFX1RZUEVTLlZBUklOVFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBcInNpbnQ2NFwiOiB7XHJcbiAgICAgICAgICAgICAgICBuYW1lOiBcInNpbnQ2NFwiLFxyXG4gICAgICAgICAgICAgICAgd2lyZVR5cGU6IFByb3RvQnVmLldJUkVfVFlQRVMuVkFSSU5UXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIFwiYm9vbFwiOiB7XHJcbiAgICAgICAgICAgICAgICBuYW1lOiBcImJvb2xcIixcclxuICAgICAgICAgICAgICAgIHdpcmVUeXBlOiBQcm90b0J1Zi5XSVJFX1RZUEVTLlZBUklOVFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBcImRvdWJsZVwiOiB7XHJcbiAgICAgICAgICAgICAgICBuYW1lOiBcImRvdWJsZVwiLFxyXG4gICAgICAgICAgICAgICAgd2lyZVR5cGU6IFByb3RvQnVmLldJUkVfVFlQRVMuQklUUzY0XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIFwic3RyaW5nXCI6IHtcclxuICAgICAgICAgICAgICAgIG5hbWU6IFwic3RyaW5nXCIsXHJcbiAgICAgICAgICAgICAgICB3aXJlVHlwZTogUHJvdG9CdWYuV0lSRV9UWVBFUy5MREVMSU1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgXCJieXRlc1wiOiB7XHJcbiAgICAgICAgICAgICAgICBuYW1lOiBcImJ5dGVzXCIsXHJcbiAgICAgICAgICAgICAgICB3aXJlVHlwZTogUHJvdG9CdWYuV0lSRV9UWVBFUy5MREVMSU1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgXCJmaXhlZDMyXCI6IHtcclxuICAgICAgICAgICAgICAgIG5hbWU6IFwiZml4ZWQzMlwiLFxyXG4gICAgICAgICAgICAgICAgd2lyZVR5cGU6IFByb3RvQnVmLldJUkVfVFlQRVMuQklUUzMyXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIFwic2ZpeGVkMzJcIjoge1xyXG4gICAgICAgICAgICAgICAgbmFtZTogXCJzZml4ZWQzMlwiLFxyXG4gICAgICAgICAgICAgICAgd2lyZVR5cGU6IFByb3RvQnVmLldJUkVfVFlQRVMuQklUUzMyXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIFwiZml4ZWQ2NFwiOiB7XHJcbiAgICAgICAgICAgICAgICBuYW1lOiBcImZpeGVkNjRcIixcclxuICAgICAgICAgICAgICAgIHdpcmVUeXBlOiBQcm90b0J1Zi5XSVJFX1RZUEVTLkJJVFM2NFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBcInNmaXhlZDY0XCI6IHtcclxuICAgICAgICAgICAgICAgIG5hbWU6IFwic2ZpeGVkNjRcIixcclxuICAgICAgICAgICAgICAgIHdpcmVUeXBlOiBQcm90b0J1Zi5XSVJFX1RZUEVTLkJJVFM2NFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBcImZsb2F0XCI6IHtcclxuICAgICAgICAgICAgICAgIG5hbWU6IFwiZmxvYXRcIixcclxuICAgICAgICAgICAgICAgIHdpcmVUeXBlOiBQcm90b0J1Zi5XSVJFX1RZUEVTLkJJVFMzMlxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBcImVudW1cIjoge1xyXG4gICAgICAgICAgICAgICAgbmFtZTogXCJlbnVtXCIsXHJcbiAgICAgICAgICAgICAgICB3aXJlVHlwZTogUHJvdG9CdWYuV0lSRV9UWVBFUy5WQVJJTlRcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgXCJtZXNzYWdlXCI6IHtcclxuICAgICAgICAgICAgICAgIG5hbWU6IFwibWVzc2FnZVwiLFxyXG4gICAgICAgICAgICAgICAgd2lyZVR5cGU6IFByb3RvQnVmLldJUkVfVFlQRVMuTERFTElNXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIFwiZ3JvdXBcIjoge1xyXG4gICAgICAgICAgICAgICAgbmFtZTogXCJncm91cFwiLFxyXG4gICAgICAgICAgICAgICAgd2lyZVR5cGU6IFByb3RvQnVmLldJUkVfVFlQRVMuU1RBUlRHUk9VUFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTWluaW11bSBmaWVsZCBpZC5cclxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICAgICAqIEBjb25zdFxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBQcm90b0J1Zi5JRF9NSU4gPSAxO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBNYXhpbXVtIGZpZWxkIGlkLlxyXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgICAgICogQGNvbnN0XHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFByb3RvQnVmLklEX01BWCA9IDB4MUZGRkZGRkY7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEB0eXBlIHshZnVuY3Rpb24obmV3OiBCeXRlQnVmZmVyLCAuLi5bKl0pfVxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBQcm90b0J1Zi5CeXRlQnVmZmVyID0gQnl0ZUJ1ZmZlcjtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHR5cGUgez9mdW5jdGlvbihuZXc6IExvbmcsIC4uLlsqXSl9XHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFByb3RvQnVmLkxvbmcgPSBCeXRlQnVmZmVyLkxvbmcgfHwgbnVsbDtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSWYgc2V0IHRvIGB0cnVlYCwgZmllbGQgbmFtZXMgd2lsbCBiZSBjb252ZXJ0ZWQgZnJvbSB1bmRlcnNjb3JlIG5vdGF0aW9uIHRvIGNhbWVsIGNhc2UuIERlZmF1bHRzIHRvIGBmYWxzZWAuXHJcbiAgICAgICAgICogIE11c3QgYmUgc2V0IHByaW9yIHRvIHBhcnNpbmcuXHJcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFByb3RvQnVmLmNvbnZlcnRGaWVsZHNUb0NhbWVsQ2FzZSA9IGZhbHNlO1xyXG5cclxuICAgICAgICAvKipcbiAgICAgICAgICogQGFsaWFzIFByb3RvQnVmLlV0aWxcbiAgICAgICAgICogQGV4cG9zZVxuICAgICAgICAgKi9cbiAgICAgICAgUHJvdG9CdWYuVXRpbCA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgICAgICAvLyBPYmplY3QuY3JlYXRlIHBvbHlmaWxsXG4gICAgICAgICAgICAvLyByZWY6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RlL2RvY3MvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2NyZWF0ZVxuICAgICAgICAgICAgaWYgKCFPYmplY3QuY3JlYXRlKVxuICAgICAgICAgICAgICAgIC8qKiBAZXhwb3NlICovXG4gICAgICAgICAgICAgICAgT2JqZWN0LmNyZWF0ZSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCdPYmplY3QuY3JlYXRlIHBvbHlmaWxsIG9ubHkgYWNjZXB0cyB0aGUgZmlyc3QgcGFyYW1ldGVyLicpO1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBGKCkge31cbiAgICAgICAgICAgICAgICAgICAgRi5wcm90b3R5cGUgPSBvO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEYoKTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFByb3RvQnVmIHV0aWxpdGllcy5cbiAgICAgICAgICAgICAqIEBleHBvcnRzIFByb3RvQnVmLlV0aWxcbiAgICAgICAgICAgICAqIEBuYW1lc3BhY2VcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmFyIFV0aWwgPSB7fTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBGbGFnIGlmIHJ1bm5pbmcgaW4gbm9kZSAoZnMgaXMgYXZhaWxhYmxlKSBvciBub3QuXG4gICAgICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICAgICAqIEBjb25zdFxuICAgICAgICAgICAgICogQGV4cG9zZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBVdGlsLklTX05PREUgPSBmYWxzZTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlcmUgaXMgbm8gcmVsaWFibGUgd2F5IHRvIGRldGVjdCBub2RlLmpzIGFzIGFuIGVudmlyb25tZW50LCBzbyBvdXJcbiAgICAgICAgICAgICAgICAvLyBiZXN0IGJldCBpcyB0byBmZWF0dXJlLWRldGVjdCB3aGF0IHdlIGFjdHVhbGx5IG5lZWQuXG4gICAgICAgICAgICAgICAgVXRpbC5JU19OT0RFID1cbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHJlcXVpcmUoXCJmc1wiKS5yZWFkRmlsZVN5bmMgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHJlcXVpcmUoXCJwYXRoXCIpLnJlc29sdmUgPT09ICdmdW5jdGlvbic7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7fVxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIENvbnN0cnVjdHMgYSBYTUxIdHRwUmVxdWVzdCBvYmplY3QuXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHtYTUxIdHRwUmVxdWVzdH1cbiAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiBYTUxIdHRwUmVxdWVzdCBpcyBub3Qgc3VwcG9ydGVkXG4gICAgICAgICAgICAgKiBAZXhwb3NlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFV0aWwuWEhSID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgLy8gTm8gZGVwZW5kZW5jaWVzIHBsZWFzZSwgcmVmOiBodHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2pzL3htbGh0dHAuaHRtbFxuICAgICAgICAgICAgICAgIHZhciBYTUxIdHRwRmFjdG9yaWVzID0gW1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7cmV0dXJuIG5ldyBYTUxIdHRwUmVxdWVzdCgpfSxcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkge3JldHVybiBuZXcgQWN0aXZlWE9iamVjdChcIk1zeG1sMi5YTUxIVFRQXCIpfSxcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkge3JldHVybiBuZXcgQWN0aXZlWE9iamVjdChcIk1zeG1sMy5YTUxIVFRQXCIpfSxcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkge3JldHVybiBuZXcgQWN0aXZlWE9iamVjdChcIk1pY3Jvc29mdC5YTUxIVFRQXCIpfVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgLyoqIEB0eXBlIHs/WE1MSHR0cFJlcXVlc3R9ICovXG4gICAgICAgICAgICAgICAgdmFyIHhociA9IG51bGw7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaT0wO2k8WE1MSHR0cEZhY3Rvcmllcy5sZW5ndGg7aSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7IHhociA9IFhNTEh0dHBGYWN0b3JpZXNbaV0oKTsgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkgeyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCF4aHIpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiWE1MSHR0cFJlcXVlc3QgaXMgbm90IHN1cHBvcnRlZFwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geGhyO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBGZXRjaGVzIGEgcmVzb3VyY2UuXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBSZXNvdXJjZSBwYXRoXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKD9zdHJpbmcpPX0gY2FsbGJhY2sgQ2FsbGJhY2sgcmVjZWl2aW5nIHRoZSByZXNvdXJjZSdzIGNvbnRlbnRzLiBJZiBvbWl0dGVkIHRoZSByZXNvdXJjZSB3aWxsXG4gICAgICAgICAgICAgKiAgIGJlIGZldGNoZWQgc3luY2hyb25vdXNseS4gSWYgdGhlIHJlcXVlc3QgZmFpbGVkLCBjb250ZW50cyB3aWxsIGJlIG51bGwuXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/c3RyaW5nfHVuZGVmaW5lZH0gUmVzb3VyY2UgY29udGVudHMgaWYgY2FsbGJhY2sgaXMgb21pdHRlZCAobnVsbCBpZiB0aGUgcmVxdWVzdCBmYWlsZWQpLCBlbHNlIHVuZGVmaW5lZC5cbiAgICAgICAgICAgICAqIEBleHBvc2VcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgVXRpbC5mZXRjaCA9IGZ1bmN0aW9uKHBhdGgsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrICYmIHR5cGVvZiBjYWxsYmFjayAhPSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKFV0aWwuSVNfTk9ERSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmUoXCJmc1wiKS5yZWFkRmlsZShwYXRoLCBmdW5jdGlvbihlcnIsIGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKFwiXCIrZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXF1aXJlKFwiZnNcIikucmVhZEZpbGVTeW5jKHBhdGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB4aHIgPSBVdGlsLlhIUigpO1xuICAgICAgICAgICAgICAgICAgICB4aHIub3BlbignR0VUJywgcGF0aCwgY2FsbGJhY2sgPyB0cnVlIDogZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAvLyB4aHIuc2V0UmVxdWVzdEhlYWRlcignVXNlci1BZ2VudCcsICdYTUxIVFRQLzEuMCcpO1xuICAgICAgICAgICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignQWNjZXB0JywgJ3RleHQvcGxhaW4nKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB4aHIub3ZlcnJpZGVNaW1lVHlwZSA9PT0gJ2Z1bmN0aW9uJykgeGhyLm92ZXJyaWRlTWltZVR5cGUoJ3RleHQvcGxhaW4nKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHhoci5yZWFkeVN0YXRlICE9IDQpIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoLyogcmVtb3RlICovIHhoci5zdGF0dXMgPT0gMjAwIHx8IC8qIGxvY2FsICovICh4aHIuc3RhdHVzID09IDAgJiYgdHlwZW9mIHhoci5yZXNwb25zZVRleHQgPT09ICdzdHJpbmcnKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soeGhyLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPT0gNClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB4aHIuc2VuZChudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHhoci5zZW5kKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKC8qIHJlbW90ZSAqLyB4aHIuc3RhdHVzID09IDIwMCB8fCAvKiBsb2NhbCAqLyAoeGhyLnN0YXR1cyA9PSAwICYmIHR5cGVvZiB4aHIucmVzcG9uc2VUZXh0ID09PSAnc3RyaW5nJykpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHhoci5yZXNwb25zZVRleHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGVzdHMgaWYgYW4gb2JqZWN0IGlzIGFuIGFycmF5LlxuICAgICAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAgICAgKiBAcGFyYW0geyp9IG9iaiBPYmplY3QgdG8gdGVzdFxuICAgICAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgaXQgaXMgYW4gYXJyYXksIGVsc2UgZmFsc2VcbiAgICAgICAgICAgICAqIEBleHBvc2VcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgVXRpbC5pc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09IFwiW29iamVjdCBBcnJheV1cIjtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJldHVybiBVdGlsO1xuICAgICAgICB9KSgpO1xuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTGFuZ3VhZ2UgZXhwcmVzc2lvbnMuXHJcbiAgICAgICAgICogQGV4cG9ydHMgUHJvdG9CdWYuTGFuZ1xyXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZyxzdHJpbmd8UmVnRXhwPn1cclxuICAgICAgICAgKiBAbmFtZXNwYWNlXHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFByb3RvQnVmLkxhbmcgPSB7XHJcbiAgICAgICAgICAgIE9QRU46IFwie1wiLFxyXG4gICAgICAgICAgICBDTE9TRTogXCJ9XCIsXHJcbiAgICAgICAgICAgIE9QVE9QRU46IFwiW1wiLFxyXG4gICAgICAgICAgICBPUFRDTE9TRTogXCJdXCIsXHJcbiAgICAgICAgICAgIE9QVEVORDogXCIsXCIsXHJcbiAgICAgICAgICAgIEVRVUFMOiBcIj1cIixcclxuICAgICAgICAgICAgRU5EOiBcIjtcIixcclxuICAgICAgICAgICAgU1RSSU5HT1BFTjogJ1wiJyxcclxuICAgICAgICAgICAgU1RSSU5HQ0xPU0U6ICdcIicsXHJcbiAgICAgICAgICAgIFNUUklOR09QRU5fU1E6IFwiJ1wiLFxyXG4gICAgICAgICAgICBTVFJJTkdDTE9TRV9TUTogXCInXCIsXHJcbiAgICAgICAgICAgIENPUFRPUEVOOiAnKCcsXHJcbiAgICAgICAgICAgIENPUFRDTE9TRTogJyknLFxyXG4gICAgICAgICAgICBERUxJTTogL1tcXHNcXHtcXH09O1xcW1xcXSwnXCJcXChcXCldL2csXHJcbiAgICAgICAgICAgIC8vIEtFWVdPUkQ6IC9eKD86cGFja2FnZXxvcHRpb258aW1wb3J0fG1lc3NhZ2V8ZW51bXxleHRlbmR8c2VydmljZXxzeW50YXh8ZXh0ZW5zaW9uc3xncm91cCkkLyxcclxuICAgICAgICAgICAgUlVMRTogL14oPzpyZXF1aXJlZHxvcHRpb25hbHxyZXBlYXRlZCkkLyxcclxuICAgICAgICAgICAgVFlQRTogL14oPzpkb3VibGV8ZmxvYXR8aW50MzJ8dWludDMyfHNpbnQzMnxpbnQ2NHx1aW50NjR8c2ludDY0fGZpeGVkMzJ8c2ZpeGVkMzJ8Zml4ZWQ2NHxzZml4ZWQ2NHxib29sfHN0cmluZ3xieXRlcykkLyxcclxuICAgICAgICAgICAgTkFNRTogL15bYS16QS1aX11bYS16QS1aXzAtOV0qJC8sXHJcbiAgICAgICAgICAgIFRZUEVERUY6IC9eW2EtekEtWl1bYS16QS1aXzAtOV0qJC8sXHJcbiAgICAgICAgICAgIFRZUEVSRUY6IC9eKD86XFwuP1thLXpBLVpfXVthLXpBLVpfMC05XSopKyQvLFxyXG4gICAgICAgICAgICBGUVRZUEVSRUY6IC9eKD86XFwuW2EtekEtWl1bYS16QS1aXzAtOV0qKSskLyxcclxuICAgICAgICAgICAgTlVNQkVSOiAvXi0/KD86WzEtOV1bMC05XSp8MHwweFswLTlhLWZBLUZdK3wwWzAtN10rfChbMC05XSpcXC5bMC05XSsoW0VlXVsrLV0/WzAtOV0rKT8pKSQvLFxyXG4gICAgICAgICAgICBOVU1CRVJfREVDOiAvXig/OlsxLTldWzAtOV0qfDApJC8sXHJcbiAgICAgICAgICAgIE5VTUJFUl9IRVg6IC9eMHhbMC05YS1mQS1GXSskLyxcclxuICAgICAgICAgICAgTlVNQkVSX09DVDogL14wWzAtN10rJC8sXHJcbiAgICAgICAgICAgIE5VTUJFUl9GTFQ6IC9eWzAtOV0qXFwuWzAtOV0rKFtFZV1bKy1dP1swLTldKyk/JC8sXHJcbiAgICAgICAgICAgIElEOiAvXig/OlsxLTldWzAtOV0qfDB8MHhbMC05YS1mQS1GXSt8MFswLTddKykkLyxcclxuICAgICAgICAgICAgTkVHSUQ6IC9eXFwtPyg/OlsxLTldWzAtOV0qfDB8MHhbMC05YS1mQS1GXSt8MFswLTddKykkLyxcclxuICAgICAgICAgICAgV0hJVEVTUEFDRTogL1xccy8sXHJcbiAgICAgICAgICAgIFNUUklORzogL1snXCJdKFteJ1wiXFxcXF0qKFxcXFwuW15cIlxcXFxdKikqKVsnXCJdL2csXHJcbiAgICAgICAgICAgIEJPT0w6IC9eKD86dHJ1ZXxmYWxzZSkkL2lcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAYWxpYXMgUHJvdG9CdWYuRG90UHJvdG9cclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUHJvdG9CdWYuRG90UHJvdG8gPSAoZnVuY3Rpb24oUHJvdG9CdWYsIExhbmcpIHtcclxuICAgICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVXRpbGl0aWVzIHRvIHBhcnNlIC5wcm90byBmaWxlcy5cclxuICAgICAgICAgICAgICogQGV4cG9ydHMgUHJvdG9CdWYuRG90UHJvdG9cclxuICAgICAgICAgICAgICogQG5hbWVzcGFjZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdmFyIERvdFByb3RvID0ge307XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQ29uc3RydWN0cyBhIG5ldyBUb2tlbml6ZXIuXHJcbiAgICAgICAgICAgICAqIEBleHBvcnRzIFByb3RvQnVmLkRvdFByb3RvLlRva2VuaXplclxyXG4gICAgICAgICAgICAgKiBAY2xhc3MgcHJvdG8gdG9rZW5pemVyXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm90byBQcm90byB0byB0b2tlbml6ZVxyXG4gICAgICAgICAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHZhciBUb2tlbml6ZXIgPSBmdW5jdGlvbihwcm90bykge1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogU291cmNlIHRvIHBhcnNlLlxyXG4gICAgICAgICAgICAgICAgICogQHR5cGUge3N0cmluZ31cclxuICAgICAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zb3VyY2UgPSBcIlwiK3Byb3RvOyAvLyBJbiBjYXNlIGl0J3MgYSBidWZmZXJcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEN1cnJlbnQgaW5kZXguXHJcbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLmluZGV4ID0gMDtcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEN1cnJlbnQgbGluZS5cclxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMubGluZSA9IDE7XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBTdGFja2VkIHZhbHVlcy5cclxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtBcnJheX1cclxuICAgICAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGFjayA9IFtdO1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogV2hldGhlciBjdXJyZW50bHkgcmVhZGluZyBhIHN0cmluZyBvciBub3QuXHJcbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZWFkaW5nU3RyaW5nID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBXaGF0ZXZlciBjaGFyYWN0ZXIgZW5kcyB0aGUgc3RyaW5nLiBFaXRoZXIgYSBzaW5nbGUgb3IgZG91YmxlIHF1b3RlIGNoYXJhY3Rlci5cclxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICAgICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuc3RyaW5nRW5kc1dpdGggPSBMYW5nLlNUUklOR0NMT1NFO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFJlYWRzIGEgc3RyaW5nIGJlZ2lubmluZyBhdCB0aGUgY3VycmVudCBpbmRleC5cclxuICAgICAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgc3RyaW5nXHJcbiAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiBpdCdzIG5vdCBhIHZhbGlkIHN0cmluZ1xyXG4gICAgICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgVG9rZW5pemVyLnByb3RvdHlwZS5fcmVhZFN0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgTGFuZy5TVFJJTkcubGFzdEluZGV4ID0gdGhpcy5pbmRleC0xOyAvLyBJbmNsdWRlIHRoZSBvcGVuIHF1b3RlXHJcbiAgICAgICAgICAgICAgICB2YXIgbWF0Y2g7XHJcbiAgICAgICAgICAgICAgICBpZiAoKG1hdGNoID0gTGFuZy5TVFJJTkcuZXhlYyh0aGlzLnNvdXJjZSkpICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHMgPSBtYXRjaFsxXTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmluZGV4ID0gTGFuZy5TVFJJTkcubGFzdEluZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhY2sucHVzaCh0aGlzLnN0cmluZ0VuZHNXaXRoKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCBzdHJpbmcgdmFsdWUgYXQgbGluZSBcIit0aGlzLmxpbmUrXCIsIGluZGV4IFwiK3RoaXMuaW5kZXgpO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdldHMgdGhlIG5leHQgdG9rZW4gYW5kIGFkdmFuY2VzIGJ5IG9uZS5cclxuICAgICAgICAgICAgICogQHJldHVybiB7P3N0cmluZ30gVG9rZW4gb3IgYG51bGxgIG9uIEVPRlxyXG4gICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgaXQncyBub3QgYSB2YWxpZCBwcm90byBmaWxlXHJcbiAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFRva2VuaXplci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhY2subGVuZ3RoID4gMClcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdGFjay5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaW5kZXggPj0gdGhpcy5zb3VyY2UubGVuZ3RoKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsOyAvLyBObyBtb3JlIHRva2Vuc1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmVhZGluZ1N0cmluZykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZGluZ1N0cmluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZWFkU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVwZWF0LCBsYXN0O1xyXG4gICAgICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlcGVhdCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFN0cmlwIHdoaXRlIHNwYWNlc1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChMYW5nLldISVRFU1BBQ0UudGVzdChsYXN0ID0gdGhpcy5zb3VyY2UuY2hhckF0KHRoaXMuaW5kZXgpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmluZGV4Kys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsYXN0ID09PSBcIlxcblwiKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5saW5lKys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmluZGV4ID09PSB0aGlzLnNvdXJjZS5sZW5ndGgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gU3RyaXAgY29tbWVudHNcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zb3VyY2UuY2hhckF0KHRoaXMuaW5kZXgpID09PSAnLycpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc291cmNlLmNoYXJBdCgrK3RoaXMuaW5kZXgpID09PSAnLycpIHsgLy8gU2luZ2xlIGxpbmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICh0aGlzLnNvdXJjZS5jaGFyQXQodGhpcy5pbmRleCkgIT09IFwiXFxuXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmluZGV4Kys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaW5kZXggPT0gdGhpcy5zb3VyY2UubGVuZ3RoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZXgrKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGluZSsrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVwZWF0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnNvdXJjZS5jaGFyQXQodGhpcy5pbmRleCkgPT09ICcqJykgeyAvKiBCbG9jayAqL1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdCA9ICcnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGxhc3QrKGxhc3Q9dGhpcy5zb3VyY2UuY2hhckF0KHRoaXMuaW5kZXgpKSAhPT0gJyovJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZXgrKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGFzdCA9PT0gXCJcXG5cIilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5saW5lKys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaW5kZXggPT09IHRoaXMuc291cmNlLmxlbmd0aClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmluZGV4Kys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXBlYXQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSW52YWxpZCBjb21tZW50IGF0IGxpbmUgXCIrdGhpcy5saW5lK1wiOiAvXCIrdGhpcy5zb3VyY2UuY2hhckF0KHRoaXMuaW5kZXgpK1wiICgnLycgb3IgJyonIGV4cGVjdGVkKVwiKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IHdoaWxlIChyZXBlYXQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaW5kZXggPT09IHRoaXMuc291cmNlLmxlbmd0aCkgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gUmVhZCB0aGUgbmV4dCB0b2tlblxyXG4gICAgICAgICAgICAgICAgdmFyIGVuZCA9IHRoaXMuaW5kZXg7XHJcbiAgICAgICAgICAgICAgICBMYW5nLkRFTElNLmxhc3RJbmRleCA9IDA7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGVsaW0gPSBMYW5nLkRFTElNLnRlc3QodGhpcy5zb3VyY2UuY2hhckF0KGVuZCkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFkZWxpbSkge1xyXG4gICAgICAgICAgICAgICAgICAgICsrZW5kO1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlKGVuZCA8IHRoaXMuc291cmNlLmxlbmd0aCAmJiAhTGFuZy5ERUxJTS50ZXN0KHRoaXMuc291cmNlLmNoYXJBdChlbmQpKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kKys7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2VcclxuICAgICAgICAgICAgICAgICAgICArK2VuZDtcclxuICAgICAgICAgICAgICAgIHZhciB0b2tlbiA9IHRoaXMuc291cmNlLnN1YnN0cmluZyh0aGlzLmluZGV4LCB0aGlzLmluZGV4ID0gZW5kKTtcclxuICAgICAgICAgICAgICAgIGlmICh0b2tlbiA9PT0gTGFuZy5TVFJJTkdPUEVOKVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZGluZ1N0cmluZyA9IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdHJpbmdFbmRzV2l0aCA9IExhbmcuU1RSSU5HQ0xPU0U7XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0b2tlbiA9PT0gTGFuZy5TVFJJTkdPUEVOX1NRKVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZGluZ1N0cmluZyA9IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdHJpbmdFbmRzV2l0aCA9IExhbmcuU1RSSU5HQ0xPU0VfU1E7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW47XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUGVla3MgZm9yIHRoZSBuZXh0IHRva2VuLlxyXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/c3RyaW5nfSBUb2tlbiBvciBgbnVsbGAgb24gRU9GXHJcbiAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiBpdCdzIG5vdCBhIHZhbGlkIHByb3RvIGZpbGVcclxuICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgVG9rZW5pemVyLnByb3RvdHlwZS5wZWVrID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGFjay5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLm5leHQoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW4gPT09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhY2sucHVzaCh0b2tlbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdGFja1swXTtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgb2JqZWN0LlxyXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFN0cmluZyByZXByZXNlbnRhdGlvbiBhcyBvZiBcIlRva2VuaXplcihpbmRleC9sZW5ndGgpXCJcclxuICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgVG9rZW5pemVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiVG9rZW5pemVyKFwiK3RoaXMuaW5kZXgrXCIvXCIrdGhpcy5zb3VyY2UubGVuZ3RoK1wiIGF0IGxpbmUgXCIrdGhpcy5saW5lK1wiKVwiO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEBhbGlhcyBQcm90b0J1Zi5Eb3RQcm90by5Ub2tlbml6ZXJcclxuICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgRG90UHJvdG8uVG9rZW5pemVyID0gVG9rZW5pemVyO1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgUGFyc2VyLlxyXG4gICAgICAgICAgICAgKiBAZXhwb3J0cyBQcm90b0J1Zi5Eb3RQcm90by5QYXJzZXJcclxuICAgICAgICAgICAgICogQGNsYXNzIHByb3RvIHBhcnNlclxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvdG8gUHJvdG9jb2wgc291cmNlXHJcbiAgICAgICAgICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdmFyIFBhcnNlciA9IGZ1bmN0aW9uKHByb3RvKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBUb2tlbml6ZXIuXHJcbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7UHJvdG9CdWYuRG90UHJvdG8uVG9rZW5pemVyfVxyXG4gICAgICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLnRuID0gbmV3IFRva2VuaXplcihwcm90byk7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUnVucyB0aGUgcGFyc2VyLlxyXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHt7cGFja2FnZTogc3RyaW5nfG51bGwsIG1lc3NhZ2VzOiBBcnJheS48b2JqZWN0PiwgZW51bXM6IEFycmF5LjxvYmplY3Q+LCBpbXBvcnRzOiBBcnJheS48c3RyaW5nPiwgb3B0aW9uczogb2JqZWN0PHN0cmluZywqPn19XHJcbiAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgc291cmNlIGNhbm5vdCBiZSBwYXJzZWRcclxuICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRvcExldmVsID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIltST09UXVwiLCAvLyB0ZW1wb3JhcnlcclxuICAgICAgICAgICAgICAgICAgICBcInBhY2thZ2VcIjogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICBcIm1lc3NhZ2VzXCI6IFtdLFxyXG4gICAgICAgICAgICAgICAgICAgIFwiZW51bXNcIjogW10sXHJcbiAgICAgICAgICAgICAgICAgICAgXCJpbXBvcnRzXCI6IFtdLFxyXG4gICAgICAgICAgICAgICAgICAgIFwib3B0aW9uc1wiOiB7fSxcclxuICAgICAgICAgICAgICAgICAgICBcInNlcnZpY2VzXCI6IFtdXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgdmFyIHRva2VuLCBoZWFkZXIgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUodG9rZW4gPSB0aGlzLnRuLm5leHQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodG9rZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAncGFja2FnZSc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWhlYWRlciB8fCB0b3BMZXZlbFtcInBhY2thZ2VcIl0gIT09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIHBhY2thZ2UgYXQgbGluZSBcIit0aGlzLnRuLmxpbmUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wTGV2ZWxbXCJwYWNrYWdlXCJdID0gdGhpcy5fcGFyc2VQYWNrYWdlKHRva2VuKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdpbXBvcnQnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFoZWFkZXIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIGltcG9ydCBhdCBsaW5lIFwiK3RoaXMudG4ubGluZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3BMZXZlbC5pbXBvcnRzLnB1c2godGhpcy5fcGFyc2VJbXBvcnQodG9rZW4pKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdtZXNzYWdlJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhcnNlTWVzc2FnZSh0b3BMZXZlbCwgbnVsbCwgdG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnZW51bSc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYXJzZUVudW0odG9wTGV2ZWwsIHRva2VuKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlciA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ29wdGlvbic6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWhlYWRlcilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIklsbGVnYWwgb3B0aW9uIGF0IGxpbmUgXCIrdGhpcy50bi5saW5lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhcnNlT3B0aW9uKHRvcExldmVsLCB0b2tlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnc2VydmljZSc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYXJzZVNlcnZpY2UodG9wTGV2ZWwsIHRva2VuKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdleHRlbmQnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFyc2VFeHRlbmQodG9wTGV2ZWwsIHRva2VuKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdzeW50YXgnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFyc2VJZ25vcmVkU3RhdGVtZW50KHRvcExldmVsLCB0b2tlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCB0b2tlbiBhdCBsaW5lIFwiK3RoaXMudG4ubGluZStcIjogXCIrdG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0b3BMZXZlbFtcIm5hbWVcIl07XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9wTGV2ZWw7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUGFyc2VzIGEgbnVtYmVyIHZhbHVlLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsIE51bWJlciB2YWx1ZSB0byBwYXJzZVxyXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IE51bWJlclxyXG4gICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIG51bWJlciB2YWx1ZSBpcyBpbnZhbGlkXHJcbiAgICAgICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBQYXJzZXIucHJvdG90eXBlLl9wYXJzZU51bWJlciA9IGZ1bmN0aW9uKHZhbCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHNpZ24gPSAxO1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhbC5jaGFyQXQoMCkgPT0gJy0nKVxyXG4gICAgICAgICAgICAgICAgICAgIHNpZ24gPSAtMSxcclxuICAgICAgICAgICAgICAgICAgICB2YWwgPSB2YWwuc3Vic3RyaW5nKDEpO1xyXG4gICAgICAgICAgICAgICAgaWYgKExhbmcuTlVNQkVSX0RFQy50ZXN0KHZhbCkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpZ24qcGFyc2VJbnQodmFsLCAxMCk7XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChMYW5nLk5VTUJFUl9IRVgudGVzdCh2YWwpKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzaWduKnBhcnNlSW50KHZhbC5zdWJzdHJpbmcoMiksIDE2KTtcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKExhbmcuTlVNQkVSX09DVC50ZXN0KHZhbCkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpZ24qcGFyc2VJbnQodmFsLnN1YnN0cmluZygxKSwgOCk7XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChMYW5nLk5VTUJFUl9GTFQudGVzdCh2YWwpKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzaWduKnBhcnNlRmxvYXQodmFsKTtcclxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCBudW1iZXIgYXQgbGluZSBcIit0aGlzLnRuLmxpbmUrXCI6IFwiKyhzaWduIDwgMCA/ICctJyA6ICcnKSt2YWwpO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFBhcnNlcyBhbiBJRCB2YWx1ZS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbCBJRCB2YWx1ZSB0byBwYXJzZVxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBuZWcgV2hldGhlciB0aGUgSUQgbWF5IGJlIG5lZ2F0aXZlLCBkZWZhdWx0cyB0byBgZmFsc2VgXHJcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IElEXHJcbiAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgSUQgdmFsdWUgaXMgaW52YWxpZFxyXG4gICAgICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgUGFyc2VyLnByb3RvdHlwZS5fcGFyc2VJZCA9IGZ1bmN0aW9uKHZhbCwgbmVnKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaWQgPSAtMTtcclxuICAgICAgICAgICAgICAgIHZhciBzaWduID0gMTtcclxuICAgICAgICAgICAgICAgIGlmICh2YWwuY2hhckF0KDApID09ICctJylcclxuICAgICAgICAgICAgICAgICAgICBzaWduID0gLTEsXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gdmFsLnN1YnN0cmluZygxKTtcclxuICAgICAgICAgICAgICAgIGlmIChMYW5nLk5VTUJFUl9ERUMudGVzdCh2YWwpKVxyXG4gICAgICAgICAgICAgICAgICAgIGlkID0gcGFyc2VJbnQodmFsKTtcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKExhbmcuTlVNQkVSX0hFWC50ZXN0KHZhbCkpXHJcbiAgICAgICAgICAgICAgICAgICAgaWQgPSBwYXJzZUludCh2YWwuc3Vic3RyaW5nKDIpLCAxNik7XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChMYW5nLk5VTUJFUl9PQ1QudGVzdCh2YWwpKVxyXG4gICAgICAgICAgICAgICAgICAgIGlkID0gcGFyc2VJbnQodmFsLnN1YnN0cmluZygxKSwgOCk7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIElEIGF0IGxpbmUgXCIrdGhpcy50bi5saW5lK1wiOiBcIisoc2lnbiA8IDAgPyAnLScgOiAnJykrdmFsKTtcclxuICAgICAgICAgICAgICAgIGlkID0gKHNpZ24qaWQpfDA7IC8vIEZvcmNlIHRvIDMyYml0XHJcbiAgICAgICAgICAgICAgICBpZiAoIW5lZyAmJiBpZCA8IDApXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIElEIGF0IGxpbmUgXCIrdGhpcy50bi5saW5lK1wiOiBcIisoc2lnbiA8IDAgPyAnLScgOiAnJykrdmFsKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpZDtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBQYXJzZXMgdGhlIHBhY2thZ2UgZGVmaW5pdGlvbi5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHRva2VuIEluaXRpYWwgdG9rZW5cclxuICAgICAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBQYWNrYWdlIG5hbWVcclxuICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYWNrYWdlIGRlZmluaXRpb24gY2Fubm90IGJlIHBhcnNlZFxyXG4gICAgICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgUGFyc2VyLnByb3RvdHlwZS5fcGFyc2VQYWNrYWdlID0gZnVuY3Rpb24odG9rZW4pIHtcclxuICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy50bi5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIUxhbmcuVFlQRVJFRi50ZXN0KHRva2VuKSlcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIklsbGVnYWwgcGFja2FnZSBhdCBsaW5lIFwiK3RoaXMudG4ubGluZStcIjogXCIrdG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgdmFyIHBrZyA9IHRva2VuO1xyXG4gICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRuLm5leHQoKTtcclxuICAgICAgICAgICAgICAgIGlmICh0b2tlbiAhPSBMYW5nLkVORClcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIklsbGVnYWwgZW5kIG9mIHBhY2thZ2UgYXQgbGluZSBcIit0aGlzLnRuLmxpbmUrXCI6IFwiK3Rva2VuK1wiICgnXCIrTGFuZy5FTkQrXCInIGV4cGVjdGVkKVwiKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwa2c7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUGFyc2VzIGFuIGltcG9ydCBkZWZpbml0aW9uLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdG9rZW4gSW5pdGlhbCB0b2tlblxyXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IEltcG9ydCBmaWxlIG5hbWVcclxuICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBpbXBvcnQgZGVmaW5pdGlvbiBjYW5ub3QgYmUgcGFyc2VkXHJcbiAgICAgICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBQYXJzZXIucHJvdG90eXBlLl9wYXJzZUltcG9ydCA9IGZ1bmN0aW9uKHRva2VuKSB7XHJcbiAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMudG4ubmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRva2VuID09PSBcInB1YmxpY1wiKVxyXG4gICAgICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy50bi5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4gIT09IExhbmcuU1RSSU5HT1BFTiAmJiB0b2tlbiAhPT0gTGFuZy5TVFJJTkdPUEVOX1NRKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCBpbXBvcnQgYXQgbGluZSBcIit0aGlzLnRuLmxpbmUrXCI6IFwiK3Rva2VuK1wiICgnXCIrTGFuZy5TVFJJTkdPUEVOK1wiJyBvciAnXCIrTGFuZy5TVFJJTkdPUEVOX1NRK1wiJyBleHBlY3RlZClcIik7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW1wb3J0ZWQgPSB0aGlzLnRuLm5leHQoKTtcclxuICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy50bi5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4gIT09IHRoaXMudG4uc3RyaW5nRW5kc1dpdGgpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIGltcG9ydCBhdCBsaW5lIFwiK3RoaXMudG4ubGluZStcIjogXCIrdG9rZW4rXCIgKCdcIit0aGlzLnRuLnN0cmluZ0VuZHNXaXRoK1wiJyBleHBlY3RlZClcIik7XHJcbiAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMudG4ubmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRva2VuICE9PSBMYW5nLkVORClcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIklsbGVnYWwgaW1wb3J0IGF0IGxpbmUgXCIrdGhpcy50bi5saW5lK1wiOiBcIit0b2tlbitcIiAoJ1wiK0xhbmcuRU5EK1wiJyBleHBlY3RlZClcIik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaW1wb3J0ZWQ7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUGFyc2VzIGEgbmFtZXNwYWNlIG9wdGlvbi5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmVudCBQYXJlbnQgZGVmaW5pdGlvblxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdG9rZW4gSW5pdGlhbCB0b2tlblxyXG4gICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIG9wdGlvbiBjYW5ub3QgYmUgcGFyc2VkXHJcbiAgICAgICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBQYXJzZXIucHJvdG90eXBlLl9wYXJzZU9wdGlvbiA9IGZ1bmN0aW9uKHBhcmVudCwgdG9rZW4pIHtcclxuICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy50bi5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgY3VzdG9tID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4gPT0gTGFuZy5DT1BUT1BFTilcclxuICAgICAgICAgICAgICAgICAgICBjdXN0b20gPSB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy50bi5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIUxhbmcuVFlQRVJFRi50ZXN0KHRva2VuKSlcclxuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBjYW4gYWxsb3cgb3B0aW9ucyBvZiB0aGUgZm9ybSBnb29nbGUucHJvdG9idWYuKiBzaW5jZSB0aGV5IHdpbGwganVzdCBnZXQgaWdub3JlZCBhbnl3YXlzXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEvZ29vZ2xlXFwucHJvdG9idWZcXC4vLnRlc3QodG9rZW4pKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIklsbGVnYWwgb3B0aW9uIGluIG1lc3NhZ2UgXCIrcGFyZW50Lm5hbWUrXCIgYXQgbGluZSBcIit0aGlzLnRuLmxpbmUrXCI6IFwiK3Rva2VuKTtcclxuICAgICAgICAgICAgICAgIHZhciBuYW1lID0gdG9rZW47XHJcbiAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMudG4ubmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGN1c3RvbSkgeyAvLyAobXlfbWV0aG9kX29wdGlvbikuZm9vLCAobXlfbWV0aG9kX29wdGlvbiksIHNvbWVfbWV0aG9kX29wdGlvbiwgKGZvby5teV9vcHRpb24pLmJhclxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbiAhPT0gTGFuZy5DT1BUQ0xPU0UpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCBvcHRpb24gaW4gbWVzc2FnZSBcIitwYXJlbnQubmFtZStcIiwgb3B0aW9uIFwiK25hbWUrXCIgYXQgbGluZSBcIit0aGlzLnRuLmxpbmUrXCI6IFwiK3Rva2VuK1wiICgnXCIrTGFuZy5DT1BUQ0xPU0UrXCInIGV4cGVjdGVkKVwiKTtcclxuICAgICAgICAgICAgICAgICAgICBuYW1lID0gJygnK25hbWUrJyknO1xyXG4gICAgICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy50bi5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKExhbmcuRlFUWVBFUkVGLnRlc3QodG9rZW4pKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lICs9IHRva2VuLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMudG4ubmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHRva2VuICE9PSBMYW5nLkVRVUFMKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCBvcHRpb24gb3BlcmF0b3IgaW4gbWVzc2FnZSBcIitwYXJlbnQubmFtZStcIiwgb3B0aW9uIFwiK25hbWUrXCIgYXQgbGluZSBcIit0aGlzLnRuLmxpbmUrXCI6IFwiK3Rva2VuK1wiICgnXCIrTGFuZy5FUVVBTCtcIicgZXhwZWN0ZWQpXCIpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRuLm5leHQoKTtcclxuICAgICAgICAgICAgICAgIGlmICh0b2tlbiA9PT0gTGFuZy5TVFJJTkdPUEVOIHx8IHRva2VuID09PSBMYW5nLlNUUklOR09QRU5fU1EpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMudG4ubmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy50bi5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuICE9PSB0aGlzLnRuLnN0cmluZ0VuZHNXaXRoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIklsbGVnYWwgZW5kIG9mIG9wdGlvbiB2YWx1ZSBpbiBtZXNzYWdlIFwiK3BhcmVudC5uYW1lK1wiLCBvcHRpb24gXCIrbmFtZStcIiBhdCBsaW5lIFwiK3RoaXMudG4ubGluZStcIjogXCIrdG9rZW4rXCIgKCdcIit0aGlzLnRuLnN0cmluZ0VuZHNXaXRoK1wiJyBleHBlY3RlZClcIik7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChMYW5nLk5VTUJFUi50ZXN0KHRva2VuKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLl9wYXJzZU51bWJlcih0b2tlbiwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoTGFuZy5CT09MLnRlc3QodG9rZW4pKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRva2VuID09PSAndHJ1ZSc7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoTGFuZy5UWVBFUkVGLnRlc3QodG9rZW4pKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRva2VuO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIG9wdGlvbiB2YWx1ZSBpbiBtZXNzYWdlIFwiK3BhcmVudC5uYW1lK1wiLCBvcHRpb24gXCIrbmFtZStcIiBhdCBsaW5lIFwiK3RoaXMudG4ubGluZStcIjogXCIrdG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRuLm5leHQoKTtcclxuICAgICAgICAgICAgICAgIGlmICh0b2tlbiAhPT0gTGFuZy5FTkQpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIGVuZCBvZiBvcHRpb24gaW4gbWVzc2FnZSBcIitwYXJlbnQubmFtZStcIiwgb3B0aW9uIFwiK25hbWUrXCIgYXQgbGluZSBcIit0aGlzLnRuLmxpbmUrXCI6IFwiK3Rva2VuK1wiICgnXCIrTGFuZy5FTkQrXCInIGV4cGVjdGVkKVwiKTtcclxuICAgICAgICAgICAgICAgIHBhcmVudFtcIm9wdGlvbnNcIl1bbmFtZV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBQYXJzZXMgYW4gaWdub3JlZCBzdGF0ZW1lbnQgb2YgdGhlIGZvcm0gWydrZXl3b3JkJywgLi4uLCAnOyddLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyZW50IFBhcmVudCBkZWZpbml0aW9uXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXl3b3JkIEluaXRpYWwgdG9rZW5cclxuICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBkaXJlY3RpdmUgY2Fubm90IGJlIHBhcnNlZFxyXG4gICAgICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgUGFyc2VyLnByb3RvdHlwZS5fcGFyc2VJZ25vcmVkU3RhdGVtZW50ID0gZnVuY3Rpb24ocGFyZW50LCBrZXl3b3JkKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdG9rZW47XHJcbiAgICAgICAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRuLm5leHQoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW4gPT09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiVW5leHBlY3RlZCBFT0YgaW4gXCIrcGFyZW50Lm5hbWUrXCIsIFwiK2tleXdvcmQrXCIgKGlnbm9yZWQpIGF0IGxpbmUgXCIrdGhpcy50bi5saW5lKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW4gPT09IExhbmcuRU5EKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH0gd2hpbGUgKHRydWUpO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFBhcnNlcyBhIHNlcnZpY2UgZGVmaW5pdGlvbi5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmVudCBQYXJlbnQgZGVmaW5pdGlvblxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdG9rZW4gSW5pdGlhbCB0b2tlblxyXG4gICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHNlcnZpY2UgY2Fubm90IGJlIHBhcnNlZFxyXG4gICAgICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgUGFyc2VyLnByb3RvdHlwZS5fcGFyc2VTZXJ2aWNlID0gZnVuY3Rpb24ocGFyZW50LCB0b2tlbikge1xyXG4gICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRuLm5leHQoKTtcclxuICAgICAgICAgICAgICAgIGlmICghTGFuZy5OQU1FLnRlc3QodG9rZW4pKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCBzZXJ2aWNlIG5hbWUgYXQgbGluZSBcIit0aGlzLnRuLmxpbmUrXCI6IFwiK3Rva2VuKTtcclxuICAgICAgICAgICAgICAgIHZhciBuYW1lID0gdG9rZW47XHJcbiAgICAgICAgICAgICAgICB2YXIgc3ZjID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIFwibmFtZVwiOiBuYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgIFwicnBjXCI6IHt9LFxyXG4gICAgICAgICAgICAgICAgICAgIFwib3B0aW9uc1wiOiB7fVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy50bi5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4gIT09IExhbmcuT1BFTilcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIklsbGVnYWwgT1BFTiBhZnRlciBzZXJ2aWNlIFwiK25hbWUrXCIgYXQgbGluZSBcIit0aGlzLnRuLmxpbmUrXCI6IFwiK3Rva2VuK1wiICgnXCIrTGFuZy5PUEVOK1wiJyBleHBlY3RlZClcIik7XHJcbiAgICAgICAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRuLm5leHQoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW4gPT09IFwib3B0aW9uXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhcnNlT3B0aW9uKHN2YywgdG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRva2VuID09PSAncnBjJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFyc2VTZXJ2aWNlUlBDKHN2YywgdG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRva2VuICE9PSBMYW5nLkNMT1NFKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIklsbGVnYWwgdHlwZSBmb3Igc2VydmljZSBcIituYW1lK1wiIGF0IGxpbmUgXCIrdGhpcy50bi5saW5lK1wiOiBcIit0b2tlbik7XHJcbiAgICAgICAgICAgICAgICB9IHdoaWxlICh0b2tlbiAhPT0gTGFuZy5DTE9TRSk7XHJcbiAgICAgICAgICAgICAgICBwYXJlbnRbXCJzZXJ2aWNlc1wiXS5wdXNoKHN2Yyk7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUGFyc2VzIGEgUlBDIHNlcnZpY2UgZGVmaW5pdGlvbiBvZiB0aGUgZm9ybSBbJ3JwYycsIG5hbWUsIChyZXF1ZXN0KSwgJ3JldHVybnMnLCAocmVzcG9uc2UpXS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHN2YyBQYXJlbnQgZGVmaW5pdGlvblxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdG9rZW4gSW5pdGlhbCB0b2tlblxyXG4gICAgICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgUGFyc2VyLnByb3RvdHlwZS5fcGFyc2VTZXJ2aWNlUlBDID0gZnVuY3Rpb24oc3ZjLCB0b2tlbikge1xyXG4gICAgICAgICAgICAgICAgdmFyIHR5cGUgPSB0b2tlbjtcclxuICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy50bi5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIUxhbmcuTkFNRS50ZXN0KHRva2VuKSlcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIklsbGVnYWwgUlBDIG1ldGhvZCBuYW1lIGluIHNlcnZpY2UgXCIrc3ZjW1wibmFtZVwiXStcIiBhdCBsaW5lIFwiK3RoaXMudG4ubGluZStcIjogXCIrdG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgdmFyIG5hbWUgPSB0b2tlbjtcclxuICAgICAgICAgICAgICAgIHZhciBtZXRob2QgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgXCJyZXF1ZXN0XCI6IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJyZXNwb25zZVwiOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgIFwib3B0aW9uc1wiOiB7fVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy50bi5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4gIT09IExhbmcuQ09QVE9QRU4pXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIHN0YXJ0IG9mIHJlcXVlc3QgdHlwZSBpbiBSUEMgc2VydmljZSBcIitzdmNbXCJuYW1lXCJdK1wiI1wiK25hbWUrXCIgYXQgbGluZSBcIit0aGlzLnRuLmxpbmUrXCI6IFwiK3Rva2VuK1wiICgnXCIrTGFuZy5DT1BUT1BFTitcIicgZXhwZWN0ZWQpXCIpO1xyXG4gICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRuLm5leHQoKTtcclxuICAgICAgICAgICAgICAgIGlmICghTGFuZy5UWVBFUkVGLnRlc3QodG9rZW4pKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCByZXF1ZXN0IHR5cGUgaW4gUlBDIHNlcnZpY2UgXCIrc3ZjW1wibmFtZVwiXStcIiNcIituYW1lK1wiIGF0IGxpbmUgXCIrdGhpcy50bi5saW5lK1wiOiBcIit0b2tlbik7XHJcbiAgICAgICAgICAgICAgICBtZXRob2RbXCJyZXF1ZXN0XCJdID0gdG9rZW47XHJcbiAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMudG4ubmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRva2VuICE9IExhbmcuQ09QVENMT1NFKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCBlbmQgb2YgcmVxdWVzdCB0eXBlIGluIFJQQyBzZXJ2aWNlIFwiK3N2Y1tcIm5hbWVcIl0rXCIjXCIrbmFtZStcIiBhdCBsaW5lIFwiK3RoaXMudG4ubGluZStcIjogXCIrdG9rZW4rXCIgKCdcIitMYW5nLkNPUFRDTE9TRStcIicgZXhwZWN0ZWQpXCIpO1xyXG4gICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRuLm5leHQoKTtcclxuICAgICAgICAgICAgICAgIGlmICh0b2tlbi50b0xvd2VyQ2FzZSgpICE9PSBcInJldHVybnNcIilcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIklsbGVnYWwgcmVxdWVzdC9yZXNwb25zZSBkZWxpbWl0ZXIgaW4gUlBDIHNlcnZpY2UgXCIrc3ZjW1wibmFtZVwiXStcIiNcIituYW1lK1wiIGF0IGxpbmUgXCIrdGhpcy50bi5saW5lK1wiOiBcIit0b2tlbitcIiAoJ3JldHVybnMnIGV4cGVjdGVkKVwiKTtcclxuICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy50bi5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4gIT0gTGFuZy5DT1BUT1BFTilcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIklsbGVnYWwgc3RhcnQgb2YgcmVzcG9uc2UgdHlwZSBpbiBSUEMgc2VydmljZSBcIitzdmNbXCJuYW1lXCJdK1wiI1wiK25hbWUrXCIgYXQgbGluZSBcIit0aGlzLnRuLmxpbmUrXCI6IFwiK3Rva2VuK1wiICgnXCIrTGFuZy5DT1BUT1BFTitcIicgZXhwZWN0ZWQpXCIpO1xyXG4gICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRuLm5leHQoKTtcclxuICAgICAgICAgICAgICAgIG1ldGhvZFtcInJlc3BvbnNlXCJdID0gdG9rZW47XHJcbiAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMudG4ubmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRva2VuICE9PSBMYW5nLkNPUFRDTE9TRSlcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIklsbGVnYWwgZW5kIG9mIHJlc3BvbnNlIHR5cGUgaW4gUlBDIHNlcnZpY2UgXCIrc3ZjW1wibmFtZVwiXStcIiNcIituYW1lK1wiIGF0IGxpbmUgXCIrdGhpcy50bi5saW5lK1wiOiBcIit0b2tlbitcIiAoJ1wiK0xhbmcuQ09QVENMT1NFK1wiJyBleHBlY3RlZClcIik7XHJcbiAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMudG4ubmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRva2VuID09PSBMYW5nLk9QRU4pIHtcclxuICAgICAgICAgICAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy50bi5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbiA9PT0gJ29wdGlvbicpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYXJzZU9wdGlvbihtZXRob2QsIHRva2VuKTsgLy8gPC0gd2lsbCBmYWlsIGZvciB0aGUgY3VzdG9tLW9wdGlvbnMgZXhhbXBsZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0b2tlbiAhPT0gTGFuZy5DTE9TRSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCBzdGFydCBvZiBvcHRpb24gaW4gUlBDIHNlcnZpY2UgXCIrc3ZjW1wibmFtZVwiXStcIiNcIituYW1lK1wiIGF0IGxpbmUgXCIrdGhpcy50bi5saW5lK1wiOiBcIit0b2tlbitcIiAoJ29wdGlvbicgZXhwZWN0ZWQpXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKHRva2VuICE9PSBMYW5nLkNMT1NFKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy50bi5wZWVrKCkgPT09IExhbmcuRU5EKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRuLm5leHQoKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodG9rZW4gIT09IExhbmcuRU5EKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCBtZXRob2QgZGVsaW1pdGVyIGluIFJQQyBzZXJ2aWNlIFwiK3N2Y1tcIm5hbWVcIl0rXCIjXCIrbmFtZStcIiBhdCBsaW5lIFwiK3RoaXMudG4ubGluZStcIjogXCIrdG9rZW4rXCIgKCdcIitMYW5nLkVORCtcIicgb3IgJ1wiK0xhbmcuT1BFTitcIicgZXhwZWN0ZWQpXCIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzdmNbdHlwZV0gPT09ICd1bmRlZmluZWQnKVxyXG4gICAgICAgICAgICAgICAgICAgIHN2Y1t0eXBlXSA9IHt9O1xyXG4gICAgICAgICAgICAgICAgc3ZjW3R5cGVdW25hbWVdID0gbWV0aG9kO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFBhcnNlcyBhIG1lc3NhZ2UgZGVmaW5pdGlvbi5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmVudCBQYXJlbnQgZGVmaW5pdGlvblxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZmxkIEZpZWxkIGRlZmluaXRpb24gaWYgdGhpcyBpcyBhIGdyb3VwLCBvdGhlcndpc2UgYG51bGxgXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlbiBGaXJzdCB0b2tlblxyXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9XHJcbiAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgbWVzc2FnZSBjYW5ub3QgYmUgcGFyc2VkXHJcbiAgICAgICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBQYXJzZXIucHJvdG90eXBlLl9wYXJzZU1lc3NhZ2UgPSBmdW5jdGlvbihwYXJlbnQsIGZsZCwgdG9rZW4pIHtcclxuICAgICAgICAgICAgICAgIC8qKiBAZGljdCAqL1xyXG4gICAgICAgICAgICAgICAgdmFyIG1zZyA9IHt9OyAvLyBOb3RlOiBBdCBzb21lIHBvaW50IHdlIG1pZ2h0IHdhbnQgdG8gZXhjbHVkZSB0aGUgcGFyc2VyLCBzbyB3ZSBuZWVkIGEgZGljdC5cclxuICAgICAgICAgICAgICAgIHZhciBpc0dyb3VwID0gdG9rZW4gPT09IFwiZ3JvdXBcIjtcclxuICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy50bi5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIUxhbmcuTkFNRS50ZXN0KHRva2VuKSlcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIklsbGVnYWwgXCIrKGlzR3JvdXAgPyBcImdyb3VwXCIgOiBcIm1lc3NhZ2VcIikrXCIgbmFtZVwiKyhwYXJlbnQgPyBcIiBpbiBtZXNzYWdlIFwiK3BhcmVudFtcIm5hbWVcIl0gOiBcIlwiKStcIiBhdCBsaW5lIFwiK3RoaXMudG4ubGluZStcIjogXCIrdG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgbXNnW1wibmFtZVwiXSA9IHRva2VuO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzR3JvdXApIHtcclxuICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMudG4ubmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbiAhPT0gTGFuZy5FUVVBTClcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIGlkIGFzc2lnbm1lbnQgYWZ0ZXIgZ3JvdXAgXCIrbXNnLm5hbWUrXCIgYXQgbGluZSBcIit0aGlzLnRuLmxpbmUrXCI6IFwiK3Rva2VuK1wiICgnXCIrTGFuZy5FUVVBTCtcIicgZXhwZWN0ZWQpXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy50bi5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmxkW1wiaWRcIl0gPSB0aGlzLl9wYXJzZUlkKHRva2VuKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCBmaWVsZCBpZCB2YWx1ZSBmb3IgZ3JvdXAgXCIrbXNnLm5hbWUrXCIjXCIrZmxkLm5hbWUrXCIgYXQgbGluZSBcIit0aGlzLnRuLmxpbmUrXCI6IFwiK3Rva2VuKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgbXNnW1wiaXNHcm91cFwiXSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBtc2dbXCJmaWVsZHNcIl0gPSBbXTsgLy8gTm90ZTogVXNpbmcgYXJyYXlzIHRvIHN1cHBvcnQgYWxzbyBicm93c2VyIHRoYXQgY2Fubm90IHByZXNlcnZlIG9yZGVyIG9mIG9iamVjdCBrZXlzLlxyXG4gICAgICAgICAgICAgICAgbXNnW1wiZW51bXNcIl0gPSBbXTtcclxuICAgICAgICAgICAgICAgIG1zZ1tcIm1lc3NhZ2VzXCJdID0gW107XHJcbiAgICAgICAgICAgICAgICBtc2dbXCJvcHRpb25zXCJdID0ge307XHJcbiAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMudG4ubmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRva2VuID09PSBMYW5nLk9QVE9QRU4gJiYgZmxkKVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhcnNlRmllbGRPcHRpb25zKG1zZywgZmxkLCB0b2tlbiksXHJcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRuLm5leHQoKTtcclxuICAgICAgICAgICAgICAgIGlmICh0b2tlbiAhPT0gTGFuZy5PUEVOKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCBPUEVOIGFmdGVyIFwiKyhpc0dyb3VwID8gXCJncm91cFwiIDogXCJtZXNzYWdlXCIpK1wiIFwiK21zZy5uYW1lK1wiIGF0IGxpbmUgXCIrdGhpcy50bi5saW5lK1wiOiBcIit0b2tlbitcIiAoJ1wiK0xhbmcuT1BFTitcIicgZXhwZWN0ZWQpXCIpO1xyXG4gICAgICAgICAgICAgICAgLy8gbXNnW1wiZXh0ZW5zaW9uc1wiXSA9IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy50bi5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuID09PSBMYW5nLkNMT1NFKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy50bi5wZWVrKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbiA9PT0gTGFuZy5FTkQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRuLm5leHQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChMYW5nLlJVTEUudGVzdCh0b2tlbikpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhcnNlTWVzc2FnZUZpZWxkKG1zZywgdG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRva2VuID09PSBcImVudW1cIilcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFyc2VFbnVtKG1zZywgdG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRva2VuID09PSBcIm1lc3NhZ2VcIilcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFyc2VNZXNzYWdlKG1zZywgbnVsbCwgdG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRva2VuID09PSBcIm9wdGlvblwiKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYXJzZU9wdGlvbihtc2csIHRva2VuKTtcclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0b2tlbiA9PT0gXCJleHRlbnNpb25zXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1zZ1tcImV4dGVuc2lvbnNcIl0gPSB0aGlzLl9wYXJzZUV4dGVuc2lvbnMobXNnLCB0b2tlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodG9rZW4gPT09IFwiZXh0ZW5kXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhcnNlRXh0ZW5kKG1zZywgdG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIHRva2VuIGluIG1lc3NhZ2UgXCIrbXNnLm5hbWUrXCIgYXQgbGluZSBcIit0aGlzLnRuLmxpbmUrXCI6IFwiK3Rva2VuK1wiICh0eXBlIG9yICdcIitMYW5nLkNMT1NFK1wiJyBleHBlY3RlZClcIik7XHJcbiAgICAgICAgICAgICAgICB9IHdoaWxlICh0cnVlKTtcclxuICAgICAgICAgICAgICAgIHBhcmVudFtcIm1lc3NhZ2VzXCJdLnB1c2gobXNnKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBtc2c7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUGFyc2VzIGEgbWVzc2FnZSBmaWVsZC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG1zZyBNZXNzYWdlIGRlZmluaXRpb25cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHRva2VuIEluaXRpYWwgdG9rZW5cclxuICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBtZXNzYWdlIGZpZWxkIGNhbm5vdCBiZSBwYXJzZWRcclxuICAgICAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFBhcnNlci5wcm90b3R5cGUuX3BhcnNlTWVzc2FnZUZpZWxkID0gZnVuY3Rpb24obXNnLCB0b2tlbikge1xyXG4gICAgICAgICAgICAgICAgLyoqIEBkaWN0ICovXHJcbiAgICAgICAgICAgICAgICB2YXIgZmxkID0ge30sIGdycCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBmbGRbXCJydWxlXCJdID0gdG9rZW47XHJcbiAgICAgICAgICAgICAgICAvKiogQGRpY3QgKi9cclxuICAgICAgICAgICAgICAgIGZsZFtcIm9wdGlvbnNcIl0gPSB7fTtcclxuICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy50bi5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4gPT09IFwiZ3JvdXBcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFwiQSBbbGVnYWN5XSBncm91cCBzaW1wbHkgY29tYmluZXMgYSBuZXN0ZWQgbWVzc2FnZSB0eXBlIGFuZCBhIGZpZWxkIGludG8gYSBzaW5nbGUgZGVjbGFyYXRpb24uIEluIHlvdXJcclxuICAgICAgICAgICAgICAgICAgICAvLyBjb2RlLCB5b3UgY2FuIHRyZWF0IHRoaXMgbWVzc2FnZSBqdXN0IGFzIGlmIGl0IGhhZCBhIFJlc3VsdCB0eXBlIGZpZWxkIGNhbGxlZCByZXN1bHQgKHRoZSBsYXR0ZXIgbmFtZSBpc1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnZlcnRlZCB0byBsb3dlci1jYXNlIHNvIHRoYXQgaXQgZG9lcyBub3QgY29uZmxpY3Qgd2l0aCB0aGUgZm9ybWVyKS5cIlxyXG4gICAgICAgICAgICAgICAgICAgIGdycCA9IHRoaXMuX3BhcnNlTWVzc2FnZShtc2csIGZsZCwgdG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghL15bQS1aXS8udGVzdChncnBbXCJuYW1lXCJdKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0dyb3VwIG5hbWVzIG11c3Qgc3RhcnQgd2l0aCBhIGNhcGl0YWwgbGV0dGVyJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgZmxkW1widHlwZVwiXSA9IGdycFtcIm5hbWVcIl07XHJcbiAgICAgICAgICAgICAgICAgICAgZmxkW1wibmFtZVwiXSA9IGdycFtcIm5hbWVcIl0udG9Mb3dlckNhc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMudG4ucGVlaygpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbiA9PT0gTGFuZy5FTkQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudG4ubmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIUxhbmcuVFlQRS50ZXN0KHRva2VuKSAmJiAhTGFuZy5UWVBFUkVGLnRlc3QodG9rZW4pKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIklsbGVnYWwgZmllbGQgdHlwZSBpbiBtZXNzYWdlIFwiK21zZy5uYW1lK1wiIGF0IGxpbmUgXCIrdGhpcy50bi5saW5lK1wiOiBcIit0b2tlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgZmxkW1widHlwZVwiXSA9IHRva2VuO1xyXG4gICAgICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy50bi5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFMYW5nLk5BTUUudGVzdCh0b2tlbikpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCBmaWVsZCBuYW1lIGluIG1lc3NhZ2UgXCIrbXNnLm5hbWUrXCIgYXQgbGluZSBcIit0aGlzLnRuLmxpbmUrXCI6IFwiK3Rva2VuKTtcclxuICAgICAgICAgICAgICAgICAgICBmbGRbXCJuYW1lXCJdID0gdG9rZW47XHJcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRuLm5leHQoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW4gIT09IExhbmcuRVFVQUwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCBmaWVsZCBpZCBhc3NpZ25tZW50IGluIG1lc3NhZ2UgXCIrbXNnLm5hbWUrXCIjXCIrZmxkLm5hbWUrXCIgYXQgbGluZSBcIit0aGlzLnRuLmxpbmUrXCI6IFwiK3Rva2VuK1wiICgnXCIrTGFuZy5FUVVBTCtcIicgZXhwZWN0ZWQpXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy50bi5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmxkW1wiaWRcIl0gPSB0aGlzLl9wYXJzZUlkKHRva2VuKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCBmaWVsZCBpZCB2YWx1ZSBpbiBtZXNzYWdlIFwiK21zZy5uYW1lK1wiI1wiK2ZsZC5uYW1lK1wiIGF0IGxpbmUgXCIrdGhpcy50bi5saW5lK1wiOiBcIit0b2tlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy50bi5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuID09PSBMYW5nLk9QVE9QRU4pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhcnNlRmllbGRPcHRpb25zKG1zZywgZmxkLCB0b2tlbiksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy50bi5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuICE9PSBMYW5nLkVORClcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIGZpZWxkIGRlbGltaXRlciBpbiBtZXNzYWdlIFwiK21zZy5uYW1lK1wiI1wiK2ZsZC5uYW1lK1wiIGF0IGxpbmUgXCIrdGhpcy50bi5saW5lK1wiOiBcIit0b2tlbitcIiAoJ1wiK0xhbmcuRU5EK1wiJyBleHBlY3RlZClcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBtc2dbXCJmaWVsZHNcIl0ucHVzaChmbGQpO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFBhcnNlcyBhIHNldCBvZiBmaWVsZCBvcHRpb24gZGVmaW5pdGlvbnMuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtc2cgTWVzc2FnZSBkZWZpbml0aW9uXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBmbGQgRmllbGQgZGVmaW5pdGlvblxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdG9rZW4gSW5pdGlhbCB0b2tlblxyXG4gICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIG1lc3NhZ2UgZmllbGQgb3B0aW9ucyBjYW5ub3QgYmUgcGFyc2VkXHJcbiAgICAgICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBQYXJzZXIucHJvdG90eXBlLl9wYXJzZUZpZWxkT3B0aW9ucyA9IGZ1bmN0aW9uKG1zZywgZmxkLCB0b2tlbikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGZpcnN0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMudG4ubmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbiA9PT0gTGFuZy5PUFRDTE9TRSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodG9rZW4gPT09IExhbmcuT1BURU5EKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaXJzdClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCBzdGFydCBvZiBtZXNzYWdlIGZpZWxkIG9wdGlvbnMgaW4gbWVzc2FnZSBcIittc2cubmFtZStcIiNcIitmbGQubmFtZStcIiBhdCBsaW5lIFwiK3RoaXMudG4ubGluZStcIjogXCIrdG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMudG4ubmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYXJzZUZpZWxkT3B0aW9uKG1zZywgZmxkLCB0b2tlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgZmlyc3QgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH0gd2hpbGUgKHRydWUpO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFBhcnNlcyBhIHNpbmdsZSBmaWVsZCBvcHRpb24uXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtc2cgTWVzc2FnZSBkZWZpbml0aW9uXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBmbGQgRmllbGQgZGVmaW5pdGlvblxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdG9rZW4gSW5pdGlhbCB0b2tlblxyXG4gICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIG1lc2FnZSBmaWVsZCBvcHRpb24gY2Fubm90IGJlIHBhcnNlZFxyXG4gICAgICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgUGFyc2VyLnByb3RvdHlwZS5fcGFyc2VGaWVsZE9wdGlvbiA9IGZ1bmN0aW9uKG1zZywgZmxkLCB0b2tlbikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGN1c3RvbSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRva2VuID09PSBMYW5nLkNPUFRPUEVOKVxyXG4gICAgICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy50bi5uZXh0KCksXHJcbiAgICAgICAgICAgICAgICAgICAgY3VzdG9tID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGlmICghTGFuZy5UWVBFUkVGLnRlc3QodG9rZW4pKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCBmaWVsZCBvcHRpb24gaW4gbWVzc2FnZSBcIittc2cubmFtZStcIiNcIitmbGQubmFtZStcIiBhdCBsaW5lIFwiK3RoaXMudG4ubGluZStcIjogXCIrdG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgdmFyIG5hbWUgPSB0b2tlbjtcclxuICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy50bi5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoY3VzdG9tKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuICE9PSBMYW5nLkNPUFRDTE9TRSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIGN1c3RvbSBmaWVsZCBvcHRpb24gbmFtZSBkZWxpbWl0ZXIgaW4gbWVzc2FnZSBcIittc2cubmFtZStcIiNcIitmbGQubmFtZStcIiBhdCBsaW5lIFwiK3RoaXMudG4ubGluZStcIjogXCIrdG9rZW4rXCIgKCcpJyBleHBlY3RlZClcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgbmFtZSA9ICcoJytuYW1lKycpJztcclxuICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMudG4ubmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChMYW5nLkZRVFlQRVJFRi50ZXN0KHRva2VuKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSArPSB0b2tlbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRuLm5leHQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0b2tlbiAhPT0gTGFuZy5FUVVBTClcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIklsbGVnYWwgZmllbGQgb3B0aW9uIG9wZXJhdGlvbiBpbiBtZXNzYWdlIFwiK21zZy5uYW1lK1wiI1wiK2ZsZC5uYW1lK1wiIGF0IGxpbmUgXCIrdGhpcy50bi5saW5lK1wiOiBcIit0b2tlbitcIiAoJz0nIGV4cGVjdGVkKVwiKTtcclxuICAgICAgICAgICAgICAgIHZhciB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy50bi5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4gPT09IExhbmcuU1RSSU5HT1BFTiB8fCB0b2tlbiA9PT0gTGFuZy5TVFJJTkdPUEVOX1NRKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLnRuLm5leHQoKTtcclxuICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMudG4ubmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbiAhPSB0aGlzLnRuLnN0cmluZ0VuZHNXaXRoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIklsbGVnYWwgZW5kIG9mIGZpZWxkIHZhbHVlIGluIG1lc3NhZ2UgXCIrbXNnLm5hbWUrXCIjXCIrZmxkLm5hbWUrXCIsIG9wdGlvbiBcIituYW1lK1wiIGF0IGxpbmUgXCIrdGhpcy50bi5saW5lK1wiOiBcIit0b2tlbitcIiAoJ1wiK3RoaXMudG4uc3RyaW5nRW5kc1dpdGgrXCInIGV4cGVjdGVkKVwiKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoTGFuZy5OVU1CRVIudGVzdCh0b2tlbiwgdHJ1ZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLl9wYXJzZU51bWJlcih0b2tlbiwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChMYW5nLkJPT0wudGVzdCh0b2tlbikpXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB0b2tlbi50b0xvd2VyQ2FzZSgpID09PSAndHJ1ZSc7XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChMYW5nLlRZUEVSRUYudGVzdCh0b2tlbikpXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB0b2tlbjsgLy8gVE9ETzogUmVzb2x2ZT9cclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIklsbGVnYWwgZmllbGQgb3B0aW9uIHZhbHVlIGluIG1lc3NhZ2UgXCIrbXNnLm5hbWUrXCIjXCIrZmxkLm5hbWUrXCIsIG9wdGlvbiBcIituYW1lK1wiIGF0IGxpbmUgXCIrdGhpcy50bi5saW5lK1wiOiBcIit0b2tlbik7XHJcbiAgICAgICAgICAgICAgICBmbGRbXCJvcHRpb25zXCJdW25hbWVdID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUGFyc2VzIGFuIGVudW0uXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtc2cgTWVzc2FnZSBkZWZpbml0aW9uXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlbiBJbml0aWFsIHRva2VuXHJcbiAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgZW51bSBjYW5ub3QgYmUgcGFyc2VkXHJcbiAgICAgICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBQYXJzZXIucHJvdG90eXBlLl9wYXJzZUVudW0gPSBmdW5jdGlvbihtc2csIHRva2VuKSB7XHJcbiAgICAgICAgICAgICAgICAvKiogQGRpY3QgKi9cclxuICAgICAgICAgICAgICAgIHZhciBlbm0gPSB7fTtcclxuICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy50bi5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIUxhbmcuTkFNRS50ZXN0KHRva2VuKSlcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIklsbGVnYWwgZW51bSBuYW1lIGluIG1lc3NhZ2UgXCIrbXNnLm5hbWUrXCIgYXQgbGluZSBcIit0aGlzLnRuLmxpbmUrXCI6IFwiK3Rva2VuKTtcclxuICAgICAgICAgICAgICAgIGVubVtcIm5hbWVcIl0gPSB0b2tlbjtcclxuICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy50bi5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4gIT09IExhbmcuT1BFTilcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIklsbGVnYWwgT1BFTiBhZnRlciBlbnVtIFwiK2VubS5uYW1lK1wiIGF0IGxpbmUgXCIrdGhpcy50bi5saW5lK1wiOiBcIit0b2tlbik7XHJcbiAgICAgICAgICAgICAgICBlbm1bXCJ2YWx1ZXNcIl0gPSBbXTtcclxuICAgICAgICAgICAgICAgIGVubVtcIm9wdGlvbnNcIl0gPSB7fTtcclxuICAgICAgICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMudG4ubmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbiA9PT0gTGFuZy5DTE9TRSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMudG4ucGVlaygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW4gPT09IExhbmcuRU5EKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50bi5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW4gPT0gJ29wdGlvbicpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhcnNlT3B0aW9uKGVubSwgdG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIUxhbmcuTkFNRS50ZXN0KHRva2VuKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCBlbnVtIHZhbHVlIG5hbWUgaW4gZW51bSBcIitlbm0ubmFtZStcIiBhdCBsaW5lIFwiK3RoaXMudG4ubGluZStcIjogXCIrdG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYXJzZUVudW1WYWx1ZShlbm0sIHRva2VuKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IHdoaWxlICh0cnVlKTtcclxuICAgICAgICAgICAgICAgIG1zZ1tcImVudW1zXCJdLnB1c2goZW5tKTtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBQYXJzZXMgYW4gZW51bSB2YWx1ZS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGVubSBFbnVtIGRlZmluaXRpb25cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHRva2VuIEluaXRpYWwgdG9rZW5cclxuICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBlbnVtIHZhbHVlIGNhbm5vdCBiZSBwYXJzZWRcclxuICAgICAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFBhcnNlci5wcm90b3R5cGUuX3BhcnNlRW51bVZhbHVlID0gZnVuY3Rpb24oZW5tLCB0b2tlbikge1xyXG4gICAgICAgICAgICAgICAgLyoqIEBkaWN0ICovXHJcbiAgICAgICAgICAgICAgICB2YXIgdmFsID0ge307XHJcbiAgICAgICAgICAgICAgICB2YWxbXCJuYW1lXCJdID0gdG9rZW47XHJcbiAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMudG4ubmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRva2VuICE9PSBMYW5nLkVRVUFMKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCBlbnVtIHZhbHVlIG9wZXJhdG9yIGluIGVudW0gXCIrZW5tLm5hbWUrXCIgYXQgbGluZSBcIit0aGlzLnRuLmxpbmUrXCI6IFwiK3Rva2VuK1wiICgnXCIrTGFuZy5FUVVBTCtcIicgZXhwZWN0ZWQpXCIpO1xyXG4gICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRuLm5leHQoKTtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsW1wiaWRcIl0gPSB0aGlzLl9wYXJzZUlkKHRva2VuLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIklsbGVnYWwgZW51bSB2YWx1ZSBpZCBpbiBlbnVtIFwiK2VubS5uYW1lK1wiIGF0IGxpbmUgXCIrdGhpcy50bi5saW5lK1wiOiBcIit0b2tlbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbm1bXCJ2YWx1ZXNcIl0ucHVzaCh2YWwpO1xyXG4gICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRuLm5leHQoKTtcclxuICAgICAgICAgICAgICAgIGlmICh0b2tlbiA9PT0gTGFuZy5PUFRPUEVOKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9wdCA9IHsgJ29wdGlvbnMnIDoge30gfTsgLy8gVE9ETzogQWN0dWFsbHkgZXhwb3NlIHRoZW0gc29tZWhvdy5cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYXJzZUZpZWxkT3B0aW9ucyhlbm0sIG9wdCwgdG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy50bi5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4gIT09IExhbmcuRU5EKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCBlbnVtIHZhbHVlIGRlbGltaXRlciBpbiBlbnVtIFwiK2VubS5uYW1lK1wiIGF0IGxpbmUgXCIrdGhpcy50bi5saW5lK1wiOiBcIit0b2tlbitcIiAoJ1wiK0xhbmcuRU5EK1wiJyBleHBlY3RlZClcIik7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUGFyc2VzIGFuIGV4dGVuc2lvbnMgc3RhdGVtZW50LlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gbXNnIE1lc3NhZ2Ugb2JqZWN0XHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlbiBJbml0aWFsIHRva2VuXHJcbiAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgZXh0ZW5zaW9ucyBzdGF0ZW1lbnQgY2Fubm90IGJlIHBhcnNlZFxyXG4gICAgICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgUGFyc2VyLnByb3RvdHlwZS5fcGFyc2VFeHRlbnNpb25zID0gZnVuY3Rpb24obXNnLCB0b2tlbikge1xyXG4gICAgICAgICAgICAgICAgLyoqIEB0eXBlIHtBcnJheS48bnVtYmVyPn0gKi9cclxuICAgICAgICAgICAgICAgIHZhciByYW5nZSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRuLm5leHQoKTtcclxuICAgICAgICAgICAgICAgIGlmICh0b2tlbiA9PT0gXCJtaW5cIikgLy8gRklYTUU6IERvZXMgdGhlIG9mZmljaWFsIGltcGxlbWVudGF0aW9uIHN1cHBvcnQgdGhpcz9cclxuICAgICAgICAgICAgICAgICAgICByYW5nZS5wdXNoKFByb3RvQnVmLklEX01JTik7XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0b2tlbiA9PT0gXCJtYXhcIilcclxuICAgICAgICAgICAgICAgICAgICByYW5nZS5wdXNoKFByb3RvQnVmLklEX01BWCk7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2UucHVzaCh0aGlzLl9wYXJzZU51bWJlcih0b2tlbikpO1xyXG4gICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRuLm5leHQoKTtcclxuICAgICAgICAgICAgICAgIGlmICh0b2tlbiAhPT0gJ3RvJylcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIklsbGVnYWwgZXh0ZW5zaW9ucyBkZWxpbWl0ZXIgaW4gbWVzc2FnZSBcIittc2cubmFtZStcIiBhdCBsaW5lIFwiK3RoaXMudG4ubGluZStcIiAoJ3RvJyBleHBlY3RlZClcIik7XHJcbiAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMudG4ubmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRva2VuID09PSBcIm1pblwiKVxyXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlLnB1c2goUHJvdG9CdWYuSURfTUlOKTtcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRva2VuID09PSBcIm1heFwiKVxyXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlLnB1c2goUHJvdG9CdWYuSURfTUFYKTtcclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICByYW5nZS5wdXNoKHRoaXMuX3BhcnNlTnVtYmVyKHRva2VuKSk7XHJcbiAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMudG4ubmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRva2VuICE9PSBMYW5nLkVORClcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIklsbGVnYWwgZXh0ZW5zaW9uIGRlbGltaXRlciBpbiBtZXNzYWdlIFwiK21zZy5uYW1lK1wiIGF0IGxpbmUgXCIrdGhpcy50bi5saW5lK1wiOiBcIit0b2tlbitcIiAoJ1wiK0xhbmcuRU5EK1wiJyBleHBlY3RlZClcIik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmFuZ2U7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUGFyc2VzIGFuIGV4dGVuZCBibG9jay5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmVudCBQYXJlbnQgb2JqZWN0XHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlbiBJbml0aWFsIHRva2VuXHJcbiAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgZXh0ZW5kIGJsb2NrIGNhbm5vdCBiZSBwYXJzZWRcclxuICAgICAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFBhcnNlci5wcm90b3R5cGUuX3BhcnNlRXh0ZW5kID0gZnVuY3Rpb24ocGFyZW50LCB0b2tlbikge1xyXG4gICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRuLm5leHQoKTtcclxuICAgICAgICAgICAgICAgIGlmICghTGFuZy5UWVBFUkVGLnRlc3QodG9rZW4pKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCBleHRlbmRlZCBtZXNzYWdlIG5hbWUgYXQgbGluZSBcIit0aGlzLnRuLmxpbmUrXCI6IFwiK3Rva2VuKTtcclxuICAgICAgICAgICAgICAgIC8qKiBAZGljdCAqL1xyXG4gICAgICAgICAgICAgICAgdmFyIGV4dCA9IHt9O1xyXG4gICAgICAgICAgICAgICAgZXh0W1wicmVmXCJdID0gdG9rZW47XHJcbiAgICAgICAgICAgICAgICBleHRbXCJmaWVsZHNcIl0gPSBbXTtcclxuICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy50bi5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4gIT09IExhbmcuT1BFTilcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIklsbGVnYWwgT1BFTiBpbiBleHRlbmQgXCIrZXh0Lm5hbWUrXCIgYXQgbGluZSBcIit0aGlzLnRuLmxpbmUrXCI6IFwiK3Rva2VuK1wiICgnXCIrTGFuZy5PUEVOK1wiJyBleHBlY3RlZClcIik7XHJcbiAgICAgICAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRuLm5leHQoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW4gPT09IExhbmcuQ0xPU0UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRuLnBlZWsoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuID09IExhbmcuRU5EKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50bi5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoTGFuZy5SVUxFLnRlc3QodG9rZW4pKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYXJzZU1lc3NhZ2VGaWVsZChleHQsIHRva2VuKTtcclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCB0b2tlbiBpbiBleHRlbmQgXCIrZXh0Lm5hbWUrXCIgYXQgbGluZSBcIit0aGlzLnRuLmxpbmUrXCI6IFwiK3Rva2VuK1wiIChydWxlIG9yICdcIitMYW5nLkNMT1NFK1wiJyBleHBlY3RlZClcIik7XHJcbiAgICAgICAgICAgICAgICB9IHdoaWxlICh0cnVlKTtcclxuICAgICAgICAgICAgICAgIHBhcmVudFtcIm1lc3NhZ2VzXCJdLnB1c2goZXh0KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBleHQ7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG9iamVjdC5cclxuICAgICAgICAgICAgICogQHJldHVybnMge3N0cmluZ30gU3RyaW5nIHJlcHJlc2VudGF0aW9uIGFzIG9mIFwiUGFyc2VyXCJcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFBhcnNlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBcIlBhcnNlclwiO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEBhbGlhcyBQcm90b0J1Zi5Eb3RQcm90by5QYXJzZXJcclxuICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgRG90UHJvdG8uUGFyc2VyID0gUGFyc2VyO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIERvdFByb3RvO1xyXG5cclxuICAgICAgICB9KShQcm90b0J1ZiwgUHJvdG9CdWYuTGFuZyk7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBhbGlhcyBQcm90b0J1Zi5SZWZsZWN0XHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFByb3RvQnVmLlJlZmxlY3QgPSAoZnVuY3Rpb24oUHJvdG9CdWYpIHtcclxuICAgICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUmVmbGVjdGlvbiB0eXBlcy5cclxuICAgICAgICAgICAgICogQGV4cG9ydHMgUHJvdG9CdWYuUmVmbGVjdFxyXG4gICAgICAgICAgICAgKiBAbmFtZXNwYWNlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB2YXIgUmVmbGVjdCA9IHt9O1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIENvbnN0cnVjdHMgYSBSZWZsZWN0IGJhc2UgY2xhc3MuXHJcbiAgICAgICAgICAgICAqIEBleHBvcnRzIFByb3RvQnVmLlJlZmxlY3QuVFxyXG4gICAgICAgICAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAgICAgICAgICogQGFic3RyYWN0XHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7UHJvdG9CdWYuUmVmbGVjdC5UfSBwYXJlbnQgUGFyZW50IG9iamVjdFxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBPYmplY3QgbmFtZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdmFyIFQgPSBmdW5jdGlvbihwYXJlbnQsIG5hbWUpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFBhcmVudCBvYmplY3QuXHJcbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7UHJvdG9CdWYuUmVmbGVjdC5UfG51bGx9XHJcbiAgICAgICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogT2JqZWN0IG5hbWUgaW4gbmFtZXNwYWNlLlxyXG4gICAgICAgICAgICAgICAgICogQHR5cGUge3N0cmluZ31cclxuICAgICAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEZ1bGx5IHF1YWxpZmllZCBjbGFzcyBuYW1lXHJcbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAgICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLmNsYXNzTmFtZTtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBSZXR1cm5zIHRoZSBmdWxseSBxdWFsaWZpZWQgbmFtZSBvZiB0aGlzIG9iamVjdC5cclxuICAgICAgICAgICAgICogQHJldHVybnMge3N0cmluZ30gRnVsbHkgcXVhbGlmaWVkIG5hbWUgYXMgb2YgXCIuUEFUSC5UTy5USElTXCJcclxuICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgVC5wcm90b3R5cGUuZnFuID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IHRoaXMubmFtZSxcclxuICAgICAgICAgICAgICAgICAgICBwdHIgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAgICAgICAgIHB0ciA9IHB0ci5wYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHB0ciA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBuYW1lID0gcHRyLm5hbWUrXCIuXCIrbmFtZTtcclxuICAgICAgICAgICAgICAgIH0gd2hpbGUgKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5hbWU7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIFJlZmxlY3Qgb2JqZWN0IChpdHMgZnVsbHkgcXVhbGlmaWVkIG5hbWUpLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBpbmNsdWRlQ2xhc3MgU2V0IHRvIHRydWUgdG8gaW5jbHVkZSB0aGUgY2xhc3MgbmFtZS4gRGVmYXVsdHMgdG8gZmFsc2UuXHJcbiAgICAgICAgICAgICAqIEByZXR1cm4gU3RyaW5nIHJlcHJlc2VudGF0aW9uXHJcbiAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oaW5jbHVkZUNsYXNzKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKGluY2x1ZGVDbGFzcyA/IHRoaXMuY2xhc3NOYW1lICsgXCIgXCIgOiBcIlwiKSArIHRoaXMuZnFuKCk7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQnVpbGRzIHRoaXMgdHlwZS5cclxuICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoaXMgdHlwZSBjYW5ub3QgYmUgYnVpbHQgZGlyZWN0bHlcclxuICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgVC5wcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKHRoaXMudG9TdHJpbmcodHJ1ZSkrXCIgY2Fubm90IGJlIGJ1aWx0IGRpcmVjdGx5XCIpO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEBhbGlhcyBQcm90b0J1Zi5SZWZsZWN0LlRcclxuICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgUmVmbGVjdC5UID0gVDtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IE5hbWVzcGFjZS5cclxuICAgICAgICAgICAgICogQGV4cG9ydHMgUHJvdG9CdWYuUmVmbGVjdC5OYW1lc3BhY2VcclxuICAgICAgICAgICAgICogQHBhcmFtIHtQcm90b0J1Zi5SZWZsZWN0Lk5hbWVzcGFjZXxudWxsfSBwYXJlbnQgTmFtZXNwYWNlIHBhcmVudFxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBOYW1lc3BhY2UgbmFtZVxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBvcHRpb25zIE5hbWVzcGFjZSBvcHRpb25zXHJcbiAgICAgICAgICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICAgICAgICAgKiBAZXh0ZW5kcyBQcm90b0J1Zi5SZWZsZWN0LlRcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHZhciBOYW1lc3BhY2UgPSBmdW5jdGlvbihwYXJlbnQsIG5hbWUsIG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgIFQuY2FsbCh0aGlzLCBwYXJlbnQsIG5hbWUpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQG92ZXJyaWRlXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuY2xhc3NOYW1lID0gXCJOYW1lc3BhY2VcIjtcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIENoaWxkcmVuIGluc2lkZSB0aGUgbmFtZXNwYWNlLlxyXG4gICAgICAgICAgICAgICAgICogQHR5cGUge0FycmF5LjxQcm90b0J1Zi5SZWZsZWN0LlQ+fVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLmNoaWxkcmVuID0gW107XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBPcHRpb25zLlxyXG4gICAgICAgICAgICAgICAgICogQHR5cGUge09iamVjdC48c3RyaW5nLCAqPn1cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8vIEV4dGVuZHMgVFxyXG4gICAgICAgICAgICBOYW1lc3BhY2UucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShULnByb3RvdHlwZSk7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUmV0dXJucyBhbiBhcnJheSBvZiB0aGUgbmFtZXNwYWNlJ3MgY2hpbGRyZW4uXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7UHJvdG9CdWYuUmVmbGVjdC5UPX0gdHlwZSBGaWx0ZXIgdHlwZSAocmV0dXJucyBpbnN0YW5jZXMgb2YgdGhpcyB0eXBlIG9ubHkpLiBEZWZhdWx0cyB0byBudWxsIChhbGwgY2hpbGRyZW4pLlxyXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHtBcnJheS48UHJvdG9CdWYuUmVmbGVjdC5UPn1cclxuICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgTmFtZXNwYWNlLnByb3RvdHlwZS5nZXRDaGlsZHJlbiA9IGZ1bmN0aW9uKHR5cGUpIHtcclxuICAgICAgICAgICAgICAgIHR5cGUgPSB0eXBlIHx8IG51bGw7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuLnNsaWNlKCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSBbXTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGk9MCwgaz10aGlzLmNoaWxkcmVuLmxlbmd0aDsgaTxrOyArK2kpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW5baV0gaW5zdGFuY2VvZiB0eXBlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBhbHNvIG5lZWQgdG8gZGlzdGluZ3Vpc2ggYmV0d2VlbiBGaWVsZCBhbmQgRXh0ZW5zaW9uRmllbGQgd2hpY2ggaXMgYW4gaW5zdGFuY2Ugb2YgRmllbGRcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgIT09IE1lc3NhZ2UuRmllbGQgfHwgISh0aGlzLmNoaWxkcmVuW2ldIGluc3RhbmNlb2YgTWVzc2FnZS5FeHRlbnNpb25GaWVsZCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKHRoaXMuY2hpbGRyZW5baV0pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkcmVuO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEFkZHMgYSBjaGlsZCB0byB0aGUgbmFtZXNwYWNlLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge1Byb3RvQnVmLlJlZmxlY3QuVH0gY2hpbGQgQ2hpbGRcclxuICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBjaGlsZCBjYW5ub3QgYmUgYWRkZWQgKGR1cGxpY2F0ZSlcclxuICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgTmFtZXNwYWNlLnByb3RvdHlwZS5hZGRDaGlsZCA9IGZ1bmN0aW9uKGNoaWxkKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgb3RoZXI7XHJcbiAgICAgICAgICAgICAgICBpZiAob3RoZXIgPSB0aGlzLmdldENoaWxkKGNoaWxkLm5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVHJ5IHRvIHJldmVydCBjYW1lbGNhc2UgdHJhbnNmb3JtYXRpb24gb24gY29sbGlzaW9uXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG90aGVyIGluc3RhbmNlb2YgTWVzc2FnZS5GaWVsZCAmJiBvdGhlci5uYW1lICE9PSBvdGhlci5vcmlnaW5hbE5hbWUgJiYgIXRoaXMuaGFzQ2hpbGQob3RoZXIub3JpZ2luYWxOYW1lKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3RoZXIubmFtZSA9IG90aGVyLm9yaWdpbmFsTmFtZTsgLy8gUmV2ZXJ0IHByZXZpb3VzIGZpcnN0IChlZmZlY3RpdmVseSBrZWVwcyBib3RoIG9yaWdpbmFscylcclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjaGlsZCBpbnN0YW5jZW9mIE1lc3NhZ2UuRmllbGQgJiYgY2hpbGQubmFtZSAhPT0gY2hpbGQub3JpZ2luYWxOYW1lICYmICF0aGlzLmhhc0NoaWxkKGNoaWxkLm9yaWdpbmFsTmFtZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkLm5hbWUgPSBjaGlsZC5vcmlnaW5hbE5hbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIkR1cGxpY2F0ZSBuYW1lIGluIG5hbWVzcGFjZSBcIit0aGlzLnRvU3RyaW5nKHRydWUpK1wiOiBcIitjaGlsZC5uYW1lKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4ucHVzaChjaGlsZCk7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGVzdHMgaWYgdGhpcyBuYW1lc3BhY2UgaGFzIGEgY2hpbGQgd2l0aCB0aGUgc3BlY2lmaWVkIG5hbWUuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gbmFtZU9ySWQgQ2hpbGQgbmFtZSBvciBpZFxyXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGVyZSBpcyBvbmUsIGVsc2UgZmFsc2VcclxuICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgTmFtZXNwYWNlLnByb3RvdHlwZS5oYXNDaGlsZCA9IGZ1bmN0aW9uKG5hbWVPcklkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faW5kZXhPZihuYW1lT3JJZCkgPiAtMTtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBHZXRzIGEgY2hpbGQgYnkgaXRzIG5hbWUuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gbmFtZU9ySWQgQ2hpbGQgbmFtZSBvciBpZFxyXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/UHJvdG9CdWYuUmVmbGVjdC5UfSBUaGUgY2hpbGQgb3IgbnVsbCBpZiBub3QgZm91bmRcclxuICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgTmFtZXNwYWNlLnByb3RvdHlwZS5nZXRDaGlsZCA9IGZ1bmN0aW9uKG5hbWVPcklkKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLl9pbmRleE9mKG5hbWVPcklkKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpbmRleCA+IC0xID8gdGhpcy5jaGlsZHJlbltpbmRleF0gOiBudWxsO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFJldHVybnMgY2hpbGQgaW5kZXggYnkgaXRzIG5hbWUgb3IgaWQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gbmFtZU9ySWQgQ2hpbGQgbmFtZSBvciBpZFxyXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBjaGlsZCBpbmRleFxyXG4gICAgICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgTmFtZXNwYWNlLnByb3RvdHlwZS5faW5kZXhPZiA9IGZ1bmN0aW9uKG5hbWVPcklkKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gdHlwZW9mIG5hbWVPcklkID09PSAnbnVtYmVyJyA/ICdpZCcgOiAnbmFtZSc7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8dGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuY2hpbGRyZW5baV1ba2V5XSAhPT0gJ3VuZGVmaW5lZCcgJiYgdGhpcy5jaGlsZHJlbltpXVtrZXldID09IG5hbWVPcklkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcclxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBSZXNvbHZlcyBhIHJlZmxlY3Qgb2JqZWN0IGluc2lkZSBvZiB0aGlzIG5hbWVzcGFjZS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHFuIFF1YWxpZmllZCBuYW1lIHRvIHJlc29sdmVcclxuICAgICAgICAgICAgICogQHBhcmFtIHtib29sZWFuPX0gZXhjbHVkZUZpZWxkcyBFeGNsdWRlcyBmaWVsZHMsIGRlZmF1bHRzIHRvIGBmYWxzZWBcclxuICAgICAgICAgICAgICogQHJldHVybiB7UHJvdG9CdWYuUmVmbGVjdC5OYW1lc3BhY2V8bnVsbH0gVGhlIHJlc29sdmVkIHR5cGUgb3IgbnVsbCBpZiBub3QgZm91bmRcclxuICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgTmFtZXNwYWNlLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24ocW4sIGV4Y2x1ZGVGaWVsZHMpIHtcclxuICAgICAgICAgICAgICAgIHZhciBwYXJ0ID0gcW4uc3BsaXQoXCIuXCIpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHB0ciA9IHRoaXMsIGk9MDtcclxuICAgICAgICAgICAgICAgIGlmIChwYXJ0W2ldID09IFwiXCIpIHsgLy8gRnVsbHkgcXVhbGlmaWVkIG5hbWUsIGUuZy4gXCIuTXkuTWVzc2FnZSdcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAocHRyLnBhcmVudCAhPSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwdHIgPSBwdHIucGFyZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIGkrKztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBjaGlsZDtcclxuICAgICAgICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkID0gcHRyLmdldENoaWxkKHBhcnRbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNoaWxkIHx8ICEoY2hpbGQgaW5zdGFuY2VvZiBSZWZsZWN0LlQpIHx8IChleGNsdWRlRmllbGRzICYmIGNoaWxkIGluc3RhbmNlb2YgUmVmbGVjdC5NZXNzYWdlLkZpZWxkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHRyID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHB0ciA9IGNoaWxkOyBpKys7XHJcbiAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoaSA8IHBhcnQubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocHRyICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOyAvLyBGb3VuZFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEVsc2Ugc2VhcmNoIHRoZSBwYXJlbnRcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wYXJlbnQgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50LnJlc29sdmUocW4sIGV4Y2x1ZGVGaWVsZHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gd2hpbGUgKHB0ciAhPSBudWxsKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwdHI7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQnVpbGRzIHRoZSBuYW1lc3BhY2UgYW5kIHJldHVybnMgdGhlIHJ1bnRpbWUgY291bnRlcnBhcnQuXHJcbiAgICAgICAgICAgICAqIEByZXR1cm4ge09iamVjdC48c3RyaW5nLEZ1bmN0aW9ufE9iamVjdD59IFJ1bnRpbWUgbmFtZXNwYWNlXHJcbiAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIE5hbWVzcGFjZS5wcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIC8qKiBAZGljdCAqL1xyXG4gICAgICAgICAgICAgICAgdmFyIG5zID0ge307XHJcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLmdldENoaWxkcmVuKCksIGNoaWxkO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaT0wLCBrPWNoaWxkcmVuLmxlbmd0aDsgaTxrOyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICBjaGlsZCA9IGNoaWxkcmVuW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIE5hbWVzcGFjZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgbnNbY2hpbGQubmFtZV0gPSBjaGlsZC5idWlsZCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSlcclxuICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsIFwiJG9wdGlvbnNcIiwgeyBcInZhbHVlXCI6IHRoaXMuYnVpbGRPcHQoKSB9KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBucztcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBCdWlsZHMgdGhlIG5hbWVzcGFjZSdzICckb3B0aW9ucycgcHJvcGVydHkuXHJcbiAgICAgICAgICAgICAqIEByZXR1cm4ge09iamVjdC48c3RyaW5nLCo+fVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgTmFtZXNwYWNlLnByb3RvdHlwZS5idWlsZE9wdCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG9wdCA9IHt9O1xyXG4gICAgICAgICAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh0aGlzLm9wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpPGtleXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gdGhpcy5vcHRpb25zW2tleXNbaV1dO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IE9wdGlvbnMgYXJlIG5vdCByZXNvbHZlZCwgeWV0LlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmICh2YWwgaW5zdGFuY2VvZiBOYW1lc3BhY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgb3B0W2tleV0gPSB2YWwuYnVpbGQoKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG9wdFtrZXldID0gdmFsO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBvcHQ7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR2V0cyB0aGUgdmFsdWUgYXNzaWduZWQgdG8gdGhlIG9wdGlvbiB3aXRoIHRoZSBzcGVjaWZpZWQgbmFtZS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmc9fSBuYW1lIFJldHVybnMgdGhlIG9wdGlvbiB2YWx1ZSBpZiBzcGVjaWZpZWQsIG90aGVyd2lzZSBhbGwgb3B0aW9ucyBhcmUgcmV0dXJuZWQuXHJcbiAgICAgICAgICAgICAqIEByZXR1cm4geyp8T2JqZWN0LjxzdHJpbmcsKj59bnVsbH0gT3B0aW9uIHZhbHVlIG9yIE5VTEwgaWYgdGhlcmUgaXMgbm8gc3VjaCBvcHRpb25cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIE5hbWVzcGFjZS5wcm90b3R5cGUuZ2V0T3B0aW9uID0gZnVuY3Rpb24obmFtZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSAndW5kZWZpbmVkJylcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiB0aGlzLm9wdGlvbnNbbmFtZV0gIT09ICd1bmRlZmluZWQnID8gdGhpcy5vcHRpb25zW25hbWVdIDogbnVsbDtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBAYWxpYXMgUHJvdG9CdWYuUmVmbGVjdC5OYW1lc3BhY2VcclxuICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgUmVmbGVjdC5OYW1lc3BhY2UgPSBOYW1lc3BhY2U7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQ29uc3RydWN0cyBhIG5ldyBNZXNzYWdlLlxyXG4gICAgICAgICAgICAgKiBAZXhwb3J0cyBQcm90b0J1Zi5SZWZsZWN0Lk1lc3NhZ2VcclxuICAgICAgICAgICAgICogQHBhcmFtIHtQcm90b0J1Zi5SZWZsZWN0Lk5hbWVzcGFjZX0gcGFyZW50IFBhcmVudCBtZXNzYWdlIG9yIG5hbWVzcGFjZVxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBNZXNzYWdlIG5hbWVcclxuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gb3B0aW9ucyBNZXNzYWdlIG9wdGlvbnNcclxuICAgICAgICAgICAgICogQHBhcmFtIHtib29sZWFuPX0gaXNHcm91cCBgdHJ1ZWAgaWYgdGhpcyBpcyBhIGxlZ2FjeSBncm91cFxyXG4gICAgICAgICAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAgICAgICAgICogQGV4dGVuZHMgUHJvdG9CdWYuUmVmbGVjdC5OYW1lc3BhY2VcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHZhciBNZXNzYWdlID0gZnVuY3Rpb24ocGFyZW50LCBuYW1lLCBvcHRpb25zLCBpc0dyb3VwKSB7XHJcbiAgICAgICAgICAgICAgICBOYW1lc3BhY2UuY2FsbCh0aGlzLCBwYXJlbnQsIG5hbWUsIG9wdGlvbnMpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQG92ZXJyaWRlXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuY2xhc3NOYW1lID0gXCJNZXNzYWdlXCI7XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBFeHRlbnNpb25zIHJhbmdlLlxyXG4gICAgICAgICAgICAgICAgICogQHR5cGUgeyFBcnJheS48bnVtYmVyPn1cclxuICAgICAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5leHRlbnNpb25zID0gW1Byb3RvQnVmLklEX01JTiwgUHJvdG9CdWYuSURfTUFYXTtcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFJ1bnRpbWUgbWVzc2FnZSBjbGFzcy5cclxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHs/ZnVuY3Rpb24obmV3OlByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZSl9XHJcbiAgICAgICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuY2xhenogPSBudWxsO1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogV2hldGhlciB0aGlzIGlzIGEgbGVnYWN5IGdyb3VwIG9yIG5vdC5cclxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLmlzR3JvdXAgPSAhIWlzR3JvdXA7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvLyBFeHRlbmRzIE5hbWVzcGFjZVxyXG4gICAgICAgICAgICBNZXNzYWdlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTmFtZXNwYWNlLnByb3RvdHlwZSk7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQnVpbGRzIHRoZSBtZXNzYWdlIGFuZCByZXR1cm5zIHRoZSBydW50aW1lIGNvdW50ZXJwYXJ0LCB3aGljaCBpcyBhIGZ1bGx5IGZ1bmN0aW9uYWwgY2xhc3MuXHJcbiAgICAgICAgICAgICAqIEBzZWUgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IHJlYnVpbGQgV2hldGhlciB0byByZWJ1aWxkIG9yIG5vdCwgZGVmYXVsdHMgdG8gZmFsc2VcclxuICAgICAgICAgICAgICogQHJldHVybiB7UHJvdG9CdWYuUmVmbGVjdC5NZXNzYWdlfSBNZXNzYWdlIGNsYXNzXHJcbiAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgbWVzc2FnZSBjYW5ub3QgYmUgYnVpbHRcclxuICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgTWVzc2FnZS5wcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbihyZWJ1aWxkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jbGF6eiAmJiAhcmVidWlsZCkgcmV0dXJuIHRoaXMuY2xheno7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBjcmVhdGUgYSBwcm90b3R5cGVkIE1lc3NhZ2UgY2xhc3MgaW4gYW4gaXNvbGF0ZWQgc2NvcGVcclxuICAgICAgICAgICAgICAgIHZhciBjbGF6eiA9IChmdW5jdGlvbihQcm90b0J1ZiwgVCkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgZmllbGRzID0gVC5nZXRDaGlsZHJlbihQcm90b0J1Zi5SZWZsZWN0Lk1lc3NhZ2UuRmllbGQpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IHJ1bnRpbWUgTWVzc2FnZS5cclxuICAgICAgICAgICAgICAgICAgICAgKiBAbmFtZSBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2VcclxuICAgICAgICAgICAgICAgICAgICAgKiBAY2xhc3MgQmFyZWJvbmUgb2YgYWxsIHJ1bnRpbWUgbWVzc2FnZXMuXHJcbiAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPnwuLi5bc3RyaW5nXX0gdmFsdWVzIFByZXNldCB2YWx1ZXNcclxuICAgICAgICAgICAgICAgICAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAgICAgICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIG1lc3NhZ2UgY2Fubm90IGJlIGNyZWF0ZWRcclxuICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICB2YXIgTWVzc2FnZSA9IGZ1bmN0aW9uKHZhbHVlcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UuY2FsbCh0aGlzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGksIGZpZWxkO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGZpZWxkcyBvbiB0aGUgb2JqZWN0IGl0c2VsZiB0byBhbGxvdyBzZXR0aW5nIGFuZCBnZXR0aW5nIHRocm91Z2ggTWVzc2FnZSNmaWVsZG5hbWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpPTA7IGk8ZmllbGRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWVsZCA9IGZpZWxkc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbZmllbGQubmFtZV0gPSAoZmllbGQucmVwZWF0ZWQpID8gW10gOiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNldCB0aGUgZGVmYXVsdCB2YWx1ZXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpPTA7IGk8ZmllbGRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWVsZCA9IGZpZWxkc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZmllbGQub3B0aW9uc1snZGVmYXVsdCddICE9ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kc2V0KGZpZWxkLm5hbWUsIGZpZWxkLm9wdGlvbnNbJ2RlZmF1bHQnXSk7IC8vIFNob3VsZCBub3QgdGhyb3dcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiW0lOVEVSTkFMXSBcIitlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2V0IGZpZWxkIHZhbHVlcyBmcm9tIGEgdmFsdWVzIG9iamVjdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAxICYmIHR5cGVvZiB2YWx1ZXMgPT0gJ29iamVjdCcgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIG5vdCBhbm90aGVyIE1lc3NhZ2UgKi8gdHlwZW9mIHZhbHVlcy5lbmNvZGUgIT0gJ2Z1bmN0aW9uJyAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogbm90IGEgcmVwZWF0ZWQgZmllbGQgKi8gIVByb3RvQnVmLlV0aWwuaXNBcnJheSh2YWx1ZXMpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBub3QgYSBCeXRlQnVmZmVyICovICEodmFsdWVzIGluc3RhbmNlb2YgQnl0ZUJ1ZmZlcikgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIG5vdCBhbiBBcnJheUJ1ZmZlciAqLyAhKHZhbHVlcyBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogbm90IGEgTG9uZyAqLyAhKFByb3RvQnVmLkxvbmcgJiYgdmFsdWVzIGluc3RhbmNlb2YgUHJvdG9CdWYuTG9uZykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsdWVzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaT0wOyBpPGtleXMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kc2V0KGtleXNbaV0sIHZhbHVlc1trZXlzW2ldXSk7IC8vIE1heSB0aHJvd1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRWxzZSBzZXQgZmllbGQgdmFsdWVzIGZyb20gYXJndW1lbnRzLCBpbiBjb3JyZWN0IG9yZGVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpPTA7IGk8YXJndW1lbnRzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpPGZpZWxkcy5sZW5ndGgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJHNldChmaWVsZHNbaV0ubmFtZSwgYXJndW1lbnRzW2ldKTsgLy8gTWF5IHRocm93XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRXh0ZW5kcyBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2VcclxuICAgICAgICAgICAgICAgICAgICBNZXNzYWdlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlLnByb3RvdHlwZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAqIEFkZHMgYSB2YWx1ZSB0byBhIHJlcGVhdGVkIGZpZWxkLlxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBuYW1lIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZSNhZGRcclxuICAgICAgICAgICAgICAgICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IEZpZWxkIG5hbWVcclxuICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIGFkZFxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IG5vQXNzZXJ0IFdoZXRoZXIgdG8gYXNzZXJ0IHRoZSB2YWx1ZSBvciBub3QgKGFzc2VydHMgYnkgZGVmYXVsdClcclxuICAgICAgICAgICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHZhbHVlIGNhbm5vdCBiZSBhZGRlZFxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICBNZXNzYWdlLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihrZXksIHZhbHVlLCBub0Fzc2VydCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmllbGQgPSBULmdldENoaWxkKGtleSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZmllbGQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcih0aGlzK1wiI1wiK2tleStcIiBpcyB1bmRlZmluZWRcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGZpZWxkIGluc3RhbmNlb2YgUHJvdG9CdWYuUmVmbGVjdC5NZXNzYWdlLkZpZWxkKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKHRoaXMrXCIjXCIra2V5K1wiIGlzIG5vdCBhIGZpZWxkOiBcIitmaWVsZC50b1N0cmluZyh0cnVlKSk7IC8vIE1heSB0aHJvdyBpZiBpdCdzIGFuIGVudW0gb3IgZW1iZWRkZWQgbWVzc2FnZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWZpZWxkLnJlcGVhdGVkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IodGhpcytcIiNcIitrZXkrXCIgaXMgbm90IGEgcmVwZWF0ZWQgZmllbGRcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzW2ZpZWxkLm5hbWVdID09PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1tmaWVsZC5uYW1lXSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2ZpZWxkLm5hbWVdLnB1c2gobm9Bc3NlcnQgPyB2YWx1ZSA6IGZpZWxkLnZlcmlmeVZhbHVlKHZhbHVlLCB0cnVlKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICogQWRkcyBhIHZhbHVlIHRvIGEgcmVwZWF0ZWQgZmllbGQuIFRoaXMgaXMgYW4gYWxpYXMgZm9yIHtAbGluayBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UjYWRkfS5cclxuICAgICAgICAgICAgICAgICAgICAgKiBAbmFtZSBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UjJGFkZFxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgRmllbGQgbmFtZVxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgdG8gYWRkXHJcbiAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtib29sZWFuPX0gbm9Bc3NlcnQgV2hldGhlciB0byBhc3NlcnQgdGhlIHZhbHVlIG9yIG5vdCAoYXNzZXJ0cyBieSBkZWZhdWx0KVxyXG4gICAgICAgICAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgdmFsdWUgY2Fubm90IGJlIGFkZGVkXHJcbiAgICAgICAgICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgIE1lc3NhZ2UucHJvdG90eXBlLiRhZGQgPSBNZXNzYWdlLnByb3RvdHlwZS5hZGQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAqIFNldHMgYSBmaWVsZCdzIHZhbHVlLlxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBuYW1lIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZSNzZXRcclxuICAgICAgICAgICAgICAgICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IEtleVxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgdG8gc2V0XHJcbiAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtib29sZWFuPX0gbm9Bc3NlcnQgV2hldGhlciB0byBhc3NlcnQgdGhlIHZhbHVlIG9yIG5vdCAoYXNzZXJ0cyBieSBkZWZhdWx0KVxyXG4gICAgICAgICAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgdmFsdWUgY2Fubm90IGJlIHNldFxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICBNZXNzYWdlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihrZXksIHZhbHVlLCBub0Fzc2VydCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmllbGQgPSBULmdldENoaWxkKGtleSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZmllbGQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcih0aGlzK1wiI1wiK2tleStcIiBpcyBub3QgYSBmaWVsZDogdW5kZWZpbmVkXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShmaWVsZCBpbnN0YW5jZW9mIFByb3RvQnVmLlJlZmxlY3QuTWVzc2FnZS5GaWVsZCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcih0aGlzK1wiI1wiK2tleStcIiBpcyBub3QgYSBmaWVsZDogXCIrZmllbGQudG9TdHJpbmcodHJ1ZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2ZpZWxkLm5hbWVdID0gbm9Bc3NlcnQgPyB2YWx1ZSA6IGZpZWxkLnZlcmlmeVZhbHVlKHZhbHVlKTsgLy8gTWF5IHRocm93XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICogU2V0cyBhIGZpZWxkJ3MgdmFsdWUuIFRoaXMgaXMgYW4gYWxpYXMgZm9yIFtAbGluayBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2Ujc2V0fS5cclxuICAgICAgICAgICAgICAgICAgICAgKiBAbmFtZSBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UjJHNldFxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgS2V5XHJcbiAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byBzZXRcclxuICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBub0Fzc2VydCBXaGV0aGVyIHRvIGFzc2VydCB0aGUgdmFsdWUgb3Igbm90IChhc3NlcnRzIGJ5IGRlZmF1bHQpXHJcbiAgICAgICAgICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSB2YWx1ZSBjYW5ub3QgYmUgc2V0XHJcbiAgICAgICAgICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgIE1lc3NhZ2UucHJvdG90eXBlLiRzZXQgPSBNZXNzYWdlLnByb3RvdHlwZS5zZXQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAqIEdldHMgYSBmaWVsZCdzIHZhbHVlLlxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBuYW1lIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZSNnZXRcclxuICAgICAgICAgICAgICAgICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IEtleVxyXG4gICAgICAgICAgICAgICAgICAgICAqIEByZXR1cm4geyp9IFZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZXJlIGlzIG5vIHN1Y2ggZmllbGRcclxuICAgICAgICAgICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgTWVzc2FnZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oa2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmaWVsZCA9IFQuZ2V0Q2hpbGQoa2V5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFmaWVsZCB8fCAhKGZpZWxkIGluc3RhbmNlb2YgUHJvdG9CdWYuUmVmbGVjdC5NZXNzYWdlLkZpZWxkKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKHRoaXMrXCIjXCIra2V5K1wiIGlzIG5vdCBhIGZpZWxkOiB1bmRlZmluZWRcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGZpZWxkIGluc3RhbmNlb2YgUHJvdG9CdWYuUmVmbGVjdC5NZXNzYWdlLkZpZWxkKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKHRoaXMrXCIjXCIra2V5K1wiIGlzIG5vdCBhIGZpZWxkOiBcIitmaWVsZC50b1N0cmluZyh0cnVlKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW2ZpZWxkLm5hbWVdO1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAqIEdldHMgYSBmaWVsZCdzIHZhbHVlLiBUaGlzIGlzIGFuIGFsaWFzIGZvciB7QGxpbmsgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlIyRnZXR9LlxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBuYW1lIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZSMkZ2V0XHJcbiAgICAgICAgICAgICAgICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBLZXlcclxuICAgICAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIHsqfSBWYWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGVyZSBpcyBubyBzdWNoIGZpZWxkXHJcbiAgICAgICAgICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgIE1lc3NhZ2UucHJvdG90eXBlLiRnZXQgPSBNZXNzYWdlLnByb3RvdHlwZS5nZXQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEdldHRlcnMgYW5kIHNldHRlcnNcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpPGZpZWxkcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmllbGQgPSBmaWVsZHNbaV07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAoZnVuY3Rpb24oZmllbGQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNldC9nZXRbU29tZVZhbHVlXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIE5hbWUgPSBmaWVsZC5vcmlnaW5hbE5hbWUucmVwbGFjZSgvKF9bYS16QS1aXSkvZywgZnVuY3Rpb24obWF0Y2gpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2gudG9VcHBlckNhc2UoKS5yZXBsYWNlKCdfJywnJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE5hbWUgPSBOYW1lLnN1YnN0cmluZygwLDEpLnRvVXBwZXJDYXNlKCkrTmFtZS5zdWJzdHJpbmcoMSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2V0L2dldF9bc29tZV92YWx1ZV1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuYW1lID0gZmllbGQub3JpZ2luYWxOYW1lLnJlcGxhY2UoLyhbQS1aXSkvZywgZnVuY3Rpb24obWF0Y2gpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJfXCIrbWF0Y2g7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIFNldHMgYSB2YWx1ZS4gVGhpcyBtZXRob2QgaXMgcHJlc2VudCBmb3IgZWFjaCBmaWVsZCwgYnV0IG9ubHkgaWYgdGhlcmUgaXMgbm8gbmFtZSBjb25mbGljdCB3aXRoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBhbm90aGVyIGZpZWxkLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG5hbWUgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlI3NldFtTb21lRmllbGRdXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgdG8gc2V0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAYWJzdHJhY3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgdmFsdWUgY2Fubm90IGJlIHNldFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIVQuaGFzQ2hpbGQoXCJzZXRcIitOYW1lKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNZXNzYWdlLnByb3RvdHlwZVtcInNldFwiK05hbWVdID0gZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kc2V0KGZpZWxkLm5hbWUsIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogU2V0cyBhIHZhbHVlLiBUaGlzIG1ldGhvZCBpcyBwcmVzZW50IGZvciBlYWNoIGZpZWxkLCBidXQgb25seSBpZiB0aGVyZSBpcyBubyBuYW1lIGNvbmZsaWN0IHdpdGhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIGFub3RoZXIgZmllbGQuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbmFtZSBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2Ujc2V0X1tzb21lX2ZpZWxkXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIHNldFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGFic3RyYWN0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHZhbHVlIGNhbm5vdCBiZSBzZXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFULmhhc0NoaWxkKFwic2V0X1wiK25hbWUpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1lc3NhZ2UucHJvdG90eXBlW1wic2V0X1wiK25hbWVdID0gZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kc2V0KGZpZWxkLm5hbWUsIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogR2V0cyBhIHZhbHVlLiBUaGlzIG1ldGhvZCBpcyBwcmVzZW50IGZvciBlYWNoIGZpZWxkLCBidXQgb25seSBpZiB0aGVyZSBpcyBubyBuYW1lIGNvbmZsaWN0IHdpdGhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIGFub3RoZXIgZmllbGQuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbmFtZSBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UjZ2V0W1NvbWVGaWVsZF1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGFic3RyYWN0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIHsqfSBUaGUgdmFsdWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFULmhhc0NoaWxkKFwiZ2V0XCIrTmFtZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWVzc2FnZS5wcm90b3R5cGVbXCJnZXRcIitOYW1lXSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kZ2V0KGZpZWxkLm5hbWUpOyAvLyBEb2VzIG5vdCB0aHJvdywgZmllbGQgZXhpc3RzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogR2V0cyBhIHZhbHVlLiBUaGlzIG1ldGhvZCBpcyBwcmVzZW50IGZvciBlYWNoIGZpZWxkLCBidXQgb25seSBpZiB0aGVyZSBpcyBubyBuYW1lIGNvbmZsaWN0IHdpdGhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIGFub3RoZXIgZmllbGQuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbmFtZSBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UjZ2V0X1tzb21lX2ZpZWxkXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIHsqfSBUaGUgdmFsdWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIVQuaGFzQ2hpbGQoXCJnZXRfXCIrbmFtZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWVzc2FnZS5wcm90b3R5cGVbXCJnZXRfXCIrbmFtZV0gPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGdldChmaWVsZC5uYW1lKTsgLy8gRG9lcyBub3QgdGhyb3csIGZpZWxkIGV4aXN0c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KShmaWVsZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBFbi0vZGVjb2RpbmdcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICogRW5jb2RlcyB0aGUgbWVzc2FnZS5cclxuICAgICAgICAgICAgICAgICAgICAgKiBAbmFtZSBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UjJGVuY29kZVxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7KCFCeXRlQnVmZmVyfGJvb2xlYW4pPX0gYnVmZmVyIEJ5dGVCdWZmZXIgdG8gZW5jb2RlIHRvLiBXaWxsIGNyZWF0ZSBhIG5ldyBvbmUgYW5kIGZsaXAgaXQgaWYgb21pdHRlZC5cclxuICAgICAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIHshQnl0ZUJ1ZmZlcn0gRW5jb2RlZCBtZXNzYWdlIGFzIGEgQnl0ZUJ1ZmZlclxyXG4gICAgICAgICAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgbWVzc2FnZSBjYW5ub3QgYmUgZW5jb2RlZCBvciBpZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmcuIFRoZSBsYXRlciBzdGlsbFxyXG4gICAgICAgICAgICAgICAgICAgICAqICByZXR1cm5zIHRoZSBlbmNvZGVkIEJ5dGVCdWZmZXIgaW4gdGhlIGBlbmNvZGVkYCBwcm9wZXJ0eSBvbiB0aGUgZXJyb3IuXHJcbiAgICAgICAgICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBzZWUgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlI2VuY29kZTY0XHJcbiAgICAgICAgICAgICAgICAgICAgICogQHNlZSBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UjZW5jb2RlSGV4XHJcbiAgICAgICAgICAgICAgICAgICAgICogQHNlZSBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UjZW5jb2RlQUJcclxuICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICBNZXNzYWdlLnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbihidWZmZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlzTmV3ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYnVmZmVyKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyID0gbmV3IEJ5dGVCdWZmZXIoKSwgaXNOZXcgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGUgPSBidWZmZXIubGl0dGxlRW5kaWFuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgVC5lbmNvZGUodGhpcywgYnVmZmVyLkxFKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChpc05ldyA/IGJ1ZmZlci5mbGlwKCkgOiBidWZmZXIpLkxFKGxlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLkxFKGxlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93KGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICogQ2FsY3VsYXRlcyB0aGUgYnl0ZSBsZW5ndGggb2YgdGhlIG1lc3NhZ2UuXHJcbiAgICAgICAgICAgICAgICAgICAgICogQG5hbWUgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlI2NhbGN1bGF0ZVxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IEJ5dGUgbGVuZ3RoXHJcbiAgICAgICAgICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBtZXNzYWdlIGNhbm5vdCBiZSBjYWxjdWxhdGVkIG9yIGlmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZy5cclxuICAgICAgICAgICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgTWVzc2FnZS5wcm90b3R5cGUuY2FsY3VsYXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBULmNhbGN1bGF0ZSh0aGlzKTtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAgICAgKiBFbmNvZGVzIHRoZSB2YXJpbnQzMiBsZW5ndGgtZGVsaW1pdGVkIG1lc3NhZ2UuXHJcbiAgICAgICAgICAgICAgICAgICAgICogQG5hbWUgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlI2VuY29kZURlbGltaXRlZFxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7KCFCeXRlQnVmZmVyfGJvb2xlYW4pPX0gYnVmZmVyIEJ5dGVCdWZmZXIgdG8gZW5jb2RlIHRvLiBXaWxsIGNyZWF0ZSBhIG5ldyBvbmUgYW5kIGZsaXAgaXQgaWYgb21pdHRlZC5cclxuICAgICAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIHshQnl0ZUJ1ZmZlcn0gRW5jb2RlZCBtZXNzYWdlIGFzIGEgQnl0ZUJ1ZmZlclxyXG4gICAgICAgICAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgbWVzc2FnZSBjYW5ub3QgYmUgZW5jb2RlZCBvciBpZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmcuIFRoZSBsYXRlciBzdGlsbFxyXG4gICAgICAgICAgICAgICAgICAgICAqICByZXR1cm5zIHRoZSBlbmNvZGVkIEJ5dGVCdWZmZXIgaW4gdGhlIGBlbmNvZGVkYCBwcm9wZXJ0eSBvbiB0aGUgZXJyb3IuXHJcbiAgICAgICAgICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgIE1lc3NhZ2UucHJvdG90eXBlLmVuY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXNOZXcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFidWZmZXIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIgPSBuZXcgQnl0ZUJ1ZmZlcigpLCBpc05ldyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbmMgPSBuZXcgQnl0ZUJ1ZmZlcigpLkxFKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFQuZW5jb2RlKHRoaXMsIGVuYykuZmxpcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIud3JpdGVWYXJpbnQzMihlbmMucmVtYWluaW5nKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIuYXBwZW5kKGVuYyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpc05ldyA/IGJ1ZmZlci5mbGlwKCkgOiBidWZmZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICogRGlyZWN0bHkgZW5jb2RlcyB0aGUgbWVzc2FnZSB0byBhbiBBcnJheUJ1ZmZlci5cclxuICAgICAgICAgICAgICAgICAgICAgKiBAbmFtZSBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UjZW5jb2RlQUJcclxuICAgICAgICAgICAgICAgICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIHtBcnJheUJ1ZmZlcn0gRW5jb2RlZCBtZXNzYWdlIGFzIEFycmF5QnVmZmVyXHJcbiAgICAgICAgICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBtZXNzYWdlIGNhbm5vdCBiZSBlbmNvZGVkIG9yIGlmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZy4gVGhlIGxhdGVyIHN0aWxsXHJcbiAgICAgICAgICAgICAgICAgICAgICogIHJldHVybnMgdGhlIGVuY29kZWQgQXJyYXlCdWZmZXIgaW4gdGhlIGBlbmNvZGVkYCBwcm9wZXJ0eSBvbiB0aGUgZXJyb3IuXHJcbiAgICAgICAgICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgIE1lc3NhZ2UucHJvdG90eXBlLmVuY29kZUFCID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGUoKS50b0FycmF5QnVmZmVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlW1wiZW5jb2RlZFwiXSkgZVtcImVuY29kZWRcIl0gPSBlW1wiZW5jb2RlZFwiXS50b0FycmF5QnVmZmVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyhlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAqIFJldHVybnMgdGhlIG1lc3NhZ2UgYXMgYW4gQXJyYXlCdWZmZXIuIFRoaXMgaXMgYW4gYWxpYXMgZm9yIHtAbGluayBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UjZW5jb2RlQUJ9LlxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBuYW1lIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZSN0b0FycmF5QnVmZmVyXHJcbiAgICAgICAgICAgICAgICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICogQHJldHVybiB7QXJyYXlCdWZmZXJ9IEVuY29kZWQgbWVzc2FnZSBhcyBBcnJheUJ1ZmZlclxyXG4gICAgICAgICAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgbWVzc2FnZSBjYW5ub3QgYmUgZW5jb2RlZCBvciBpZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmcuIFRoZSBsYXRlciBzdGlsbFxyXG4gICAgICAgICAgICAgICAgICAgICAqICByZXR1cm5zIHRoZSBlbmNvZGVkIEFycmF5QnVmZmVyIGluIHRoZSBgZW5jb2RlZGAgcHJvcGVydHkgb24gdGhlIGVycm9yLlxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICBNZXNzYWdlLnByb3RvdHlwZS50b0FycmF5QnVmZmVyID0gTWVzc2FnZS5wcm90b3R5cGUuZW5jb2RlQUI7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAqIERpcmVjdGx5IGVuY29kZXMgdGhlIG1lc3NhZ2UgdG8gYSBub2RlIEJ1ZmZlci5cclxuICAgICAgICAgICAgICAgICAgICAgKiBAbmFtZSBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UjZW5jb2RlTkJcclxuICAgICAgICAgICAgICAgICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIHshQnVmZmVyfVxyXG4gICAgICAgICAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgbWVzc2FnZSBjYW5ub3QgYmUgZW5jb2RlZCwgbm90IHJ1bm5pbmcgdW5kZXIgbm9kZS5qcyBvciBpZiByZXF1aXJlZCBmaWVsZHMgYXJlXHJcbiAgICAgICAgICAgICAgICAgICAgICogIG1pc3NpbmcuIFRoZSBsYXRlciBzdGlsbCByZXR1cm5zIHRoZSBlbmNvZGVkIG5vZGUgQnVmZmVyIGluIHRoZSBgZW5jb2RlZGAgcHJvcGVydHkgb24gdGhlIGVycm9yLlxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICBNZXNzYWdlLnByb3RvdHlwZS5lbmNvZGVOQiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlKCkudG9CdWZmZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVbXCJlbmNvZGVkXCJdKSBlW1wiZW5jb2RlZFwiXSA9IGVbXCJlbmNvZGVkXCJdLnRvQnVmZmVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyhlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAqIFJldHVybnMgdGhlIG1lc3NhZ2UgYXMgYSBub2RlIEJ1ZmZlci4gVGhpcyBpcyBhbiBhbGlhcyBmb3Ige0BsaW5rIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZSNlbmNvZGVOQn0uXHJcbiAgICAgICAgICAgICAgICAgICAgICogQG5hbWUgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlI3RvQnVmZmVyXHJcbiAgICAgICAgICAgICAgICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICogQHJldHVybiB7IUJ1ZmZlcn1cclxuICAgICAgICAgICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIG1lc3NhZ2UgY2Fubm90IGJlIGVuY29kZWQgb3IgaWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nLiBUaGUgbGF0ZXIgc3RpbGxcclxuICAgICAgICAgICAgICAgICAgICAgKiAgcmV0dXJucyB0aGUgZW5jb2RlZCBub2RlIEJ1ZmZlciBpbiB0aGUgYGVuY29kZWRgIHByb3BlcnR5IG9uIHRoZSBlcnJvci5cclxuICAgICAgICAgICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgTWVzc2FnZS5wcm90b3R5cGUudG9CdWZmZXIgPSBNZXNzYWdlLnByb3RvdHlwZS5lbmNvZGVOQjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICogRGlyZWN0bHkgZW5jb2RlcyB0aGUgbWVzc2FnZSB0byBhIGJhc2U2NCBlbmNvZGVkIHN0cmluZy5cclxuICAgICAgICAgICAgICAgICAgICAgKiBAbmFtZSBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UjZW5jb2RlNjRcclxuICAgICAgICAgICAgICAgICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IEJhc2U2NCBlbmNvZGVkIHN0cmluZ1xyXG4gICAgICAgICAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgdW5kZXJseWluZyBidWZmZXIgY2Fubm90IGJlIGVuY29kZWQgb3IgaWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nLiBUaGUgbGF0ZXJcclxuICAgICAgICAgICAgICAgICAgICAgKiAgc3RpbGwgcmV0dXJucyB0aGUgZW5jb2RlZCBiYXNlNjQgc3RyaW5nIGluIHRoZSBgZW5jb2RlZGAgcHJvcGVydHkgb24gdGhlIGVycm9yLlxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICBNZXNzYWdlLnByb3RvdHlwZS5lbmNvZGU2NCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlKCkudG9CYXNlNjQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVbXCJlbmNvZGVkXCJdKSBlW1wiZW5jb2RlZFwiXSA9IGVbXCJlbmNvZGVkXCJdLnRvQmFzZTY0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyhlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAqIFJldHVybnMgdGhlIG1lc3NhZ2UgYXMgYSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcuIFRoaXMgaXMgYW4gYWxpYXMgZm9yIHtAbGluayBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UjZW5jb2RlNjR9LlxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBuYW1lIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZSN0b0Jhc2U2NFxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gQmFzZTY0IGVuY29kZWQgc3RyaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBtZXNzYWdlIGNhbm5vdCBiZSBlbmNvZGVkIG9yIGlmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZy4gVGhlIGxhdGVyIHN0aWxsXHJcbiAgICAgICAgICAgICAgICAgICAgICogIHJldHVybnMgdGhlIGVuY29kZWQgYmFzZTY0IHN0cmluZyBpbiB0aGUgYGVuY29kZWRgIHByb3BlcnR5IG9uIHRoZSBlcnJvci5cclxuICAgICAgICAgICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgTWVzc2FnZS5wcm90b3R5cGUudG9CYXNlNjQgPSBNZXNzYWdlLnByb3RvdHlwZS5lbmNvZGU2NDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICogRGlyZWN0bHkgZW5jb2RlcyB0aGUgbWVzc2FnZSB0byBhIGhleCBlbmNvZGVkIHN0cmluZy5cclxuICAgICAgICAgICAgICAgICAgICAgKiBAbmFtZSBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UjZW5jb2RlSGV4XHJcbiAgICAgICAgICAgICAgICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBIZXggZW5jb2RlZCBzdHJpbmdcclxuICAgICAgICAgICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHVuZGVybHlpbmcgYnVmZmVyIGNhbm5vdCBiZSBlbmNvZGVkIG9yIGlmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZy4gVGhlIGxhdGVyXHJcbiAgICAgICAgICAgICAgICAgICAgICogIHN0aWxsIHJldHVybnMgdGhlIGVuY29kZWQgaGV4IHN0cmluZyBpbiB0aGUgYGVuY29kZWRgIHByb3BlcnR5IG9uIHRoZSBlcnJvci5cclxuICAgICAgICAgICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgTWVzc2FnZS5wcm90b3R5cGUuZW5jb2RlSGV4ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGUoKS50b0hleCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZVtcImVuY29kZWRcIl0pIGVbXCJlbmNvZGVkXCJdID0gZVtcImVuY29kZWRcIl0udG9IZXgoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93KGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICogUmV0dXJucyB0aGUgbWVzc2FnZSBhcyBhIGhleCBlbmNvZGVkIHN0cmluZy4gVGhpcyBpcyBhbiBhbGlhcyBmb3Ige0BsaW5rIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZSNlbmNvZGVIZXh9LlxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBuYW1lIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZSN0b0hleFxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gSGV4IGVuY29kZWQgc3RyaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBtZXNzYWdlIGNhbm5vdCBiZSBlbmNvZGVkIG9yIGlmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZy4gVGhlIGxhdGVyIHN0aWxsXHJcbiAgICAgICAgICAgICAgICAgICAgICogIHJldHVybnMgdGhlIGVuY29kZWQgaGV4IHN0cmluZyBpbiB0aGUgYGVuY29kZWRgIHByb3BlcnR5IG9uIHRoZSBlcnJvci5cclxuICAgICAgICAgICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgTWVzc2FnZS5wcm90b3R5cGUudG9IZXggPSBNZXNzYWdlLnByb3RvdHlwZS5lbmNvZGVIZXg7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAqIENsb25lcyBhIG1lc3NhZ2Ugb2JqZWN0IHRvIGEgcmF3IG9iamVjdC5cclxuICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0geyp9IG9iaiBPYmplY3QgdG8gY2xvbmVcclxuICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGluY2x1ZGVCdWZmZXJzIFdoZXRoZXIgdG8gaW5jbHVkZSBuYXRpdmUgYnVmZmVyIGRhdGEgb3Igbm90XHJcbiAgICAgICAgICAgICAgICAgICAgICogQHJldHVybnMgeyp9IENsb25lZCBvYmplY3RcclxuICAgICAgICAgICAgICAgICAgICAgKiBAaW5uZXJcclxuICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBjbG9uZVJhdyhvYmosIGluY2x1ZGVCdWZmZXJzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjbG9uZSA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpIGluIG9iailcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoaSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob2JqW2ldID09PSBudWxsIHx8IHR5cGVvZiBvYmpbaV0gIT09ICdvYmplY3QnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9uZVtpXSA9IG9ialtpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChvYmpbaV0gaW5zdGFuY2VvZiBCeXRlQnVmZmVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmNsdWRlQnVmZmVycylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb25lW2ldID0gb2JqLnRvQnVmZmVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIC8vIGlzIGEgbm9uLW51bGwgb2JqZWN0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb25lW2ldID0gY2xvbmVSYXcob2JqW2ldLCBpbmNsdWRlQnVmZmVycyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjbG9uZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAqIFJldHVybnMgdGhlIG1lc3NhZ2UncyByYXcgcGF5bG9hZC5cclxuICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBpbmNsdWRlQnVmZmVycyBXaGV0aGVyIHRvIGluY2x1ZGUgbmF0aXZlIGJ1ZmZlciBkYXRhIG9yIG5vdCwgZGVmYXVsdHMgdG8gYGZhbHNlYFxyXG4gICAgICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gUmF3IHBheWxvYWRcclxuICAgICAgICAgICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgTWVzc2FnZS5wcm90b3R5cGUudG9SYXcgPSBmdW5jdGlvbihpbmNsdWRlQnVmZmVycykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2xvbmVSYXcodGhpcywgISFpbmNsdWRlQnVmZmVycyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICogRGVjb2RlcyBhIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIGJ1ZmZlciBvciBzdHJpbmcuXHJcbiAgICAgICAgICAgICAgICAgICAgICogQG5hbWUgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlLmRlY29kZVxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7IUJ5dGVCdWZmZXJ8IUFycmF5QnVmZmVyfCFCdWZmZXJ8c3RyaW5nfSBidWZmZXIgQnVmZmVyIHRvIGRlY29kZSBmcm9tXHJcbiAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmc9fSBlbmMgRW5jb2RpbmcgaWYgYnVmZmVyIGlzIGEgc3RyaW5nOiBoZXgsIHV0ZjggKG5vdCByZWNvbW1lbmRlZCksIGRlZmF1bHRzIHRvIGJhc2U2NFxyXG4gICAgICAgICAgICAgICAgICAgICAqIEByZXR1cm4geyFQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2V9IERlY29kZWQgbWVzc2FnZVxyXG4gICAgICAgICAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgbWVzc2FnZSBjYW5ub3QgYmUgZGVjb2RlZCBvciBpZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmcuIFRoZSBsYXRlciBzdGlsbFxyXG4gICAgICAgICAgICAgICAgICAgICAqICByZXR1cm5zIHRoZSBkZWNvZGVkIG1lc3NhZ2Ugd2l0aCBtaXNzaW5nIGZpZWxkcyBpbiB0aGUgYGRlY29kZWRgIHByb3BlcnR5IG9uIHRoZSBlcnJvci5cclxuICAgICAgICAgICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAgICAgICAgICogQHNlZSBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UuZGVjb2RlNjRcclxuICAgICAgICAgICAgICAgICAgICAgKiBAc2VlIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZS5kZWNvZGVIZXhcclxuICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICBNZXNzYWdlLmRlY29kZSA9IGZ1bmN0aW9uKGJ1ZmZlciwgZW5jKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYnVmZmVyID09PSAnc3RyaW5nJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlciA9IEJ5dGVCdWZmZXIud3JhcChidWZmZXIsIGVuYyA/IGVuYyA6IFwiYmFzZTY0XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIgPSBidWZmZXIgaW5zdGFuY2VvZiBCeXRlQnVmZmVyID8gYnVmZmVyIDogQnl0ZUJ1ZmZlci53cmFwKGJ1ZmZlcik7IC8vIE1heSB0aHJvd1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGUgPSBidWZmZXIubGl0dGxlRW5kaWFuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1zZyA9IFQuZGVjb2RlKGJ1ZmZlci5MRSgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci5MRShsZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbXNnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIuTEUobGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3coZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAgICAgKiBEZWNvZGVzIGEgdmFyaW50MzIgbGVuZ3RoLWRlbGltaXRlZCBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCBidWZmZXIgb3Igc3RyaW5nLlxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBuYW1lIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZS5kZWNvZGVEZWxpbWl0ZWRcclxuICAgICAgICAgICAgICAgICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0geyFCeXRlQnVmZmVyfCFBcnJheUJ1ZmZlcnwhQnVmZmVyfHN0cmluZ30gYnVmZmVyIEJ1ZmZlciB0byBkZWNvZGUgZnJvbVxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nPX0gZW5jIEVuY29kaW5nIGlmIGJ1ZmZlciBpcyBhIHN0cmluZzogaGV4LCB1dGY4IChub3QgcmVjb21tZW5kZWQpLCBkZWZhdWx0cyB0byBiYXNlNjRcclxuICAgICAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIHshUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlfSBEZWNvZGVkIG1lc3NhZ2VcclxuICAgICAgICAgICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIG1lc3NhZ2UgY2Fubm90IGJlIGRlY29kZWQgb3IgaWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nLiBUaGUgbGF0ZXIgc3RpbGxcclxuICAgICAgICAgICAgICAgICAgICAgKiAgcmV0dXJucyB0aGUgZGVjb2RlZCBtZXNzYWdlIHdpdGggbWlzc2luZyBmaWVsZHMgaW4gdGhlIGBkZWNvZGVkYCBwcm9wZXJ0eSBvbiB0aGUgZXJyb3IuXHJcbiAgICAgICAgICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgIE1lc3NhZ2UuZGVjb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24oYnVmZmVyLCBlbmMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBidWZmZXIgPT09ICdzdHJpbmcnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyID0gQnl0ZUJ1ZmZlci53cmFwKGJ1ZmZlciwgZW5jID8gZW5jIDogXCJiYXNlNjRcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlciA9IGJ1ZmZlciBpbnN0YW5jZW9mIEJ5dGVCdWZmZXIgPyBidWZmZXIgOiBCeXRlQnVmZmVyLndyYXAoYnVmZmVyKTsgLy8gTWF5IHRocm93XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsZW4gPSBidWZmZXIucmVhZFZhcmludDMyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtc2cgPSBULmRlY29kZShidWZmZXIuc2xpY2UoYnVmZmVyLm9mZnNldCwgYnVmZmVyLm9mZnNldCArIGxlbikuTEUoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci5vZmZzZXQgKz0gbGVuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbXNnO1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAqIERlY29kZXMgdGhlIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIGJhc2U2NCBlbmNvZGVkIHN0cmluZy5cclxuICAgICAgICAgICAgICAgICAgICAgKiBAbmFtZSBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UuZGVjb2RlNjRcclxuICAgICAgICAgICAgICAgICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIFN0cmluZyB0byBkZWNvZGUgZnJvbVxyXG4gICAgICAgICAgICAgICAgICAgICAqIEByZXR1cm4geyFQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2V9IERlY29kZWQgbWVzc2FnZVxyXG4gICAgICAgICAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgbWVzc2FnZSBjYW5ub3QgYmUgZGVjb2RlZCBvciBpZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmcuIFRoZSBsYXRlciBzdGlsbFxyXG4gICAgICAgICAgICAgICAgICAgICAqICByZXR1cm5zIHRoZSBkZWNvZGVkIG1lc3NhZ2Ugd2l0aCBtaXNzaW5nIGZpZWxkcyBpbiB0aGUgYGRlY29kZWRgIHByb3BlcnR5IG9uIHRoZSBlcnJvci5cclxuICAgICAgICAgICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgTWVzc2FnZS5kZWNvZGU2NCA9IGZ1bmN0aW9uKHN0cikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gTWVzc2FnZS5kZWNvZGUoc3RyLCBcImJhc2U2NFwiKTtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAgICAgKiBEZWNvZGVzIHRoZSBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCBoZXggZW5jb2RlZCBzdHJpbmcuXHJcbiAgICAgICAgICAgICAgICAgICAgICogQG5hbWUgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlLmRlY29kZUhleFxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgU3RyaW5nIHRvIGRlY29kZSBmcm9tXHJcbiAgICAgICAgICAgICAgICAgICAgICogQHJldHVybiB7IVByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZX0gRGVjb2RlZCBtZXNzYWdlXHJcbiAgICAgICAgICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBtZXNzYWdlIGNhbm5vdCBiZSBkZWNvZGVkIG9yIGlmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZy4gVGhlIGxhdGVyIHN0aWxsXHJcbiAgICAgICAgICAgICAgICAgICAgICogIHJldHVybnMgdGhlIGRlY29kZWQgbWVzc2FnZSB3aXRoIG1pc3NpbmcgZmllbGRzIGluIHRoZSBgZGVjb2RlZGAgcHJvcGVydHkgb24gdGhlIGVycm9yLlxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICBNZXNzYWdlLmRlY29kZUhleCA9IGZ1bmN0aW9uKHN0cikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gTWVzc2FnZS5kZWNvZGUoc3RyLCBcImhleFwiKTtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBVdGlsaXR5XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBNZXNzYWdlLlxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBuYW1lIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZSN0b1N0cmluZ1xyXG4gICAgICAgICAgICAgICAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gU3RyaW5nIHJlcHJlc2VudGF0aW9uIGFzIG9mIFwiLkZ1bGx5LlF1YWxpZmllZC5NZXNzYWdlTmFtZVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgIE1lc3NhZ2UucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBULnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gU3RhdGljXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAqIE9wdGlvbnMuXHJcbiAgICAgICAgICAgICAgICAgICAgICogQG5hbWUgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlLiRvcHRpb25zXHJcbiAgICAgICAgICAgICAgICAgICAgICogQHR5cGUge09iamVjdC48c3RyaW5nLCo+fVxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICB2YXIgJG9wdGlvbnM7IC8vIGZvciBjY1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWVzc2FnZSwgJyRvcHRpb25zJywgeyBcInZhbHVlXCI6IFQuYnVpbGRPcHQoKSB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1lc3NhZ2U7XHJcblxyXG4gICAgICAgICAgICAgICAgfSkoUHJvdG9CdWYsIHRoaXMpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFN0YXRpYyBlbnVtcyBhbmQgcHJvdG90eXBlZCBzdWItbWVzc2FnZXNcclxuICAgICAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuZ2V0Q2hpbGRyZW4oKTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGk9MDsgaTxjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZHJlbltpXSBpbnN0YW5jZW9mIEVudW0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXp6W2NoaWxkcmVuW2ldWyduYW1lJ11dID0gY2hpbGRyZW5baV0uYnVpbGQoKTtcclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjaGlsZHJlbltpXSBpbnN0YW5jZW9mIE1lc3NhZ2UpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXp6W2NoaWxkcmVuW2ldWyduYW1lJ11dID0gY2hpbGRyZW5baV0uYnVpbGQoKTtcclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjaGlsZHJlbltpXSBpbnN0YW5jZW9mIE1lc3NhZ2UuRmllbGQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlXHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCByZWZsZWN0IGNoaWxkIG9mIFwiK3RoaXMudG9TdHJpbmcodHJ1ZSkrXCI6IFwiK2NoaWxkcmVuW2ldLnRvU3RyaW5nKHRydWUpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNsYXp6ID0gY2xheno7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogRW5jb2RlcyBhIHJ1bnRpbWUgbWVzc2FnZSdzIGNvbnRlbnRzIHRvIHRoZSBzcGVjaWZpZWQgYnVmZmVyLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0geyFQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2V9IG1lc3NhZ2UgUnVudGltZSBtZXNzYWdlIHRvIGVuY29kZVxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0J5dGVCdWZmZXJ9IGJ1ZmZlciBCeXRlQnVmZmVyIHRvIHdyaXRlIHRvXHJcbiAgICAgICAgICAgICAqIEByZXR1cm4ge0J5dGVCdWZmZXJ9IFRoZSBCeXRlQnVmZmVyIGZvciBjaGFpbmluZ1xyXG4gICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nIG9yIHRoZSBtZXNzYWdlIGNhbm5vdCBiZSBlbmNvZGVkIGZvciBhbm90aGVyIHJlYXNvblxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBNZXNzYWdlLnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbihtZXNzYWdlLCBidWZmZXIpIHtcclxuICAgICAgICAgICAgICAgIHZhciBmaWVsZHMgPSB0aGlzLmdldENoaWxkcmVuKE1lc3NhZ2UuRmllbGQpLFxyXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkTWlzc2luZyA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpPTAsIHZhbDsgaTxmaWVsZHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWwgPSBtZXNzYWdlLiRnZXQoZmllbGRzW2ldLm5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChmaWVsZHNbaV0ucmVxdWlyZWQgJiYgdmFsID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaWVsZE1pc3NpbmcgPT09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWVsZE1pc3NpbmcgPSBmaWVsZHNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkc1tpXS5lbmNvZGUodmFsLCBidWZmZXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGZpZWxkTWlzc2luZyAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlcnIgPSBFcnJvcihcIk1pc3NpbmcgYXQgbGVhc3Qgb25lIHJlcXVpcmVkIGZpZWxkIGZvciBcIit0aGlzLnRvU3RyaW5nKHRydWUpK1wiOiBcIitmaWVsZE1pc3NpbmcpO1xyXG4gICAgICAgICAgICAgICAgICAgIGVycltcImVuY29kZWRcIl0gPSBidWZmZXI7IC8vIFN0aWxsIGV4cG9zZSB3aGF0IHdlIGdvdFxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93KGVycik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYnVmZmVyO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIENhbGN1bGF0ZXMgYSBydW50aW1lIG1lc3NhZ2UncyBieXRlIGxlbmd0aC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHshUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlfSBtZXNzYWdlIFJ1bnRpbWUgbWVzc2FnZSB0byBlbmNvZGVcclxuICAgICAgICAgICAgICogQHJldHVybnMge251bWJlcn0gQnl0ZSBsZW5ndGhcclxuICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZyBvciB0aGUgbWVzc2FnZSBjYW5ub3QgYmUgY2FsY3VsYXRlZCBmb3IgYW5vdGhlciByZWFzb25cclxuICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgTWVzc2FnZS5wcm90b3R5cGUuY2FsY3VsYXRlID0gZnVuY3Rpb24obWVzc2FnZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGZpZWxkcyA9IHRoaXMuZ2V0Q2hpbGRyZW4oTWVzc2FnZS5GaWVsZCksXHJcbiAgICAgICAgICAgICAgICAgICAgbiA9IDA7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpPTAsIHZhbDsgaTxmaWVsZHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWwgPSBtZXNzYWdlLiRnZXQoZmllbGRzW2ldLm5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChmaWVsZHNbaV0ucmVxdWlyZWQgJiYgdmFsID09PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiTWlzc2luZyBhdCBsZWFzdCBvbmUgcmVxdWlyZWQgZmllbGQgZm9yIFwiK3RoaXMudG9TdHJpbmcodHJ1ZSkrXCI6IFwiK2ZpZWxkc1tpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuICs9IGZpZWxkc1tpXS5jYWxjdWxhdGUodmFsKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBuO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFNraXBzIGFsbCBkYXRhIHVudGlsIHRoZSBlbmQgb2YgdGhlIHNwZWNpZmllZCBncm91cCBoYXMgYmVlbiByZWFjaGVkLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gZXhwZWN0ZWRJZCBFeHBlY3RlZCBHUk9VUEVORCBpZFxyXG4gICAgICAgICAgICAgKiBAcGFyYW0geyFCeXRlQnVmZmVyfSBidWYgQnl0ZUJ1ZmZlclxyXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIGEgdmFsdWUgYXMgYmVlbiBza2lwcGVkLCBgZmFsc2VgIGlmIHRoZSBlbmQgaGFzIGJlZW4gcmVhY2hlZFxyXG4gICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgaXQgd2Fzbid0IHBvc3NpYmxlIHRvIGZpbmQgdGhlIGVuZCBvZiB0aGUgZ3JvdXAgKGJ1ZmZlciBvdmVycnVuIG9yIGVuZCB0YWcgbWlzbWF0Y2gpXHJcbiAgICAgICAgICAgICAqIEBpbm5lclxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZnVuY3Rpb24gc2tpcFRpbGxHcm91cEVuZChleHBlY3RlZElkLCBidWYpIHtcclxuICAgICAgICAgICAgICAgIHZhciB0YWcgPSBidWYucmVhZFZhcmludDMyKCksIC8vIFRocm93cyBvbiBPT0JcclxuICAgICAgICAgICAgICAgICAgICB3aXJlVHlwZSA9IHRhZyAmIDB4MDcsXHJcbiAgICAgICAgICAgICAgICAgICAgaWQgPSB0YWcgPj4gMztcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAod2lyZVR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLldJUkVfVFlQRVMuVkFSSU5UOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkbyB0YWcgPSBidWYucmVhZFVpbnQ4KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICgodGFnICYgMHg4MCkgPT09IDB4ODApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLldJUkVfVFlQRVMuQklUUzY0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWYub2Zmc2V0ICs9IDg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuV0lSRV9UWVBFUy5MREVMSU06XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZyA9IGJ1Zi5yZWFkVmFyaW50MzIoKTsgLy8gcmVhZHMgdGhlIHZhcmludFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWYub2Zmc2V0ICs9IHRhZzsgICAgICAgIC8vIHNraXBzIG4gYnl0ZXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5XSVJFX1RZUEVTLlNUQVJUR1JPVVA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNraXBUaWxsR3JvdXBFbmQoaWQsIGJ1Zik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuV0lSRV9UWVBFUy5FTkRHUk9VUDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlkID09PSBleHBlY3RlZElkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIklsbGVnYWwgR1JPVVBFTkQgYWZ0ZXIgdW5rbm93biBncm91cDogXCIraWQrXCIgKFwiK2V4cGVjdGVkSWQrXCIgZXhwZWN0ZWQpXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuV0lSRV9UWVBFUy5CSVRTMzI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1Zi5vZmZzZXQgKz0gNDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIHdpcmUgdHlwZSBpbiB1bmtub3duIGdyb3VwIFwiK2V4cGVjdGVkSWQrXCI6IFwiK3dpcmVUeXBlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogRGVjb2RlcyBhbiBlbmNvZGVkIG1lc3NhZ2UgYW5kIHJldHVybnMgdGhlIGRlY29kZWQgbWVzc2FnZS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtCeXRlQnVmZmVyfSBidWZmZXIgQnl0ZUJ1ZmZlciB0byBkZWNvZGUgZnJvbVxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcj19IGxlbmd0aCBNZXNzYWdlIGxlbmd0aC4gRGVmYXVsdHMgdG8gZGVjb2RlIGFsbCB0aGUgYXZhaWxhYmxlIGRhdGEuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gZXhwZWN0ZWRHcm91cEVuZElkIEV4cGVjdGVkIEdST1VQRU5EIGlkIGlmIHRoaXMgaXMgYSBsZWdhY3kgZ3JvdXBcclxuICAgICAgICAgICAgICogQHJldHVybiB7UHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlfSBEZWNvZGVkIG1lc3NhZ2VcclxuICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBtZXNzYWdlIGNhbm5vdCBiZSBkZWNvZGVkXHJcbiAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIE1lc3NhZ2UucHJvdG90eXBlLmRlY29kZSA9IGZ1bmN0aW9uKGJ1ZmZlciwgbGVuZ3RoLCBleHBlY3RlZEdyb3VwRW5kSWQpIHtcclxuICAgICAgICAgICAgICAgIGxlbmd0aCA9IHR5cGVvZiBsZW5ndGggPT09ICdudW1iZXInID8gbGVuZ3RoIDogLTE7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnQgPSBidWZmZXIub2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgdmFyIG1zZyA9IG5ldyAodGhpcy5jbGF6eikoKTtcclxuICAgICAgICAgICAgICAgIHZhciB0YWcsIHdpcmVUeXBlLCBpZDtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChidWZmZXIub2Zmc2V0IDwgc3RhcnQrbGVuZ3RoIHx8IChsZW5ndGggPT0gLTEgJiYgYnVmZmVyLnJlbWFpbmluZygpID4gMCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0YWcgPSBidWZmZXIucmVhZFZhcmludDMyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgd2lyZVR5cGUgPSB0YWcgJiAweDA3O1xyXG4gICAgICAgICAgICAgICAgICAgIGlkID0gdGFnID4+IDM7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHdpcmVUeXBlID09PSBQcm90b0J1Zi5XSVJFX1RZUEVTLkVOREdST1VQKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpZCAhPT0gZXhwZWN0ZWRHcm91cEVuZElkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIGdyb3VwIGVuZCBpbmRpY2F0b3IgZm9yIFwiK3RoaXMudG9TdHJpbmcodHJ1ZSkrXCI6IFwiK2lkK1wiIChcIisoZXhwZWN0ZWRHcm91cEVuZElkID8gZXhwZWN0ZWRHcm91cEVuZElkK1wiIGV4cGVjdGVkXCIgOiBcIm5vdCBhIGdyb3VwXCIpK1wiKVwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBmaWVsZCA9IHRoaXMuZ2V0Q2hpbGQoaWQpOyAvLyBNZXNzYWdlLkZpZWxkIG9ubHlcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWZpZWxkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFwibWVzc2FnZXMgY3JlYXRlZCBieSB5b3VyIG5ldyBjb2RlIGNhbiBiZSBwYXJzZWQgYnkgeW91ciBvbGQgY29kZTogb2xkIGJpbmFyaWVzIHNpbXBseSBpZ25vcmUgdGhlIG5ldyBmaWVsZCB3aGVuIHBhcnNpbmcuXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh3aXJlVHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5XSVJFX1RZUEVTLlZBUklOVDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIucmVhZFZhcmludDMyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLldJUkVfVFlQRVMuQklUUzMyOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci5vZmZzZXQgKz0gNDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuV0lSRV9UWVBFUy5CSVRTNjQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLm9mZnNldCArPSA4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5XSVJFX1RZUEVTLkxERUxJTTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGVuID0gYnVmZmVyLnJlYWRWYXJpbnQzMigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci5vZmZzZXQgKz0gbGVuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5XSVJFX1RZUEVTLlNUQVJUR1JPVVA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHNraXBUaWxsR3JvdXBFbmQoaWQsIGJ1ZmZlcikpIHt9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCB3aXJlIHR5cGUgZm9yIHVua25vd24gZmllbGQgXCIraWQrXCIgaW4gXCIrdGhpcy50b1N0cmluZyh0cnVlKStcIiNkZWNvZGU6IFwiK3dpcmVUeXBlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpZWxkLnJlcGVhdGVkICYmICFmaWVsZC5vcHRpb25zW1wicGFja2VkXCJdKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtc2cuJGFkZChmaWVsZC5uYW1lLCBmaWVsZC5kZWNvZGUod2lyZVR5cGUsIGJ1ZmZlciksIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgbXNnLiRzZXQoZmllbGQubmFtZSwgZmllbGQuZGVjb2RlKHdpcmVUeXBlLCBidWZmZXIpLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBhbGwgcmVxdWlyZWQgZmllbGRzIGFyZSBwcmVzZW50XHJcbiAgICAgICAgICAgICAgICB2YXIgZmllbGRzID0gdGhpcy5nZXRDaGlsZHJlbihQcm90b0J1Zi5SZWZsZWN0LkZpZWxkKTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGk9MDsgaTxmaWVsZHMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpZWxkc1tpXS5yZXF1aXJlZCAmJiBtc2dbZmllbGRzW2ldLm5hbWVdID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlcnIgPSBFcnJvcihcIk1pc3NpbmcgYXQgbGVhc3Qgb25lIHJlcXVpcmVkIGZpZWxkIGZvciBcIit0aGlzLnRvU3RyaW5nKHRydWUpK1wiOiBcIitmaWVsZHNbaV0ubmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycltcImRlY29kZWRcIl0gPSBtc2c7IC8vIFN0aWxsIGV4cG9zZSB3aGF0IHdlIGdvdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyhlcnIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBtc2c7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQGFsaWFzIFByb3RvQnVmLlJlZmxlY3QuTWVzc2FnZVxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBSZWZsZWN0Lk1lc3NhZ2UgPSBNZXNzYWdlO1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgTWVzc2FnZSBGaWVsZC5cclxuICAgICAgICAgICAgICogQGV4cG9ydHMgUHJvdG9CdWYuUmVmbGVjdC5NZXNzYWdlLkZpZWxkXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7UHJvdG9CdWYuUmVmbGVjdC5NZXNzYWdlfSBtZXNzYWdlIE1lc3NhZ2UgcmVmZXJlbmNlXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBydWxlIFJ1bGUsIG9uZSBvZiByZXF1cmllZCwgb3B0aW9uYWwsIHJlcGVhdGVkXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIERhdGEgdHlwZSwgZS5nLiBpbnQzMlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBGaWVsZCBuYW1lXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpZCBVbmlxdWUgZmllbGQgaWRcclxuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZy4qPj19IG9wdGlvbnMgT3B0aW9uc1xyXG4gICAgICAgICAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAgICAgICAgICogQGV4dGVuZHMgUHJvdG9CdWYuUmVmbGVjdC5UXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB2YXIgRmllbGQgPSBmdW5jdGlvbihtZXNzYWdlLCBydWxlLCB0eXBlLCBuYW1lLCBpZCwgb3B0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgVC5jYWxsKHRoaXMsIG1lc3NhZ2UsIG5hbWUpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQG92ZXJyaWRlXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuY2xhc3NOYW1lID0gXCJNZXNzYWdlLkZpZWxkXCI7XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBNZXNzYWdlIGZpZWxkIHJlcXVpcmVkIGZsYWcuXHJcbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZXF1aXJlZCA9IHJ1bGUgPT0gXCJyZXF1aXJlZFwiO1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogTWVzc2FnZSBmaWVsZCByZXBlYXRlZCBmbGFnLlxyXG4gICAgICAgICAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMucmVwZWF0ZWQgPSBydWxlID09IFwicmVwZWF0ZWRcIjtcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIE1lc3NhZ2UgZmllbGQgdHlwZS4gVHlwZSByZWZlcmVuY2Ugc3RyaW5nIGlmIHVucmVzb2x2ZWQsIHByb3RvYnVmIHR5cGUgaWYgcmVzb2x2ZWQuXHJcbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfHtuYW1lOiBzdHJpbmcsIHdpcmVUeXBlOiBudW1iZXJ9fVxyXG4gICAgICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogUmVzb2x2ZWQgdHlwZSByZWZlcmVuY2UgaW5zaWRlIHRoZSBnbG9iYWwgbmFtZXNwYWNlLlxyXG4gICAgICAgICAgICAgICAgICogQHR5cGUge1Byb3RvQnVmLlJlZmxlY3QuVHxudWxsfVxyXG4gICAgICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlc29sdmVkVHlwZSA9IG51bGw7XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBVbmlxdWUgbWVzc2FnZSBmaWVsZCBpZC5cclxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuaWQgPSBpZDtcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIE1lc3NhZ2UgZmllbGQgb3B0aW9ucy5cclxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHshT2JqZWN0LjxzdHJpbmcsKj59XHJcbiAgICAgICAgICAgICAgICAgKiBAZGljdFxyXG4gICAgICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogT3JpZ2luYWwgZmllbGQgbmFtZS5cclxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICAgICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMub3JpZ2luYWxOYW1lID0gdGhpcy5uYW1lOyAvLyBVc2VkIHRvIHJldmVydCBjYW1lbGNhc2UgdHJhbnNmb3JtYXRpb24gb24gbmFtaW5nIGNvbGxpc2lvbnNcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDb252ZXJ0IGZpZWxkIG5hbWVzIHRvIGNhbWVsIGNhc2Ugbm90YXRpb24gaWYgdGhlIG92ZXJyaWRlIGlzIHNldFxyXG4gICAgICAgICAgICAgICAgaWYgKFByb3RvQnVmLmNvbnZlcnRGaWVsZHNUb0NhbWVsQ2FzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubmFtZSA9IHRoaXMubmFtZS5yZXBsYWNlKC9fKFthLXpBLVpdKS9nLCBmdW5jdGlvbigkMCwgJDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICQxLnRvVXBwZXJDYXNlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvLyBFeHRlbmRzIFRcclxuICAgICAgICAgICAgRmllbGQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShULnByb3RvdHlwZSk7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogTWFrZXMgYSBMb25nIGZyb20gYSB2YWx1ZS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHt7bG93OiBudW1iZXIsIGhpZ2g6IG51bWJlciwgdW5zaWduZWQ6IGJvb2xlYW59fHN0cmluZ3xudW1iZXJ9IHZhbHVlIFZhbHVlXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byByZXVzZSBpdCBmcm9tIExvbmctbGlrZSBvYmplY3RzIG9yIHRvIHNpZ25lZCBmb3JcclxuICAgICAgICAgICAgICogIHN0cmluZ3MgYW5kIG51bWJlcnNcclxuICAgICAgICAgICAgICogQHJldHVybnMgeyFMb25nfVxyXG4gICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHZhbHVlIGNhbm5vdCBiZSBjb252ZXJ0ZWQgdG8gYSBMb25nXHJcbiAgICAgICAgICAgICAqIEBpbm5lclxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZnVuY3Rpb24gbWtMb25nKHZhbHVlLCB1bnNpZ25lZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZS5sb3cgPT09ICdudW1iZXInICYmIHR5cGVvZiB2YWx1ZS5oaWdoID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgdmFsdWUudW5zaWduZWQgPT09ICdib29sZWFuJ1xyXG4gICAgICAgICAgICAgICAgICAgICYmIHZhbHVlLmxvdyA9PT0gdmFsdWUubG93ICYmIHZhbHVlLmhpZ2ggPT09IHZhbHVlLmhpZ2gpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm90b0J1Zi5Mb25nKHZhbHVlLmxvdywgdmFsdWUuaGlnaCwgdHlwZW9mIHVuc2lnbmVkID09PSAndW5kZWZpbmVkJyA/IHZhbHVlLnVuc2lnbmVkIDogdW5zaWduZWQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb3RvQnVmLkxvbmcuZnJvbVN0cmluZyh2YWx1ZSwgdW5zaWduZWQgfHwgZmFsc2UsIDEwKTtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm90b0J1Zi5Mb25nLmZyb21OdW1iZXIodmFsdWUsIHVuc2lnbmVkIHx8IGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwibm90IGNvbnZlcnRpYmxlIHRvIExvbmdcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBDaGVja3MgaWYgdGhlIGdpdmVuIHZhbHVlIGNhbiBiZSBzZXQgZm9yIHRoaXMgZmllbGQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgdG8gY2hlY2tcclxuICAgICAgICAgICAgICogQHBhcmFtIHtib29sZWFuPX0gc2tpcFJlcGVhdGVkIFdoZXRoZXIgdG8gc2tpcCB0aGUgcmVwZWF0ZWQgdmFsdWUgY2hlY2sgb3Igbm90LiBEZWZhdWx0cyB0byBmYWxzZS5cclxuICAgICAgICAgICAgICogQHJldHVybiB7Kn0gVmVyaWZpZWQsIG1heWJlIGFkanVzdGVkLCB2YWx1ZVxyXG4gICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHZhbHVlIGNhbm5vdCBiZSBzZXQgZm9yIHRoaXMgZmllbGRcclxuICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgRmllbGQucHJvdG90eXBlLnZlcmlmeVZhbHVlID0gZnVuY3Rpb24odmFsdWUsIHNraXBSZXBlYXRlZCkge1xyXG4gICAgICAgICAgICAgICAgc2tpcFJlcGVhdGVkID0gc2tpcFJlcGVhdGVkIHx8IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgdmFyIGZhaWwgPSBmdW5jdGlvbih2YWwsIG1zZykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCB2YWx1ZSBmb3IgXCIrdGhpcy50b1N0cmluZyh0cnVlKStcIiBvZiB0eXBlIFwiK3RoaXMudHlwZS5uYW1lK1wiOiBcIit2YWwrXCIgKFwiK21zZytcIilcIik7XHJcbiAgICAgICAgICAgICAgICB9LmJpbmQodGhpcyk7XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHsgLy8gTlVMTCB2YWx1ZXMgZm9yIG9wdGlvbmFsIGZpZWxkc1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlcXVpcmVkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWlsKHR5cGVvZiB2YWx1ZSwgXCJyZXF1aXJlZFwiKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmVwZWF0ZWQgJiYgIXNraXBSZXBlYXRlZCkgeyAvLyBSZXBlYXRlZCB2YWx1ZXMgYXMgYXJyYXlzXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFQcm90b0J1Zi5VdGlsLmlzQXJyYXkodmFsdWUpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IFt2YWx1ZV07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlcyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaT0wOyBpPHZhbHVlLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXMucHVzaCh0aGlzLnZlcmlmeVZhbHVlKHZhbHVlW2ldLCB0cnVlKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIEFsbCBub24tcmVwZWF0ZWQgZmllbGRzIGV4cGVjdCBubyBhcnJheVxyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnJlcGVhdGVkICYmIFByb3RvQnVmLlV0aWwuaXNBcnJheSh2YWx1ZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgZmFpbCh0eXBlb2YgdmFsdWUsIFwibm8gYXJyYXkgZXhwZWN0ZWRcIik7XHJcblxyXG4gICAgICAgICAgICAgICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBTaWduZWQgMzJiaXRcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiaW50MzJcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInNpbnQzMlwiXTpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wic2ZpeGVkMzJcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFjY291bnQgZm9yICFOYU46IHZhbHVlID09PSB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJyB8fCAodmFsdWUgPT09IHZhbHVlICYmIHZhbHVlICUgMSAhPT0gMCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWlsKHR5cGVvZiB2YWx1ZSwgXCJub3QgYW4gaW50ZWdlclwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlID4gNDI5NDk2NzI5NSA/IHZhbHVlIHwgMCA6IHZhbHVlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBVbnNpZ25lZCAzMmJpdFxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJ1aW50MzJcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImZpeGVkMzJcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInIHx8ICh2YWx1ZSA9PT0gdmFsdWUgJiYgdmFsdWUgJSAxICE9PSAwKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhaWwodHlwZW9mIHZhbHVlLCBcIm5vdCBhbiBpbnRlZ2VyXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgPCAwID8gdmFsdWUgPj4+IDAgOiB2YWx1ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gU2lnbmVkIDY0Yml0XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImludDY0XCJdOlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJzaW50NjRcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInNmaXhlZDY0XCJdOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChQcm90b0J1Zi5Mb25nKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWtMb25nKHZhbHVlLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFpbCh0eXBlb2YgdmFsdWUsIGUubWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhaWwodHlwZW9mIHZhbHVlLCBcInJlcXVpcmVzIExvbmcuanNcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBVbnNpZ25lZCA2NGJpdFxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJ1aW50NjRcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImZpeGVkNjRcIl06IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFByb3RvQnVmLkxvbmcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBta0xvbmcodmFsdWUsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhaWwodHlwZW9mIHZhbHVlLCBlLm1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWlsKHR5cGVvZiB2YWx1ZSwgXCJyZXF1aXJlcyBMb25nLmpzXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQm9vbFxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJib29sXCJdOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnYm9vbGVhbicpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWlsKHR5cGVvZiB2YWx1ZSwgXCJub3QgYSBib29sZWFuXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEZsb2F0XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImZsb2F0XCJdOlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJkb3VibGVcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFpbCh0eXBlb2YgdmFsdWUsIFwibm90IGEgbnVtYmVyXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIExlbmd0aC1kZWxpbWl0ZWQgc3RyaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInN0cmluZ1wiXTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycgJiYgISh2YWx1ZSAmJiB2YWx1ZSBpbnN0YW5jZW9mIFN0cmluZykpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWlsKHR5cGVvZiB2YWx1ZSwgXCJub3QgYSBzdHJpbmdcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlwiK3ZhbHVlOyAvLyBDb252ZXJ0IFN0cmluZyBvYmplY3QgdG8gc3RyaW5nXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIExlbmd0aC1kZWxpbWl0ZWQgYnl0ZXNcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiYnl0ZXNcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSAmJiB2YWx1ZSBpbnN0YW5jZW9mIEJ5dGVCdWZmZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gdmFsdWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogQnl0ZUJ1ZmZlci53cmFwKHZhbHVlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ29uc3RhbnQgZW51bSB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJlbnVtXCJdOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZXMgPSB0aGlzLnJlc29sdmVkVHlwZS5nZXRDaGlsZHJlbihFbnVtLlZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpPTA7IGk8dmFsdWVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWVzW2ldLm5hbWUgPT0gdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVzW2ldLmlkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZXNbaV0uaWQgPT0gdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVzW2ldLmlkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhaWwodmFsdWUsIFwibm90IGEgdmFsaWQgZW51bSB2YWx1ZVwiKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRW1iZWRkZWQgbWVzc2FnZVxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJncm91cFwiXTpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wibWVzc2FnZVwiXToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXZhbHVlIHx8IHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWlsKHR5cGVvZiB2YWx1ZSwgXCJvYmplY3QgZXhwZWN0ZWRcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIHRoaXMucmVzb2x2ZWRUeXBlLmNsYXp6KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFbHNlIGxldCdzIHRyeSB0byBjb25zdHJ1Y3Qgb25lIGZyb20gYSBrZXktdmFsdWUgb2JqZWN0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgKHRoaXMucmVzb2x2ZWRUeXBlLmNsYXp6KSh2YWx1ZSk7IC8vIE1heSB0aHJvdyBmb3IgYSBodW5kcmVkIG9mIHJlYXNvbnNcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gV2Ugc2hvdWxkIG5ldmVyIGVuZCBoZXJlXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIltJTlRFUk5BTF0gSWxsZWdhbCB2YWx1ZSBmb3IgXCIrdGhpcy50b1N0cmluZyh0cnVlKStcIjogXCIrdmFsdWUrXCIgKHVuZGVmaW5lZCB0eXBlIFwiK3RoaXMudHlwZStcIilcIik7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIGZpZWxkIHZhbHVlIHRvIHRoZSBzcGVjaWZpZWQgYnVmZmVyLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0geyp9IHZhbHVlIEZpZWxkIHZhbHVlXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7Qnl0ZUJ1ZmZlcn0gYnVmZmVyIEJ5dGVCdWZmZXIgdG8gZW5jb2RlIHRvXHJcbiAgICAgICAgICAgICAqIEByZXR1cm4ge0J5dGVCdWZmZXJ9IFRoZSBCeXRlQnVmZmVyIGZvciBjaGFpbmluZ1xyXG4gICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGZpZWxkIGNhbm5vdCBiZSBlbmNvZGVkXHJcbiAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEZpZWxkLnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbih2YWx1ZSwgYnVmZmVyKSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMudmVyaWZ5VmFsdWUodmFsdWUpOyAvLyBNYXkgdGhyb3dcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnR5cGUgPT09IG51bGwgfHwgdHlwZW9mIHRoaXMudHlwZSAhPT0gJ29iamVjdCcpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJbSU5URVJOQUxdIFVucmVzb2x2ZWQgdHlwZSBpbiBcIit0aGlzLnRvU3RyaW5nKHRydWUpK1wiOiBcIit0aGlzLnR5cGUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsIHx8ICh0aGlzLnJlcGVhdGVkICYmIHZhbHVlLmxlbmd0aCA9PSAwKSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYnVmZmVyOyAvLyBPcHRpb25hbCBvbWl0dGVkXHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlcGVhdGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBcIk9ubHkgcmVwZWF0ZWQgZmllbGRzIG9mIHByaW1pdGl2ZSBudW1lcmljIHR5cGVzICh0eXBlcyB3aGljaCB1c2UgdGhlIHZhcmludCwgMzItYml0LCBvciA2NC1iaXQgd2lyZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0eXBlcykgY2FuIGJlIGRlY2xhcmVkICdwYWNrZWQnLlwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnNbXCJwYWNrZWRcIl0gJiYgUHJvdG9CdWYuUEFDS0FCTEVfV0lSRV9UWVBFUy5pbmRleE9mKHRoaXMudHlwZS53aXJlVHlwZSkgPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gXCJBbGwgb2YgdGhlIGVsZW1lbnRzIG9mIHRoZSBmaWVsZCBhcmUgcGFja2VkIGludG8gYSBzaW5nbGUga2V5LXZhbHVlIHBhaXIgd2l0aCB3aXJlIHR5cGUgMlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gKGxlbmd0aC1kZWxpbWl0ZWQpLiBFYWNoIGVsZW1lbnQgaXMgZW5jb2RlZCB0aGUgc2FtZSB3YXkgaXQgd291bGQgYmUgbm9ybWFsbHksIGV4Y2VwdCB3aXRob3V0IGFcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRhZyBwcmVjZWRpbmcgaXQuXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci53cml0ZVZhcmludDMyKCh0aGlzLmlkIDw8IDMpIHwgUHJvdG9CdWYuV0lSRV9UWVBFUy5MREVMSU0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLmVuc3VyZUNhcGFjaXR5KGJ1ZmZlci5vZmZzZXQgKz0gMSk7IC8vIFdlIGRvIG5vdCBrbm93IHRoZSBsZW5ndGggeWV0LCBzbyBsZXQncyBhc3N1bWUgYSB2YXJpbnQgb2YgbGVuZ3RoIDFcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdGFydCA9IGJ1ZmZlci5vZmZzZXQ7IC8vIFJlbWVtYmVyIHdoZXJlIHRoZSBjb250ZW50cyBiZWdpblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpPTA7IGk8dmFsdWUubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbmNvZGVWYWx1ZSh2YWx1ZVtpXSwgYnVmZmVyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsZW4gPSBidWZmZXIub2Zmc2V0LXN0YXJ0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhcmludExlbiA9IEJ5dGVCdWZmZXIuY2FsY3VsYXRlVmFyaW50MzIobGVuKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YXJpbnRMZW4gPiAxKSB7IC8vIFdlIG5lZWQgdG8gbW92ZSB0aGUgY29udGVudHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29udGVudHMgPSBidWZmZXIuc2xpY2Uoc3RhcnQsIGJ1ZmZlci5vZmZzZXQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ICs9IHZhcmludExlbi0xO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci5vZmZzZXQgPSBzdGFydDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIuYXBwZW5kKGNvbnRlbnRzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci53cml0ZVZhcmludDMyKGxlbiwgc3RhcnQtdmFyaW50TGVuKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFwiSWYgeW91ciBtZXNzYWdlIGRlZmluaXRpb24gaGFzIHJlcGVhdGVkIGVsZW1lbnRzICh3aXRob3V0IHRoZSBbcGFja2VkPXRydWVdIG9wdGlvbiksIHRoZSBlbmNvZGVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBtZXNzYWdlIGhhcyB6ZXJvIG9yIG1vcmUga2V5LXZhbHVlIHBhaXJzIHdpdGggdGhlIHNhbWUgdGFnIG51bWJlclwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGk9MDsgaTx2YWx1ZS5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIud3JpdGVWYXJpbnQzMigodGhpcy5pZCA8PCAzKSB8IHRoaXMudHlwZS53aXJlVHlwZSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbmNvZGVWYWx1ZSh2YWx1ZVtpXSwgYnVmZmVyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIud3JpdGVWYXJpbnQzMigodGhpcy5pZCA8PCAzKSB8IHRoaXMudHlwZS53aXJlVHlwZSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW5jb2RlVmFsdWUodmFsdWUsIGJ1ZmZlcik7XHJcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIHZhbHVlIGZvciBcIit0aGlzLnRvU3RyaW5nKHRydWUpK1wiOiBcIit2YWx1ZStcIiAoXCIrZStcIilcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYnVmZmVyO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEVuY29kZXMgYSB2YWx1ZSB0byB0aGUgc3BlY2lmaWVkIGJ1ZmZlci4gRG9lcyBub3QgZW5jb2RlIHRoZSBrZXkuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgRmllbGQgdmFsdWVcclxuICAgICAgICAgICAgICogQHBhcmFtIHtCeXRlQnVmZmVyfSBidWZmZXIgQnl0ZUJ1ZmZlciB0byBlbmNvZGUgdG9cclxuICAgICAgICAgICAgICogQHJldHVybiB7Qnl0ZUJ1ZmZlcn0gVGhlIEJ5dGVCdWZmZXIgZm9yIGNoYWluaW5nXHJcbiAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgdmFsdWUgY2Fubm90IGJlIGVuY29kZWRcclxuICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgRmllbGQucHJvdG90eXBlLmVuY29kZVZhbHVlID0gZnVuY3Rpb24odmFsdWUsIGJ1ZmZlcikge1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSByZXR1cm4gYnVmZmVyOyAvLyBOb3RoaW5nIHRvIGVuY29kZVxyXG4gICAgICAgICAgICAgICAgLy8gVGFnIGhhcyBhbHJlYWR5IGJlZW4gd3JpdHRlblxyXG5cclxuICAgICAgICAgICAgICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gMzJiaXQgc2lnbmVkIHZhcmludFxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJpbnQzMlwiXTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gXCJJZiB5b3UgdXNlIGludDMyIG9yIGludDY0IGFzIHRoZSB0eXBlIGZvciBhIG5lZ2F0aXZlIG51bWJlciwgdGhlIHJlc3VsdGluZyB2YXJpbnQgaXMgYWx3YXlzIHRlbiBieXRlc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBsb25nIOKAkyBpdCBpcywgZWZmZWN0aXZlbHksIHRyZWF0ZWQgbGlrZSBhIHZlcnkgbGFyZ2UgdW5zaWduZWQgaW50ZWdlci5cIiAoc2VlICMxMjIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA8IDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIud3JpdGVWYXJpbnQ2NCh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci53cml0ZVZhcmludDMyKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIDMyYml0IHVuc2lnbmVkIHZhcmludFxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJ1aW50MzJcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci53cml0ZVZhcmludDMyKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIDMyYml0IHZhcmludCB6aWctemFnXHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInNpbnQzMlwiXTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLndyaXRlVmFyaW50MzJaaWdaYWcodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRml4ZWQgdW5zaWduZWQgMzJiaXRcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiZml4ZWQzMlwiXTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLndyaXRlVWludDMyKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEZpeGVkIHNpZ25lZCAzMmJpdFxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJzZml4ZWQzMlwiXTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLndyaXRlSW50MzIodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gNjRiaXQgdmFyaW50IGFzLWlzXHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImludDY0XCJdOlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJ1aW50NjRcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci53cml0ZVZhcmludDY0KHZhbHVlKTsgLy8gdGhyb3dzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyA2NGJpdCB2YXJpbnQgemlnLXphZ1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJzaW50NjRcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci53cml0ZVZhcmludDY0WmlnWmFnKHZhbHVlKTsgLy8gdGhyb3dzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBGaXhlZCB1bnNpZ25lZCA2NGJpdFxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJmaXhlZDY0XCJdOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIud3JpdGVVaW50NjQodmFsdWUpOyAvLyB0aHJvd3NcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEZpeGVkIHNpZ25lZCA2NGJpdFxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJzZml4ZWQ2NFwiXTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLndyaXRlSW50NjQodmFsdWUpOyAvLyB0aHJvd3NcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEJvb2xcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiYm9vbFwiXTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIud3JpdGVWYXJpbnQzMih2YWx1ZS50b0xvd2VyQ2FzZSgpID09PSAnZmFsc2UnID8gMCA6ICEhdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIud3JpdGVWYXJpbnQzMih2YWx1ZSA/IDEgOiAwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIENvbnN0YW50IGVudW0gdmFsdWVcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiZW51bVwiXTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLndyaXRlVmFyaW50MzIodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gMzJiaXQgZmxvYXRcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiZmxvYXRcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci53cml0ZUZsb2F0MzIodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gNjRiaXQgZmxvYXRcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiZG91YmxlXCJdOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIud3JpdGVGbG9hdDY0KHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIExlbmd0aC1kZWxpbWl0ZWQgc3RyaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInN0cmluZ1wiXTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLndyaXRlVlN0cmluZyh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBMZW5ndGgtZGVsaW1pdGVkIGJ5dGVzXHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImJ5dGVzXCJdOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUucmVtYWluaW5nKCkgPCAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIHZhbHVlIGZvciBcIit0aGlzLnRvU3RyaW5nKHRydWUpK1wiOiBcIit2YWx1ZS5yZW1haW5pbmcoKStcIiBieXRlcyByZW1haW5pbmdcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcmV2T2Zmc2V0ID0gdmFsdWUub2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIud3JpdGVWYXJpbnQzMih2YWx1ZS5yZW1haW5pbmcoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci5hcHBlbmQodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZS5vZmZzZXQgPSBwcmV2T2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRW1iZWRkZWQgbWVzc2FnZVxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJtZXNzYWdlXCJdOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYmIgPSBuZXcgQnl0ZUJ1ZmZlcigpLkxFKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVzb2x2ZWRUeXBlLmVuY29kZSh2YWx1ZSwgYmIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIud3JpdGVWYXJpbnQzMihiYi5vZmZzZXQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIuYXBwZW5kKGJiLmZsaXAoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBMZWdhY3kgZ3JvdXBcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiZ3JvdXBcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVzb2x2ZWRUeXBlLmVuY29kZSh2YWx1ZSwgYnVmZmVyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLndyaXRlVmFyaW50MzIoKHRoaXMuaWQgPDwgMykgfCBQcm90b0J1Zi5XSVJFX1RZUEVTLkVOREdST1VQKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIHNob3VsZCBuZXZlciBlbmQgaGVyZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIltJTlRFUk5BTF0gSWxsZWdhbCB2YWx1ZSB0byBlbmNvZGUgaW4gXCIrdGhpcy50b1N0cmluZyh0cnVlKStcIjogXCIrdmFsdWUrXCIgKHVua25vd24gdHlwZSlcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYnVmZmVyO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIENhbGN1bGF0ZXMgdGhlIGxlbmd0aCBvZiB0aGlzIGZpZWxkJ3MgdmFsdWUgb24gdGhlIG5ldHdvcmsgbGV2ZWwuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgRmllbGQgdmFsdWVcclxuICAgICAgICAgICAgICogQHJldHVybnMge251bWJlcn0gQnl0ZSBsZW5ndGhcclxuICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgRmllbGQucHJvdG90eXBlLmNhbGN1bGF0ZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMudmVyaWZ5VmFsdWUodmFsdWUpOyAvLyBNYXkgdGhyb3dcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnR5cGUgPT09IG51bGwgfHwgdHlwZW9mIHRoaXMudHlwZSAhPT0gJ29iamVjdCcpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJbSU5URVJOQUxdIFVucmVzb2x2ZWQgdHlwZSBpbiBcIit0aGlzLnRvU3RyaW5nKHRydWUpK1wiOiBcIit0aGlzLnR5cGUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsIHx8ICh0aGlzLnJlcGVhdGVkICYmIHZhbHVlLmxlbmd0aCA9PSAwKSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDsgLy8gT3B0aW9uYWwgb21pdHRlZFxyXG4gICAgICAgICAgICAgICAgdmFyIG4gPSAwO1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5yZXBlYXRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaSwgbmk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnNbXCJwYWNrZWRcIl0gJiYgUHJvdG9CdWYuUEFDS0FCTEVfV0lSRV9UWVBFUy5pbmRleE9mKHRoaXMudHlwZS53aXJlVHlwZSkgPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbiArPSBCeXRlQnVmZmVyLmNhbGN1bGF0ZVZhcmludDMyKCh0aGlzLmlkIDw8IDMpIHwgUHJvdG9CdWYuV0lSRV9UWVBFUy5MREVMSU0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmkgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpPTA7IGk8dmFsdWUubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmkgKz0gdGhpcy5jYWxjdWxhdGVWYWx1ZSh2YWx1ZVtpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuICs9IEJ5dGVCdWZmZXIuY2FsY3VsYXRlVmFyaW50MzIobmkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbiArPSBuaTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaT0wOyBpPHZhbHVlLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG4gKz0gQnl0ZUJ1ZmZlci5jYWxjdWxhdGVWYXJpbnQzMigodGhpcy5pZCA8PCAzKSB8IHRoaXMudHlwZS53aXJlVHlwZSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbiArPSB0aGlzLmNhbGN1bGF0ZVZhbHVlKHZhbHVlW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG4gKz0gQnl0ZUJ1ZmZlci5jYWxjdWxhdGVWYXJpbnQzMigodGhpcy5pZCA8PCAzKSB8IHRoaXMudHlwZS53aXJlVHlwZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG4gKz0gdGhpcy5jYWxjdWxhdGVWYWx1ZSh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCB2YWx1ZSBmb3IgXCIrdGhpcy50b1N0cmluZyh0cnVlKStcIjogXCIrdmFsdWUrXCIgKFwiK2UrXCIpXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG47XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQ2FsY3VsYXRlcyB0aGUgYnl0ZSBsZW5ndGggb2YgYSB2YWx1ZS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBGaWVsZCB2YWx1ZVxyXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBCeXRlIGxlbmd0aFxyXG4gICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHZhbHVlIGNhbm5vdCBiZSBjYWxjdWxhdGVkXHJcbiAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEZpZWxkLnByb3RvdHlwZS5jYWxjdWxhdGVWYWx1ZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHJldHVybiAwOyAvLyBOb3RoaW5nIHRvIGVuY29kZVxyXG4gICAgICAgICAgICAgICAgLy8gVGFnIGhhcyBhbHJlYWR5IGJlZW4gd3JpdHRlblxyXG4gICAgICAgICAgICAgICAgdmFyIG47XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJpbnQzMlwiXTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlIDwgMCA/IEJ5dGVCdWZmZXIuY2FsY3VsYXRlVmFyaW50NjQodmFsdWUpIDogQnl0ZUJ1ZmZlci5jYWxjdWxhdGVWYXJpbnQzMih2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInVpbnQzMlwiXTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJ5dGVCdWZmZXIuY2FsY3VsYXRlVmFyaW50MzIodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJzaW50MzJcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBCeXRlQnVmZmVyLmNhbGN1bGF0ZVZhcmludDMyKEJ5dGVCdWZmZXIuemlnWmFnRW5jb2RlMzIodmFsdWUpKTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiZml4ZWQzMlwiXTpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wic2ZpeGVkMzJcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImZsb2F0XCJdOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gNDtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiaW50NjRcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInVpbnQ2NFwiXTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJ5dGVCdWZmZXIuY2FsY3VsYXRlVmFyaW50NjQodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJzaW50NjRcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBCeXRlQnVmZmVyLmNhbGN1bGF0ZVZhcmludDY0KEJ5dGVCdWZmZXIuemlnWmFnRW5jb2RlNjQodmFsdWUpKTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiZml4ZWQ2NFwiXTpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wic2ZpeGVkNjRcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiA4O1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJib29sXCJdOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiZW51bVwiXTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJ5dGVCdWZmZXIuY2FsY3VsYXRlVmFyaW50MzIodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJkb3VibGVcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiA4O1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJzdHJpbmdcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG4gPSBCeXRlQnVmZmVyLmNhbGN1bGF0ZVVURjhCeXRlcyh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBCeXRlQnVmZmVyLmNhbGN1bGF0ZVZhcmludDMyKG4pICsgbjtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiYnl0ZXNcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5yZW1haW5pbmcoKSA8IDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIklsbGVnYWwgdmFsdWUgZm9yIFwiK3RoaXMudG9TdHJpbmcodHJ1ZSkrXCI6IFwiK3ZhbHVlLnJlbWFpbmluZygpK1wiIGJ5dGVzIHJlbWFpbmluZ1wiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJ5dGVCdWZmZXIuY2FsY3VsYXRlVmFyaW50MzIodmFsdWUucmVtYWluaW5nKCkpICsgdmFsdWUucmVtYWluaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcIm1lc3NhZ2VcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG4gPSB0aGlzLnJlc29sdmVkVHlwZS5jYWxjdWxhdGUodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gQnl0ZUJ1ZmZlci5jYWxjdWxhdGVWYXJpbnQzMihuKSArIG47XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImdyb3VwXCJdOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuID0gdGhpcy5yZXNvbHZlZFR5cGUuY2FsY3VsYXRlKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG4gKyBCeXRlQnVmZmVyLmNhbGN1bGF0ZVZhcmludDMyKCh0aGlzLmlkIDw8IDMpIHwgUHJvdG9CdWYuV0lSRV9UWVBFUy5FTkRHUk9VUCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBXZSBzaG91bGQgbmV2ZXIgZW5kIGhlcmVcclxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiW0lOVEVSTkFMXSBJbGxlZ2FsIHZhbHVlIHRvIGVuY29kZSBpbiBcIit0aGlzLnRvU3RyaW5nKHRydWUpK1wiOiBcIit2YWx1ZStcIiAodW5rbm93biB0eXBlKVwiKTtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBEZWNvZGUgdGhlIGZpZWxkIHZhbHVlIGZyb20gdGhlIHNwZWNpZmllZCBidWZmZXIuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3aXJlVHlwZSBMZWFkaW5nIHdpcmUgdHlwZVxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0J5dGVCdWZmZXJ9IGJ1ZmZlciBCeXRlQnVmZmVyIHRvIGRlY29kZSBmcm9tXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IHNraXBSZXBlYXRlZCBXaGV0aGVyIHRvIHNraXAgdGhlIHJlcGVhdGVkIGNoZWNrIG9yIG5vdC4gRGVmYXVsdHMgdG8gZmFsc2UuXHJcbiAgICAgICAgICAgICAqIEByZXR1cm4geyp9IERlY29kZWQgdmFsdWVcclxuICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBmaWVsZCBjYW5ub3QgYmUgZGVjb2RlZFxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBGaWVsZC5wcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24od2lyZVR5cGUsIGJ1ZmZlciwgc2tpcFJlcGVhdGVkKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUsIG5CeXRlcztcclxuICAgICAgICAgICAgICAgIGlmICh3aXJlVHlwZSAhPSB0aGlzLnR5cGUud2lyZVR5cGUgJiYgKHNraXBSZXBlYXRlZCB8fCAod2lyZVR5cGUgIT0gUHJvdG9CdWYuV0lSRV9UWVBFUy5MREVMSU0gfHwgIXRoaXMucmVwZWF0ZWQpKSlcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIklsbGVnYWwgd2lyZSB0eXBlIGZvciBmaWVsZCBcIit0aGlzLnRvU3RyaW5nKHRydWUpK1wiOiBcIit3aXJlVHlwZStcIiAoXCIrdGhpcy50eXBlLndpcmVUeXBlK1wiIGV4cGVjdGVkKVwiKTtcclxuICAgICAgICAgICAgICAgIGlmICh3aXJlVHlwZSA9PSBQcm90b0J1Zi5XSVJFX1RZUEVTLkxERUxJTSAmJiB0aGlzLnJlcGVhdGVkICYmIHRoaXMub3B0aW9uc1tcInBhY2tlZFwiXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghc2tpcFJlcGVhdGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5CeXRlcyA9IGJ1ZmZlci5yZWFkVmFyaW50MzIoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbkJ5dGVzID0gYnVmZmVyLm9mZnNldCArIG5CeXRlczsgLy8gTGltaXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlcyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoYnVmZmVyLm9mZnNldCA8IG5CeXRlcylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKHRoaXMuZGVjb2RlKHRoaXMudHlwZS53aXJlVHlwZSwgYnVmZmVyLCB0cnVlKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlYWQgdGhlIG5leHQgdmFsdWUgb3RoZXJ3aXNlLi4uXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIDMyYml0IHNpZ25lZCB2YXJpbnRcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiaW50MzJcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBidWZmZXIucmVhZFZhcmludDMyKCkgfCAwO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyAzMmJpdCB1bnNpZ25lZCB2YXJpbnRcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1widWludDMyXCJdOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYnVmZmVyLnJlYWRWYXJpbnQzMigpID4+PiAwO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyAzMmJpdCBzaWduZWQgdmFyaW50IHppZy16YWdcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wic2ludDMyXCJdOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYnVmZmVyLnJlYWRWYXJpbnQzMlppZ1phZygpIHwgMDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRml4ZWQgMzJiaXQgdW5zaWduZWRcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiZml4ZWQzMlwiXTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlci5yZWFkVWludDMyKCkgPj4+IDA7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJzZml4ZWQzMlwiXTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlci5yZWFkSW50MzIoKSB8IDA7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIDY0Yml0IHNpZ25lZCB2YXJpbnRcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiaW50NjRcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBidWZmZXIucmVhZFZhcmludDY0KCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIDY0Yml0IHVuc2lnbmVkIHZhcmludFxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJ1aW50NjRcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBidWZmZXIucmVhZFZhcmludDY0KCkudG9VbnNpZ25lZCgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyA2NGJpdCBzaWduZWQgdmFyaW50IHppZy16YWdcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wic2ludDY0XCJdOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYnVmZmVyLnJlYWRWYXJpbnQ2NFppZ1phZygpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBGaXhlZCA2NGJpdCB1bnNpZ25lZFxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJmaXhlZDY0XCJdOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYnVmZmVyLnJlYWRVaW50NjQoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRml4ZWQgNjRiaXQgc2lnbmVkXHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInNmaXhlZDY0XCJdOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYnVmZmVyLnJlYWRJbnQ2NCgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBCb29sIHZhcmludFxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJib29sXCJdOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gISFidWZmZXIucmVhZFZhcmludDMyKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIENvbnN0YW50IGVudW0gdmFsdWUgKHZhcmludClcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiZW51bVwiXTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGZvbGxvd2luZyBCdWlsZGVyLk1lc3NhZ2Ujc2V0IHdpbGwgYWxyZWFkeSB0aHJvd1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYnVmZmVyLnJlYWRWYXJpbnQzMigpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyAzMmJpdCBmbG9hdFxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJmbG9hdFwiXTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlci5yZWFkRmxvYXQoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gNjRiaXQgZmxvYXRcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiZG91YmxlXCJdOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYnVmZmVyLnJlYWREb3VibGUoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTGVuZ3RoLWRlbGltaXRlZCBzdHJpbmdcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wic3RyaW5nXCJdOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYnVmZmVyLnJlYWRWU3RyaW5nKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIExlbmd0aC1kZWxpbWl0ZWQgYnl0ZXNcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiYnl0ZXNcIl06IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbkJ5dGVzID0gYnVmZmVyLnJlYWRWYXJpbnQzMigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYnVmZmVyLnJlbWFpbmluZygpIDwgbkJ5dGVzKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIG51bWJlciBvZiBieXRlcyBmb3IgXCIrdGhpcy50b1N0cmluZyh0cnVlKStcIjogXCIrbkJ5dGVzK1wiIHJlcXVpcmVkIGJ1dCBnb3Qgb25seSBcIitidWZmZXIucmVtYWluaW5nKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGJ1ZmZlci5jbG9uZSgpOyAvLyBPZmZzZXQgYWxyZWFkeSBzZXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUubGltaXQgPSB2YWx1ZS5vZmZzZXQrbkJ5dGVzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIub2Zmc2V0ICs9IG5CeXRlcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTGVuZ3RoLWRlbGltaXRlZCBlbWJlZGRlZCBtZXNzYWdlXHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcIm1lc3NhZ2VcIl06IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbkJ5dGVzID0gYnVmZmVyLnJlYWRWYXJpbnQzMigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZXNvbHZlZFR5cGUuZGVjb2RlKGJ1ZmZlciwgbkJ5dGVzKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIExlZ2FjeSBncm91cFxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJncm91cFwiXTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzb2x2ZWRUeXBlLmRlY29kZShidWZmZXIsIC0xLCB0aGlzLmlkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBXZSBzaG91bGQgbmV2ZXIgZW5kIGhlcmVcclxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiW0lOVEVSTkFMXSBJbGxlZ2FsIHdpcmUgdHlwZSBmb3IgXCIrdGhpcy50b1N0cmluZyh0cnVlKStcIjogXCIrd2lyZVR5cGUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQGFsaWFzIFByb3RvQnVmLlJlZmxlY3QuTWVzc2FnZS5GaWVsZFxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBSZWZsZWN0Lk1lc3NhZ2UuRmllbGQgPSBGaWVsZDtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IE1lc3NhZ2UgRXh0ZW5zaW9uRmllbGQuXHJcbiAgICAgICAgICAgICAqIEBleHBvcnRzIFByb3RvQnVmLlJlZmxlY3QuTWVzc2FnZS5FeHRlbnNpb25GaWVsZFxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge1Byb3RvQnVmLlJlZmxlY3QuTWVzc2FnZX0gbWVzc2FnZSBNZXNzYWdlIHJlZmVyZW5jZVxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcnVsZSBSdWxlLCBvbmUgb2YgcmVxdXJpZWQsIG9wdGlvbmFsLCByZXBlYXRlZFxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBEYXRhIHR5cGUsIGUuZy4gaW50MzJcclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgRmllbGQgbmFtZVxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gaWQgVW5pcXVlIGZpZWxkIGlkXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcuKj49fSBvcHRpb25zIE9wdGlvbnNcclxuICAgICAgICAgICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgICAgICAgICAqIEBleHRlbmRzIFByb3RvQnVmLlJlZmxlY3QuTWVzc2FnZS5GaWVsZFxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdmFyIEV4dGVuc2lvbkZpZWxkID0gZnVuY3Rpb24obWVzc2FnZSwgcnVsZSwgdHlwZSwgbmFtZSwgaWQsIG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgIEZpZWxkLmNhbGwodGhpcywgbWVzc2FnZSwgcnVsZSwgdHlwZSwgbmFtZSwgaWQsIG9wdGlvbnMpO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLy8gRXh0ZW5kcyBGaWVsZFxyXG4gICAgICAgICAgICBFeHRlbnNpb25GaWVsZC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEZpZWxkLnByb3RvdHlwZSk7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQGFsaWFzIFByb3RvQnVmLlJlZmxlY3QuTWVzc2FnZS5FeHRlbnNpb25GaWVsZFxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBSZWZsZWN0Lk1lc3NhZ2UuRXh0ZW5zaW9uRmllbGQgPSBFeHRlbnNpb25GaWVsZDtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IEVudW0uXHJcbiAgICAgICAgICAgICAqIEBleHBvcnRzIFByb3RvQnVmLlJlZmxlY3QuRW51bVxyXG4gICAgICAgICAgICAgKiBAcGFyYW0geyFQcm90b0J1Zi5SZWZsZWN0LlR9IHBhcmVudCBQYXJlbnQgUmVmbGVjdCBvYmplY3RcclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgRW51bSBuYW1lXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcuKj49fSBvcHRpb25zIEVudW0gb3B0aW9uc1xyXG4gICAgICAgICAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAgICAgICAgICogQGV4dGVuZHMgUHJvdG9CdWYuUmVmbGVjdC5OYW1lc3BhY2VcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHZhciBFbnVtID0gZnVuY3Rpb24ocGFyZW50LCBuYW1lLCBvcHRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICBOYW1lc3BhY2UuY2FsbCh0aGlzLCBwYXJlbnQsIG5hbWUsIG9wdGlvbnMpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQG92ZXJyaWRlXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuY2xhc3NOYW1lID0gXCJFbnVtXCI7XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBSdW50aW1lIGVudW0gb2JqZWN0LlxyXG4gICAgICAgICAgICAgICAgICogQHR5cGUge09iamVjdC48c3RyaW5nLG51bWJlcj58bnVsbH1cclxuICAgICAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vYmplY3QgPSBudWxsO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLy8gRXh0ZW5kcyBOYW1lc3BhY2VcclxuICAgICAgICAgICAgRW51bS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKE5hbWVzcGFjZS5wcm90b3R5cGUpO1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEJ1aWxkcyB0aGlzIGVudW0gYW5kIHJldHVybnMgdGhlIHJ1bnRpbWUgY291bnRlcnBhcnQuXHJcbiAgICAgICAgICAgICAqIEByZXR1cm4ge09iamVjdDxzdHJpbmcsKj59XHJcbiAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEVudW0ucHJvdG90eXBlLmJ1aWxkID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZW5tID0ge307XHJcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWVzID0gdGhpcy5nZXRDaGlsZHJlbihFbnVtLlZhbHVlKTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGk9MDsgaTx2YWx1ZXMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgZW5tW3ZhbHVlc1tpXVsnbmFtZSddXSA9IHZhbHVlc1tpXVsnaWQnXTtcclxuICAgICAgICAgICAgICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpXHJcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVubSwgJyRvcHRpb25zJywgeyBcInZhbHVlXCI6IHRoaXMuYnVpbGRPcHQoKSB9KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9iamVjdCA9IGVubTtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBAYWxpYXMgUHJvdG9CdWYuUmVmbGVjdC5FbnVtXHJcbiAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFJlZmxlY3QuRW51bSA9IEVudW07XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQ29uc3RydWN0cyBhIG5ldyBFbnVtIFZhbHVlLlxyXG4gICAgICAgICAgICAgKiBAZXhwb3J0cyBQcm90b0J1Zi5SZWZsZWN0LkVudW0uVmFsdWVcclxuICAgICAgICAgICAgICogQHBhcmFtIHshUHJvdG9CdWYuUmVmbGVjdC5FbnVtfSBlbm0gRW51bSByZWZlcmVuY2VcclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgRmllbGQgbmFtZVxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gaWQgVW5pcXVlIGZpZWxkIGlkXHJcbiAgICAgICAgICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICAgICAgICAgKiBAZXh0ZW5kcyBQcm90b0J1Zi5SZWZsZWN0LlRcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHZhciBWYWx1ZSA9IGZ1bmN0aW9uKGVubSwgbmFtZSwgaWQpIHtcclxuICAgICAgICAgICAgICAgIFQuY2FsbCh0aGlzLCBlbm0sIG5hbWUpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQG92ZXJyaWRlXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuY2xhc3NOYW1lID0gXCJFbnVtLlZhbHVlXCI7XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBVbmlxdWUgZW51bSB2YWx1ZSBpZC5cclxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuaWQgPSBpZDtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8vIEV4dGVuZHMgVFxyXG4gICAgICAgICAgICBWYWx1ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFQucHJvdG90eXBlKTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBAYWxpYXMgUHJvdG9CdWYuUmVmbGVjdC5FbnVtLlZhbHVlXHJcbiAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFJlZmxlY3QuRW51bS5WYWx1ZSA9IFZhbHVlO1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgU2VydmljZS5cclxuICAgICAgICAgICAgICogQGV4cG9ydHMgUHJvdG9CdWYuUmVmbGVjdC5TZXJ2aWNlXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7IVByb3RvQnVmLlJlZmxlY3QuTmFtZXNwYWNlfSByb290IFJvb3RcclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgU2VydmljZSBuYW1lXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj49fSBvcHRpb25zIE9wdGlvbnNcclxuICAgICAgICAgICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgICAgICAgICAqIEBleHRlbmRzIFByb3RvQnVmLlJlZmxlY3QuTmFtZXNwYWNlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB2YXIgU2VydmljZSA9IGZ1bmN0aW9uKHJvb3QsIG5hbWUsIG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgIE5hbWVzcGFjZS5jYWxsKHRoaXMsIHJvb3QsIG5hbWUsIG9wdGlvbnMpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQG92ZXJyaWRlXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuY2xhc3NOYW1lID0gXCJTZXJ2aWNlXCI7XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBCdWlsdCBydW50aW1lIHNlcnZpY2UgY2xhc3MuXHJcbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7P2Z1bmN0aW9uKG5ldzpQcm90b0J1Zi5CdWlsZGVyLlNlcnZpY2UpfVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLmNsYXp6ID0gbnVsbDtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8vIEV4dGVuZHMgTmFtZXNwYWNlXHJcbiAgICAgICAgICAgIFNlcnZpY2UucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShOYW1lc3BhY2UucHJvdG90eXBlKTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBCdWlsZHMgdGhlIHNlcnZpY2UgYW5kIHJldHVybnMgdGhlIHJ1bnRpbWUgY291bnRlcnBhcnQsIHdoaWNoIGlzIGEgZnVsbHkgZnVuY3Rpb25hbCBjbGFzcy5cclxuICAgICAgICAgICAgICogQHNlZSBQcm90b0J1Zi5CdWlsZGVyLlNlcnZpY2VcclxuICAgICAgICAgICAgICogQHBhcmFtIHtib29sZWFuPX0gcmVidWlsZCBXaGV0aGVyIHRvIHJlYnVpbGQgb3Igbm90XHJcbiAgICAgICAgICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBTZXJ2aWNlIGNsYXNzXHJcbiAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgbWVzc2FnZSBjYW5ub3QgYmUgYnVpbHRcclxuICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgU2VydmljZS5wcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbihyZWJ1aWxkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jbGF6eiAmJiAhcmVidWlsZCkgcmV0dXJuIHRoaXMuY2xheno7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jbGF6eiA9IChmdW5jdGlvbihQcm90b0J1ZiwgVCkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IHJ1bnRpbWUgU2VydmljZS5cclxuICAgICAgICAgICAgICAgICAgICAgKiBAbmFtZSBQcm90b0J1Zi5CdWlsZGVyLlNlcnZpY2VcclxuICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKHN0cmluZywgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlLCBmdW5jdGlvbihFcnJvciwgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlPSkpPX0gcnBjSW1wbCBSUEMgaW1wbGVtZW50YXRpb24gcmVjZWl2aW5nIHRoZSBtZXRob2QgbmFtZSBhbmQgdGhlIG1lc3NhZ2VcclxuICAgICAgICAgICAgICAgICAgICAgKiBAY2xhc3MgQmFyZWJvbmUgb2YgYWxsIHJ1bnRpbWUgc2VydmljZXMuXHJcbiAgICAgICAgICAgICAgICAgICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgICAgICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBzZXJ2aWNlIGNhbm5vdCBiZSBjcmVhdGVkXHJcbiAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIFNlcnZpY2UgPSBmdW5jdGlvbihycGNJbXBsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFByb3RvQnVmLkJ1aWxkZXIuU2VydmljZS5jYWxsKHRoaXMpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIFNlcnZpY2UgaW1wbGVtZW50YXRpb24uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEBuYW1lIFByb3RvQnVmLkJ1aWxkZXIuU2VydmljZSNycGNJbXBsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEB0eXBlIHshZnVuY3Rpb24oc3RyaW5nLCBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UsIGZ1bmN0aW9uKEVycm9yLCBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2U9KSl9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucnBjSW1wbCA9IHJwY0ltcGwgfHwgZnVuY3Rpb24obmFtZSwgbXNnLCBjYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBpcyB3aGF0IGEgdXNlciBoYXMgdG8gaW1wbGVtZW50OiBBIGZ1bmN0aW9uIHJlY2VpdmluZyB0aGUgbWV0aG9kIG5hbWUsIHRoZSBhY3R1YWwgbWVzc2FnZSB0b1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2VuZCAodHlwZSBjaGVja2VkKSBhbmQgdGhlIGNhbGxiYWNrIHRoYXQncyBlaXRoZXIgcHJvdmlkZWQgd2l0aCB0aGUgZXJyb3IgYXMgaXRzIGZpcnN0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhcmd1bWVudCBvciBudWxsIGFuZCB0aGUgYWN0dWFsIHJlc3BvbnNlIG1lc3NhZ2UuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGNhbGxiYWNrLmJpbmQodGhpcywgRXJyb3IoXCJOb3QgaW1wbGVtZW50ZWQsIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Rjb2RlSU8vUHJvdG9CdWYuanMvd2lraS9TZXJ2aWNlc1wiKSksIDApOyAvLyBNdXN0IGJlIGFzeW5jIVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEV4dGVuZHMgUHJvdG9CdWYuQnVpbGRlci5TZXJ2aWNlXHJcbiAgICAgICAgICAgICAgICAgICAgU2VydmljZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFByb3RvQnVmLkJ1aWxkZXIuU2VydmljZS5wcm90b3R5cGUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2VydmljZSwgXCIkb3B0aW9uc1wiLCB7IFwidmFsdWVcIjogVC5idWlsZE9wdCgpIH0pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2VydmljZS5wcm90b3R5cGUsIFwiJG9wdGlvbnNcIiwgeyBcInZhbHVlXCI6IFNlcnZpY2VbXCIkb3B0aW9uc1wiXSB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICogQXN5bmNocm9ub3VzbHkgcGVyZm9ybXMgYW4gUlBDIGNhbGwgdXNpbmcgdGhlIGdpdmVuIFJQQyBpbXBsZW1lbnRhdGlvbi5cclxuICAgICAgICAgICAgICAgICAgICAgKiBAbmFtZSBQcm90b0J1Zi5CdWlsZGVyLlNlcnZpY2UuW01ldGhvZF1cclxuICAgICAgICAgICAgICAgICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0geyFmdW5jdGlvbihzdHJpbmcsIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZSwgZnVuY3Rpb24oRXJyb3IsIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZT0pKX0gcnBjSW1wbCBSUEMgaW1wbGVtZW50YXRpb25cclxuICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge1Byb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZX0gcmVxIFJlcXVlc3RcclxuICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yLCAoUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlfEJ5dGVCdWZmZXJ8QnVmZmVyfHN0cmluZyk9KX0gY2FsbGJhY2sgQ2FsbGJhY2sgcmVjZWl2aW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICogIHRoZSBlcnJvciBpZiBhbnkgYW5kIHRoZSByZXNwb25zZSBlaXRoZXIgYXMgYSBwcmUtcGFyc2VkIG1lc3NhZ2Ugb3IgYXMgaXRzIHJhdyBieXRlc1xyXG4gICAgICAgICAgICAgICAgICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICAgICAgICAgICAgICAgICAqL1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAgICAgKiBBc3luY2hyb25vdXNseSBwZXJmb3JtcyBhbiBSUEMgY2FsbCB1c2luZyB0aGUgaW5zdGFuY2UncyBSUEMgaW1wbGVtZW50YXRpb24uXHJcbiAgICAgICAgICAgICAgICAgICAgICogQG5hbWUgUHJvdG9CdWYuQnVpbGRlci5TZXJ2aWNlI1tNZXRob2RdXHJcbiAgICAgICAgICAgICAgICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2V9IHJlcSBSZXF1ZXN0XHJcbiAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtmdW5jdGlvbihFcnJvciwgKFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZXxCeXRlQnVmZmVyfEJ1ZmZlcnxzdHJpbmcpPSl9IGNhbGxiYWNrIENhbGxiYWNrIHJlY2VpdmluZ1xyXG4gICAgICAgICAgICAgICAgICAgICAqICB0aGUgZXJyb3IgaWYgYW55IGFuZCB0aGUgcmVzcG9uc2UgZWl0aGVyIGFzIGEgcHJlLXBhcnNlZCBtZXNzYWdlIG9yIGFzIGl0cyByYXcgYnl0ZXNcclxuICAgICAgICAgICAgICAgICAgICAgKiBAYWJzdHJhY3RcclxuICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJwYyA9IFQuZ2V0Q2hpbGRyZW4oUHJvdG9CdWYuUmVmbGVjdC5TZXJ2aWNlLlJQQ01ldGhvZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpPHJwYy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAoZnVuY3Rpb24obWV0aG9kKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2VydmljZSNNZXRob2QobWVzc2FnZSwgY2FsbGJhY2spXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBTZXJ2aWNlLnByb3RvdHlwZVttZXRob2QubmFtZV0gPSBmdW5jdGlvbihyZXEsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXEgfHwgIShyZXEgaW5zdGFuY2VvZiBtZXRob2QucmVzb2x2ZWRSZXF1ZXN0VHlwZS5jbGF6eikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoY2FsbGJhY2suYmluZCh0aGlzLCBFcnJvcihcIklsbGVnYWwgcmVxdWVzdCB0eXBlIHByb3ZpZGVkIHRvIHNlcnZpY2UgbWV0aG9kIFwiK1QubmFtZStcIiNcIittZXRob2QubmFtZSkpLCAwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJwY0ltcGwobWV0aG9kLmZxbigpLCByZXEsIGZ1bmN0aW9uKGVyciwgcmVzKSB7IC8vIEFzc3VtZXMgdGhhdCB0aGlzIGlzIHByb3Blcmx5IGFzeW5jXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkgeyByZXMgPSBtZXRob2QucmVzb2x2ZWRSZXNwb25zZVR5cGUuY2xhenouZGVjb2RlKHJlcyk7IH0gY2F0Y2ggKG5vdEFCdWZmZXIpIHt9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJlcyB8fCAhKHJlcyBpbnN0YW5jZW9mIG1ldGhvZC5yZXNvbHZlZFJlc3BvbnNlVHlwZS5jbGF6eikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhFcnJvcihcIklsbGVnYWwgcmVzcG9uc2UgdHlwZSByZWNlaXZlZCBpbiBzZXJ2aWNlIG1ldGhvZCBcIisgVC5uYW1lK1wiI1wiK21ldGhvZC5uYW1lKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgcmVzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoY2FsbGJhY2suYmluZCh0aGlzLCBlcnIpLCAwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNlcnZpY2UuTWV0aG9kKHJwY0ltcGwsIG1lc3NhZ2UsIGNhbGxiYWNrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgU2VydmljZVttZXRob2QubmFtZV0gPSBmdW5jdGlvbihycGNJbXBsLCByZXEsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IFNlcnZpY2UocnBjSW1wbClbbWV0aG9kLm5hbWVdKHJlcSwgY2FsbGJhY2spO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTZXJ2aWNlW21ldGhvZC5uYW1lXSwgXCIkb3B0aW9uc1wiLCB7IFwidmFsdWVcIjogbWV0aG9kLmJ1aWxkT3B0KCkgfSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNlcnZpY2UucHJvdG90eXBlW21ldGhvZC5uYW1lXSwgXCIkb3B0aW9uc1wiLCB7IFwidmFsdWVcIjogU2VydmljZVttZXRob2QubmFtZV1bXCIkb3B0aW9uc1wiXSB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSkocnBjW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBTZXJ2aWNlO1xyXG5cclxuICAgICAgICAgICAgICAgIH0pKFByb3RvQnVmLCB0aGlzKTtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBAYWxpYXMgUHJvdG9CdWYuUmVmbGVjdC5TZXJ2aWNlXHJcbiAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFJlZmxlY3QuU2VydmljZSA9IFNlcnZpY2U7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQWJzdHJhY3Qgc2VydmljZSBtZXRob2QuXHJcbiAgICAgICAgICAgICAqIEBleHBvcnRzIFByb3RvQnVmLlJlZmxlY3QuU2VydmljZS5NZXRob2RcclxuICAgICAgICAgICAgICogQHBhcmFtIHshUHJvdG9CdWYuUmVmbGVjdC5TZXJ2aWNlfSBzdmMgU2VydmljZVxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBNZXRob2QgbmFtZVxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+PX0gb3B0aW9ucyBPcHRpb25zXHJcbiAgICAgICAgICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICAgICAgICAgKiBAZXh0ZW5kcyBQcm90b0J1Zi5SZWZsZWN0LlRcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHZhciBNZXRob2QgPSBmdW5jdGlvbihzdmMsIG5hbWUsIG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgIFQuY2FsbCh0aGlzLCBzdmMsIG5hbWUpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQG92ZXJyaWRlXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuY2xhc3NOYW1lID0gXCJTZXJ2aWNlLk1ldGhvZFwiO1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogT3B0aW9ucy5cclxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZywgKj59XHJcbiAgICAgICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvLyBFeHRlbmRzIFRcclxuICAgICAgICAgICAgTWV0aG9kLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoVC5wcm90b3R5cGUpO1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEJ1aWxkcyB0aGUgbWV0aG9kJ3MgJyRvcHRpb25zJyBwcm9wZXJ0eS5cclxuICAgICAgICAgICAgICogQG5hbWUgUHJvdG9CdWYuUmVmbGVjdC5TZXJ2aWNlLk1ldGhvZCNidWlsZE9wdFxyXG4gICAgICAgICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICAgICAgICogQHJldHVybiB7T2JqZWN0LjxzdHJpbmcsKj59XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBNZXRob2QucHJvdG90eXBlLmJ1aWxkT3B0ID0gTmFtZXNwYWNlLnByb3RvdHlwZS5idWlsZE9wdDtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBAYWxpYXMgUHJvdG9CdWYuUmVmbGVjdC5TZXJ2aWNlLk1ldGhvZFxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBSZWZsZWN0LlNlcnZpY2UuTWV0aG9kID0gTWV0aG9kO1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFJQQyBzZXJ2aWNlIG1ldGhvZC5cclxuICAgICAgICAgICAgICogQGV4cG9ydHMgUHJvdG9CdWYuUmVmbGVjdC5TZXJ2aWNlLlJQQ01ldGhvZFxyXG4gICAgICAgICAgICAgKiBAcGFyYW0geyFQcm90b0J1Zi5SZWZsZWN0LlNlcnZpY2V9IHN2YyBTZXJ2aWNlXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE1ldGhvZCBuYW1lXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSByZXF1ZXN0IFJlcXVlc3QgbWVzc2FnZSBuYW1lXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSByZXNwb25zZSBSZXNwb25zZSBtZXNzYWdlIG5hbWVcclxuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPj19IG9wdGlvbnMgT3B0aW9uc1xyXG4gICAgICAgICAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAgICAgICAgICogQGV4dGVuZHMgUHJvdG9CdWYuUmVmbGVjdC5TZXJ2aWNlLk1ldGhvZFxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdmFyIFJQQ01ldGhvZCA9IGZ1bmN0aW9uKHN2YywgbmFtZSwgcmVxdWVzdCwgcmVzcG9uc2UsIG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgIE1ldGhvZC5jYWxsKHRoaXMsIHN2YywgbmFtZSwgb3B0aW9ucyk7XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBAb3ZlcnJpZGVcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jbGFzc05hbWUgPSBcIlNlcnZpY2UuUlBDTWV0aG9kXCI7XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBSZXF1ZXN0IG1lc3NhZ2UgbmFtZS5cclxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICAgICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMucmVxdWVzdE5hbWUgPSByZXF1ZXN0O1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogUmVzcG9uc2UgbWVzc2FnZSBuYW1lLlxyXG4gICAgICAgICAgICAgICAgICogQHR5cGUge3N0cmluZ31cclxuICAgICAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZXNwb25zZU5hbWUgPSByZXNwb25zZTtcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFJlc29sdmVkIHJlcXVlc3QgbWVzc2FnZSB0eXBlLlxyXG4gICAgICAgICAgICAgICAgICogQHR5cGUge1Byb3RvQnVmLlJlZmxlY3QuTWVzc2FnZX1cclxuICAgICAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZXNvbHZlZFJlcXVlc3RUeXBlID0gbnVsbDtcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFJlc29sdmVkIHJlc3BvbnNlIG1lc3NhZ2UgdHlwZS5cclxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtQcm90b0J1Zi5SZWZsZWN0Lk1lc3NhZ2V9XHJcbiAgICAgICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMucmVzb2x2ZWRSZXNwb25zZVR5cGUgPSBudWxsO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLy8gRXh0ZW5kcyBNZXRob2RcclxuICAgICAgICAgICAgUlBDTWV0aG9kLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTWV0aG9kLnByb3RvdHlwZSk7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQGFsaWFzIFByb3RvQnVmLlJlZmxlY3QuU2VydmljZS5SUENNZXRob2RcclxuICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgUmVmbGVjdC5TZXJ2aWNlLlJQQ01ldGhvZCA9IFJQQ01ldGhvZDtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBSZWZsZWN0O1xyXG4gICAgICAgIH0pKFByb3RvQnVmKTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQGFsaWFzIFByb3RvQnVmLkJ1aWxkZXJcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUHJvdG9CdWYuQnVpbGRlciA9IChmdW5jdGlvbihQcm90b0J1ZiwgTGFuZywgUmVmbGVjdCkge1xyXG4gICAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IEJ1aWxkZXIuXHJcbiAgICAgICAgICAgICAqIEBleHBvcnRzIFByb3RvQnVmLkJ1aWxkZXJcclxuICAgICAgICAgICAgICogQGNsYXNzIFByb3ZpZGVzIHRoZSBmdW5jdGlvbmFsaXR5IHRvIGJ1aWxkIHByb3RvY29sIG1lc3NhZ2VzLlxyXG4gICAgICAgICAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHZhciBCdWlsZGVyID0gZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBOYW1lc3BhY2UuXHJcbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7UHJvdG9CdWYuUmVmbGVjdC5OYW1lc3BhY2V9XHJcbiAgICAgICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMubnMgPSBuZXcgUmVmbGVjdC5OYW1lc3BhY2UobnVsbCwgXCJcIik7IC8vIEdsb2JhbCBuYW1lc3BhY2VcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIE5hbWVzcGFjZSBwb2ludGVyLlxyXG4gICAgICAgICAgICAgICAgICogQHR5cGUge1Byb3RvQnVmLlJlZmxlY3QuVH1cclxuICAgICAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wdHIgPSB0aGlzLm5zO1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogUmVzb2x2ZWQgZmxhZy5cclxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlc29sdmVkID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBUaGUgY3VycmVudCBidWlsZGluZyByZXN1bHQuXHJcbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlfE9iamVjdD58bnVsbH1cclxuICAgICAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZXN1bHQgPSBudWxsO1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogSW1wb3J0ZWQgZmlsZXMuXHJcbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPHN0cmluZz59XHJcbiAgICAgICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuZmlsZXMgPSB7fTtcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEltcG9ydCByb290IG92ZXJyaWRlLlxyXG4gICAgICAgICAgICAgICAgICogQHR5cGUgez9zdHJpbmd9XHJcbiAgICAgICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuaW1wb3J0Um9vdCA9IG51bGw7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUmVzZXRzIHRoZSBwb2ludGVyIHRvIHRoZSByb290IG5hbWVzcGFjZS5cclxuICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQnVpbGRlci5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucHRyID0gdGhpcy5ucztcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBEZWZpbmVzIGEgcGFja2FnZSBvbiB0b3Agb2YgdGhlIGN1cnJlbnQgcG9pbnRlciBwb3NpdGlvbiBhbmQgcGxhY2VzIHRoZSBwb2ludGVyIG9uIGl0LlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGtnXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj49fSBvcHRpb25zXHJcbiAgICAgICAgICAgICAqIEByZXR1cm4ge1Byb3RvQnVmLkJ1aWxkZXJ9IHRoaXNcclxuICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYWNrYWdlIG5hbWUgaXMgaW52YWxpZFxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBCdWlsZGVyLnByb3RvdHlwZS5kZWZpbmUgPSBmdW5jdGlvbihwa2csIG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcGtnICE9PSAnc3RyaW5nJyB8fCAhTGFuZy5UWVBFUkVGLnRlc3QocGtnKSlcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIklsbGVnYWwgcGFja2FnZTogXCIrcGtnKTtcclxuICAgICAgICAgICAgICAgIHZhciBwYXJ0ID0gcGtnLnNwbGl0KFwiLlwiKSwgaTtcclxuICAgICAgICAgICAgICAgIGZvciAoaT0wOyBpPHBhcnQubGVuZ3RoOyBpKyspIC8vIFRvIGJlIGFic29sdXRlbHkgc3VyZVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghTGFuZy5OQU1FLnRlc3QocGFydFtpXSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCBwYWNrYWdlOiBcIitwYXJ0W2ldKTtcclxuICAgICAgICAgICAgICAgIGZvciAoaT0wOyBpPHBhcnQubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMucHRyLmhhc0NoaWxkKHBhcnRbaV0pKSAvLyBLZWVwIGV4aXN0aW5nIG5hbWVzcGFjZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnB0ci5hZGRDaGlsZChuZXcgUmVmbGVjdC5OYW1lc3BhY2UodGhpcy5wdHIsIHBhcnRbaV0sIG9wdGlvbnMpKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnB0ciA9IHRoaXMucHRyLmdldENoaWxkKHBhcnRbaV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGVzdHMgaWYgYSBkZWZpbml0aW9uIGlzIGEgdmFsaWQgbWVzc2FnZSBkZWZpbml0aW9uLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBkZWYgRGVmaW5pdGlvblxyXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIHZhbGlkLCBlbHNlIGZhbHNlXHJcbiAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEJ1aWxkZXIuaXNWYWxpZE1lc3NhZ2UgPSBmdW5jdGlvbihkZWYpIHtcclxuICAgICAgICAgICAgICAgIC8vIE1lc3NhZ2VzIHJlcXVpcmUgYSBzdHJpbmcgbmFtZVxyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkZWZbXCJuYW1lXCJdICE9PSAnc3RyaW5nJyB8fCAhTGFuZy5OQU1FLnRlc3QoZGVmW1wibmFtZVwiXSkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgLy8gTWVzc2FnZXMgbXVzdCBub3QgY29udGFpbiB2YWx1ZXMgKHRoYXQnZCBiZSBhbiBlbnVtKSBvciBtZXRob2RzICh0aGF0J2QgYmUgYSBzZXJ2aWNlKVxyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkZWZbXCJ2YWx1ZXNcIl0gIT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBkZWZbXCJycGNcIl0gIT09ICd1bmRlZmluZWQnKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIC8vIEZpZWxkcywgZW51bXMgYW5kIG1lc3NhZ2VzIGFyZSBhcnJheXMgaWYgcHJvdmlkZWRcclxuICAgICAgICAgICAgICAgIHZhciBpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkZWZbXCJmaWVsZHNcIl0gIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFQcm90b0J1Zi5VdGlsLmlzQXJyYXkoZGVmW1wiZmllbGRzXCJdKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpZHMgPSBbXSwgaWQ7IC8vIElEcyBtdXN0IGJlIHVuaXF1ZVxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaT0wOyBpPGRlZltcImZpZWxkc1wiXS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIUJ1aWxkZXIuaXNWYWxpZE1lc3NhZ2VGaWVsZChkZWZbXCJmaWVsZHNcIl1baV0pKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZCA9IHBhcnNlSW50KGRlZltcImZpZWxkc1wiXVtpXVtcImlkXCJdLCAxMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpZHMuaW5kZXhPZihpZCkgPj0gMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWRzLnB1c2goaWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZHMgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkZWZbXCJlbnVtc1wiXSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIVByb3RvQnVmLlV0aWwuaXNBcnJheShkZWZbXCJlbnVtc1wiXSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGk9MDsgaTxkZWZbXCJlbnVtc1wiXS5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFCdWlsZGVyLmlzVmFsaWRFbnVtKGRlZltcImVudW1zXCJdW2ldKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZGVmW1wibWVzc2FnZXNcIl0gIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFQcm90b0J1Zi5VdGlsLmlzQXJyYXkoZGVmW1wibWVzc2FnZXNcIl0pKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpPTA7IGk8ZGVmW1wibWVzc2FnZXNcIl0ubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghQnVpbGRlci5pc1ZhbGlkTWVzc2FnZShkZWZbXCJtZXNzYWdlc1wiXVtpXSkgJiYgIUJ1aWxkZXIuaXNWYWxpZEV4dGVuZChkZWZbXCJtZXNzYWdlc1wiXVtpXSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGRlZltcImV4dGVuc2lvbnNcIl0gIT09ICd1bmRlZmluZWQnKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghUHJvdG9CdWYuVXRpbC5pc0FycmF5KGRlZltcImV4dGVuc2lvbnNcIl0pIHx8IGRlZltcImV4dGVuc2lvbnNcIl0ubGVuZ3RoICE9PSAyIHx8IHR5cGVvZiBkZWZbXCJleHRlbnNpb25zXCJdWzBdICE9PSAnbnVtYmVyJyB8fCB0eXBlb2YgZGVmW1wiZXh0ZW5zaW9uc1wiXVsxXSAhPT0gJ251bWJlcicpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRlc3RzIGlmIGEgZGVmaW5pdGlvbiBpcyBhIHZhbGlkIG1lc3NhZ2UgZmllbGQgZGVmaW5pdGlvbi5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGRlZiBEZWZpbml0aW9uXHJcbiAgICAgICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgdmFsaWQsIGVsc2UgZmFsc2VcclxuICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQnVpbGRlci5pc1ZhbGlkTWVzc2FnZUZpZWxkID0gZnVuY3Rpb24oZGVmKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBNZXNzYWdlIGZpZWxkcyByZXF1aXJlIGEgc3RyaW5nIHJ1bGUsIG5hbWUgYW5kIHR5cGUgYW5kIGFuIGlkXHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGRlZltcInJ1bGVcIl0gIT09ICdzdHJpbmcnIHx8IHR5cGVvZiBkZWZbXCJuYW1lXCJdICE9PSAnc3RyaW5nJyB8fCB0eXBlb2YgZGVmW1widHlwZVwiXSAhPT0gJ3N0cmluZycgfHwgdHlwZW9mIGRlZltcImlkXCJdID09PSAndW5kZWZpbmVkJylcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBpZiAoIUxhbmcuUlVMRS50ZXN0KGRlZltcInJ1bGVcIl0pIHx8ICFMYW5nLk5BTUUudGVzdChkZWZbXCJuYW1lXCJdKSB8fCAhTGFuZy5UWVBFUkVGLnRlc3QoZGVmW1widHlwZVwiXSkgfHwgIUxhbmcuSUQudGVzdChcIlwiK2RlZltcImlkXCJdKSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGRlZltcIm9wdGlvbnNcIl0gIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gT3B0aW9ucyBhcmUgb2JqZWN0c1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZGVmW1wib3B0aW9uc1wiXSAhPT0gJ29iamVjdCcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBPcHRpb25zIGFyZSA8c3RyaW5nLHN0cmluZ3xudW1iZXJ8Ym9vbGVhbj5cclxuICAgICAgICAgICAgICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGRlZltcIm9wdGlvbnNcIl0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGk9MCwga2V5OyBpPGtleXMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKGtleSA9IGtleXNbaV0pICE9PSAnc3RyaW5nJyB8fCAodHlwZW9mIGRlZltcIm9wdGlvbnNcIl1ba2V5XSAhPT0gJ3N0cmluZycgJiYgdHlwZW9mIGRlZltcIm9wdGlvbnNcIl1ba2V5XSAhPT0gJ251bWJlcicgJiYgdHlwZW9mIGRlZltcIm9wdGlvbnNcIl1ba2V5XSAhPT0gJ2Jvb2xlYW4nKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRlc3RzIGlmIGEgZGVmaW5pdGlvbiBpcyBhIHZhbGlkIGVudW0gZGVmaW5pdGlvbi5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGRlZiBEZWZpbml0aW9uXHJcbiAgICAgICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgdmFsaWQsIGVsc2UgZmFsc2VcclxuICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQnVpbGRlci5pc1ZhbGlkRW51bSA9IGZ1bmN0aW9uKGRlZikge1xyXG4gICAgICAgICAgICAgICAgLy8gRW51bXMgcmVxdWlyZSBhIHN0cmluZyBuYW1lXHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGRlZltcIm5hbWVcIl0gIT09ICdzdHJpbmcnIHx8ICFMYW5nLk5BTUUudGVzdChkZWZbXCJuYW1lXCJdKSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAvLyBFbnVtcyByZXF1aXJlIGF0IGxlYXN0IG9uZSB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkZWZbXCJ2YWx1ZXNcIl0gPT09ICd1bmRlZmluZWQnIHx8ICFQcm90b0J1Zi5VdGlsLmlzQXJyYXkoZGVmW1widmFsdWVzXCJdKSB8fCBkZWZbXCJ2YWx1ZXNcIl0ubGVuZ3RoID09IDApXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpPGRlZltcInZhbHVlc1wiXS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFZhbHVlcyBhcmUgb2JqZWN0c1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZGVmW1widmFsdWVzXCJdW2ldICE9IFwib2JqZWN0XCIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBWYWx1ZXMgcmVxdWlyZSBhIHN0cmluZyBuYW1lIGFuZCBhbiBpZFxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZGVmW1widmFsdWVzXCJdW2ldW1wibmFtZVwiXSAhPT0gJ3N0cmluZycgfHwgdHlwZW9mIGRlZltcInZhbHVlc1wiXVtpXVtcImlkXCJdID09PSAndW5kZWZpbmVkJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghTGFuZy5OQU1FLnRlc3QoZGVmW1widmFsdWVzXCJdW2ldW1wibmFtZVwiXSkgfHwgIUxhbmcuTkVHSUQudGVzdChcIlwiK2RlZltcInZhbHVlc1wiXVtpXVtcImlkXCJdKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gSXQncyBub3QgaW1wb3J0YW50IGlmIHRoZXJlIGFyZSBvdGhlciBmaWVsZHMgYmVjYXVzZSBbXCJ2YWx1ZXNcIl0gaXMgYWxyZWFkeSB1bmlxdWVcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIENyZWF0ZXMgdGhzIHNwZWNpZmllZCBwcm90b2NvbCB0eXBlcyBhdCB0aGUgY3VycmVudCBwb2ludGVyIHBvc2l0aW9uLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5LjxPYmplY3QuPHN0cmluZywqPj59IGRlZnMgTWVzc2FnZXMsIGVudW1zIG9yIHNlcnZpY2VzIHRvIGNyZWF0ZVxyXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHtQcm90b0J1Zi5CdWlsZGVyfSB0aGlzXHJcbiAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiBhIG1lc3NhZ2UgZGVmaW5pdGlvbiBpcyBpbnZhbGlkXHJcbiAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEJ1aWxkZXIucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uKGRlZnMpIHtcclxuICAgICAgICAgICAgICAgIGlmICghZGVmcylcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpczsgLy8gTm90aGluZyB0byBjcmVhdGVcclxuICAgICAgICAgICAgICAgIGlmICghUHJvdG9CdWYuVXRpbC5pc0FycmF5KGRlZnMpKVxyXG4gICAgICAgICAgICAgICAgICAgIGRlZnMgPSBbZGVmc107XHJcbiAgICAgICAgICAgICAgICBpZiAoZGVmcy5sZW5ndGggPT0gMClcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBJdCdzIHF1aXRlIGhhcmQgdG8ga2VlcCB0cmFjayBvZiBzY29wZXMgYW5kIG1lbW9yeSBoZXJlLCBzbyBsZXQncyBkbyB0aGlzIGl0ZXJhdGl2ZWx5LlxyXG4gICAgICAgICAgICAgICAgdmFyIHN0YWNrID0gW10sIGRlZiwgb2JqLCBzdWJPYmosIGksIGo7XHJcbiAgICAgICAgICAgICAgICBzdGFjay5wdXNoKGRlZnMpOyAvLyBPbmUgbGV2ZWwgW2EsIGIsIGNdXHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZnMgPSBzdGFjay5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoUHJvdG9CdWYuVXRpbC5pc0FycmF5KGRlZnMpKSB7IC8vIFN0YWNrIGFsd2F5cyBjb250YWlucyBlbnRpcmUgbmFtZXNwYWNlc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoZGVmcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWYgPSBkZWZzLnNoaWZ0KCk7IC8vIE5hbWVzcGFjZSBhbHdheXMgY29udGFpbnMgYW4gYXJyYXkgb2YgbWVzc2FnZXMsIGVudW1zIGFuZCBzZXJ2aWNlc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEJ1aWxkZXIuaXNWYWxpZE1lc3NhZ2UoZGVmKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iaiA9IG5ldyBSZWZsZWN0Lk1lc3NhZ2UodGhpcy5wdHIsIGRlZltcIm5hbWVcIl0sIGRlZltcIm9wdGlvbnNcIl0sIGRlZltcImlzR3JvdXBcIl0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBmaWVsZHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVmW1wiZmllbGRzXCJdICYmIGRlZltcImZpZWxkc1wiXS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaT0wOyBpPGRlZltcImZpZWxkc1wiXS5sZW5ndGg7IGkrKykgeyAvLyBpPUZpZWxkc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9iai5oYXNDaGlsZChkZWZbJ2ZpZWxkcyddW2ldWydpZCddKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIkR1cGxpY2F0ZSBmaWVsZCBpZCBpbiBtZXNzYWdlIFwiK29iai5uYW1lK1wiOiBcIitkZWZbJ2ZpZWxkcyddW2ldWydpZCddKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWZbXCJmaWVsZHNcIl1baV1bXCJvcHRpb25zXCJdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViT2JqID0gT2JqZWN0LmtleXMoZGVmW1wiZmllbGRzXCJdW2ldW1wib3B0aW9uc1wiXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChqPTA7IGo8c3ViT2JqLmxlbmd0aDsgaisrKSB7IC8vIGo9T3B0aW9uIG5hbWVzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc3ViT2JqW2pdICE9PSAnc3RyaW5nJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCBmaWVsZCBvcHRpb24gbmFtZSBpbiBtZXNzYWdlIFwiK29iai5uYW1lK1wiI1wiK2RlZltcImZpZWxkc1wiXVtpXVtcIm5hbWVcIl0rXCI6IFwiK3N1Yk9ialtqXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZGVmW1wiZmllbGRzXCJdW2ldW1wib3B0aW9uc1wiXVtzdWJPYmpbal1dICE9PSAnc3RyaW5nJyAmJiB0eXBlb2YgZGVmW1wiZmllbGRzXCJdW2ldW1wib3B0aW9uc1wiXVtzdWJPYmpbal1dICE9PSAnbnVtYmVyJyAmJiB0eXBlb2YgZGVmW1wiZmllbGRzXCJdW2ldW1wib3B0aW9uc1wiXVtzdWJPYmpbal1dICE9PSAnYm9vbGVhbicpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIklsbGVnYWwgZmllbGQgb3B0aW9uIHZhbHVlIGluIG1lc3NhZ2UgXCIrb2JqLm5hbWUrXCIjXCIrZGVmW1wiZmllbGRzXCJdW2ldW1wibmFtZVwiXStcIiNcIitzdWJPYmpbal0rXCI6IFwiK2RlZltcImZpZWxkc1wiXVtpXVtcIm9wdGlvbnNcIl1bc3ViT2JqW2pdXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Yk9iaiA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmouYWRkQ2hpbGQobmV3IFJlZmxlY3QuTWVzc2FnZS5GaWVsZChvYmosIGRlZltcImZpZWxkc1wiXVtpXVtcInJ1bGVcIl0sIGRlZltcImZpZWxkc1wiXVtpXVtcInR5cGVcIl0sIGRlZltcImZpZWxkc1wiXVtpXVtcIm5hbWVcIl0sIGRlZltcImZpZWxkc1wiXVtpXVtcImlkXCJdLCBkZWZbXCJmaWVsZHNcIl1baV1bXCJvcHRpb25zXCJdKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUHVzaCBlbnVtcyBhbmQgbWVzc2FnZXMgdG8gc3RhY2tcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJPYmogPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGRlZltcImVudW1zXCJdICE9PSAndW5kZWZpbmVkJyAmJiBkZWZbJ2VudW1zJ10ubGVuZ3RoID4gMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpPTA7IGk8ZGVmW1wiZW51bXNcIl0ubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJPYmoucHVzaChkZWZbXCJlbnVtc1wiXVtpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlZltcIm1lc3NhZ2VzXCJdICYmIGRlZltcIm1lc3NhZ2VzXCJdLmxlbmd0aCA+IDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaT0wOyBpPGRlZltcIm1lc3NhZ2VzXCJdLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViT2JqLnB1c2goZGVmW1wibWVzc2FnZXNcIl1baV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNldCBleHRlbnNpb24gcmFuZ2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVmW1wiZXh0ZW5zaW9uc1wiXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmouZXh0ZW5zaW9ucyA9IGRlZltcImV4dGVuc2lvbnNcIl07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvYmouZXh0ZW5zaW9uc1swXSA8IFByb3RvQnVmLklEX01JTilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iai5leHRlbnNpb25zWzBdID0gUHJvdG9CdWYuSURfTUlOO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob2JqLmV4dGVuc2lvbnNbMV0gPiBQcm90b0J1Zi5JRF9NQVgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmouZXh0ZW5zaW9uc1sxXSA9IFByb3RvQnVmLklEX01BWDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wdHIuYWRkQ2hpbGQob2JqKTsgLy8gQWRkIHRvIGN1cnJlbnQgbmFtZXNwYWNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN1Yk9iai5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goZGVmcyk7IC8vIFB1c2ggdGhlIGN1cnJlbnQgbGV2ZWwgYmFja1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZzID0gc3ViT2JqOyAvLyBDb250aW51ZSBwcm9jZXNzaW5nIHN1YiBsZXZlbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJPYmogPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnB0ciA9IG9iajsgLy8gQW5kIG1vdmUgdGhlIHBvaW50ZXIgdG8gdGhpcyBuYW1lc3BhY2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Yk9iaiA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoQnVpbGRlci5pc1ZhbGlkRW51bShkZWYpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqID0gbmV3IFJlZmxlY3QuRW51bSh0aGlzLnB0ciwgZGVmW1wibmFtZVwiXSwgZGVmW1wib3B0aW9uc1wiXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpPTA7IGk8ZGVmW1widmFsdWVzXCJdLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmouYWRkQ2hpbGQobmV3IFJlZmxlY3QuRW51bS5WYWx1ZShvYmosIGRlZltcInZhbHVlc1wiXVtpXVtcIm5hbWVcIl0sIGRlZltcInZhbHVlc1wiXVtpXVtcImlkXCJdKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wdHIuYWRkQ2hpbGQob2JqKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmogPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChCdWlsZGVyLmlzVmFsaWRTZXJ2aWNlKGRlZikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmogPSBuZXcgUmVmbGVjdC5TZXJ2aWNlKHRoaXMucHRyLCBkZWZbXCJuYW1lXCJdLCBkZWZbXCJvcHRpb25zXCJdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgaW4gZGVmW1wicnBjXCJdKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVmW1wicnBjXCJdLmhhc093blByb3BlcnR5KGkpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqLmFkZENoaWxkKG5ldyBSZWZsZWN0LlNlcnZpY2UuUlBDTWV0aG9kKG9iaiwgaSwgZGVmW1wicnBjXCJdW2ldW1wicmVxdWVzdFwiXSwgZGVmW1wicnBjXCJdW2ldW1wicmVzcG9uc2VcIl0sIGRlZltcInJwY1wiXVtpXVtcIm9wdGlvbnNcIl0pKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnB0ci5hZGRDaGlsZChvYmopO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iaiA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKEJ1aWxkZXIuaXNWYWxpZEV4dGVuZChkZWYpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqID0gdGhpcy5wdHIucmVzb2x2ZShkZWZbXCJyZWZcIl0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvYmopIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpPTA7IGk8ZGVmW1wiZmllbGRzXCJdLmxlbmd0aDsgaSsrKSB7IC8vIGk9RmllbGRzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob2JqLmhhc0NoaWxkKGRlZlsnZmllbGRzJ11baV1bJ2lkJ10pKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiRHVwbGljYXRlIGV4dGVuZGVkIGZpZWxkIGlkIGluIG1lc3NhZ2UgXCIrb2JqLm5hbWUrXCI6IFwiK2RlZlsnZmllbGRzJ11baV1bJ2lkJ10pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlZlsnZmllbGRzJ11baV1bJ2lkJ10gPCBvYmouZXh0ZW5zaW9uc1swXSB8fCBkZWZbJ2ZpZWxkcyddW2ldWydpZCddID4gb2JqLmV4dGVuc2lvbnNbMV0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIGV4dGVuZGVkIGZpZWxkIGlkIGluIG1lc3NhZ2UgXCIrb2JqLm5hbWUrXCI6IFwiK2RlZlsnZmllbGRzJ11baV1bJ2lkJ10rXCIgKFwiK29iai5leHRlbnNpb25zLmpvaW4oJyB0byAnKStcIiBleHBlY3RlZClcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBTZWUgIzE2MVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogc3ViT2JqID0gbmV3ICh0aGlzLnB0ciBpbnN0YW5jZW9mIFJlZmxlY3QuTWVzc2FnZSA/IFJlZmxlY3QuTWVzc2FnZS5FeHRlbnNpb25GaWVsZCA6IFJlZmxlY3QuTWVzc2FnZS5GaWVsZCkob2JqLCBkZWZbXCJmaWVsZHNcIl1baV1bXCJydWxlXCJdLCBkZWZbXCJmaWVsZHNcIl1baV1bXCJ0eXBlXCJdLCBkZWZbXCJmaWVsZHNcIl1baV1bXCJuYW1lXCJdLCBkZWZbXCJmaWVsZHNcIl1baV1bXCJpZFwiXSwgZGVmW1wiZmllbGRzXCJdW2ldW1wib3B0aW9uc1wiXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wdHIgaW5zdGFuY2VvZiBSZWZsZWN0Lk1lc3NhZ2UpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wdHIuYWRkQ2hpbGQoc3ViT2JqKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmouYWRkQ2hpbGQoc3ViT2JqKTsgKi9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iai5hZGRDaGlsZChuZXcgUmVmbGVjdC5NZXNzYWdlLkZpZWxkKG9iaiwgZGVmW1wiZmllbGRzXCJdW2ldW1wicnVsZVwiXSwgZGVmW1wiZmllbGRzXCJdW2ldW1widHlwZVwiXSwgZGVmW1wiZmllbGRzXCJdW2ldW1wibmFtZVwiXSwgZGVmW1wiZmllbGRzXCJdW2ldW1wiaWRcIl0sIGRlZltcImZpZWxkc1wiXVtpXVtcIm9wdGlvbnNcIl0pKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIS9cXC4/Z29vZ2xlXFwucHJvdG9idWZcXC4vLnRlc3QoZGVmW1wicmVmXCJdKSkgLy8gU2lsZW50bHkgc2tpcCBpbnRlcm5hbCBleHRlbnNpb25zXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiRXh0ZW5kZWQgbWVzc2FnZSBcIitkZWZbXCJyZWZcIl0rXCIgaXMgbm90IGRlZmluZWRcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIk5vdCBhIHZhbGlkIGRlZmluaXRpb246IFwiK0pTT04uc3RyaW5naWZ5KGRlZikpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBCcmVhayBnb2VzIGhlcmVcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJOb3QgYSB2YWxpZCBuYW1lc3BhY2U6IFwiK0pTT04uc3RyaW5naWZ5KGRlZnMpKTtcclxuICAgICAgICAgICAgICAgICAgICBkZWZzID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnB0ciA9IHRoaXMucHRyLnBhcmVudDsgLy8gVGhpcyBuYW1lc3BhY2UgaXMgcyBkb25lXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlc29sdmVkID0gZmFsc2U7IC8vIFJlcXVpcmUgcmUtcmVzb2x2ZVxyXG4gICAgICAgICAgICAgICAgdGhpcy5yZXN1bHQgPSBudWxsOyAvLyBSZXF1aXJlIHJlLWJ1aWxkXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBJbXBvcnRzIGFub3RoZXIgZGVmaW5pdGlvbiBpbnRvIHRoaXMgYnVpbGRlci5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0ganNvbiBQYXJzZWQgaW1wb3J0XHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7KHN0cmluZ3x7cm9vdDogc3RyaW5nLCBmaWxlOiBzdHJpbmd9KT19IGZpbGVuYW1lIEltcG9ydGVkIGZpbGUgbmFtZVxyXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHtQcm90b0J1Zi5CdWlsZGVyfSB0aGlzXHJcbiAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgZGVmaW5pdGlvbiBvciBmaWxlIGNhbm5vdCBiZSBpbXBvcnRlZFxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBCdWlsZGVyLnByb3RvdHlwZVtcImltcG9ydFwiXSA9IGZ1bmN0aW9uKGpzb24sIGZpbGVuYW1lKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZpbGVuYW1lID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChQcm90b0J1Zi5VdGlsLklTX05PREUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVuYW1lID0gcmVxdWlyZShcInBhdGhcIilbJ3Jlc29sdmUnXShmaWxlbmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZmlsZXNbZmlsZW5hbWVdID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7IC8vIFNraXAgZHVwbGljYXRlIGltcG9ydHNcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maWxlc1tmaWxlbmFtZV0gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCEhanNvblsnaW1wb3J0cyddICYmIGpzb25bJ2ltcG9ydHMnXS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGltcG9ydFJvb3QsIGRlbGltID0gJy8nLCByZXNldFJvb3QgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZpbGVuYW1lID09PSAnb2JqZWN0JykgeyAvLyBJZiBhbiBpbXBvcnQgcm9vdCBpcyBzcGVjaWZpZWQsIG92ZXJyaWRlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW1wb3J0Um9vdCA9IGZpbGVuYW1lW1wicm9vdFwiXTsgcmVzZXRSb290ID0gdHJ1ZTsgLy8gLi4uIGFuZCByZXNldCBhZnRlcndhcmRzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGltcG9ydFJvb3QgPSB0aGlzLmltcG9ydFJvb3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVuYW1lID0gZmlsZW5hbWVbXCJmaWxlXCJdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW1wb3J0Um9vdC5pbmRleE9mKFwiXFxcXFwiKSA+PSAwIHx8IGZpbGVuYW1lLmluZGV4T2YoXCJcXFxcXCIpID49IDApIGRlbGltID0gJ1xcXFwnO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGZpbGVuYW1lID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pbXBvcnRSb290KSAvLyBJZiBpbXBvcnQgcm9vdCBpcyBvdmVycmlkZGVuLCB1c2UgaXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltcG9ydFJvb3QgPSB0aGlzLmltcG9ydFJvb3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgeyAvLyBPdGhlcndpc2UgY29tcHV0ZSBmcm9tIGZpbGVuYW1lXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlsZW5hbWUuaW5kZXhPZihcIi9cIikgPj0gMCkgeyAvLyBVbml4XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1wb3J0Um9vdCA9IGZpbGVuYW1lLnJlcGxhY2UoL1xcL1teXFwvXSokLywgXCJcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKC8qIC9maWxlLnByb3RvICovIGltcG9ydFJvb3QgPT09IFwiXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltcG9ydFJvb3QgPSBcIi9cIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZmlsZW5hbWUuaW5kZXhPZihcIlxcXFxcIikgPj0gMCkgeyAvLyBXaW5kb3dzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1wb3J0Um9vdCA9IGZpbGVuYW1lLnJlcGxhY2UoL1xcXFxbXlxcXFxdKiQvLCBcIlwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxpbSA9ICdcXFxcJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltcG9ydFJvb3QgPSBcIi5cIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbXBvcnRSb290ID0gbnVsbDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpPGpzb25bJ2ltcG9ydHMnXS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGpzb25bJ2ltcG9ydHMnXVtpXSA9PT0gJ3N0cmluZycpIHsgLy8gSW1wb3J0IGZpbGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaW1wb3J0Um9vdClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIkNhbm5vdCBkZXRlcm1pbmUgaW1wb3J0IHJvb3Q6IEZpbGUgbmFtZSBpcyB1bmtub3duXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGltcG9ydEZpbGVuYW1lID0ganNvblsnaW1wb3J0cyddW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKC9eZ29vZ2xlXFwvcHJvdG9idWZcXC8vLnRlc3QoaW1wb3J0RmlsZW5hbWUpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlOyAvLyBOb3QgbmVlZGVkIGFuZCB0aGVyZWZvcmUgbm90IHVzZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltcG9ydEZpbGVuYW1lID0gaW1wb3J0Um9vdCtkZWxpbStpbXBvcnRGaWxlbmFtZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmZpbGVzW2ltcG9ydEZpbGVuYW1lXSA9PT0gdHJ1ZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTsgLy8gQWxyZWFkeSBpbXBvcnRlZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKC9cXC5wcm90byQvaS50ZXN0KGltcG9ydEZpbGVuYW1lKSAmJiAhUHJvdG9CdWYuRG90UHJvdG8pICAgICAvLyBJZiB0aGlzIGlzIGEgTk9QQVJTRSBidWlsZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltcG9ydEZpbGVuYW1lID0gaW1wb3J0RmlsZW5hbWUucmVwbGFjZSgvXFwucHJvdG8kLywgXCIuanNvblwiKTsgLy8gYWx3YXlzIGxvYWQgdGhlIEpTT04gZmlsZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRlbnRzID0gUHJvdG9CdWYuVXRpbC5mZXRjaChpbXBvcnRGaWxlbmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGVudHMgPT09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJGYWlsZWQgdG8gaW1wb3J0ICdcIitpbXBvcnRGaWxlbmFtZStcIicgaW4gJ1wiK2ZpbGVuYW1lK1wiJzogRmlsZSBub3QgZm91bmRcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoL1xcLmpzb24kL2kudGVzdChpbXBvcnRGaWxlbmFtZSkpIC8vIEFsd2F5cyBwb3NzaWJsZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbXCJpbXBvcnRcIl0oSlNPTi5wYXJzZShjb250ZW50cytcIlwiKSwgaW1wb3J0RmlsZW5hbWUpOyAvLyBNYXkgdGhyb3dcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW1wiaW1wb3J0XCJdKChuZXcgUHJvdG9CdWYuRG90UHJvdG8uUGFyc2VyKGNvbnRlbnRzK1wiXCIpKS5wYXJzZSgpLCBpbXBvcnRGaWxlbmFtZSk7IC8vIE1heSB0aHJvd1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgLy8gSW1wb3J0IHN0cnVjdHVyZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFmaWxlbmFtZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW1wiaW1wb3J0XCJdKGpzb25bJ2ltcG9ydHMnXVtpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICgvXFwuKFxcdyspJC8udGVzdChmaWxlbmFtZSkpIC8vIFdpdGggZXh0ZW5zaW9uOiBBcHBlbmQgX2ltcG9ydE4gdG8gdGhlIG5hbWUgcG9ydGlvbiB0byBtYWtlIGl0IHVuaXF1ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbXCJpbXBvcnRcIl0oanNvblsnaW1wb3J0cyddW2ldLCBmaWxlbmFtZS5yZXBsYWNlKC9eKC4rKVxcLihcXHcrKSQvLCBmdW5jdGlvbigkMCwgJDEsICQyKSB7IHJldHVybiAkMStcIl9pbXBvcnRcIitpK1wiLlwiKyQyOyB9KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIC8vIFdpdGhvdXQgZXh0ZW5zaW9uOiBBcHBlbmQgX2ltcG9ydE4gdG8gbWFrZSBpdCB1bmlxdWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW1wiaW1wb3J0XCJdKGpzb25bJ2ltcG9ydHMnXVtpXSwgZmlsZW5hbWUrXCJfaW1wb3J0XCIraSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNldFJvb3QpIC8vIFJlc2V0IGltcG9ydCByb290IG92ZXJyaWRlIHdoZW4gYWxsIGltcG9ydHMgYXJlIGRvbmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbXBvcnRSb290ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChqc29uWydtZXNzYWdlcyddKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGpzb25bJ3BhY2thZ2UnXSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWZpbmUoanNvblsncGFja2FnZSddLCBqc29uW1wib3B0aW9uc1wiXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jcmVhdGUoanNvblsnbWVzc2FnZXMnXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGpzb25bJ2VudW1zJ10pIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoanNvblsncGFja2FnZSddKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRlZmluZShqc29uWydwYWNrYWdlJ10sIGpzb25bXCJvcHRpb25zXCJdKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZShqc29uWydlbnVtcyddKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc2V0KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoanNvblsnc2VydmljZXMnXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChqc29uWydwYWNrYWdlJ10pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVmaW5lKGpzb25bJ3BhY2thZ2UnXSwganNvbltcIm9wdGlvbnNcIl0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlKGpzb25bJ3NlcnZpY2VzJ10pO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChqc29uWydleHRlbmRzJ10pIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoanNvblsncGFja2FnZSddKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRlZmluZShqc29uWydwYWNrYWdlJ10sIGpzb25bXCJvcHRpb25zXCJdKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZShqc29uWydleHRlbmRzJ10pO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRlc3RzIGlmIGEgZGVmaW5pdGlvbiBpcyBhIHZhbGlkIHNlcnZpY2UgZGVmaW5pdGlvbi5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGRlZiBEZWZpbml0aW9uXHJcbiAgICAgICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgdmFsaWQsIGVsc2UgZmFsc2VcclxuICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQnVpbGRlci5pc1ZhbGlkU2VydmljZSA9IGZ1bmN0aW9uKGRlZikge1xyXG4gICAgICAgICAgICAgICAgLy8gU2VydmljZXMgcmVxdWlyZSBhIHN0cmluZyBuYW1lIGFuZCBhbiBycGMgb2JqZWN0XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gISh0eXBlb2YgZGVmW1wibmFtZVwiXSAhPT0gJ3N0cmluZycgfHwgIUxhbmcuTkFNRS50ZXN0KGRlZltcIm5hbWVcIl0pIHx8IHR5cGVvZiBkZWZbXCJycGNcIl0gIT09ICdvYmplY3QnKTtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUZXN0cyBpZiBhIGRlZmluaXRpb24gaXMgYSB2YWxpZCBleHRlbnNpb24uXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkZWYgRGVmaW5pdGlvblxyXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB2YWxpZCwgZWxzZSBmYWxzZVxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEJ1aWxkZXIuaXNWYWxpZEV4dGVuZCA9IGZ1bmN0aW9uKGRlZikge1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkZWZbXCJyZWZcIl0gIT09ICdzdHJpbmcnIHx8ICFMYW5nLlRZUEVSRUYudGVzdChkZWZbXCJyZWZcIl0pKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHZhciBpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkZWZbXCJmaWVsZHNcIl0gIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFQcm90b0J1Zi5VdGlsLmlzQXJyYXkoZGVmW1wiZmllbGRzXCJdKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpZHMgPSBbXSwgaWQ7IC8vIElEcyBtdXN0IGJlIHVuaXF1ZSAoZG9lcyBub3QgeWV0IHRlc3QgZm9yIHRoZSBleHRlbmRlZCBtZXNzYWdlJ3MgaWRzKVxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaT0wOyBpPGRlZltcImZpZWxkc1wiXS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIUJ1aWxkZXIuaXNWYWxpZE1lc3NhZ2VGaWVsZChkZWZbXCJmaWVsZHNcIl1baV0pKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZCA9IHBhcnNlSW50KGRlZltcImlkXCJdLCAxMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpZHMuaW5kZXhPZihpZCkgPj0gMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWRzLnB1c2goaWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZHMgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUmVzb2x2ZXMgYWxsIG5hbWVzcGFjZSBvYmplY3RzLlxyXG4gICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgYSB0eXBlIGNhbm5vdCBiZSByZXNvbHZlZFxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBCdWlsZGVyLnByb3RvdHlwZS5yZXNvbHZlQWxsID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBSZXNvbHZlIGFsbCByZWZsZWN0ZWQgb2JqZWN0c1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlcztcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnB0ciA9PSBudWxsIHx8IHR5cGVvZiB0aGlzLnB0ci50eXBlID09PSAnb2JqZWN0JylcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47IC8vIERvbmUgKGFscmVhZHkgcmVzb2x2ZWQpXHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wdHIgaW5zdGFuY2VvZiBSZWZsZWN0Lk5hbWVzcGFjZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEJ1aWxkIGFsbCBjaGlsZHJlblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMucHRyLmdldENoaWxkcmVuKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpPGNoaWxkcmVuLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnB0ciA9IGNoaWxkcmVuW2ldLCB0aGlzLnJlc29sdmVBbGwoKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5wdHIgaW5zdGFuY2VvZiBSZWZsZWN0Lk1lc3NhZ2UuRmllbGQpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIUxhbmcuVFlQRS50ZXN0KHRoaXMucHRyLnR5cGUpKSB7IC8vIFJlc29sdmUgdHlwZS4uLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIUxhbmcuVFlQRVJFRi50ZXN0KHRoaXMucHRyLnR5cGUpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIHR5cGUgcmVmZXJlbmNlIGluIFwiK3RoaXMucHRyLnRvU3RyaW5nKHRydWUpK1wiOiBcIit0aGlzLnB0ci50eXBlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzID0gdGhpcy5wdHIucGFyZW50LnJlc29sdmUodGhpcy5wdHIudHlwZSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcmVzKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJVbnJlc29sdmFibGUgdHlwZSByZWZlcmVuY2UgaW4gXCIrdGhpcy5wdHIudG9TdHJpbmcodHJ1ZSkrXCI6IFwiK3RoaXMucHRyLnR5cGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnB0ci5yZXNvbHZlZFR5cGUgPSByZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXMgaW5zdGFuY2VvZiBSZWZsZWN0LkVudW0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnB0ci50eXBlID0gUHJvdG9CdWYuVFlQRVNbXCJlbnVtXCJdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChyZXMgaW5zdGFuY2VvZiBSZWZsZWN0Lk1lc3NhZ2UpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnB0ci50eXBlID0gcmVzLmlzR3JvdXAgPyBQcm90b0J1Zi5UWVBFU1tcImdyb3VwXCJdIDogUHJvdG9CdWYuVFlQRVNbXCJtZXNzYWdlXCJdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIklsbGVnYWwgdHlwZSByZWZlcmVuY2UgaW4gXCIrdGhpcy5wdHIudG9TdHJpbmcodHJ1ZSkrXCI6IFwiK3RoaXMucHRyLnR5cGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnB0ci50eXBlID0gUHJvdG9CdWYuVFlQRVNbdGhpcy5wdHIudHlwZV07XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMucHRyIGluc3RhbmNlb2YgUHJvdG9CdWYuUmVmbGVjdC5FbnVtLlZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTm8gbmVlZCB0byBidWlsZCBlbnVtIHZhbHVlcyAoYnVpbHQgaW4gZW51bSlcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5wdHIgaW5zdGFuY2VvZiBQcm90b0J1Zi5SZWZsZWN0LlNlcnZpY2UuTWV0aG9kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucHRyIGluc3RhbmNlb2YgUHJvdG9CdWYuUmVmbGVjdC5TZXJ2aWNlLlJQQ01ldGhvZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXMgPSB0aGlzLnB0ci5wYXJlbnQucmVzb2x2ZSh0aGlzLnB0ci5yZXF1ZXN0TmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcmVzIHx8ICEocmVzIGluc3RhbmNlb2YgUHJvdG9CdWYuUmVmbGVjdC5NZXNzYWdlKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCB0eXBlIHJlZmVyZW5jZSBpbiBcIit0aGlzLnB0ci50b1N0cmluZyh0cnVlKStcIjogXCIrdGhpcy5wdHIucmVxdWVzdE5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnB0ci5yZXNvbHZlZFJlcXVlc3RUeXBlID0gcmVzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXMgPSB0aGlzLnB0ci5wYXJlbnQucmVzb2x2ZSh0aGlzLnB0ci5yZXNwb25zZU5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJlcyB8fCAhKHJlcyBpbnN0YW5jZW9mIFByb3RvQnVmLlJlZmxlY3QuTWVzc2FnZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIklsbGVnYWwgdHlwZSByZWZlcmVuY2UgaW4gXCIrdGhpcy5wdHIudG9TdHJpbmcodHJ1ZSkrXCI6IFwiK3RoaXMucHRyLnJlc3BvbnNlTmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHRyLnJlc29sdmVkUmVzcG9uc2VUeXBlID0gcmVzO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNob3VsZCBub3QgaGFwcGVuIGFzIG5vdGhpbmcgZWxzZSBpcyBpbXBsZW1lbnRlZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIklsbGVnYWwgc2VydmljZSB0eXBlIGluIFwiK3RoaXMucHRyLnRvU3RyaW5nKHRydWUpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IGVsc2VcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIklsbGVnYWwgb2JqZWN0IGluIG5hbWVzcGFjZTogXCIrdHlwZW9mKHRoaXMucHRyKStcIjpcIit0aGlzLnB0cik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2V0KCk7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQnVpbGRzIHRoZSBwcm90b2NvbC4gVGhpcyB3aWxsIGZpcnN0IHRyeSB0byByZXNvbHZlIGFsbCBkZWZpbml0aW9ucyBhbmQsIGlmIHRoaXMgaGFzIGJlZW4gc3VjY2Vzc2Z1bCxcclxuICAgICAgICAgICAgICogcmV0dXJuIHRoZSBidWlsdCBwYWNrYWdlLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZz19IHBhdGggU3BlY2lmaWVzIHdoYXQgdG8gcmV0dXJuLiBJZiBvbWl0dGVkLCB0aGUgZW50aXJlIG5hbWVzcGFjZSB3aWxsIGJlIHJldHVybmVkLlxyXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHtQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2V8T2JqZWN0LjxzdHJpbmcsKj59XHJcbiAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiBhIHR5cGUgY291bGQgbm90IGJlIHJlc29sdmVkXHJcbiAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEJ1aWxkZXIucHJvdG90eXBlLmJ1aWxkID0gZnVuY3Rpb24ocGF0aCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnJlc29sdmVkKVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzb2x2ZUFsbCgpLFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzb2x2ZWQgPSB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzdWx0ID0gbnVsbDsgLy8gUmVxdWlyZSByZS1idWlsZFxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmVzdWx0ID09IG51bGwpIC8vIChSZS0pQnVpbGRcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdCA9IHRoaXMubnMuYnVpbGQoKTtcclxuICAgICAgICAgICAgICAgIGlmICghcGF0aClcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcGFydCA9IHBhdGguc3BsaXQoXCIuXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwdHIgPSB0aGlzLnJlc3VsdDsgLy8gQnVpbGQgbmFtZXNwYWNlIHBvaW50ZXIgKG5vIGhhc0NoaWxkIGV0Yy4pXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpPHBhcnQubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwdHJbcGFydFtpXV0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdHIgPSBwdHJbcGFydFtpXV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHRyID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHB0cjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBTaW1pbGFyIHRvIHtAbGluayBQcm90b0J1Zi5CdWlsZGVyI2J1aWxkfSwgYnV0IGxvb2tzIHVwIHRoZSBpbnRlcm5hbCByZWZsZWN0aW9uIGRlc2NyaXB0b3IuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nPX0gcGF0aCBTcGVjaWZpZXMgd2hhdCB0byByZXR1cm4uIElmIG9taXR0ZWQsIHRoZSBlbnRpcmUgbmFtZXNwYWNlIHdpaWwgYmUgcmV0dXJuZWQuXHJcbiAgICAgICAgICAgICAqIEByZXR1cm4ge1Byb3RvQnVmLlJlZmxlY3QuVH0gUmVmbGVjdGlvbiBkZXNjcmlwdG9yIG9yIGBudWxsYCBpZiBub3QgZm91bmRcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEJ1aWxkZXIucHJvdG90eXBlLmxvb2t1cCA9IGZ1bmN0aW9uKHBhdGgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwYXRoID8gdGhpcy5ucy5yZXNvbHZlKHBhdGgpIDogdGhpcy5ucztcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgb2JqZWN0LlxyXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFN0cmluZyByZXByZXNlbnRhdGlvbiBhcyBvZiBcIkJ1aWxkZXJcIlxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBCdWlsZGVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiQnVpbGRlclwiO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLy8gUHNldWRvIHR5cGVzIGRvY3VtZW50ZWQgaW4gUmVmbGVjdC5qcy5cclxuICAgICAgICAgICAgLy8gRXhpc3QgZm9yIHRoZSBzb2xlIHB1cnBvc2Ugb2YgYmVpbmcgYWJsZSB0byBcIi4uLiBpbnN0YW5jZW9mIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZVwiIGV0Yy5cclxuICAgICAgICAgICAgQnVpbGRlci5NZXNzYWdlID0gZnVuY3Rpb24oKSB7fTtcclxuICAgICAgICAgICAgQnVpbGRlci5TZXJ2aWNlID0gZnVuY3Rpb24oKSB7fTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBCdWlsZGVyO1xyXG5cclxuICAgICAgICB9KShQcm90b0J1ZiwgUHJvdG9CdWYuTGFuZywgUHJvdG9CdWYuUmVmbGVjdCk7XHJcblxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBMb2FkcyBhIC5wcm90byBzdHJpbmcgYW5kIHJldHVybnMgdGhlIEJ1aWxkZXIuXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3RvIC5wcm90byBmaWxlIGNvbnRlbnRzXHJcbiAgICAgICAgICogQHBhcmFtIHsoUHJvdG9CdWYuQnVpbGRlcnxzdHJpbmd8e3Jvb3Q6IHN0cmluZywgZmlsZTogc3RyaW5nfSk9fSBidWlsZGVyIEJ1aWxkZXIgdG8gYXBwZW5kIHRvLiBXaWxsIGNyZWF0ZSBhIG5ldyBvbmUgaWYgb21pdHRlZC5cclxuICAgICAgICAgKiBAcGFyYW0geyhzdHJpbmd8e3Jvb3Q6IHN0cmluZywgZmlsZTogc3RyaW5nfSk9fSBmaWxlbmFtZSBUaGUgY29ycmVzcG9uZGluZyBmaWxlIG5hbWUgaWYga25vd24uIE11c3QgYmUgc3BlY2lmaWVkIGZvciBpbXBvcnRzLlxyXG4gICAgICAgICAqIEByZXR1cm4ge1Byb3RvQnVmLkJ1aWxkZXJ9IEJ1aWxkZXIgdG8gY3JlYXRlIG5ldyBtZXNzYWdlc1xyXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgZGVmaW5pdGlvbiBjYW5ub3QgYmUgcGFyc2VkIG9yIGJ1aWx0XHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFByb3RvQnVmLmxvYWRQcm90byA9IGZ1bmN0aW9uKHByb3RvLCBidWlsZGVyLCBmaWxlbmFtZSkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGJ1aWxkZXIgPT09ICdzdHJpbmcnIHx8IChidWlsZGVyICYmIHR5cGVvZiBidWlsZGVyW1wiZmlsZVwiXSA9PT0gJ3N0cmluZycgJiYgdHlwZW9mIGJ1aWxkZXJbXCJyb290XCJdID09PSAnc3RyaW5nJykpIHtcclxuICAgICAgICAgICAgICAgIGZpbGVuYW1lID0gYnVpbGRlcjtcclxuICAgICAgICAgICAgICAgIGJ1aWxkZXIgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBQcm90b0J1Zi5sb2FkSnNvbigobmV3IFByb3RvQnVmLkRvdFByb3RvLlBhcnNlcihwcm90bykpLnBhcnNlKCksIGJ1aWxkZXIsIGZpbGVuYW1lKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBMb2FkcyBhIC5wcm90byBzdHJpbmcgYW5kIHJldHVybnMgdGhlIEJ1aWxkZXIuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIFByb3RvQnVmLmxvYWRQcm90b30uXHJcbiAgICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3RvIC5wcm90byBmaWxlIGNvbnRlbnRzXHJcbiAgICAgICAgICogQHBhcmFtIHsoUHJvdG9CdWYuQnVpbGRlcnxzdHJpbmcpPX0gYnVpbGRlciBCdWlsZGVyIHRvIGFwcGVuZCB0by4gV2lsbCBjcmVhdGUgYSBuZXcgb25lIGlmIG9taXR0ZWQuXHJcbiAgICAgICAgICogQHBhcmFtIHsoc3RyaW5nfHtyb290OiBzdHJpbmcsIGZpbGU6IHN0cmluZ30pPX0gZmlsZW5hbWUgVGhlIGNvcnJlc3BvbmRpbmcgZmlsZSBuYW1lIGlmIGtub3duLiBNdXN0IGJlIHNwZWNpZmllZCBmb3IgaW1wb3J0cy5cclxuICAgICAgICAgKiBAcmV0dXJuIHtQcm90b0J1Zi5CdWlsZGVyfSBCdWlsZGVyIHRvIGNyZWF0ZSBuZXcgbWVzc2FnZXNcclxuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGRlZmluaXRpb24gY2Fubm90IGJlIHBhcnNlZCBvciBidWlsdFxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBQcm90b0J1Zi5wcm90b0Zyb21TdHJpbmcgPSBQcm90b0J1Zi5sb2FkUHJvdG87IC8vIExlZ2FjeVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBMb2FkcyBhIC5wcm90byBmaWxlIGFuZCByZXR1cm5zIHRoZSBCdWlsZGVyLlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfHtyb290OiBzdHJpbmcsIGZpbGU6IHN0cmluZ319IGZpbGVuYW1lIFBhdGggdG8gcHJvdG8gZmlsZSBvciBhbiBvYmplY3Qgc3BlY2lmeWluZyAnZmlsZScgd2l0aFxyXG4gICAgICAgICAqICBhbiBvdmVycmlkZGVuICdyb290JyBwYXRoIGZvciBhbGwgaW1wb3J0ZWQgZmlsZXMuXHJcbiAgICAgICAgICogQHBhcmFtIHtmdW5jdGlvbig/RXJyb3IsICFQcm90b0J1Zi5CdWlsZGVyPSk9fSBjYWxsYmFjayBDYWxsYmFjayB0aGF0IHdpbGwgcmVjZWl2ZSBgbnVsbGAgYXMgdGhlIGZpcnN0IGFuZFxyXG4gICAgICAgICAqICB0aGUgQnVpbGRlciBhcyBpdHMgc2Vjb25kIGFyZ3VtZW50IG9uIHN1Y2Nlc3MsIG90aGVyd2lzZSB0aGUgZXJyb3IgYXMgaXRzIGZpcnN0IGFyZ3VtZW50LiBJZiBvbWl0dGVkLCB0aGVcclxuICAgICAgICAgKiAgZmlsZSB3aWxsIGJlIHJlYWQgc3luY2hyb25vdXNseSBhbmQgdGhpcyBmdW5jdGlvbiB3aWxsIHJldHVybiB0aGUgQnVpbGRlci5cclxuICAgICAgICAgKiBAcGFyYW0ge1Byb3RvQnVmLkJ1aWxkZXI9fSBidWlsZGVyIEJ1aWxkZXIgdG8gYXBwZW5kIHRvLiBXaWxsIGNyZWF0ZSBhIG5ldyBvbmUgaWYgb21pdHRlZC5cclxuICAgICAgICAgKiBAcmV0dXJuIHs/UHJvdG9CdWYuQnVpbGRlcnx1bmRlZmluZWR9IFRoZSBCdWlsZGVyIGlmIHN5bmNocm9ub3VzIChubyBjYWxsYmFjayBzcGVjaWZpZWQsIHdpbGwgYmUgTlVMTCBpZiB0aGVcclxuICAgICAgICAgKiAgIHJlcXVlc3QgaGFzIGZhaWxlZCksIGVsc2UgdW5kZWZpbmVkXHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFByb3RvQnVmLmxvYWRQcm90b0ZpbGUgPSBmdW5jdGlvbihmaWxlbmFtZSwgY2FsbGJhY2ssIGJ1aWxkZXIpIHtcclxuICAgICAgICAgICAgaWYgKGNhbGxiYWNrICYmIHR5cGVvZiBjYWxsYmFjayA9PT0gJ29iamVjdCcpXHJcbiAgICAgICAgICAgICAgICBidWlsZGVyID0gY2FsbGJhY2ssXHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IG51bGw7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCFjYWxsYmFjayB8fCB0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpXHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IG51bGw7XHJcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaylcclxuICAgICAgICAgICAgICAgIHJldHVybiBQcm90b0J1Zi5VdGlsLmZldGNoKHR5cGVvZiBmaWxlbmFtZSA9PT0gJ3N0cmluZycgPyBmaWxlbmFtZSA6IGZpbGVuYW1lW1wicm9vdFwiXStcIi9cIitmaWxlbmFtZVtcImZpbGVcIl0sIGZ1bmN0aW9uKGNvbnRlbnRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRlbnRzID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKEVycm9yKFwiRmFpbGVkIHRvIGZldGNoIGZpbGVcIikpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIFByb3RvQnVmLmxvYWRQcm90byhjb250ZW50cywgYnVpbGRlciwgZmlsZW5hbWUpKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB2YXIgY29udGVudHMgPSBQcm90b0J1Zi5VdGlsLmZldGNoKHR5cGVvZiBmaWxlbmFtZSA9PT0gJ29iamVjdCcgPyBmaWxlbmFtZVtcInJvb3RcIl0rXCIvXCIrZmlsZW5hbWVbXCJmaWxlXCJdIDogZmlsZW5hbWUpO1xyXG4gICAgICAgICAgICByZXR1cm4gY29udGVudHMgPT09IG51bGwgPyBudWxsIDogUHJvdG9CdWYubG9hZFByb3RvKGNvbnRlbnRzLCBidWlsZGVyLCBmaWxlbmFtZSk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTG9hZHMgYSAucHJvdG8gZmlsZSBhbmQgcmV0dXJucyB0aGUgQnVpbGRlci4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgUHJvdG9CdWYubG9hZFByb3RvRmlsZX0uXHJcbiAgICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd8e3Jvb3Q6IHN0cmluZywgZmlsZTogc3RyaW5nfX0gZmlsZW5hbWUgUGF0aCB0byBwcm90byBmaWxlIG9yIGFuIG9iamVjdCBzcGVjaWZ5aW5nICdmaWxlJyB3aXRoXHJcbiAgICAgICAgICogIGFuIG92ZXJyaWRkZW4gJ3Jvb3QnIHBhdGggZm9yIGFsbCBpbXBvcnRlZCBmaWxlcy5cclxuICAgICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKD9FcnJvciwgIVByb3RvQnVmLkJ1aWxkZXI9KT19IGNhbGxiYWNrIENhbGxiYWNrIHRoYXQgd2lsbCByZWNlaXZlIGBudWxsYCBhcyB0aGUgZmlyc3QgYW5kXHJcbiAgICAgICAgICogIHRoZSBCdWlsZGVyIGFzIGl0cyBzZWNvbmQgYXJndW1lbnQgb24gc3VjY2Vzcywgb3RoZXJ3aXNlIHRoZSBlcnJvciBhcyBpdHMgZmlyc3QgYXJndW1lbnQuIElmIG9taXR0ZWQsIHRoZVxyXG4gICAgICAgICAqICBmaWxlIHdpbGwgYmUgcmVhZCBzeW5jaHJvbm91c2x5IGFuZCB0aGlzIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIHRoZSBCdWlsZGVyLlxyXG4gICAgICAgICAqIEBwYXJhbSB7UHJvdG9CdWYuQnVpbGRlcj19IGJ1aWxkZXIgQnVpbGRlciB0byBhcHBlbmQgdG8uIFdpbGwgY3JlYXRlIGEgbmV3IG9uZSBpZiBvbWl0dGVkLlxyXG4gICAgICAgICAqIEByZXR1cm4geyFQcm90b0J1Zi5CdWlsZGVyfHVuZGVmaW5lZH0gVGhlIEJ1aWxkZXIgaWYgc3luY2hyb25vdXMgKG5vIGNhbGxiYWNrIHNwZWNpZmllZCwgd2lsbCBiZSBOVUxMIGlmIHRoZVxyXG4gICAgICAgICAqICAgcmVxdWVzdCBoYXMgZmFpbGVkKSwgZWxzZSB1bmRlZmluZWRcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUHJvdG9CdWYucHJvdG9Gcm9tRmlsZSA9IFByb3RvQnVmLmxvYWRQcm90b0ZpbGU7IC8vIExlZ2FjeVxyXG5cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29uc3RydWN0cyBhIG5ldyBCdWlsZGVyIHdpdGggdGhlIHNwZWNpZmllZCBwYWNrYWdlIGRlZmluZWQuXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmc9fSBwa2cgUGFja2FnZSBuYW1lIGFzIGZ1bGx5IHF1YWxpZmllZCBuYW1lLCBlLmcuIFwiTXkuR2FtZVwiLiBJZiBubyBwYWNrYWdlIGlzIHNwZWNpZmllZCwgdGhlXHJcbiAgICAgICAgICogYnVpbGRlciB3aWxsIG9ubHkgY29udGFpbiBhIGdsb2JhbCBuYW1lc3BhY2UuXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPj19IG9wdGlvbnMgVG9wIGxldmVsIG9wdGlvbnNcclxuICAgICAgICAgKiBAcmV0dXJuIHtQcm90b0J1Zi5CdWlsZGVyfSBOZXcgQnVpbGRlclxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBQcm90b0J1Zi5uZXdCdWlsZGVyID0gZnVuY3Rpb24ocGtnLCBvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIHZhciBidWlsZGVyID0gbmV3IFByb3RvQnVmLkJ1aWxkZXIoKTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBwa2cgIT09ICd1bmRlZmluZWQnICYmIHBrZyAhPT0gbnVsbClcclxuICAgICAgICAgICAgICAgIGJ1aWxkZXIuZGVmaW5lKHBrZywgb3B0aW9ucyk7XHJcbiAgICAgICAgICAgIHJldHVybiBidWlsZGVyO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIExvYWRzIGEgLmpzb24gZGVmaW5pdGlvbiBhbmQgcmV0dXJucyB0aGUgQnVpbGRlci5cclxuICAgICAgICAgKiBAcGFyYW0geyEqfHN0cmluZ30ganNvbiBKU09OIGRlZmluaXRpb25cclxuICAgICAgICAgKiBAcGFyYW0geyhQcm90b0J1Zi5CdWlsZGVyfHN0cmluZ3x7cm9vdDogc3RyaW5nLCBmaWxlOiBzdHJpbmd9KT19IGJ1aWxkZXIgQnVpbGRlciB0byBhcHBlbmQgdG8uIFdpbGwgY3JlYXRlIGEgbmV3IG9uZSBpZiBvbWl0dGVkLlxyXG4gICAgICAgICAqIEBwYXJhbSB7KHN0cmluZ3x7cm9vdDogc3RyaW5nLCBmaWxlOiBzdHJpbmd9KT19IGZpbGVuYW1lIFRoZSBjb3JyZXNwb25kaW5nIGZpbGUgbmFtZSBpZiBrbm93bi4gTXVzdCBiZSBzcGVjaWZpZWQgZm9yIGltcG9ydHMuXHJcbiAgICAgICAgICogQHJldHVybiB7UHJvdG9CdWYuQnVpbGRlcn0gQnVpbGRlciB0byBjcmVhdGUgbmV3IG1lc3NhZ2VzXHJcbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBkZWZpbml0aW9uIGNhbm5vdCBiZSBwYXJzZWQgb3IgYnVpbHRcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUHJvdG9CdWYubG9hZEpzb24gPSBmdW5jdGlvbihqc29uLCBidWlsZGVyLCBmaWxlbmFtZSkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGJ1aWxkZXIgPT09ICdzdHJpbmcnIHx8IChidWlsZGVyICYmIHR5cGVvZiBidWlsZGVyW1wiZmlsZVwiXSA9PT0gJ3N0cmluZycgJiYgdHlwZW9mIGJ1aWxkZXJbXCJyb290XCJdID09PSAnc3RyaW5nJykpXHJcbiAgICAgICAgICAgICAgICBmaWxlbmFtZSA9IGJ1aWxkZXIsXHJcbiAgICAgICAgICAgICAgICBidWlsZGVyID0gbnVsbDtcclxuICAgICAgICAgICAgaWYgKCFidWlsZGVyIHx8IHR5cGVvZiBidWlsZGVyICE9PSAnb2JqZWN0JylcclxuICAgICAgICAgICAgICAgIGJ1aWxkZXIgPSBQcm90b0J1Zi5uZXdCdWlsZGVyKCk7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YganNvbiA9PT0gJ3N0cmluZycpXHJcbiAgICAgICAgICAgICAgICBqc29uID0gSlNPTi5wYXJzZShqc29uKTtcclxuICAgICAgICAgICAgYnVpbGRlcltcImltcG9ydFwiXShqc29uLCBmaWxlbmFtZSk7XHJcbiAgICAgICAgICAgIGJ1aWxkZXIucmVzb2x2ZUFsbCgpO1xyXG4gICAgICAgICAgICBidWlsZGVyLmJ1aWxkKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBidWlsZGVyO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIExvYWRzIGEgLmpzb24gZmlsZSBhbmQgcmV0dXJucyB0aGUgQnVpbGRlci5cclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ3whe3Jvb3Q6IHN0cmluZywgZmlsZTogc3RyaW5nfX0gZmlsZW5hbWUgUGF0aCB0byBqc29uIGZpbGUgb3IgYW4gb2JqZWN0IHNwZWNpZnlpbmcgJ2ZpbGUnIHdpdGhcclxuICAgICAgICAgKiAgYW4gb3ZlcnJpZGRlbiAncm9vdCcgcGF0aCBmb3IgYWxsIGltcG9ydGVkIGZpbGVzLlxyXG4gICAgICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oP0Vycm9yLCAhUHJvdG9CdWYuQnVpbGRlcj0pPX0gY2FsbGJhY2sgQ2FsbGJhY2sgdGhhdCB3aWxsIHJlY2VpdmUgYG51bGxgIGFzIHRoZSBmaXJzdCBhbmRcclxuICAgICAgICAgKiAgdGhlIEJ1aWxkZXIgYXMgaXRzIHNlY29uZCBhcmd1bWVudCBvbiBzdWNjZXNzLCBvdGhlcndpc2UgdGhlIGVycm9yIGFzIGl0cyBmaXJzdCBhcmd1bWVudC4gSWYgb21pdHRlZCwgdGhlXHJcbiAgICAgICAgICogIGZpbGUgd2lsbCBiZSByZWFkIHN5bmNocm9ub3VzbHkgYW5kIHRoaXMgZnVuY3Rpb24gd2lsbCByZXR1cm4gdGhlIEJ1aWxkZXIuXHJcbiAgICAgICAgICogQHBhcmFtIHtQcm90b0J1Zi5CdWlsZGVyPX0gYnVpbGRlciBCdWlsZGVyIHRvIGFwcGVuZCB0by4gV2lsbCBjcmVhdGUgYSBuZXcgb25lIGlmIG9taXR0ZWQuXHJcbiAgICAgICAgICogQHJldHVybiB7P1Byb3RvQnVmLkJ1aWxkZXJ8dW5kZWZpbmVkfSBUaGUgQnVpbGRlciBpZiBzeW5jaHJvbm91cyAobm8gY2FsbGJhY2sgc3BlY2lmaWVkLCB3aWxsIGJlIE5VTEwgaWYgdGhlXHJcbiAgICAgICAgICogICByZXF1ZXN0IGhhcyBmYWlsZWQpLCBlbHNlIHVuZGVmaW5lZFxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBQcm90b0J1Zi5sb2FkSnNvbkZpbGUgPSBmdW5jdGlvbihmaWxlbmFtZSwgY2FsbGJhY2ssIGJ1aWxkZXIpIHtcclxuICAgICAgICAgICAgaWYgKGNhbGxiYWNrICYmIHR5cGVvZiBjYWxsYmFjayA9PT0gJ29iamVjdCcpXHJcbiAgICAgICAgICAgICAgICBidWlsZGVyID0gY2FsbGJhY2ssXHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IG51bGw7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCFjYWxsYmFjayB8fCB0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpXHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IG51bGw7XHJcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaylcclxuICAgICAgICAgICAgICAgIHJldHVybiBQcm90b0J1Zi5VdGlsLmZldGNoKHR5cGVvZiBmaWxlbmFtZSA9PT0gJ3N0cmluZycgPyBmaWxlbmFtZSA6IGZpbGVuYW1lW1wicm9vdFwiXStcIi9cIitmaWxlbmFtZVtcImZpbGVcIl0sIGZ1bmN0aW9uKGNvbnRlbnRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRlbnRzID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKEVycm9yKFwiRmFpbGVkIHRvIGZldGNoIGZpbGVcIikpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIFByb3RvQnVmLmxvYWRKc29uKEpTT04ucGFyc2UoY29udGVudHMpLCBidWlsZGVyLCBmaWxlbmFtZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHZhciBjb250ZW50cyA9IFByb3RvQnVmLlV0aWwuZmV0Y2godHlwZW9mIGZpbGVuYW1lID09PSAnb2JqZWN0JyA/IGZpbGVuYW1lW1wicm9vdFwiXStcIi9cIitmaWxlbmFtZVtcImZpbGVcIl0gOiBmaWxlbmFtZSk7XHJcbiAgICAgICAgICAgIHJldHVybiBjb250ZW50cyA9PT0gbnVsbCA/IG51bGwgOiBQcm90b0J1Zi5sb2FkSnNvbihKU09OLnBhcnNlKGNvbnRlbnRzKSwgYnVpbGRlciwgZmlsZW5hbWUpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHJldHVybiBQcm90b0J1ZjtcclxuICAgIH1cclxuXHJcbiAgICAvKiBDb21tb25KUyAqLyBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlW1wiZXhwb3J0c1wiXSlcclxuICAgICAgICBtb2R1bGVbXCJleHBvcnRzXCJdID0gaW5pdChyZXF1aXJlKFwiYnl0ZWJ1ZmZlclwiKSk7XHJcbiAgICAvKiBBTUQgKi8gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmVbXCJhbWRcIl0pXHJcbiAgICAgICAgZGVmaW5lKFtcIkJ5dGVCdWZmZXJcIl0sIGluaXQpO1xyXG4gICAgLyogR2xvYmFsICovIGVsc2VcclxuICAgICAgICAoZ2xvYmFsW1wiZGNvZGVJT1wiXSA9IGdsb2JhbFtcImRjb2RlSU9cIl0gfHwge30pW1wiUHJvdG9CdWZcIl0gPSBpbml0KGdsb2JhbFtcImRjb2RlSU9cIl1bXCJCeXRlQnVmZmVyXCJdKTtcclxuXHJcbn0pKHRoaXMpO1xyXG4iLCIvKlxyXG4gQ29weXJpZ2h0IDIwMTMgRGFuaWVsIFdpcnR6IDxkY29kZUBkY29kZS5pbz5cclxuXHJcbiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcblxyXG4gaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcblxyXG4gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbnZhciBQcm90b0J1ZiA9IHJlcXVpcmUoXCIuL2Rpc3QvUHJvdG9CdWYuanNcIik7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFByb3RvQnVmO1xyXG4iLCIvKlxuIEJ5dGVCdWZmZXIuanMgKGMpIDIwMTMtMjAxNCBEYW5pZWwgV2lydHogPGRjb2RlQGRjb2RlLmlvPlxuIFRoaXMgdmVyc2lvbiBvZiBCeXRlQnVmZmVyLmpzIHVzZXMgYW4gQXJyYXlCdWZmZXIgKEFCKSBhcyBpdHMgYmFja2luZyBidWZmZXIgYW5kIGlzIGNvbXBhdGlibGUgd2l0aCBtb2Rlcm4gYnJvd3NlcnMuXG4gUmVsZWFzZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMFxuIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Rjb2RlSU8vQnl0ZUJ1ZmZlci5qcyBmb3IgZGV0YWlsc1xuKi9cbihmdW5jdGlvbihyKXtmdW5jdGlvbiBzKGwpe2Z1bmN0aW9uIGQoYSxiLGMpe1widW5kZWZpbmVkXCI9PT10eXBlb2YgYSYmKGE9ZC5ERUZBVUxUX0NBUEFDSVRZKTtcInVuZGVmaW5lZFwiPT09dHlwZW9mIGImJihiPWQuREVGQVVMVF9FTkRJQU4pO1widW5kZWZpbmVkXCI9PT10eXBlb2YgYyYmKGM9ZC5ERUZBVUxUX05PQVNTRVJUKTtpZighYyl7YXw9MDtpZigwPmEpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIGNhcGFjaXR5OiAwIDw9IFwiK2EpO2lmKFwiYm9vbGVhblwiIT09dHlwZW9mIGIpdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgbGl0dGxlRW5kaWFuOiBOb3QgYSBib29sZWFuXCIpO2lmKFwiYm9vbGVhblwiIT09dHlwZW9mIGMpdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgbm9Bc3NlcnQ6IE5vdCBhIGJvb2xlYW5cIik7fXRoaXMuYnVmZmVyPTA9PT1hP3I6bmV3IEFycmF5QnVmZmVyKGEpO3RoaXMudmlldz0wPT09YT9udWxsOm5ldyBEYXRhVmlldyh0aGlzLmJ1ZmZlcik7XG50aGlzLm9mZnNldD0wO3RoaXMubWFya2VkT2Zmc2V0PS0xO3RoaXMubGltaXQ9YTt0aGlzLmxpdHRsZUVuZGlhbj1cInVuZGVmaW5lZFwiIT09dHlwZW9mIGI/ISFiOiExO3RoaXMubm9Bc3NlcnQ9ISFjfWQuVkVSU0lPTj1cIjMuMS4wXCI7ZC5MSVRUTEVfRU5ESUFOPSEwO2QuQklHX0VORElBTj0hMTtkLkRFRkFVTFRfQ0FQQUNJVFk9MTY7ZC5ERUZBVUxUX0VORElBTj1kLkJJR19FTkRJQU47ZC5ERUZBVUxUX05PQVNTRVJUPSExO2QuTG9uZz1sfHxudWxsO3ZhciByPW5ldyBBcnJheUJ1ZmZlcigwKTtkLmFsbG9jYXRlPWZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gbmV3IGQoYSxiLGMpfTtkLmNvbmNhdD1mdW5jdGlvbihhLGIsYyxlKXtpZihcImJvb2xlYW5cIj09PXR5cGVvZiBifHxcInN0cmluZ1wiIT09dHlwZW9mIGIpZT1jLGM9YixiPXZvaWQgMDtmb3IodmFyIGg9MCxmPTAsZz1hLmxlbmd0aCxuO2Y8ZzsrK2YpZC5pc0J5dGVCdWZmZXIoYVtmXSl8fChhW2ZdPWQud3JhcChhW2ZdLGIpKSxuPVxuYVtmXS5saW1pdC1hW2ZdLm9mZnNldCwwPG4mJihoKz1uKTtpZigwPT09aClyZXR1cm4gbmV3IGQoMCxjLGUpO2I9bmV3IGQoaCxjLGUpO2U9bmV3IFVpbnQ4QXJyYXkoYi5idWZmZXIpO2ZvcihmPTA7ZjxnOyljPWFbZisrXSxuPWMubGltaXQtYy5vZmZzZXQsMD49bnx8KGUuc2V0KChuZXcgVWludDhBcnJheShjLmJ1ZmZlcikpLnN1YmFycmF5KGMub2Zmc2V0LGMubGltaXQpLGIub2Zmc2V0KSxiLm9mZnNldCs9bik7Yi5saW1pdD1iLm9mZnNldDtiLm9mZnNldD0wO3JldHVybiBifTtkLmlzQnl0ZUJ1ZmZlcj1mdW5jdGlvbihhKXtyZXR1cm4gYSYmYSBpbnN0YW5jZW9mIGR9O2QudHlwZT1mdW5jdGlvbigpe3JldHVybiBBcnJheUJ1ZmZlcn07ZC53cmFwPWZ1bmN0aW9uKGEsYixjLGUpe1wic3RyaW5nXCIhPT10eXBlb2YgYiYmKGU9YyxjPWIsYj12b2lkIDApO2lmKFwic3RyaW5nXCI9PT10eXBlb2YgYSlzd2l0Y2goXCJ1bmRlZmluZWRcIj09PXR5cGVvZiBiJiYoYj1cInV0ZjhcIiksYil7Y2FzZSBcImJhc2U2NFwiOnJldHVybiBkLmZyb21CYXNlNjQoYSxcbmMpO2Nhc2UgXCJoZXhcIjpyZXR1cm4gZC5mcm9tSGV4KGEsYyk7Y2FzZSBcImJpbmFyeVwiOnJldHVybiBkLmZyb21CaW5hcnkoYSxjKTtjYXNlIFwidXRmOFwiOnJldHVybiBkLmZyb21VVEY4KGEsYyk7Y2FzZSBcImRlYnVnXCI6cmV0dXJuIGQuZnJvbURlYnVnKGEsYyk7ZGVmYXVsdDp0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5zdXBwb3J0ZWQgZW5jb2Rpbmc6IFwiK2IpO31pZihudWxsPT09YXx8XCJvYmplY3RcIiE9PXR5cGVvZiBhKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGJ1ZmZlcjogbnVsbCBvciBub24tb2JqZWN0XCIpO2lmKGQuaXNCeXRlQnVmZmVyKGEpKXJldHVybiBiPWQucHJvdG90eXBlLmNsb25lLmNhbGwoYSksYi5tYXJrZWRPZmZzZXQ9LTEsYjtpZihhIGluc3RhbmNlb2YgVWludDhBcnJheSliPW5ldyBkKDAsYyxlKSwwPGEubGVuZ3RoJiYoYi5idWZmZXI9YS5idWZmZXIsYi5vZmZzZXQ9YS5ieXRlT2Zmc2V0LGIubGltaXQ9YS5ieXRlT2Zmc2V0K2EubGVuZ3RoLGIudmlldz1cbjA8YS5sZW5ndGg/bmV3IERhdGFWaWV3KGEuYnVmZmVyKTpudWxsKTtlbHNlIGlmKGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciliPW5ldyBkKDAsYyxlKSwwPGEuYnl0ZUxlbmd0aCYmKGIuYnVmZmVyPWEsYi5vZmZzZXQ9MCxiLmxpbWl0PWEuYnl0ZUxlbmd0aCxiLnZpZXc9MDxhLmJ5dGVMZW5ndGg/bmV3IERhdGFWaWV3KGEpOm51bGwpO2Vsc2UgaWYoXCJbb2JqZWN0IEFycmF5XVwiPT09T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGEpKWZvcihiPW5ldyBkKGEubGVuZ3RoLGMsZSksYi5saW1pdD1hLmxlbmd0aCxpPTA7aTxhLmxlbmd0aDsrK2kpYi52aWV3LnNldFVpbnQ4KGksYVtpXSk7ZWxzZSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBidWZmZXJcIik7cmV0dXJuIGJ9O2QucHJvdG90eXBlLndyaXRlSW50OD1mdW5jdGlvbihhLGIpe3ZhciBjPVwidW5kZWZpbmVkXCI9PT10eXBlb2YgYjtjJiYoYj10aGlzLm9mZnNldCk7aWYoIXRoaXMubm9Bc3NlcnQpe2lmKFwibnVtYmVyXCIhPT1cbnR5cGVvZiBhfHwwIT09YSUxKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIHZhbHVlOiBcIithK1wiIChub3QgYW4gaW50ZWdlcilcIik7YXw9MDtpZihcIm51bWJlclwiIT09dHlwZW9mIGJ8fDAhPT1iJTEpdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitiK1wiIChub3QgYW4gaW50ZWdlcilcIik7Yj4+Pj0wO2lmKDA+Ynx8YiswPnRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitiK1wiICgrMCkgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7fWIrPTE7dmFyIGU9dGhpcy5idWZmZXIuYnl0ZUxlbmd0aDtiPmUmJnRoaXMucmVzaXplKChlKj0yKT5iP2U6Yik7dGhpcy52aWV3LnNldEludDgoYi0xLGEpO2MmJih0aGlzLm9mZnNldCs9MSk7cmV0dXJuIHRoaXN9O2QucHJvdG90eXBlLndyaXRlQnl0ZT1kLnByb3RvdHlwZS53cml0ZUludDg7ZC5wcm90b3R5cGUucmVhZEludDg9ZnVuY3Rpb24oYSl7dmFyIGI9XG5cInVuZGVmaW5lZFwiPT09dHlwZW9mIGE7YiYmKGE9dGhpcy5vZmZzZXQpO2lmKCF0aGlzLm5vQXNzZXJ0KXtpZihcIm51bWJlclwiIT09dHlwZW9mIGF8fDAhPT1hJTEpdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIithK1wiIChub3QgYW4gaW50ZWdlcilcIik7YT4+Pj0wO2lmKDA+YXx8YSsxPnRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIithK1wiICgrMSkgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7fWE9dGhpcy52aWV3LmdldEludDgoYSk7YiYmKHRoaXMub2Zmc2V0Kz0xKTtyZXR1cm4gYX07ZC5wcm90b3R5cGUucmVhZEJ5dGU9ZC5wcm90b3R5cGUucmVhZEludDg7ZC5wcm90b3R5cGUud3JpdGVVaW50OD1mdW5jdGlvbihhLGIpe3ZhciBjPVwidW5kZWZpbmVkXCI9PT10eXBlb2YgYjtjJiYoYj10aGlzLm9mZnNldCk7aWYoIXRoaXMubm9Bc3NlcnQpe2lmKFwibnVtYmVyXCIhPT10eXBlb2YgYXx8XG4wIT09YSUxKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIHZhbHVlOiBcIithK1wiIChub3QgYW4gaW50ZWdlcilcIik7YT4+Pj0wO2lmKFwibnVtYmVyXCIhPT10eXBlb2YgYnx8MCE9PWIlMSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK2IrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtiPj4+PTA7aWYoMD5ifHxiKzA+dGhpcy5idWZmZXIuYnl0ZUxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK2IrXCIgKCswKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTt9Yis9MTt2YXIgZT10aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoO2I+ZSYmdGhpcy5yZXNpemUoKGUqPTIpPmI/ZTpiKTt0aGlzLnZpZXcuc2V0VWludDgoYi0xLGEpO2MmJih0aGlzLm9mZnNldCs9MSk7cmV0dXJuIHRoaXN9O2QucHJvdG90eXBlLnJlYWRVaW50OD1mdW5jdGlvbihhKXt2YXIgYj1cInVuZGVmaW5lZFwiPT09dHlwZW9mIGE7YiYmKGE9dGhpcy5vZmZzZXQpO1xuaWYoIXRoaXMubm9Bc3NlcnQpe2lmKFwibnVtYmVyXCIhPT10eXBlb2YgYXx8MCE9PWElMSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK2ErXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTthPj4+PTA7aWYoMD5hfHxhKzE+dGhpcy5idWZmZXIuYnl0ZUxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK2ErXCIgKCsxKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTt9YT10aGlzLnZpZXcuZ2V0VWludDgoYSk7YiYmKHRoaXMub2Zmc2V0Kz0xKTtyZXR1cm4gYX07ZC5wcm90b3R5cGUud3JpdGVJbnQxNj1mdW5jdGlvbihhLGIpe3ZhciBjPVwidW5kZWZpbmVkXCI9PT10eXBlb2YgYjtjJiYoYj10aGlzLm9mZnNldCk7aWYoIXRoaXMubm9Bc3NlcnQpe2lmKFwibnVtYmVyXCIhPT10eXBlb2YgYXx8MCE9PWElMSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCB2YWx1ZTogXCIrYStcIiAobm90IGFuIGludGVnZXIpXCIpO2F8PTA7aWYoXCJudW1iZXJcIiE9PVxudHlwZW9mIGJ8fDAhPT1iJTEpdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitiK1wiIChub3QgYW4gaW50ZWdlcilcIik7Yj4+Pj0wO2lmKDA+Ynx8YiswPnRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitiK1wiICgrMCkgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7fWIrPTI7dmFyIGU9dGhpcy5idWZmZXIuYnl0ZUxlbmd0aDtiPmUmJnRoaXMucmVzaXplKChlKj0yKT5iP2U6Yik7dGhpcy52aWV3LnNldEludDE2KGItMixhLHRoaXMubGl0dGxlRW5kaWFuKTtjJiYodGhpcy5vZmZzZXQrPTIpO3JldHVybiB0aGlzfTtkLnByb3RvdHlwZS53cml0ZVNob3J0PWQucHJvdG90eXBlLndyaXRlSW50MTY7ZC5wcm90b3R5cGUucmVhZEludDE2PWZ1bmN0aW9uKGEpe3ZhciBiPVwidW5kZWZpbmVkXCI9PT10eXBlb2YgYTtiJiYoYT10aGlzLm9mZnNldCk7aWYoIXRoaXMubm9Bc3NlcnQpe2lmKFwibnVtYmVyXCIhPT1cbnR5cGVvZiBhfHwwIT09YSUxKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrYStcIiAobm90IGFuIGludGVnZXIpXCIpO2E+Pj49MDtpZigwPmF8fGErMj50aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrYStcIiAoKzIpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO31hPXRoaXMudmlldy5nZXRJbnQxNihhLHRoaXMubGl0dGxlRW5kaWFuKTtiJiYodGhpcy5vZmZzZXQrPTIpO3JldHVybiBhfTtkLnByb3RvdHlwZS5yZWFkU2hvcnQ9ZC5wcm90b3R5cGUucmVhZEludDE2O2QucHJvdG90eXBlLndyaXRlVWludDE2PWZ1bmN0aW9uKGEsYil7dmFyIGM9XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBiO2MmJihiPXRoaXMub2Zmc2V0KTtpZighdGhpcy5ub0Fzc2VydCl7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBhfHwwIT09YSUxKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIHZhbHVlOiBcIithK1wiIChub3QgYW4gaW50ZWdlcilcIik7XG5hPj4+PTA7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBifHwwIT09YiUxKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrYitcIiAobm90IGFuIGludGVnZXIpXCIpO2I+Pj49MDtpZigwPmJ8fGIrMD50aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrYitcIiAoKzApIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO31iKz0yO3ZhciBlPXRoaXMuYnVmZmVyLmJ5dGVMZW5ndGg7Yj5lJiZ0aGlzLnJlc2l6ZSgoZSo9Mik+Yj9lOmIpO3RoaXMudmlldy5zZXRVaW50MTYoYi0yLGEsdGhpcy5saXR0bGVFbmRpYW4pO2MmJih0aGlzLm9mZnNldCs9Mik7cmV0dXJuIHRoaXN9O2QucHJvdG90eXBlLnJlYWRVaW50MTY9ZnVuY3Rpb24oYSl7dmFyIGI9XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBhO2ImJihhPXRoaXMub2Zmc2V0KTtpZighdGhpcy5ub0Fzc2VydCl7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBhfHwwIT09YSVcbjEpdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIithK1wiIChub3QgYW4gaW50ZWdlcilcIik7YT4+Pj0wO2lmKDA+YXx8YSsyPnRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIithK1wiICgrMikgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7fWE9dGhpcy52aWV3LmdldFVpbnQxNihhLHRoaXMubGl0dGxlRW5kaWFuKTtiJiYodGhpcy5vZmZzZXQrPTIpO3JldHVybiBhfTtkLnByb3RvdHlwZS53cml0ZUludDMyPWZ1bmN0aW9uKGEsYil7dmFyIGM9XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBiO2MmJihiPXRoaXMub2Zmc2V0KTtpZighdGhpcy5ub0Fzc2VydCl7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBhfHwwIT09YSUxKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIHZhbHVlOiBcIithK1wiIChub3QgYW4gaW50ZWdlcilcIik7YXw9MDtpZihcIm51bWJlclwiIT09dHlwZW9mIGJ8fDAhPT1iJTEpdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitcbmIrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtiPj4+PTA7aWYoMD5ifHxiKzA+dGhpcy5idWZmZXIuYnl0ZUxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK2IrXCIgKCswKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTt9Yis9NDt2YXIgZT10aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoO2I+ZSYmdGhpcy5yZXNpemUoKGUqPTIpPmI/ZTpiKTt0aGlzLnZpZXcuc2V0SW50MzIoYi00LGEsdGhpcy5saXR0bGVFbmRpYW4pO2MmJih0aGlzLm9mZnNldCs9NCk7cmV0dXJuIHRoaXN9O2QucHJvdG90eXBlLndyaXRlSW50PWQucHJvdG90eXBlLndyaXRlSW50MzI7ZC5wcm90b3R5cGUucmVhZEludDMyPWZ1bmN0aW9uKGEpe3ZhciBiPVwidW5kZWZpbmVkXCI9PT10eXBlb2YgYTtiJiYoYT10aGlzLm9mZnNldCk7aWYoIXRoaXMubm9Bc3NlcnQpe2lmKFwibnVtYmVyXCIhPT10eXBlb2YgYXx8MCE9PWElMSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK1xuYStcIiAobm90IGFuIGludGVnZXIpXCIpO2E+Pj49MDtpZigwPmF8fGErND50aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrYStcIiAoKzQpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO31hPXRoaXMudmlldy5nZXRJbnQzMihhLHRoaXMubGl0dGxlRW5kaWFuKTtiJiYodGhpcy5vZmZzZXQrPTQpO3JldHVybiBhfTtkLnByb3RvdHlwZS5yZWFkSW50PWQucHJvdG90eXBlLnJlYWRJbnQzMjtkLnByb3RvdHlwZS53cml0ZVVpbnQzMj1mdW5jdGlvbihhLGIpe3ZhciBjPVwidW5kZWZpbmVkXCI9PT10eXBlb2YgYjtjJiYoYj10aGlzLm9mZnNldCk7aWYoIXRoaXMubm9Bc3NlcnQpe2lmKFwibnVtYmVyXCIhPT10eXBlb2YgYXx8MCE9PWElMSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCB2YWx1ZTogXCIrYStcIiAobm90IGFuIGludGVnZXIpXCIpO2E+Pj49MDtpZihcIm51bWJlclwiIT09dHlwZW9mIGJ8fDAhPT1iJTEpdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitcbmIrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtiPj4+PTA7aWYoMD5ifHxiKzA+dGhpcy5idWZmZXIuYnl0ZUxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK2IrXCIgKCswKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTt9Yis9NDt2YXIgZT10aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoO2I+ZSYmdGhpcy5yZXNpemUoKGUqPTIpPmI/ZTpiKTt0aGlzLnZpZXcuc2V0VWludDMyKGItNCxhLHRoaXMubGl0dGxlRW5kaWFuKTtjJiYodGhpcy5vZmZzZXQrPTQpO3JldHVybiB0aGlzfTtkLnByb3RvdHlwZS5yZWFkVWludDMyPWZ1bmN0aW9uKGEpe3ZhciBiPVwidW5kZWZpbmVkXCI9PT10eXBlb2YgYTtiJiYoYT10aGlzLm9mZnNldCk7aWYoIXRoaXMubm9Bc3NlcnQpe2lmKFwibnVtYmVyXCIhPT10eXBlb2YgYXx8MCE9PWElMSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK2ErXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTthPj4+PTA7aWYoMD5hfHxcbmErND50aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrYStcIiAoKzQpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO31hPXRoaXMudmlldy5nZXRVaW50MzIoYSx0aGlzLmxpdHRsZUVuZGlhbik7YiYmKHRoaXMub2Zmc2V0Kz00KTtyZXR1cm4gYX07bCYmKGQucHJvdG90eXBlLndyaXRlSW50NjQ9ZnVuY3Rpb24oYSxiKXt2YXIgYz1cInVuZGVmaW5lZFwiPT09dHlwZW9mIGI7YyYmKGI9dGhpcy5vZmZzZXQpO2lmKCF0aGlzLm5vQXNzZXJ0KXtpZihcIm51bWJlclwiPT09dHlwZW9mIGEpYT1sLmZyb21OdW1iZXIoYSk7ZWxzZSBpZighKGEmJmEgaW5zdGFuY2VvZiBsKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCB2YWx1ZTogXCIrYStcIiAobm90IGFuIGludGVnZXIgb3IgTG9uZylcIik7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBifHwwIT09YiUxKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrXG5iK1wiIChub3QgYW4gaW50ZWdlcilcIik7Yj4+Pj0wO2lmKDA+Ynx8YiswPnRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitiK1wiICgrMCkgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7fVwibnVtYmVyXCI9PT10eXBlb2YgYSYmKGE9bC5mcm9tTnVtYmVyKGEpKTtiKz04O3ZhciBlPXRoaXMuYnVmZmVyLmJ5dGVMZW5ndGg7Yj5lJiZ0aGlzLnJlc2l6ZSgoZSo9Mik+Yj9lOmIpO2ItPTg7dGhpcy5saXR0bGVFbmRpYW4/KHRoaXMudmlldy5zZXRJbnQzMihiLGEubG93LCEwKSx0aGlzLnZpZXcuc2V0SW50MzIoYis0LGEuaGlnaCwhMCkpOih0aGlzLnZpZXcuc2V0SW50MzIoYixhLmhpZ2gsITEpLHRoaXMudmlldy5zZXRJbnQzMihiKzQsYS5sb3csITEpKTtjJiYodGhpcy5vZmZzZXQrPTgpO3JldHVybiB0aGlzfSxkLnByb3RvdHlwZS53cml0ZUxvbmc9ZC5wcm90b3R5cGUud3JpdGVJbnQ2NCxkLnByb3RvdHlwZS5yZWFkSW50NjQ9XG5mdW5jdGlvbihhKXt2YXIgYj1cInVuZGVmaW5lZFwiPT09dHlwZW9mIGE7YiYmKGE9dGhpcy5vZmZzZXQpO2lmKCF0aGlzLm5vQXNzZXJ0KXtpZihcIm51bWJlclwiIT09dHlwZW9mIGF8fDAhPT1hJTEpdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIithK1wiIChub3QgYW4gaW50ZWdlcilcIik7YT4+Pj0wO2lmKDA+YXx8YSs4PnRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIithK1wiICgrOCkgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7fWE9dGhpcy5saXR0bGVFbmRpYW4/bmV3IGwodGhpcy52aWV3LmdldEludDMyKGEsITApLHRoaXMudmlldy5nZXRJbnQzMihhKzQsITApLCExKTpuZXcgbCh0aGlzLnZpZXcuZ2V0SW50MzIoYSs0LCExKSx0aGlzLnZpZXcuZ2V0SW50MzIoYSwhMSksITEpO2ImJih0aGlzLm9mZnNldCs9OCk7cmV0dXJuIGF9LGQucHJvdG90eXBlLnJlYWRMb25nPWQucHJvdG90eXBlLnJlYWRJbnQ2NCxcbmQucHJvdG90eXBlLndyaXRlVWludDY0PWZ1bmN0aW9uKGEsYil7dmFyIGM9XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBiO2MmJihiPXRoaXMub2Zmc2V0KTtpZighdGhpcy5ub0Fzc2VydCl7aWYoXCJudW1iZXJcIj09PXR5cGVvZiBhKWE9bC5mcm9tTnVtYmVyKGEpO2Vsc2UgaWYoIShhJiZhIGluc3RhbmNlb2YgbCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgdmFsdWU6IFwiK2ErXCIgKG5vdCBhbiBpbnRlZ2VyIG9yIExvbmcpXCIpO2lmKFwibnVtYmVyXCIhPT10eXBlb2YgYnx8MCE9PWIlMSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK2IrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtiPj4+PTA7aWYoMD5ifHxiKzA+dGhpcy5idWZmZXIuYnl0ZUxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK2IrXCIgKCswKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTt9XCJudW1iZXJcIj09PXR5cGVvZiBhJiYoYT1sLmZyb21OdW1iZXIoYSkpO1xuYis9ODt2YXIgZT10aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoO2I+ZSYmdGhpcy5yZXNpemUoKGUqPTIpPmI/ZTpiKTtiLT04O3RoaXMubGl0dGxlRW5kaWFuPyh0aGlzLnZpZXcuc2V0SW50MzIoYixhLmxvdywhMCksdGhpcy52aWV3LnNldEludDMyKGIrNCxhLmhpZ2gsITApKToodGhpcy52aWV3LnNldEludDMyKGIsYS5oaWdoLCExKSx0aGlzLnZpZXcuc2V0SW50MzIoYis0LGEubG93LCExKSk7YyYmKHRoaXMub2Zmc2V0Kz04KTtyZXR1cm4gdGhpc30sZC5wcm90b3R5cGUucmVhZFVpbnQ2ND1mdW5jdGlvbihhKXt2YXIgYj1cInVuZGVmaW5lZFwiPT09dHlwZW9mIGE7YiYmKGE9dGhpcy5vZmZzZXQpO2lmKCF0aGlzLm5vQXNzZXJ0KXtpZihcIm51bWJlclwiIT09dHlwZW9mIGF8fDAhPT1hJTEpdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIithK1wiIChub3QgYW4gaW50ZWdlcilcIik7YT4+Pj0wO2lmKDA+YXx8YSs4PnRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitcbmErXCIgKCs4KSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTt9YT10aGlzLmxpdHRsZUVuZGlhbj9uZXcgbCh0aGlzLnZpZXcuZ2V0SW50MzIoYSwhMCksdGhpcy52aWV3LmdldEludDMyKGErNCwhMCksITApOm5ldyBsKHRoaXMudmlldy5nZXRJbnQzMihhKzQsITEpLHRoaXMudmlldy5nZXRJbnQzMihhLCExKSwhMCk7YiYmKHRoaXMub2Zmc2V0Kz04KTtyZXR1cm4gYX0pO2QucHJvdG90eXBlLndyaXRlRmxvYXQzMj1mdW5jdGlvbihhLGIpe3ZhciBjPVwidW5kZWZpbmVkXCI9PT10eXBlb2YgYjtjJiYoYj10aGlzLm9mZnNldCk7aWYoIXRoaXMubm9Bc3NlcnQpe2lmKFwibnVtYmVyXCIhPT10eXBlb2YgYSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCB2YWx1ZTogXCIrYStcIiAobm90IGEgbnVtYmVyKVwiKTtpZihcIm51bWJlclwiIT09dHlwZW9mIGJ8fDAhPT1iJTEpdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitiK1wiIChub3QgYW4gaW50ZWdlcilcIik7Yj4+Pj1cbjA7aWYoMD5ifHxiKzA+dGhpcy5idWZmZXIuYnl0ZUxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK2IrXCIgKCswKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTt9Yis9NDt2YXIgZT10aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoO2I+ZSYmdGhpcy5yZXNpemUoKGUqPTIpPmI/ZTpiKTt0aGlzLnZpZXcuc2V0RmxvYXQzMihiLTQsYSx0aGlzLmxpdHRsZUVuZGlhbik7YyYmKHRoaXMub2Zmc2V0Kz00KTtyZXR1cm4gdGhpc307ZC5wcm90b3R5cGUud3JpdGVGbG9hdD1kLnByb3RvdHlwZS53cml0ZUZsb2F0MzI7ZC5wcm90b3R5cGUucmVhZEZsb2F0MzI9ZnVuY3Rpb24oYSl7dmFyIGI9XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBhO2ImJihhPXRoaXMub2Zmc2V0KTtpZighdGhpcy5ub0Fzc2VydCl7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBhfHwwIT09YSUxKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrYStcIiAobm90IGFuIGludGVnZXIpXCIpO1xuYT4+Pj0wO2lmKDA+YXx8YSs0PnRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIithK1wiICgrNCkgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7fWE9dGhpcy52aWV3LmdldEZsb2F0MzIoYSx0aGlzLmxpdHRsZUVuZGlhbik7YiYmKHRoaXMub2Zmc2V0Kz00KTtyZXR1cm4gYX07ZC5wcm90b3R5cGUucmVhZEZsb2F0PWQucHJvdG90eXBlLnJlYWRGbG9hdDMyO2QucHJvdG90eXBlLndyaXRlRmxvYXQ2ND1mdW5jdGlvbihhLGIpe3ZhciBjPVwidW5kZWZpbmVkXCI9PT10eXBlb2YgYjtjJiYoYj10aGlzLm9mZnNldCk7aWYoIXRoaXMubm9Bc3NlcnQpe2lmKFwibnVtYmVyXCIhPT10eXBlb2YgYSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCB2YWx1ZTogXCIrYStcIiAobm90IGEgbnVtYmVyKVwiKTtpZihcIm51bWJlclwiIT09dHlwZW9mIGJ8fDAhPT1iJTEpdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitcbmIrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtiPj4+PTA7aWYoMD5ifHxiKzA+dGhpcy5idWZmZXIuYnl0ZUxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK2IrXCIgKCswKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTt9Yis9ODt2YXIgZT10aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoO2I+ZSYmdGhpcy5yZXNpemUoKGUqPTIpPmI/ZTpiKTt0aGlzLnZpZXcuc2V0RmxvYXQ2NChiLTgsYSx0aGlzLmxpdHRsZUVuZGlhbik7YyYmKHRoaXMub2Zmc2V0Kz04KTtyZXR1cm4gdGhpc307ZC5wcm90b3R5cGUud3JpdGVEb3VibGU9ZC5wcm90b3R5cGUud3JpdGVGbG9hdDY0O2QucHJvdG90eXBlLnJlYWRGbG9hdDY0PWZ1bmN0aW9uKGEpe3ZhciBiPVwidW5kZWZpbmVkXCI9PT10eXBlb2YgYTtiJiYoYT10aGlzLm9mZnNldCk7aWYoIXRoaXMubm9Bc3NlcnQpe2lmKFwibnVtYmVyXCIhPT10eXBlb2YgYXx8MCE9PWElMSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK1xuYStcIiAobm90IGFuIGludGVnZXIpXCIpO2E+Pj49MDtpZigwPmF8fGErOD50aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrYStcIiAoKzgpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO31hPXRoaXMudmlldy5nZXRGbG9hdDY0KGEsdGhpcy5saXR0bGVFbmRpYW4pO2ImJih0aGlzLm9mZnNldCs9OCk7cmV0dXJuIGF9O2QucHJvdG90eXBlLnJlYWREb3VibGU9ZC5wcm90b3R5cGUucmVhZEZsb2F0NjQ7ZC5NQVhfVkFSSU5UMzJfQllURVM9NTtkLmNhbGN1bGF0ZVZhcmludDMyPWZ1bmN0aW9uKGEpe2E+Pj49MDtyZXR1cm4gMTI4PmE/MToxNjM4ND5hPzI6MjA5NzE1Mj5hPzM6MjY4NDM1NDU2PmE/NDo1fTtkLnppZ1phZ0VuY29kZTMyPWZ1bmN0aW9uKGEpe3JldHVybigoYXw9MCk8PDFeYT4+MzEpPj4+MH07ZC56aWdaYWdEZWNvZGUzMj1mdW5jdGlvbihhKXtyZXR1cm4gYT4+PjFeLShhJjEpfDB9O2QucHJvdG90eXBlLndyaXRlVmFyaW50MzI9XG5mdW5jdGlvbihhLGIpe3ZhciBjPVwidW5kZWZpbmVkXCI9PT10eXBlb2YgYjtjJiYoYj10aGlzLm9mZnNldCk7aWYoIXRoaXMubm9Bc3NlcnQpe2lmKFwibnVtYmVyXCIhPT10eXBlb2YgYXx8MCE9PWElMSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCB2YWx1ZTogXCIrYStcIiAobm90IGFuIGludGVnZXIpXCIpO2F8PTA7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBifHwwIT09YiUxKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrYitcIiAobm90IGFuIGludGVnZXIpXCIpO2I+Pj49MDtpZigwPmJ8fGIrMD50aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrYitcIiAoKzApIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO312YXIgZT1kLmNhbGN1bGF0ZVZhcmludDMyKGEpO2IrPWU7dmFyIGg9dGhpcy5idWZmZXIuYnl0ZUxlbmd0aDtiPmgmJnRoaXMucmVzaXplKChoKj0yKT5iP2g6Yik7Yi09ZTt0aGlzLnZpZXcuc2V0VWludDgoYixcbmU9YXwxMjgpO2E+Pj49MDsxMjg8PWE/KGU9YT4+N3wxMjgsdGhpcy52aWV3LnNldFVpbnQ4KGIrMSxlKSwxNjM4NDw9YT8oZT1hPj4xNHwxMjgsdGhpcy52aWV3LnNldFVpbnQ4KGIrMixlKSwyMDk3MTUyPD1hPyhlPWE+PjIxfDEyOCx0aGlzLnZpZXcuc2V0VWludDgoYiszLGUpLDI2ODQzNTQ1Njw9YT8odGhpcy52aWV3LnNldFVpbnQ4KGIrNCxhPj4yOCYxNSksZT01KToodGhpcy52aWV3LnNldFVpbnQ4KGIrMyxlJjEyNyksZT00KSk6KHRoaXMudmlldy5zZXRVaW50OChiKzIsZSYxMjcpLGU9MykpOih0aGlzLnZpZXcuc2V0VWludDgoYisxLGUmMTI3KSxlPTIpKToodGhpcy52aWV3LnNldFVpbnQ4KGIsZSYxMjcpLGU9MSk7cmV0dXJuIGM/KHRoaXMub2Zmc2V0Kz1lLHRoaXMpOmV9O2QucHJvdG90eXBlLndyaXRlVmFyaW50MzJaaWdaYWc9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gdGhpcy53cml0ZVZhcmludDMyKGQuemlnWmFnRW5jb2RlMzIoYSksYil9O2QucHJvdG90eXBlLnJlYWRWYXJpbnQzMj1cbmZ1bmN0aW9uKGEpe3ZhciBiPVwidW5kZWZpbmVkXCI9PT10eXBlb2YgYTtiJiYoYT10aGlzLm9mZnNldCk7aWYoIXRoaXMubm9Bc3NlcnQpe2lmKFwibnVtYmVyXCIhPT10eXBlb2YgYXx8MCE9PWElMSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK2ErXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTthPj4+PTA7aWYoMD5hfHxhKzE+dGhpcy5idWZmZXIuYnl0ZUxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK2ErXCIgKCsxKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTt9dmFyIGM9MCxlPTAsZDtkbyBkPXRoaXMudmlldy5nZXRVaW50OChhK2MpLDU+YyYmKGV8PShkJjEyNyk8PDcqYz4+PjApLCsrYzt3aGlsZSgxMjg9PT0oZCYxMjgpKTtlfD0wO3JldHVybiBiPyh0aGlzLm9mZnNldCs9YyxlKTp7dmFsdWU6ZSxsZW5ndGg6Y319O2QucHJvdG90eXBlLnJlYWRWYXJpbnQzMlppZ1phZz1mdW5jdGlvbihhKXthPXRoaXMucmVhZFZhcmludDMyKGEpO1xuXCJvYmplY3RcIj09PXR5cGVvZiBhP2EudmFsdWU9ZC56aWdaYWdEZWNvZGUzMihhLnZhbHVlKTphPWQuemlnWmFnRGVjb2RlMzIoYSk7cmV0dXJuIGF9O2wmJihkLk1BWF9WQVJJTlQ2NF9CWVRFUz0xMCxkLmNhbGN1bGF0ZVZhcmludDY0PWZ1bmN0aW9uKGEpe1wibnVtYmVyXCI9PT10eXBlb2YgYSYmKGE9bC5mcm9tTnVtYmVyKGEpKTt2YXIgYj1hLnRvSW50KCk+Pj4wLGM9YS5zaGlmdFJpZ2h0VW5zaWduZWQoMjgpLnRvSW50KCk+Pj4wO2E9YS5zaGlmdFJpZ2h0VW5zaWduZWQoNTYpLnRvSW50KCk+Pj4wO3JldHVybiAwPT1hPzA9PWM/MTYzODQ+Yj8xMjg+Yj8xOjI6MjA5NzE1Mj5iPzM6NDoxNjM4ND5jPzEyOD5jPzU6NjoyMDk3MTUyPmM/Nzo4OjEyOD5hPzk6MTB9LGQuemlnWmFnRW5jb2RlNjQ9ZnVuY3Rpb24oYSl7XCJudW1iZXJcIj09PXR5cGVvZiBhP2E9bC5mcm9tTnVtYmVyKGEsITEpOiExIT09YS51bnNpZ25lZCYmKGE9YS50b1NpZ25lZCgpKTtyZXR1cm4gYS5zaGlmdExlZnQoMSkueG9yKGEuc2hpZnRSaWdodCg2MykpLnRvVW5zaWduZWQoKX0sXG5kLnppZ1phZ0RlY29kZTY0PWZ1bmN0aW9uKGEpe1wibnVtYmVyXCI9PT10eXBlb2YgYT9hPWwuZnJvbU51bWJlcihhLCExKTohMSE9PWEudW5zaWduZWQmJihhPWEudG9TaWduZWQoKSk7cmV0dXJuIGEuc2hpZnRSaWdodFVuc2lnbmVkKDEpLnhvcihhLmFuZChsLk9ORSkudG9TaWduZWQoKS5uZWdhdGUoKSkudG9TaWduZWQoKX0sZC5wcm90b3R5cGUud3JpdGVWYXJpbnQ2ND1mdW5jdGlvbihhLGIpe3ZhciBjPVwidW5kZWZpbmVkXCI9PT10eXBlb2YgYjtjJiYoYj10aGlzLm9mZnNldCk7aWYoIXRoaXMubm9Bc3NlcnQpe2lmKFwibnVtYmVyXCI9PT10eXBlb2YgYSlhPWwuZnJvbU51bWJlcihhKTtlbHNlIGlmKCEoYSYmYSBpbnN0YW5jZW9mIGwpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIHZhbHVlOiBcIithK1wiIChub3QgYW4gaW50ZWdlciBvciBMb25nKVwiKTtpZihcIm51bWJlclwiIT09dHlwZW9mIGJ8fDAhPT1iJTEpdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitcbmIrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtiPj4+PTA7aWYoMD5ifHxiKzA+dGhpcy5idWZmZXIuYnl0ZUxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK2IrXCIgKCswKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTt9XCJudW1iZXJcIj09PXR5cGVvZiBhP2E9bC5mcm9tTnVtYmVyKGEsITEpOiExIT09YS51bnNpZ25lZCYmKGE9YS50b1NpZ25lZCgpKTt2YXIgZT1kLmNhbGN1bGF0ZVZhcmludDY0KGEpLGg9YS50b0ludCgpPj4+MCxmPWEuc2hpZnRSaWdodFVuc2lnbmVkKDI4KS50b0ludCgpPj4+MCxnPWEuc2hpZnRSaWdodFVuc2lnbmVkKDU2KS50b0ludCgpPj4+MDtiKz1lO3ZhciBuPXRoaXMuYnVmZmVyLmJ5dGVMZW5ndGg7Yj5uJiZ0aGlzLnJlc2l6ZSgobio9Mik+Yj9uOmIpO2ItPWU7c3dpdGNoKGUpe2Nhc2UgMTA6dGhpcy52aWV3LnNldFVpbnQ4KGIrOSxnPj4+NyYxKTtjYXNlIDk6dGhpcy52aWV3LnNldFVpbnQ4KGIrOCw5IT09XG5lP2d8MTI4OmcmMTI3KTtjYXNlIDg6dGhpcy52aWV3LnNldFVpbnQ4KGIrNyw4IT09ZT9mPj4+MjF8MTI4OmY+Pj4yMSYxMjcpO2Nhc2UgNzp0aGlzLnZpZXcuc2V0VWludDgoYis2LDchPT1lP2Y+Pj4xNHwxMjg6Zj4+PjE0JjEyNyk7Y2FzZSA2OnRoaXMudmlldy5zZXRVaW50OChiKzUsNiE9PWU/Zj4+Pjd8MTI4OmY+Pj43JjEyNyk7Y2FzZSA1OnRoaXMudmlldy5zZXRVaW50OChiKzQsNSE9PWU/ZnwxMjg6ZiYxMjcpO2Nhc2UgNDp0aGlzLnZpZXcuc2V0VWludDgoYiszLDQhPT1lP2g+Pj4yMXwxMjg6aD4+PjIxJjEyNyk7Y2FzZSAzOnRoaXMudmlldy5zZXRVaW50OChiKzIsMyE9PWU/aD4+PjE0fDEyODpoPj4+MTQmMTI3KTtjYXNlIDI6dGhpcy52aWV3LnNldFVpbnQ4KGIrMSwyIT09ZT9oPj4+N3wxMjg6aD4+PjcmMTI3KTtjYXNlIDE6dGhpcy52aWV3LnNldFVpbnQ4KGIsMSE9PWU/aHwxMjg6aCYxMjcpfXJldHVybiBjPyh0aGlzLm9mZnNldCs9ZSx0aGlzKTplfSxkLnByb3RvdHlwZS53cml0ZVZhcmludDY0WmlnWmFnPVxuZnVuY3Rpb24oYSxiKXtyZXR1cm4gdGhpcy53cml0ZVZhcmludDY0KGQuemlnWmFnRW5jb2RlNjQoYSksYil9LGQucHJvdG90eXBlLnJlYWRWYXJpbnQ2ND1mdW5jdGlvbihhKXt2YXIgYj1cInVuZGVmaW5lZFwiPT09dHlwZW9mIGE7YiYmKGE9dGhpcy5vZmZzZXQpO2lmKCF0aGlzLm5vQXNzZXJ0KXtpZihcIm51bWJlclwiIT09dHlwZW9mIGF8fDAhPT1hJTEpdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIithK1wiIChub3QgYW4gaW50ZWdlcilcIik7YT4+Pj0wO2lmKDA+YXx8YSsxPnRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIithK1wiICgrMSkgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7fXZhciBjPWEsZT0wLGQ9MCxmPTAsZz0wLGc9dGhpcy52aWV3LmdldFVpbnQ4KGErKyksZT1nJjEyNztpZihnJjEyOCYmKGc9dGhpcy52aWV3LmdldFVpbnQ4KGErKyksZXw9KGcmMTI3KTw8NyxnJjEyOCYmXG4oZz10aGlzLnZpZXcuZ2V0VWludDgoYSsrKSxlfD0oZyYxMjcpPDwxNCxnJjEyOCYmKGc9dGhpcy52aWV3LmdldFVpbnQ4KGErKyksZXw9KGcmMTI3KTw8MjEsZyYxMjgmJihnPXRoaXMudmlldy5nZXRVaW50OChhKyspLGQ9ZyYxMjcsZyYxMjgmJihnPXRoaXMudmlldy5nZXRVaW50OChhKyspLGR8PShnJjEyNyk8PDcsZyYxMjgmJihnPXRoaXMudmlldy5nZXRVaW50OChhKyspLGR8PShnJjEyNyk8PDE0LGcmMTI4JiYoZz10aGlzLnZpZXcuZ2V0VWludDgoYSsrKSxkfD0oZyYxMjcpPDwyMSxnJjEyOCYmKGc9dGhpcy52aWV3LmdldFVpbnQ4KGErKyksZj1nJjEyNyxnJjEyOCYmKGc9dGhpcy52aWV3LmdldFVpbnQ4KGErKyksZnw9KGcmMTI3KTw8NyxnJjEyOCkpKSkpKSkpKSl0aHJvdyBFcnJvcihcIkRhdGEgbXVzdCBiZSBjb3JydXB0OiBCdWZmZXIgb3ZlcnJ1blwiKTtlPWwuZnJvbTI4Qml0cyhlLGQsZiwhMSk7cmV0dXJuIGI/KHRoaXMub2Zmc2V0PWEsZSk6e3ZhbHVlOmUsbGVuZ3RoOmEtXG5jfX0sZC5wcm90b3R5cGUucmVhZFZhcmludDY0WmlnWmFnPWZ1bmN0aW9uKGEpeyhhPXRoaXMucmVhZFZhcmludDY0KGEpKSYmYS52YWx1ZSBpbnN0YW5jZW9mIGw/YS52YWx1ZT1kLnppZ1phZ0RlY29kZTY0KGEudmFsdWUpOmE9ZC56aWdaYWdEZWNvZGU2NChhKTtyZXR1cm4gYX0pO2QucHJvdG90eXBlLndyaXRlQ1N0cmluZz1mdW5jdGlvbihhLGIpe3ZhciBjPVwidW5kZWZpbmVkXCI9PT10eXBlb2YgYjtjJiYoYj10aGlzLm9mZnNldCk7dmFyIGUsZD1hLmxlbmd0aDtpZighdGhpcy5ub0Fzc2VydCl7aWYoXCJzdHJpbmdcIiE9PXR5cGVvZiBhKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIHN0cjogTm90IGEgc3RyaW5nXCIpO2ZvcihlPTA7ZTxkOysrZSlpZigwPT09YS5jaGFyQ29kZUF0KGUpKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSWxsZWdhbCBzdHI6IENvbnRhaW5zIE5VTEwtY2hhcmFjdGVyc1wiKTtpZihcIm51bWJlclwiIT09dHlwZW9mIGJ8fDAhPT1iJTEpdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitcbmIrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtiPj4+PTA7aWYoMD5ifHxiKzA+dGhpcy5idWZmZXIuYnl0ZUxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK2IrXCIgKCswKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTt9ZT1iO2Q9ay5iKGsuYShhKSlbMV07Yis9ZCsxO3ZhciBmPXRoaXMuYnVmZmVyLmJ5dGVMZW5ndGg7Yj5mJiZ0aGlzLnJlc2l6ZSgoZio9Mik+Yj9mOmIpO2ItPWQrMTtrLmUoay5hKGEpLGZ1bmN0aW9uKGEpe3RoaXMudmlldy5zZXRVaW50OChiKyssYSl9LmJpbmQodGhpcykpO3RoaXMudmlldy5zZXRVaW50OChiKyssMCk7cmV0dXJuIGM/KHRoaXMub2Zmc2V0PWItZSx0aGlzKTpkfTtkLnByb3RvdHlwZS5yZWFkQ1N0cmluZz1mdW5jdGlvbihhKXt2YXIgYj1cInVuZGVmaW5lZFwiPT09dHlwZW9mIGE7YiYmKGE9dGhpcy5vZmZzZXQpO2lmKCF0aGlzLm5vQXNzZXJ0KXtpZihcIm51bWJlclwiIT09dHlwZW9mIGF8fDAhPT1hJTEpdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitcbmErXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTthPj4+PTA7aWYoMD5hfHxhKzE+dGhpcy5idWZmZXIuYnl0ZUxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK2ErXCIgKCsxKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTt9dmFyIGM9YSxlLGQ9LTE7ay5kKGZ1bmN0aW9uKCl7aWYoMD09PWQpcmV0dXJuIG51bGw7aWYoYT49dGhpcy5saW1pdCl0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCByYW5nZTogVHJ1bmNhdGVkIGRhdGEsIFwiK2ErXCIgPCBcIit0aGlzLmxpbWl0KTtyZXR1cm4gMD09PShkPXRoaXMudmlldy5nZXRVaW50OChhKyspKT9udWxsOmR9LmJpbmQodGhpcyksZT1rLmMoKSwhMCk7cmV0dXJuIGI/KHRoaXMub2Zmc2V0PWEsZSgpKTp7c3RyaW5nOmUoKSxsZW5ndGg6YS1jfX07ZC5wcm90b3R5cGUud3JpdGVJU3RyaW5nPWZ1bmN0aW9uKGEsYil7dmFyIGM9XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBiO2MmJihiPXRoaXMub2Zmc2V0KTtpZighdGhpcy5ub0Fzc2VydCl7aWYoXCJzdHJpbmdcIiE9PVxudHlwZW9mIGEpdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgc3RyOiBOb3QgYSBzdHJpbmdcIik7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBifHwwIT09YiUxKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrYitcIiAobm90IGFuIGludGVnZXIpXCIpO2I+Pj49MDtpZigwPmJ8fGIrMD50aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrYitcIiAoKzApIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO312YXIgZT1iLGQ7ZD1rLmIoay5hKGEpLHRoaXMubm9Bc3NlcnQpWzFdO2IrPTQrZDt2YXIgZj10aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoO2I+ZiYmdGhpcy5yZXNpemUoKGYqPTIpPmI/ZjpiKTtiLT00K2Q7dGhpcy52aWV3LnNldFVpbnQzMihiLGQsdGhpcy5saXR0bGVFbmRpYW4pO2IrPTQ7ay5lKGsuYShhKSxmdW5jdGlvbihhKXt0aGlzLnZpZXcuc2V0VWludDgoYisrLGEpfS5iaW5kKHRoaXMpKTtcbmlmKGIhPT1lKzQrZCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIklsbGVnYWwgcmFuZ2U6IFRydW5jYXRlZCBkYXRhLCBcIitiK1wiID09IFwiKyhiKzQrZCkpO3JldHVybiBjPyh0aGlzLm9mZnNldD1iLHRoaXMpOmItZX07ZC5wcm90b3R5cGUucmVhZElTdHJpbmc9ZnVuY3Rpb24oYSl7dmFyIGI9XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBhO2ImJihhPXRoaXMub2Zmc2V0KTtpZighdGhpcy5ub0Fzc2VydCl7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBhfHwwIT09YSUxKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrYStcIiAobm90IGFuIGludGVnZXIpXCIpO2E+Pj49MDtpZigwPmF8fGErND50aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrYStcIiAoKzQpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO312YXIgYz0wLGU9YSxjPXRoaXMudmlldy5nZXRVaW50MzIoYSx0aGlzLmxpdHRsZUVuZGlhbik7YSs9XG40O3ZhciBkPWErYztrLmQoZnVuY3Rpb24oKXtyZXR1cm4gYTxkP3RoaXMudmlldy5nZXRVaW50OChhKyspOm51bGx9LmJpbmQodGhpcyksYz1rLmMoKSx0aGlzLm5vQXNzZXJ0KTtjPWMoKTtyZXR1cm4gYj8odGhpcy5vZmZzZXQ9YSxjKTp7c3RyaW5nOmMsbGVuZ3RoOmEtZX19O2QuTUVUUklDU19DSEFSUz1cImNcIjtkLk1FVFJJQ1NfQllURVM9XCJiXCI7ZC5wcm90b3R5cGUud3JpdGVVVEY4U3RyaW5nPWZ1bmN0aW9uKGEsYil7dmFyIGM9XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBiO2MmJihiPXRoaXMub2Zmc2V0KTtpZighdGhpcy5ub0Fzc2VydCl7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBifHwwIT09YiUxKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrYitcIiAobm90IGFuIGludGVnZXIpXCIpO2I+Pj49MDtpZigwPmJ8fGIrMD50aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrYitcIiAoKzApIDw9IFwiK1xudGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7fXZhciBlLGQ9YjtlPWsuYihrLmEoYSkpWzFdO2IrPWU7dmFyIGY9dGhpcy5idWZmZXIuYnl0ZUxlbmd0aDtiPmYmJnRoaXMucmVzaXplKChmKj0yKT5iP2Y6Yik7Yi09ZTtrLmUoay5hKGEpLGZ1bmN0aW9uKGEpe3RoaXMudmlldy5zZXRVaW50OChiKyssYSl9LmJpbmQodGhpcykpO3JldHVybiBjPyh0aGlzLm9mZnNldD1iLHRoaXMpOmItZH07ZC5wcm90b3R5cGUud3JpdGVTdHJpbmc9ZC5wcm90b3R5cGUud3JpdGVVVEY4U3RyaW5nO2QuY2FsY3VsYXRlVVRGOENoYXJzPWZ1bmN0aW9uKGEpe3JldHVybiBrLmIoay5hKGEpKVswXX07ZC5jYWxjdWxhdGVVVEY4Qnl0ZXM9ZnVuY3Rpb24oYSl7cmV0dXJuIGsuYihrLmEoYSkpWzFdfTtkLnByb3RvdHlwZS5yZWFkVVRGOFN0cmluZz1mdW5jdGlvbihhLGIsYyl7XCJudW1iZXJcIj09PXR5cGVvZiBiJiYoYz1iLGI9dm9pZCAwKTt2YXIgZT1cInVuZGVmaW5lZFwiPT09dHlwZW9mIGM7ZSYmKGM9dGhpcy5vZmZzZXQpO1xuXCJ1bmRlZmluZWRcIj09PXR5cGVvZiBiJiYoYj1kLk1FVFJJQ1NfQ0hBUlMpO2lmKCF0aGlzLm5vQXNzZXJ0KXtpZihcIm51bWJlclwiIT09dHlwZW9mIGF8fDAhPT1hJTEpdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgbGVuZ3RoOiBcIithK1wiIChub3QgYW4gaW50ZWdlcilcIik7YXw9MDtpZihcIm51bWJlclwiIT09dHlwZW9mIGN8fDAhPT1jJTEpdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitjK1wiIChub3QgYW4gaW50ZWdlcilcIik7Yz4+Pj0wO2lmKDA+Y3x8YyswPnRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitjK1wiICgrMCkgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7fXZhciBoPTAsZj1jLGc7aWYoYj09PWQuTUVUUklDU19DSEFSUyl7Zz1rLmMoKTtrLmkoZnVuY3Rpb24oKXtyZXR1cm4gaDxhJiZjPHRoaXMubGltaXQ/dGhpcy52aWV3LmdldFVpbnQ4KGMrKyk6bnVsbH0uYmluZCh0aGlzKSxcbmZ1bmN0aW9uKGEpeysraDtrLmcoYSxnKX0uYmluZCh0aGlzKSk7aWYoaCE9PWEpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIHJhbmdlOiBUcnVuY2F0ZWQgZGF0YSwgXCIraCtcIiA9PSBcIithKTtyZXR1cm4gZT8odGhpcy5vZmZzZXQ9YyxnKCkpOntzdHJpbmc6ZygpLGxlbmd0aDpjLWZ9fWlmKGI9PT1kLk1FVFJJQ1NfQllURVMpe2lmKCF0aGlzLm5vQXNzZXJ0KXtpZihcIm51bWJlclwiIT09dHlwZW9mIGN8fDAhPT1jJTEpdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitjK1wiIChub3QgYW4gaW50ZWdlcilcIik7Yz4+Pj0wO2lmKDA+Y3x8YythPnRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitjK1wiICgrXCIrYStcIikgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7fXZhciBuPWMrYTtrLmQoZnVuY3Rpb24oKXtyZXR1cm4gYzxuP3RoaXMudmlldy5nZXRVaW50OChjKyspOm51bGx9LmJpbmQodGhpcyksXG5nPWsuYygpLHRoaXMubm9Bc3NlcnQpO2lmKGMhPT1uKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSWxsZWdhbCByYW5nZTogVHJ1bmNhdGVkIGRhdGEsIFwiK2MrXCIgPT0gXCIrbik7cmV0dXJuIGU/KHRoaXMub2Zmc2V0PWMsZygpKTp7c3RyaW5nOmcoKSxsZW5ndGg6Yy1mfX10aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5zdXBwb3J0ZWQgbWV0cmljczogXCIrYik7fTtkLnByb3RvdHlwZS5yZWFkU3RyaW5nPWQucHJvdG90eXBlLnJlYWRVVEY4U3RyaW5nO2QucHJvdG90eXBlLndyaXRlVlN0cmluZz1mdW5jdGlvbihhLGIpe3ZhciBjPVwidW5kZWZpbmVkXCI9PT10eXBlb2YgYjtjJiYoYj10aGlzLm9mZnNldCk7aWYoIXRoaXMubm9Bc3NlcnQpe2lmKFwic3RyaW5nXCIhPT10eXBlb2YgYSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBzdHI6IE5vdCBhIHN0cmluZ1wiKTtpZihcIm51bWJlclwiIT09dHlwZW9mIGJ8fDAhPT1iJTEpdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitiK1xuXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtiPj4+PTA7aWYoMD5ifHxiKzA+dGhpcy5idWZmZXIuYnl0ZUxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK2IrXCIgKCswKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTt9dmFyIGU9YixoLGY7aD1rLmIoay5hKGEpLHRoaXMubm9Bc3NlcnQpWzFdO2Y9ZC5jYWxjdWxhdGVWYXJpbnQzMihoKTtiKz1mK2g7dmFyIGc9dGhpcy5idWZmZXIuYnl0ZUxlbmd0aDtiPmcmJnRoaXMucmVzaXplKChnKj0yKT5iP2c6Yik7Yi09ZitoO2IrPXRoaXMud3JpdGVWYXJpbnQzMihoLGIpO2suZShrLmEoYSksZnVuY3Rpb24oYSl7dGhpcy52aWV3LnNldFVpbnQ4KGIrKyxhKX0uYmluZCh0aGlzKSk7aWYoYiE9PWUraCtmKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSWxsZWdhbCByYW5nZTogVHJ1bmNhdGVkIGRhdGEsIFwiK2IrXCIgPT0gXCIrKGIraCtmKSk7cmV0dXJuIGM/KHRoaXMub2Zmc2V0PWIsdGhpcyk6Yi1lfTtkLnByb3RvdHlwZS5yZWFkVlN0cmluZz1cbmZ1bmN0aW9uKGEpe3ZhciBiPVwidW5kZWZpbmVkXCI9PT10eXBlb2YgYTtiJiYoYT10aGlzLm9mZnNldCk7aWYoIXRoaXMubm9Bc3NlcnQpe2lmKFwibnVtYmVyXCIhPT10eXBlb2YgYXx8MCE9PWElMSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK2ErXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTthPj4+PTA7aWYoMD5hfHxhKzE+dGhpcy5idWZmZXIuYnl0ZUxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK2ErXCIgKCsxKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTt9dmFyIGM9dGhpcy5yZWFkVmFyaW50MzIoYSksZT1hO2ErPWMubGVuZ3RoO3ZhciBjPWMudmFsdWUsZD1hK2MsYz1rLmMoKTtrLmQoZnVuY3Rpb24oKXtyZXR1cm4gYTxkP3RoaXMudmlldy5nZXRVaW50OChhKyspOm51bGx9LmJpbmQodGhpcyksYyx0aGlzLm5vQXNzZXJ0KTtjPWMoKTtyZXR1cm4gYj8odGhpcy5vZmZzZXQ9YSxjKTp7c3RyaW5nOmMsbGVuZ3RoOmEtXG5lfX07ZC5wcm90b3R5cGUuYXBwZW5kPWZ1bmN0aW9uKGEsYixjKXtpZihcIm51bWJlclwiPT09dHlwZW9mIGJ8fFwic3RyaW5nXCIhPT10eXBlb2YgYiljPWIsYj12b2lkIDA7dmFyIGU9XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBjO2UmJihjPXRoaXMub2Zmc2V0KTtpZighdGhpcy5ub0Fzc2VydCl7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBjfHwwIT09YyUxKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrYytcIiAobm90IGFuIGludGVnZXIpXCIpO2M+Pj49MDtpZigwPmN8fGMrMD50aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrYytcIiAoKzApIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO31hIGluc3RhbmNlb2YgZHx8KGE9ZC53cmFwKGEsYikpO2I9YS5saW1pdC1hLm9mZnNldDtpZigwPj1iKXJldHVybiB0aGlzO2MrPWI7dmFyIGg9dGhpcy5idWZmZXIuYnl0ZUxlbmd0aDtjPmgmJnRoaXMucmVzaXplKChoKj1cbjIpPmM/aDpjKTsobmV3IFVpbnQ4QXJyYXkodGhpcy5idWZmZXIsYy1iKSkuc2V0KChuZXcgVWludDhBcnJheShhLmJ1ZmZlcikpLnN1YmFycmF5KGEub2Zmc2V0LGEubGltaXQpKTthLm9mZnNldCs9YjtlJiYodGhpcy5vZmZzZXQrPWIpO3JldHVybiB0aGlzfTtkLnByb3RvdHlwZS5hcHBlbmRUbz1mdW5jdGlvbihhLGIpe2EuYXBwZW5kKHRoaXMsYik7cmV0dXJuIHRoaXN9O2QucHJvdG90eXBlLmFzc2VydD1mdW5jdGlvbihhKXt0aGlzLm5vQXNzZXJ0PSFhO3JldHVybiB0aGlzfTtkLnByb3RvdHlwZS5jYXBhY2l0eT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RofTtkLnByb3RvdHlwZS5jbGVhcj1mdW5jdGlvbigpe3RoaXMub2Zmc2V0PTA7dGhpcy5saW1pdD10aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoO3RoaXMubWFya2VkT2Zmc2V0PS0xO3JldHVybiB0aGlzfTtkLnByb3RvdHlwZS5jbG9uZT1mdW5jdGlvbihhKXt2YXIgYj1uZXcgZCgwLHRoaXMubGl0dGxlRW5kaWFuLFxudGhpcy5ub0Fzc2VydCk7YT8oYT1uZXcgQXJyYXlCdWZmZXIodGhpcy5idWZmZXIuYnl0ZUxlbmd0aCksKG5ldyBVaW50OEFycmF5KGEpKS5zZXQodGhpcy5idWZmZXIpLGIuYnVmZmVyPWEsYi52aWV3PW5ldyBEYXRhVmlldyhhKSk6KGIuYnVmZmVyPXRoaXMuYnVmZmVyLGIudmlldz10aGlzLnZpZXcpO2Iub2Zmc2V0PXRoaXMub2Zmc2V0O2IubWFya2VkT2Zmc2V0PXRoaXMubWFya2VkT2Zmc2V0O2IubGltaXQ9dGhpcy5saW1pdDtyZXR1cm4gYn07ZC5wcm90b3R5cGUuY29tcGFjdD1mdW5jdGlvbihhLGIpe1widW5kZWZpbmVkXCI9PT10eXBlb2YgYSYmKGE9dGhpcy5vZmZzZXQpO1widW5kZWZpbmVkXCI9PT10eXBlb2YgYiYmKGI9dGhpcy5saW1pdCk7aWYoIXRoaXMubm9Bc3NlcnQpe2lmKFwibnVtYmVyXCIhPT10eXBlb2YgYXx8MCE9PWElMSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBiZWdpbjogTm90IGFuIGludGVnZXJcIik7YT4+Pj0wO2lmKFwibnVtYmVyXCIhPT10eXBlb2YgYnx8XG4wIT09YiUxKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGVuZDogTm90IGFuIGludGVnZXJcIik7Yj4+Pj0wO2lmKDA+YXx8YT5ifHxiPnRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIHJhbmdlOiAwIDw9IFwiK2ErXCIgPD0gXCIrYitcIiA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTt9aWYoMD09PWEmJmI9PT10aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKXJldHVybiB0aGlzO3ZhciBjPWItYTtpZigwPT09YylyZXR1cm4gdGhpcy5idWZmZXI9cix0aGlzLnZpZXc9bnVsbCwwPD10aGlzLm1hcmtlZE9mZnNldCYmKHRoaXMubWFya2VkT2Zmc2V0LT1hKSx0aGlzLmxpbWl0PXRoaXMub2Zmc2V0PTAsdGhpczt2YXIgZT1uZXcgQXJyYXlCdWZmZXIoYyk7KG5ldyBVaW50OEFycmF5KGUpKS5zZXQoKG5ldyBVaW50OEFycmF5KHRoaXMuYnVmZmVyKSkuc3ViYXJyYXkoYSxiKSk7dGhpcy5idWZmZXI9ZTt0aGlzLnZpZXc9bmV3IERhdGFWaWV3KGUpO1xuMDw9dGhpcy5tYXJrZWRPZmZzZXQmJih0aGlzLm1hcmtlZE9mZnNldC09YSk7dGhpcy5vZmZzZXQ9MDt0aGlzLmxpbWl0PWM7cmV0dXJuIHRoaXN9O2QucHJvdG90eXBlLmNvcHk9ZnVuY3Rpb24oYSxiKXtcInVuZGVmaW5lZFwiPT09dHlwZW9mIGEmJihhPXRoaXMub2Zmc2V0KTtcInVuZGVmaW5lZFwiPT09dHlwZW9mIGImJihiPXRoaXMubGltaXQpO2lmKCF0aGlzLm5vQXNzZXJ0KXtpZihcIm51bWJlclwiIT09dHlwZW9mIGF8fDAhPT1hJTEpdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgYmVnaW46IE5vdCBhbiBpbnRlZ2VyXCIpO2E+Pj49MDtpZihcIm51bWJlclwiIT09dHlwZW9mIGJ8fDAhPT1iJTEpdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgZW5kOiBOb3QgYW4gaW50ZWdlclwiKTtiPj4+PTA7aWYoMD5hfHxhPmJ8fGI+dGhpcy5idWZmZXIuYnl0ZUxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIklsbGVnYWwgcmFuZ2U6IDAgPD0gXCIrYStcIiA8PSBcIitiK1wiIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xufWlmKGE9PT1iKXJldHVybiBuZXcgZCgwLHRoaXMubGl0dGxlRW5kaWFuLHRoaXMubm9Bc3NlcnQpO3ZhciBjPWItYSxlPW5ldyBkKGMsdGhpcy5saXR0bGVFbmRpYW4sdGhpcy5ub0Fzc2VydCk7ZS5vZmZzZXQ9MDtlLmxpbWl0PWM7MDw9ZS5tYXJrZWRPZmZzZXQmJihlLm1hcmtlZE9mZnNldC09YSk7dGhpcy5jb3B5VG8oZSwwLGEsYik7cmV0dXJuIGV9O2QucHJvdG90eXBlLmNvcHlUbz1mdW5jdGlvbihhLGIsYyxlKXt2YXIgaCxmO2lmKCF0aGlzLm5vQXNzZXJ0JiYhZC5pc0J5dGVCdWZmZXIoYSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgdGFyZ2V0OiBOb3QgYSBCeXRlQnVmZmVyXCIpO2I9KGY9XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBiKT9hLm9mZnNldDpifDA7Yz0oaD1cInVuZGVmaW5lZFwiPT09dHlwZW9mIGMpP3RoaXMub2Zmc2V0OmN8MDtlPVwidW5kZWZpbmVkXCI9PT10eXBlb2YgZT90aGlzLmxpbWl0OmV8MDtpZigwPmJ8fGI+YS5idWZmZXIuYnl0ZUxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIklsbGVnYWwgdGFyZ2V0IHJhbmdlOiAwIDw9IFwiK1xuYitcIiA8PSBcIithLmJ1ZmZlci5ieXRlTGVuZ3RoKTtpZigwPmN8fGU+dGhpcy5idWZmZXIuYnl0ZUxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIklsbGVnYWwgc291cmNlIHJhbmdlOiAwIDw9IFwiK2MrXCIgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7dmFyIGc9ZS1jO2lmKDA9PT1nKXJldHVybiBhO2EuZW5zdXJlQ2FwYWNpdHkoYitnKTsobmV3IFVpbnQ4QXJyYXkoYS5idWZmZXIpKS5zZXQoKG5ldyBVaW50OEFycmF5KHRoaXMuYnVmZmVyKSkuc3ViYXJyYXkoYyxlKSxiKTtoJiYodGhpcy5vZmZzZXQrPWcpO2YmJihhLm9mZnNldCs9Zyk7cmV0dXJuIHRoaXN9O2QucHJvdG90eXBlLmVuc3VyZUNhcGFjaXR5PWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuYnVmZmVyLmJ5dGVMZW5ndGg7cmV0dXJuIGI8YT90aGlzLnJlc2l6ZSgoYio9Mik+YT9iOmEpOnRoaXN9O2QucHJvdG90eXBlLmZpbGw9ZnVuY3Rpb24oYSxiLGMpe3ZhciBlPVwidW5kZWZpbmVkXCI9PT10eXBlb2YgYjtlJiZcbihiPXRoaXMub2Zmc2V0KTtcInN0cmluZ1wiPT09dHlwZW9mIGEmJjA8YS5sZW5ndGgmJihhPWEuY2hhckNvZGVBdCgwKSk7XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBiJiYoYj10aGlzLm9mZnNldCk7XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBjJiYoYz10aGlzLmxpbWl0KTtpZighdGhpcy5ub0Fzc2VydCl7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBhfHwwIT09YSUxKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIHZhbHVlOiBcIithK1wiIChub3QgYW4gaW50ZWdlcilcIik7YXw9MDtpZihcIm51bWJlclwiIT09dHlwZW9mIGJ8fDAhPT1iJTEpdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgYmVnaW46IE5vdCBhbiBpbnRlZ2VyXCIpO2I+Pj49MDtpZihcIm51bWJlclwiIT09dHlwZW9mIGN8fDAhPT1jJTEpdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgZW5kOiBOb3QgYW4gaW50ZWdlclwiKTtjPj4+PTA7aWYoMD5ifHxiPmN8fGM+dGhpcy5idWZmZXIuYnl0ZUxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIklsbGVnYWwgcmFuZ2U6IDAgPD0gXCIrXG5iK1wiIDw9IFwiK2MrXCIgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7fWlmKGI+PWMpcmV0dXJuIHRoaXM7Zm9yKDtiPGM7KXRoaXMudmlldy5zZXRVaW50OChiKyssYSk7ZSYmKHRoaXMub2Zmc2V0PWIpO3JldHVybiB0aGlzfTtkLnByb3RvdHlwZS5mbGlwPWZ1bmN0aW9uKCl7dGhpcy5saW1pdD10aGlzLm9mZnNldDt0aGlzLm9mZnNldD0wO3JldHVybiB0aGlzfTtkLnByb3RvdHlwZS5tYXJrPWZ1bmN0aW9uKGEpe2E9XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBhP3RoaXMub2Zmc2V0OmE7aWYoIXRoaXMubm9Bc3NlcnQpe2lmKFwibnVtYmVyXCIhPT10eXBlb2YgYXx8MCE9PWElMSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK2ErXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTthPj4+PTA7aWYoMD5hfHxhKzA+dGhpcy5idWZmZXIuYnl0ZUxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK2ErXCIgKCswKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbn10aGlzLm1hcmtlZE9mZnNldD1hO3JldHVybiB0aGlzfTtkLnByb3RvdHlwZS5vcmRlcj1mdW5jdGlvbihhKXtpZighdGhpcy5ub0Fzc2VydCYmXCJib29sZWFuXCIhPT10eXBlb2YgYSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBsaXR0bGVFbmRpYW46IE5vdCBhIGJvb2xlYW5cIik7dGhpcy5saXR0bGVFbmRpYW49ISFhO3JldHVybiB0aGlzfTtkLnByb3RvdHlwZS5MRT1mdW5jdGlvbihhKXt0aGlzLmxpdHRsZUVuZGlhbj1cInVuZGVmaW5lZFwiIT09dHlwZW9mIGE/ISFhOiEwO3JldHVybiB0aGlzfTtkLnByb3RvdHlwZS5CRT1mdW5jdGlvbihhKXt0aGlzLmxpdHRsZUVuZGlhbj1cInVuZGVmaW5lZFwiIT09dHlwZW9mIGE/IWE6ITE7cmV0dXJuIHRoaXN9O2QucHJvdG90eXBlLnByZXBlbmQ9ZnVuY3Rpb24oYSxiLGMpe2lmKFwibnVtYmVyXCI9PT10eXBlb2YgYnx8XCJzdHJpbmdcIiE9PXR5cGVvZiBiKWM9YixiPXZvaWQgMDt2YXIgZT1cInVuZGVmaW5lZFwiPT09dHlwZW9mIGM7ZSYmKGM9XG50aGlzLm9mZnNldCk7aWYoIXRoaXMubm9Bc3NlcnQpe2lmKFwibnVtYmVyXCIhPT10eXBlb2YgY3x8MCE9PWMlMSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK2MrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtjPj4+PTA7aWYoMD5jfHxjKzA+dGhpcy5idWZmZXIuYnl0ZUxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK2MrXCIgKCswKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTt9YSBpbnN0YW5jZW9mIGR8fChhPWQud3JhcChhLGIpKTtiPWEubGltaXQtYS5vZmZzZXQ7aWYoMD49YilyZXR1cm4gdGhpczt2YXIgaD1iLWMsZjtpZigwPGgpe3ZhciBnPW5ldyBBcnJheUJ1ZmZlcih0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoK2gpO2Y9bmV3IFVpbnQ4QXJyYXkoZyk7Zi5zZXQoKG5ldyBVaW50OEFycmF5KHRoaXMuYnVmZmVyKSkuc3ViYXJyYXkoYyx0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKSxiKTt0aGlzLmJ1ZmZlcj1nO3RoaXMudmlldz1cbm5ldyBEYXRhVmlldyhnKTt0aGlzLm9mZnNldCs9aDswPD10aGlzLm1hcmtlZE9mZnNldCYmKHRoaXMubWFya2VkT2Zmc2V0Kz1oKTt0aGlzLmxpbWl0Kz1oO2MrPWh9ZWxzZSBmPW5ldyBVaW50OEFycmF5KHRoaXMuYnVmZmVyKTtmLnNldCgobmV3IFVpbnQ4QXJyYXkoYS5idWZmZXIpKS5zdWJhcnJheShhLm9mZnNldCxhLmxpbWl0KSxjLWIpO2Eub2Zmc2V0PWEubGltaXQ7ZSYmKHRoaXMub2Zmc2V0LT1iKTtyZXR1cm4gdGhpc307ZC5wcm90b3R5cGUucHJlcGVuZFRvPWZ1bmN0aW9uKGEsYil7YS5wcmVwZW5kKHRoaXMsYik7cmV0dXJuIHRoaXN9O2QucHJvdG90eXBlLnByaW50RGVidWc9ZnVuY3Rpb24oYSl7XCJmdW5jdGlvblwiIT09dHlwZW9mIGEmJihhPWNvbnNvbGUubG9nLmJpbmQoY29uc29sZSkpO2EodGhpcy50b1N0cmluZygpK1wiXFxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcblwiK3RoaXMudG9EZWJ1ZyghMCkpfTtcbmQucHJvdG90eXBlLnJlbWFpbmluZz1mdW5jdGlvbigpe3JldHVybiB0aGlzLmxpbWl0LXRoaXMub2Zmc2V0fTtkLnByb3RvdHlwZS5yZXNldD1mdW5jdGlvbigpezA8PXRoaXMubWFya2VkT2Zmc2V0Pyh0aGlzLm9mZnNldD10aGlzLm1hcmtlZE9mZnNldCx0aGlzLm1hcmtlZE9mZnNldD0tMSk6dGhpcy5vZmZzZXQ9MDtyZXR1cm4gdGhpc307ZC5wcm90b3R5cGUucmVzaXplPWZ1bmN0aW9uKGEpe2lmKCF0aGlzLm5vQXNzZXJ0KXtpZihcIm51bWJlclwiIT09dHlwZW9mIGF8fDAhPT1hJTEpdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgY2FwYWNpdHk6IFwiK2ErXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTthfD0wO2lmKDA+YSl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIklsbGVnYWwgY2FwYWNpdHk6IDAgPD0gXCIrYSk7fXRoaXMuYnVmZmVyLmJ5dGVMZW5ndGg8YSYmKGE9bmV3IEFycmF5QnVmZmVyKGEpLChuZXcgVWludDhBcnJheShhKSkuc2V0KG5ldyBVaW50OEFycmF5KHRoaXMuYnVmZmVyKSksXG50aGlzLmJ1ZmZlcj1hLHRoaXMudmlldz1uZXcgRGF0YVZpZXcoYSkpO3JldHVybiB0aGlzfTtkLnByb3RvdHlwZS5yZXZlcnNlPWZ1bmN0aW9uKGEsYil7XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBhJiYoYT10aGlzLm9mZnNldCk7XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBiJiYoYj10aGlzLmxpbWl0KTtpZighdGhpcy5ub0Fzc2VydCl7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBhfHwwIT09YSUxKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGJlZ2luOiBOb3QgYW4gaW50ZWdlclwiKTthPj4+PTA7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBifHwwIT09YiUxKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGVuZDogTm90IGFuIGludGVnZXJcIik7Yj4+Pj0wO2lmKDA+YXx8YT5ifHxiPnRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIHJhbmdlOiAwIDw9IFwiK2ErXCIgPD0gXCIrYitcIiA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTt9aWYoYT09PWIpcmV0dXJuIHRoaXM7XG5BcnJheS5wcm90b3R5cGUucmV2ZXJzZS5jYWxsKChuZXcgVWludDhBcnJheSh0aGlzLmJ1ZmZlcikpLnN1YmFycmF5KGEsYikpO3RoaXMudmlldz1uZXcgRGF0YVZpZXcodGhpcy5idWZmZXIpO3JldHVybiB0aGlzfTtkLnByb3RvdHlwZS5za2lwPWZ1bmN0aW9uKGEpe2lmKCF0aGlzLm5vQXNzZXJ0KXtpZihcIm51bWJlclwiIT09dHlwZW9mIGF8fDAhPT1hJTEpdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgbGVuZ3RoOiBcIithK1wiIChub3QgYW4gaW50ZWdlcilcIik7YXw9MH12YXIgYj10aGlzLm9mZnNldCthO2lmKCF0aGlzLm5vQXNzZXJ0JiYoMD5ifHxiPnRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSWxsZWdhbCBsZW5ndGg6IDAgPD0gXCIrdGhpcy5vZmZzZXQrXCIgKyBcIithK1wiIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO3RoaXMub2Zmc2V0PWI7cmV0dXJuIHRoaXN9O2QucHJvdG90eXBlLnNsaWNlPWZ1bmN0aW9uKGEsYil7XCJ1bmRlZmluZWRcIj09PVxudHlwZW9mIGEmJihhPXRoaXMub2Zmc2V0KTtcInVuZGVmaW5lZFwiPT09dHlwZW9mIGImJihiPXRoaXMubGltaXQpO2lmKCF0aGlzLm5vQXNzZXJ0KXtpZihcIm51bWJlclwiIT09dHlwZW9mIGF8fDAhPT1hJTEpdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgYmVnaW46IE5vdCBhbiBpbnRlZ2VyXCIpO2E+Pj49MDtpZihcIm51bWJlclwiIT09dHlwZW9mIGJ8fDAhPT1iJTEpdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgZW5kOiBOb3QgYW4gaW50ZWdlclwiKTtiPj4+PTA7aWYoMD5hfHxhPmJ8fGI+dGhpcy5idWZmZXIuYnl0ZUxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIklsbGVnYWwgcmFuZ2U6IDAgPD0gXCIrYStcIiA8PSBcIitiK1wiIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO312YXIgYz10aGlzLmNsb25lKCk7Yy5vZmZzZXQ9YTtjLmxpbWl0PWI7cmV0dXJuIGN9O2QucHJvdG90eXBlLnRvQnVmZmVyPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMub2Zmc2V0LGM9dGhpcy5saW1pdDtcbmlmKGI+Yyl2YXIgZT1iLGI9YyxjPWU7aWYoIXRoaXMubm9Bc3NlcnQpe2lmKFwibnVtYmVyXCIhPT10eXBlb2YgYnx8MCE9PWIlMSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IE5vdCBhbiBpbnRlZ2VyXCIpO2I+Pj49MDtpZihcIm51bWJlclwiIT09dHlwZW9mIGN8fDAhPT1jJTEpdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgbGltaXQ6IE5vdCBhbiBpbnRlZ2VyXCIpO2M+Pj49MDtpZigwPmJ8fGI+Y3x8Yz50aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSWxsZWdhbCByYW5nZTogMCA8PSBcIitiK1wiIDw9IFwiK2MrXCIgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7fWlmKCFhJiYwPT09YiYmYz09PXRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpcmV0dXJuIHRoaXMuYnVmZmVyO2lmKGI9PT1jKXJldHVybiByO2E9bmV3IEFycmF5QnVmZmVyKGMtYik7KG5ldyBVaW50OEFycmF5KGEpKS5zZXQoKG5ldyBVaW50OEFycmF5KHRoaXMuYnVmZmVyKSkuc3ViYXJyYXkoYixcbmMpLDApO3JldHVybiBhfTtkLnByb3RvdHlwZS50b0FycmF5QnVmZmVyPWQucHJvdG90eXBlLnRvQnVmZmVyO2QucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKGEpe2lmKFwidW5kZWZpbmVkXCI9PT10eXBlb2YgYSlyZXR1cm5cIkJ5dGVCdWZmZXJBQihvZmZzZXQ9XCIrdGhpcy5vZmZzZXQrXCIsbWFya2VkT2Zmc2V0PVwiK3RoaXMubWFya2VkT2Zmc2V0K1wiLGxpbWl0PVwiK3RoaXMubGltaXQrXCIsY2FwYWNpdHk9XCIrdGhpcy5jYXBhY2l0eSgpK1wiKVwiO3N3aXRjaChhKXtjYXNlIFwidXRmOFwiOnJldHVybiB0aGlzLnRvVVRGOCgpO2Nhc2UgXCJiYXNlNjRcIjpyZXR1cm4gdGhpcy50b0Jhc2U2NCgpO2Nhc2UgXCJoZXhcIjpyZXR1cm4gdGhpcy50b0hleCgpO2Nhc2UgXCJiaW5hcnlcIjpyZXR1cm4gdGhpcy50b0JpbmFyeSgpO2Nhc2UgXCJkZWJ1Z1wiOnJldHVybiB0aGlzLnRvRGVidWcoKTtjYXNlIFwiY29sdW1uc1wiOnJldHVybiB0aGlzLm8oKTtkZWZhdWx0OnRocm93IEVycm9yKFwiVW5zdXBwb3J0ZWQgZW5jb2Rpbmc6IFwiK1xuYSk7fX07dmFyIG09XCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPVwiLG09bStcIlwiO2QucHJvdG90eXBlLnRvQmFzZTY0PWZ1bmN0aW9uKGEsYil7XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBhJiYoYT10aGlzLm9mZnNldCk7XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBiJiYoYj10aGlzLmxpbWl0KTtpZighdGhpcy5ub0Fzc2VydCl7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBhfHwwIT09YSUxKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGJlZ2luOiBOb3QgYW4gaW50ZWdlclwiKTthPj4+PTA7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBifHwwIT09YiUxKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGVuZDogTm90IGFuIGludGVnZXJcIik7Yj4+Pj0wO2lmKDA+YXx8YT5ifHxiPnRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIHJhbmdlOiAwIDw9IFwiK2ErXCIgPD0gXCIrYitcIiA8PSBcIitcbnRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO31pZihhPT09YilyZXR1cm5cIlwiO2Zvcih2YXIgYyxlLGQsZixnLGssbD1cIlwiO2E8YjspYz10aGlzLnZpZXcuZ2V0VWludDgoYSsrKSxlPShmPWE8Yik/dGhpcy52aWV3LmdldFVpbnQ4KGErKyk6MCxkPShnPWE8Yik/dGhpcy52aWV3LmdldFVpbnQ4KGErKyk6MCxrPWM+PjIsYz0oYyYzKTw8NHxlPj40LGU9KGUmMTUpPDwyfGQ+PjYsZCY9NjMsZ3x8KGQ9NjQsZnx8KGU9NjQpKSxsKz1tLmNoYXJBdChrKSttLmNoYXJBdChjKSttLmNoYXJBdChlKSttLmNoYXJBdChkKTtyZXR1cm4gbH07ZC5mcm9tQmFzZTY0PWZ1bmN0aW9uKGEsYixjKXtpZighYyl7aWYoXCJzdHJpbmdcIiE9PXR5cGVvZiBhKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIHN0cjogTm90IGEgc3RyaW5nXCIpO2lmKDAhPT1hLmxlbmd0aCU0KXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIHN0cjogTGVuZ3RoIG5vdCBhIG11bHRpcGxlIG9mIDRcIik7fXZhciBlPWEubGVuZ3RoLFxuaD0wLGY7Zm9yKGY9YS5sZW5ndGgtMTswPD1mOy0tZilpZihcIj1cIj09PWEuY2hhckF0KGYpKWgrKztlbHNlIGJyZWFrO2lmKDI8aCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBzdHI6IFN1ZmZpeCBpcyB0b28gbGFyZ2VcIik7aWYoMD09PWUpcmV0dXJuIG5ldyBkKDAsYixjKTt2YXIgZyxrLGwscD1uZXcgZChlLzQqMy1oLGIsYyk7Zm9yKGI9Zj0wO2Y8ZTspe2g9bS5pbmRleE9mKGEuY2hhckF0KGYrKykpO2c9ZjxlP20uaW5kZXhPZihhLmNoYXJBdChmKyspKTowO2s9ZjxlP20uaW5kZXhPZihhLmNoYXJBdChmKyspKTowO2w9ZjxlP20uaW5kZXhPZihhLmNoYXJBdChmKyspKTowO2lmKCFjJiYoMD5ofHwwPmd8fDA+a3x8MD5sKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBzdHI6IENvbnRhaW5zIG5vbi1iYXNlNjQgY2hhcmFjdGVyc1wiKTtwLnZpZXcuc2V0VWludDgoYisrLGg8PDJ8Zz4+NCk7NjQhPT1rJiYocC52aWV3LnNldFVpbnQ4KGIrKyxnPDw0JjI0MHxrPj4yLFxuYiksNjQhPT1sJiZwLnZpZXcuc2V0VWludDgoYisrLGs8PDYmMTkyfGwpKX1wLmxpbWl0PWI7cmV0dXJuIHB9O2QuYnRvYT1mdW5jdGlvbihhKXtyZXR1cm4gZC5mcm9tQmluYXJ5KGEpLnRvQmFzZTY0KCl9O2QuYXRvYj1mdW5jdGlvbihhKXtyZXR1cm4gZC5mcm9tQmFzZTY0KGEpLnRvQmluYXJ5KCl9O2QucHJvdG90eXBlLnRvQmluYXJ5PWZ1bmN0aW9uKGEsYil7YT1cInVuZGVmaW5lZFwiPT09dHlwZW9mIGE/dGhpcy5vZmZzZXQ6YTtiPVwidW5kZWZpbmVkXCI9PT10eXBlb2YgYj90aGlzLmxpbWl0OmI7aWYoIXRoaXMubm9Bc3NlcnQpe2lmKFwibnVtYmVyXCIhPT10eXBlb2YgYXx8MCE9PWElMSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBiZWdpbjogTm90IGFuIGludGVnZXJcIik7YT4+Pj0wO2lmKFwibnVtYmVyXCIhPT10eXBlb2YgYnx8MCE9PWIlMSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBlbmQ6IE5vdCBhbiBpbnRlZ2VyXCIpO2I+Pj49MDtpZigwPmF8fGE+Ynx8Yj50aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSWxsZWdhbCByYW5nZTogMCA8PSBcIitcbmErXCIgPD0gXCIrYitcIiA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTt9aWYoYT09PWIpcmV0dXJuXCJcIjtmb3IodmFyIGM9W107YTxiOyljLnB1c2godGhpcy52aWV3LmdldFVpbnQ4KGErKykpO3JldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZyxjKX07ZC5mcm9tQmluYXJ5PWZ1bmN0aW9uKGEsYixjKXtpZighYyYmXCJzdHJpbmdcIiE9PXR5cGVvZiBhKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIHN0cjogTm90IGEgc3RyaW5nXCIpO2Zvcih2YXIgZT0wLGg9YS5sZW5ndGgsZj1uZXcgZChoLGIsYyk7ZTxoOyl7Yj1hLmNoYXJDb2RlQXQoZSk7aWYoIWMmJjI1NTxiKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGNoYXJDb2RlIGF0IFwiK2UrXCI6IDAgPD0gXCIrYitcIiA8PSAyNTVcIik7Zi52aWV3LnNldFVpbnQ4KGUrKyxiKX1mLmxpbWl0PWg7cmV0dXJuIGZ9O2QucHJvdG90eXBlLnRvRGVidWc9ZnVuY3Rpb24oYSl7Zm9yKHZhciBiPS0xLGM9dGhpcy5idWZmZXIuYnl0ZUxlbmd0aCxcbmUsZD1cIlwiLGY9XCJcIixnPVwiXCI7YjxjOyl7LTEhPT1iJiYoZT10aGlzLnZpZXcuZ2V0VWludDgoYiksZD0xNj5lP2QrKFwiMFwiK2UudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkpOmQrZS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSxhJiYoZis9MzI8ZSYmMTI3PmU/U3RyaW5nLmZyb21DaGFyQ29kZShlKTpcIi5cIikpOysrYjtpZihhJiYwPGImJjA9PT1iJTE2JiZiIT09Yyl7Zm9yKDs1MT5kLmxlbmd0aDspZCs9XCIgXCI7Zys9ZCtmK1wiXFxuXCI7ZD1mPVwiXCJ9ZD1iPT09dGhpcy5vZmZzZXQmJmI9PT10aGlzLmxpbWl0P2QrKGI9PT10aGlzLm1hcmtlZE9mZnNldD9cIiFcIjpcInxcIik6Yj09PXRoaXMub2Zmc2V0P2QrKGI9PT10aGlzLm1hcmtlZE9mZnNldD9cIltcIjpcIjxcIik6Yj09PXRoaXMubGltaXQ/ZCsoYj09PXRoaXMubWFya2VkT2Zmc2V0P1wiXVwiOlwiPlwiKTpkKyhiPT09dGhpcy5tYXJrZWRPZmZzZXQ/XCInXCI6YXx8MCE9PWImJmIhPT1jP1wiIFwiOlwiXCIpfWlmKGEmJlwiIFwiIT09ZCl7Zm9yKDs1MT5kLmxlbmd0aDspZCs9XG5cIiBcIjtnKz1kK2YrXCJcXG5cIn1yZXR1cm4gYT9nOmR9O2QuZnJvbURlYnVnPWZ1bmN0aW9uKGEsYixjKXt2YXIgZT1hLmxlbmd0aDtiPW5ldyBkKChlKzEpLzN8MCxiLGMpO2Zvcih2YXIgaD0wLGY9MCxnLGs9ITEsbD0hMSxwPSExLG09ITEscT0hMTtoPGU7KXtzd2l0Y2goZz1hLmNoYXJBdChoKyspKXtjYXNlIFwiIVwiOmlmKCFjKXtpZihsfHxwfHxtKXtxPSEwO2JyZWFrfWw9cD1tPSEwfWIub2Zmc2V0PWIubWFya2VkT2Zmc2V0PWIubGltaXQ9ZjtrPSExO2JyZWFrO2Nhc2UgXCJ8XCI6aWYoIWMpe2lmKGx8fG0pe3E9ITA7YnJlYWt9bD1tPSEwfWIub2Zmc2V0PWIubGltaXQ9ZjtrPSExO2JyZWFrO2Nhc2UgXCJbXCI6aWYoIWMpe2lmKGx8fHApe3E9ITA7YnJlYWt9bD1wPSEwfWIub2Zmc2V0PWIubWFya2VkT2Zmc2V0PWY7az0hMTticmVhaztjYXNlIFwiPFwiOmlmKCFjKXtpZihsKXtxPSEwO2JyZWFrfWw9ITB9Yi5vZmZzZXQ9ZjtrPSExO2JyZWFrO2Nhc2UgXCJdXCI6aWYoIWMpe2lmKG18fHApe3E9XG4hMDticmVha31tPXA9ITB9Yi5saW1pdD1iLm1hcmtlZE9mZnNldD1mO2s9ITE7YnJlYWs7Y2FzZSBcIj5cIjppZighYyl7aWYobSl7cT0hMDticmVha31tPSEwfWIubGltaXQ9ZjtrPSExO2JyZWFrO2Nhc2UgXCInXCI6aWYoIWMpe2lmKHApe3E9ITA7YnJlYWt9cD0hMH1iLm1hcmtlZE9mZnNldD1mO2s9ITE7YnJlYWs7Y2FzZSBcIiBcIjprPSExO2JyZWFrO2RlZmF1bHQ6aWYoIWMmJmspe3E9ITA7YnJlYWt9Zz1wYXJzZUludChnK2EuY2hhckF0KGgrKyksMTYpO2lmKCFjJiYoaXNOYU4oZyl8fDA+Z3x8MjU1PGcpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIHN0cjogTm90IGEgZGVidWcgZW5jb2RlZCBzdHJpbmdcIik7Yi52aWV3LnNldFVpbnQ4KGYrKyxnKTtrPSEwfWlmKHEpdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgc3RyOiBJbnZhbGlkIHN5bWJvbCBhdCBcIitoKTt9aWYoIWMpe2lmKCFsfHwhbSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBzdHI6IE1pc3Npbmcgb2Zmc2V0IG9yIGxpbWl0XCIpO1xuaWYoZjxiLmJ1ZmZlci5ieXRlTGVuZ3RoKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIHN0cjogTm90IGEgZGVidWcgZW5jb2RlZCBzdHJpbmcgKGlzIGl0IGhleD8pIFwiK2YrXCIgPCBcIitlKTt9cmV0dXJuIGJ9O2QucHJvdG90eXBlLnRvSGV4PWZ1bmN0aW9uKGEsYil7YT1cInVuZGVmaW5lZFwiPT09dHlwZW9mIGE/dGhpcy5vZmZzZXQ6YTtiPVwidW5kZWZpbmVkXCI9PT10eXBlb2YgYj90aGlzLmxpbWl0OmI7aWYoIXRoaXMubm9Bc3NlcnQpe2lmKFwibnVtYmVyXCIhPT10eXBlb2YgYXx8MCE9PWElMSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBiZWdpbjogTm90IGFuIGludGVnZXJcIik7YT4+Pj0wO2lmKFwibnVtYmVyXCIhPT10eXBlb2YgYnx8MCE9PWIlMSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBlbmQ6IE5vdCBhbiBpbnRlZ2VyXCIpO2I+Pj49MDtpZigwPmF8fGE+Ynx8Yj50aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSWxsZWdhbCByYW5nZTogMCA8PSBcIitcbmErXCIgPD0gXCIrYitcIiA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTt9Zm9yKHZhciBjPUFycmF5KGItYSksZTthPGI7KWU9dGhpcy52aWV3LmdldFVpbnQ4KGErKyksMTY+ZT9jLnB1c2goXCIwXCIsZS50b1N0cmluZygxNikpOmMucHVzaChlLnRvU3RyaW5nKDE2KSk7cmV0dXJuIGMuam9pbihcIlwiKX07ZC5mcm9tSGV4PWZ1bmN0aW9uKGEsYixjKXtpZighYyl7aWYoXCJzdHJpbmdcIiE9PXR5cGVvZiBhKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIHN0cjogTm90IGEgc3RyaW5nXCIpO2lmKDAhPT1hLmxlbmd0aCUyKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIHN0cjogTGVuZ3RoIG5vdCBhIG11bHRpcGxlIG9mIDJcIik7fXZhciBlPWEubGVuZ3RoO2I9bmV3IGQoZS8yfDAsYik7Zm9yKHZhciBoLGY9MCxnPTA7ZjxlO2YrPTIpe2g9cGFyc2VJbnQoYS5zdWJzdHJpbmcoZixmKzIpLDE2KTtpZighYyYmKCFpc0Zpbml0ZShoKXx8MD5ofHwyNTU8aCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgc3RyOiBDb250YWlucyBub24taGV4IGNoYXJhY3RlcnNcIik7XG5iLnZpZXcuc2V0VWludDgoZysrLGgpfWIubGltaXQ9ZztyZXR1cm4gYn07dmFyIGs9ZnVuY3Rpb24oKXt2YXIgYT17ajpmdW5jdGlvbihhLGMpe3ZhciBlPW51bGw7XCJudW1iZXJcIj09PXR5cGVvZiBhJiYoZT1hLGE9ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbH0pO2Zvcig7bnVsbCE9PWV8fG51bGwhPT0oZT1hKCkpOykxMjg+ZT9jKGUmMTI3KTooMjA0OD5lP2MoZT4+NiYzMXwxOTIpOig2NTUzNj5lP2MoZT4+MTImMTV8MjI0KTooYyhlPj4xOCY3fDI0MCksYyhlPj4xMiY2M3wxMjgpKSxjKGU+PjYmNjN8MTI4KSksYyhlJjYzfDEyOCkpLGU9bnVsbH0saTpmdW5jdGlvbihhLGMpe2Z1bmN0aW9uIGUoYSl7YT1hLnNsaWNlKDAsYS5pbmRleE9mKG51bGwpKTt2YXIgYj1FcnJvcihhLnRvU3RyaW5nKCkpO2IubmFtZT1cIlRydW5jYXRlZEVycm9yXCI7Yi5ieXRlcz1hO3Rocm93IGI7fWZvcih2YXIgZCxmLGcsaztudWxsIT09KGQ9YSgpKTspaWYoMD09PShkJjEyOCkpYyhkKTtlbHNlIGlmKDE5Mj09PVxuKGQmMjI0KSludWxsPT09KGY9YSgpKSYmZShbZCxmXSksYygoZCYzMSk8PDZ8ZiY2Myk7ZWxzZSBpZigyMjQ9PT0oZCYyNDApKW51bGwhPT0oZj1hKCkpJiZudWxsIT09KGc9YSgpKXx8ZShbZCxmLGddKSxjKChkJjE1KTw8MTJ8KGYmNjMpPDw2fGcmNjMpO2Vsc2UgaWYoMjQwPT09KGQmMjQ4KSludWxsIT09KGY9YSgpKSYmbnVsbCE9PShnPWEoKSkmJm51bGwhPT0oaz1hKCkpfHxlKFtkLGYsZyxrXSksYygoZCY3KTw8MTh8KGYmNjMpPDwxMnwoZyY2Myk8PDZ8ayY2Myk7ZWxzZSB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBzdGFydGluZyBieXRlOiBcIitkKTt9LGY6ZnVuY3Rpb24oYSxjKXtmb3IodmFyIGUsZD1udWxsO251bGwhPT0oZT1udWxsIT09ZD9kOmEoKSk7KTU1Mjk2PD1lJiY1NzM0Mz49ZSYmbnVsbCE9PShkPWEoKSkmJjU2MzIwPD1kJiY1NzM0Mz49ZD8oYygxMDI0KihlLTU1Mjk2KStkLTU2MzIwKzY1NTM2KSxkPW51bGwpOmMoZSk7bnVsbCE9PWQmJmMoZCl9LGc6ZnVuY3Rpb24oYSxcbmMpe3ZhciBlPW51bGw7XCJudW1iZXJcIj09PXR5cGVvZiBhJiYoZT1hLGE9ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbH0pO2Zvcig7bnVsbCE9PWV8fG51bGwhPT0oZT1hKCkpOyk2NTUzNT49ZT9jKGUpOihlLT02NTUzNixjKChlPj4xMCkrNTUyOTYpLGMoZSUxMDI0KzU2MzIwKSksZT1udWxsfSxlOmZ1bmN0aW9uKGIsYyl7YS5mKGIsZnVuY3Rpb24oYil7YS5qKGIsYyl9KX0sZDpmdW5jdGlvbihiLGMpe2EuaShiLGZ1bmN0aW9uKGIpe2EuZyhiLGMpfSl9LGs6ZnVuY3Rpb24oYSl7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBhfHxhIT09YSl0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGJ5dGU6IFwiK3R5cGVvZiBhKTtpZigtMTI4PmF8fDI1NTxhKXRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIGJ5dGU6IFwiK2EpO3JldHVybiBhfSxsOmZ1bmN0aW9uKGEpe2lmKFwibnVtYmVyXCIhPT10eXBlb2YgYXx8YSE9PWEpdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBjaGFyIGNvZGU6IFwiK3R5cGVvZiBhKTtpZigwPlxuYXx8NjU1MzU8YSl0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBjaGFyIGNvZGU6IFwiK2EpO3JldHVybiBhfSxtOmZ1bmN0aW9uKGEpe2lmKFwibnVtYmVyXCIhPT10eXBlb2YgYXx8YSE9PWEpdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBjb2RlIHBvaW50OiBcIit0eXBlb2YgYSk7aWYoMD5hfHwxMTE0MTExPGEpdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgY29kZSBwb2ludDogXCIrYSk7cmV0dXJuIGF9LGg6ZnVuY3Rpb24oYSl7cmV0dXJuIDEyOD5hPzE6MjA0OD5hPzI6NjU1MzY+YT8zOjR9LG46ZnVuY3Rpb24oYil7Zm9yKHZhciBjLGQ9MDtudWxsIT09KGM9YigpKTspZCs9YS5oKGMpO3JldHVybiBkfSxiOmZ1bmN0aW9uKGIpe3ZhciBjPTAsZD0wO2EuZihiLGZ1bmN0aW9uKGIpeysrYztkKz1hLmgoYil9KTtyZXR1cm5bYyxkXX19O3JldHVybiBhfSgpLHM9U3RyaW5nLmZyb21DaGFyQ29kZTtrLmE9ZnVuY3Rpb24oYSl7dmFyIGI9MDtyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gYjxcbmEubGVuZ3RoP2EuY2hhckNvZGVBdChiKyspOm51bGx9fTtrLmM9ZnVuY3Rpb24oKXt2YXIgYT1bXSxiPVtdO3JldHVybiBmdW5jdGlvbigpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiBiLmpvaW4oXCJcIikrcy5hcHBseShTdHJpbmcsYSk7MTAyNDxhLmxlbmd0aCthcmd1bWVudHMubGVuZ3RoJiYoYi5wdXNoKHMuYXBwbHkoU3RyaW5nLGEpKSxhLmxlbmd0aD0wKTtBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShhLGFyZ3VtZW50cyl9fTtkLnByb3RvdHlwZS50b1VURjg9ZnVuY3Rpb24oYSxiKXtcInVuZGVmaW5lZFwiPT09dHlwZW9mIGEmJihhPXRoaXMub2Zmc2V0KTtcInVuZGVmaW5lZFwiPT09dHlwZW9mIGImJihiPXRoaXMubGltaXQpO2lmKCF0aGlzLm5vQXNzZXJ0KXtpZihcIm51bWJlclwiIT09dHlwZW9mIGF8fDAhPT1hJTEpdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgYmVnaW46IE5vdCBhbiBpbnRlZ2VyXCIpO2E+Pj49MDtpZihcIm51bWJlclwiIT09dHlwZW9mIGJ8fFxuMCE9PWIlMSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBlbmQ6IE5vdCBhbiBpbnRlZ2VyXCIpO2I+Pj49MDtpZigwPmF8fGE+Ynx8Yj50aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSWxsZWdhbCByYW5nZTogMCA8PSBcIithK1wiIDw9IFwiK2IrXCIgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7fXZhciBjPXRoaXMsZDt0cnl7ay5kKGZ1bmN0aW9uKCl7cmV0dXJuIGE8Yj9jLnZpZXcuZ2V0VWludDgoYSsrKTpudWxsfSxkPWsuYygpKX1jYXRjaChoKXtpZihhIT09Yil0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIklsbGVnYWwgcmFuZ2U6IFRydW5jYXRlZCBkYXRhLCBcIithK1wiICE9IFwiK2IpO31yZXR1cm4gZCgpfTtkLmZyb21VVEY4PWZ1bmN0aW9uKGEsYixjKXtpZighYyYmXCJzdHJpbmdcIiE9PXR5cGVvZiBhKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIHN0cjogTm90IGEgc3RyaW5nXCIpO3ZhciBlPW5ldyBkKGsuYihrLmEoYSksITApWzFdLFxuYixjKSxoPTA7ay5lKGsuYShhKSxmdW5jdGlvbihhKXtlLnZpZXcuc2V0VWludDgoaCsrLGEpfSk7ZS5saW1pdD1oO3JldHVybiBlfTtyZXR1cm4gZH1cInVuZGVmaW5lZFwiIT10eXBlb2YgbW9kdWxlJiZtb2R1bGUuZXhwb3J0cz9tb2R1bGUuZXhwb3J0cz1zKHJlcXVpcmUoXCJsb25nXCIpKTpcInVuZGVmaW5lZFwiIT09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoXCJCeXRlQnVmZmVyXCIsW1wiTWF0aC9Mb25nXCJdLGZ1bmN0aW9uKGwpe3JldHVybiBzKGwpfSk6KHIuZGNvZGVJT3x8KHIuZGNvZGVJTz17fSksci5kY29kZUlPLkJ5dGVCdWZmZXI9cyhyLmRjb2RlSU8uTG9uZykpfSkodGhpcyk7XG4iLCIvKlxyXG4gQ29weXJpZ2h0IDIwMTMgRGFuaWVsIFdpcnR6IDxkY29kZUBkY29kZS5pbz5cclxuIENvcHlyaWdodCAyMDA5IFRoZSBDbG9zdXJlIExpYnJhcnkgQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cclxuXHJcbiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcblxyXG4gaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcblxyXG4gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUy1JU1wiIEJBU0lTLFxyXG4gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBAbGljZW5zZSBMb25nLmpzIChjKSAyMDEzIERhbmllbCBXaXJ0eiA8ZGNvZGVAZGNvZGUuaW8+XHJcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjBcclxuICogRGVyaXZlZCBmcm9tIGdvb2cubWF0aC5Mb25nIGZyb20gdGhlIENsb3N1cmUgTGlicmFyeVxyXG4gKiBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9kY29kZUlPL0xvbmcuanMgZm9yIGRldGFpbHNcclxuICovXHJcbihmdW5jdGlvbihnbG9iYWwpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29uc3RydWN0cyBhIDY0LWJpdCB0d28ncy1jb21wbGVtZW50IGludGVnZXIsIGdpdmVuIGl0cyBsb3cgYW5kIGhpZ2ggMzItYml0XHJcbiAgICAgKiB2YWx1ZXMgYXMgKnNpZ25lZCogaW50ZWdlcnMuICBTZWUgdGhlIGZyb20qIGZ1bmN0aW9ucyBiZWxvdyBmb3IgbW9yZVxyXG4gICAgICogY29udmVuaWVudCB3YXlzIG9mIGNvbnN0cnVjdGluZyBMb25ncy5cclxuICAgICAqXHJcbiAgICAgKiBUaGUgaW50ZXJuYWwgcmVwcmVzZW50YXRpb24gb2YgYSBsb25nIGlzIHRoZSB0d28gZ2l2ZW4gc2lnbmVkLCAzMi1iaXQgdmFsdWVzLlxyXG4gICAgICogV2UgdXNlIDMyLWJpdCBwaWVjZXMgYmVjYXVzZSB0aGVzZSBhcmUgdGhlIHNpemUgb2YgaW50ZWdlcnMgb24gd2hpY2hcclxuICAgICAqIEphdmFzY3JpcHQgcGVyZm9ybXMgYml0LW9wZXJhdGlvbnMuICBGb3Igb3BlcmF0aW9ucyBsaWtlIGFkZGl0aW9uIGFuZFxyXG4gICAgICogbXVsdGlwbGljYXRpb24sIHdlIHNwbGl0IGVhY2ggbnVtYmVyIGludG8gMTYtYml0IHBpZWNlcywgd2hpY2ggY2FuIGVhc2lseSBiZVxyXG4gICAgICogbXVsdGlwbGllZCB3aXRoaW4gSmF2YXNjcmlwdCdzIGZsb2F0aW5nLXBvaW50IHJlcHJlc2VudGF0aW9uIHdpdGhvdXQgb3ZlcmZsb3dcclxuICAgICAqIG9yIGNoYW5nZSBpbiBzaWduLlxyXG4gICAgICpcclxuICAgICAqIEluIHRoZSBhbGdvcml0aG1zIGJlbG93LCB3ZSBmcmVxdWVudGx5IHJlZHVjZSB0aGUgbmVnYXRpdmUgY2FzZSB0byB0aGVcclxuICAgICAqIHBvc2l0aXZlIGNhc2UgYnkgbmVnYXRpbmcgdGhlIGlucHV0KHMpIGFuZCB0aGVuIHBvc3QtcHJvY2Vzc2luZyB0aGUgcmVzdWx0LlxyXG4gICAgICogTm90ZSB0aGF0IHdlIG11c3QgQUxXQVlTIGNoZWNrIHNwZWNpYWxseSB3aGV0aGVyIHRob3NlIHZhbHVlcyBhcmUgTUlOX1ZBTFVFXHJcbiAgICAgKiAoLTJeNjMpIGJlY2F1c2UgLU1JTl9WQUxVRSA9PSBNSU5fVkFMVUUgKHNpbmNlIDJeNjMgY2Fubm90IGJlIHJlcHJlc2VudGVkIGFzXHJcbiAgICAgKiBhIHBvc2l0aXZlIG51bWJlciwgaXQgb3ZlcmZsb3dzIGJhY2sgaW50byBhIG5lZ2F0aXZlKS4gIE5vdCBoYW5kbGluZyB0aGlzXHJcbiAgICAgKiBjYXNlIHdvdWxkIG9mdGVuIHJlc3VsdCBpbiBpbmZpbml0ZSByZWN1cnNpb24uXHJcbiAgICAgKiBcclxuICAgICAqIEBleHBvcnRzIExvbmdcclxuICAgICAqIEBjbGFzcyBBIExvbmcgY2xhc3MgZm9yIHJlcHJlc2VudGluZyBhIDY0LWJpdCB0d28ncy1jb21wbGVtZW50IGludGVnZXIgdmFsdWUuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcnwhe2xvdzogbnVtYmVyLCBoaWdoOiBudW1iZXIsIHVuc2lnbmVkOiBib29sZWFufX0gbG93IFRoZSBsb3cgKHNpZ25lZCkgMzIgYml0cyBvZiB0aGUgbG9uZy5cclxuICAgICAqICBPcHRpb25hbGx5IGFjY2VwdHMgYSBMb25nLWxpa2Ugb2JqZWN0IGFzIHRoZSBmaXJzdCBwYXJhbWV0ZXIuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IGhpZ2ggVGhlIGhpZ2ggKHNpZ25lZCkgMzIgYml0cyBvZiB0aGUgbG9uZy5cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LiBEZWZhdWx0cyB0byBgZmFsc2VgIChzaWduZWQpLlxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKi9cclxuICAgIHZhciBMb25nID0gZnVuY3Rpb24obG93LCBoaWdoLCB1bnNpZ25lZCkge1xyXG4gICAgICAgIGlmIChsb3cgJiYgdHlwZW9mIGxvdyA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgaGlnaCA9IGxvdy5oaWdoO1xyXG4gICAgICAgICAgICB1bnNpZ25lZCA9IGxvdy51bnNpZ25lZDtcclxuICAgICAgICAgICAgbG93ID0gbG93LmxvdztcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGxvdyAzMiBiaXRzIGFzIGEgc2lnbmVkIHZhbHVlLlxyXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMubG93ID0gbG93IHwgMDtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGhpZ2ggMzIgYml0cyBhcyBhIHNpZ25lZCB2YWx1ZS5cclxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmhpZ2ggPSBoaWdoIHwgMDtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogV2hldGhlciB1bnNpZ25lZCBvciBub3QuXHJcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMudW5zaWduZWQgPSAhIXVuc2lnbmVkO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBOT1RFOiBDb21tb24gY29uc3RhbnQgdmFsdWVzIFpFUk8sIE9ORSwgTkVHX09ORSwgZXRjLiBhcmUgZGVmaW5lZCBiZWxvdyB0aGUgZnJvbSogbWV0aG9kcyBvbiB3aGljaCB0aGV5IGRlcGVuZC5cclxuXHJcbiAgICAvLyBOT1RFOiBUaGUgZm9sbG93aW5nIGNhY2hlIHZhcmlhYmxlcyBhcmUgdXNlZCBpbnRlcm5hbGx5IG9ubHkgYW5kIGFyZSB0aGVyZWZvcmUgbm90IGV4cG9zZWQgYXMgcHJvcGVydGllcyBvZiB0aGVcclxuICAgIC8vIExvbmcgY2xhc3MuXHJcbiAgICBcclxuICAgIC8qKlxyXG4gICAgICogQSBjYWNoZSBvZiB0aGUgTG9uZyByZXByZXNlbnRhdGlvbnMgb2Ygc21hbGwgaW50ZWdlciB2YWx1ZXMuXHJcbiAgICAgKiBAdHlwZSB7IU9iamVjdH1cclxuICAgICAqL1xyXG4gICAgdmFyIElOVF9DQUNIRSA9IHt9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSBjYWNoZSBvZiB0aGUgTG9uZyByZXByZXNlbnRhdGlvbnMgb2Ygc21hbGwgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuXHJcbiAgICAgKiBAdHlwZSB7IU9iamVjdH1cclxuICAgICAqL1xyXG4gICAgdmFyIFVJTlRfQ0FDSEUgPSB7fTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBMb25nIHJlcHJlc2VudGluZyB0aGUgZ2l2ZW4gKDMyLWJpdCkgaW50ZWdlciB2YWx1ZS5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBUaGUgMzItYml0IGludGVnZXIgaW4gcXVlc3Rpb24uXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdC4gRGVmYXVsdHMgdG8gZmFsc2UgKHNpZ25lZCkuXHJcbiAgICAgKiBAcmV0dXJuIHshTG9uZ30gVGhlIGNvcnJlc3BvbmRpbmcgTG9uZyB2YWx1ZS5cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgTG9uZy5mcm9tSW50ID0gZnVuY3Rpb24odmFsdWUsIHVuc2lnbmVkKSB7XHJcbiAgICAgICAgdmFyIG9iaiwgY2FjaGVkT2JqO1xyXG4gICAgICAgIGlmICghdW5zaWduZWQpIHtcclxuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSB8IDA7XHJcbiAgICAgICAgICAgIGlmICgtMTI4IDw9IHZhbHVlICYmIHZhbHVlIDwgMTI4KSB7XHJcbiAgICAgICAgICAgICAgICBjYWNoZWRPYmogPSBJTlRfQ0FDSEVbdmFsdWVdO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlZE9iaikgcmV0dXJuIGNhY2hlZE9iajtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvYmogPSBuZXcgTG9uZyh2YWx1ZSwgdmFsdWUgPCAwID8gLTEgOiAwLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIGlmICgtMTI4IDw9IHZhbHVlICYmIHZhbHVlIDwgMTI4KSB7XHJcbiAgICAgICAgICAgICAgICBJTlRfQ0FDSEVbdmFsdWVdID0gb2JqO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBvYmo7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSA+Pj4gMDtcclxuICAgICAgICAgICAgaWYgKDAgPD0gdmFsdWUgJiYgdmFsdWUgPCAyNTYpIHtcclxuICAgICAgICAgICAgICAgIGNhY2hlZE9iaiA9IFVJTlRfQ0FDSEVbdmFsdWVdO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlZE9iaikgcmV0dXJuIGNhY2hlZE9iajtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvYmogPSBuZXcgTG9uZyh2YWx1ZSwgKHZhbHVlIHwgMCkgPCAwID8gLTEgOiAwLCB0cnVlKTtcclxuICAgICAgICAgICAgaWYgKDAgPD0gdmFsdWUgJiYgdmFsdWUgPCAyNTYpIHtcclxuICAgICAgICAgICAgICAgIFVJTlRfQ0FDSEVbdmFsdWVdID0gb2JqO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBvYmo7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBMb25nIHJlcHJlc2VudGluZyB0aGUgZ2l2ZW4gdmFsdWUsIHByb3ZpZGVkIHRoYXQgaXQgaXMgYSBmaW5pdGVcclxuICAgICAqIG51bWJlci4gIE90aGVyd2lzZSwgemVybyBpcyByZXR1cm5lZC5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBUaGUgbnVtYmVyIGluIHF1ZXN0aW9uLlxyXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QuIERlZmF1bHRzIHRvIGZhbHNlIChzaWduZWQpLlxyXG4gICAgICogQHJldHVybiB7IUxvbmd9IFRoZSBjb3JyZXNwb25kaW5nIExvbmcgdmFsdWUuXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIExvbmcuZnJvbU51bWJlciA9IGZ1bmN0aW9uKHZhbHVlLCB1bnNpZ25lZCkge1xyXG4gICAgICAgIHVuc2lnbmVkID0gISF1bnNpZ25lZDtcclxuICAgICAgICBpZiAoaXNOYU4odmFsdWUpIHx8ICFpc0Zpbml0ZSh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIExvbmcuWkVSTztcclxuICAgICAgICB9IGVsc2UgaWYgKCF1bnNpZ25lZCAmJiB2YWx1ZSA8PSAtVFdPX1BXUl82M19EQkwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIExvbmcuTUlOX1NJR05FRF9WQUxVRTtcclxuICAgICAgICB9IGVsc2UgaWYgKHVuc2lnbmVkICYmIHZhbHVlIDw9IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIExvbmcuTUlOX1VOU0lHTkVEX1ZBTFVFO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoIXVuc2lnbmVkICYmIHZhbHVlICsgMSA+PSBUV09fUFdSXzYzX0RCTCkge1xyXG4gICAgICAgICAgICByZXR1cm4gTG9uZy5NQVhfU0lHTkVEX1ZBTFVFO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodW5zaWduZWQgJiYgdmFsdWUgPj0gVFdPX1BXUl82NF9EQkwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIExvbmcuTUFYX1VOU0lHTkVEX1ZBTFVFO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPCAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBMb25nLmZyb21OdW1iZXIoLXZhbHVlLCBmYWxzZSkubmVnYXRlKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBMb25nKCh2YWx1ZSAlIFRXT19QV1JfMzJfREJMKSB8IDAsICh2YWx1ZSAvIFRXT19QV1JfMzJfREJMKSB8IDAsIHVuc2lnbmVkKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIExvbmcgcmVwcmVzZW50aW5nIHRoZSA2NGJpdCBpbnRlZ2VyIHRoYXQgY29tZXMgYnkgY29uY2F0ZW5hdGluZyB0aGUgZ2l2ZW4gbG93IGFuZCBoaWdoIGJpdHMuIEVhY2ggaXNcclxuICAgICAqICBhc3N1bWVkIHRvIHVzZSAzMiBiaXRzLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxvd0JpdHMgVGhlIGxvdyAzMiBiaXRzLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGhpZ2hCaXRzIFRoZSBoaWdoIDMyIGJpdHMuXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdC4gRGVmYXVsdHMgdG8gZmFsc2UgKHNpZ25lZCkuXHJcbiAgICAgKiBAcmV0dXJuIHshTG9uZ30gVGhlIGNvcnJlc3BvbmRpbmcgTG9uZyB2YWx1ZS5cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgTG9uZy5mcm9tQml0cyA9IGZ1bmN0aW9uKGxvd0JpdHMsIGhpZ2hCaXRzLCB1bnNpZ25lZCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgTG9uZyhsb3dCaXRzLCBoaWdoQml0cywgdW5zaWduZWQpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBMb25nIHJlcHJlc2VudGluZyB0aGUgNjRiaXQgaW50ZWdlciB0aGF0IGNvbWVzIGJ5IGNvbmNhdGVuYXRpbmcgdGhlIGdpdmVuIGxvdywgbWlkZGxlIGFuZCBoaWdoIGJpdHMuXHJcbiAgICAgKiAgRWFjaCBpcyBhc3N1bWVkIHRvIHVzZSAyOCBiaXRzLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBhcnQwIFRoZSBsb3cgMjggYml0c1xyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBhcnQxIFRoZSBtaWRkbGUgMjggYml0c1xyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBhcnQyIFRoZSBoaWdoIDI4ICg4KSBiaXRzXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdC4gRGVmYXVsdHMgdG8gZmFsc2UgKHNpZ25lZCkuXHJcbiAgICAgKiBAcmV0dXJuIHshTG9uZ31cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgTG9uZy5mcm9tMjhCaXRzID0gZnVuY3Rpb24ocGFydDAsIHBhcnQxLCBwYXJ0MiwgdW5zaWduZWQpIHtcclxuICAgICAgICAvLyAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTExMSAxMTExMTExMTExMTExMTExMTExMTExMTEyMjIyMjIyMiAyMjIyMjIyMjIyMjIyXHJcbiAgICAgICAgLy8gTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTEwgSEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhcclxuICAgICAgICByZXR1cm4gTG9uZy5mcm9tQml0cyhwYXJ0MCB8IChwYXJ0MSA8PCAyOCksIChwYXJ0MSA+Pj4gNCkgfCAocGFydDIpIDw8IDI0LCB1bnNpZ25lZCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIExvbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIHN0cmluZywgd3JpdHRlbiB1c2luZyB0aGUgZ2l2ZW5cclxuICAgICAqIHJhZGl4LlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciBUaGUgdGV4dHVhbCByZXByZXNlbnRhdGlvbiBvZiB0aGUgTG9uZy5cclxuICAgICAqIEBwYXJhbSB7KGJvb2xlYW58bnVtYmVyKT19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LiBEZWZhdWx0cyB0byBmYWxzZSAoc2lnbmVkKS5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gcmFkaXggVGhlIHJhZGl4IGluIHdoaWNoIHRoZSB0ZXh0IGlzIHdyaXR0ZW4uXHJcbiAgICAgKiBAcmV0dXJuIHshTG9uZ30gVGhlIGNvcnJlc3BvbmRpbmcgTG9uZyB2YWx1ZS5cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgTG9uZy5mcm9tU3RyaW5nID0gZnVuY3Rpb24oc3RyLCB1bnNpZ25lZCwgcmFkaXgpIHtcclxuICAgICAgICBpZiAoc3RyLmxlbmd0aCA9PSAwKSB7XHJcbiAgICAgICAgICAgIHRocm93KG5ldyBFcnJvcignbnVtYmVyIGZvcm1hdCBlcnJvcjogZW1wdHkgc3RyaW5nJykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc3RyID09PSBcIk5hTlwiIHx8IHN0ciA9PT0gXCJJbmZpbml0eVwiIHx8IHN0ciA9PT0gXCIrSW5maW5pdHlcIiB8fCBzdHIgPT09IFwiLUluZmluaXR5XCIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIExvbmcuWkVSTztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiB1bnNpZ25lZCA9PT0gJ251bWJlcicpIHsgLy8gRm9yIGdvb2cubWF0aC5Mb25nIGNvbXBhdGliaWxpdHlcclxuICAgICAgICAgICAgcmFkaXggPSB1bnNpZ25lZDtcclxuICAgICAgICAgICAgdW5zaWduZWQgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmFkaXggPSByYWRpeCB8fCAxMDtcclxuICAgICAgICBpZiAocmFkaXggPCAyIHx8IDM2IDwgcmFkaXgpIHtcclxuICAgICAgICAgICAgdGhyb3cobmV3IEVycm9yKCdyYWRpeCBvdXQgb2YgcmFuZ2U6ICcgKyByYWRpeCkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHN0ci5jaGFyQXQoMCkgPT0gJy0nKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBMb25nLmZyb21TdHJpbmcoc3RyLnN1YnN0cmluZygxKSwgdW5zaWduZWQsIHJhZGl4KS5uZWdhdGUoKTtcclxuICAgICAgICB9IGVsc2UgaWYgKHN0ci5pbmRleE9mKCctJykgPj0gMCkge1xyXG4gICAgICAgICAgICB0aHJvdyhuZXcgRXJyb3IoJ251bWJlciBmb3JtYXQgZXJyb3I6IGludGVyaW9yIFwiLVwiIGNoYXJhY3RlcjogJyArIHN0cikpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRG8gc2V2ZXJhbCAoOCkgZGlnaXRzIGVhY2ggdGltZSB0aHJvdWdoIHRoZSBsb29wLCBzbyBhcyB0b1xyXG4gICAgICAgIC8vIG1pbmltaXplIHRoZSBjYWxscyB0byB0aGUgdmVyeSBleHBlbnNpdmUgZW11bGF0ZWQgZGl2LlxyXG4gICAgICAgIHZhciByYWRpeFRvUG93ZXIgPSBMb25nLmZyb21OdW1iZXIoTWF0aC5wb3cocmFkaXgsIDgpKTtcclxuXHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IExvbmcuWkVSTztcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkgKz0gOCkge1xyXG4gICAgICAgICAgICB2YXIgc2l6ZSA9IE1hdGgubWluKDgsIHN0ci5sZW5ndGggLSBpKTtcclxuICAgICAgICAgICAgdmFyIHZhbHVlID0gcGFyc2VJbnQoc3RyLnN1YnN0cmluZyhpLCBpICsgc2l6ZSksIHJhZGl4KTtcclxuICAgICAgICAgICAgaWYgKHNpemUgPCA4KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcG93ZXIgPSBMb25nLmZyb21OdW1iZXIoTWF0aC5wb3cocmFkaXgsIHNpemUpKTtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5tdWx0aXBseShwb3dlcikuYWRkKExvbmcuZnJvbU51bWJlcih2YWx1ZSkpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0Lm11bHRpcGx5KHJhZGl4VG9Qb3dlcik7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuYWRkKExvbmcuZnJvbU51bWJlcih2YWx1ZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlc3VsdC51bnNpZ25lZCA9IHVuc2lnbmVkO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIE5PVEU6IHRoZSBjb21waWxlciBzaG91bGQgaW5saW5lIHRoZXNlIGNvbnN0YW50IHZhbHVlcyBiZWxvdyBhbmQgdGhlbiByZW1vdmUgdGhlc2UgdmFyaWFibGVzLCBzbyB0aGVyZSBzaG91bGQgYmVcclxuICAgIC8vIG5vIHJ1bnRpbWUgcGVuYWx0eSBmb3IgdGhlc2UuXHJcbiAgICBcclxuICAgIC8vIE5PVEU6IFRoZSBmb2xsb3dpbmcgY29uc3RhbnQgdmFsdWVzIGFyZSB1c2VkIGludGVybmFsbHkgb25seSBhbmQgYXJlIHRoZXJlZm9yZSBub3QgZXhwb3NlZCBhcyBwcm9wZXJ0aWVzIG9mIHRoZVxyXG4gICAgLy8gTG9uZyBjbGFzcy5cclxuXHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHZhciBUV09fUFdSXzE2X0RCTCA9IDEgPDwgMTY7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB2YXIgVFdPX1BXUl8yNF9EQkwgPSAxIDw8IDI0O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgdmFyIFRXT19QV1JfMzJfREJMID0gVFdPX1BXUl8xNl9EQkwgKiBUV09fUFdSXzE2X0RCTDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHZhciBUV09fUFdSXzMxX0RCTCA9IFRXT19QV1JfMzJfREJMIC8gMjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHZhciBUV09fUFdSXzQ4X0RCTCA9IFRXT19QV1JfMzJfREJMICogVFdPX1BXUl8xNl9EQkw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB2YXIgVFdPX1BXUl82NF9EQkwgPSBUV09fUFdSXzMyX0RCTCAqIFRXT19QV1JfMzJfREJMO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgdmFyIFRXT19QV1JfNjNfREJMID0gVFdPX1BXUl82NF9EQkwgLyAyO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUgeyFMb25nfVxyXG4gICAgICovXHJcbiAgICB2YXIgVFdPX1BXUl8yNCA9IExvbmcuZnJvbUludCgxIDw8IDI0KTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHshTG9uZ31cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgTG9uZy5aRVJPID0gTG9uZy5mcm9tSW50KDApO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUgeyFMb25nfVxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBMb25nLlVaRVJPID0gTG9uZy5mcm9tSW50KDAsIHRydWUpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUgeyFMb25nfVxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBMb25nLk9ORSA9IExvbmcuZnJvbUludCgxKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHshTG9uZ31cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgTG9uZy5VT05FID0gTG9uZy5mcm9tSW50KDEsIHRydWUpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUgeyFMb25nfVxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBMb25nLk5FR19PTkUgPSBMb25nLmZyb21JbnQoLTEpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUgeyFMb25nfVxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBMb25nLk1BWF9TSUdORURfVkFMVUUgPSBMb25nLmZyb21CaXRzKDB4RkZGRkZGRkYgfCAwLCAweDdGRkZGRkZGIHwgMCwgZmFsc2UpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUgeyFMb25nfVxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBMb25nLk1BWF9VTlNJR05FRF9WQUxVRSA9IExvbmcuZnJvbUJpdHMoMHhGRkZGRkZGRiB8IDAsIDB4RkZGRkZGRkYgfCAwLCB0cnVlKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFsaWFzIG9mIHtAbGluayBMb25nLk1BWF9TSUdORURfVkFMVUV9IGZvciBnb29nLm1hdGguTG9uZyBjb21wYXRpYmlsaXR5LlxyXG4gICAgICogQHR5cGUgeyFMb25nfVxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBMb25nLk1BWF9WQUxVRSA9IExvbmcuTUFYX1NJR05FRF9WQUxVRTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHshTG9uZ31cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgTG9uZy5NSU5fU0lHTkVEX1ZBTFVFID0gTG9uZy5mcm9tQml0cygwLCAweDgwMDAwMDAwIHwgMCwgZmFsc2UpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUgeyFMb25nfVxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBMb25nLk1JTl9VTlNJR05FRF9WQUxVRSA9IExvbmcuZnJvbUJpdHMoMCwgMCwgdHJ1ZSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBbGlhcyBvZiB7QGxpbmsgTG9uZy5NSU5fU0lHTkVEX1ZBTFVFfSAgZm9yIGdvb2cubWF0aC5Mb25nIGNvbXBhdGliaWxpdHkuXHJcbiAgICAgKiBAdHlwZSB7IUxvbmd9XHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIExvbmcuTUlOX1ZBTFVFID0gTG9uZy5NSU5fU0lHTkVEX1ZBTFVFO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgdmFsdWUsIGFzc3VtaW5nIGl0IGlzIGEgMzItYml0IGludGVnZXIuXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIExvbmcucHJvdG90eXBlLnRvSW50ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudW5zaWduZWQgPyB0aGlzLmxvdyA+Pj4gMCA6IHRoaXMubG93O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4ge251bWJlcn0gVGhlIGNsb3Nlc3QgZmxvYXRpbmctcG9pbnQgcmVwcmVzZW50YXRpb24gdG8gdGhpcyB2YWx1ZS5cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgTG9uZy5wcm90b3R5cGUudG9OdW1iZXIgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBpZiAodGhpcy51bnNpZ25lZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gKCh0aGlzLmhpZ2ggPj4+IDApICogVFdPX1BXUl8zMl9EQkwpICsgKHRoaXMubG93ID4+PiAwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaGlnaCAqIFRXT19QV1JfMzJfREJMICsgKHRoaXMubG93ID4+PiAwKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IHJhZGl4IFRoZSByYWRpeCBpbiB3aGljaCB0aGUgdGV4dCBzaG91bGQgYmUgd3JpdHRlbi5cclxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHRleHR1YWwgcmVwcmVzZW50YXRpb24gb2YgdGhpcyB2YWx1ZS5cclxuICAgICAqIEBvdmVycmlkZVxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBMb25nLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKHJhZGl4KSB7XHJcbiAgICAgICAgcmFkaXggPSByYWRpeCB8fCAxMDtcclxuICAgICAgICBpZiAocmFkaXggPCAyIHx8IDM2IDwgcmFkaXgpIHtcclxuICAgICAgICAgICAgdGhyb3cobmV3IEVycm9yKCdyYWRpeCBvdXQgb2YgcmFuZ2U6ICcgKyByYWRpeCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5pc1plcm8oKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gJzAnO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcmVtO1xyXG4gICAgICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSkgeyAvLyBVbnNpZ25lZCBMb25ncyBhcmUgbmV2ZXIgbmVnYXRpdmVcclxuICAgICAgICAgICAgaWYgKHRoaXMuZXF1YWxzKExvbmcuTUlOX1NJR05FRF9WQUxVRSkpIHtcclxuICAgICAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gY2hhbmdlIHRoZSBMb25nIHZhbHVlIGJlZm9yZSBpdCBjYW4gYmUgbmVnYXRlZCwgc28gd2UgcmVtb3ZlXHJcbiAgICAgICAgICAgICAgICAvLyB0aGUgYm90dG9tLW1vc3QgZGlnaXQgaW4gdGhpcyBiYXNlIGFuZCB0aGVuIHJlY3Vyc2UgdG8gZG8gdGhlIHJlc3QuXHJcbiAgICAgICAgICAgICAgICB2YXIgcmFkaXhMb25nID0gTG9uZy5mcm9tTnVtYmVyKHJhZGl4KTtcclxuICAgICAgICAgICAgICAgIHZhciBkaXYgPSB0aGlzLmRpdihyYWRpeExvbmcpO1xyXG4gICAgICAgICAgICAgICAgcmVtID0gZGl2Lm11bHRpcGx5KHJhZGl4TG9uZykuc3VidHJhY3QodGhpcyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZGl2LnRvU3RyaW5nKHJhZGl4KSArIHJlbS50b0ludCgpLnRvU3RyaW5nKHJhZGl4KTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAnLScgKyB0aGlzLm5lZ2F0ZSgpLnRvU3RyaW5nKHJhZGl4KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRG8gc2V2ZXJhbCAoNikgZGlnaXRzIGVhY2ggdGltZSB0aHJvdWdoIHRoZSBsb29wLCBzbyBhcyB0b1xyXG4gICAgICAgIC8vIG1pbmltaXplIHRoZSBjYWxscyB0byB0aGUgdmVyeSBleHBlbnNpdmUgZW11bGF0ZWQgZGl2LlxyXG4gICAgICAgIHZhciByYWRpeFRvUG93ZXIgPSBMb25nLmZyb21OdW1iZXIoTWF0aC5wb3cocmFkaXgsIDYpKTtcclxuICAgICAgICByZW0gPSB0aGlzO1xyXG4gICAgICAgIHZhciByZXN1bHQgPSAnJztcclxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgICAgICB2YXIgcmVtRGl2ID0gcmVtLmRpdihyYWRpeFRvUG93ZXIpO1xyXG4gICAgICAgICAgICB2YXIgaW50dmFsID0gcmVtLnN1YnRyYWN0KHJlbURpdi5tdWx0aXBseShyYWRpeFRvUG93ZXIpKS50b0ludCgpO1xyXG4gICAgICAgICAgICB2YXIgZGlnaXRzID0gaW50dmFsLnRvU3RyaW5nKHJhZGl4KTtcclxuICAgICAgICAgICAgcmVtID0gcmVtRGl2O1xyXG4gICAgICAgICAgICBpZiAocmVtLmlzWmVybygpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZGlnaXRzICsgcmVzdWx0O1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGRpZ2l0cy5sZW5ndGggPCA2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlnaXRzID0gJzAnICsgZGlnaXRzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gJycgKyBkaWdpdHMgKyByZXN1bHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgaGlnaCAzMiBiaXRzIGFzIGEgc2lnbmVkIHZhbHVlLlxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBMb25nLnByb3RvdHlwZS5nZXRIaWdoQml0cyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmhpZ2g7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgaGlnaCAzMiBiaXRzIGFzIGFuIHVuc2lnbmVkIHZhbHVlLlxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBMb25nLnByb3RvdHlwZS5nZXRIaWdoQml0c1Vuc2lnbmVkID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaGlnaCA+Pj4gMDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBsb3cgMzIgYml0cyBhcyBhIHNpZ25lZCB2YWx1ZS5cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgTG9uZy5wcm90b3R5cGUuZ2V0TG93Qml0cyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxvdztcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBsb3cgMzIgYml0cyBhcyBhbiB1bnNpZ25lZCB2YWx1ZS5cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgTG9uZy5wcm90b3R5cGUuZ2V0TG93Qml0c1Vuc2lnbmVkID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubG93ID4+PiAwO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4ge251bWJlcn0gUmV0dXJucyB0aGUgbnVtYmVyIG9mIGJpdHMgbmVlZGVkIHRvIHJlcHJlc2VudCB0aGUgYWJzb2x1dGVcclxuICAgICAqICAgICB2YWx1ZSBvZiB0aGlzIExvbmcuXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIExvbmcucHJvdG90eXBlLmdldE51bUJpdHNBYnMgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpIHsgLy8gVW5zaWduZWQgTG9uZ3MgYXJlIG5ldmVyIG5lZ2F0aXZlXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmVxdWFscyhMb25nLk1JTl9TSUdORURfVkFMVUUpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gNjQ7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5uZWdhdGUoKS5nZXROdW1CaXRzQWJzKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgdmFsID0gdGhpcy5oaWdoICE9IDAgPyB0aGlzLmhpZ2ggOiB0aGlzLmxvdztcclxuICAgICAgICAgICAgZm9yICh2YXIgYml0ID0gMzE7IGJpdCA+IDA7IGJpdC0tKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoKHZhbCAmICgxIDw8IGJpdCkpICE9IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oaWdoICE9IDAgPyBiaXQgKyAzMyA6IGJpdCArIDE7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhpcyB2YWx1ZSBpcyB6ZXJvLlxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBMb25nLnByb3RvdHlwZS5pc1plcm8gPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5oaWdoID09IDAgJiYgdGhpcy5sb3cgPT0gMDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoaXMgdmFsdWUgaXMgbmVnYXRpdmUuXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIExvbmcucHJvdG90eXBlLmlzTmVnYXRpdmUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gIXRoaXMudW5zaWduZWQgJiYgdGhpcy5oaWdoIDwgMDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoaXMgdmFsdWUgaXMgb2RkLlxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBMb25nLnByb3RvdHlwZS5pc09kZCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5sb3cgJiAxKSA9PSAxO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhpcyB2YWx1ZSBpcyBldmVuLlxyXG4gICAgICovXHJcbiAgICBMb25nLnByb3RvdHlwZS5pc0V2ZW4gPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMubG93ICYgMSkgPT0gMDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge0xvbmd9IG90aGVyIExvbmcgdG8gY29tcGFyZSBhZ2FpbnN0LlxyXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGlzIExvbmcgZXF1YWxzIHRoZSBvdGhlci5cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgTG9uZy5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24ob3RoZXIpIHtcclxuICAgICAgICBpZiAodGhpcy51bnNpZ25lZCAhPSBvdGhlci51bnNpZ25lZCAmJiAodGhpcy5oaWdoID4+PiAzMSkgIT0gKG90aGVyLmhpZ2ggPj4+IDMxKSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIHJldHVybiAodGhpcy5oaWdoID09IG90aGVyLmhpZ2gpICYmICh0aGlzLmxvdyA9PSBvdGhlci5sb3cpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7TG9uZ30gb3RoZXIgTG9uZyB0byBjb21wYXJlIGFnYWluc3QuXHJcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoaXMgTG9uZyBkb2VzIG5vdCBlcXVhbCB0aGUgb3RoZXIuXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIExvbmcucHJvdG90eXBlLm5vdEVxdWFscyA9IGZ1bmN0aW9uKG90aGVyKSB7XHJcbiAgICAgICAgcmV0dXJuICF0aGlzLmVxdWFscyhvdGhlcik7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHtMb25nfSBvdGhlciBMb25nIHRvIGNvbXBhcmUgYWdhaW5zdC5cclxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhpcyBMb25nIGlzIGxlc3MgdGhhbiB0aGUgb3RoZXIuXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIExvbmcucHJvdG90eXBlLmxlc3NUaGFuID0gZnVuY3Rpb24ob3RoZXIpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb21wYXJlKG90aGVyKSA8IDA7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHtMb25nfSBvdGhlciBMb25nIHRvIGNvbXBhcmUgYWdhaW5zdC5cclxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhpcyBMb25nIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgb3RoZXIuXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIExvbmcucHJvdG90eXBlLmxlc3NUaGFuT3JFcXVhbCA9IGZ1bmN0aW9uKG90aGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGFyZShvdGhlcikgPD0gMDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge0xvbmd9IG90aGVyIExvbmcgdG8gY29tcGFyZSBhZ2FpbnN0LlxyXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGlzIExvbmcgaXMgZ3JlYXRlciB0aGFuIHRoZSBvdGhlci5cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgTG9uZy5wcm90b3R5cGUuZ3JlYXRlclRoYW4gPSBmdW5jdGlvbihvdGhlcikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBhcmUob3RoZXIpID4gMDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge0xvbmd9IG90aGVyIExvbmcgdG8gY29tcGFyZSBhZ2FpbnN0LlxyXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGlzIExvbmcgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHRoZSBvdGhlci5cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgTG9uZy5wcm90b3R5cGUuZ3JlYXRlclRoYW5PckVxdWFsID0gZnVuY3Rpb24ob3RoZXIpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb21wYXJlKG90aGVyKSA+PSAwO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbXBhcmVzIHRoaXMgTG9uZyB3aXRoIHRoZSBnaXZlbiBvbmUuXHJcbiAgICAgKiBAcGFyYW0ge0xvbmd9IG90aGVyIExvbmcgdG8gY29tcGFyZSBhZ2FpbnN0LlxyXG4gICAgICogQHJldHVybiB7bnVtYmVyfSAwIGlmIHRoZXkgYXJlIHRoZSBzYW1lLCAxIGlmIHRoZSB0aGlzIGlzIGdyZWF0ZXIsIGFuZCAtMVxyXG4gICAgICogICAgIGlmIHRoZSBnaXZlbiBvbmUgaXMgZ3JlYXRlci5cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgTG9uZy5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uKG90aGVyKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZXF1YWxzKG90aGVyKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHRoaXNOZWcgPSB0aGlzLmlzTmVnYXRpdmUoKTtcclxuICAgICAgICB2YXIgb3RoZXJOZWcgPSBvdGhlci5pc05lZ2F0aXZlKCk7XHJcbiAgICAgICAgaWYgKHRoaXNOZWcgJiYgIW90aGVyTmVnKSByZXR1cm4gLTE7XHJcbiAgICAgICAgaWYgKCF0aGlzTmVnICYmIG90aGVyTmVnKSByZXR1cm4gMTtcclxuICAgICAgICBpZiAoIXRoaXMudW5zaWduZWQpIHtcclxuICAgICAgICAgICAgLy8gQXQgdGhpcyBwb2ludCB0aGUgc2lnbnMgYXJlIHRoZSBzYW1lXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN1YnRyYWN0KG90aGVyKS5pc05lZ2F0aXZlKCkgPyAtMSA6IDE7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gQm90aCBhcmUgcG9zaXRpdmUgaWYgYXQgbGVhc3Qgb25lIGlzIHVuc2lnbmVkXHJcbiAgICAgICAgICAgIHJldHVybiAob3RoZXIuaGlnaCA+Pj4gMCkgPiAodGhpcy5oaWdoID4+PiAwKSB8fCAob3RoZXIuaGlnaCA9PSB0aGlzLmhpZ2ggJiYgKG90aGVyLmxvdyA+Pj4gMCkgPiAodGhpcy5sb3cgPj4+IDApKSA/IC0xIDogMTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiB7IUxvbmd9IFRoZSBuZWdhdGlvbiBvZiB0aGlzIHZhbHVlLlxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBMb25nLnByb3RvdHlwZS5uZWdhdGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBpZiAoIXRoaXMudW5zaWduZWQgJiYgdGhpcy5lcXVhbHMoTG9uZy5NSU5fU0lHTkVEX1ZBTFVFKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gTG9uZy5NSU5fU0lHTkVEX1ZBTFVFO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5ub3QoKS5hZGQoTG9uZy5PTkUpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHN1bSBvZiB0aGlzIGFuZCB0aGUgZ2l2ZW4gTG9uZy5cclxuICAgICAqIEBwYXJhbSB7TG9uZ30gb3RoZXIgTG9uZyB0byBhZGQgdG8gdGhpcyBvbmUuXHJcbiAgICAgKiBAcmV0dXJuIHshTG9uZ30gVGhlIHN1bSBvZiB0aGlzIGFuZCB0aGUgZ2l2ZW4gTG9uZy5cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgTG9uZy5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24ob3RoZXIpIHtcclxuICAgICAgICAvLyBEaXZpZGUgZWFjaCBudW1iZXIgaW50byA0IGNodW5rcyBvZiAxNiBiaXRzLCBhbmQgdGhlbiBzdW0gdGhlIGNodW5rcy5cclxuICAgICAgICBcclxuICAgICAgICB2YXIgYTQ4ID0gdGhpcy5oaWdoID4+PiAxNjtcclxuICAgICAgICB2YXIgYTMyID0gdGhpcy5oaWdoICYgMHhGRkZGO1xyXG4gICAgICAgIHZhciBhMTYgPSB0aGlzLmxvdyA+Pj4gMTY7XHJcbiAgICAgICAgdmFyIGEwMCA9IHRoaXMubG93ICYgMHhGRkZGO1xyXG5cclxuICAgICAgICB2YXIgYjQ4ID0gb3RoZXIuaGlnaCA+Pj4gMTY7XHJcbiAgICAgICAgdmFyIGIzMiA9IG90aGVyLmhpZ2ggJiAweEZGRkY7XHJcbiAgICAgICAgdmFyIGIxNiA9IG90aGVyLmxvdyA+Pj4gMTY7XHJcbiAgICAgICAgdmFyIGIwMCA9IG90aGVyLmxvdyAmIDB4RkZGRjtcclxuXHJcbiAgICAgICAgdmFyIGM0OCA9IDAsIGMzMiA9IDAsIGMxNiA9IDAsIGMwMCA9IDA7XHJcbiAgICAgICAgYzAwICs9IGEwMCArIGIwMDtcclxuICAgICAgICBjMTYgKz0gYzAwID4+PiAxNjtcclxuICAgICAgICBjMDAgJj0gMHhGRkZGO1xyXG4gICAgICAgIGMxNiArPSBhMTYgKyBiMTY7XHJcbiAgICAgICAgYzMyICs9IGMxNiA+Pj4gMTY7XHJcbiAgICAgICAgYzE2ICY9IDB4RkZGRjtcclxuICAgICAgICBjMzIgKz0gYTMyICsgYjMyO1xyXG4gICAgICAgIGM0OCArPSBjMzIgPj4+IDE2O1xyXG4gICAgICAgIGMzMiAmPSAweEZGRkY7XHJcbiAgICAgICAgYzQ4ICs9IGE0OCArIGI0ODtcclxuICAgICAgICBjNDggJj0gMHhGRkZGO1xyXG4gICAgICAgIHJldHVybiBMb25nLmZyb21CaXRzKChjMTYgPDwgMTYpIHwgYzAwLCAoYzQ4IDw8IDE2KSB8IGMzMiwgdGhpcy51bnNpZ25lZCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgZGlmZmVyZW5jZSBvZiB0aGlzIGFuZCB0aGUgZ2l2ZW4gTG9uZy5cclxuICAgICAqIEBwYXJhbSB7TG9uZ30gb3RoZXIgTG9uZyB0byBzdWJ0cmFjdCBmcm9tIHRoaXMuXHJcbiAgICAgKiBAcmV0dXJuIHshTG9uZ30gVGhlIGRpZmZlcmVuY2Ugb2YgdGhpcyBhbmQgdGhlIGdpdmVuIExvbmcuXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIExvbmcucHJvdG90eXBlLnN1YnRyYWN0ID0gZnVuY3Rpb24ob3RoZXIpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5hZGQob3RoZXIubmVnYXRlKCkpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHByb2R1Y3Qgb2YgdGhpcyBhbmQgdGhlIGdpdmVuIGxvbmcuXHJcbiAgICAgKiBAcGFyYW0ge0xvbmd9IG90aGVyIExvbmcgdG8gbXVsdGlwbHkgd2l0aCB0aGlzLlxyXG4gICAgICogQHJldHVybiB7IUxvbmd9IFRoZSBwcm9kdWN0IG9mIHRoaXMgYW5kIHRoZSBvdGhlci5cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgTG9uZy5wcm90b3R5cGUubXVsdGlwbHkgPSBmdW5jdGlvbihvdGhlcikge1xyXG4gICAgICAgIGlmICh0aGlzLmlzWmVybygpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBMb25nLlpFUk87XHJcbiAgICAgICAgfSBlbHNlIGlmIChvdGhlci5pc1plcm8oKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gTG9uZy5aRVJPO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuZXF1YWxzKExvbmcuTUlOX1ZBTFVFKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gb3RoZXIuaXNPZGQoKSA/IExvbmcuTUlOX1ZBTFVFIDogTG9uZy5aRVJPO1xyXG4gICAgICAgIH0gZWxzZSBpZiAob3RoZXIuZXF1YWxzKExvbmcuTUlOX1ZBTFVFKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pc09kZCgpID8gTG9uZy5NSU5fVkFMVUUgOiBMb25nLlpFUk87XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpIHtcclxuICAgICAgICAgICAgaWYgKG90aGVyLmlzTmVnYXRpdmUoKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubmVnYXRlKCkubXVsdGlwbHkob3RoZXIubmVnYXRlKCkpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubmVnYXRlKCkubXVsdGlwbHkob3RoZXIpLm5lZ2F0ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmIChvdGhlci5pc05lZ2F0aXZlKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubXVsdGlwbHkob3RoZXIubmVnYXRlKCkpLm5lZ2F0ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBJZiBib3RoIGxvbmdzIGFyZSBzbWFsbCwgdXNlIGZsb2F0IG11bHRpcGxpY2F0aW9uXHJcbiAgICAgICAgaWYgKHRoaXMubGVzc1RoYW4oVFdPX1BXUl8yNCkgJiZcclxuICAgICAgICAgICAgb3RoZXIubGVzc1RoYW4oVFdPX1BXUl8yNCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIExvbmcuZnJvbU51bWJlcih0aGlzLnRvTnVtYmVyKCkgKiBvdGhlci50b051bWJlcigpLCB0aGlzLnVuc2lnbmVkKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIERpdmlkZSBlYWNoIGxvbmcgaW50byA0IGNodW5rcyBvZiAxNiBiaXRzLCBhbmQgdGhlbiBhZGQgdXAgNHg0IHByb2R1Y3RzLlxyXG4gICAgICAgIC8vIFdlIGNhbiBza2lwIHByb2R1Y3RzIHRoYXQgd291bGQgb3ZlcmZsb3cuXHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIGE0OCA9IHRoaXMuaGlnaCA+Pj4gMTY7XHJcbiAgICAgICAgdmFyIGEzMiA9IHRoaXMuaGlnaCAmIDB4RkZGRjtcclxuICAgICAgICB2YXIgYTE2ID0gdGhpcy5sb3cgPj4+IDE2O1xyXG4gICAgICAgIHZhciBhMDAgPSB0aGlzLmxvdyAmIDB4RkZGRjtcclxuXHJcbiAgICAgICAgdmFyIGI0OCA9IG90aGVyLmhpZ2ggPj4+IDE2O1xyXG4gICAgICAgIHZhciBiMzIgPSBvdGhlci5oaWdoICYgMHhGRkZGO1xyXG4gICAgICAgIHZhciBiMTYgPSBvdGhlci5sb3cgPj4+IDE2O1xyXG4gICAgICAgIHZhciBiMDAgPSBvdGhlci5sb3cgJiAweEZGRkY7XHJcblxyXG4gICAgICAgIHZhciBjNDggPSAwLCBjMzIgPSAwLCBjMTYgPSAwLCBjMDAgPSAwO1xyXG4gICAgICAgIGMwMCArPSBhMDAgKiBiMDA7XHJcbiAgICAgICAgYzE2ICs9IGMwMCA+Pj4gMTY7XHJcbiAgICAgICAgYzAwICY9IDB4RkZGRjtcclxuICAgICAgICBjMTYgKz0gYTE2ICogYjAwO1xyXG4gICAgICAgIGMzMiArPSBjMTYgPj4+IDE2O1xyXG4gICAgICAgIGMxNiAmPSAweEZGRkY7XHJcbiAgICAgICAgYzE2ICs9IGEwMCAqIGIxNjtcclxuICAgICAgICBjMzIgKz0gYzE2ID4+PiAxNjtcclxuICAgICAgICBjMTYgJj0gMHhGRkZGO1xyXG4gICAgICAgIGMzMiArPSBhMzIgKiBiMDA7XHJcbiAgICAgICAgYzQ4ICs9IGMzMiA+Pj4gMTY7XHJcbiAgICAgICAgYzMyICY9IDB4RkZGRjtcclxuICAgICAgICBjMzIgKz0gYTE2ICogYjE2O1xyXG4gICAgICAgIGM0OCArPSBjMzIgPj4+IDE2O1xyXG4gICAgICAgIGMzMiAmPSAweEZGRkY7XHJcbiAgICAgICAgYzMyICs9IGEwMCAqIGIzMjtcclxuICAgICAgICBjNDggKz0gYzMyID4+PiAxNjtcclxuICAgICAgICBjMzIgJj0gMHhGRkZGO1xyXG4gICAgICAgIGM0OCArPSBhNDggKiBiMDAgKyBhMzIgKiBiMTYgKyBhMTYgKiBiMzIgKyBhMDAgKiBiNDg7XHJcbiAgICAgICAgYzQ4ICY9IDB4RkZGRjtcclxuICAgICAgICByZXR1cm4gTG9uZy5mcm9tQml0cygoYzE2IDw8IDE2KSB8IGMwMCwgKGM0OCA8PCAxNikgfCBjMzIsIHRoaXMudW5zaWduZWQpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhpcyBMb25nIGRpdmlkZWQgYnkgdGhlIGdpdmVuIG9uZS5cclxuICAgICAqIEBwYXJhbSB7TG9uZ30gb3RoZXIgTG9uZyBieSB3aGljaCB0byBkaXZpZGUuXHJcbiAgICAgKiBAcmV0dXJuIHshTG9uZ30gVGhpcyBMb25nIGRpdmlkZWQgYnkgdGhlIGdpdmVuIG9uZS5cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgTG9uZy5wcm90b3R5cGUuZGl2ID0gZnVuY3Rpb24ob3RoZXIpIHtcclxuICAgICAgICBpZiAob3RoZXIuaXNaZXJvKCkpIHtcclxuICAgICAgICAgICAgdGhyb3cobmV3IEVycm9yKCdkaXZpc2lvbiBieSB6ZXJvJykpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5pc1plcm8oKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy51bnNpZ25lZCA/IExvbmcuVVpFUk8gOiBMb25nLlpFUk87XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBhcHByb3gsIHJlbSwgcmVzO1xyXG4gICAgICAgIGlmICh0aGlzLmVxdWFscyhMb25nLk1JTl9TSUdORURfVkFMVUUpKSB7XHJcbiAgICAgICAgICAgIGlmIChvdGhlci5lcXVhbHMoTG9uZy5PTkUpIHx8IG90aGVyLmVxdWFscyhMb25nLk5FR19PTkUpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gTG9uZy5NSU5fU0lHTkVEX1ZBTFVFOyAgLy8gcmVjYWxsIHRoYXQgLU1JTl9WQUxVRSA9PSBNSU5fVkFMVUVcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChvdGhlci5lcXVhbHMoTG9uZy5NSU5fU0lHTkVEX1ZBTFVFKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIExvbmcuT05FO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gQXQgdGhpcyBwb2ludCwgd2UgaGF2ZSB8b3RoZXJ8ID49IDIsIHNvIHx0aGlzL290aGVyfCA8IHxNSU5fVkFMVUV8LlxyXG4gICAgICAgICAgICAgICAgdmFyIGhhbGZUaGlzID0gdGhpcy5zaGlmdFJpZ2h0KDEpO1xyXG4gICAgICAgICAgICAgICAgYXBwcm94ID0gaGFsZlRoaXMuZGl2KG90aGVyKS5zaGlmdExlZnQoMSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoYXBwcm94LmVxdWFscyhMb25nLlpFUk8pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG90aGVyLmlzTmVnYXRpdmUoKSA/IExvbmcuT05FIDogTG9uZy5ORUdfT05FO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZW0gPSB0aGlzLnN1YnRyYWN0KG90aGVyLm11bHRpcGx5KGFwcHJveCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlcyA9IGFwcHJveC5hZGQocmVtLmRpdihvdGhlcikpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2UgaWYgKG90aGVyLmVxdWFscyhMb25nLk1JTl9TSUdORURfVkFMVUUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVuc2lnbmVkID8gTG9uZy5VWkVSTyA6IExvbmcuWkVSTztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpKSB7XHJcbiAgICAgICAgICAgIGlmIChvdGhlci5pc05lZ2F0aXZlKCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm5lZ2F0ZSgpLmRpdihvdGhlci5uZWdhdGUoKSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5uZWdhdGUoKS5kaXYob3RoZXIpLm5lZ2F0ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmIChvdGhlci5pc05lZ2F0aXZlKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGl2KG90aGVyLm5lZ2F0ZSgpKS5uZWdhdGUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gUmVwZWF0IHRoZSBmb2xsb3dpbmcgdW50aWwgdGhlIHJlbWFpbmRlciBpcyBsZXNzIHRoYW4gb3RoZXI6ICBmaW5kIGFcclxuICAgICAgICAvLyBmbG9hdGluZy1wb2ludCB0aGF0IGFwcHJveGltYXRlcyByZW1haW5kZXIgLyBvdGhlciAqZnJvbSBiZWxvdyosIGFkZCB0aGlzXHJcbiAgICAgICAgLy8gaW50byB0aGUgcmVzdWx0LCBhbmQgc3VidHJhY3QgaXQgZnJvbSB0aGUgcmVtYWluZGVyLiAgSXQgaXMgY3JpdGljYWwgdGhhdFxyXG4gICAgICAgIC8vIHRoZSBhcHByb3hpbWF0ZSB2YWx1ZSBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHJlYWwgdmFsdWUgc28gdGhhdCB0aGVcclxuICAgICAgICAvLyByZW1haW5kZXIgbmV2ZXIgYmVjb21lcyBuZWdhdGl2ZS5cclxuICAgICAgICByZXMgPSBMb25nLlpFUk87XHJcbiAgICAgICAgcmVtID0gdGhpcztcclxuICAgICAgICB3aGlsZSAocmVtLmdyZWF0ZXJUaGFuT3JFcXVhbChvdGhlcikpIHtcclxuICAgICAgICAgICAgLy8gQXBwcm94aW1hdGUgdGhlIHJlc3VsdCBvZiBkaXZpc2lvbi4gVGhpcyBtYXkgYmUgYSBsaXR0bGUgZ3JlYXRlciBvclxyXG4gICAgICAgICAgICAvLyBzbWFsbGVyIHRoYW4gdGhlIGFjdHVhbCB2YWx1ZS5cclxuICAgICAgICAgICAgYXBwcm94ID0gTWF0aC5tYXgoMSwgTWF0aC5mbG9vcihyZW0udG9OdW1iZXIoKSAvIG90aGVyLnRvTnVtYmVyKCkpKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFdlIHdpbGwgdHdlYWsgdGhlIGFwcHJveGltYXRlIHJlc3VsdCBieSBjaGFuZ2luZyBpdCBpbiB0aGUgNDgtdGggZGlnaXQgb3JcclxuICAgICAgICAgICAgLy8gdGhlIHNtYWxsZXN0IG5vbi1mcmFjdGlvbmFsIGRpZ2l0LCB3aGljaGV2ZXIgaXMgbGFyZ2VyLlxyXG4gICAgICAgICAgICB2YXIgbG9nMiA9IE1hdGguY2VpbChNYXRoLmxvZyhhcHByb3gpIC8gTWF0aC5MTjIpO1xyXG4gICAgICAgICAgICB2YXIgZGVsdGEgPSAobG9nMiA8PSA0OCkgPyAxIDogTWF0aC5wb3coMiwgbG9nMiAtIDQ4KTtcclxuXHJcbiAgICAgICAgICAgIC8vIERlY3JlYXNlIHRoZSBhcHByb3hpbWF0aW9uIHVudGlsIGl0IGlzIHNtYWxsZXIgdGhhbiB0aGUgcmVtYWluZGVyLiAgTm90ZVxyXG4gICAgICAgICAgICAvLyB0aGF0IGlmIGl0IGlzIHRvbyBsYXJnZSwgdGhlIHByb2R1Y3Qgb3ZlcmZsb3dzIGFuZCBpcyBuZWdhdGl2ZS5cclxuICAgICAgICAgICAgdmFyIGFwcHJveFJlcyA9IExvbmcuZnJvbU51bWJlcihhcHByb3gsIHRoaXMudW5zaWduZWQpO1xyXG4gICAgICAgICAgICB2YXIgYXBwcm94UmVtID0gYXBwcm94UmVzLm11bHRpcGx5KG90aGVyKTtcclxuICAgICAgICAgICAgd2hpbGUgKGFwcHJveFJlbS5pc05lZ2F0aXZlKCkgfHwgYXBwcm94UmVtLmdyZWF0ZXJUaGFuKHJlbSkpIHtcclxuICAgICAgICAgICAgICAgIGFwcHJveCAtPSBkZWx0YTtcclxuICAgICAgICAgICAgICAgIGFwcHJveFJlcyA9IExvbmcuZnJvbU51bWJlcihhcHByb3gsIHRoaXMudW5zaWduZWQpO1xyXG4gICAgICAgICAgICAgICAgYXBwcm94UmVtID0gYXBwcm94UmVzLm11bHRpcGx5KG90aGVyKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gV2Uga25vdyB0aGUgYW5zd2VyIGNhbid0IGJlIHplcm8uLi4gYW5kIGFjdHVhbGx5LCB6ZXJvIHdvdWxkIGNhdXNlXHJcbiAgICAgICAgICAgIC8vIGluZmluaXRlIHJlY3Vyc2lvbiBzaW5jZSB3ZSB3b3VsZCBtYWtlIG5vIHByb2dyZXNzLlxyXG4gICAgICAgICAgICBpZiAoYXBwcm94UmVzLmlzWmVybygpKSB7XHJcbiAgICAgICAgICAgICAgICBhcHByb3hSZXMgPSBMb25nLk9ORTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmVzID0gcmVzLmFkZChhcHByb3hSZXMpO1xyXG4gICAgICAgICAgICByZW0gPSByZW0uc3VidHJhY3QoYXBwcm94UmVtKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoaXMgTG9uZyBtb2R1bG8gdGhlIGdpdmVuIG9uZS5cclxuICAgICAqIEBwYXJhbSB7TG9uZ30gb3RoZXIgTG9uZyBieSB3aGljaCB0byBtb2QuXHJcbiAgICAgKiBAcmV0dXJuIHshTG9uZ30gVGhpcyBMb25nIG1vZHVsbyB0aGUgZ2l2ZW4gb25lLlxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBMb25nLnByb3RvdHlwZS5tb2R1bG8gPSBmdW5jdGlvbihvdGhlcikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnN1YnRyYWN0KHRoaXMuZGl2KG90aGVyKS5tdWx0aXBseShvdGhlcikpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4geyFMb25nfSBUaGUgYml0d2lzZS1OT1Qgb2YgdGhpcyB2YWx1ZS5cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgTG9uZy5wcm90b3R5cGUubm90ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIExvbmcuZnJvbUJpdHMofnRoaXMubG93LCB+dGhpcy5oaWdoLCB0aGlzLnVuc2lnbmVkKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBiaXR3aXNlLUFORCBvZiB0aGlzIExvbmcgYW5kIHRoZSBnaXZlbiBvbmUuXHJcbiAgICAgKiBAcGFyYW0ge0xvbmd9IG90aGVyIFRoZSBMb25nIHdpdGggd2hpY2ggdG8gQU5ELlxyXG4gICAgICogQHJldHVybiB7IUxvbmd9IFRoZSBiaXR3aXNlLUFORCBvZiB0aGlzIGFuZCB0aGUgb3RoZXIuXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIExvbmcucHJvdG90eXBlLmFuZCA9IGZ1bmN0aW9uKG90aGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIExvbmcuZnJvbUJpdHModGhpcy5sb3cgJiBvdGhlci5sb3csIHRoaXMuaGlnaCAmIG90aGVyLmhpZ2gsIHRoaXMudW5zaWduZWQpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGJpdHdpc2UtT1Igb2YgdGhpcyBMb25nIGFuZCB0aGUgZ2l2ZW4gb25lLlxyXG4gICAgICogQHBhcmFtIHtMb25nfSBvdGhlciBUaGUgTG9uZyB3aXRoIHdoaWNoIHRvIE9SLlxyXG4gICAgICogQHJldHVybiB7IUxvbmd9IFRoZSBiaXR3aXNlLU9SIG9mIHRoaXMgYW5kIHRoZSBvdGhlci5cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgTG9uZy5wcm90b3R5cGUub3IgPSBmdW5jdGlvbihvdGhlcikge1xyXG4gICAgICAgIHJldHVybiBMb25nLmZyb21CaXRzKHRoaXMubG93IHwgb3RoZXIubG93LCB0aGlzLmhpZ2ggfCBvdGhlci5oaWdoLCB0aGlzLnVuc2lnbmVkKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBiaXR3aXNlLVhPUiBvZiB0aGlzIExvbmcgYW5kIHRoZSBnaXZlbiBvbmUuXHJcbiAgICAgKiBAcGFyYW0ge0xvbmd9IG90aGVyIFRoZSBMb25nIHdpdGggd2hpY2ggdG8gWE9SLlxyXG4gICAgICogQHJldHVybiB7IUxvbmd9IFRoZSBiaXR3aXNlLVhPUiBvZiB0aGlzIGFuZCB0aGUgb3RoZXIuXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIExvbmcucHJvdG90eXBlLnhvciA9IGZ1bmN0aW9uKG90aGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIExvbmcuZnJvbUJpdHModGhpcy5sb3cgXiBvdGhlci5sb3csIHRoaXMuaGlnaCBeIG90aGVyLmhpZ2gsIHRoaXMudW5zaWduZWQpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyBzaGlmdGVkIHRvIHRoZSBsZWZ0IGJ5IHRoZSBnaXZlbiBhbW91bnQuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtQml0cyBUaGUgbnVtYmVyIG9mIGJpdHMgYnkgd2hpY2ggdG8gc2hpZnQuXHJcbiAgICAgKiBAcmV0dXJuIHshTG9uZ30gVGhpcyBzaGlmdGVkIHRvIHRoZSBsZWZ0IGJ5IHRoZSBnaXZlbiBhbW91bnQuXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIExvbmcucHJvdG90eXBlLnNoaWZ0TGVmdCA9IGZ1bmN0aW9uKG51bUJpdHMpIHtcclxuICAgICAgICBudW1CaXRzICY9IDYzO1xyXG4gICAgICAgIGlmIChudW1CaXRzID09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIGxvdyA9IHRoaXMubG93O1xyXG4gICAgICAgICAgICBpZiAobnVtQml0cyA8IDMyKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaGlnaCA9IHRoaXMuaGlnaDtcclxuICAgICAgICAgICAgICAgIHJldHVybiBMb25nLmZyb21CaXRzKGxvdyA8PCBudW1CaXRzLCAoaGlnaCA8PCBudW1CaXRzKSB8IChsb3cgPj4+ICgzMiAtIG51bUJpdHMpKSwgdGhpcy51bnNpZ25lZCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gTG9uZy5mcm9tQml0cygwLCBsb3cgPDwgKG51bUJpdHMgLSAzMiksIHRoaXMudW5zaWduZWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyBzaGlmdGVkIHRvIHRoZSByaWdodCBieSB0aGUgZ2l2ZW4gYW1vdW50LlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG51bUJpdHMgVGhlIG51bWJlciBvZiBiaXRzIGJ5IHdoaWNoIHRvIHNoaWZ0LlxyXG4gICAgICogQHJldHVybiB7IUxvbmd9IFRoaXMgc2hpZnRlZCB0byB0aGUgcmlnaHQgYnkgdGhlIGdpdmVuIGFtb3VudC5cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgTG9uZy5wcm90b3R5cGUuc2hpZnRSaWdodCA9IGZ1bmN0aW9uKG51bUJpdHMpIHtcclxuICAgICAgICBudW1CaXRzICY9IDYzO1xyXG4gICAgICAgIGlmIChudW1CaXRzID09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIGhpZ2ggPSB0aGlzLmhpZ2g7XHJcbiAgICAgICAgICAgIGlmIChudW1CaXRzIDwgMzIpIHtcclxuICAgICAgICAgICAgICAgIHZhciBsb3cgPSB0aGlzLmxvdztcclxuICAgICAgICAgICAgICAgIHJldHVybiBMb25nLmZyb21CaXRzKChsb3cgPj4+IG51bUJpdHMpIHwgKGhpZ2ggPDwgKDMyIC0gbnVtQml0cykpLCBoaWdoID4+IG51bUJpdHMsIHRoaXMudW5zaWduZWQpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIExvbmcuZnJvbUJpdHMoaGlnaCA+PiAobnVtQml0cyAtIDMyKSwgaGlnaCA+PSAwID8gMCA6IC0xLCB0aGlzLnVuc2lnbmVkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgc2hpZnRlZCB0byB0aGUgcmlnaHQgYnkgdGhlIGdpdmVuIGFtb3VudCwgd2l0aFxyXG4gICAgICogdGhlIG5ldyB0b3AgYml0cyBtYXRjaGluZyB0aGUgY3VycmVudCBzaWduIGJpdC5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1CaXRzIFRoZSBudW1iZXIgb2YgYml0cyBieSB3aGljaCB0byBzaGlmdC5cclxuICAgICAqIEByZXR1cm4geyFMb25nfSBUaGlzIHNoaWZ0ZWQgdG8gdGhlIHJpZ2h0IGJ5IHRoZSBnaXZlbiBhbW91bnQsIHdpdGhcclxuICAgICAqICAgICB6ZXJvcyBwbGFjZWQgaW50byB0aGUgbmV3IGxlYWRpbmcgYml0cy5cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgTG9uZy5wcm90b3R5cGUuc2hpZnRSaWdodFVuc2lnbmVkID0gZnVuY3Rpb24obnVtQml0cykge1xyXG4gICAgICAgIG51bUJpdHMgJj0gNjM7XHJcbiAgICAgICAgaWYgKG51bUJpdHMgPT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgaGlnaCA9IHRoaXMuaGlnaDtcclxuICAgICAgICAgICAgaWYgKG51bUJpdHMgPCAzMikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGxvdyA9IHRoaXMubG93O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIExvbmcuZnJvbUJpdHMoKGxvdyA+Pj4gbnVtQml0cykgfCAoaGlnaCA8PCAoMzIgLSBudW1CaXRzKSksIGhpZ2ggPj4+IG51bUJpdHMsIHRoaXMudW5zaWduZWQpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG51bUJpdHMgPT0gMzIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBMb25nLmZyb21CaXRzKGhpZ2gsIDAsIHRoaXMudW5zaWduZWQpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIExvbmcuZnJvbUJpdHMoaGlnaCA+Pj4gKG51bUJpdHMgLSAzMiksIDAsIHRoaXMudW5zaWduZWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4geyFMb25nfSBTaWduZWQgbG9uZ1xyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBMb25nLnByb3RvdHlwZS50b1NpZ25lZCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBsID0gdGhpcy5jbG9uZSgpO1xyXG4gICAgICAgIGwudW5zaWduZWQgPSBmYWxzZTtcclxuICAgICAgICByZXR1cm4gbDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIHshTG9uZ30gVW5zaWduZWQgbG9uZ1xyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBMb25nLnByb3RvdHlwZS50b1Vuc2lnbmVkID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIGwgPSB0aGlzLmNsb25lKCk7XHJcbiAgICAgICAgbC51bnNpZ25lZCA9IHRydWU7XHJcbiAgICAgICAgcmV0dXJuIGw7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4ge0xvbmd9IENsb25lZCBpbnN0YW5jZSB3aXRoIHRoZSBzYW1lIGxvdy9oaWdoIGJpdHMgYW5kIHVuc2lnbmVkIGZsYWcuXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIExvbmcucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBMb25nKHRoaXMubG93LCB0aGlzLmhpZ2gsIHRoaXMudW5zaWduZWQpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBFbmFibGUgbW9kdWxlIGxvYWRpbmcgaWYgYXZhaWxhYmxlXHJcbiAgICBpZiAodHlwZW9mIG1vZHVsZSAhPSAndW5kZWZpbmVkJyAmJiBtb2R1bGVbXCJleHBvcnRzXCJdKSB7IC8vIENvbW1vbkpTXHJcbiAgICAgICAgbW9kdWxlW1wiZXhwb3J0c1wiXSA9IExvbmc7XHJcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgIT0gJ3VuZGVmaW5lZCcgJiYgZGVmaW5lW1wiYW1kXCJdKSB7IC8vIEFNRFxyXG4gICAgICAgIGRlZmluZShcIk1hdGgvTG9uZ1wiLCBbXSwgZnVuY3Rpb24oKSB7IHJldHVybiBMb25nOyB9KTtcclxuICAgIH0gZWxzZSB7IC8vIFNoaW1cclxuICAgICAgICBpZiAoIWdsb2JhbFtcImRjb2RlSU9cIl0pIHtcclxuICAgICAgICAgICAgZ2xvYmFsW1wiZGNvZGVJT1wiXSA9IHt9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBnbG9iYWxbXCJkY29kZUlPXCJdW1wiTG9uZ1wiXSA9IExvbmc7XHJcbiAgICB9XHJcblxyXG59KSh0aGlzKTtcclxuIiwiLypcclxuIENvcHlyaWdodCAyMDEzIERhbmllbCBXaXJ0eiA8ZGNvZGVAZGNvZGUuaW8+XHJcbiBDb3B5cmlnaHQgMjAwOSBUaGUgQ2xvc3VyZSBMaWJyYXJ5IEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXHJcblxyXG4gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG5cclxuIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG5cclxuIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMtSVNcIiBCQVNJUyxcclxuIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9kaXN0L0xvbmcuanNcIik7XHJcbiIsInZhciBmdXJpb3VzID0gcmVxdWlyZShcIi4uL2xpYi9mdXJpb3VzLmpzXCIpO1xyXG52YXIgZXhwZWN0ID0gcmVxdWlyZShcImNoYWlcIikuZXhwZWN0O1xyXG5cclxudmFyIGNvbnRleHQgPSBudWxsO1xyXG5iZWZvcmUoZnVuY3Rpb24oZG9uZSkge1xyXG5cdGZ1cmlvdXMuaW5pdChmdW5jdGlvbihjdHgpIHtcclxuXHRcdGNvbnRleHQgPSBjdHg7XHJcblx0XHRkb25lKCk7XHJcblx0fSk7XHJcbn0pO1xyXG5cclxuZGVzY3JpYmUoXCJDb250ZXh0XCIsIGZ1bmN0aW9uKCl7XHJcblx0ZGVzY3JpYmUoXCJiYXJyaWVyXCIsIGZ1bmN0aW9uKCkge1xyXG5cdFx0aXQoXCJDYWxscyB0aGUgY2FsbGJhY2tcIiwgZnVuY3Rpb24oZG9uZSkge1xyXG5cdFx0XHRjb250ZXh0LmJhcnJpZXIoZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRcdGRvbmUoKTtcclxuXHRcdFx0fSk7XHJcblx0XHR9KTtcclxuXHRcdGl0KFwiRXhlY3V0ZXMgYWZ0ZXIgcHJlY2VlZGluZyBjb21tYW5kcyBoYXZlIGZpbmlzaGVkXCIsIGZ1bmN0aW9uKGRvbmUpIHtcclxuXHRcdFx0dmFyIHggPSBjb250ZXh0Lnplcm9zKFszLCAzXSk7XHJcblx0XHRcdHZhciBnZXRIYXNGaW5pc2hlZCA9IGZhbHNlO1xyXG5cdFx0XHR4LmdldChmdW5jdGlvbihkYXRhKSB7XHJcblx0XHRcdFx0Z2V0SGFzRmluaXNoZWQgPSB0cnVlO1xyXG5cdFx0XHR9KTtcclxuXHRcdFx0Y29udGV4dC5iYXJyaWVyKGZ1bmN0aW9uICgpe1xyXG5cdFx0XHRcdGV4cGVjdChnZXRIYXNGaW5pc2hlZCkudG8uYmUudHJ1ZTtcclxuXHRcdFx0XHRkb25lKCk7XHJcblx0XHRcdH0pO1xyXG5cdFx0fSk7XHJcblx0XHRpdChcIkV4ZWN1dGVzIGJlZm9yZSBzdWJzZXF1ZW50IGNvbW1hbmRzIGhhdmUgc3RhcnRlZFwiLCBmdW5jdGlvbihkb25lKSB7XHJcblx0XHRcdHZhciB4ID0gY29udGV4dC56ZXJvcyhbMywgM10pO1xyXG5cdFx0XHR2YXIgYmFycmllckhhc0ZpbmlzaGVkID0gZmFsc2U7XHJcblx0XHRcdGNvbnRleHQuYmFycmllcihmdW5jdGlvbiAoKXtcclxuXHRcdFx0XHRiYXJyaWVySGFzRmluaXNoZWQgPSB0cnVlO1xyXG5cdFx0XHR9KTtcclxuXHRcdFx0eC5nZXQoZnVuY3Rpb24oeCkge1xyXG5cdFx0XHRcdGV4cGVjdChiYXJyaWVySGFzRmluaXNoZWQpLnRvLmJlLnRydWU7XHJcblx0XHRcdFx0ZG9uZSgpO1xyXG5cdFx0XHR9KTtcclxuXHRcdH0pO1xyXG5cdH0pO1xyXG5cdGRlc2NyaWJlKFwiZW1wdHlcIiwgZnVuY3Rpb24oKXtcclxuXHRcdGl0KFwiQ3JlYXRlcyBhcnJheSB3aXRoIHNwZWNpZmllZCBzaGFwZVwiLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0dmFyIHggPSBjb250ZXh0LmVtcHR5KDQyKTtcclxuXHRcdFx0dmFyIHkgPSBjb250ZXh0LmVtcHR5KFs0Ml0pO1xyXG5cdFx0XHR2YXIgeiA9IGNvbnRleHQuZW1wdHkoWzQsIDJdKTtcclxuXHRcdFx0ZXhwZWN0KHguc2hhcGUpLnRvLmRlZXAuZXF1YWwoWzQyXSk7XHJcblx0XHRcdGV4cGVjdCh5LnNoYXBlKS50by5kZWVwLmVxdWFsKFs0Ml0pO1xyXG5cdFx0XHRleHBlY3Qoei5zaGFwZSkudG8uZGVlcC5lcXVhbChbNCwgMl0pO1xyXG5cdFx0XHR4LmludmFsaWRhdGUoKTtcclxuXHRcdFx0eS5pbnZhbGlkYXRlKCk7XHJcblx0XHRcdHouaW52YWxpZGF0ZSgpO1xyXG5cdFx0fSk7XHJcblx0XHRpdChcIkNyZWF0ZXMgYXJyYXkgd2l0aCBzcGVjaWZpZWQgZGF0YSB0eXBlIChmNjQgYnkgZGVmYXVsdClcIiwgZnVuY3Rpb24oKSB7XHJcblx0XHRcdHZhciB4ID0gY29udGV4dC5lbXB0eShbNCwgMl0pO1xyXG5cdFx0XHR2YXIgeSA9IGNvbnRleHQuZW1wdHkoWzQsIDJdLCBuZXcgZnVyaW91cy5EYXRhVHlwZShcImY2NFwiKSk7XHJcblx0XHRcdHZhciB6ID0gY29udGV4dC5lbXB0eShbNCwgMl0sIG5ldyBmdXJpb3VzLkRhdGFUeXBlKFwiZjMyXCIpKTtcclxuXHRcdFx0ZXhwZWN0KHguZGF0YVR5cGUuZXF1YWxzKG5ldyBmdXJpb3VzLkRhdGFUeXBlKFwiZjY0XCIpKSkudG8uYmUudHJ1ZTtcclxuXHRcdFx0ZXhwZWN0KHkuZGF0YVR5cGUuZXF1YWxzKG5ldyBmdXJpb3VzLkRhdGFUeXBlKFwiZjY0XCIpKSkudG8uYmUudHJ1ZTtcclxuXHRcdFx0ZXhwZWN0KHouZGF0YVR5cGUuZXF1YWxzKG5ldyBmdXJpb3VzLkRhdGFUeXBlKFwiZjMyXCIpKSkudG8uYmUudHJ1ZTtcclxuXHRcdFx0eC5pbnZhbGlkYXRlKCk7XHJcblx0XHRcdHkuaW52YWxpZGF0ZSgpO1xyXG5cdFx0XHR6LmludmFsaWRhdGUoKTtcclxuXHRcdH0pO1xyXG5cdH0pO1xyXG5cdGRlc2NyaWJlKFwiemVyb3NcIiwgZnVuY3Rpb24oKXtcclxuXHRcdGl0KFwiQ3JlYXRlcyBhcnJheSB3aXRoIHNwZWNpZmllZCBzaGFwZVwiLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0dmFyIHggPSBjb250ZXh0Lnplcm9zKDQyKTtcclxuXHRcdFx0dmFyIHkgPSBjb250ZXh0Lnplcm9zKFs0Ml0pO1xyXG5cdFx0XHR2YXIgeiA9IGNvbnRleHQuemVyb3MoWzQsIDJdKTtcclxuXHRcdFx0ZXhwZWN0KHguc2hhcGUpLnRvLmRlZXAuZXF1YWwoWzQyXSk7XHJcblx0XHRcdGV4cGVjdCh5LnNoYXBlKS50by5kZWVwLmVxdWFsKFs0Ml0pO1xyXG5cdFx0XHRleHBlY3Qoei5zaGFwZSkudG8uZGVlcC5lcXVhbChbNCwgMl0pO1xyXG5cdFx0XHR4LmludmFsaWRhdGUoKTtcclxuXHRcdFx0eS5pbnZhbGlkYXRlKCk7XHJcblx0XHRcdHouaW52YWxpZGF0ZSgpO1xyXG5cdFx0fSk7XHJcblx0XHRpdChcIkNyZWF0ZXMgYXJyYXkgd2l0aCBzcGVjaWZpZWQgZGF0YSB0eXBlIChmNjQgYnkgZGVmYXVsdClcIiwgZnVuY3Rpb24oKSB7XHJcblx0XHRcdHZhciB4ID0gY29udGV4dC56ZXJvcyhbNCwgMl0pO1xyXG5cdFx0XHR2YXIgeSA9IGNvbnRleHQuemVyb3MoWzQsIDJdLCBuZXcgZnVyaW91cy5EYXRhVHlwZShcImY2NFwiKSk7XHJcblx0XHRcdHZhciB6ID0gY29udGV4dC56ZXJvcyhbNCwgMl0sIG5ldyBmdXJpb3VzLkRhdGFUeXBlKFwiZjMyXCIpKTtcclxuXHRcdFx0ZXhwZWN0KHguZGF0YVR5cGUuZXF1YWxzKG5ldyBmdXJpb3VzLkRhdGFUeXBlKFwiZjY0XCIpKSkudG8uYmUudHJ1ZTtcclxuXHRcdFx0ZXhwZWN0KHkuZGF0YVR5cGUuZXF1YWxzKG5ldyBmdXJpb3VzLkRhdGFUeXBlKFwiZjY0XCIpKSkudG8uYmUudHJ1ZTtcclxuXHRcdFx0ZXhwZWN0KHouZGF0YVR5cGUuZXF1YWxzKG5ldyBmdXJpb3VzLkRhdGFUeXBlKFwiZjMyXCIpKSkudG8uYmUudHJ1ZTtcclxuXHRcdFx0eC5pbnZhbGlkYXRlKCk7XHJcblx0XHRcdHkuaW52YWxpZGF0ZSgpO1xyXG5cdFx0XHR6LmludmFsaWRhdGUoKTtcclxuXHRcdH0pO1xyXG5cdFx0aXQoXCJDcmVhdGVzIGFycmF5IHdpdGggYWxsIGVsZW1lbnRzIGluaXRpYWxpemVkIHRvIHplcm9cIiwgZnVuY3Rpb24oZG9uZSkge1xyXG5cdFx0XHR2YXIgeCA9IGNvbnRleHQuemVyb3MoWzMsIDJdLCBuZXcgZnVyaW91cy5EYXRhVHlwZShcImY2NFwiKSk7XHJcblx0XHRcdHZhciB5ID0gY29udGV4dC56ZXJvcyhbMiwgM10sIG5ldyBmdXJpb3VzLkRhdGFUeXBlKFwiZjMyXCIpKTtcclxuXHRcdFx0Y29udGV4dC5nZXQoeCwgeSwgZnVuY3Rpb24oeCwgeSkge1xyXG5cdFx0XHRcdGV4cGVjdCh4KS50by5kZWVwLmVxdWFsKFtbMC4wLCAwLjBdLFxyXG5cdFx0XHRcdCAgICAgICAgICAgICAgICAgICAgICAgICBbMC4wLCAwLjBdLFxyXG5cdFx0XHRcdCAgICAgICAgICAgICAgICAgICAgICAgICBbMC4wLCAwLjBdXSk7XHJcblx0XHRcdFx0ZXhwZWN0KHkpLnRvLmRlZXAuZXF1YWwoW1swLjAsIDAuMCwgMC4wXSxcclxuXHRcdFx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgWzAuMCwgMC4wLCAwLjBdXSk7XHJcblx0XHRcdFx0ZG9uZSgpO1xyXG5cdFx0XHR9KTtcclxuXHRcdH0pO1xyXG5cdH0pO1xyXG5cdGRlc2NyaWJlKFwib25lc1wiLCBmdW5jdGlvbigpe1xyXG5cdFx0aXQoXCJDcmVhdGVzIGFycmF5IHdpdGggc3BlY2lmaWVkIHNoYXBlXCIsIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHR2YXIgeCA9IGNvbnRleHQub25lcyg0Mik7XHJcblx0XHRcdHZhciB5ID0gY29udGV4dC5vbmVzKFs0Ml0pO1xyXG5cdFx0XHR2YXIgeiA9IGNvbnRleHQub25lcyhbNCwgMl0pO1xyXG5cdFx0XHRleHBlY3QoeC5zaGFwZSkudG8uZGVlcC5lcXVhbChbNDJdKTtcclxuXHRcdFx0ZXhwZWN0KHkuc2hhcGUpLnRvLmRlZXAuZXF1YWwoWzQyXSk7XHJcblx0XHRcdGV4cGVjdCh6LnNoYXBlKS50by5kZWVwLmVxdWFsKFs0LCAyXSk7XHJcblx0XHRcdHguaW52YWxpZGF0ZSgpO1xyXG5cdFx0XHR5LmludmFsaWRhdGUoKTtcclxuXHRcdFx0ei5pbnZhbGlkYXRlKCk7XHJcblx0XHR9KTtcclxuXHRcdGl0KFwiQ3JlYXRlcyBhcnJheSB3aXRoIHNwZWNpZmllZCBkYXRhIHR5cGUgKGY2NCBieSBkZWZhdWx0KVwiLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0dmFyIHggPSBjb250ZXh0Lm9uZXMoWzQsIDJdKTtcclxuXHRcdFx0dmFyIHkgPSBjb250ZXh0Lm9uZXMoWzQsIDJdLCBuZXcgZnVyaW91cy5EYXRhVHlwZShcImY2NFwiKSk7XHJcblx0XHRcdHZhciB6ID0gY29udGV4dC5vbmVzKFs0LCAyXSwgbmV3IGZ1cmlvdXMuRGF0YVR5cGUoXCJmMzJcIikpO1xyXG5cdFx0XHRleHBlY3QoeC5kYXRhVHlwZS5lcXVhbHMobmV3IGZ1cmlvdXMuRGF0YVR5cGUoXCJmNjRcIikpKS50by5iZS50cnVlO1xyXG5cdFx0XHRleHBlY3QoeS5kYXRhVHlwZS5lcXVhbHMobmV3IGZ1cmlvdXMuRGF0YVR5cGUoXCJmNjRcIikpKS50by5iZS50cnVlO1xyXG5cdFx0XHRleHBlY3Qoei5kYXRhVHlwZS5lcXVhbHMobmV3IGZ1cmlvdXMuRGF0YVR5cGUoXCJmMzJcIikpKS50by5iZS50cnVlO1xyXG5cdFx0XHR4LmludmFsaWRhdGUoKTtcclxuXHRcdFx0eS5pbnZhbGlkYXRlKCk7XHJcblx0XHRcdHouaW52YWxpZGF0ZSgpO1xyXG5cdFx0fSk7XHJcblx0XHRpdChcIkNyZWF0ZXMgYXJyYXkgd2l0aCBhbGwgZWxlbWVudHMgaW5pdGlhbGl6ZWQgdG8gb25lXCIsIGZ1bmN0aW9uKGRvbmUpIHtcclxuXHRcdFx0dmFyIHggPSBjb250ZXh0Lm9uZXMoWzMsIDJdLCBuZXcgZnVyaW91cy5EYXRhVHlwZShcImY2NFwiKSk7XHJcblx0XHRcdHZhciB5ID0gY29udGV4dC5vbmVzKFsyLCAzXSwgbmV3IGZ1cmlvdXMuRGF0YVR5cGUoXCJmMzJcIikpO1xyXG5cdFx0XHRjb250ZXh0LmdldCh4LCB5LCBmdW5jdGlvbih4LCB5KSB7XHJcblx0XHRcdFx0ZXhwZWN0KHgpLnRvLmRlZXAuZXF1YWwoW1sxLjAsIDEuMF0sXHJcblx0XHRcdFx0ICAgICAgICAgICAgICAgICAgICAgICAgIFsxLjAsIDEuMF0sXHJcblx0XHRcdFx0ICAgICAgICAgICAgICAgICAgICAgICAgIFsxLjAsIDEuMF1dKTtcclxuXHRcdFx0XHRleHBlY3QoeSkudG8uZGVlcC5lcXVhbChbWzEuMCwgMS4wLCAxLjBdLFxyXG5cdFx0XHRcdCAgICAgICAgICAgICAgICAgICAgICAgICBbMS4wLCAxLjAsIDEuMF1dKTtcclxuXHRcdFx0XHRkb25lKCk7XHJcblx0XHRcdH0pO1xyXG5cdFx0fSk7XHJcblx0fSk7XHJcblx0ZGVzY3JpYmUoXCJhcnJheVwiLCBmdW5jdGlvbigpe1xyXG5cdFx0aXQoXCJDcmVhdGVzIGFycmF5IG9mIHRoZSBzYW1lIGxlbmd0aCBhcyB0aGUgcHJvdmlkZWQgYXJyYXlcIiwgZnVuY3Rpb24oKXtcclxuXHRcdFx0dmFyIHggPSBjb250ZXh0LmFycmF5KFswLCAxXSk7XHJcblx0XHRcdHZhciB5ID0gY29udGV4dC5hcnJheShbWzAsIDFdLFxyXG5cdFx0XHQgICAgICAgICAgICAgICAgICAgICAgIFsyLCAzXSxcclxuXHRcdFx0ICAgICAgICAgICAgICAgICAgICAgICBbMywgNF1dKTtcclxuXHRcdFx0ZXhwZWN0KHgubGVuZ3RoKS50by5lcXVhbCgyKTtcclxuXHRcdFx0ZXhwZWN0KHkubGVuZ3RoKS50by5lcXVhbCg2KTtcclxuXHRcdFx0eC5pbnZhbGlkYXRlKCk7XHJcblx0XHRcdHkuaW52YWxpZGF0ZSgpO1xyXG5cdFx0fSk7XHJcblx0XHRpdChcIkNyZWF0ZXMgYXJyYXkgb2YgdGhlIHNhbWUgc2hhcGUgYXMgdGhlIHByb3ZpZGVkIGFycmF5XCIsIGZ1bmN0aW9uKCl7XHJcblx0XHRcdHZhciB4ID0gY29udGV4dC5hcnJheShbMCwgMV0pO1xyXG5cdFx0XHR2YXIgeSA9IGNvbnRleHQuYXJyYXkoW1swLCAxXSxcclxuXHRcdFx0ICAgICAgICAgICAgICAgICAgICAgICBbMiwgM10sXHJcblx0XHRcdCAgICAgICAgICAgICAgICAgICAgICAgWzMsIDRdXSk7XHJcblx0XHRcdHZhciB6ID0gY29udGV4dC5hcnJheShbW1sxLCAyLCAzXSwgWyA0LCAgNSwgIDZdXSxcclxuXHRcdFx0ICAgICAgICAgICAgICAgICAgICAgICBbWzcsIDgsIDldLCBbMTAsIDExLCAxMl1dXSk7XHJcblx0XHRcdGV4cGVjdCh4LnNoYXBlKS50by5kZWVwLmVxdWFsKFsyXSk7XHJcblx0XHRcdGV4cGVjdCh5LnNoYXBlKS50by5kZWVwLmVxdWFsKFszLCAyXSk7XHJcblx0XHRcdGV4cGVjdCh6LnNoYXBlKS50by5kZWVwLmVxdWFsKFsyLCAyLCAzXSk7XHJcblx0XHRcdHguaW52YWxpZGF0ZSgpO1xyXG5cdFx0XHR5LmludmFsaWRhdGUoKTtcclxuXHRcdFx0ei5pbnZhbGlkYXRlKCk7XHJcblx0XHR9KTtcclxuXHRcdGl0KFwiQ3JlYXRlcyBhcnJheSB3aXRoIHRoZSBzYW1lIGRhdGEgYXMgdGhlIHByb3ZpZGVkIGFycmF5XCIsIGZ1bmN0aW9uKGRvbmUpe1xyXG5cdFx0XHR2YXIgYXJyYXkgPSBbW1sxLCAyLCAzXSwgWyA0LCAgNSwgIDZdXSxcclxuXHRcdFx0ICAgICAgICAgICAgIFtbNywgOCwgOV0sIFsxMCwgMTEsIDEyXV1dO1xyXG5cdFx0XHR2YXIgeCA9IGNvbnRleHQuYXJyYXkoYXJyYXksIG5ldyBmdXJpb3VzLkRhdGFUeXBlKFwiZjY0XCIpKTtcclxuXHRcdFx0dmFyIHkgPSBjb250ZXh0LmFycmF5KGFycmF5LCBuZXcgZnVyaW91cy5EYXRhVHlwZShcImYzMlwiKSk7XHJcblx0XHRcdGNvbnRleHQuZ2V0KHgsIHksIGZ1bmN0aW9uKHgsIHkpIHtcclxuXHRcdFx0XHRleHBlY3QoeCkudG8uZGVlcC5lcXVhbChhcnJheSk7XHJcblx0XHRcdFx0ZXhwZWN0KHkpLnRvLmRlZXAuZXF1YWwoYXJyYXkpO1xyXG5cdFx0XHRcdGRvbmUoKTtcclxuXHRcdFx0fSk7XHJcblx0XHR9KTtcclxuXHR9KTtcclxuXHRkZXNjcmliZShcImxpbnNwYWNlXCIsIGZ1bmN0aW9uKCl7XHJcblx0XHRpdChcIkhhcyBsZW5ndGggb2YgNTAgd2l0aCBkZWZhdWx0IGFyZ3VtZW50c1wiLCBmdW5jdGlvbigpe1xyXG5cdFx0XHRleHBlY3QoKGNvbnRleHQubGluc3BhY2UoMCwgMSkpLmxlbmd0aCkudG8uZXF1YWwoNTApO1xyXG5cdFx0fSk7XHJcblx0XHRpdChcIkhhcyB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiBzYW1wbGVzXCIsIGZ1bmN0aW9uKCl7XHJcblx0XHRcdGV4cGVjdCgoY29udGV4dC5saW5zcGFjZSgwLCAxLCAyNDMpKS5sZW5ndGgpLnRvLmVxdWFsKDI0Myk7XHJcblx0XHR9KTtcclxuXHRcdGl0KFwiSGFzIGV4cGVjdGVkIHZhbHVlc1wiLCBmdW5jdGlvbihkb25lKXtcclxuXHRcdFx0dmFyIHN0YXJ0ID0gNTA7XHJcblx0XHRcdHZhciBzdG9wID0gOTk7XHJcblx0XHRcdHZhciB4ID0gY29udGV4dC5saW5zcGFjZShzdGFydCwgc3RvcCk7XHJcblx0XHRcdHguZ2V0KGZ1bmN0aW9uKHJlc3VsdCkge1xyXG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgcmVzdWx0Lmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0XHRleHBlY3QocmVzdWx0W2ldKS50by5lcXVhbChzdGFydCtpKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0ZG9uZSgpO1xyXG5cdFx0XHR9KTtcclxuXHRcdH0pO1xyXG5cdFx0ZGVzY3JpYmUoXCJ3aXRoIGluY2x1ZGVTdG9wID09PSBmYWxzZVwiLCBmdW5jdGlvbigpe1xyXG5cdFx0XHRpdChcIkhhcyB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiBzYW1wbGVzXCIsIGZ1bmN0aW9uKCl7XHJcblx0XHRcdFx0ZXhwZWN0KChjb250ZXh0LmxpbnNwYWNlKDAsIDEsIDI0MywgZmFsc2UpKS5sZW5ndGgpLnRvLmVxdWFsKDI0Myk7XHJcblx0XHRcdH0pO1xyXG5cdFx0XHRpdChcIkRvZXMgbm90IGNvbnRhaW4gdGhlIHJpZ2h0IGVuZHBvaW50XCIsIGZ1bmN0aW9uKGRvbmUpe1xyXG5cdFx0XHRcdHZhciB4ID0gY29udGV4dC5saW5zcGFjZSgtMSwgMSwgMTAwMCwgZmFsc2UpO1xyXG5cdFx0XHRcdHguZ2V0KGZ1bmN0aW9uKHJlc3VsdCkge1xyXG5cdFx0XHRcdFx0ZXhwZWN0KHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV0pLnRvLm5vdC5lcXVhbCgxKTtcclxuXHRcdFx0XHRcdGRvbmUoKTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fSk7XHJcblx0XHR9KTtcclxuXHR9KTtcclxuXHRkZXNjcmliZShcIm5lZ1wiLCBmdW5jdGlvbigpIHtcclxuXHRcdHZhciB4UmVmID0gWyAxLCAtNy41LCAgMCwgLTE1XTtcclxuXHRcdHZhciB5UmVmID0gWy0xLCAgNy41LCAtMCwgIDE1XTtcclxuXHRcdHZhciBkYXRhVHlwZXMgPSBbXCJmMzJcIiwgXCJmNjRcIl07XHJcblxyXG5cdFx0ZGVzY3JpYmUoXCJXaXRoIG5vIG91dHB1dCBhcnJheSBzdXBwbGllZFwiLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0aXQoXCJDcmVhdGVzIGFuIG91dHB1dCBhcnJheSB3aXRoIHRoZSBzYW1lIHNoYXBlIGFzIGlucHV0IGFycmF5XCIsIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHZhciB4ID0gY29udGV4dC5vbmVzKFsyLCAzLCA0XSk7XHJcblx0XHRcdFx0dmFyIHkgPSBjb250ZXh0Lm5lZyh4KTtcclxuXHRcdFx0XHRleHBlY3QoeS5zaGFwZSkudG8uZGVlcC5lcXVhbChbMiwgMywgNF0pO1xyXG5cdFx0XHRcdHkuaW52YWxpZGF0ZSgpO1xyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YVR5cGVzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0KGZ1bmN0aW9uKGRhdGFUeXBlKSB7XHJcblx0XHRcdFx0XHRpdChcIkNyZWF0ZXMgYW4gb3V0cHV0IGFycmF5IHdpdGggdGhlIHNhbWUgZGF0YSB0eXBlIGFzIGlucHV0IGFycmF5IChcIiArIGRhdGFUeXBlICsgXCIgZGF0YSB0eXBlKVwiLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRcdFx0dmFyIHggPSBjb250ZXh0LmFycmF5KHhSZWYsIG5ldyBmdXJpb3VzLkRhdGFUeXBlKGRhdGFUeXBlKSk7XHJcblx0XHRcdFx0XHRcdHZhciB5ID0gY29udGV4dC5uZWcoeCk7XHJcblx0XHRcdFx0XHRcdGV4cGVjdCh5LmRhdGFUeXBlLmVxdWFscyhuZXcgZnVyaW91cy5EYXRhVHlwZShkYXRhVHlwZSkpKS50by5iZS50cnVlO1xyXG5cdFx0XHRcdFx0XHR5LmludmFsaWRhdGUoKTtcclxuXHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdH0pKGRhdGFUeXBlc1tpXSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YVR5cGVzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0KGZ1bmN0aW9uKGRhdGFUeXBlKSB7XHJcblx0XHRcdFx0XHRpdChcIkNyZWF0ZXMgYW4gb3V0cHV0IGFycmF5IHdpdGggbmVnYXRlZCBlbGVtZW50cyAoXCIgKyBkYXRhVHlwZSArIFwiIGRhdGEgdHlwZSlcIiwgZnVuY3Rpb24oZG9uZSkge1xyXG5cdFx0XHRcdFx0XHR2YXIgeCA9IGNvbnRleHQuYXJyYXkoeFJlZiwgbmV3IGZ1cmlvdXMuRGF0YVR5cGUoZGF0YVR5cGUpKTtcclxuXHRcdFx0XHRcdFx0dmFyIHkgPSBjb250ZXh0Lm5lZyh4KTtcclxuXHRcdFx0XHRcdFx0eS5nZXQoZnVuY3Rpb24oeSkge1xyXG5cdFx0XHRcdFx0XHRcdGV4cGVjdCh5KS50by5kZWVwLmVxdWFsKHlSZWYpO1xyXG5cdFx0XHRcdFx0XHRcdGRvbmUoKTtcclxuXHRcdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHR9KShkYXRhVHlwZXNbaV0pO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHRcdGRlc2NyaWJlKFwiV2l0aCBhbiBvdXRwdXQgYXJyYXlcIiwgZnVuY3Rpb24oKSB7XHJcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YVR5cGVzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0KGZ1bmN0aW9uKGRhdGFUeXBlKSB7XHJcblx0XHRcdFx0XHRpdChcIlBvcHVsYXRlcyB0aGUgb3V0cHV0IGFycmF5IHdpdGggbmVnYXRlZCBlbGVtZW50cyAoXCIgKyBkYXRhVHlwZSArIFwiIGRhdGEgdHlwZSlcIiwgZnVuY3Rpb24oZG9uZSkge1xyXG5cdFx0XHRcdFx0XHR2YXIgeCA9IGNvbnRleHQuYXJyYXkoeFJlZiwgbmV3IGZ1cmlvdXMuRGF0YVR5cGUoZGF0YVR5cGUpKTtcclxuXHRcdFx0XHRcdFx0dmFyIHkgPSBjb250ZXh0Lm9uZXMoeC5zaGFwZSwgeC5kYXRhVHlwZSk7XHJcblx0XHRcdFx0XHRcdGNvbnRleHQubmVnKHgsIHkpO1xyXG5cdFx0XHRcdFx0XHR5LmdldChmdW5jdGlvbih5KSB7XHJcblx0XHRcdFx0XHRcdFx0ZXhwZWN0KHkpLnRvLmRlZXAuZXF1YWwoeVJlZik7XHJcblx0XHRcdFx0XHRcdFx0ZG9uZSgpO1xyXG5cdFx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdH0pKGRhdGFUeXBlc1tpXSk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdH0pO1xyXG5cdGRlc2NyaWJlKFwiYWJzXCIsIGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIHhSZWYgPSBbMSwgLTcuNSwgMCwgLTE1XTtcclxuXHRcdHZhciB5UmVmID0gWzEsICA3LjUsIDAsICAxNV07XHJcblx0XHR2YXIgZGF0YVR5cGVzID0gW1wiZjMyXCIsIFwiZjY0XCJdO1xyXG5cclxuXHRcdGRlc2NyaWJlKFwiV2l0aCBubyBvdXRwdXQgYXJyYXkgc3VwcGxpZWRcIiwgZnVuY3Rpb24oKSB7XHJcblx0XHRcdGl0KFwiQ3JlYXRlcyBhbiBvdXRwdXQgYXJyYXkgd2l0aCB0aGUgc2FtZSBzaGFwZSBhcyBpbnB1dCBhcnJheVwiLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHR2YXIgeCA9IGNvbnRleHQub25lcyhbMiwgMywgNF0pO1xyXG5cdFx0XHRcdHZhciB5ID0gY29udGV4dC5hYnMoeCk7XHJcblx0XHRcdFx0ZXhwZWN0KHkuc2hhcGUpLnRvLmRlZXAuZXF1YWwoWzIsIDMsIDRdKTtcclxuXHRcdFx0XHR5LmludmFsaWRhdGUoKTtcclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGRhdGFUeXBlcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdChmdW5jdGlvbihkYXRhVHlwZSkge1xyXG5cdFx0XHRcdFx0aXQoXCJDcmVhdGVzIGFuIG91dHB1dCBhcnJheSB3aXRoIHRoZSBzYW1lIGRhdGEgdHlwZSBhcyBpbnB1dCBhcnJheSAoXCIgKyBkYXRhVHlwZSArIFwiIGRhdGEgdHlwZSlcIiwgZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHRcdHZhciB4ID0gY29udGV4dC5hcnJheSh4UmVmLCBuZXcgZnVyaW91cy5EYXRhVHlwZShkYXRhVHlwZSkpO1xyXG5cdFx0XHRcdFx0XHR2YXIgeSA9IGNvbnRleHQuYWJzKHgpO1xyXG5cdFx0XHRcdFx0XHRleHBlY3QoeS5kYXRhVHlwZS5lcXVhbHMobmV3IGZ1cmlvdXMuRGF0YVR5cGUoZGF0YVR5cGUpKSkudG8uYmUudHJ1ZTtcclxuXHRcdFx0XHRcdFx0eS5pbnZhbGlkYXRlKCk7XHJcblx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHR9KShkYXRhVHlwZXNbaV0pO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGRhdGFUeXBlcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdChmdW5jdGlvbihkYXRhVHlwZSkge1xyXG5cdFx0XHRcdFx0aXQoXCJDcmVhdGVzIGFuIG91dHB1dCBhcnJheSB3aXRoIGFic29sdXRlIHZhbHVlcyBvZiBlbGVtZW50cyAoXCIgKyBkYXRhVHlwZSArIFwiIGRhdGEgdHlwZSlcIiwgZnVuY3Rpb24oZG9uZSkge1xyXG5cdFx0XHRcdFx0XHR2YXIgeCA9IGNvbnRleHQuYXJyYXkoeFJlZiwgbmV3IGZ1cmlvdXMuRGF0YVR5cGUoZGF0YVR5cGUpKTtcclxuXHRcdFx0XHRcdFx0dmFyIHkgPSBjb250ZXh0LmFicyh4KTtcclxuXHRcdFx0XHRcdFx0eS5nZXQoZnVuY3Rpb24oeSkge1xyXG5cdFx0XHRcdFx0XHRcdGV4cGVjdCh5KS50by5kZWVwLmVxdWFsKHlSZWYpO1xyXG5cdFx0XHRcdFx0XHRcdGRvbmUoKTtcclxuXHRcdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHR9KShkYXRhVHlwZXNbaV0pO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHRcdGRlc2NyaWJlKFwiV2l0aCBhbiBvdXRwdXQgYXJyYXlcIiwgZnVuY3Rpb24oKSB7XHJcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YVR5cGVzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0KGZ1bmN0aW9uKGRhdGFUeXBlKSB7XHJcblx0XHRcdFx0XHRpdChcIlBvcHVsYXRlcyB0aGUgb3V0cHV0IGFycmF5IHdpdGggYWJzb2x1dGUgdmFsdWVzIG9mIGVsZW1lbnRzIChcIiArIGRhdGFUeXBlICsgXCIgZGF0YSB0eXBlKVwiLCBmdW5jdGlvbihkb25lKSB7XHJcblx0XHRcdFx0XHRcdHZhciB4ID0gY29udGV4dC5hcnJheSh4UmVmLCBuZXcgZnVyaW91cy5EYXRhVHlwZShkYXRhVHlwZSkpO1xyXG5cdFx0XHRcdFx0XHR2YXIgeSA9IGNvbnRleHQub25lcyh4LnNoYXBlLCB4LmRhdGFUeXBlKTtcclxuXHRcdFx0XHRcdFx0Y29udGV4dC5hYnMoeCwgeSk7XHJcblx0XHRcdFx0XHRcdHkuZ2V0KGZ1bmN0aW9uKHkpIHtcclxuXHRcdFx0XHRcdFx0XHRleHBlY3QoeSkudG8uZGVlcC5lcXVhbCh5UmVmKTtcclxuXHRcdFx0XHRcdFx0XHRkb25lKCk7XHJcblx0XHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0fSkoZGF0YVR5cGVzW2ldKTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0fSk7XHJcblx0ZGVzY3JpYmUoXCJleHBcIiwgZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgeFJlZiA9IFsxLCAtMSwgMF07XHJcblx0XHR2YXIgZGF0YVR5cGVzID0gW1wiZjMyXCIsIFwiZjY0XCJdO1xyXG5cclxuXHRcdGRlc2NyaWJlKFwiV2l0aCBubyBvdXRwdXQgYXJyYXkgc3VwcGxpZWRcIiwgZnVuY3Rpb24oKSB7XHJcblx0XHRcdGl0KFwiQ3JlYXRlcyBhbiBvdXRwdXQgYXJyYXkgd2l0aCB0aGUgc2FtZSBzaGFwZSBhcyBpbnB1dCBhcnJheVwiLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHR2YXIgeCA9IGNvbnRleHQub25lcyhbMiwgMywgNF0pO1xyXG5cdFx0XHRcdHZhciB5ID0gY29udGV4dC5leHAoeCk7XHJcblx0XHRcdFx0ZXhwZWN0KHkuc2hhcGUpLnRvLmRlZXAuZXF1YWwoWzIsIDMsIDRdKTtcclxuXHRcdFx0XHR5LmludmFsaWRhdGUoKTtcclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGRhdGFUeXBlcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdChmdW5jdGlvbihkYXRhVHlwZSkge1xyXG5cdFx0XHRcdFx0aXQoXCJDcmVhdGVzIGFuIG91dHB1dCBhcnJheSB3aXRoIHRoZSBzYW1lIGRhdGEgdHlwZSBhcyBpbnB1dCBhcnJheSAoXCIgKyBkYXRhVHlwZSArIFwiIGRhdGEgdHlwZSlcIiwgZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHRcdHZhciB4ID0gY29udGV4dC5hcnJheSh4UmVmLCBuZXcgZnVyaW91cy5EYXRhVHlwZShkYXRhVHlwZSkpO1xyXG5cdFx0XHRcdFx0XHR2YXIgeSA9IGNvbnRleHQuZXhwKHgpO1xyXG5cdFx0XHRcdFx0XHRleHBlY3QoeS5kYXRhVHlwZS5lcXVhbHMobmV3IGZ1cmlvdXMuRGF0YVR5cGUoZGF0YVR5cGUpKSkudG8uYmUudHJ1ZTtcclxuXHRcdFx0XHRcdFx0eS5pbnZhbGlkYXRlKCk7XHJcblx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHR9KShkYXRhVHlwZXNbaV0pO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGRhdGFUeXBlcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdChmdW5jdGlvbihkYXRhVHlwZSkge1xyXG5cdFx0XHRcdFx0aXQoXCJDcmVhdGVzIGFuIG91dHB1dCBhcnJheSB3aXRoIGFic29sdXRlIHZhbHVlcyBvZiBlbGVtZW50cyAoXCIgKyBkYXRhVHlwZSArIFwiIGRhdGEgdHlwZSlcIiwgZnVuY3Rpb24oZG9uZSkge1xyXG5cdFx0XHRcdFx0XHR2YXIgeCA9IGNvbnRleHQuYXJyYXkoeFJlZiwgbmV3IGZ1cmlvdXMuRGF0YVR5cGUoZGF0YVR5cGUpKTtcclxuXHRcdFx0XHRcdFx0dmFyIHkgPSBjb250ZXh0LmV4cCh4KTtcclxuXHRcdFx0XHRcdFx0eS5nZXQoZnVuY3Rpb24oeSkge1xyXG5cdFx0XHRcdFx0XHRcdGZvciAodmFyIGsgPSAwOyBrIDwgeS5sZW5ndGg7IGsrKykge1xyXG5cdFx0XHRcdFx0XHRcdFx0ZXhwZWN0KHlba10pLnRvLmJlLmNsb3NlVG8oTWF0aC5leHAoeFJlZltrXSksIE1hdGguZXhwKHhSZWZba10pICogMyAqIHguZGF0YVR5cGUuZXBzaWxvbik7XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdGRvbmUoKTtcclxuXHRcdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHR9KShkYXRhVHlwZXNbaV0pO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHRcdGRlc2NyaWJlKFwiV2l0aCBhbiBvdXRwdXQgYXJyYXlcIiwgZnVuY3Rpb24oKSB7XHJcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YVR5cGVzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0KGZ1bmN0aW9uKGRhdGFUeXBlKSB7XHJcblx0XHRcdFx0XHRpdChcIlBvcHVsYXRlcyB0aGUgb3V0cHV0IGFycmF5IHdpdGggYWJzb2x1dGUgdmFsdWVzIG9mIGVsZW1lbnRzIChcIiArIGRhdGFUeXBlICsgXCIgZGF0YSB0eXBlKVwiLCBmdW5jdGlvbihkb25lKSB7XHJcblx0XHRcdFx0XHRcdHZhciB4ID0gY29udGV4dC5hcnJheSh4UmVmLCBuZXcgZnVyaW91cy5EYXRhVHlwZShkYXRhVHlwZSkpO1xyXG5cdFx0XHRcdFx0XHR2YXIgeSA9IGNvbnRleHQub25lcyh4LnNoYXBlLCB4LmRhdGFUeXBlKTtcclxuXHRcdFx0XHRcdFx0Y29udGV4dC5leHAoeCwgeSk7XHJcblx0XHRcdFx0XHRcdHkuZ2V0KGZ1bmN0aW9uKHkpIHtcclxuXHRcdFx0XHRcdFx0XHRmb3IgKHZhciBrID0gMDsgayA8IHkubGVuZ3RoOyBrKyspIHtcclxuXHRcdFx0XHRcdFx0XHRcdGV4cGVjdCh5W2tdKS50by5iZS5jbG9zZVRvKE1hdGguZXhwKHhSZWZba10pLCBNYXRoLmV4cCh4UmVmW2tdKSAqIDMgKiB4LmRhdGFUeXBlLmVwc2lsb24pO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRkb25lKCk7XHJcblx0XHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0fSkoZGF0YVR5cGVzW2ldKTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0fSk7XHJcblx0ZGVzY3JpYmUoXCJsb2dcIiwgZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgeFJlZiA9IFsxLCAzLCAxMF07XHJcblx0XHR2YXIgZGF0YVR5cGVzID0gW1wiZjMyXCIsIFwiZjY0XCJdO1xyXG5cclxuXHRcdGRlc2NyaWJlKFwiV2l0aCBubyBvdXRwdXQgYXJyYXkgc3VwcGxpZWRcIiwgZnVuY3Rpb24oKSB7XHJcblx0XHRcdGl0KFwiQ3JlYXRlcyBhbiBvdXRwdXQgYXJyYXkgd2l0aCB0aGUgc2FtZSBzaGFwZSBhcyBpbnB1dCBhcnJheVwiLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHR2YXIgeCA9IGNvbnRleHQub25lcyhbMiwgMywgNF0pO1xyXG5cdFx0XHRcdHZhciB5ID0gY29udGV4dC5sb2coeCk7XHJcblx0XHRcdFx0ZXhwZWN0KHkuc2hhcGUpLnRvLmRlZXAuZXF1YWwoWzIsIDMsIDRdKTtcclxuXHRcdFx0XHR5LmludmFsaWRhdGUoKTtcclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGRhdGFUeXBlcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdChmdW5jdGlvbihkYXRhVHlwZSkge1xyXG5cdFx0XHRcdFx0aXQoXCJDcmVhdGVzIGFuIG91dHB1dCBhcnJheSB3aXRoIHRoZSBzYW1lIGRhdGEgdHlwZSBhcyBpbnB1dCBhcnJheSAoXCIgKyBkYXRhVHlwZSArIFwiIGRhdGEgdHlwZSlcIiwgZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHRcdHZhciB4ID0gY29udGV4dC5hcnJheSh4UmVmLCBuZXcgZnVyaW91cy5EYXRhVHlwZShkYXRhVHlwZSkpO1xyXG5cdFx0XHRcdFx0XHR2YXIgeSA9IGNvbnRleHQubG9nKHgpO1xyXG5cdFx0XHRcdFx0XHRleHBlY3QoeS5kYXRhVHlwZS5lcXVhbHMobmV3IGZ1cmlvdXMuRGF0YVR5cGUoZGF0YVR5cGUpKSkudG8uYmUudHJ1ZTtcclxuXHRcdFx0XHRcdFx0eS5pbnZhbGlkYXRlKCk7XHJcblx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHR9KShkYXRhVHlwZXNbaV0pO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGRhdGFUeXBlcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdChmdW5jdGlvbihkYXRhVHlwZSkge1xyXG5cdFx0XHRcdFx0aXQoXCJDcmVhdGVzIGFuIG91dHB1dCBhcnJheSB3aXRoIGFic29sdXRlIHZhbHVlcyBvZiBlbGVtZW50cyAoXCIgKyBkYXRhVHlwZSArIFwiIGRhdGEgdHlwZSlcIiwgZnVuY3Rpb24oZG9uZSkge1xyXG5cdFx0XHRcdFx0XHR2YXIgeCA9IGNvbnRleHQuYXJyYXkoeFJlZiwgbmV3IGZ1cmlvdXMuRGF0YVR5cGUoZGF0YVR5cGUpKTtcclxuXHRcdFx0XHRcdFx0dmFyIHkgPSBjb250ZXh0LmxvZyh4KTtcclxuXHRcdFx0XHRcdFx0eS5nZXQoZnVuY3Rpb24oeSkge1xyXG5cdFx0XHRcdFx0XHRcdGZvciAodmFyIGsgPSAwOyBrIDwgeS5sZW5ndGg7IGsrKykge1xyXG5cdFx0XHRcdFx0XHRcdFx0ZXhwZWN0KHlba10pLnRvLmJlLmNsb3NlVG8oTWF0aC5sb2coeFJlZltrXSksIE1hdGgubG9nKHhSZWZba10pICogMyAqIHguZGF0YVR5cGUuZXBzaWxvbik7XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdGRvbmUoKTtcclxuXHRcdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHR9KShkYXRhVHlwZXNbaV0pO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHRcdGRlc2NyaWJlKFwiV2l0aCBhbiBvdXRwdXQgYXJyYXlcIiwgZnVuY3Rpb24oKSB7XHJcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YVR5cGVzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0KGZ1bmN0aW9uKGRhdGFUeXBlKSB7XHJcblx0XHRcdFx0XHRpdChcIlBvcHVsYXRlcyB0aGUgb3V0cHV0IGFycmF5IHdpdGggYWJzb2x1dGUgdmFsdWVzIG9mIGVsZW1lbnRzIChcIiArIGRhdGFUeXBlICsgXCIgZGF0YSB0eXBlKVwiLCBmdW5jdGlvbihkb25lKSB7XHJcblx0XHRcdFx0XHRcdHZhciB4ID0gY29udGV4dC5hcnJheSh4UmVmLCBuZXcgZnVyaW91cy5EYXRhVHlwZShkYXRhVHlwZSkpO1xyXG5cdFx0XHRcdFx0XHR2YXIgeSA9IGNvbnRleHQub25lcyh4LnNoYXBlLCB4LmRhdGFUeXBlKTtcclxuXHRcdFx0XHRcdFx0Y29udGV4dC5sb2coeCwgeSk7XHJcblx0XHRcdFx0XHRcdHkuZ2V0KGZ1bmN0aW9uKHkpIHtcclxuXHRcdFx0XHRcdFx0XHRmb3IgKHZhciBrID0gMDsgayA8IHkubGVuZ3RoOyBrKyspIHtcclxuXHRcdFx0XHRcdFx0XHRcdGV4cGVjdCh5W2tdKS50by5iZS5jbG9zZVRvKE1hdGgubG9nKHhSZWZba10pLCBNYXRoLmxvZyh4UmVmW2tdKSAqIDMgKiB4LmRhdGFUeXBlLmVwc2lsb24pO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRkb25lKCk7XHJcblx0XHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0fSkoZGF0YVR5cGVzW2ldKTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0fSk7XHJcblx0ZGVzY3JpYmUoXCJzcXJ0XCIsIGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIHhSZWYgPSBbMCwgMC4yNSwgMSwgOSwgMTBdO1xyXG5cdFx0dmFyIGRhdGFUeXBlcyA9IFtcImYzMlwiLCBcImY2NFwiXTtcclxuXHJcblx0XHRkZXNjcmliZShcIldpdGggbm8gb3V0cHV0IGFycmF5IHN1cHBsaWVkXCIsIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRpdChcIkNyZWF0ZXMgYW4gb3V0cHV0IGFycmF5IHdpdGggdGhlIHNhbWUgc2hhcGUgYXMgaW5wdXQgYXJyYXlcIiwgZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0dmFyIHggPSBjb250ZXh0Lm9uZXMoWzIsIDMsIDRdKTtcclxuXHRcdFx0XHR2YXIgeSA9IGNvbnRleHQuc3FydCh4KTtcclxuXHRcdFx0XHRleHBlY3QoeS5zaGFwZSkudG8uZGVlcC5lcXVhbChbMiwgMywgNF0pO1xyXG5cdFx0XHRcdHkuaW52YWxpZGF0ZSgpO1xyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YVR5cGVzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0KGZ1bmN0aW9uKGRhdGFUeXBlKSB7XHJcblx0XHRcdFx0XHRpdChcIkNyZWF0ZXMgYW4gb3V0cHV0IGFycmF5IHdpdGggdGhlIHNhbWUgZGF0YSB0eXBlIGFzIGlucHV0IGFycmF5IChcIiArIGRhdGFUeXBlICsgXCIgZGF0YSB0eXBlKVwiLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRcdFx0dmFyIHggPSBjb250ZXh0LmFycmF5KHhSZWYsIG5ldyBmdXJpb3VzLkRhdGFUeXBlKGRhdGFUeXBlKSk7XHJcblx0XHRcdFx0XHRcdHZhciB5ID0gY29udGV4dC5zcXJ0KHgpO1xyXG5cdFx0XHRcdFx0XHRleHBlY3QoeS5kYXRhVHlwZS5lcXVhbHMobmV3IGZ1cmlvdXMuRGF0YVR5cGUoZGF0YVR5cGUpKSkudG8uYmUudHJ1ZTtcclxuXHRcdFx0XHRcdFx0eS5pbnZhbGlkYXRlKCk7XHJcblx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHR9KShkYXRhVHlwZXNbaV0pO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGRhdGFUeXBlcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdChmdW5jdGlvbihkYXRhVHlwZSkge1xyXG5cdFx0XHRcdFx0aXQoXCJDcmVhdGVzIGFuIG91dHB1dCBhcnJheSB3aXRoIGFic29sdXRlIHZhbHVlcyBvZiBlbGVtZW50cyAoXCIgKyBkYXRhVHlwZSArIFwiIGRhdGEgdHlwZSlcIiwgZnVuY3Rpb24oZG9uZSkge1xyXG5cdFx0XHRcdFx0XHR2YXIgeCA9IGNvbnRleHQuYXJyYXkoeFJlZiwgbmV3IGZ1cmlvdXMuRGF0YVR5cGUoZGF0YVR5cGUpKTtcclxuXHRcdFx0XHRcdFx0dmFyIHkgPSBjb250ZXh0LnNxcnQoeCk7XHJcblx0XHRcdFx0XHRcdHkuZ2V0KGZ1bmN0aW9uKHkpIHtcclxuXHRcdFx0XHRcdFx0XHRmb3IgKHZhciBrID0gMDsgayA8IHkubGVuZ3RoOyBrKyspIHtcclxuXHRcdFx0XHRcdFx0XHRcdGV4cGVjdCh5W2tdKS50by5iZS5jbG9zZVRvKE1hdGguc3FydCh4UmVmW2tdKSwgTWF0aC5zcXJ0KHhSZWZba10pICogMyAqIHguZGF0YVR5cGUuZXBzaWxvbik7XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdGRvbmUoKTtcclxuXHRcdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHR9KShkYXRhVHlwZXNbaV0pO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHRcdGRlc2NyaWJlKFwiV2l0aCBhbiBvdXRwdXQgYXJyYXlcIiwgZnVuY3Rpb24oKSB7XHJcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YVR5cGVzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0KGZ1bmN0aW9uKGRhdGFUeXBlKSB7XHJcblx0XHRcdFx0XHRpdChcIlBvcHVsYXRlcyB0aGUgb3V0cHV0IGFycmF5IHdpdGggYWJzb2x1dGUgdmFsdWVzIG9mIGVsZW1lbnRzIChcIiArIGRhdGFUeXBlICsgXCIgZGF0YSB0eXBlKVwiLCBmdW5jdGlvbihkb25lKSB7XHJcblx0XHRcdFx0XHRcdHZhciB4ID0gY29udGV4dC5hcnJheSh4UmVmLCBuZXcgZnVyaW91cy5EYXRhVHlwZShkYXRhVHlwZSkpO1xyXG5cdFx0XHRcdFx0XHR2YXIgeSA9IGNvbnRleHQub25lcyh4LnNoYXBlLCB4LmRhdGFUeXBlKTtcclxuXHRcdFx0XHRcdFx0Y29udGV4dC5zcXJ0KHgsIHkpO1xyXG5cdFx0XHRcdFx0XHR5LmdldChmdW5jdGlvbih5KSB7XHJcblx0XHRcdFx0XHRcdFx0Zm9yICh2YXIgayA9IDA7IGsgPCB5Lmxlbmd0aDsgaysrKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRleHBlY3QoeVtrXSkudG8uYmUuY2xvc2VUbyhNYXRoLnNxcnQoeFJlZltrXSksIE1hdGguc3FydCh4UmVmW2tdKSAqIDMgKiB4LmRhdGFUeXBlLmVwc2lsb24pO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRkb25lKCk7XHJcblx0XHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0fSkoZGF0YVR5cGVzW2ldKTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0fSk7XHJcblx0ZGVzY3JpYmUoXCJzcXVhcmVcIiwgZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgeFJlZiA9IFstMiwgMCwgMC41LCAxLCAzXTtcclxuXHRcdHZhciBkYXRhVHlwZXMgPSBbXCJmMzJcIiwgXCJmNjRcIl07XHJcblxyXG5cdFx0ZGVzY3JpYmUoXCJXaXRoIG5vIG91dHB1dCBhcnJheSBzdXBwbGllZFwiLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0aXQoXCJDcmVhdGVzIGFuIG91dHB1dCBhcnJheSB3aXRoIHRoZSBzYW1lIHNoYXBlIGFzIGlucHV0IGFycmF5XCIsIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHZhciB4ID0gY29udGV4dC5vbmVzKFsyLCAzLCA0XSk7XHJcblx0XHRcdFx0dmFyIHkgPSBjb250ZXh0LnNxdWFyZSh4KTtcclxuXHRcdFx0XHRleHBlY3QoeS5zaGFwZSkudG8uZGVlcC5lcXVhbChbMiwgMywgNF0pO1xyXG5cdFx0XHRcdHkuaW52YWxpZGF0ZSgpO1xyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YVR5cGVzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0KGZ1bmN0aW9uKGRhdGFUeXBlKSB7XHJcblx0XHRcdFx0XHRpdChcIkNyZWF0ZXMgYW4gb3V0cHV0IGFycmF5IHdpdGggdGhlIHNhbWUgZGF0YSB0eXBlIGFzIGlucHV0IGFycmF5IChcIiArIGRhdGFUeXBlICsgXCIgZGF0YSB0eXBlKVwiLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRcdFx0dmFyIHggPSBjb250ZXh0LmFycmF5KHhSZWYsIG5ldyBmdXJpb3VzLkRhdGFUeXBlKGRhdGFUeXBlKSk7XHJcblx0XHRcdFx0XHRcdHZhciB5ID0gY29udGV4dC5zcXVhcmUoeCk7XHJcblx0XHRcdFx0XHRcdGV4cGVjdCh5LmRhdGFUeXBlLmVxdWFscyhuZXcgZnVyaW91cy5EYXRhVHlwZShkYXRhVHlwZSkpKS50by5iZS50cnVlO1xyXG5cdFx0XHRcdFx0XHR5LmludmFsaWRhdGUoKTtcclxuXHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdH0pKGRhdGFUeXBlc1tpXSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YVR5cGVzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0KGZ1bmN0aW9uKGRhdGFUeXBlKSB7XHJcblx0XHRcdFx0XHRpdChcIkNyZWF0ZXMgYW4gb3V0cHV0IGFycmF5IHdpdGggYWJzb2x1dGUgdmFsdWVzIG9mIGVsZW1lbnRzIChcIiArIGRhdGFUeXBlICsgXCIgZGF0YSB0eXBlKVwiLCBmdW5jdGlvbihkb25lKSB7XHJcblx0XHRcdFx0XHRcdHZhciB4ID0gY29udGV4dC5hcnJheSh4UmVmLCBuZXcgZnVyaW91cy5EYXRhVHlwZShkYXRhVHlwZSkpO1xyXG5cdFx0XHRcdFx0XHR2YXIgeSA9IGNvbnRleHQuc3F1YXJlKHgpO1xyXG5cdFx0XHRcdFx0XHR5LmdldChmdW5jdGlvbih5KSB7XHJcblx0XHRcdFx0XHRcdFx0Zm9yICh2YXIgayA9IDA7IGsgPCB5Lmxlbmd0aDsgaysrKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRleHBlY3QoeVtrXSkudG8uYmUuY2xvc2VUbyh4UmVmW2tdICogeFJlZltrXSwgeFJlZltrXSAqIHhSZWZba10gKiB4LmRhdGFUeXBlLmVwc2lsb24pO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRkb25lKCk7XHJcblx0XHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0fSkoZGF0YVR5cGVzW2ldKTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0XHRkZXNjcmliZShcIldpdGggYW4gb3V0cHV0IGFycmF5XCIsIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGRhdGFUeXBlcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdChmdW5jdGlvbihkYXRhVHlwZSkge1xyXG5cdFx0XHRcdFx0aXQoXCJQb3B1bGF0ZXMgdGhlIG91dHB1dCBhcnJheSB3aXRoIGFic29sdXRlIHZhbHVlcyBvZiBlbGVtZW50cyAoXCIgKyBkYXRhVHlwZSArIFwiIGRhdGEgdHlwZSlcIiwgZnVuY3Rpb24oZG9uZSkge1xyXG5cdFx0XHRcdFx0XHR2YXIgeCA9IGNvbnRleHQuYXJyYXkoeFJlZiwgbmV3IGZ1cmlvdXMuRGF0YVR5cGUoZGF0YVR5cGUpKTtcclxuXHRcdFx0XHRcdFx0dmFyIHkgPSBjb250ZXh0Lm9uZXMoeC5zaGFwZSwgeC5kYXRhVHlwZSk7XHJcblx0XHRcdFx0XHRcdGNvbnRleHQuc3F1YXJlKHgsIHkpO1xyXG5cdFx0XHRcdFx0XHR5LmdldChmdW5jdGlvbih5KSB7XHJcblx0XHRcdFx0XHRcdFx0Zm9yICh2YXIgayA9IDA7IGsgPCB5Lmxlbmd0aDsgaysrKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRleHBlY3QoeVtrXSkudG8uYmUuY2xvc2VUbyh4UmVmW2tdICogeFJlZltrXSwgeFJlZltrXSAqIHhSZWZba10gKiB4LmRhdGFUeXBlLmVwc2lsb24pO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRkb25lKCk7XHJcblx0XHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0fSkoZGF0YVR5cGVzW2ldKTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0fSk7XHJcbn0pO1xyXG4iLCJ2YXIgZnVyaW91cyA9IHJlcXVpcmUoXCIuLi9saWIvZnVyaW91cy5qc1wiKTtcclxudmFyIGV4cGVjdCA9IHJlcXVpcmUoXCJjaGFpXCIpLmV4cGVjdDtcclxuXHJcbmRlc2NyaWJlKFwiRGF0YVR5cGVcIiwgZnVuY3Rpb24oKXtcclxuXHRkZXNjcmliZShcImYzMlwiLCBmdW5jdGlvbigpe1xyXG5cdFx0aXQoXCJzaG91bGQgaGF2ZSBzaXplIDRcIiwgZnVuY3Rpb24oKXtcclxuXHRcdFx0dmFyIGR0eXBlID0gbmV3IGZ1cmlvdXMuRGF0YVR5cGUoXCJmMzJcIik7XHJcblx0XHRcdGV4cGVjdChkdHlwZS5zaXplKS50by5lcXVhbCg0KTtcclxuXHRcdH0pO1xyXG5cclxuXHRcdGl0KFwic2hvdWxkIGhhdmUgdHlwZSBcXFwiZjMyXFxcIlwiLCBmdW5jdGlvbigpe1xyXG5cdFx0XHR2YXIgZHR5cGUgPSBuZXcgZnVyaW91cy5EYXRhVHlwZShcImYzMlwiKTtcclxuXHRcdFx0ZXhwZWN0KGR0eXBlLnR5cGUpLnRvLmVxdWFsKFwiZjMyXCIpO1xyXG5cdFx0fSk7XHJcblx0fSk7XHJcblx0ZGVzY3JpYmUoXCJmNjRcIiwgZnVuY3Rpb24oKXtcclxuXHRcdGl0KFwic2hvdWxkIGhhdmUgc2l6ZSA4XCIsIGZ1bmN0aW9uKCl7XHJcblx0XHRcdHZhciBkdHlwZSA9IG5ldyBmdXJpb3VzLkRhdGFUeXBlKFwiZjY0XCIpO1xyXG5cdFx0XHRleHBlY3QoZHR5cGUuc2l6ZSkudG8uZXF1YWwoOCk7XHJcblx0XHR9KTtcclxuXHJcblx0XHRpdChcInNob3VsZCBoYXZlIHR5cGUgXFxcImY2NFxcXCJcIiwgZnVuY3Rpb24oKXtcclxuXHRcdFx0dmFyIGR0eXBlID0gbmV3IGZ1cmlvdXMuRGF0YVR5cGUoXCJmNjRcIik7XHJcblx0XHRcdGV4cGVjdChkdHlwZS50eXBlKS50by5lcXVhbChcImY2NFwiKTtcclxuXHRcdH0pO1xyXG5cdH0pO1xyXG59KTtcclxuIiwidmFyIGZ1cmlvdXMgPSByZXF1aXJlKFwiLi4vbGliL2Z1cmlvdXMuanNcIik7XHJcbnZhciBleHBlY3QgPSByZXF1aXJlKFwiY2hhaVwiKS5leHBlY3Q7XHJcblxyXG52YXIgY29udGV4dCA9IG51bGw7XHJcbmJlZm9yZShmdW5jdGlvbihkb25lKSB7XHJcblx0ZnVyaW91cy5pbml0KGZ1bmN0aW9uKGN0eCkge1xyXG5cdFx0Y29udGV4dCA9IGN0eDtcclxuXHRcdGRvbmUoKTtcclxuXHR9KTtcclxufSk7XHJcblxyXG5kZXNjcmliZShcIk5EQXJyYXlcIiwgZnVuY3Rpb24oKSB7XHJcblx0ZGVzY3JpYmUoXCJsZW5ndGhcIiwgZnVuY3Rpb24oKSB7XHJcblx0XHRpdChcIkVxdWFscyB0byB0aGUgbnVtYmVyIHBhc3NlZCBpbiBjb25zdHJ1Y3RvclwiLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0dmFyIHggPSBjb250ZXh0LmVtcHR5KDQyKTtcclxuXHRcdFx0ZXhwZWN0KHgubGVuZ3RoKS50by5lcXVhbCg0Mik7XHJcblx0XHRcdHguaW52YWxpZGF0ZSgpO1xyXG5cdFx0fSk7XHJcblx0XHRpdChcIkVxdWFscyB0byB0aGUgbnVtYmVyIHBhc3NlZCBpbiBjb25zdHJ1Y3RvciBhcyBhbiBhcnJheVwiLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0dmFyIHggPSBjb250ZXh0LmVtcHR5KFs0Ml0pO1xyXG5cdFx0XHRleHBlY3QoeC5sZW5ndGgpLnRvLmVxdWFsKDQyKTtcclxuXHRcdFx0eC5pbnZhbGlkYXRlKCk7XHJcblx0XHR9KTtcclxuXHRcdGl0KFwiRXF1YWxzIHRvIHRoZSBwcm9kdWN0IG9mIGRpbWVuc2lvbnNcIiwgZnVuY3Rpb24oKSB7XHJcblx0XHRcdHZhciB4ID0gY29udGV4dC5lbXB0eShbMiwgNSwgM10pO1xyXG5cdFx0XHRleHBlY3QoeC5sZW5ndGgpLnRvLmVxdWFsKDMwKTtcclxuXHRcdFx0eC5pbnZhbGlkYXRlKCk7XHJcblx0XHR9KTtcclxuXHR9KTtcclxuXHRkZXNjcmliZShcInJlc2hhcGVcIiwgZnVuY3Rpb24oKSB7XHJcblx0XHRpdChcIlByZXNlcnZlcyBsZW5ndGhcIiwgZnVuY3Rpb24oKSB7XHJcblx0XHRcdHZhciB4ID0gY29udGV4dC5lbXB0eShbNyw1LDNdKTtcclxuXHRcdFx0dmFyIHkgPSB4LnJlc2hhcGUoWzIxLDVdKTtcclxuXHRcdFx0ZXhwZWN0KHkubGVuZ3RoKS50by5lcXVhbCh4Lmxlbmd0aCk7XHJcblx0XHRcdHkuaW52YWxpZGF0ZSgpO1xyXG5cdFx0fSk7XHJcblx0XHRpdChcIkNoYW5nZXMgc2hhcGVcIiwgZnVuY3Rpb24oKSB7XHJcblx0XHRcdHZhciB4ID0gY29udGV4dC5lbXB0eShbNyw1LDNdKTtcclxuXHRcdFx0dmFyIHkgPSB4LnJlc2hhcGUoWzIxLDVdKTtcclxuXHRcdFx0ZXhwZWN0KHkuc2hhcGUpLnRvLmRlZXAuZXF1YWwoWzIxLDVdKTtcclxuXHRcdFx0eS5pbnZhbGlkYXRlKCk7XHJcblx0XHR9KTtcclxuXHRcdGl0KFwiUmVhcnJhbmdlcyBkYXRhXCIsIGZ1bmN0aW9uKGRvbmUpIHtcclxuXHRcdFx0dmFyIHggPSBjb250ZXh0LmxpbnNwYWNlKDEsIDgsIDgpLnJlc2hhcGUoWzIsIDIsIDJdKTtcclxuXHRcdFx0eC5nZXQoZnVuY3Rpb24ocmVzdWx0KSB7XHJcblx0XHRcdFx0ZXhwZWN0KHJlc3VsdCkudG8uZGVlcC5lcXVhbChbW1sgMSwgIDJdLCBbIDMsICA0XV0sXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQgIFtbIDUsICA2XSwgWyA3LCAgOF1dXSk7XHJcblx0XHRcdFx0ZG9uZSgpO1xyXG5cdFx0XHR9KTtcclxuXHRcdH0pO1xyXG5cdH0pO1xyXG5cdGRlc2NyaWJlKFwicmVwZWF0XCIsIGZ1bmN0aW9uKCkge1xyXG5cdFx0aXQoXCJSZXBlYXRzIGFycmF5IGVsZW1lbnRzIGFsb25nIGF4aXMgMFwiLCBmdW5jdGlvbihkb25lKSB7XHJcblx0XHRcdHZhciB4ID0gY29udGV4dC5hcnJheShbWzgsIDEsIDZdLFxyXG5cdFx0XHQgICAgICAgICAgICAgICAgICAgICAgIFszLCA1LCA3XSxcclxuXHRcdFx0ICAgICAgICAgICAgICAgICAgICAgICBbNCwgOSwgMl1dKTtcclxuXHRcdFx0eC5yZXBlYXQoMiwgMCkuZ2V0KGZ1bmN0aW9uKHkpIHtcclxuXHRcdFx0XHRleHBlY3QoeSkudG8uZGVlcC5lcXVhbChbWzgsIDEsIDZdLFxyXG5cdFx0XHRcdCAgICAgICAgICAgICAgICAgICAgICAgICBbOCwgMSwgNl0sXHJcblx0XHRcdFx0ICAgICAgICAgICAgICAgICAgICAgICAgIFszLCA1LCA3XSxcclxuXHRcdFx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgWzMsIDUsIDddLFxyXG5cdFx0XHRcdCAgICAgICAgICAgICAgICAgICAgICAgICBbNCwgOSwgMl0sXHJcblx0XHRcdFx0ICAgICAgICAgICAgICAgICAgICAgICAgIFs0LCA5LCAyXV0pO1xyXG5cdFx0XHRcdGRvbmUoKTtcclxuXHRcdFx0fSk7XHJcblx0XHR9KTtcclxuXHRcdGl0KFwiUmVwZWF0cyBhcnJheSBlbGVtZW50cyBhbG9uZyBheGlzIDFcIiwgZnVuY3Rpb24oZG9uZSkge1xyXG5cdFx0XHR2YXIgeCA9IGNvbnRleHQuYXJyYXkoW1s4LCAxLCA2XSxcclxuXHRcdFx0ICAgICAgICAgICAgICAgICAgICAgICBbMywgNSwgN10sXHJcblx0XHRcdCAgICAgICAgICAgICAgICAgICAgICAgWzQsIDksIDJdXSk7XHJcblx0XHRcdHgucmVwZWF0KDIsIDEpLmdldChmdW5jdGlvbih5KSB7XHJcblx0XHRcdFx0ZXhwZWN0KHkpLnRvLmRlZXAuZXF1YWwoW1s4LCA4LCAxLCAxLCA2LCA2XSxcclxuXHRcdFx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgWzMsIDMsIDUsIDUsIDcsIDddLFxyXG5cdFx0XHRcdCAgICAgICAgICAgICAgICAgICAgICAgICBbNCwgNCwgOSwgOSwgMiwgMl1dKTtcclxuXHRcdFx0XHRkb25lKCk7XHJcblx0XHRcdH0pO1xyXG5cdFx0fSk7XHJcblx0fSk7XHJcblx0ZGVzY3JpYmUoXCJnZXRcIiwgZnVuY3Rpb24oKXtcclxuXHRcdGl0KFwiV29ya3Mgd2l0aCAxLWRpbWVuc2lvbmFsIGFycmF5XCIsIGZ1bmN0aW9uKGRvbmUpIHtcclxuXHRcdFx0dmFyIHggPSBjb250ZXh0LmFycmF5KFs0MiwgMTBdKTtcclxuXHRcdFx0eC5nZXQoZnVuY3Rpb24oeSkge1xyXG5cdFx0XHRcdGV4cGVjdCh5KS50by5kZWVwLmVxdWFsKFs0MiwgMTBdKTtcclxuXHRcdFx0XHRkb25lKCk7XHJcblx0XHRcdH0pO1xyXG5cdFx0fSk7XHJcblx0XHRpdChcIldvcmtzIHdpdGggMi1kaW1lbnNpb25hbCBhcnJheVwiLCBmdW5jdGlvbihkb25lKSB7XHJcblx0XHRcdHZhciBhcnJheSA9IFtbMTYsICAyLCAgMywgMTMsICA1XSxcclxuXHRcdFx0XHRcdFx0IFsxMSwgMTAsICA4LCAgOSwgIDddLFxyXG5cdFx0XHRcdFx0XHQgWyA2LCAxMiwgIDQsIDE0LCAxNV1dO1xyXG5cdFx0XHR2YXIgeCA9IGNvbnRleHQuYXJyYXkoYXJyYXkpO1xyXG5cdFx0XHR4LmdldChmdW5jdGlvbih5KSB7XHJcblx0XHRcdFx0ZXhwZWN0KHkpLnRvLmRlZXAuZXF1YWwoYXJyYXkpO1xyXG5cdFx0XHRcdGRvbmUoKTtcclxuXHRcdFx0fSk7XHJcblx0XHR9KTtcclxuXHR9KTtcclxuXHRkZXNjcmliZShcImFkZFwiLCBmdW5jdGlvbigpIHtcclxuXHRcdGRlc2NyaWJlKFwiQWRkIGFycmF5XCIsIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRpdChcIkNvcnJlY3QgcmVzdWx0IGZvciAxLWRpbWVuc2lvbmFsIGFycmF5c1wiLCBmdW5jdGlvbihkb25lKSB7XHJcblx0XHRcdFx0dmFyIHggPSBjb250ZXh0LmFycmF5KFsxLCA0LCA5XSk7XHJcblx0XHRcdFx0dmFyIHkgPSBjb250ZXh0LmFycmF5KFs4LCAtMSwgMTBdKTtcclxuXHRcdFx0XHR2YXIgeiA9IHguYWRkKHkpO1xyXG5cdFx0XHRcdHouZ2V0KGZ1bmN0aW9uKHopIHtcclxuXHRcdFx0XHRcdGV4cGVjdCh6KS50by5kZWVwLmVxdWFsKFs5LCAzLCAxOV0pO1xyXG5cdFx0XHRcdFx0ZG9uZSgpO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9KTtcclxuXHRcdFx0aXQoXCJDb3JyZWN0IHJlc3VsdCBmb3IgMi1kaW1lbnNpb25hbCBhcnJheXNcIiwgZnVuY3Rpb24oZG9uZSkge1xyXG5cdFx0XHRcdHZhciB4ID0gY29udGV4dC5hcnJheShbWzEsIDRdLCBbOSwgLTE3XV0pO1xyXG5cdFx0XHRcdHZhciB5ID0gY29udGV4dC5hcnJheShbWzgsIC0xXSwgWzEwLCAtMjFdXSk7XHJcblx0XHRcdFx0dmFyIHogPSB4LmFkZCh5KTtcclxuXHRcdFx0XHR6LmdldChmdW5jdGlvbihyZXN1bHQpIHtcclxuXHRcdFx0XHRcdGV4cGVjdChyZXN1bHQpLnRvLmRlZXAuZXF1YWwoW1s5LCAzXSwgWzE5LCAtMzhdXSk7XHJcblx0XHRcdFx0XHRkb25lKCk7XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH0pO1xyXG5cdFx0fSk7XHJcblx0XHRkZXNjcmliZShcIkFkZCBzY2FsYXJcIiwgZnVuY3Rpb24oKXtcclxuXHRcdFx0aXQoXCJDb3JyZWN0IHJlc3VsdCBmb3IgMS1kaW1lbnNpb25hbCBhcnJheXNcIiwgZnVuY3Rpb24oZG9uZSkge1xyXG5cdFx0XHRcdHZhciB4ID0gY29udGV4dC5hcnJheShbMSwgNCwgOV0pO1xyXG5cdFx0XHRcdHZhciB6ID0geC5hZGQoLTcpO1xyXG5cdFx0XHRcdHouZ2V0KGZ1bmN0aW9uKHopIHtcclxuXHRcdFx0XHRcdGV4cGVjdCh6KS50by5kZWVwLmVxdWFsKFstNiwgLTMsIDJdKTtcclxuXHRcdFx0XHRcdGRvbmUoKTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fSk7XHJcblx0XHRcdGl0KFwiQ29ycmVjdCByZXN1bHQgZm9yIDItZGltZW5zaW9uYWwgYXJyYXlzXCIsIGZ1bmN0aW9uKGRvbmUpIHtcclxuXHRcdFx0XHR2YXIgeCA9IGNvbnRleHQuYXJyYXkoW1sxLCA0XSwgWzksIC0xN11dKTtcclxuXHRcdFx0XHR2YXIgeiA9IHguYWRkKDQyKTtcclxuXHRcdFx0XHR6LmdldChmdW5jdGlvbih6KSB7XHJcblx0XHRcdFx0XHRleHBlY3QoeikudG8uZGVlcC5lcXVhbChbWzQzLCA0Nl0sIFs1MSwgMjVdXSk7XHJcblx0XHRcdFx0XHRkb25lKCk7XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH0pO1xyXG5cdFx0fSk7XHJcblx0fSk7XHJcblx0ZGVzY3JpYmUoXCJzdWJcIiwgZnVuY3Rpb24oKSB7XHJcblx0XHRkZXNjcmliZShcIlN1YnRyYWN0IGFycmF5XCIsIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRpdChcIkNvcnJlY3QgcmVzdWx0IGZvciAxLWRpbWVuc2lvbmFsIGFycmF5c1wiLCBmdW5jdGlvbihkb25lKSB7XHJcblx0XHRcdFx0dmFyIHggPSBjb250ZXh0LmFycmF5KFsxLCA0LCA5XSk7XHJcblx0XHRcdFx0dmFyIHkgPSBjb250ZXh0LmFycmF5KFs4LCAtMSwgMTBdKTtcclxuXHRcdFx0XHR2YXIgeiA9IHguc3ViKHkpO1xyXG5cdFx0XHRcdHouZ2V0KGZ1bmN0aW9uKHJlc3VsdCkge1xyXG5cdFx0XHRcdFx0ZXhwZWN0KHJlc3VsdCkudG8uZGVlcC5lcXVhbChbLTcsIDUsIC0xXSk7XHJcblx0XHRcdFx0XHRkb25lKCk7XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH0pO1xyXG5cdFx0XHRpdChcIkNvcnJlY3QgcmVzdWx0IGZvciAyLWRpbWVuc2lvbmFsIGFycmF5c1wiLCBmdW5jdGlvbihkb25lKSB7XHJcblx0XHRcdFx0dmFyIHggPSBjb250ZXh0LmFycmF5KFtbMSwgNF0sIFs5LCAtMTddXSk7XHJcblx0XHRcdFx0dmFyIHkgPSBjb250ZXh0LmFycmF5KFtbOCwgLTFdLCBbMTAsIC0yMV1dKTtcclxuXHRcdFx0XHR2YXIgeiA9IHguc3ViKHkpO1xyXG5cdFx0XHRcdHouZ2V0KGZ1bmN0aW9uKHJlc3VsdCkge1xyXG5cdFx0XHRcdFx0ZXhwZWN0KHJlc3VsdCkudG8uZGVlcC5lcXVhbChbWy03LCA1XSwgWy0xLCA0XV0pO1xyXG5cdFx0XHRcdFx0ZG9uZSgpO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9KTtcclxuXHRcdH0pO1xyXG5cdFx0ZGVzY3JpYmUoXCJTdWJ0cmFjdCBzY2FsYXJcIiwgZnVuY3Rpb24oKSB7XHJcblx0XHRcdGl0KFwiQ29ycmVjdCByZXN1bHQgZm9yIDEtZGltZW5zaW9uYWwgYXJyYXlzXCIsIGZ1bmN0aW9uKGRvbmUpIHtcclxuXHRcdFx0XHR2YXIgeCA9IGNvbnRleHQuYXJyYXkoWzEsIDQsIDldKTtcclxuXHRcdFx0XHR2YXIgeSA9IHguc3ViKC03KTtcclxuXHRcdFx0XHR5LmdldChmdW5jdGlvbih5KSB7XHJcblx0XHRcdFx0XHRleHBlY3QoeSkudG8uZGVlcC5lcXVhbChbOCwgMTEsIDE2XSk7XHJcblx0XHRcdFx0XHRkb25lKCk7XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH0pO1xyXG5cdFx0XHRpdChcIkNvcnJlY3QgcmVzdWx0IGZvciAyLWRpbWVuc2lvbmFsIGFycmF5c1wiLCBmdW5jdGlvbihkb25lKSB7XHJcblx0XHRcdFx0dmFyIHggPSBjb250ZXh0LmFycmF5KFtbMSwgNF0sIFs5LCAtMTddXSk7XHJcblx0XHRcdFx0dmFyIHkgPSB4LnN1Yig0Mik7XHJcblx0XHRcdFx0eS5nZXQoZnVuY3Rpb24oeSkge1xyXG5cdFx0XHRcdFx0ZXhwZWN0KHkpLnRvLmRlZXAuZXF1YWwoW1stNDEsIC0zOF0sIFstMzMsIC01OV1dKTtcclxuXHRcdFx0XHRcdGRvbmUoKTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fSk7XHJcblx0XHR9KTtcclxuXHR9KTtcclxuXHRkZXNjcmliZShcIm11bFwiLCBmdW5jdGlvbigpIHtcclxuXHRcdGRlc2NyaWJlKFwiTXVsdGlwbHkgYnkgYXJyYXlcIiwgZnVuY3Rpb24oKSB7XHJcblx0XHRcdGl0KFwiQ29ycmVjdCByZXN1bHQgZm9yIDEtZGltZW5zaW9uYWwgYXJyYXlzXCIsIGZ1bmN0aW9uKGRvbmUpIHtcclxuXHRcdFx0XHR2YXIgeCA9IGNvbnRleHQuYXJyYXkoWzEsIDQsIDldKTtcclxuXHRcdFx0XHR2YXIgeSA9IGNvbnRleHQuYXJyYXkoWzgsIC0xLCAxMF0pO1xyXG5cdFx0XHRcdHZhciB6ID0geC5tdWwoeSk7XHJcblx0XHRcdFx0ei5nZXQoZnVuY3Rpb24oeikge1xyXG5cdFx0XHRcdFx0ZXhwZWN0KHopLnRvLmRlZXAuZXF1YWwoWzgsIC00LCA5MF0pO1xyXG5cdFx0XHRcdFx0ZG9uZSgpO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9KTtcclxuXHRcdFx0aXQoXCJDb3JyZWN0IHJlc3VsdCBmb3IgMi1kaW1lbnNpb25hbCBhcnJheXNcIiwgZnVuY3Rpb24oZG9uZSkge1xyXG5cdFx0XHRcdHZhciB4ID0gY29udGV4dC5hcnJheShbWzEsIDRdLCBbOSwgLTE3XV0pO1xyXG5cdFx0XHRcdHZhciB5ID0gY29udGV4dC5hcnJheShbWzgsIC0xXSwgWzEwLCAtMjFdXSk7XHJcblx0XHRcdFx0dmFyIHogPSB4Lm11bCh5KTtcclxuXHRcdFx0XHR6LmdldChmdW5jdGlvbih6KSB7XHJcblx0XHRcdFx0XHRleHBlY3QoeikudG8uZGVlcC5lcXVhbChbWzgsIC00XSwgWzkwLCAzNTddXSk7XHJcblx0XHRcdFx0XHRkb25lKCk7XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH0pO1xyXG5cdFx0fSk7XHJcblx0XHRkZXNjcmliZShcIk11bHRpcGx5IGJ5IHNjYWxhclwiLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0aXQoXCJDb3JyZWN0IHJlc3VsdCBmb3IgMS1kaW1lbnNpb25hbCBhcnJheXNcIiwgZnVuY3Rpb24oZG9uZSkge1xyXG5cdFx0XHRcdHZhciB4ID0gY29udGV4dC5hcnJheShbMSwgNCwgOV0pO1xyXG5cdFx0XHRcdHZhciB5ID0geC5tdWwoLTEwKTtcclxuXHRcdFx0XHR5LmdldChmdW5jdGlvbih5KSB7XHJcblx0XHRcdFx0XHRleHBlY3QoeSkudG8uZGVlcC5lcXVhbChbLTEwLCAtNDAsIC05MF0pO1xyXG5cdFx0XHRcdFx0ZG9uZSgpO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9KTtcclxuXHRcdFx0aXQoXCJDb3JyZWN0IHJlc3VsdCBmb3IgMi1kaW1lbnNpb25hbCBhcnJheXNcIiwgZnVuY3Rpb24oZG9uZSkge1xyXG5cdFx0XHRcdHZhciB4ID0gY29udGV4dC5hcnJheShbWzEsIDRdLCBbOSwgLTE3XV0pO1xyXG5cdFx0XHRcdHZhciB5ID0geC5tdWwoMTApO1xyXG5cdFx0XHRcdHkuZ2V0KGZ1bmN0aW9uKHkpIHtcclxuXHRcdFx0XHRcdGV4cGVjdCh5KS50by5kZWVwLmVxdWFsKFtbMTAsIDQwXSwgWzkwLCAtMTcwXV0pO1xyXG5cdFx0XHRcdFx0ZG9uZSgpO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9KTtcclxuXHRcdH0pO1xyXG5cdH0pO1xyXG5cdGRlc2NyaWJlKFwiZGl2XCIsIGZ1bmN0aW9uKCl7XHJcblx0XHRkZXNjcmliZShcIkRpdmlkZSBieSBhcnJheVwiLCBmdW5jdGlvbigpe1xyXG5cdFx0XHRpdChcIkNvcnJlY3QgcmVzdWx0IGZvciAxLWRpbWVuc2lvbmFsIGFycmF5c1wiLCBmdW5jdGlvbihkb25lKSB7XHJcblx0XHRcdFx0dmFyIHggPSBjb250ZXh0LmFycmF5KFsxLCA0LCA5XSk7XHJcblx0XHRcdFx0dmFyIHkgPSBjb250ZXh0LmFycmF5KFsyLCAtNCwgOF0pO1xyXG5cdFx0XHRcdHZhciB6ID0geC5kaXYoeSk7XHJcblx0XHRcdFx0ei5nZXQoZnVuY3Rpb24oeikge1xyXG5cdFx0XHRcdFx0ZXhwZWN0KHopLnRvLmRlZXAuZXF1YWwoWzAuNSwgLTEsIDEuMTI1XSk7XHJcblx0XHRcdFx0XHRkb25lKCk7XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH0pO1xyXG5cdFx0XHRpdChcIkNvcnJlY3QgcmVzdWx0IGZvciAyLWRpbWVuc2lvbmFsIGFycmF5c1wiLCBmdW5jdGlvbihkb25lKSB7XHJcblx0XHRcdFx0dmFyIHggPSBjb250ZXh0LmFycmF5KFtbMSwgNF0sIFs5LCAtMTddXSk7XHJcblx0XHRcdFx0dmFyIHkgPSBjb250ZXh0LmFycmF5KFtbLTIsIDRdLCBbLTgsIDE2XV0pO1xyXG5cdFx0XHRcdHZhciB6ID0geC5kaXYoeSk7XHJcblx0XHRcdFx0ei5nZXQoZnVuY3Rpb24oeikge1xyXG5cdFx0XHRcdFx0ZXhwZWN0KHopLnRvLmRlZXAuZXF1YWwoW1stMC41LCAxXSwgWy0xLjEyNSwgLTEuMDYyNV1dKTtcclxuXHRcdFx0XHRcdGRvbmUoKTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fSk7XHJcblx0XHR9KTtcclxuXHRcdGRlc2NyaWJlKFwiRGl2aWRlIGJ5IHNjYWxhclwiLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0aXQoXCJDb3JyZWN0IHJlc3VsdCBmb3IgMS1kaW1lbnNpb25hbCBhcnJheXNcIiwgZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0dmFyIHggPSBjb250ZXh0LmFycmF5KFsxLCA0LCA5XSk7XHJcblx0XHRcdFx0dmFyIHkgPSB4LmRpdigtMik7XHJcblx0XHRcdFx0eS5nZXQoZnVuY3Rpb24oeSkge1xyXG5cdFx0XHRcdFx0ZXhwZWN0KHkpLnRvLmRlZXAuZXF1YWwoWy0wLjUsIC0yLCAtNC41XSk7XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH0pO1xyXG5cdFx0XHRpdChcIkNvcnJlY3QgcmVzdWx0IGZvciAyLWRpbWVuc2lvbmFsIGFycmF5c1wiLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHR2YXIgeCA9IGNvbnRleHQuYXJyYXkoW1sxLCA0XSwgWzksIC0xN11dKTtcclxuXHRcdFx0XHR2YXIgeSA9IHguZGl2KC00KTtcclxuXHRcdFx0XHR5LmdldChmdW5jdGlvbih5KSB7XHJcblx0XHRcdFx0XHRleHBlY3QoeSkudG8uZGVlcC5lcXVhbChbWy0wLjI1LCAtMV0sIFstMi4yNSwgNC4yNV1dKTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fSk7XHJcblx0XHR9KTtcclxuXHR9KTtcclxuXHRkZXNjcmliZShcIm1pblwiLCBmdW5jdGlvbigpe1xyXG5cdFx0ZGVzY3JpYmUoXCJBbGwgZWxlbWVudHNcIiwgZnVuY3Rpb24oKXtcclxuXHRcdFx0aXQoXCJSZXR1cm5zIHplcm8tZGltZW5zaW9uYWwgYXJyYXkgb2YgbGVuZ3RoIG9uZVwiLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHR2YXIgeCA9IGNvbnRleHQuemVyb3MoWzIwLCAzMF0pO1xyXG5cdFx0XHRcdHZhciB5ID0geC5taW4oKTtcclxuXHRcdFx0XHRleHBlY3QoeS5zaGFwZSkudG8uZGVlcC5lcXVhbChbXSk7XHJcblx0XHRcdFx0ZXhwZWN0KHkubGVuZ3RoKS50by5lcXVhbCgxKTtcclxuXHRcdFx0XHR5LmludmFsaWRhdGUoKTtcclxuXHRcdFx0fSk7XHJcblx0XHRcdGl0KFwiQ29tcHV0ZXMgdGhlIG1pbmltdW0gb2YgYWxsIGVsZW1lbnRzIGluIGFuIGFycmF5XCIsIGZ1bmN0aW9uKGRvbmUpIHtcclxuXHRcdFx0XHR2YXIgeCA9IGNvbnRleHQubGluc3BhY2UoLTUwLCAxMDAsIDEwMDAwMCkucmVzaGFwZShbMjAwLCA1MDBdKTtcclxuXHRcdFx0XHR4Lm1pbigpLmdldChmdW5jdGlvbih5KSB7XHJcblx0XHRcdFx0XHRleHBlY3QoeSkudG8uZXF1YWwoLTUwKTtcclxuXHRcdFx0XHRcdGRvbmUoKTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fSk7XHJcblx0XHR9KTtcclxuXHRcdGRlc2NyaWJlKFwiQWxvbmcgYW4gYXhpc1wiLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0aXQoXCJDb3JyZWN0IHNoYXBlIGZvciAzLWRpbWVuc2lvbmFsIGFycmF5c1wiLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHR2YXIgeCA9IGNvbnRleHQubGluc3BhY2UoMSwgMjQsIDI0KS5yZXNoYXBlKFsyLCAzLCA0XSkubG9jaygpO1xyXG5cdFx0XHRcdGV4cGVjdCh4Lm1pbigwKS5zaGFwZSkudG8uZGVlcC5lcXVhbChbMywgNF0pO1xyXG5cdFx0XHRcdGV4cGVjdCh4Lm1pbigxKS5zaGFwZSkudG8uZGVlcC5lcXVhbChbMiwgNF0pO1xyXG5cdFx0XHRcdGV4cGVjdCh4Lm1pbigyKS5zaGFwZSkudG8uZGVlcC5lcXVhbChbMiwgM10pO1xyXG5cdFx0XHRcdHguaW52YWxpZGF0ZSgpO1xyXG5cdFx0XHR9KTtcclxuXHRcdFx0aXQoXCJDb3JyZWN0IHJlc3VsdCBmb3IgMy1kaW1lbnNpb25hbCBhcnJheXMsIGF4aXMgMFwiLCBmdW5jdGlvbihkb25lKSB7XHJcblx0XHRcdFx0dmFyIHggPSBjb250ZXh0LmxpbnNwYWNlKDEsIDI0LCAyNCkucmVzaGFwZShbMiwgMywgNF0pO1xyXG5cdFx0XHRcdHgubWluKDApLmdldChmdW5jdGlvbih5KSB7XHJcblx0XHRcdFx0XHRleHBlY3QoeSkudG8uZGVlcC5lcXVhbChbWyAxLCAgMiwgIDMsICA0XSxcclxuXHRcdFx0XHRcdCAgICAgICAgICAgICAgICAgICAgICAgICBbIDUsICA2LCAgNywgIDhdLFxyXG5cdFx0XHRcdFx0ICAgICAgICAgICAgICAgICAgICAgICAgIFsgOSwgMTAsIDExLCAxMl1dKTtcclxuXHRcdFx0XHRcdGRvbmUoKTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fSk7XHJcblx0XHRcdGl0KFwiQ29ycmVjdCByZXN1bHQgZm9yIDMtZGltZW5zaW9uYWwgYXJyYXlzLCBheGlzIDFcIiwgZnVuY3Rpb24oZG9uZSkge1xyXG5cdFx0XHRcdHZhciB4ID0gY29udGV4dC5saW5zcGFjZSgxLCAyNCwgMjQpLnJlc2hhcGUoWzIsIDMsIDRdKTtcclxuXHRcdFx0XHR4Lm1pbigxKS5nZXQoZnVuY3Rpb24oeSkge1xyXG5cdFx0XHRcdFx0ZXhwZWN0KHkpLnRvLmRlZXAuZXF1YWwoW1sgIDEsICAyLCAgMywgIDRdLFxyXG5cdFx0XHRcdFx0ICAgICAgICAgICAgICAgICAgICAgICAgIFsgMTMsIDE0LCAxNSwgMTZdXSk7XHJcblx0XHRcdFx0XHRkb25lKCk7XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH0pO1xyXG5cdFx0XHRpdChcIkNvcnJlY3QgcmVzdWx0IGZvciAzLWRpbWVuc2lvbmFsIGFycmF5cywgYXhpcyAyXCIsIGZ1bmN0aW9uKGRvbmUpIHtcclxuXHRcdFx0XHR2YXIgeCA9IGNvbnRleHQubGluc3BhY2UoMSwgMjQsIDI0KS5yZXNoYXBlKFsyLCAzLCA0XSk7XHJcblx0XHRcdFx0eC5taW4oMikuZ2V0KGZ1bmN0aW9uKHkpIHtcclxuXHRcdFx0XHRcdGV4cGVjdCh5KS50by5kZWVwLmVxdWFsKFtbICAxLCAgNSwgIDldLFxyXG5cdFx0XHRcdFx0ICAgICAgICAgICAgICAgICAgICAgICAgIFsgMTMsIDE3LCAyMV1dKTtcclxuXHRcdFx0XHRcdGRvbmUoKTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fSk7XHJcblx0XHR9KTtcclxuXHR9KTtcclxuXHRkZXNjcmliZShcIm1heFwiLCBmdW5jdGlvbigpIHtcclxuXHRcdGRlc2NyaWJlKFwiQWxsIGVsZW1lbnRzXCIsIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRpdChcIlJldHVybnMgemVyby1kaW1lbnNpb25hbCBhcnJheSBvZiBsZW5ndGggb25lXCIsIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHZhciB4ID0gY29udGV4dC56ZXJvcyhbMjAsIDMwXSk7XHJcblx0XHRcdFx0dmFyIHkgPSB4Lm1heCgpO1xyXG5cdFx0XHRcdGV4cGVjdCh5LnNoYXBlKS50by5kZWVwLmVxdWFsKFtdKTtcclxuXHRcdFx0XHRleHBlY3QoeS5sZW5ndGgpLnRvLmVxdWFsKDEpO1xyXG5cdFx0XHRcdHkuaW52YWxpZGF0ZSgpO1xyXG5cdFx0XHR9KTtcclxuXHRcdFx0aXQoXCJDb21wdXRlcyB0aGUgbWF4aW11bSBvZiBhbGwgZWxlbWVudHMgaW4gYW4gYXJyYXlcIiwgZnVuY3Rpb24oZG9uZSkge1xyXG5cdFx0XHRcdHZhciB4ID0gY29udGV4dC5saW5zcGFjZSgtNTAsIDEwMCwgMTAwMDAwKS5yZXNoYXBlKFsyMDAsIDUwMF0pO1xyXG5cdFx0XHRcdHgubWF4KCkuZ2V0KGZ1bmN0aW9uKHkpIHtcclxuXHRcdFx0XHRcdGV4cGVjdCh5KS50by5lcXVhbCgxMDApO1xyXG5cdFx0XHRcdFx0ZG9uZSgpO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9KTtcclxuXHRcdH0pO1xyXG5cdFx0ZGVzY3JpYmUoXCJBbG9uZyBhbiBheGlzXCIsIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRpdChcIkNvcnJlY3Qgc2hhcGUgZm9yIDMtZGltZW5zaW9uYWwgYXJyYXlzXCIsIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHZhciB4ID0gY29udGV4dC5saW5zcGFjZSgxLCAyNCwgMjQpLnJlc2hhcGUoWzIsIDMsIDRdKS5sb2NrKCk7XHJcblx0XHRcdFx0ZXhwZWN0KHgubWF4KDApLnNoYXBlKS50by5kZWVwLmVxdWFsKFszLCA0XSk7XHJcblx0XHRcdFx0ZXhwZWN0KHgubWF4KDEpLnNoYXBlKS50by5kZWVwLmVxdWFsKFsyLCA0XSk7XHJcblx0XHRcdFx0ZXhwZWN0KHgubWF4KDIpLnNoYXBlKS50by5kZWVwLmVxdWFsKFsyLCAzXSk7XHJcblx0XHRcdFx0eC5pbnZhbGlkYXRlKCk7XHJcblx0XHRcdH0pO1xyXG5cdFx0XHRpdChcIkNvcnJlY3QgcmVzdWx0IGZvciAzLWRpbWVuc2lvbmFsIGFycmF5cywgYXhpcyAwXCIsIGZ1bmN0aW9uKGRvbmUpIHtcclxuXHRcdFx0XHR2YXIgeCA9IGNvbnRleHQubGluc3BhY2UoMSwgMjQsIDI0KS5yZXNoYXBlKFsyLCAzLCA0XSk7XHJcblx0XHRcdFx0eC5tYXgoMCkuZ2V0KGZ1bmN0aW9uKHkpIHtcclxuXHRcdFx0XHRcdGV4cGVjdCh5KS50by5kZWVwLmVxdWFsKFtbIDEzLCAxNCwgMTUsIDE2XSxcclxuXHRcdFx0XHRcdCAgICAgICAgICAgICAgICAgICAgICAgICBbIDE3LCAxOCwgMTksIDIwXSxcclxuXHRcdFx0XHRcdCAgICAgICAgICAgICAgICAgICAgICAgICBbIDIxLCAyMiwgMjMsIDI0XV0pO1xyXG5cdFx0XHRcdFx0ZG9uZSgpO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9KTtcclxuXHRcdFx0aXQoXCJDb3JyZWN0IHJlc3VsdCBmb3IgMy1kaW1lbnNpb25hbCBhcnJheXMsIGF4aXMgMVwiLCBmdW5jdGlvbihkb25lKSB7XHJcblx0XHRcdFx0dmFyIHggPSBjb250ZXh0LmxpbnNwYWNlKDEsIDI0LCAyNCkucmVzaGFwZShbMiwgMywgNF0pO1xyXG5cdFx0XHRcdHgubWF4KDEpLmdldChmdW5jdGlvbih5KSB7XHJcblx0XHRcdFx0XHRleHBlY3QoeSkudG8uZGVlcC5lcXVhbChbWyAgOSwgMTAsIDExLCAxMl0sXHJcblx0XHRcdFx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgWyAyMSwgMjIsIDIzLCAyNF1dKTtcclxuXHRcdFx0XHRcdGRvbmUoKTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fSk7XHJcblx0XHRcdGl0KFwiQ29ycmVjdCByZXN1bHQgZm9yIDMtZGltZW5zaW9uYWwgYXJyYXlzLCBheGlzIDJcIiwgZnVuY3Rpb24oZG9uZSkge1xyXG5cdFx0XHRcdHZhciB4ID0gY29udGV4dC5saW5zcGFjZSgxLCAyNCwgMjQpLnJlc2hhcGUoWzIsIDMsIDRdKTtcclxuXHRcdFx0XHR4Lm1heCgyKS5nZXQoZnVuY3Rpb24oeSkge1xyXG5cdFx0XHRcdFx0ZXhwZWN0KHkpLnRvLmRlZXAuZXF1YWwoW1sgIDQsICA4LCAxMl0sXHJcblx0XHRcdFx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgWyAxNiwgMjAsIDI0XV0pO1xyXG5cdFx0XHRcdFx0ZG9uZSgpO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9KTtcclxuXHRcdH0pO1xyXG5cdH0pO1xyXG5cdGRlc2NyaWJlKFwic3VtXCIsIGZ1bmN0aW9uKCkge1xyXG5cdFx0ZGVzY3JpYmUoXCJBbGwgZWxlbWVudHNcIiwgZnVuY3Rpb24oKSB7XHJcblx0XHRcdGl0KFwiUmV0dXJucyB6ZXJvLWRpbWVuc2lvbmFsIGFycmF5IG9mIGxlbmd0aCBvbmVcIiwgZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0dmFyIHggPSBjb250ZXh0Lnplcm9zKFsyMCwgMzBdKTtcclxuXHRcdFx0XHR2YXIgeSA9IHguc3VtKCk7XHJcblx0XHRcdFx0ZXhwZWN0KHkuc2hhcGUpLnRvLmRlZXAuZXF1YWwoW10pO1xyXG5cdFx0XHRcdGV4cGVjdCh5Lmxlbmd0aCkudG8uZXF1YWwoMSk7XHJcblx0XHRcdFx0eS5pbnZhbGlkYXRlKCk7XHJcblx0XHRcdH0pO1xyXG5cdFx0XHRpdChcIkNvbXB1dGVzIHRoZSBzdW0gb2YgYWxsIGVsZW1lbnRzIGluIGFuIGFycmF5XCIsIGZ1bmN0aW9uKGRvbmUpIHtcclxuXHRcdFx0XHR2YXIgeCA9IGNvbnRleHQubGluc3BhY2UoMSwgMTAwMDAwLCAxMDAwMDApLnJlc2hhcGUoWzIwMCwgNTAwXSk7XHJcblx0XHRcdFx0eC5zdW0oKS5nZXQoZnVuY3Rpb24oeSkge1xyXG5cdFx0XHRcdFx0ZXhwZWN0KHkpLnRvLmVxdWFsKDUwMDAwNTAwMDApO1xyXG5cdFx0XHRcdFx0ZG9uZSgpO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9KTtcclxuXHRcdH0pO1xyXG5cdFx0ZGVzY3JpYmUoXCJBbG9uZyBhbiBheGlzXCIsIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRpdChcIkNvcnJlY3Qgc2hhcGUgZm9yIDMtZGltZW5zaW9uYWwgYXJyYXlzXCIsIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHZhciB4ID0gY29udGV4dC5saW5zcGFjZSgxLCAyNCwgMjQpLnJlc2hhcGUoWzIsIDMsIDRdKS5sb2NrKCk7XHJcblx0XHRcdFx0ZXhwZWN0KHguc3VtKDApLnNoYXBlKS50by5kZWVwLmVxdWFsKFszLCA0XSk7XHJcblx0XHRcdFx0ZXhwZWN0KHguc3VtKDEpLnNoYXBlKS50by5kZWVwLmVxdWFsKFsyLCA0XSk7XHJcblx0XHRcdFx0ZXhwZWN0KHguc3VtKDIpLnNoYXBlKS50by5kZWVwLmVxdWFsKFsyLCAzXSk7XHJcblx0XHRcdFx0eC5pbnZhbGlkYXRlKCk7XHJcblx0XHRcdH0pO1xyXG5cdFx0XHRpdChcIkNvcnJlY3QgcmVzdWx0IGZvciAzLWRpbWVuc2lvbmFsIGFycmF5cywgYXhpcyAwXCIsIGZ1bmN0aW9uKGRvbmUpIHtcclxuXHRcdFx0XHR2YXIgeCA9IGNvbnRleHQubGluc3BhY2UoMSwgMjQsIDI0KS5yZXNoYXBlKFsyLCAzLCA0XSk7XHJcblx0XHRcdFx0eC5zdW0oMCkuZ2V0KGZ1bmN0aW9uKHkpIHtcclxuXHRcdFx0XHRcdGV4cGVjdCh5KS50by5kZWVwLmVxdWFsKFtbIDE0LCAxNiwgMTgsIDIwXSxcclxuXHRcdFx0XHRcdCAgICAgICAgICAgICAgICAgICAgICAgICBbIDIyLCAyNCwgMjYsIDI4XSxcclxuXHRcdFx0XHRcdCAgICAgICAgICAgICAgICAgICAgICAgICBbIDMwLCAzMiwgMzQsIDM2XV0pO1xyXG5cdFx0XHRcdFx0ZG9uZSgpO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9KTtcclxuXHRcdFx0aXQoXCJDb3JyZWN0IHJlc3VsdCBmb3IgMy1kaW1lbnNpb25hbCBhcnJheXMsIGF4aXMgMVwiLCBmdW5jdGlvbihkb25lKSB7XHJcblx0XHRcdFx0dmFyIHggPSBjb250ZXh0LmxpbnNwYWNlKDEsIDI0LCAyNCkucmVzaGFwZShbMiwgMywgNF0pO1xyXG5cdFx0XHRcdHguc3VtKDEpLmdldChmdW5jdGlvbih5KSB7XHJcblx0XHRcdFx0XHRleHBlY3QoeSkudG8uZGVlcC5lcXVhbChbWyAxNSwgIDE4LCAgMjEsICAyNF0sXHJcblx0XHRcdFx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgWyA1MSwgIDU0LCAgNTcsICA2MF1dKTtcclxuXHRcdFx0XHRcdGRvbmUoKTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fSk7XHJcblx0XHRcdGl0KFwiQ29ycmVjdCByZXN1bHQgZm9yIDMtZGltZW5zaW9uYWwgYXJyYXlzLCBheGlzIDJcIiwgZnVuY3Rpb24oZG9uZSkge1xyXG5cdFx0XHRcdHZhciB4ID0gY29udGV4dC5saW5zcGFjZSgxLCAyNCwgMjQpLnJlc2hhcGUoWzIsIDMsIDRdKTtcclxuXHRcdFx0XHR4LnN1bSgyKS5nZXQoZnVuY3Rpb24oeSkge1xyXG5cdFx0XHRcdFx0ZXhwZWN0KHkpLnRvLmRlZXAuZXF1YWwoW1sgMTAsICAyNiwgIDQyXSxcclxuXHRcdFx0XHRcdCAgICAgICAgICAgICAgICAgICAgICAgICBbIDU4LCAgNzQsICA5MF1dKTtcclxuXHRcdFx0XHRcdGRvbmUoKTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fSk7XHJcblx0XHR9KTtcclxuXHR9KTtcclxuXHRkZXNjcmliZShcImRvdFwiLCBmdW5jdGlvbigpIHtcclxuXHRcdGl0KFwiQ29ycmVjdCBzaGFwZSBmb3IgMi1kaW1lbnNpb25hbCBhcnJheXNcIiwgZnVuY3Rpb24oKSB7XHJcblx0XHRcdHZhciB4ID0gY29udGV4dC5lbXB0eShbMiwgNV0pO1xyXG5cdFx0XHR2YXIgeSA9IGNvbnRleHQuZW1wdHkoWzUsIDExXSk7XHJcblx0XHRcdHZhciB6ID0gY29udGV4dC5kb3QoeCwgeSk7XHJcblx0XHRcdGV4cGVjdCh6LnNoYXBlKS50by5kZWVwLmVxdWFsKFsyLCAxMV0pO1xyXG5cdFx0XHR6LmludmFsaWRhdGUoKTtcclxuXHRcdH0pO1xyXG5cdFx0aXQoXCJDb3JyZWN0IHNoYXBlIGZvciAzLWRpbWVuc2lvbmFsIGFycmF5c1wiLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0dmFyIHggPSBjb250ZXh0LmVtcHR5KFsyLCAzLCA0XSk7XHJcblx0XHRcdHZhciB5ID0gY29udGV4dC5lbXB0eShbNywgNCwgOF0pO1xyXG5cdFx0XHR2YXIgeiA9IGNvbnRleHQuZG90KHgsIHkpO1xyXG5cdFx0XHRleHBlY3Qoei5zaGFwZSkudG8uZGVlcC5lcXVhbChbMiwgMywgNywgOF0pO1xyXG5cdFx0XHR6LmludmFsaWRhdGUoKTtcclxuXHRcdH0pO1xyXG5cdFx0aXQoXCJDb3JyZWN0IHNoYXBlIGZvciA0LWRpbWVuc2lvbmFsIGFycmF5c1wiLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0dmFyIHggPSBjb250ZXh0LmVtcHR5KFsyLCAzLCA0LCA1XSk7XHJcblx0XHRcdHZhciB5ID0gY29udGV4dC5lbXB0eShbNiwgNywgNSwgOF0pO1xyXG5cdFx0XHR2YXIgeiA9IGNvbnRleHQuZG90KHgsIHkpO1xyXG5cdFx0XHRleHBlY3Qoei5zaGFwZSkudG8uZGVlcC5lcXVhbChbMiwgMywgNCwgNiwgNywgOF0pO1xyXG5cdFx0XHR6LmludmFsaWRhdGUoKTtcclxuXHRcdH0pO1xyXG5cdFx0aXQoXCJDb3JyZWN0IHZhbHVlIGZvciAxLWRpbWVuc2lvbmFsIGFycmF5c1wiLCBmdW5jdGlvbihkb25lKSB7XHJcblx0XHRcdHZhciB4ID0gY29udGV4dC5hcnJheShbMiwgNV0pO1xyXG5cdFx0XHR2YXIgeSA9IGNvbnRleHQuYXJyYXkoWzUsIDExXSk7XHJcblx0XHRcdGNvbnRleHQuZG90KHgsIHkpLmdldChmdW5jdGlvbih6KSB7XHJcblx0XHRcdFx0ZXhwZWN0KHopLnRvLmRlZXAuZXF1YWwoNjUpO1xyXG5cdFx0XHRcdGRvbmUoKTtcclxuXHRcdFx0fSk7XHJcblx0XHR9KTtcclxuXHRcdGl0KFwiQ29ycmVjdCB2YWx1ZSBmb3IgMi1kaW1lbnNpb25hbCBhcnJheXNcIiwgZnVuY3Rpb24oZG9uZSkge1xyXG5cdFx0XHR2YXIgeCA9IGNvbnRleHQuYXJyYXkoW1s2NCwgIDIsICAzXSxcclxuXHRcdFx0ICAgICAgICAgICAgICAgICAgICAgICBbNjEsIDYwLCAgNl1dKTtcclxuXHRcdFx0dmFyIHkgPSBjb250ZXh0LmFycmF5KFtbOTIsIDk5LCAgMSwgIDgsIDE1XSxcclxuXHRcdFx0ICAgICAgICAgICAgICAgICAgICAgICBbNjcsIDc0LCA1MSwgNTgsIDQwXSxcclxuXHRcdFx0ICAgICAgICAgICAgICAgICAgICAgICBbOTgsIDgwLCAgNywgMTQsIDE2XV0pO1xyXG5cdFx0XHR2YXIgeiA9IGNvbnRleHQuZG90KHgsIHkpO1xyXG5cdFx0XHR6LmdldChmdW5jdGlvbihyZXN1bHQpIHtcclxuXHRcdFx0XHRleHBlY3QocmVzdWx0KS50by5kZWVwLmVxdWFsKFtbICA2MzE2LCAgNjcyNCwgIDE4NywgIDY3MCwgMTA4OF0sXHJcblx0XHRcdFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgWyAxMDIyMCwgMTA5NTksIDMxNjMsIDQwNTIsIDM0MTFdXSk7XHJcblx0XHRcdFx0ZG9uZSgpO1xyXG5cdFx0XHR9KTtcclxuXHRcdH0pO1xyXG5cdH0pO1xyXG59KTtcclxuIl19
