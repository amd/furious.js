(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
"use strict";

/**
 * A numerical data type object.
 *
 * @class DataType
 * @constructor
 * @param {String} type - the abbreviated name of the data type. The following names are supported:
 *
 *     <table>
 *         <tr>
 *             <th>Abbreviated Name</th>
 *             <th>Interpretation</th>
 *         </tr>
 *         <tr>
 *             <td>"f32"</td>
 *             <td>Single-precision (32-bit) IEEE-754 floating-point type.</td>
 *         </tr>
 *         <tr>
 *             <td>"f64"</td>
 *             <td>Double-precision (64-bit) IEEE-754 floating-point type.</td>
 *         </tr>
 *     </table>
 *
 */
function DataType(type) {
	if (["f32", "f64"].indexOf(type) >= 0) {
		this.type = type;
		this.size = {"f32": 4, "f64": 8}[type];
		this.epsilon = {"f32": 1.1920928955078125e-7, "f64": 2.2204460492503131e-16}[type];
		this.arrayType = {"f32": Float32Array, "f64": Float64Array}[type];
	} else {
		throw new RangeError("Type " + type + " is not supported");
	}
}

/**
 * Compares two data type objects for equality.
 *
 * @method equals
 * @param {any} other - an object to compare to.
 */
DataType.prototype.equals = function(other) {
	return (other instanceof DataType) && (this.arrayType === other.arrayType);
};

module.exports = DataType;

},{}],2:[function(require,module,exports){
"use strict";

var util = require("./util");
var DataType = require("./DataType");

/**
 * An opaque N-dimensional array object.
 *
 * @class NDArray
 */

/**
 * Constructs an NDArray object without data.
 * Normally this constructor is called from array construction methods of computational contexts.
 * The calling function is responsible for initializing the data for the array.
 *
 * @constructor
 * @private
 */
function NDArray(shape, dataType, context) {
	if (typeof context === "undefined") {
		throw new Error("Context not defined");
	}
	if (!util.isPositiveIntArray(shape) && !util.isPositiveInt(shape)) {
		throw new TypeError(shape + " is not a valid array shape");
	}
	if (typeof dataType === "undefined") {
		dataType = new DataType("f64");
	} else if (!(dataType instanceof DataType)) {
		throw new TypeError(dataType + " is not an instance of DataType");
	}
	this.shape = shape;
	this.dataType = dataType;
	this._context = context;
	this.length = util.computeLength(this.shape);
	this._lockCount = 0;
	this._refCount = 1;
	this._isValid = true;
}

/**
 * Locks the array reference counter.
 * While the array is locked, functions and methods that operate on this array do not decrease its reference count.
 * The array can be locked multiple times, and would need just as many unlock calls to lift the lock.
 * If the array is not valid, this operation will fail with an error.
 *
 * @method lock
 * @chainable
 */
NDArray.prototype.lock = function() {
	if (!this.isValid()) {
		throw new Error("Attempted to lock an invalidated array");
	}
	this._lockCount++;
	return this;
};

/**
 * Unlocks the array reference counter.
 * Once the array is unlocked, functions and methods that operate on this array decrease its reference count and, if the reference count reaches zero, invalidate the array.
 * If the array was locked multiple times, it would need just as many unlock calls to lift the lock.
 * If the array is not locked, this operation will fail with an error.
 *
 * @method unlock
 * @chainable
 */
NDArray.prototype.unlock = function() {
	if (!this.isLocked()) {
		throw new Error("Attempted to lock a unlocked array");
	}
	this._lockCount--;
	return this;
};

/**
 * Checkes if the array is in the locked state.
 * If the array is not valid, this method return false.
 *
 * @method isLocked
 *
 * @return {Boolean} - true is the array is locked and false otherwise
 */
NDArray.prototype.isLocked = function() {
	return this._lockCount > 0;
};

/**
 * Increments the array reference count.
 * If the array is invalid or locked, this operation will fail with an error.
 *
 * @method retain
 * @chainable
 */
NDArray.prototype.retain = function() {
	if (!this.isValid()) {
		throw new Error("Attempted to release an invalidated array");
	}
	if (this.isLocked()) {
		throw new Error("Attempted to retain a locked array");
	}
	this._refCount++;
	return this;
};

/**
 * Decrements the array reference count. If the reference count turns zero, the array becomes invalid and its data buffer is deallocated.
 * If the array is invalid or locked, this operation will fail with an error.
 *
 * @method release
 * @chainable
 */
NDArray.prototype.release = function() {
	if (!this.isValid()) {
		throw new Error("Attempted to release an invalidated array");
	}
	if (this.isLocked()) {
		throw new Error("Attempted to release a locked array");
	}
	if (--this._refCount === 0) {
		this._context._invalidate(this);
	}
	return this;
};

/**
 * For a non-locked array, decrements the array reference count. If the reference count turns zero, the array becomes invalid and its data buffer is deallocated.
 * If the array is invalid, this operation will fail with an error.
 *
 * @method tryRelease
 * @chainable
 */
NDArray.prototype.tryRelease = function() {
	if (!this.isValid()) {
		throw new Error("Attempted to release an invalidated array");
	}
	if (!this.isLocked()) {
		if (--this._refCount === 0) {
			this._context._invalidate(this);
		}
	}
	return this;
};

/**
 * For a non-locked array, decrements the array reference count. If the reference count turns zero, the array becomes invalid and its data buffer is deallocated.
 * The array must be valid to perform this operation.
 *
 * @private
 * @method _tryRelease
 * @chainable
 */
NDArray.prototype._tryRelease = function() {
	if (!this.isLocked()) {
		if (--this._refCount === 0) {
			this._context._invalidate(this);
		}
	}
	return this;
};

/**
 * Invalidates the array and deallocates its data buffer, regardless of locks and reference count.
 * Calling this method on an invalidated array has no effect.
 *
 * @method invalidate
 * @chainable
 */
NDArray.prototype.invalidate = function() {
	if (this.isValid()) {
		this._context._invalidate(this);
		this._isValid = false;
		this._refCount = 0;
		this._lockCount = 0;
	}
	return this;
};

/**
 * Checkes if the array is in a valid state.
 * If the array is not in a valid state, its data buffer was deallocated, and any operations on the array will throw an error.
 *
 * @method isValid
 *
 * @return {Boolean} - true is the array is valid and false otherwise
 */
NDArray.prototype.isValid = function() {
	return this._isValid;
};

/**
 * Decrements the array reference count if the array is not locked.
 * This function does not invalidate the array when the reference count reach zero.
 * The caller is responsible for invalidating array if its reference count is zero after the operation.
 *
 * For a locked array the method has no effect and always returns true.
 *
 * @private
 * @method _decRef
 * @param {NDArray} array - the array to decrement the reference count for. Must be valid before the call.
 * @return {Boolean} - true if the reference count is non-zero after the operation and false otherwise.
 */
NDArray.prototype._decRef = function(array) {
	if (this._lockCount === 0) {
		--this._refCount;
	}
	return this._refCount !== 0;
};

/**
 * Increments the array reference count if the array is not locked.
 * For a locked array the method has no effect.
 *
 * @private
 * @method _incRef
 * @chainable
 * @param {NDArray} array - the array to increment the reference count for. Must be valid before the call, but may have zero reference count.
 */
NDArray.prototype._incRef = function(array) {
	if (this._lockCount === 0) {
		++this._refCount;
	}
	return this;
};

/**
 * Checks if the array is locked or has any references.
 *
 * @private
 * @method _hasRefs
 * @param {NDArray} array - the array to check. Must be valid before the call, but may have zero reference count.
 * @return {Boolean} - true if the array is locked or has references and false otherwise.
 */
NDArray.prototype._hasRefs = function(array) {
	return (this._lockCount !== 0) || (this._refCount !== 0);
};

/**
 * Invalidates the array if it valid, not locked, and has zero reference count.
 * Has no effect in all other cases.
 *
 * @private
 * @method _tryInvalidate
 * @param {NDArray} array - the array to try to invalidate. Can be invalid.
 * @return {Boolean} - true if the array was invalidated by this call and false otherwise.
 */
NDArray.prototype._tryInvalidate = function(array) {
	if (this.isValid() && !this._hasRefs()) {
		this._context._invalidate(this);
		this._isValid = false;
		return true;
	} else {
		return false;
	}
};

/**
 * Adds another array or a number to this array.
 *
 * @method add
 * @param {(NDArray|Number)} other - the array or scalar to be added.
 * @return {NDArray}
 */
NDArray.prototype.add = function(other) {
	return this._context.add(this, other);
};

/**
 * Subtracts another array or a number from this array.
 *
 * @method sub
 * @param {(NDArray|Number)} other - the array or scalar to be subtracted.
 * @return {NDArray}
 */
NDArray.prototype.sub = function(other) {
	return this._context.sub(this, other);
};

/**
 * Multiplies array elements by another array or by a number.
 *
 * @method mul
 * @param {(NDArray|Number)} other - the array or scalar to multiply elements by.
 * @return {NDArray}
 */
NDArray.prototype.mul = function(other) {
	return this._context.mul(this, other);
};

/**
 * Divides array elements by another array or by a number.
 *
 * @method div
 * @param {(NDArray|Number)} other - the array or scalar to divide elements by.
 * @return {NDArray}
 */
NDArray.prototype.div = function(other) {
	return this._context.div(this, other);
};

/**
 * Reduces array elements using minimum operation.
 * If the axis argument is provided, the method computes minimum of elements along the specified axis.
 * Otherwise, the method computes an all-array minimum of the elements and returns them as a 1-element array.
 *
 * @method min
 * @param {Number} [axis] - the axis along which the minimum is computed.
 * @return {NDArray}
 */
NDArray.prototype.min = function(axis) {
	return this._context.min(this, axis);
};

/**
 * Reduces array elements using maximum operation.
 * If the axis argument is provided, the method computes maximum of elements along the specified axis.
 * Otherwise, the method computes an all-array maximum of the elements and returns them as a 1-element array.
 *
 * @method min
 * @param {Number} [axis] - the axis along which the maximum is computed.
 * @return {NDArray}
 */
NDArray.prototype.max = function(axis) {
	return this._context.max(this, axis);
};

/**
 * Reduces array elements using sum operation.
 * If the axis argument is provided, the method computes sum of elements along the specified axis.
 * Otherwise, the method computes an all-array sum of the elements and returns them as a 1-element array.
 *
 * @method min
 * @param {Number} [axis] - the axis along which the sum is computed.
 * @return {NDArray}
 */
NDArray.prototype.sum = function(axis) {
	return this._context.sum(this, axis);
};

/**
 * Creates another array with the same data, but different dimensions.
 *
 * @method reshape
 * @param {(NDArray|Number)} other - dimensions of the new array.
 * @return {NDArray}
 */
NDArray.prototype.reshape = function(newShape) {
	return this._context.reshape(this, newShape);
};

/**
 * Duplicates array elements along the specified axis.
 *
 * @method repeat
 * @param {Number} repeats - the number of times to repeat each element.
 * @param {Number} axis - the axis along which the elements will be duplicated.
 * @return {NDArray}
 */
NDArray.prototype.repeat = function(repeats, axis) {
	return this._context.repeat(this, repeats, axis);
};

/**
 * Converts the data to a JavaScript Array.
 *
 * @method get
 * @async
 */
NDArray.prototype.get = function(callback) {
	this._context.get(this, callback);
};

module.exports = NDArray;

},{"./DataType":1,"./util":12}],3:[function(require,module,exports){
"use strict";

var NDArray = require("./NDArray");
var DataType = require("./DataType");
var allocator = require("./allocator");
var util = require("./util");
var requests = require("./requests.pb");
var Request = requests.Request;
var EmptyArrayRequest = requests.EmptyArrayRequest;
var DataArrayRequest = requests.DataArrayRequest;
var ConstArrayRequest = requests.ConstArrayRequest;
var LinspaceRequest = requests.LinspaceRequest;
var ReshapeRequest = requests.ReshapeRequest;
var RepeatRequest = requests.RepeatRequest;
var DeallocateRequest = requests.DeallocateRequest;
var FetchRequest = requests.FetchRequest;
var BinaryOperationRequest = requests.BinaryOperationRequest;
var BinaryConstOperationRequest = requests.BinaryConstOperationRequest;
var UnaryOperationRequest = requests.UnaryOperationRequest;
var ReductionRequest = requests.ReductionRequest;
var AxisReductionRequest = requests.AxisReductionRequest;
var DotOperationRequest = requests.DotOperationRequest;
var Response = require("./responses.pb").Response;

var dataTypeMap = {
	"f32": requests.DataType.FLOAT32,
	"f64": requests.DataType.FLOAT64
};

function PBContext(options, postMessage, callback) {
	var context = this;
	this._postMessage = postMessage;
	this._callbacks = {};
	this._callbacks[0] = function(limits) {
		callback(context, limits);
	};
}

PBContext.prototype._onMessage = function(message) {
	var response = Response.decode(message.data);
	var id = response.id;
	var callback = this._callbacks[id];
	delete this._callbacks[id];
	switch (response.type) {
		case Response.Type.INIT:
			var limits = {};
			var initResponse = response.initResponse;
			if (initResponse.concurrency !== null) {
				limits.concurrency = initResponse.concurrency;
			}
			callback(limits);
			break;
		case Response.Type.BARRIER:
			callback();
			break;
		case Response.Type.FETCH:
			callback(response.fetchResponse.dataBuffer.toArrayBuffer());
			break;
		case Response.Type.ERROR:
			break;
		case Response.Type.INFO:
			break;
	}
};

PBContext.prototype.empty = function(shape, dataType) {
	shape = util.checkShape(shape);
	if (typeof dataType === "undefined") {
		dataType = new DataType("f64");
	} else if (!(dataType instanceof DataType)) {
		throw new TypeError(dataType + " is not an instance of DataType");
	}
	var array = new NDArray(shape, dataType, this);
	array._id = allocator.newArrayId();

	var request = new Request();
	request.id = allocator.newMessageId();
	request.type = Request.Type.EMPTY_ARRAY;
	var emptyArrayRequest = new EmptyArrayRequest();
	emptyArrayRequest.idOut = array._id;
	emptyArrayRequest.shape = shape;
	emptyArrayRequest.dataType = dataTypeMap[dataType.type];
	request.emptyArrayRequest = emptyArrayRequest;
	this._postMessage(request.encodeAB());

	return array;
};

PBContext.prototype.zeros = function(shape, dataType) {
	shape = util.checkShape(shape);
	if (typeof dataType === "undefined") {
		dataType = new DataType("f64");
	} else if (!(dataType instanceof DataType)) {
		throw new TypeError(dataType + " is not an instance of DataType");
	}
	var array = new NDArray(shape, dataType, this);
	array._id = allocator.newArrayId();

	var request = new Request();
	request.id = allocator.newMessageId();
	request.type = Request.Type.CONST_ARRAY;
	var constArrayRequest = new ConstArrayRequest();
	constArrayRequest.idOut = array._id;
	constArrayRequest.shape = shape;
	constArrayRequest.dataType = dataTypeMap[dataType.type];
	constArrayRequest.fillValue = 0.0;
	request.constArrayRequest = constArrayRequest;
	this._postMessage(request.encodeAB());

	return array;
};

PBContext.prototype.ones = function(shape, dataType) {
	shape = util.checkShape(shape);
	if (typeof dataType === "undefined") {
		dataType = new DataType("f64");
	} else if (!(dataType instanceof DataType)) {
		throw new TypeError(dataType + " is not an instance of DataType");
	}
	var array = new NDArray(shape, dataType, this);
	array._id = allocator.newArrayId();

	var request = new Request();
	request.id = allocator.newMessageId();
	request.type = Request.Type.CONST_ARRAY;
	var constArrayRequest = new ConstArrayRequest();
	constArrayRequest.idOut = array._id;
	constArrayRequest.shape = shape;
	constArrayRequest.dataType = dataTypeMap[dataType.type];
	constArrayRequest.fillValue = 1.0;
	request.constArrayRequest = constArrayRequest;
	this._postMessage(request.encodeAB());

	return array;
};

PBContext.prototype.array = function(data, dataType) {
	var shape = [];
	util.discoverArrayShapeRecursive(data, shape, 0);
	if (typeof dataType === "undefined") {
		dataType = new DataType("f64");
	} else if (!(dataType instanceof DataType)) {
		throw new TypeError(dataType + " is not an instance of DataType");
	}
	var array = new NDArray(shape, dataType, this);
	array._id = allocator.newArrayId();
	var arrayBuffer = new dataType.arrayType(array.length);
	util.copyArrayDataRecursive(arrayBuffer, data, shape, 0, 0);

	var request = new Request();
	request.id = allocator.newMessageId();
	request.type = Request.Type.DATA_ARRAY;
	var dataArrayRequest = new DataArrayRequest();
	dataArrayRequest.idOut = array._id;
	dataArrayRequest.shape = shape;
	dataArrayRequest.dataType = dataTypeMap[dataType.type];
	dataArrayRequest.dataBuffer = arrayBuffer.buffer;
	request.dataArrayRequest = dataArrayRequest;
	this._postMessage(request.encodeAB());

	return array;
};

PBContext.prototype.linspace = function(start, stop, samples, includeStop) {
	if (!util.isReal(start)) {
		throw new TypeError(start + " is not a real number");
	}
	if (!util.isReal(stop)) {
		throw new TypeError(stop + " is not a real number");
	}
	if (typeof samples === "undefined") {
		/* Default value in NumPy */
		samples = 50;
	} else if (!util.isInt(samples)) {
		throw new TypeError(samples + " is not an integer");
	} else if (samples <= 0) {
		throw new RangeError("The number of samples must be positive");
	}
	if (typeof includeStop === "undefined") {
		includeStop = true;
	}
	if (includeStop && (samples === 1)) {
		throw new RangeError("The number of samples must be a least 2 (for start and end points)");
	}
	var dataType = new DataType("f64");
	var array = new NDArray([samples], dataType, this);
	array._id = allocator.newArrayId();

	var request = new Request();
	request.id = allocator.newMessageId();
	request.type = Request.Type.LINSPACE;
	var linspaceRequest = new LinspaceRequest();
	linspaceRequest.idOut = array._id;
	linspaceRequest.start = start;
	linspaceRequest.stop = stop;
	linspaceRequest.samples = samples;
	linspaceRequest.closed = includeStop;
	linspaceRequest.dataType = dataTypeMap[dataType.type];
	request.linspaceRequest = linspaceRequest;
	this._postMessage(request.encodeAB());

	return array;
};

PBContext.prototype.reshape = function(a, shape) {
	util.checkNDArray(a, "a");
	shape = util.checkShape(shape);
	if (util.computeLength(shape) !== a.length) {
		throw new RangeError("The shape is not compatible with the array");
	}
	var idA = a._id;
	var releaseA = !a._decRef();
	var out = new NDArray(shape, a.dataType, this);
	if (releaseA) {
		out._id = idA;
		a._id = 0;
		releaseA = false;
	} else {
		out._id = allocator.newArrayId();
	}

	var request = new Request();
	request.id = allocator.newMessageId();
	request.type = Request.Type.RESHAPE;
	var reshapeRequest = new ReshapeRequest();
	reshapeRequest.idA = idA;
	reshapeRequest.idOut = out._id;
	reshapeRequest.shapeOut = shape;
	request.reshapeRequest = reshapeRequest;
	this._postMessage(request.encodeAB());

	a._tryInvalidate();
	return out;
};

PBContext.prototype.repeat = function(a, repeats, axis, out) {
	util.checkNDArray(a, "a");
	repeats = util.checkRepeats(repeats);
	axis = util.checkAxis(axis, a.shape.length);
	var shapeA = a.shape;
	var shapeOut = shapeA.slice(0);
	shapeOut[axis] *= repeats;
	if (typeof out === "undefined") {
		out = new NDArray(shapeOut, a.dataType, this);
		out._id = allocator.newArrayId();
	} else {
		util.checkNDArray(out, "out");
		util.checkShapesCompatibility(out.shape, shapeOut);
		util.checkDataTypesCompatibility(a.dataType, out.dataType);
		out._incRef();
	}
	var idA = a._id;
	if (!a._decRef()) {
		idA = -idA;
		a._id = 0;
	}

	var request = new Request();
	request.id = allocator.newMessageId();
	request.type = Request.Type.REPEAT;
	var repeatRequest = new RepeatRequest();
	repeatRequest.idA = idA;
	repeatRequest.idOut = out._id;
	repeatRequest.axis = axis;
	repeatRequest.repeats = repeats;
	request.repeatRequest = repeatRequest;
	this._postMessage(request.encodeAB());

	a._tryInvalidate();
	return out;
};

PBContext.prototype._invalidate = function(array) {
	if (array._id !== 0) {
		var request = new Request();
		request.id = allocator.newMessageId();
		request.type = Request.Type.DEALLOCATE;
		var deallocateRequest = new DeallocateRequest();
		deallocateRequest.idA = array._id;
		request.deallocateRequest = deallocateRequest;
		this._postMessage(request.encodeAB());
	}
};

PBContext.prototype.fetch = function() {
	if (arguments.length === 0) {
		throw new Error("Callback argument missing");
	}
	var callback = arguments[arguments.length - 1];
	/* Validate arguments */
	if (arguments.length === 1) {
		throw new Error("At least one NDArray argument expected");
	}
	for (var i = 0; i < arguments.length - 1; ++i) {
		util.checkNDArray(arguments[i], "argument " + i);
	}
	var release = new Array(arguments.length - 1);
	for (var i = 0; i < arguments.length - 1; ++i) {
		release[i] = !arguments[i]._decRef();
	}
	var callbackWaitArguments = arguments.length - 1;
	var callbackArguments = new Array(callbackWaitArguments);
	for (var i = 0; i < callbackWaitArguments; i++) {
		var array = arguments[i];
		var messageId = allocator.newMessageId();
		this._callbacks[messageId] = (function(i, ArrayType) {
			return function(buffer) {
				callbackArguments[i] = new ArrayType(buffer);
				if (--callbackWaitArguments === 0) {
					callback.apply(null, callbackArguments);
				}
			};
		})(i, array.dataType.arrayType);
		var arrayId = array._id;
		if (release[i]) {
			array._id = 0;
			arrayId = -arrayId;
			array._tryInvalidate();
		}

		var request = new Request();
		request.id = messageId;
		request.type = Request.Type.FETCH;
		var fetchRequest = new FetchRequest();
		fetchRequest.idA = arrayId;
		request.fetchRequest = fetchRequest;
		this._postMessage(request.encodeAB());
	}
};

PBContext.prototype.get = function() {
	if (arguments.length === 0) {
		throw new Error("Callback argument missing");
	}
	var callback = arguments[arguments.length - 1];
	/* Validate arguments */
	if (arguments.length === 1) {
		throw new Error("At least one NDArray argument expected");
	}
	for (var i = 0; i < arguments.length - 1; ++i) {
		util.checkNDArray(arguments[i], "argument " + i);
	}
	var release = new Array(arguments.length - 1);
	for (var i = 0; i < arguments.length - 1; ++i) {
		release[i] = !arguments[i]._decRef();
	}
	var callbackWaitArguments = arguments.length - 1;
	var callbackArguments = new Array(callbackWaitArguments);
	for (var i = 0; i < callbackWaitArguments; i++) {
		var array = arguments[i];
		var messageId = allocator.newMessageId();
		if (array.shape.length === 0) {
			this._callbacks[messageId] = (function(i, ArrayType) {
				return function(buffer) {
					var typedArray = new ArrayType(buffer);
					callbackArguments[i] = typedArray[0];
					if (--callbackWaitArguments === 0) {
						callback.apply(null, callbackArguments);
					}
				};
			})(i, array.dataType.arrayType);
		} else {
			this._callbacks[messageId] = (function(i, ArrayType, shape) {
				return function(buffer) {
					var jsarray = new Array(shape[0]);
					util.createArrayRecursive(new ArrayType(buffer), jsarray, shape, 0, 0);
					callbackArguments[i] = jsarray;
					if (--callbackWaitArguments === 0) {
						callback.apply(null, callbackArguments);
					}
				};
			})(i, array.dataType.arrayType, array.shape);
		}
		var arrayId = array._id;
		if (release[i]) {
			array._id = 0;
			arrayId = -arrayId;
			array._tryInvalidate();
		}

		var request = new Request();
		request.id = messageId;
		request.type = Request.Type.FETCH;
		var fetchRequest = new FetchRequest();
		fetchRequest.idA = arrayId;
		request.fetchRequest = fetchRequest;
		this._postMessage(request.encodeAB());
	}
};

PBContext.prototype.info = function(callback) {
	throw new Error("Not implemented");
/*	var messageId = allocator.newMessageId();
	messageCallbacks[messageId] = callback;
	this._pnaclObject.postMessage({
		"id": messageId,
		"command": "info"
	});*/
};

PBContext.prototype.barrier = function(callback) {
	var messageId = allocator.newMessageId();
	this._callbacks[messageId] = callback;

	var request = new Request();
	request.id = messageId;
	request.type = Request.Type.BARRIER;
	this._postMessage(request.encodeAB());
};

var binaryArithOp = function(a, b, out, context, operation, constOperation, revConstOperation) {
	var shapeOut = null, dataTypeOut = null, releaseIdA = false, releaseIdB = false, idA = 0, idB = 0;
	if (a instanceof NDArray) {
		idA = a._id;
		shapeOut = a.shape;
		dataTypeOut = a.dataType;
		if (b instanceof NDArray) {
			idB = b._id;
			util.checkShapesCompatibility(a.shape, b.shape);
			util.checkDataTypesCompatibility(a.dataType, b.dataType);
		} else if (!util.isNumber(b)) {
			throw new TypeError("Unsupported type of b");
		}
	} else if (util.isNumber(a)) {
		idB = b._id;
		shapeOut = b.shape;
		dataTypeOut = b.dataType;
		util.checkNDArray(b, "b");
	} else {
		throw new TypeError("Unsupported type of a");
	}
	/* The IDs of a and b must be invalidated before we assign ID to out because a/b and out may be the same arrays */
	if (idA !== 0) {
		releaseIdA = !a._decRef();
		if (releaseIdA) {
			a._id = 0;
		}
	}
	if (idB !== 0) {
		releaseIdB = !b._decRef();
		if (releaseIdB) {
			b._id = 0;
		}
	}
	try {
		if (typeof out === "undefined") {
			out = new NDArray(shapeOut, dataTypeOut, context);
			if (releaseIdA) {
				out._id = idA;
				releaseIdA = false;
			} else if (releaseIdB) {
				out._id = idB;
				releaseIdB = false;
			} else {
				out._id = allocator.newArrayId();
			}
		} else {
			util.checkNDArray(out, "out");
			util.checkShapesCompatibility(shapeOut, out.shape);
			util.checkDataTypesCompatibility(dataTypeOut, out.dataType);
			out._incRef();
		}
		var request = new Request();
		request.id = allocator.newMessageId();
		if (idA !== 0) {
			if (idB !== 0) {
				request.type = Request.Type.BINARY_OPERATION;
				var binaryOperationRequest = new BinaryOperationRequest();
				binaryOperationRequest.type = operation;
				binaryOperationRequest.idA = (releaseIdA ? -idA : idA);
				binaryOperationRequest.idB = (releaseIdB ? -idB : idB);
				binaryOperationRequest.idOut = out._id;
				request.binaryOperationRequest = binaryOperationRequest;
				context._postMessage(request.encodeAB());
			} else {
				request.type = Request.Type.BINARY_CONST_OPERATION;
				var binaryConstOperationRequest = new BinaryConstOperationRequest();
				binaryConstOperationRequest.type = constOperation;
				binaryConstOperationRequest.idA = (releaseIdA ? -idA : idA);
				binaryConstOperationRequest.valueB = b;
				binaryConstOperationRequest.idOut = out._id;
				request.binaryConstOperationRequest = binaryConstOperationRequest;
				context._postMessage(request.encodeAB());
			}
		} else {
			request.type = Request.Type.BINARY_CONST_OPERATION;
			var binaryConstOperationRequest = new BinaryConstOperationRequest();
			binaryConstOperationRequest.type = revConstOperation;
			binaryConstOperationRequest.idA = (releaseIdB ? -idB : idB);
			binaryConstOperationRequest.valueB = a;
			binaryConstOperationRequest.idOut = out._id;
			request.binaryConstOperationRequest = binaryConstOperationRequest;
			context._postMessage(request.encodeAB());
		}
	} catch (e) {
		/* Restore the previous state */
		if (idA !== 0) {
			a._id = idA;
			a._incRef();
		}
		if (idB !== 0) {
			b._id = idB;
			b._incRef();
		}
		throw e;
	}
	/*
	 * If a or b are arrays, invalidate them as needed.
	 * If a/b and out are the same, their ref count is non-zero at this point, so they will stay valid.
	 */
	if (idA !== 0) {
		a._tryInvalidate();
	}
	if (idB !== 0) {
		b._tryInvalidate();
	}
	return out;
};

var unaryArithOp = function(a, out, context, operation) {
	util.checkNDArray(a, "a");
	var idA = a._id;
	var releaseIdA = !a._decRef();
	/* The ID of a must be invalidated before we assign ID to out because a and out may be the same arrays */
	if (releaseIdA) {
		a._id = 0;
	}
	try {
		if (typeof out === "undefined") {
			out = new NDArray(a.shape, a.dataType, context);
			if (releaseIdA) {
				out._id = idA;
				releaseIdA = false;
			} else {
				out._id = allocator.newArrayId();
			}
		} else {
			util.checkNDArray(out, "out");
			util.checkShapesCompatibility(a.shape, out.shape);
			util.checkDataTypesCompatibility(a.dataType, out.dataType);
			out._incRef();
		}
	} catch (e) {
		/* Restore the previous state */
		a._id = idA;
		a._incRef();
		throw e;
	}

	var request = new Request();
	request.id = allocator.newMessageId();
	request.type = Request.Type.UNARY_OPERATION;
	var unaryOperationRequest = new UnaryOperationRequest();
	unaryOperationRequest.type = operation;
	unaryOperationRequest.idA = (releaseIdA ? -idA : idA);
	unaryOperationRequest.idOut = out._id;
	request.unaryOperationRequest = unaryOperationRequest;
	context._postMessage(request.encodeAB());

	/* If a and out are the same, their ref count is non-zero at this point, so they will stay valid. */
	a._tryInvalidate();
	return out;
};

var reduceArithOp = function(a, out, context, operation) {
	util.checkNDArray(a, "a");
	var idA = a._id;
	var releaseIdA = !a._decRef();
	if (releaseIdA) {
		a._id = 0;
	}
	try {
		if (typeof out === "undefined") {
			out = new NDArray([], a.dataType, context);
			out._id = allocator.newArrayId();
		} else {
			util.checkNDArray(out, "out");
			util.checkShapesCompatibility(out.shape, []);
			util.checkDataTypesCompatibility(a.dataType, out.dataType);
			out._incRef();
		}
	} catch (e) {
		/* Restore the previous state */
		a._id = idA;
		a._incRef();
		throw e;
	}

	var request = new Request();
	request.id = allocator.newMessageId();
	request.type = Request.Type.REDUCTION_OPERATION;
	var reductionRequest = new ReductionRequest();
	reductionRequest.type = operation;
	reductionRequest.idA = (releaseIdA ? -idA : idA);
	reductionRequest.idOut = out._id;
	request.reductionRequest = reductionRequest;
	context._postMessage(request.encodeAB());

	a._tryInvalidate();
	return out;
};

var axisReduceArithOp = function(a, axis, out, context, operation) {
	util.checkNDArray(a, "a");
	var idA = a._id;
	var releaseIdA = !a._decRef();
	if (releaseIdA) {
		a._id = 0;
	}
	try {
		util.checkAxis(axis);
		if (typeof out === "undefined") {
			out = new NDArray(util.computeAxisReductionOutShape(a.shape, axis), a.dataType, context);
			out._id = allocator.newArrayId();
		} else {
			util.checkNDArray(out, "out");
			util.checkShapesCompatibility(out.shape, []);
			util.checkDataTypesCompatibility(a.dataType, out.dataType);
			out._incRef();
		}
	} catch (e) {
		/* Restore the previous state */
		a._id = idA;
		a._incRef();
		throw e;
	}

	var request = new Request();
	request.id = allocator.newMessageId();
	request.type = Request.Type.AXIS_REDUCTION_OPERATION;
	var axisReductionRequest = new AxisReductionRequest();
	axisReductionRequest.type = operation;
	axisReductionRequest.idA = (releaseIdA ? -idA : idA);
	axisReductionRequest.axis = axis;
	axisReductionRequest.idOut = out._id;
	request.axisReductionRequest = axisReductionRequest;
	context._postMessage(request.encodeAB());

	a._tryInvalidate();
	return out;
};

var dotArithOp = function(a, b, out, context) {
	util.checkNDArray(a, "a");
	util.checkNDArray(b, "b");
	util.checkDataTypesCompatibility(a.dataType, b.dataType);
	var idA = a._id;
	var releaseIdA = !a._decRef();
	if (releaseIdA) {
		a._id = 0;
	}
	var idB = b._id;
	var releaseIdB = !b._decRef();
	if (releaseIdB) {
		b._id = 0;
	}
	try {
		if (typeof out === "undefined") {
			var shapeA = a.shape;
			var shapeB = b.shape;
			var axisA = Math.max(shapeA.length - 1, 0);
			var axisB = Math.max(shapeB.length - 2, 0);
			if (shapeA[axisA] != shapeB[axisB]) {
				throw new TypeError("Mismatch in reduction dimensions");
			}
			var shapeOut = [];
			for (var i = 0; i < axisA; i++) {
				shapeOut.push(shapeA[i]);
			}
			if (shapeB.length > 1) {
				for (var i = 0; i < axisB; i++) {
					shapeOut.push(shapeB[i]);
				}
				shapeOut.push(shapeB[shapeB.length - 1]);
			}
			out = new NDArray(shapeOut, a.dataType, context);
			out._id = allocator.newArrayId();
		} else if (out instanceof NDArray) {
			util.checkNDArray(out, "out");
			util.checkDataTypesCompatibility(a.dataType, out.dataType);
			throw new Error("Not implemented");
		}
	} catch (e) {
		/* Restore the previous state */
		a._id = idA;
		a._incRef();
		b._id = idB;
		b._incRef();
		throw e;
	}

	var request = new Request();
	request.id = allocator.newMessageId();
	request.type = Request.Type.DOT_OPERATION;
	var dotOperationRequest = new DotOperationRequest();
	dotOperationRequest.idA = (releaseIdA ? -idA : idA);
	dotOperationRequest.idB = (releaseIdB ? -idB : idB);
	dotOperationRequest.idOut = out._id;
	request.dotOperationRequest = dotOperationRequest;
	context._postMessage(request.encodeAB());

	a._tryInvalidate();
	b._tryInvalidate();
	return out;
};

PBContext.prototype.add = function(a, b, out) {
	return binaryArithOp(a, b, out, this,
		BinaryOperationRequest.Type.ADD,
		BinaryConstOperationRequest.Type.ADDC,
		BinaryConstOperationRequest.Type.ADDC);
};

PBContext.prototype.sub = function(a, b, out) {
	return binaryArithOp(a, b, out, this,
		BinaryOperationRequest.Type.SUB,
		BinaryConstOperationRequest.Type.SUBC,
		BinaryConstOperationRequest.Type.SUBRC);
};

PBContext.prototype.mul = function(a, b, out) {
	return binaryArithOp(a, b, out, this,
		BinaryOperationRequest.Type.MUL,
		BinaryConstOperationRequest.Type.MULC,
		BinaryConstOperationRequest.Type.MULC);
};

PBContext.prototype.div = function(a, b, out) {
	return binaryArithOp(a, b, out, this,
		BinaryOperationRequest.Type.DIV,
		BinaryConstOperationRequest.Type.DIVC,
		BinaryConstOperationRequest.Type.DIVRC);
};

PBContext.prototype.neg = function(a, out) {
	return unaryArithOp(a, out, this,
		UnaryOperationRequest.Type.NEG);
};

PBContext.prototype.abs = function(a, out) {
	return unaryArithOp(a, out, this,
		UnaryOperationRequest.Type.ABS);
};

PBContext.prototype.exp = function(a, out) {
	return unaryArithOp(a, out, this,
		UnaryOperationRequest.Type.EXP);
};

PBContext.prototype.log = function(a, out) {
	return unaryArithOp(a, out, this,
		UnaryOperationRequest.Type.LOG);
};

PBContext.prototype.sqrt = function(a, out) {
	return unaryArithOp(a, out, this,
		UnaryOperationRequest.Type.SQRT);
};

PBContext.prototype.square = function(a, out) {
	return unaryArithOp(a, out, this,
		UnaryOperationRequest.Type.SQUARE);
};

PBContext.prototype.min = function(a, axis) {
	if (typeof axis === "undefined") {
		return reduceArithOp(a, undefined, this,
			ReductionRequest.Type.MIN);
	} else if (util.isInt(axis)) {
		return axisReduceArithOp(a, axis, undefined, this,
			AxisReductionRequest.Type.MIN);
	} else {
		throw new TypeError("Unsupported axis type");
	}
};

PBContext.prototype.max = function(a, axis) {
	if (typeof axis === "undefined") {
		return reduceArithOp(a, undefined, this,
			ReductionRequest.Type.MAX);
	} else if (util.isInt(axis)) {
		return axisReduceArithOp(a, axis, undefined, this,
			AxisReductionRequest.Type.MAX);
	} else {
		throw new TypeError("Unsupported axis type");
	}
};

PBContext.prototype.sum = function(a, axis) {
	if (typeof axis === "undefined") {
		return reduceArithOp(a, undefined, this,
			ReductionRequest.Type.SUM);
	} else if (util.isInt(axis)) {
		return axisReduceArithOp(a, axis, undefined, this,
			AxisReductionRequest.Type.SUM);
	} else {
		throw new TypeError("Unsupported axis type");
	}
};

PBContext.prototype.dot = function(a, b, out) {
	return dotArithOp(a, b, out, this);
};

module.exports = PBContext;

},{"./DataType":1,"./NDArray":2,"./allocator":5,"./requests.pb":10,"./responses.pb":11,"./util":12}],4:[function(require,module,exports){
"use strict";

var PBContext = require("./PBContext");

function PNaClContext(options, callback) {
	var self = this;
	this._pnaclObject = document.createElement("object");
	this._pnaclObject.width = 0;
	this._pnaclObject.height = 0;
	this._pnaclObject.data = PNaClContext.getManifestURL(options.baseUrl);
	this._pnaclObject.type = "application/x-pnacl";
	this._pnaclObject.addEventListener("message", function(e) {
		self._messagingContext._onMessage(e);
	}, true);
	this._messagingContext = new PBContext(options, function(message) {
		self._pnaclObject.postMessage(message);
	}, callback);
	document.body.appendChild(this._pnaclObject);
}

PNaClContext.isSupported = function() {
	try {
		return (typeof navigator.mimeTypes["application/x-pnacl"]) !== "undefined";
	} catch (e) {
	}
	return false;
};

PNaClContext.getManifestURL = function(baseUrl) {
	if (baseUrl) {
		return baseUrl + "furious.nmf";
	} else {
		return "furious.nmf";
	}
};

PNaClContext.prototype.empty = function(shape, dataType) {
	return this._messagingContext.empty(shape, dataType);
};

PNaClContext.prototype.zeros = function(shape, dataType) {
	return this._messagingContext.zeros(shape, dataType);
};

PNaClContext.prototype.ones = function(shape, dataType) {
	return this._messagingContext.ones(shape, dataType);
};

PNaClContext.prototype.array = function(data, dataType) {
	return this._messagingContext.array(data, dataType);
};

PNaClContext.prototype.linspace = function(start, stop, samples, closed) {
	return this._messagingContext.linspace(start, stop, samples, closed);
};

PNaClContext.prototype.reshape = function(a, shape) {
	return this._messagingContext.reshape(a, shape);
};

PNaClContext.prototype.repeat = function(a, repeats, axis, out) {
	return this._messagingContext.repeat(a, repeats, axis, out);
};

PNaClContext.prototype._invalidate = function(array) {
	return this._messagingContext._invalidate(array);
};

PNaClContext.prototype.fetch = function() {
	this._messagingContext.fetch.apply(this._messagingContext, arguments);
};

PNaClContext.prototype.get = function() {
	this._messagingContext.get.apply(this._messagingContext, arguments);
};

PNaClContext.prototype.info = function(callback) {
	this._messagingContext.info(callback);
};

PNaClContext.prototype.barrier = function(callback) {
	this._messagingContext.barrier(callback);
};

PNaClContext.prototype.add = function(a, b, out) {
	return this._messagingContext.add(a, b, out);
};

PNaClContext.prototype.sub = function(a, b, out) {
	return this._messagingContext.sub(a, b, out);
};

PNaClContext.prototype.mul = function(a, b, out) {
	return this._messagingContext.mul(a, b, out);
};

PNaClContext.prototype.div = function(a, b, out) {
	return this._messagingContext.div(a, b, out);
};

PNaClContext.prototype.neg = function(a, out) {
	return this._messagingContext.neg(a, out);
};

PNaClContext.prototype.abs = function(a, out) {
	return this._messagingContext.abs(a, out);
};

PNaClContext.prototype.exp = function(a, out) {
	return this._messagingContext.exp(a, out);
};

PNaClContext.prototype.log = function(a, out) {
	return this._messagingContext.log(a, out);
};

PNaClContext.prototype.sqrt = function(a, out) {
	return this._messagingContext.sqrt(a, out);
};

PNaClContext.prototype.square = function(a, out) {
	return this._messagingContext.square(a, out);
};

PNaClContext.prototype.min = function(a, axis) {
	return this._messagingContext.min(a, axis);
};

PNaClContext.prototype.max = function(a, axis) {
	return this._messagingContext.max(a, axis);
};

PNaClContext.prototype.sum = function(a, axis) {
	return this._messagingContext.sum(a, axis);
};

PNaClContext.prototype.dot = function(a, b, out) {
	return this._messagingContext.dot(a, b, out);
};

module.exports = PNaClContext;

},{"./PBContext":3}],5:[function(require,module,exports){
"use strict";

var messageId = 1;
var arrayId = 1;

exports.newMessageId = function() {
	var id = messageId;
	messageId = (messageId+1)|0;
	return id;
};

exports.newArrayId = function () {
	var id = arrayId;
	arrayId = (arrayId+1)|0;
	return id;
};

},{}],6:[function(require,module,exports){
"use strict";

/**
 * Provides information and support functions
 *
 * @class furious
 */

var DataType = require("./DataType");
var JSContext = require("./js/JSContext");
var WebWorkerContext = require("./js/WebWorkerContext");
var PNaClContext = require("./PNaClContext");
var WebCLContext = require("./webcl/WebCLContext");

var currentScriptUri = null;
try {
	currentScriptUri = document.currentScript.src;
} catch (e) {
	try {
		var scripts = document.getElementsByTagName("script");
		currentScriptUri = scripts[scripts.length - 1].src;
	} catch (e) {
	}
}
var currentScriptDir = null;
if (currentScriptUri !== null) {
	var separatorPos = currentScriptUri.lastIndexOf("/");
	var currentScriptDir = currentScriptUri.substr(0, separatorPos + 1);
}

/**
 * Initializes a computational context.
 *
 * @static
 * @method init
 * @async
 *
 * @param {String} [backend] - A string identifier for the backend to use. The following values are supported:
 *
 *     <table>
 *         <tr>
 *             <th>Backend Identifier</th>
 *             <th>Interpretation</th>
 *         </tr>
 *         <tr>
 *             <td>"javascript"</td>
 *             <td>JavaScript backend. Works in all browsers and Node.js, but can not deliver optimal performance.</td>
 *         </tr>
 *         <tr>
 *             <td>"pnacl"</td>
 *             <td>Portable Native Client (PNaCl) backend. Works in Chromium-based browsers. Can accelerate computations through the use of advanced CPU optimization technologies, such as multi-threading and SIMD instructions.</td>
 *         </tr>
 *         <tr>
 *             <td>"webcl"</td>
 *             <td>WebCL backend. Works in browsers and Node.js when a WebCL plugin is available. Can use full power of CPUs and GPUs to accelerate computations.</td>
 *         </tr>
 *     </table>
 *
 * @param {Object} options - Backend-specific options.
 * @param {Function} callback - A callback function that is called when the backend finish initialization.
 * @param {Context} callback.context - A ready to use computational context.
 */
var init = function(backend, options, callback) {
	if (typeof callback === "undefined") {
		if (typeof options === "undefined") {
			/* Called with one parameter: callback */
			callback = backend;
			options = undefined;
			backend = undefined;
		} else {
			/* Called with two parameters: backend and callback */
			callback = options;
			options = undefined;
		}
	}
	if (typeof backend === "undefined") {
		backend = getDefaultBackend();
	}
	if (typeof options === "undefined") {
		options = {};
	}
	if (backend === "javascript") {
		var async = options.async;
		if (typeof async === "undefined") {
			async = WebWorkerContext.isSupported();
		}
		if (async) {
			options.baseUrl = currentScriptDir;
			return new WebWorkerContext(options, callback);
		} else {
			return new JSContext(options, callback);
		}
	} else if (backend === "pnacl") {
		options.baseUrl = currentScriptDir;
		return new PNaClContext(options, callback);
	} else if (backend === "webcl") {
		return new WebCLContext(options, callback);
	} else {
		throw new Error("Unsupported backend: " + backend);
	}
};

/**
 * Detects the optimal backend supported by the browser or JavaScript engine.
 *
 * @static
 * @method getDefaultBackend
 *
 * @return {String} - Default backend identifier from the following table:
 *
 *     <table>
 *         <tr>
 *             <th>Backend Identifier</th>
 *             <th>Interpretation</th>
 *         </tr>
 *         <tr>
 *             <td>"javascript"</td>
 *             <td>JavaScript backend. Works in all browsers and Node.js, but can not deliver optimal performance.</td>
 *         </tr>
 *         <tr>
 *             <td>"asmjs"</td>
 *             <td>Asm.js backend. Works in Firefox 29 and later. Can accelerate computations with a limited use of native CPU instructions.</td>
 *         </tr>
 *         <tr>
 *             <td>"pnacl"</td>
 *             <td>Portable Native Client (PNaCl) backend. Works in Chromium-based browsers. Can accelerate computations through the use of advanced CPU optimization technologies, such as multi-threading and SIMD instructions.</td>
 *         </tr>
 *         <tr>
 *             <td>"webcl"</td>
 *             <td>WebCL backend. Works in browsers and Node.js when a WebCL plugin is available. Can use full power of CPUs and GPUs to accelerate computations.</td>
 *         </tr>
 *     </table>
 */
var getDefaultBackend = function() {
	if (WebCLContext.isUsable()) {
		return "webcl";
	} else if (PNaClContext.isSupported()) {
		return "pnacl";
	} else {
		return "javascript";
	}
};

/**
 * Detects which backends are supported by the system.
 *
 * @static
 * @method getSupportedBackends
 *
 * @return {String[]} - An array of supported backend identifiers in priority order (prioritized backends first). The following identifiers could be present:
 *
 *     <table>
 *         <tr>
 *             <th>Backend Identifier</th>
 *             <th>Interpretation</th>
 *         </tr>
 *         <tr>
 *             <td>"javascript"</td>
 *             <td>JavaScript backend. Works in all browsers and Node.js, but can not deliver optimal performance.</td>
 *         </tr>
 *         <tr>
 *             <td>"asmjs"</td>
 *             <td>Asm.js backend. Works in Firefox 29 and later. Can accelerate computations with a limited use of native CPU instructions.</td>
 *         </tr>
 *         <tr>
 *             <td>"pnacl"</td>
 *             <td>Portable Native Client (PNaCl) backend. Works in Chromium-based browsers. Can accelerate computations through the use of advanced CPU optimization technologies, such as multi-threading and SIMD instructions.</td>
 *         </tr>
 *         <tr>
 *             <td>"webcl"</td>
 *             <td>WebCL backend. Works in browsers and Node.js when a WebCL plugin is available. Can use full power of CPUs and GPUs to accelerate computations.</td>
 *         </tr>
 *     </table>
 */
var getSupportedBackends = function() {
	var backends = [];
	if (WebCLContext.isUsable()) {
		backends.push("webcl");
	}
	if (PNaClContext.isSupported()) {
		backends.push("pnacl");
	}
	if (hasFeature("asm.js")) {
		backends.push("asm.js");
	}
	backends.push("javascript");
	return backends;
};

/**
 * Queries possible backend options available on this platform.
 *
 * @param {String} backend - name of the backend to query options for.
 *
 * @static
 * @method getBackendOptions
 *
 * @return {Object} - An object that describes available options.
 * The names of object's properties correspond to backend option names.
 * Object's properties have array values with possible option values.
 * Below are the backend options for the built-in backends:
 *
 *     <table>
 *         <caption>Options of "javascript" and "asmjs" backends</caption>
 *         <tr>
 *             <th>Option name</th>
 *             <th>Option values</th>
 *             <th>Default value</th>
 *         </tr>
 *         <tr>
 *             <td>"async"</td>
 *             <td>[true, false]</td>
 *             <td>true</td>
 *         </tr>
 *     </table>
 *
 *     <table>
 *         <caption>Options of "pnacl" backend</caption>
 *         <tr>
 *             <th>Option name</th>
 *             <th>Option values</th>
 *             <th>Default value</th>
 *         </tr>
 *         <tr>
 *             <td>"manifest"</td>
 *             <td>undefined</td>
 *             <td>URL of "furious.nmf" file in the same directory as "furious.js" library</td>
 *         </tr>
 *     </table>
 *
 *     <table>
 *         <caption>Options of "webcl" backend</caption>
 *         <tr>
 *             <th>Option name</th>
 *             <th>Option values</th>
 *             <th>Default value</th>
 *         </tr>
 *         <tr>
 *             <td>"device"</td>
 *             <td>Depends on the platform</td>
 *             <td>Discrete GPU device, if available. Otherwise integrated GPU device, if available. Otherwise CPU device.</td>
 *         </tr>
 *     </table>
 */
var getBackendOptions = function(backend) {
	if (backend === "javascript") {
		if (WebWorkerContext.isSupported()) {
			return {
				"async": [true, false]
			};
		} else {
			return {};
		}
	} else if (backend === "pnacl") {
		return {};
	} else if (backend === "webcl") {
		return {
			"device": WebCLContext.getAvailableDevices()
		};
	} else {
		throw new Error("Unsupported backend: " + backend);
	}
};

/**
 * Queries default backend options on this platform.
 *
 * @param {String} backend - name of the backend to query options for.
 *
 * @static
 * @method getBackendOptions
 *
 * @return {Object} - An object that describes available options.
 * The names of object's properties correspond to backend option names.
 * The values of object's properties correspond to default option values.
 */
var getDefaultBackendOptions = function(backend) {
	if (backend === "javascript") {
		return {
			"async": true
		};
	} else if (backend === "pnacl") {
		if (PNaClContext.isSupported()) {
			return {
				"manifest": PNaClContext.getDefaultManifestURL()
			};
		} else {
			return {};
		}
	} else if (backend === "webcl") {
		return {
			"device": WebCLContext.getDefaultDevice()
		};
	} else {
		throw new Error("Unsupported backend: " + backend);
	}
};

/**
 * Detects whether the requested computing feature is available
 *
 * @static
 * @method hasFeature
 *
 * @param {String} name - an identifier of the optional feature to detect. The following identifiers are supported:
 *
 *     <table>
 *         <tr>
 *             <th>Feature Identifier</th>
 *             <th>Interpretation</th>
 *         </tr>
 *         <tr>
 *             <td>"webworkers"</td>
 *             <td>Detect if the JavaScript engine can spawn dedicated Web Workers.</td>
 *         </tr>
 *         <tr>
 *             <td>"asm.js"</td>
 *             <td>Detect if the JavaScript engine recognizes Asm.js directive.</td>
 *         </tr>
 *         <tr>
 *             <td>"simd.js"</td>
 *             <td>Detect if the JavaScript engine provide SIMD.float32x4, SIMD.int32x4, Float32x4Array, and Int32x4Array of SIMD.js</td>
 *         </tr>
 *         <tr>
 *             <td>"webgl"</td>
 *             <td>Detect if the environment supports WebGL (either experimental or stable implementation)</td>
 *         </tr>
 *         <tr>
 *             <td>"webcl"</td>
 *             <td>Detect if the environment supports WebCL</td>
 *         </tr>
 *         <tr>
 *             <td>"pnacl"</td>
 *             <td>Detect if Portable Native Client (PNaCl) is supported and enabled</td>
 *         </tr>
 *         <tr>
 *             <td>"nacl"</td>
 *             <td>Detect if Native Client (NaCl) is supported and enabled</td>
 *         </tr>
 *     </table>
 *
 * @return {Boolean} - true if the feature is supported, false otherwise
 */
var hasFeature = function(name) {
	switch (name) {
		case "asm.js":
			try {
				var userAgent = window.navigator.userAgent;
				var userAgentComponents = userAgent.split(/\s+/);
				var firefoxRegexp = /[Ff]irefox\/(\d+)/g;
				for (var i = 0; i < userAgentComponents.length; ++i) {
					var component = userAgentComponents[i];
					var match = firefoxRegexp.exec(component);
					if (match !== null) {
						var firefoxVersion = parseInt(match[1]);
						return firefoxVersion >= 29;
					}
				}
				return false;
			} catch (e) {
			}
			return false;
		case "simd.js":
			return (typeof SIMD !== "undefined") &&
				(typeof Float32x4Array !== "undefined") &&
				(typeof Int32x4Array !== "undefined");
		case "webworkers":
			return (typeof Worker !== "undefined");
		case "webgl":
			try {
				var canvas = document.createElement("canvas");
				try {
					if (canvas.getContext("webgl") !== null) {
						return true;
					}
				} catch (e) {
				}
				try {
					if (canvas.getContext("experimental-webgl") !== null) {
						return true;
					}
				} catch (e) {
				}
			} catch (e) {
			}
			return false;
		case "webcl":
			return WebCLContext.isSupported();
		case "pnacl":
			return PNaClContext.isSupported();
		case "nacl":
			try {
				return (typeof navigator.mimeTypes["application/x-nacl"]) !== "undefined";
			} catch (e) {
			}
			return false;
		default:
			throw new Error("Unknown feature: " + name);
	}
};

exports.init = init;
exports.hasFeature = hasFeature;
exports.getDefaultBackend = getDefaultBackend;
exports.getSupportedBackends = getSupportedBackends;
exports.getBackendOptions = getBackendOptions;
exports.getDefaultBackendOptions = getDefaultBackendOptions;
exports.DataType = DataType;

},{"./DataType":1,"./PNaClContext":4,"./js/JSContext":7,"./js/WebWorkerContext":8,"./webcl/WebCLContext":13}],7:[function(require,module,exports){
"use strict";

var NDArray = require("./../NDArray");
var DataType = require("./../DataType");
var util = require("./../util");
var jsmath = require("./jsmath");

/**
 * Provides methods for creation, manipulation, and destruction of N-dimensional arrays.
 * Arithmetic operations are possible only on arrays that belong to the same context.
 *
 * @class Context
 * @constructor
 */
function JSContext(options, callback) {
	callback(this);
}

/**
 * Constructs an uninialized N-dimensional array.
 *
 * @method empty
 * @param {Number} shape - the dimensions of the array
 * @param {DataType} dataType - the type of elements in the array.
 */
JSContext.prototype.empty = function(shape, dataType) {
	/* The is no way to create uninitialized typed array in JavaScript */
	return this.zeros(shape, dataType);
};

/**
 * Constructs an N-dimensional array with elements initialized to zero.
 *
 * @method zeros
 * @param {Number} shape - the dimensions of the array
 * @param {DataType} dataType - the type of elements in the array.
 */
JSContext.prototype.zeros = function(shape, dataType) {
	shape = util.checkShape(shape);
	if (typeof dataType === "undefined") {
		dataType = new DataType("f64");
	} else {
		dataType = util.checkDataType(dataType);
	}
	var array = new NDArray(shape, dataType, this);
	array._data = new dataType.arrayType(array.length);
	return array;
};

/**
 * Constructs an N-dimensional array with elements initialized to one.
 *
 * @method ones
 * @param {Number} shape - the dimensions of the array
 * @param {DataType} dataType - the type of elements in the array.
 */
JSContext.prototype.ones = function(shape, dataType) {
	/* The is no way to create uninitialized typed array in JavaScript */
	var array = this.zeros(shape, dataType);
	jsmath.fill(array._data, 1.0);
	return array;
};

/**
 * Constructs an N-dimensional array object with the provided data.
 *
 * @method array
 * @param {Number[]} data - the array data
 * @param {DataType} dataType - the type of elements in the array.
 */
JSContext.prototype.array = function(data, dataType) {
	if (typeof dataType === "undefined") {
		dataType = new DataType("f64");
	} else {
		dataType = util.checkDataType(dataType);
	}
	var shape = [];
	util.discoverArrayShapeRecursive(data, shape, 0);
	var array = this.empty(shape, dataType);
	util.copyArrayDataRecursive(array._data, data, shape, 0, 0);
	return array;
};

/**
 * De-allocates data associated with the array.
 *
 * @method _invalidate
 * @private
 *
 * @param {NDArray} array - the n-dimensional array object with data to be de-allocated.
 */
JSContext.prototype._invalidate = function(array) {
	util.checkNDArray(array, "array");
	array._data = null;
};

/**
 * Fetches NDArray data and asynchronously returns it as JavaScript typed arrays.
 *
 * @method fetch
 * @async
 *
 * @param {NDArray} arrays* - NDArrays to fetch.
 * @param {Function} callback - A callback to be called with the data when it is available.
 * @param {ArrayBufferView} callback.arrays* - typed arrays with the data. The element type of the typed array matches the data type of the NDArray. For zero-dimensional arrays the output is returned as a typed array with a single element. Multi-dimensional arrays are returned in row-major storage format.
 */
JSContext.prototype.fetch = function() {
	if (arguments.length === 0) {
		throw new Error("Callback argument missing");
	}
	var callback = arguments[arguments.length - 1];
	/* Validate arguments */
	if (arguments.length === 1) {
		throw new Error("At least one NDArray argument expected");
	}
	for (var i = 0; i < arguments.length - 1; ++i) {
		util.checkNDArray(arguments[i], "argument " + i);
	}
	for (var i = 0; i < arguments.length - 1; ++i) {
		arguments[i]._decRef();
	}
	var callbackArguments = new Array(arguments.length - 1);
	for (var i = 0; i < callbackArguments.length; ++i) {
		var array = arguments[i];
		callbackArguments[i] = new array.dataType.arrayType(array._data);
	}
	for (var i = 0; i < arguments.length - 1; ++i) {
		arguments[i]._tryInvalidate();
	}
	callback.apply(null, callbackArguments);
};

/**
 * Fetches NDArray data and asynchronously returns it as JavaScript arrays or numbers.
 *
 * @method get
 * @async
 *
 * @param {NDArray} arrays* - NDArrays to fetch.
 * @param {Function} callback - A callback to be called with the data when it is available.
 * @param {Number|Number[]} callback.arrays* - JavaScript numbers or multidimensional arrays with the data. The number and order of arguments matches the NDArrays passed to the method call.
 */
JSContext.prototype.get = function() {
	if (arguments.length === 0) {
		throw new Error("Callback argument missing");
	}
	var callback = arguments[arguments.length - 1];
	/* Validate arguments */
	if (arguments.length === 1) {
		throw new Error("At least one NDArray argument expected");
	}
	for (var i = 0; i < arguments.length - 1; ++i) {
		util.checkNDArray(arguments[i], "argument " + i);
	}
	for (var i = 0; i < arguments.length - 1; ++i) {
		arguments[i]._decRef();
	}
	var callbackArguments = new Array(arguments.length - 1);
	for (var i = 0; i < callbackArguments.length; ++i) {
		var array = arguments[i];
		if (array.shape.length === 0) {
			callbackArguments[i] = array._data[0];
		} else {
			var jsarray = new Array(array.shape[0]);
			util.createArrayRecursive(array._data, jsarray, array.shape, 0, 0);
			callbackArguments[i] = jsarray;
		}
	}
	for (var i = 0; i < arguments.length - 1; ++i) {
		arguments[i]._tryInvalidate();
	}
	callback.apply(null, callbackArguments);
};

/**
 * Waits until previous commands finished execution and calls the callback.
 *
 * @method barrier
 * @async
 *
 * @param {Function} callback - A callback to be called after the previous commands retire.
 */
JSContext.prototype.barrier = function(callback) {
	callback();
};

/**
 * Creates another array with the same data, but different dimensions.
 *
 * @method reshape
 * @param {(NDArray|Number)} shape - dimensions of the new array.
 */
JSContext.prototype.reshape = function(array, shape) {
	shape = util.checkShape(shape);
	if (util.computeLength(shape) !== array.length) {
		throw new RangeError("The shape is not compatible with the array");
	}
	var out = new NDArray(shape, array.dataType, this);
	if (array._decRef()) {
		out._data = new out.dataType.arrayType(out.length);
		out._data.set(array._data);
	} else {
		out._data = array._data;
		array._tryInvalidate();
	}
	return out;
};

/**
 * Duplicates array elements along the specified axis.
 *
 * @method repeat
 * @param {NDArray} a - the input array.
 * @param {Number} repeats - the number of times to repeat each element.
 * @param {Number} axis - the axis along which the elements will be duplicated.
 * @param {NDArray} [out] - an output array to store the result.
 * @return {NDArray} - an N-dimensional array with repeated elements of array **a**.
 */
JSContext.prototype.repeat = function(a, repeats, axis, out) {
	util.checkNDArray(a, "a");
	repeats = util.checkRepeats(repeats);
	axis = util.checkAxis(axis, a.shape.length);
	var shapeA = a.shape;
	var shapeOut = shapeA.slice(0);
	shapeOut[axis] *= repeats;
	a._decRef();
	try {
		if (typeof out === "undefined") {
			out = this.empty(shapeOut, a.dataType);
		} else {
			util.checkNDArray(out, "out");
			util.checkShapesCompatibility(out.shape, shapeOut);
			util.checkDataTypesCompatibility(a.dataType, out.dataType);
			out._incRef();
		}
		var outerStride = util.computeOuterStride(shapeA, axis);
		var innerStride = util.computeInnerStride(shapeA, axis);
		jsmath.repeat(a._data, out._data, outerStride, innerStride, shapeA[axis], repeats);
	} catch (e) {
		a._incRef();
		throw e;
	}
	a._tryInvalidate();
	return out;
};

var binaryArithOp = function(a, b, out, context, operation, operationConst, operationRevConst) {
	var shapeOut = null, dataTypeOut = null;
	if (a instanceof NDArray) {
		shapeOut = a.shape;
		dataTypeOut = a.dataType;
		if (b instanceof NDArray) {
			util.checkShapesCompatibility(a.shape, b.shape);
			util.checkDataTypesCompatibility(a.dataType, b.dataType);
		} else if (!util.isNumber(b)) {
			throw new TypeError("Unsupported type of b");
		}
	} else if (util.isNumber(a)) {
		shapeOut = b.shape;
		dataTypeOut = b.dataType;
		util.checkNDArray(b, "b");
	} else {
		throw new TypeError("Unsupported type of a");
	}
	if (a instanceof NDArray) {
		a._decRef();
	}
	if (b instanceof NDArray) {
		b._decRef();
	}
	try {
		if (typeof out === "undefined") {
			out = new NDArray(shapeOut, dataTypeOut, context);
			if ((a instanceof NDArray) && !a._hasRefs()) {
				out._data = a._data;
			} else if ((b instanceof NDArray) && !b._hasRefs()) {
				out._data = b._data;
			} else {
				out._data = new dataTypeOut.arrayType(out.length);
			}
		} else {
			util.checkNDArray(out, "out");
			util.checkShapesCompatibility(shapeOut, out.shape);
			util.checkDataTypesCompatibility(dataTypeOut, out.dataType);
			out._incRef();
		}
		if (a instanceof NDArray) {
			if (b instanceof NDArray) {
				operation(a._data, b._data, out._data);
			} else {
				operationConst(a._data, +b, out._data);
			}
		} else {
			operationRevConst(b._data, +a, out._data);
		}
	} catch (e) {
		/* Restore the previous state */
		if (a instanceof NDArray) {
			a._incRef();
		}
		if (b instanceof NDArray) {
			b._incRef();
		}
		throw e;
	}
	if (a instanceof NDArray) {
		a._tryInvalidate();
	}
	if (b instanceof NDArray) {
		b._tryInvalidate();
	}
	return out;
};

var unaryArithOp = function(a, out, context, operation) {
	util.checkNDArray(a, "a");
	a._decRef();
	try {
		if (typeof out === "undefined") {
			out = new NDArray(a.shape, a.dataType, context);
			if ((a instanceof NDArray) && !a._hasRefs()) {
				out._data = a._data;
			} else {
				out._data = new a.dataType.arrayType(out.length);
			}
		} else {
			util.checkNDArray(out, "out");
			util.checkShapesCompatibility(a.shape, out.shape);
			util.checkDataTypesCompatibility(a.dataType, out.dataType);
			out._incRef();
		}
		operation(a._data, out._data);
	} catch (e) {
		/* Restore the previous state */
		a._incRef();
		throw e;
	}
	a._tryInvalidate();
	return out;
};

var axisReduceOp = function(a, axis, out, context, operation, axisOperation) {
	util.checkNDArray(a, "a");
	if (typeof axis === "undefined") {
		if (typeof out === "undefined") {
			out = context.empty([], a.dataType);
		} else {
			util.checkNDArray(out, "out");
			util.checkShapesCompatibility([], out.shape);
			util.checkDataTypesCompatibility(a.dataType, out.dataType);
			out._incRef();
		}
		operation(a._data, out._data);
		a._tryRelease();
		return out;
	} else {
		axis = util.checkAxis(axis, a.shape.length);
		var shapeOut = util.computeAxisReductionOutShape(a.shape, axis);
		if (typeof out === "undefined") {
			out = context.empty(shapeOut, a.dataType);
		} else {
			util.checkNDArray(out, "out");
			util.checkShapesCompatibility([], out.shape);
			util.checkDataTypesCompatibility(a.dataType, out.dataType);
			out._incRef();
		}
		axisOperation(a._data, out._data,
			util.computeOuterStride(a.shape, axis),
			util.computeInnerStride(a.shape, axis),
			a.shape[axis]);
		a._tryRelease();
		return out;
	}
};

/**
 * Adds one number or array with another number or array.
 * Addition is performed element-by-element.
 *
 * @method add
 * @param {(NDArray|Number)} a - one number or array to add. If **b** is a *Number*, **a** must be an *NDArray*.
 * @param {(NDArray|Number)} b - another number or array to add. If **a** is a *Number*, **b** must be an *NDArray*.
 * @param {NDArray} [out] - the array where the result is to be stored. If provided, must match the shape and data type of input arrays.
 * @return {NDArray} - the result of element-wise addition of **a** and **b**.
 */
JSContext.prototype.add = function(a, b, out) {
	return binaryArithOp(a, b, out, this, jsmath.add, jsmath.addConst, jsmath.addConst);
};

/**
 * Subtracts one number or array from another number or array.
 * Subtraction is performed element-by-element.
 *
 * @method sub
 * @param {(NDArray|Number)} a - the number or array to subtract from. If **b** is a *Number*, **a** must be an *NDArray*.
 * @param {(NDArray|Number)} b - the number or array to subtract. If **a** is a *Number*, **b** must be an *NDArray*.
 * @param {NDArray} [out] - the array where the result is to be stored. If provided, must match the shape and data type of input arrays.
 * @return {NDArray} - the result of element-wise subtraction of **b** from **a**.
 */
JSContext.prototype.sub = function(a, b, out) {
	return binaryArithOp(a, b, out, this, jsmath.sub, jsmath.subConst, jsmath.subRevConst);
};

/**
 * Multiplies one number or array by another number or array.
 * Multiplication is performed element-by-element.
 *
 * @method mul
 * @param {(NDArray|Number)} a - one number or array to multiply. If **b** is a *Number*, **a** must be an *NDArray*.
 * @param {(NDArray|Number)} b - another number or array to multiply. If **a** is a *Number*, **b** must be an *NDArray*.
 * @param {NDArray} [out] - the array where the result is to be stored. If provided, must match the shape and data type of input arrays.
 * @return {NDArray} - the result of element-wise multiplication of **a** and **b**.
 */
JSContext.prototype.mul = function(a, b, out) {
	return binaryArithOp(a, b, out, this, jsmath.mul, jsmath.mulConst, jsmath.mulConst);
};

/**
 * Divides one number or array by another number or array.
 * Division is performed element-by-element.
 *
 * @method div
 * @param {(NDArray|Number)} a - the number or array to divide. If **b** is a *Number*, **a** must be an *NDArray*.
 * @param {(NDArray|Number)} b - the number or array to divide by. If **a** is a *Number*, **b** must be an *NDArray*.
 * @param {NDArray} [out] - the array where the result is to be stored. If provided, must match the shape and data type of input arrays.
 * @return {NDArray} - the result of element-wise division of **a** by **b**.
 */
JSContext.prototype.div = function(a, b, out) {
	return binaryArithOp(a, b, out, this, jsmath.div, jsmath.divConst, jsmath.divRevConst);
};

JSContext.prototype.min = function(a, axis, out) {
	return axisReduceOp(a, axis, out, this, jsmath.min, jsmath.axisMin);
};

JSContext.prototype.max = function(a, axis, out) {
	return axisReduceOp(a, axis, out, this, jsmath.max, jsmath.axisMax);
};

JSContext.prototype.sum = function(a, axis, out) {
	return axisReduceOp(a, axis, out, this, jsmath.sum, jsmath.axisSum);
};

/**
 * Negates array elements.
 *
 * @method neg
 * @param {NDArray} a - the array of elements to be negated.
 * @param {NDArray} [out] - the array for negated elements. If supplied, must match the dimensions and data type of the **a** array.
 */
JSContext.prototype.neg = function(a, out) {
	return unaryArithOp(a, out, this, jsmath.neg);
};

/**
 * Computes absolute value of array elements.
 *
 * @method abs
 * @param {NDArray} a - the array of input elements.
 * @param {NDArray} [out] - the array for computed absolute values. If supplied, must match the dimensions and data type of the **a** array.
 */
JSContext.prototype.abs = function(a, out) {
	return unaryArithOp(a, out, this, jsmath.abs);
};

/**
 * Exponentiates array elements.
 *
 * @method exp
 * @param {NDArray} a - the array of elements to be exponentiated.
 * @param {NDArray} [out] - the array for exponentiated elements. If supplied, must match the dimensions and data type of the **a** array.
 */
JSContext.prototype.exp = function(a, out) {
	return unaryArithOp(a, out, this, jsmath.exp);
};

/**
 * Computes logarithm of array elements.
 *
 * @method log
 * @param {NDArray} a - the array of input elements.
 * @param {NDArray} [out] - the array for computed logarithm values. If supplied, must match the dimensions and data type of the **a** array.
 */
JSContext.prototype.log = function(a, out) {
	return unaryArithOp(a, out, this, jsmath.log);
};

/**
 * Computes square root of array elements.
 *
 * @method sqrt
 * @param {NDArray} a - the array of input elements.
 * @param {NDArray} [out] - the array for computed square root values. If supplied, must match the dimensions and data type of the **a** array.
 */
JSContext.prototype.sqrt = function(a, out) {
	return unaryArithOp(a, out, this, jsmath.sqrt);
};

/**
 * Squares array elements.
 *
 * @method square
 * @param {NDArray} a - the array of elements to be squared.
 * @param {NDArray} [out] - the array for squared elements. If supplied, must match the dimensions and data type of the **a** array.
 */
JSContext.prototype.square = function(a, out) {
	return unaryArithOp(a, out, this, jsmath.square);
};

/**
 * Computes the dot product of two N-dimensional arrays.
 *
 * @method dot
 * @param {NDArray} a - the first input array.
 * @param {NDArray} b - the second input array.
 * @param {NDArray} [out] - the output array. If supplied, must match the data type of **a** and **b** arrays and have the expected shape. Can not be the same array as **a** or **b**.
 * @return {NDArray} - the array with the dot product of **a** and **b**.
 */
JSContext.prototype.dot = function(a, b, out) {
	util.checkNDArray(a, "a");
	util.checkNDArray(b, "b");
	util.checkDataTypesCompatibility(a.dataType, b.dataType);

	/* The axis of b used in reduction: axis 0 for 1D array, second-to-last axis for ND array */
	var aAxis = Math.max(a.shape.length - 1, 0);
	var bAxis = Math.max(b.shape.length - 2, 0);
	var reductionDim = a.shape[aAxis];
	if (reductionDim !== b.shape[bAxis]) {
		throw new RangeError("Arrays have incompatible reduction dimensions");
	}
	var shapeOut = [], strideA = 1, outerStrideB = 1, innerStrideB = 1;
	for (var i = 0; i < aAxis; i++) {
		shapeOut.push(a.shape[i]);
		strideA *= a.shape[i];
	}
	for (var i = 0; i < b.shape.length; i++) {
		var dim = b.shape[i];
		if (i < bAxis) {
			outerStrideB *= dim;
			shapeOut.push(dim);
		} else if (i > bAxis) {
			innerStrideB *= dim;
			shapeOut.push(dim);
		}
	}
	if (typeof out === "undefined") {
		out = this.empty(shapeOut, a.dataType);
	} else if (out instanceof NDArray) {
		util.checkNDArray(out, "out");
		util.checkShapesCompatibility(out.shape, shapeOut);
		util.checkDataTypesCompatibility(out.dataType, a.dataType);
		util.checkDifferentNDArrays(a, out, "a", "out");
		util.checkDifferentNDArrays(b, out, "b", "out");
		out._incRef();
	}
	jsmath.dot(a._data, b._data, out._data, strideA, outerStrideB, innerStrideB, reductionDim);
	a._tryRelease();
	b._tryRelease();
	return out;
};

/**
 * Creates an arithmetic sequence.
 *
 * @method linspace
 * @param {Number} start - the starting endpoint of the sequence. Must be a finite number.
 * @param {Number} stop - the final endpoint of the sequence. Must be a finite number.
 * @param {Number} [samples=50] - the number of samples in the sequency. Must be a positive integer.
 * @param {Boolean} [closed=true] - an indicator of whether the final endpoint (`stop` argument) should be included in the sequence.
 */
JSContext.prototype.linspace = function(start, stop, samples, closed) {
	if (!util.isReal(start)) {
		throw new TypeError(start + " is not a real number");
	}
	if (!util.isReal(stop)) {
		throw new TypeError(stop + " is not a real number");
	}
	if (typeof samples === "undefined") {
		/* Default value in NumPy */
		samples = 50;
	} else if (!util.isInt(samples)) {
		throw new TypeError(samples + " is not an integer");
	} else if (samples <= 0) {
		throw new RangeError("The number of samples must be positive");
	}
	if (typeof closed === "undefined") {
		closed = true;
	}
	if (closed && (samples === 1)) {
		throw new RangeError("The number of samples must be a least 2 (for start and end points)");
	}
	var array = this.empty(samples, new DataType("f64"));
	var data = array._data;
	var range = stop - start;
	var n = (closed) ? samples - 1 : samples;
	var step = range / n;
	for (var i = 0; i < samples; i++) {
		data[i] = start + step * i;
	}
	return array;
};

module.exports = JSContext;

},{"./../DataType":1,"./../NDArray":2,"./../util":12,"./jsmath":9}],8:[function(require,module,exports){
"use strict";

var PBContext = require("./../PBContext.js");

function WebWorkerContext(options, callback) {
	var self = this;
	this._worker = new Worker(WebWorkerContext.getWorkerURL(options.baseUrl));
	this._worker.addEventListener("message", function(e) {
		self._messagingContext._onMessage(e);
	}, true);
	this._messagingContext = new PBContext(options, function(message) {
		self._worker.postMessage(message, [message]);
	}, callback);
}

WebWorkerContext.isSupported = function() {
	return typeof Worker !== "undefined";
};

WebWorkerContext.getWorkerURL = function(baseUrl) {
	if (baseUrl) {
		return baseUrl + "furious-worker.min.js";
	} else {
		return "furious-worker.min.js";
	}
};

WebWorkerContext.prototype.empty = function(shape, dataType) {
	return this._messagingContext.empty(shape, dataType);
};

WebWorkerContext.prototype.zeros = function(shape, dataType) {
	return this._messagingContext.zeros(shape, dataType);
};

WebWorkerContext.prototype.ones = function(shape, dataType) {
	return this._messagingContext.ones(shape, dataType);
};

WebWorkerContext.prototype.array = function(data, dataType) {
	return this._messagingContext.array(data, dataType);
};

WebWorkerContext.prototype.linspace = function(start, stop, samples, closed) {
	return this._messagingContext.linspace(start, stop, samples, closed);
};

WebWorkerContext.prototype.reshape = function(a, shape) {
	return this._messagingContext.reshape(a, shape);
};

WebWorkerContext.prototype.repeat = function(a, repeats, axis, out) {
	return this._messagingContext.repeat(a, repeats, axis, out);
};

WebWorkerContext.prototype._invalidate = function(array) {
	return this._messagingContext._invalidate(array);
};

WebWorkerContext.prototype.fetch = function() {
	this._messagingContext.fetch.apply(this._messagingContext, arguments);
};

WebWorkerContext.prototype.get = function() {
	this._messagingContext.get.apply(this._messagingContext, arguments);
};

WebWorkerContext.prototype.info = function(callback) {
	this._messagingContext.info(callback);
};

WebWorkerContext.prototype.barrier = function(callback) {
	this._messagingContext.barrier(callback);
};

WebWorkerContext.prototype.add = function(a, b, out) {
	return this._messagingContext.add(a, b, out);
};

WebWorkerContext.prototype.sub = function(a, b, out) {
	return this._messagingContext.sub(a, b, out);
};

WebWorkerContext.prototype.mul = function(a, b, out) {
	return this._messagingContext.mul(a, b, out);
};

WebWorkerContext.prototype.div = function(a, b, out) {
	return this._messagingContext.div(a, b, out);
};

WebWorkerContext.prototype.neg = function(a, out) {
	return this._messagingContext.neg(a, out);
};

WebWorkerContext.prototype.abs = function(a, out) {
	return this._messagingContext.abs(a, out);
};

WebWorkerContext.prototype.exp = function(a, out) {
	return this._messagingContext.exp(a, out);
};

WebWorkerContext.prototype.log = function(a, out) {
	return this._messagingContext.log(a, out);
};

WebWorkerContext.prototype.sqrt = function(a, out) {
	return this._messagingContext.sqrt(a, out);
};

WebWorkerContext.prototype.square = function(a, out) {
	return this._messagingContext.square(a, out);
};

WebWorkerContext.prototype.min = function(a, axis) {
	return this._messagingContext.min(a, axis);
};

WebWorkerContext.prototype.max = function(a, axis) {
	return this._messagingContext.max(a, axis);
};

WebWorkerContext.prototype.sum = function(a, axis) {
	return this._messagingContext.sum(a, axis);
};

WebWorkerContext.prototype.dot = function(a, b, out) {
	return this._messagingContext.dot(a, b, out);
};

module.exports = WebWorkerContext;

},{"./../PBContext.js":3}],9:[function(require,module,exports){
"use strict";

/**
 * JavaScript implementation of computational methods
 *
 * @private
 * @class JSMath
 */

/**
 * Sets all array elements to the specified value.
 *
 * @param {ArrayBufferView} data - the array data buffer.
 * @param {Number} value - the constant to fill the buffer with.
 *
 * @private
 * @static
 * @method fill
 */
exports.fill = function(data, value) {
	var n = data.length;
	for (var i = 0; i < n; ++i) {
		data[i] = value;
	}
};

/**
 * Adds two arrays.
 *
 * @param {ArrayBufferView} dataA - the input augend array.
 * @param {ArrayBufferView} dataB - the input addend array.
 * @param {ArrayBufferView} dataOut - the output sum array.
 *
 * @private
 * @static
 * @method add
 */
exports.add = function(dataA, dataB, dataOut) {
	var n = dataOut.length;
	for (var i = 0; i < n; ++i) {
		dataOut[i] = dataA[i] + dataB[i];
	}
};

/**
 * Adds a constant to an array.
 *
 * @param {ArrayBufferView} dataA - the input augend array.
 * @param {Number} valueB - the addend constant.
 * @param {ArrayBufferView} dataOut - the output sum array.
 *
 * @private
 * @static
 * @method addConst
 */
exports.addConst = function(dataA, valueB, dataOut) {
	var n = dataOut.length;
	for (var i = 0; i < n; ++i) {
		dataOut[i] = dataA[i] + valueB;
	}
};

/**
 * Subtracts two arrays.
 *
 * @param {ArrayBufferView} dataA - the input minuend array.
 * @param {ArrayBufferView} dataB - the input subtrahend array.
 * @param {ArrayBufferView} dataOut - the output difference array.
 *
 * @private
 * @static
 * @method sub
 */
exports.sub = function(dataA, dataB, dataOut) {
	var n = dataOut.length;
	for (var i = 0; i < n; ++i) {
		dataOut[i] = dataA[i] - dataB[i];
	}
};

/**
 * Subtracts a constant from an array.
 *
 * @param {ArrayBufferView} dataA - the input minuend array.
 * @param {Number} valueB - the subtrahend constant.
 * @param {ArrayBufferView} dataOut - the output difference array.
 *
 * @private
 * @static
 * @method subConst
 */
exports.subConst = function(dataA, valueB, dataOut) {
	var n = dataOut.length;
	for (var i = 0; i < n; ++i) {
		dataOut[i] = dataA[i] - valueB;
	}
};

/**
 * Subtracts an array from a constant.
 *
 * @param {ArrayBufferView} dataA - the input subtrahend array.
 * @param {Number} valueB - the minuend constant.
 * @param {ArrayBufferView} dataOut - the output difference array.
 *
 * @private
 * @static
 * @method subRevConst
 */
exports.subRevConst = function(dataA, valueB, dataOut) {
	var n = dataOut.length;
	for (var i = 0; i < n; ++i) {
		dataOut[i] = valueB - dataA[i];
	}
};

/**
 * Multiplies two arrays.
 *
 * @param {ArrayBufferView} dataA - the input multiplicand array.
 * @param {ArrayBufferView} dataB - the input multiplier array.
 * @param {ArrayBufferView} dataOut - the output product array.
 *
 * @private
 * @static
 * @method mul
 */
exports.mul = function(dataA, dataB, dataOut) {
	var n = dataOut.length;
	for (var i = 0; i < n; ++i) {
		dataOut[i] = dataA[i] * dataB[i];
	}
};

/**
 * Multiplies an array by a constant.
 *
 * @param {ArrayBufferView} dataA - the input multiplicand array.
 * @param {Number} valueB - the multiplier constant.
 * @param {ArrayBufferView} dataOut - the output product array.
 *
 * @private
 * @static
 * @method mulConst
 */
exports.mulConst = function(dataA, valueB, dataOut) {
	var n = dataOut.length;
	for (var i = 0; i < n; ++i) {
		dataOut[i] = dataA[i] * valueB;
	}
};

/**
 * Divides two arrays.
 *
 * @param {ArrayBufferView} dataA - the input dividend array.
 * @param {ArrayBufferView} dataB - the input divisor array.
 * @param {ArrayBufferView} dataOut - the output quotient array.
 *
 * @private
 * @static
 * @method div
 */
exports.div = function(dataA, dataB, dataOut) {
	var n = dataOut.length;
	for (var i = 0; i < n; ++i) {
		dataOut[i] = dataA[i] / dataB[i];
	}
};

/**
 * Divides an array by a constant.
 *
 * @param {ArrayBufferView} dataA - the input dividend array.
 * @param {Number} valueB - the divisor constant.
 * @param {ArrayBufferView} dataOut - the output quotient array.
 *
 * @private
 * @static
 * @method divConst
 */
exports.divConst = function(dataA, valueB, dataOut) {
	var n = dataOut.length;
	for (var i = 0; i < n; ++i) {
		dataOut[i] = dataA[i] / valueB;
	}
};

/**
 * Divides a constant by an array.
 *
 * @param {ArrayBufferView} dataA - the input divisor array.
 * @param {Number} valueB - the dividend constant.
 * @param {ArrayBufferView} dataOut - the output quotient array.
 *
 * @private
 * @static
 * @method divRevConst
 */
exports.divRevConst = function(dataA, valueB, dataOut) {
	var n = dataOut.length;
	for (var i = 0; i < n; ++i) {
		dataOut[i] = valueB / dataA[i];
	}
};

/**
 * Negates an array.
 *
 * @param {ArrayBufferView} dataA - the input array.
 * @param {ArrayBufferView} dataOut - the output array.
 *
 * @private
 * @static
 * @method neg
 */
exports.neg = function(dataA, dataOut) {
	var n = dataOut.length;
	for (var i = 0; i < n; ++i) {
		dataOut[i] = -dataA[i];
	}
};

/**
 * Computes absolute value of array elements.
 *
 * @param {ArrayBufferView} dataA - the input array.
 * @param {ArrayBufferView} dataOut - the output array.
 *
 * @private
 * @static
 * @method abs
 */
exports.abs = function(dataA, dataOut) {
	var n = dataOut.length;
	for (var i = 0; i < n; ++i) {
		dataOut[i] = Math.abs(dataA[i]);
	}
};

/**
 * Exponentiates array elements.
 *
 * @param {ArrayBufferView} dataA - the input array.
 * @param {ArrayBufferView} dataOut - the output array.
 *
 * @private
 * @static
 * @method exp
 */
exports.exp = function(dataA, dataOut) {
	var n = dataOut.length;
	for (var i = 0; i < n; ++i) {
		dataOut[i] = Math.exp(dataA[i]);
	}
};

/**
 * Computes logarithm of array elements.
 *
 * @param {ArrayBufferView} dataA - the input array.
 * @param {ArrayBufferView} dataOut - the output array.
 *
 * @private
 * @static
 * @method log
 */
exports.log = function(dataA, dataOut) {
	var n = dataOut.length;
	for (var i = 0; i < n; ++i) {
		dataOut[i] = Math.log(dataA[i]);
	}
};

/**
 * Computes square root of array elements.
 *
 * @param {ArrayBufferView} dataA - the input array.
 * @param {ArrayBufferView} dataOut - the output array.
 *
 * @private
 * @static
 * @method sqrt
 */
exports.sqrt = function(dataA, dataOut) {
	var n = dataOut.length;
	for (var i = 0; i < n; ++i) {
		dataOut[i] = Math.sqrt(dataA[i]);
	}
};

/**
 * Squares array elements.
 *
 * @param {ArrayBufferView} dataA - the input array.
 * @param {ArrayBufferView} dataOut - the output array.
 *
 * @private
 * @static
 * @method square
 */
exports.square = function(dataA, dataOut) {
	var n = dataOut.length;
	for (var i = 0; i < n; ++i) {
		var a = dataA[i];
		dataOut[i] = a * a;
	}
};

/**
 * Computes the minimum value of elements in an array.
 *
 * @param {ArrayBufferView} dataA - the input array to compute minimum on.
 * @param {ArrayBufferView} dataOut - the output array to store the minimum at.
 *
 * @private
 * @static
 * @method min
 */
exports.min = function(dataA, dataOut) {
	/* Computation of all-array min */
	var lengthA = dataA.length;
	var result = dataA[0];
	for (var i = 1; i < lengthA; ++i) {
		result = Math.min(result, dataA[i]);
	}
	dataOut[0] = result;
};

/**
 * Computes the maximum value of elements in an array.
 *
 * @param {ArrayBufferView} dataA - the input array to compute maximum on.
 * @param {ArrayBufferView} dataOut - the output array to store the maximum at.
 *
 * @private
 * @static
 * @method max
 */
exports.max = function(dataA, dataOut) {
	/* Computation of all-array min */
	var lengthA = dataA.length;
	var result = dataA[0];
	for (var i = 1; i < lengthA; ++i) {
		result = Math.max(result, dataA[i]);
	}
	dataOut[0] = result;
};

/**
 * Computes the sum of elements in an array.
 *
 * @param {ArrayBufferView} dataA - the input array with elements to sum up.
 * @param {ArrayBufferView} dataOut - the output array to store the sum at.
 *
 * @private
 * @static
 * @method min
 */
exports.sum = function(dataA, dataOut) {
	var lengthA = dataA.length;
	var result = 0.0;
	for (var i = 0; i < lengthA; ++i) {
		result += dataA[i];
	}
	dataOut[0] = result;
};

/**
 * Computes the minimum value of elements along an axis.
 *
 * @param {ArrayBufferView} dataA - the input array to compute minima on.
 * @param {ArrayBufferView} dataOut - the output array to store the minima at.
 * @param {Number} outerStride - the product of input array dimensions preceeding the reduction dimension.
 * @param {Number} innerStride - the product of input array dimensions following the reduction dimension.
 * @param {Number} reductionDim - the length of input array along the reduction dimension.
 *
 * @private
 * @static
 * @method axisMin
 */
exports.axisMin = function(dataA, dataOut, outerStride, innerStride, reductionDim) {
	for (var i = 0; i < outerStride; ++i) {
		for (var k = 0; k < innerStride; ++k) {
			var offset = i * reductionDim * innerStride + k;
			var currentMin = dataA[offset];
			for (var j = 1; j < reductionDim; ++j) {
				offset += innerStride;
				currentMin = Math.min(currentMin, dataA[offset]);
			}
			dataOut[i * innerStride + k] = currentMin;
		}
	}
};

/**
 * Computes the maximum value of elements along an axis.
 *
 * @param {ArrayBufferView} dataA - the input array to compute maxima on.
 * @param {ArrayBufferView} dataOut - the output array to store the maxima at.
 * @param {Number} outerStride - the product of input array dimensions preceeding the reduction dimension.
 * @param {Number} innerStride - the product of input array dimensions following the reduction dimension.
 * @param {Number} reductionDim - the length of input array along the reduction dimension.
 *
 * @private
 * @static
 * @method axisMax
 */
exports.axisMax = function(dataA, dataOut, outerStride, innerStride, reductionDim) {
	for (var i = 0; i < outerStride; ++i) {
		for (var k = 0; k < innerStride; ++k) {
			var offset = i * reductionDim * innerStride + k;
			var currentMax = dataA[offset];
			for (var j = 1; j < reductionDim; ++j) {
				offset += innerStride;
				currentMax = Math.max(currentMax, dataA[offset]);
			}
			dataOut[i * innerStride + k] = currentMax;
		}
	}
};

/**
 * Computes the sum of elements along an axis.
 *
 * @param {ArrayBufferView} dataA - the input array to sum up.
 * @param {ArrayBufferView} dataOut - the output array to store the sums at.
 * @param {Number} outerStride - the product of input array dimensions preceeding the reduction dimension.
 * @param {Number} innerStride - the product of input array dimensions following the reduction dimension.
 * @param {Number} reductionDim - the length of input array along the reduction dimension.
 *
 * @private
 * @static
 * @method axisSum
 */
exports.axisSum = function(dataA, dataOut, outerStride, innerStride, reductionDim) {
	for (var i = 0; i < outerStride; ++i) {
		for (var k = 0; k < innerStride; ++k) {
			var offset = i * reductionDim * innerStride + k;
			var currentSum = dataA[offset];
			for (var j = 1; j < reductionDim; ++j) {
				offset += innerStride;
				currentSum += dataA[offset];
			}
			dataOut[i * innerStride + k] = currentSum;
		}
	}
};

/**
 * Computes the dot product of two N-dimensional arrays.
 *
 * @param {ArrayBufferView} dataA - an input multiplicand array.
 * @param {ArrayBufferView} dataB - an input multiplier array.
 * @param {ArrayBufferView} dataOut - the output product array.
 * @param {Number} strideA - the product of the the multiplicand dimensions preceeding the reduction dimension.
 * @param {Number} outerStrideB - the product of the multiplier dimensions preceeding the reduction dimension.
 * @param {Number} innerStrideB - the product of the multiplier dimensions following the reduction dimension.
 * @param {Number} reductionDim - the length of inputs arrays along the reduction dimension.
 *
 * @private
 * @static
 * @method dot
 */
exports.dot = function(dataA, dataB, dataOut, strideA, outerStrideB, innerStrideB, reductionDim) {
	for (var i = 0; i < strideA; ++i) {
		for (var j = 0; j < reductionDim; ++j) {
			for (var k = 0; k < outerStrideB; ++k) {
				for (var l = 0; l < innerStrideB; ++l) {
					dataOut[(i*outerStrideB + k) * innerStrideB + l] += dataA[i*reductionDim+j] * dataB[(k*reductionDim+j)*innerStrideB+l];
				}
			}
		}
	}
};

/**
 * Replicates array elements along an axis.
 *
 * @param {ArrayBufferView} dataA - the input array.
 * @param {ArrayBufferView} dataOut - the output array for repeated elements.
 * @param {Number} outerStride - the product of input array dimensions preceeding the expansion dimension.
 * @param {Number} innerStride - the product of input array dimensions following the expansion dimension.
 * @param {Number} expansionDim - the length of input array along the expansion dimension.
 * @param {Number} repeats - the number of times each element will be replicated.
 *
 * @private
 * @static
 * @method repeat
 */
exports.repeat = function(dataA, dataOut, outerStride, innerStride, expansionDim, repeats) {
	if (innerStride < repeats) {
		for (var i = 0; i < outerStride; ++i) {
			for (var j = 0; j < expansionDim; ++j) {
				for (var k = 0; k < innerStride; ++k) {
					var valueA = dataA[(i * expansionDim + j) * innerStride + k];
					for (var c = 0; c < repeats; ++c) {
						dataOut[((i * expansionDim + j) * repeats + c) * innerStride + k] = valueA;
					}
				}
			}
		}
	} else {
		for (var i = 0; i < outerStride; ++i) {
			for (var j = 0; j < expansionDim; ++j) {
				var rowA = dataA.subarray((i * expansionDim + j) * innerStride, (i * expansionDim + j + 1) * innerStride);
				for (var c = 0; c < repeats; ++c) {
					dataOut.set(rowA, ((i * expansionDim + j) * repeats + c) * innerStride);
				}
			}
		}
	}
};

},{}],10:[function(require,module,exports){

var protobufjs = require("protobufjs");
protobufjs.convertFieldsToCamelCase = true;
var requestsProto = "package furious;\r\n\r\noption optimize_for = LITE_RUNTIME;\r\n\r\nenum DataType {\r\n\tFLOAT64 = 0;\r\n\tFLOAT32 = 1;\r\n}\r\n\r\nmessage Request {\r\n\tenum Type {\r\n\t\tEMPTY_ARRAY              =  0;\r\n\t\tDATA_ARRAY               =  1;\r\n\t\tCONST_ARRAY              =  2;\r\n\t\tLINSPACE                 =  3;\r\n\t\tRESHAPE                  =  4;\r\n\t\tREPEAT                   =  5;\r\n\t\tDEALLOCATE               =  6;\r\n\t\tFETCH                    =  7;\r\n\t\tBARRIER                  =  8;\r\n\t\tINFO                     =  9;\r\n\t\tBINARY_OPERATION         = 10;\r\n\t\tBINARY_CONST_OPERATION   = 11;\r\n\t\tUNARY_OPERATION          = 12;\r\n\t\tREDUCTION_OPERATION      = 13;\r\n\t\tAXIS_REDUCTION_OPERATION = 14;\r\n\t\tDOT_OPERATION            = 15;\r\n\t}\r\n\trequired fixed32                     id                             =  1;\r\n\trequired Type                        type                           =  2;\r\n\r\n\toptional EmptyArrayRequest           empty_array_request            =  3;\r\n\toptional DataArrayRequest            data_array_request             =  4;\r\n\toptional ConstArrayRequest           const_array_request            =  5;\r\n\toptional LinspaceRequest             linspace_request               =  6;\r\n\toptional ReshapeRequest              reshape_request                =  7;\r\n\toptional RepeatRequest               repeat_request                 =  8;\r\n\toptional DeallocateRequest           deallocate_request             =  9;\r\n\toptional FetchRequest                fetch_request                  = 10;\r\n\toptional BinaryOperationRequest      binary_operation_request       = 11;\r\n\toptional BinaryConstOperationRequest binary_const_operation_request = 12;\r\n\toptional UnaryOperationRequest       unary_operation_request        = 13;\r\n\toptional ReductionRequest            reduction_request              = 14;\r\n\toptional AxisReductionRequest        axis_reduction_request         = 15;\r\n\toptional DotOperationRequest         dot_operation_request          = 16;\r\n}\r\n\r\nmessage EmptyArrayRequest {\r\n\trequired fixed32  id_out      = 1;\r\n\trepeated uint32   shape       = 2 [packed=true];\r\n\trequired DataType data_type   = 3;\r\n}\r\n\r\nmessage DataArrayRequest {\r\n\trequired fixed32  id_out      = 1;\r\n\trepeated uint32   shape       = 2 [packed=true];\r\n\trequired DataType data_type   = 3;\r\n\trequired bytes    data_buffer = 4;\r\n}\r\n\r\nmessage ConstArrayRequest {\r\n\trequired fixed32  id_out      = 1;\r\n\trepeated uint32   shape       = 2 [packed=true];\r\n\trequired DataType data_type   = 3;\r\n\trequired double   fill_value  = 4;\r\n}\r\n\r\nmessage LinspaceRequest {\r\n\trequired sfixed32  id_out     = 1;\r\n\trequired double    start      = 2;\r\n\trequired double    stop       = 3;\r\n\trequired uint32    samples    = 4;\r\n\trequired bool      closed     = 5;\r\n\trequired DataType  data_type  = 6;\r\n}\r\n\r\nmessage ReshapeRequest {\r\n\trequired sfixed32  id_a      = 1;\r\n\trequired fixed32   id_out    = 2;\r\n\trepeated uint32    shape_out = 3 [packed=true];\r\n}\r\n\r\nmessage RepeatRequest {\r\n\trequired sfixed32 id_a    = 1;\r\n\trequired fixed32  id_out  = 2;\r\n\trequired uint32   axis    = 3;\r\n\trequired uint32   repeats = 4;\r\n}\r\n\r\nmessage DeallocateRequest {\r\n\trequired fixed32 id_a = 1;\r\n}\r\n\r\nmessage FetchRequest {\r\n\trequired sfixed32 id_a = 1;\r\n}\r\n\r\nmessage BinaryOperationRequest {\r\n\tenum Type {\r\n\t\tADD = 0;\r\n\t\tSUB = 1;\r\n\t\tMUL = 2;\r\n\t\tDIV = 3;\r\n\t}\r\n\trequired Type     type   = 1;\r\n\trequired sfixed32 id_a   = 2;\r\n\trequired sfixed32 id_b   = 3;\r\n\trequired fixed32  id_out = 4;\r\n}\r\n\r\nmessage BinaryConstOperationRequest {\r\n\tenum Type {\r\n\t\tADDC  = 0;\r\n\t\tSUBC  = 1;\r\n\t\tSUBRC = 2;\r\n\t\tMULC  = 3;\r\n\t\tDIVC  = 4;\r\n\t\tDIVRC = 5;\r\n\t}\r\n\trequired Type     type    = 1;\r\n\trequired sfixed32 id_a    = 2;\r\n\trequired double   value_b = 3;\r\n\trequired fixed32  id_out  = 4;\r\n}\r\n\r\nmessage UnaryOperationRequest {\r\n\tenum Type {\r\n\t\tNEG    = 0;\r\n\t\tABS    = 1;\r\n\t\tEXP    = 2;\r\n\t\tLOG    = 3;\r\n\t\tSQRT   = 4;\r\n\t\tSQUARE = 5;\r\n\t}\r\n\trequired Type     type   = 1;\r\n\trequired sfixed32 id_a   = 2;\r\n\trequired fixed32  id_out = 3;\r\n}\r\n\r\nmessage ReductionRequest {\r\n\tenum Type {\r\n\t\tSUM = 0;\r\n\t\tMIN = 1;\r\n\t\tMAX = 2;\r\n\t}\r\n\trequired Type     type   = 1;\r\n\trequired sfixed32 id_a   = 2;\r\n\trequired fixed32  id_out = 3;\r\n}\r\n\r\nmessage AxisReductionRequest {\r\n\tenum Type {\r\n\t\tSUM = 0;\r\n\t\tMIN = 1;\r\n\t\tMAX = 2;\r\n\t}\r\n\trequired Type     type   = 1;\r\n\trequired sfixed32 id_a   = 2;\r\n\trequired uint32   axis   = 3;\r\n\trequired fixed32  id_out = 4;\r\n}\r\n\r\nmessage DotOperationRequest {\r\n\trequired sfixed32 id_a   = 1;\r\n\trequired sfixed32 id_b   = 2;\r\n\trequired fixed32  id_out = 3;\r\n}\r\n";
module.exports = protobufjs.loadProto(requestsProto).build("furious");

},{"protobufjs":53}],11:[function(require,module,exports){

var protobufjs = require("protobufjs");
protobufjs.convertFieldsToCamelCase = true;
var responsesProto = "package furious;\r\n\r\noption optimize_for = LITE_RUNTIME;\r\n\r\nmessage Response {\r\n\tenum Type {\r\n\t\tFETCH   = 0;\r\n\t\tERROR   = 1;\r\n\t\tINIT    = 2;\r\n\t\tBARRIER = 3;\r\n\t\tINFO    = 4;\r\n\t}\r\n\trequired fixed32         id               = 1;\r\n\trequired Type            type             = 2;\r\n\r\n\toptional FetchResponse   fetch_response   = 3;\r\n\toptional ErrorResponse   error_response   = 4;\r\n\toptional InitResponse    init_response    = 5;\r\n\toptional InfoResponse    info_response    = 7;\r\n}\r\n\r\nmessage FetchResponse {\r\n\trequired bytes data_buffer = 1;\r\n}\r\n\r\nmessage ErrorResponse {\r\n\tenum Type {\r\n\t\tRUNTIME  = 0;\r\n\t\tARGUMENT = 1;\r\n\t\tPARSE    = 2;\r\n\t}\r\n\trequired Type   type        = 1;\r\n\toptional string description = 2;\r\n}\r\n\r\nmessage InitResponse {\r\n\toptional uint32 concurrency = 1;\r\n}\r\n\r\nmessage InfoResponse {\r\n}\r\n";
module.exports = protobufjs.loadProto(responsesProto).build("furious");

},{"protobufjs":53}],12:[function(require,module,exports){
"use strict";

/**
 * Provides helper functions
 *
 * @private
 * @class util
 */

var isNumber = function(n) {
	return n === +n;
};
exports.isNumber = isNumber;

var isReal = function(n) {
	return (n === +n) && (isFinite(n));
};
exports.isReal = isReal;

var isInt = function(n) {
	return n === (n|0);
};
exports.isInt = isInt;

exports.isPositiveInt = function(n) {
	return (n === +n) && (n === (n|0)) && (n > 0);
};

exports.isNonNegativeInt = function(n) {
	return (n === +n) && (n === (n|0)) && (n >= 0);
};

var isArray = function(list) {
	return list instanceof Array;
};
exports.isArray = isArray;

exports.isIntArray = function(list) {
	if (exports.isArray(list)) {
		for (var i = 0; i < list.length; i++) {
			if (!exports.isInt(list[i])) {
				return false;
			}
		}
		return true;
	} else {
		return false;
	}
};

exports.isPositiveIntArray = function(list) {
	if (exports.isArray(list)) {
		for (var i = 0; i < list.length; i++) {
			if (!exports.isPositiveInt(list[i])) {
				return false;
			}
		}
		return true;
	} else {
		return false;
	}
};

exports.asIntArray = function (list) {
	if (exports.isInt(list)) {
		return [list];
	} else if (exports.isIntArray(list)) {
		return list;
	} else {
		throw new TypeError(list + " can not be converted to integer array");
	}
};

/**
 * Compares for equality two arrays of primitive types.
 *
 * @param {Number[]} arrayA - the first array to compare.
 * @param {Number[]} arrayB - the second array to compare.
 *
 * @example
 *     if (!util.arrayEquals(a.shape, b.shape)) {
 *	       throw new Error("a and b have incompatible shapes");
 *     }
 *
 * @private
 * @static
 * @method arrayEquals
 */
exports.arrayEquals = function(arrayA, arrayB) {
	if (arrayA === arrayB) {
		return true;
	}
	if (arrayA.length !== arrayB.length) {
		return false;
	}
	var n = arrayA.length;
	for (var i = 0; i < n; ++i) {
		if (arrayA[i] !== arrayB[i]) {
			return false;
		}
	}
	return true;
};

exports.roundUp = function (number, multiple) {
	return Math.ceil(number / multiple) * multiple;
};

/**
 * Validate the shape argument.
 * Throws an error if the argument represents a valid shape.
 * Returns the shape as an integer array.
 *
 * @param {(Number|Number[])} shape - the shape argument to validate.
 *
 * @example
 *     shape = util.checkShape(shape);
 *
 * @private
 * @static
 * @method checkShape
 */
var checkShape = function(shape) {
	if (isNumber(shape)) {
		return checkShape([shape]);
	} else if (isArray(shape)) {
		var n = shape.length;
		var outShape = new Array(n);
		for (var i = 0; i < n; i++) {
			if (!isNumber(shape[i])) {
				throw new Error("Shape has non-numeric dimensions");
			}
			if (!isInt(shape[i])) {
				throw new Error("Shape must have integer dimensions");
			}
			if (shape[i] < 1) {
				throw new Error("Degenerate shape");
			}
			outShape[i] = shape[i]|0;
		}
		return outShape;
	} else {
		throw new Error("Shape must be an integer or integer array");
	}
};
exports.checkShape = checkShape;

/**
 * Checks that the two shapes are similar.
 * Throws an error if the two shapes are different.
 * If the data types are compatible, the function does nothing.
 *
 * @param {Number[]} shapeA - one valid shape to compare.
 * @param {Number[]} shapeB - another valid shape to compare.
 *
 * @example
 *     util.checkShapesCompatibility(a.shape, b.shape);
 *
 * @private
 * @static
 * @method checkShapesCompatibility
 */
exports.checkShapesCompatibility = function(shapeA, shapeB) {
	if (shapeA.length != shapeB.length) {
		throw new Error("The shapes have different dimensions");
	}
	var n = shapeA.length;
	for (var i = 0; i < n; i++) {
		if (shapeA[i] != shapeB[i]) {
			throw new Error("The shapes are different");
		}
	}
};

/**
 * Computes array length from its shape.
 *
 * @param {Number[]} shape - an array shape.  The shape must be valid w.r.t. **checkShape** function.
 *
 * @example
 *     var length = util.computeLength(shape);
 *
 * @private
 * @static
 * @method computeLength
 */
exports.computeLength = function(shape) {
	var length = 1;
	for (var i = 0; i < shape.length; ++i) {
		length *= shape[i];
	}
	return length;
};

/**
 * Checks the the argument represents a data type.
 * Throws an error if the argument is not of DataType type.
 * If the argument is a DataType object, the function does nothing.
 *
 * @param {DataType} dataType - the expectedly data type object to validate.
 * @return {DataType} - a data type object equivalent to the argument.
 *
 * @example
 *     dataType = util.checkDataType(dataType);
 *
 * @private
 * @static
 * @method checkDataType
 */
exports.checkDataType = function(dataType) {
	var DataType = require("./DataType");
	if (!(dataType instanceof DataType)) {
		throw new TypeError("dataType is not an instance of DataType");
	}
	return dataType;
};

/**
 * Checks that the two data types are compatible.
 * Throws an error if the data types do not match.
 * If the data types are compatible, the function does nothing.
 *
 * @param {DataType} dataTypeA - the first data type.
 * @param {DataType} dataTypeB - the second data type.
 *
 * @example
 *     util.checkDataTypesCompatibility(a.dataType, b.dataType);
 *
 * @private
 * @static
 * @method checkDataTypesCompatibility
 */
exports.checkDataTypesCompatibility = function(dataTypeA, dataTypeB) {
	if (!dataTypeA.equals(dataTypeB)) {
		throw new Error("The data types are not compatible");
	}
};

/**
 * Validates an NDArray parameter.
 * Throws an error if the expected NDArray argument has other type or if it has been invalidated.
 * If the argument is a valid NDArray, the function does nothing.
 *
 * @param {NDArray} array - the expectedly NDArray argument to be validated.
 * @param {String} vaname - the name of the NDArray argument to be used in error messages.
 *
 * @example
 *     util.checkNDArray(out, "out");
 *
 * @private
 * @static
 * @method checkNDArray
 */
exports.checkNDArray = function(array, varname) {
	var NDArray = require("./NDArray");
	if (!(array instanceof NDArray)) {
		throw new TypeError(varname + " is not an NDArray");
	}
	if (!array.isValid()) {
		throw new Error(varname + " is an invalidated array");
	}
};

/**
 * Checks that the two arrays are different.
 * Throws an error if they refer to the same object.
 * If the arrays are different, the function does nothing.
 *
 * @param {NDArray} a - the first array to check. Must be an NDArray object.
 * @param {NDArray} b - the second array to check. Must be an NDArray object.
 * @param {String} varnameA - name of the first array variable. This name may be used in an error message.
 * @param {String} varnameB - name of the second array variable. This name may be used in an error message.
 *
 * @example
 *     util.checkDifferentNDArrays(a, out, "a", "out");
 *
 * @private
 * @static
 * @method checkDifferentNDArrays
 */
exports.checkDifferentNDArrays = function(a, b, varnameA, varnameB) {
	if (a === b) {
		throw new Error("The arrays " + varnameA + " and " + varnameB + " must be different");
	}
};

/**
 * Validates **repeats** parameter for repeatition/tiling of array along an axis.
 * Throws an error if **repeats** is not an integer or if **repeats** is smaller than 2.
 * If **repeats** is valid, the function does nothing.
 *
 * @param {Number} repeats - the repeats argument to be verified.
 * @return {Number} - **repeats** casted to integer.
 *
 * @example
 *     repeats = util.checkRepeats(repeats);
 *
 * @private
 * @static
 * @method checkRepeats
 */
exports.checkRepeats = function(repeats) {
	if (!isInt(repeats)) {
		throw new TypeError("Repeats is not an integer");
	}
	if (repeats <= 1) {
		throw new RangeError("Repeats should be greater than 1");
	}
	return repeats|0;
};

/**
 * Validates axis parameter for reductions along an axis.
 * Throws an error if axis is not an integer, if axis is negative, or axis exceeds the number of dimensions.
 * If axis is valid, the function does nothing.
 *
 * @param {Number} axis - the axis argument to be verified.
 * @param {Number} numDimensions - the number of dimensions in the array being reduced.
 * @return {Number} - axis casted to integer.
 *
 * @example
 *     axis = util.checkAxis(axis, ndarray.shape.length);
 *
 * @private
 * @static
 * @method
 */
exports.checkAxis = function(axis, numDimensions) {
	if (!isInt(axis)) {
		throw new TypeError("Axis is not an integer");
	}
	if (axis < 0) {
		throw new RangeError("Axis is negative");
	}
	/* E.g. 3-dimensional array has axes 0, 1, 2 (but not 3!) */
	if (axis >= numDimensions) {
		throw new RangeError("Axis out of range");
	}
	return axis|0;
};

/**
 * Validates the shape of output array for reductions along an axis.
 * Throws an error if the shape of the output array does match the shape of input array after reduction along the axis.
 *
 * @param {Number[]} inShape - the shape of the input array.
 * @param {Number[]} outShape - the shape of the output array to be validated.
 * @param {Number} axis - the axis for reduction of input array. Must be valid w.r.t. inShape.
 *
 * @example
 *     util.checkAxisReductionOutShape(inArray.shape, outArray.shape, axis);
 *
 * @private
 * @static
 * @method
 */
exports.checkAxisReductionOutShape = function(inShape, outShape, axis) {
	if (inShape.length !== outShape.length + 1) {
		throw new Error("Output array has invalid number of dimensions for this operation");
	}
	for (var i = 0; i < axis; ++i) {
		if (inShape[i] !== outShape[i]) {
			throw new Error("Output array has invalid shape for this operation");
		}
	}
	for (var i = axis + 1; i < inShape.length; ++i) {
		if (inShape[i] !== outShape[i-1]) {
			throw new Error("Output array has invalid shape for this operation");
		}
	}
};

/**
 * Computes the shape of an array after reduction along an axis.
 *
 * @param {Number[]} inShape - the shape of the input array.
 * @param {Number} axis - the axis for reduction of input array. Must be valid w.r.t. inShape.
 * @return {Number[]} - the shape of the output array.
 *
 * @example
 *     var outShape = util.getAxisReductionOutShape(inArray.shape, axis);
 *     var outArray = new NDArray(outShape, inArray.dataType, context);
 *
 * @private
 * @static
 * @method
 */
exports.computeAxisReductionOutShape = function(inShape, axis) {
	var outShape = [];
	for (var i = 0; i < inShape.length; ++i) {
		if (i !== axis) {
			outShape.push(inShape[i]);
		}
	}
	return outShape;
};

/**
 * Computes the product of array dimensions before the axis.
 *
 * @param {Number[]} shape - the shape of the array.
 * @param {Number} axis - the axis used in an operation. Must be valid w.r.t. shape.
 * @return {Number} - the product of array dimensions before axis.
 *
 * @example
 *     // 5-dimensional array
 *     var ndarray = context.empty([2, 3, 4, 5, 6]);
 *     // Returns 6 = 2*3
 *     var outerStride = computeOuterStride(ndarray, 2);
 *
 * @private
 * @static
 * @method
 */
exports.computeOuterStride = function(shape, axis) {
	var outerStride = 1;
	for (var i = 0; i < axis; ++i) {
		outerStride *= shape[i];
	}
	return outerStride;
};

/**
 * Computes the product of array dimensions after the axis.
 *
 * @param {Number[]} shape - the shape of the array.
 * @param {Number} axis - the axis used in an operation. Must be valid w.r.t. shape.
 * @return {Number} - the product of array dimensions after axis.
 *
 * @example
 *     // 5-dimensional array
 *     var ndarray = context.empty([2, 3, 4, 5, 6]);
 *     // Returns 6 = 2*3
 *     var innerStride = computeInnerStride(ndarray, 2);
 *
 * @private
 * @static
 * @method
 */
exports.computeInnerStride = function(shape, axis) {
	var innerStride = 1;
	for (var i = axis + 1; i < shape.length; ++i) {
		innerStride *= shape[i];
	}
	return innerStride;
};

var discoverArrayShapeRecursive = function(data, shape, level) {
	if (isArray(data)) {
		if (shape.length <= level) {
			/* Discovered a new level of sub-arrays. Record its dimension. */
			shape.push(data.length);
		} else {
			/* Only check dimension */
			if (shape[level] != data.length) {
				throw new RangeError("Sub-array " + data + " does not match the expected dimension of " + shape[level]);
			}
		}
		for (var i = 0; i < data.length; i++) {
			discoverArrayShapeRecursive(data[i], shape, level + 1);
		}
	} else {
		if (level != shape.length) {
			throw new RangeError("Sub-array [" + data + "] does not match the expected dimension of " + shape[level]);
		}
		if (!isNumber(data)) {
			throw new TypeError("Non-numeric element: " + data);
		}
	}
};
exports.discoverArrayShapeRecursive = discoverArrayShapeRecursive;

var copyArrayDataRecursive = function(dataBuffer, dataArray, shape, level, offset) {
	var n = shape[level];
	if (level === shape.length - 1) {
		dataBuffer.set(dataArray, offset * n);
	} else {
		for (var i = 0; i < n; i++) {
			copyArrayDataRecursive(dataBuffer, dataArray[i], shape, level + 1, offset * n  + i);
		}
	}
};
exports.copyArrayDataRecursive = copyArrayDataRecursive;

var createArrayRecursive = function(dataBuffer, dataArray, shape, level, offset) {
	var n = shape[level];
	if (level === shape.length - 1) {
		for (var i = 0; i < n; i++) {
			dataArray[i] = dataBuffer[offset * n + i];
		}
	} else {
		for (var i = 0; i < n; i++) {
			dataArray[i] = new Array(shape[level + 1]);
			createArrayRecursive(dataBuffer, dataArray[i], shape, level + 1, offset * n  + i);
		}
	}
};
exports.createArrayRecursive = createArrayRecursive;

},{"./DataType":1,"./NDArray":2}],13:[function(require,module,exports){
"use strict";

var NDArray = require("../NDArray");
var DataType = require("../DataType");
var util = require("../util");


/* Buggy in Chromium-WebCL */
var useBufferCreationWithInit = false;

var isNodeWebCL = false;
var cl = void 0;
var availableDevices = null;
var availableDevicesDescriptions = null;
var defaultDeviceIndex = -1;

/**
 * If the global cl variable is undefined, this method would initialize it with a WebCL instance.
 * Works for both browser and Node.js
 *
 * @private
 * @static
 * @method initWebCL
 * @return {WebCL} - an instance of WebCL object from WebCL specification. If WebCL is not supported, return null.
 */
var initWebCL = function() {
	if (typeof cl === "undefined") {
		if (typeof window === "object") {
			cl = (typeof window.webcl !== "undefined") ? window.webcl : null;
		} else {
			try {
				cl = require("node-webcl");
				isNodeWebCL = true;
			} catch (e) {
				cl = null;
			}
		}
	}
	return cl;
};

/**
 * Creates an empty WebCLEvent.
 * Works for both browser and Node.js
 *
 * @private
 * @static
 * @method createEvent
 * @return {WebCLEvent} - an empty instance of WebCLEvent.
 */
var createEvent = function() {
	if (isNodeWebCL) {
		return new cl.WebCLEvent();
	} else {
		return new WebCLEvent();
	}
};

/**
 * Tries to release a WebCL resource and ignores any errors in the process.
 *
 * @private
 * @method tryRlease
 * @param {Object} webclObject - a WebCL object.
 * @return {Boolean} - true if the object was successfully released and false otherwise.
 */
var tryRelease = function(webclResource) {
	if (webclResource !== null) {
		try {
			webclResource.release();
			return true;
		} catch (e) {
			/* Silently ignore */
		}
	}
	return false;
};

/**
 * Checks if a WebCL device supports KHR_fp64 extension.
 *
 * @private
 * @method isFP64Capable
 * @param {WebCLDevice} device - the device to check for KHR_fp64 support.
 * @return {Boolean} - true if the device supports KHR_fp64 and false otherwise.
 */
var isFP64Capable = function(device) {
	var extensions = device.getSupportedExtensions();
	if (extensions.indexOf("KHR_fp64") === -1) {
		return false;
	}
	/*
	 * Due to a bug WebKit-WebCL may report KHR_fp64 even if it is not supported by the underlying OpenCL device.
	 * See bug https://github.com/SRA-SiliconValley/webkit-webcl/issues/536
	 */
	var testSource = "kernel void foo(global double* bar) { }";
	var context = null, program = null;
	try {
		context = cl.createContext(device);
		program = context.createProgram(testSource);
		program.build();
		return true;
	} catch (e) {
		return false;
	} finally {
		tryRelease(program);
		tryRelease(context);
	}
};

/**
 * Initialises and returns a list of WebCL devices suitable for computation.
 *
 * @private
 * @static
 * @method getAvailableDevices
 * @return {WebCLDevice[]} - a list of GPU and CPU WebCL devices that support KHR_FP64 (may be empty).
 */
var getAvailableDevices = function() {
	if (availableDevices === null) {
		availableDevices = [];
		var webcl = initWebCL();
		if (webcl !== null) {
			var platforms = cl.getPlatforms();
			for (var i = 0; i < platforms.length; ++i) {
				var platform = platforms[i];
				var devices = platform.getDevices(cl.DEVICE_TYPE_ALL);
				for (var j = 0; j < devices.length; ++j) {
					var device = devices[j];
					if (isFP64Capable(device)) {
						availableDevices.push(device);
					}
				}
			}
		}
		generateAvailableDevicesDescriptions();
	}
	return availableDevices;
};

var generateAvailableDevicesDescriptions = function() {
	availableDevicesDescriptions = [];
	/* If devices names are available, use them */
	var haveNames = true;
	for (var i = 0; i < availableDevices.length; ++i) {
		var device = availableDevices[i];
		var name = device.getInfo(cl.DEVICE_NAME);
		if ((name === null) || (name === "")) {
			haveNames = false;
			break;
		}
		availableDevicesDescriptions[i] = name;
	}
	if (!haveNames) {
		/* At least some names are not available: try to assign names based on classification (e.g. "CPU", "dGPU", "iGPU") */
		var cpuCount = 0, igpuCount = 0, dgpuCount = 0;
		for (var i = 0; i < availableDevices.length; ++i) {
			var device = availableDevices[i];
			var classification = classifyDevice(device);
			if (classification === "cpu") {
				++cpuCount;
				availableDevicesDescriptions[i] = "CPU";
			} else if (classification === "igpu") {
				++igpuCount;
				availableDevicesDescriptions[i] = "iGPU";
			} else if (classification === "dgpu") {
				++dgpuCount;
				availableDevicesDescriptions[i] = "dGPU";
			} else {
				throw new Error("Impossible device classification: " + classification);
			}
		}
		if ((cpuCount > 1) || (igpuCount > 1) || (dgpuCount > 1)) {
			/* We have multiple devices of the same type. Need to use more complicated naming scheme */
			var cpuIndex = 0, igpuIndex = 0, dgpuIndex = 0;
			for (var i = 0; i < availableDevices.length; ++i) {
				var device = availableDevices[i];
				var classification = classifyDevice(device);
				if (classification === "cpu") {
					if (cpuCount > 1) {
						++cpuIndex;
						availableDevicesDescriptions[i] = "CPU #" + cpuIndex;
					}
				} else if (classification === "igpu") {
					if (igpuCount > 1) {
						++igpuIndex;
						availableDevicesDescriptions[i] = "iGPU #" + igpuIndex;
					}
				} else if (classification === "dgpu") {
					if (dgpuCount > 1) {
						++dgpuCount;
						availableDevicesDescriptions[i] = "dGPU #" + dgpuIndex;
					}
				} else {
					throw new Error("Impossible device classification: " + classification);
				}
			}
		}
	}
};

/**
 * Classifies WebCL device to one of four categories:
 * - "cpu" for CPU devices.
 * - "igpu" for GPUs integrated with CPU package or chipset.
 * - "dgpu" for discrete GPUs.
 * - "unknown" for other types of devices (e.g. FPGAs)
 *
 * @private
 * @method classifyDevice
 * @param {WebCLDevice} device - the WebCL device to classify.
 * @return {String} - one of the strings described above.
 */
var classifyDevice = function(device) {
	try {
		var deviceType = device.getInfo(cl.DEVICE_TYPE);
		if (deviceType === cl.DEVICE_TYPE_CPU) {
			return "cpu";
		} else if (deviceType === cl.DEVICE_TYPE_GPU) {
			var isHostUnifiedMemory = device.getInfo(cl.DEVICE_HOST_UNIFIED_MEMORY);
			return (isHostUnifiedMemory ? "igpu" : "dgpu");
		}
	} catch (e) {
	}
	return "unknown";
};

/**
 * Selects the optimal WebCL device among the available devices.
 * The priority of devices: "dgpu" > "igpu" > "cpu"
 *
 * @private
 * @method getDefaultDeviceIndex
 * @return {WebCLDevice} - the selected device from the list.
 */
var getDefaultDeviceIndex = function() {
	if (defaultDeviceIndex === -1) {
		var availableDevices = getAvailableDevices();
		if (availableDevices.length === 0) {
			defaultDeviceIndex = -2;
			return defaultDeviceIndex;
		}
		var deviceClassifications = [];
		/* Search for "dgpu" */
		for (var i = 0; i < availableDevices.length; ++i) {
			var device = availableDevices[i];
			var deviceClass = classifyDevice(device);
			if (deviceClass === "dgpu") {
				defaultDeviceIndex = i;
				return i;
			}
			deviceClassifications.push(deviceClass);
		}
		/* Search for "igpu" */
		for (var i = 0; i < availableDevices.length; ++i) {
			if (deviceClassifications[i] === "igpu") {
				defaultDeviceIndex = i;
				return i;
			}
		}
		/* Search for "cpu" */
		for (var i = 0; i < availableDevices.length; ++i) {
			if (deviceClassifications[i] === "cpu") {
				defaultDeviceIndex = i;
				return i;
			}
		}
	}
	return defaultDeviceIndex;
};

var createKernels = function(program) {
	var kernels = {
		set: {
			f32: program.createKernel("set_f32"),
			f64: program.createKernel("set_f64")
		},
		linspace: {
			f32: program.createKernel("linspace_f32"),
			f64: program.createKernel("linspace_f64")
		},
		repeat: {
			f32: program.createKernel("repeat_f32"),
			f64: program.createKernel("repeat_f64")
		},
		add: {
			f32: program.createKernel("add_f32"),
			f64: program.createKernel("add_f64")
		},
		sub: {
			f32: program.createKernel("sub_f32"),
			f64: program.createKernel("sub_f64")
		},
		mul: {
			f32: program.createKernel("mul_f32"),
			f64: program.createKernel("mul_f64")
		},
		div: {
			f32: program.createKernel("div_f32"),
			f64: program.createKernel("div_f64")
		},
		addc: {
			f32: program.createKernel("addc_f32"),
			f64: program.createKernel("addc_f64")
		},
		subc: {
			f32: program.createKernel("subc_f32"),
			f64: program.createKernel("subc_f64")
		},
		subrc: {
			f32: program.createKernel("subrc_f32"),
			f64: program.createKernel("subrc_f64")
		},
		mulc: {
			f32: program.createKernel("mulc_f32"),
			f64: program.createKernel("mulc_f64")
		},
		divc: {
			f32: program.createKernel("divc_f32"),
			f64: program.createKernel("divc_f64")
		},
		divrc: {
			f32: program.createKernel("divrc_f32"),
			f64: program.createKernel("divrc_f64")
		},
		neg: {
			f32: program.createKernel("neg_f32"),
			f64: program.createKernel("neg_f64")
		},
		abs: {
			f32: program.createKernel("abs_f32"),
			f64: program.createKernel("abs_f64")
		},
		exp: {
			f32: program.createKernel("exp_f32"),
			f64: program.createKernel("exp_f64")
		},
		log: {
			f32: program.createKernel("log_f32"),
			f64: program.createKernel("log_f64")
		},
		sqrt: {
			f32: program.createKernel("sqrt_f32"),
			f64: program.createKernel("sqrt_f64")
		},
		square: {
			f32: program.createKernel("square_f32"),
			f64: program.createKernel("square_f64")
		},
		sum: {
			f32: program.createKernel("sum_f32_gpu"),
			f64: program.createKernel("sum_f64_gpu")
		},
		min: {
			f32: program.createKernel("min_f32_gpu"),
			f64: program.createKernel("min_f64_gpu")
		},
		max: {
			f32: program.createKernel("max_f32_gpu"),
			f64: program.createKernel("max_f64_gpu")
		},
		asum: {
			f32: program.createKernel("asum_f32"),
			f64: program.createKernel("asum_f64")
		},
		amin: {
			f32: program.createKernel("amin_f32"),
			f64: program.createKernel("amin_f64")
		},
		amax: {
			f32: program.createKernel("amax_f32"),
			f64: program.createKernel("amax_f64")
		},
		dot: {
			f32: program.createKernel("dot_f32"),
			f64: program.createKernel("dot_f64")
		}
	};
	return kernels;
};

function WebCLContext(options, callback) {
	initWebCL();
	var binaryKernelsSource = "kernel void add_f32(\r\n\tuint length,\r\n\tglobal float* a,\r\n\tglobal float* b,\r\n\tglobal float* out)\r\n{\r\n\tconst uint id = get_global_id(0);\r\n\tif (id < length) {\r\n\t\tout[id] = a[id] + b[id];\r\n\t}\r\n}\r\nkernel void add_f64(\r\n\tuint length,\r\n\tglobal double* a,\r\n\tglobal double* b,\r\n\tglobal double* out)\r\n{\r\n\tconst uint id = get_global_id(0);\r\n\tif (id < length) {\r\n\t\tout[id] = a[id] + b[id];\r\n\t}\r\n}\r\nkernel void sub_f32(\r\n\tuint length,\r\n\tglobal float* a,\r\n\tglobal float* b,\r\n\tglobal float* out)\r\n{\r\n\tconst uint id = get_global_id(0);\r\n\tif (id < length) {\r\n\t\tout[id] = a[id] - b[id];\r\n\t}\r\n}\r\nkernel void sub_f64(\r\n\tuint length,\r\n\tglobal double* a,\r\n\tglobal double* b,\r\n\tglobal double* out)\r\n{\r\n\tconst uint id = get_global_id(0);\r\n\tif (id < length) {\r\n\t\tout[id] = a[id] - b[id];\r\n\t}\r\n}\r\nkernel void mul_f32(\r\n\tuint length,\r\n\tglobal float* a,\r\n\tglobal float* b,\r\n\tglobal float* out)\r\n{\r\n\tconst uint id = get_global_id(0);\r\n\tif (id < length) {\r\n\t\tout[id] = a[id] * b[id];\r\n\t}\r\n}\r\nkernel void mul_f64(\r\n\tuint length,\r\n\tglobal double* a,\r\n\tglobal double* b,\r\n\tglobal double* out)\r\n{\r\n\tconst uint id = get_global_id(0);\r\n\tif (id < length) {\r\n\t\tout[id] = a[id] * b[id];\r\n\t}\r\n}\r\nkernel void div_f32(\r\n\tuint length,\r\n\tglobal float* a,\r\n\tglobal float* b,\r\n\tglobal float* out)\r\n{\r\n\tconst uint id = get_global_id(0);\r\n\tif (id < length) {\r\n\t\tout[id] = a[id] / b[id];\r\n\t}\r\n}\r\nkernel void div_f64(\r\n\tuint length,\r\n\tglobal double* a,\r\n\tglobal double* b,\r\n\tglobal double* out)\r\n{\r\n\tconst uint id = get_global_id(0);\r\n\tif (id < length) {\r\n\t\tout[id] = a[id] / b[id];\r\n\t}\r\n}\r\nkernel void addc_f32(\r\n\tuint length,\r\n\tglobal float* a,\r\n\tfloat b,\r\n\tglobal float* out)\r\n{\r\n\tconst uint id = get_global_id(0);\r\n\tif (id < length) {\r\n\t\tout[id] = a[id] + b;\r\n\t}\r\n}\r\nkernel void addc_f64(\r\n\tuint length,\r\n\tglobal double* a,\r\n\tdouble b,\r\n\tglobal double* out)\r\n{\r\n\tconst uint id = get_global_id(0);\r\n\tif (id < length) {\r\n\t\tout[id] = a[id] + b;\r\n\t}\r\n}\r\nkernel void subc_f32(\r\n\tuint length,\r\n\tglobal float* a,\r\n\tfloat b,\r\n\tglobal float* out)\r\n{\r\n\tconst uint id = get_global_id(0);\r\n\tif (id < length) {\r\n\t\tout[id] = a[id] - b;\r\n\t}\r\n}\r\nkernel void subc_f64(\r\n\tuint length,\r\n\tglobal double* a,\r\n\tdouble b,\r\n\tglobal double* out)\r\n{\r\n\tconst uint id = get_global_id(0);\r\n\tif (id < length) {\r\n\t\tout[id] = a[id] - b;\r\n\t}\r\n}\r\nkernel void subrc_f32(\r\n\tuint length,\r\n\tglobal float* a,\r\n\tfloat b,\r\n\tglobal float* out)\r\n{\r\n\tconst uint id = get_global_id(0);\r\n\tif (id < length) {\r\n\t\tout[id] = b / a[id];\r\n\t}\r\n}\r\nkernel void subrc_f64(\r\n\tuint length,\r\n\tglobal double* a,\r\n\tdouble b,\r\n\tglobal double* out)\r\n{\r\n\tconst uint id = get_global_id(0);\r\n\tif (id < length) {\r\n\t\tout[id] = b / a[id];\r\n\t}\r\n}\r\nkernel void mulc_f32(\r\n\tuint length,\r\n\tglobal float* a,\r\n\tfloat b,\r\n\tglobal float* out)\r\n{\r\n\tconst uint id = get_global_id(0);\r\n\tif (id < length) {\r\n\t\tout[id] = a[id] * b;\r\n\t}\r\n}\r\nkernel void mulc_f64(\r\n\tuint length,\r\n\tglobal double* a,\r\n\tdouble b,\r\n\tglobal double* out)\r\n{\r\n\tconst uint id = get_global_id(0);\r\n\tif (id < length) {\r\n\t\tout[id] = a[id] * b;\r\n\t}\r\n}\r\nkernel void divc_f32(\r\n\tuint length,\r\n\tglobal float* a,\r\n\tfloat b,\r\n\tglobal float* out)\r\n{\r\n\tconst uint id = get_global_id(0);\r\n\tif (id < length) {\r\n\t\tout[id] = a[id] / b;\r\n\t}\r\n}\r\nkernel void divc_f64(\r\n\tuint length,\r\n\tglobal double* a,\r\n\tdouble b,\r\n\tglobal double* out)\r\n{\r\n\tconst uint id = get_global_id(0);\r\n\tif (id < length) {\r\n\t\tout[id] = a[id] / b;\r\n\t}\r\n}\r\nkernel void divrc_f32(\r\n\tuint length,\r\n\tglobal float* a,\r\n\tfloat b,\r\n\tglobal float* out)\r\n{\r\n\tconst uint id = get_global_id(0);\r\n\tif (id < length) {\r\n\t\tout[id] = b / a[id];\r\n\t}\r\n}\r\nkernel void divrc_f64(\r\n\tuint length,\r\n\tglobal double* a,\r\n\tdouble b,\r\n\tglobal double* out)\r\n{\r\n\tconst uint id = get_global_id(0);\r\n\tif (id < length) {\r\n\t\tout[id] = b / a[id];\r\n\t}\r\n}\r\n";
	var unaryKernelsSource = "kernel void neg_f32(\r\n\tuint length,\r\n\tglobal float* a,\r\n\tglobal float* out)\r\n{\r\n\tconst uint id = get_global_id(0);\r\n\tif (id < length) {\r\n\t\tout[id] = -a[id];\r\n\t}\r\n}\r\nkernel void neg_f64(\r\n\tuint length,\r\n\tglobal double* a,\r\n\tglobal double* out)\r\n{\r\n\tconst uint id = get_global_id(0);\r\n\tif (id < length) {\r\n\t\tout[id] = -a[id];\r\n\t}\r\n}\r\nkernel void abs_f32(\r\n\tuint length,\r\n\tglobal float* a,\r\n\tglobal float* out)\r\n{\r\n\tconst uint id = get_global_id(0);\r\n\tif (id < length) {\r\n\t\tout[id] = fabs(a[id]);\r\n\t}\r\n}\r\nkernel void abs_f64(\r\n\tuint length,\r\n\tglobal double* a,\r\n\tglobal double* out)\r\n{\r\n\tconst uint id = get_global_id(0);\r\n\tif (id < length) {\r\n\t\tout[id] = fabs(a[id]);\r\n\t}\r\n}\r\nkernel void exp_f32(\r\n\tuint length,\r\n\tglobal float* a,\r\n\tglobal float* out)\r\n{\r\n\tconst uint id = get_global_id(0);\r\n\tif (id < length) {\r\n\t\tout[id] = exp(a[id]);\r\n\t}\r\n}\r\nkernel void exp_f64(\r\n\tuint length,\r\n\tglobal double* a,\r\n\tglobal double* out)\r\n{\r\n\tconst uint id = get_global_id(0);\r\n\tif (id < length) {\r\n\t\tout[id] = exp(a[id]);\r\n\t}\r\n}\r\nkernel void log_f32(\r\n\tuint length,\r\n\tglobal float* a,\r\n\tglobal float* out)\r\n{\r\n\tconst uint id = get_global_id(0);\r\n\tif (id < length) {\r\n\t\tout[id] = log(a[id]);\r\n\t}\r\n}\r\nkernel void log_f64(\r\n\tuint length,\r\n\tglobal double* a,\r\n\tglobal double* out)\r\n{\r\n\tconst uint id = get_global_id(0);\r\n\tif (id < length) {\r\n\t\tout[id] = log(a[id]);\r\n\t}\r\n}\r\nkernel void sqrt_f32(\r\n\tuint length,\r\n\tglobal float* a,\r\n\tglobal float* out)\r\n{\r\n\tconst uint id = get_global_id(0);\r\n\tif (id < length) {\r\n\t\tout[id] = sqrt(a[id]);\r\n\t}\r\n}\r\nkernel void sqrt_f64(\r\n\tuint length,\r\n\tglobal double* a,\r\n\tglobal double* out)\r\n{\r\n\tconst uint id = get_global_id(0);\r\n\tif (id < length) {\r\n\t\tout[id] = sqrt(a[id]);\r\n\t}\r\n}\r\nkernel void square_f32(\r\n\tuint length,\r\n\tglobal float* a,\r\n\tglobal float* out)\r\n{\r\n\tconst uint id = get_global_id(0);\r\n\tif (id < length) {\r\n\t\tconst float aVal = a[id]; \r\n\t\tout[id] = aVal * aVal;\r\n\t}\r\n}\r\nkernel void square_f64(\r\n\tuint length,\r\n\tglobal double* a,\r\n\tglobal double* out)\r\n{\r\n\tconst uint id = get_global_id(0);\r\n\tif (id < length) {\r\n\t\tconst double aVal = a[id];\r\n\t\tout[id] = aVal * aVal;\r\n\t}\r\n}\r\n";
	var reductionKernelsSource = "kernel void sum_f32_gpu(\r\n\tuint length,\r\n\tglobal float* a,\r\n\tlocal float* scratch,\r\n\tglobal float* out)\r\n{\r\n\tconst uint globalSize = get_global_size(0);\r\n\tuint globalIndex = get_global_id(0);\r\n\tfloat accumulator = 0.0f;\r\n\twhile (globalIndex < length) {\r\n\t\taccumulator += a[globalIndex];\r\n\t\tglobalIndex += globalSize;\r\n\t}\r\n\r\n\tuint localIndex = get_local_id(0);\r\n\tscratch[localIndex] = accumulator;\r\n\tbarrier(CLK_LOCAL_MEM_FENCE);\r\n\tfor (uint offset = get_local_size(0) / 2; offset != 0; offset >>= 1) {\r\n\t\tif (localIndex < offset) {\r\n\t\t\tscratch[localIndex] += scratch[localIndex + offset];\r\n\t\t}\r\n\t\tbarrier(CLK_LOCAL_MEM_FENCE);\r\n\t}\r\n\tif (localIndex == 0) {\r\n\t\tout[get_group_id(0)] = scratch[0];\r\n\t}\r\n}\r\n\r\nkernel void sum_f64_gpu(\r\n\tuint length,\r\n\tglobal double* a,\r\n\tlocal double* scratch,\r\n\tglobal double* out)\r\n{\r\n\tconst uint globalSize = get_global_size(0);\r\n\tuint globalIndex = get_global_id(0);\r\n\tdouble accumulator = 0.0;\r\n\twhile (globalIndex < length) {\r\n\t\taccumulator += a[globalIndex];\r\n\t\tglobalIndex += globalSize;\r\n\t}\r\n\r\n\tuint localIndex = get_local_id(0);\r\n\tscratch[localIndex] = accumulator;\r\n\tbarrier(CLK_LOCAL_MEM_FENCE);\r\n\tfor (uint offset = get_local_size(0) / 2; offset != 0; offset >>= 1) {\r\n\t\tif (localIndex < offset) {\r\n\t\t\tscratch[localIndex] += scratch[localIndex + offset];\r\n\t\t}\r\n\t\tbarrier(CLK_LOCAL_MEM_FENCE);\r\n\t}\r\n\tif (localIndex == 0) {\r\n\t\tout[get_group_id(0)] = scratch[0];\r\n\t}\r\n}\r\n\r\nkernel void min_f32_gpu(\r\n\tuint length,\r\n\tglobal float* a,\r\n\tlocal float* scratch,\r\n\tglobal float* out)\r\n{\r\n\tconst uint globalSize = get_global_size(0);\r\n\tuint globalIndex = get_global_id(0);\r\n\tfloat accumulator = INFINITY;\r\n\twhile (globalIndex < length) {\r\n\t\taccumulator = min(accumulator, a[globalIndex]);\r\n\t\tglobalIndex += globalSize;\r\n\t}\r\n\r\n\tuint localIndex = get_local_id(0);\r\n\tscratch[localIndex] = accumulator;\r\n\tbarrier(CLK_LOCAL_MEM_FENCE);\r\n\tfor (uint offset = get_local_size(0) / 2; offset != 0; offset >>= 1) {\r\n\t\tif (localIndex < offset) {\r\n\t\t\tscratch[localIndex] = min(scratch[localIndex], scratch[localIndex + offset]);\r\n\t\t}\r\n\t\tbarrier(CLK_LOCAL_MEM_FENCE);\r\n\t}\r\n\tif (localIndex == 0) {\r\n\t\tout[get_group_id(0)] = scratch[0];\r\n\t}\r\n}\r\n\r\nkernel void min_f64_gpu(\r\n\tuint length,\r\n\tglobal double* a,\r\n\tlocal double* scratch,\r\n\tglobal double* out)\r\n{\r\n\tconst uint globalSize = get_global_size(0);\r\n\tuint globalIndex = get_global_id(0);\r\n\tdouble accumulator = INFINITY;\r\n\twhile (globalIndex < length) {\r\n\t\taccumulator = min(accumulator, a[globalIndex]);\r\n\t\tglobalIndex += globalSize;\r\n\t}\r\n\r\n\tuint localIndex = get_local_id(0);\r\n\tscratch[localIndex] = accumulator;\r\n\tbarrier(CLK_LOCAL_MEM_FENCE);\r\n\tfor (uint offset = get_local_size(0) / 2; offset != 0; offset >>= 1) {\r\n\t\tif (localIndex < offset) {\r\n\t\t\tscratch[localIndex] = min(scratch[localIndex], scratch[localIndex + offset]);\r\n\t\t}\r\n\t\tbarrier(CLK_LOCAL_MEM_FENCE);\r\n\t}\r\n\tif (localIndex == 0) {\r\n\t\tout[get_group_id(0)] = scratch[0];\r\n\t}\r\n}\r\n\r\nkernel void max_f32_gpu(\r\n\tuint length,\r\n\tglobal float* a,\r\n\tlocal float* scratch,\r\n\tglobal float* out)\r\n{\r\n\tconst uint globalSize = get_global_size(0);\r\n\tuint globalIndex = get_global_id(0);\r\n\tfloat accumulator = -INFINITY;\r\n\twhile (globalIndex < length) {\r\n\t\taccumulator = max(accumulator, a[globalIndex]);\r\n\t\tglobalIndex += globalSize;\r\n\t}\r\n\r\n\tuint localIndex = get_local_id(0);\r\n\tscratch[localIndex] = accumulator;\r\n\tbarrier(CLK_LOCAL_MEM_FENCE);\r\n\tfor (uint offset = get_local_size(0) / 2; offset != 0; offset >>= 1) {\r\n\t\tif (localIndex < offset) {\r\n\t\t\tscratch[localIndex] = max(scratch[localIndex], scratch[localIndex + offset]);\r\n\t\t}\r\n\t\tbarrier(CLK_LOCAL_MEM_FENCE);\r\n\t}\r\n\tif (localIndex == 0) {\r\n\t\tout[get_group_id(0)] = scratch[0];\r\n\t}\r\n}\r\n\r\nkernel void max_f64_gpu(\r\n\tuint length,\r\n\tglobal double* a,\r\n\tlocal double* scratch,\r\n\tglobal double* out)\r\n{\r\n\tconst uint globalSize = get_global_size(0);\r\n\tuint globalIndex = get_global_id(0);\r\n\tdouble accumulator = -INFINITY;\r\n\twhile (globalIndex < length) {\r\n\t\taccumulator = max(accumulator, a[globalIndex]);\r\n\t\tglobalIndex += globalSize;\r\n\t}\r\n\r\n\tuint localIndex = get_local_id(0);\r\n\tscratch[localIndex] = accumulator;\r\n\tbarrier(CLK_LOCAL_MEM_FENCE);\r\n\tfor (uint offset = get_local_size(0) / 2; offset != 0; offset >>= 1) {\r\n\t\tif (localIndex < offset) {\r\n\t\t\tscratch[localIndex] = max(scratch[localIndex], scratch[localIndex + offset]);\r\n\t\t}\r\n\t\tbarrier(CLK_LOCAL_MEM_FENCE);\r\n\t}\r\n\tif (localIndex == 0) {\r\n\t\tout[get_group_id(0)] = scratch[0];\r\n\t}\r\n}\r\n";
	var axisReductionKernelsSource = "kernel void asum_f32(\r\n\tuint reductionDim,\r\n\tglobal float* a,\r\n\tglobal float* out)\r\n{\r\n\tconst uint innerStride = get_global_size(1);\r\n\tconst uint i = get_global_id(0);\r\n\tconst uint k = get_global_id(1);\r\n\ta += i * reductionDim * innerStride + k;\r\n\tfloat accumulator = *a;\r\n\twhile (--reductionDim) {\r\n\t\ta += innerStride;\r\n\t\taccumulator += *a;\r\n\t}\r\n\tout[i * innerStride + k] = accumulator;\r\n}\r\n\r\nkernel void asum_f64(\r\n\tuint reductionDim,\r\n\tglobal double* a,\r\n\tglobal double* out)\r\n{\r\n\tconst uint innerStride = get_global_size(1);\r\n\tconst uint i = get_global_id(0);\r\n\tconst uint k = get_global_id(1);\r\n\ta += i * reductionDim * innerStride + k;\r\n\tdouble accumulator = *a;\r\n\twhile (--reductionDim) {\r\n\t\ta += innerStride;\r\n\t\taccumulator += *a;\r\n\t}\r\n\tout[i * innerStride + k] = accumulator;\r\n}\r\n\r\nkernel void amin_f32(\r\n\tuint reductionDim,\r\n\tglobal float* a,\r\n\tglobal float* out)\r\n{\r\n\tconst uint innerStride = get_global_size(1);\r\n\tconst uint i = get_global_id(0);\r\n\tconst uint k = get_global_id(1);\r\n\ta += i * reductionDim * innerStride + k;\r\n\tfloat accumulator = *a;\r\n\twhile (--reductionDim) {\r\n\t\ta += innerStride;\r\n\t\taccumulator = min(accumulator, *a);\r\n\t}\r\n\tout[i * innerStride + k] = accumulator;\r\n}\r\n\r\nkernel void amin_f64(\r\n\tuint reductionDim,\r\n\tglobal double* a,\r\n\tglobal double* out)\r\n{\r\n\tconst uint innerStride = get_global_size(1);\r\n\tconst uint i = get_global_id(0);\r\n\tconst uint k = get_global_id(1);\r\n\ta += i * reductionDim * innerStride + k;\r\n\tdouble accumulator = *a;\r\n\twhile (--reductionDim) {\r\n\t\ta += innerStride;\r\n\t\taccumulator = min(accumulator, *a);\r\n\t}\r\n\tout[i * innerStride + k] = accumulator;\r\n}\r\n\r\nkernel void amax_f32(\r\n\tuint reductionDim,\r\n\tglobal float* a,\r\n\tglobal float* out)\r\n{\r\n\tconst uint innerStride = get_global_size(1);\r\n\tconst uint i = get_global_id(0);\r\n\tconst uint k = get_global_id(1);\r\n\ta += i * reductionDim * innerStride + k;\r\n\tfloat accumulator = *a;\r\n\twhile (--reductionDim) {\r\n\t\ta += innerStride;\r\n\t\taccumulator = max(accumulator, *a);\r\n\t}\r\n\tout[i * innerStride + k] = accumulator;\r\n}\r\n\r\nkernel void amax_f64(\r\n\tuint reductionDim,\r\n\tglobal double* a,\r\n\tglobal double* out)\r\n{\r\n\tconst uint innerStride = get_global_size(1);\r\n\tconst uint i = get_global_id(0);\r\n\tconst uint k = get_global_id(1);\r\n\ta += i * reductionDim * innerStride + k;\r\n\tdouble accumulator = *a;\r\n\twhile (--reductionDim) {\r\n\t\ta += innerStride;\r\n\t\taccumulator = max(accumulator, *a);\r\n\t}\r\n\tout[i * innerStride + k] = accumulator;\r\n}\r\n";
	var productKernelsSource = "kernel void dot_f32(\r\n\tuint reductionDim,\r\n\tglobal float* a,\r\n\tglobal float* b,\r\n\tglobal float* out)\r\n{\r\n\tconst uint i = get_global_id(0);\r\n\tconst uint k = get_global_id(1);\r\n\tconst uint l = get_global_id(2);\r\n\tconst uint outerStrideB = get_global_size(1);\r\n\tconst uint innerStrideB = get_global_size(2);\r\n\r\n\tfloat accumulator = 0.0f;\r\n\tfor (uint j = 0; j < reductionDim; ++j) {\r\n\t\taccumulator += a[i*reductionDim+j] * b[(k*reductionDim+j)*innerStrideB+l];\r\n\t}\r\n\tout[(i*outerStrideB + k) * innerStrideB + l] = accumulator;\r\n}\r\n\r\nkernel void dot_f64(\r\n\tuint reductionDim,\r\n\tglobal double* a,\r\n\tglobal double* b,\r\n\tglobal double* out)\r\n{\r\n\tconst uint i = get_global_id(0);\r\n\tconst uint k = get_global_id(1);\r\n\tconst uint l = get_global_id(2);\r\n\tconst uint outerStrideB = get_global_size(1);\r\n\tconst uint innerStrideB = get_global_size(2);\r\n\r\n\tdouble accumulator = 0.0;\r\n\tfor (uint j = 0; j < reductionDim; ++j) {\r\n\t\taccumulator += a[i*reductionDim+j] * b[(k*reductionDim+j)*innerStrideB+l];\r\n\t}\r\n\tout[(i*outerStrideB + k) * innerStrideB + l] = accumulator;\r\n}\r\n";
	var utilKernelsSource = "kernel void set_f32(\r\n\tuint length,\r\n\tglobal float* out,\r\n\tfloat value)\r\n{\r\n\tconst uint id = get_global_id(0);\r\n\tif (id < length) {\r\n\t\tout[id] = value;\r\n\t}\r\n}\r\nkernel void set_f64(\r\n\tuint length,\r\n\tglobal double* out,\r\n\tdouble value)\r\n{\r\n\tconst uint id = get_global_id(0);\r\n\tif (id < length) {\r\n\t\tout[id] = value;\r\n\t}\r\n}\r\n\r\nkernel void linspace_f32(\r\n\tuint length,\r\n\tglobal float* out,\r\n\tfloat start,\r\n\tfloat step)\r\n{\r\n\tconst uint id = get_global_id(0);\r\n\tif (id < length) {\r\n\t\tout[id] = start + step * ((float) id);\r\n\t}\r\n}\r\nkernel void linspace_f64(\r\n\tuint length,\r\n\tglobal double* out,\r\n\tdouble start,\r\n\tdouble step)\r\n{\r\n\tconst uint id = get_global_id(0);\r\n\tif (id < length) {\r\n\t\tout[id] = start + step * ((double) id);\r\n\t}\r\n}\r\n\r\nkernel void repeat_f32(\r\n\tuint expansionDim,\r\n\tuint innerStride,\r\n\tuint repeats,\r\n\tglobal float *restrict a,\r\n\tglobal float *restrict out)\r\n{\r\n\tconst uint i = get_global_id(0);\r\n\tconst uint j = get_global_id(1);\r\n\tconst uint k = get_global_id(2);\r\n\tconst float value = a[(i * expansionDim + j) * innerStride + k];\r\n\tuint offsetOut = (i * expansionDim + j) * repeats * innerStride + k;\r\n\tfor (uint c = 0; c < repeats; ++c) {\r\n\t\tout[offsetOut] = value;\r\n\t\toffsetOut += innerStride;\r\n\t}\r\n}\r\nkernel void repeat_f64(\r\n\tuint expansionDim,\r\n\tuint innerStride,\r\n\tuint repeats,\r\n\tglobal double *restrict a,\r\n\tglobal double *restrict out)\r\n{\r\n\tconst uint i = get_global_id(0);\r\n\tconst uint j = get_global_id(1);\r\n\tconst uint k = get_global_id(2);\r\n\tconst double value = a[(i * expansionDim + j) * innerStride + k];\r\n\tuint offsetOut = (i * expansionDim + j) * repeats * innerStride + k;\r\n\tfor (uint c = 0; c < repeats; ++c) {\r\n\t\tout[offsetOut] = value;\r\n\t\toffsetOut += innerStride;\r\n\t}\r\n}\r\n";
	var source = binaryKernelsSource + unaryKernelsSource + 
		reductionKernelsSource + axisReductionKernelsSource + 
		productKernelsSource + utilKernelsSource;

	var asyncCallbacks = options.asyncCallbacks;
	if (typeof asyncCallbacks === "undefined") {
		/* Currently only Node-WebCL supports asynchronous callbacks */
		this.asyncCallbacks = isNodeWebCL;
	} else {
		this.asyncCallbacks = !!asyncCallbacks;
	}
	var deviceName = options.device;
	if (deviceName) {
		var deviceIndex = availableDevicesDescriptions.indexOf(deviceName);
		if (deviceIndex === -1) {
			throw new Error("Invalid WebCL device name: " + deviceName);
		}
		this.device = availableDevices[deviceIndex];
	} else {
		var deviceIndex = getDefaultDeviceIndex();
		if (deviceIndex < 0) {
			throw new Error("No suitable WebCL device found");
		}
		this.device = availableDevices[deviceIndex];
	}
	this.device.enableExtension("KHR_fp64");
	this.deviceInfo = {
		deviceClass: classifyDevice(this.device),
		localMemorySize: this.device.getInfo(cl.DEVICE_LOCAL_MEM_SIZE),
		maxComputeUnits: this.device.getInfo(cl.DEVICE_MAX_COMPUTE_UNITS),
		maxWorkGroupSize: this.device.getInfo(cl.DEVICE_MAX_WORK_GROUP_SIZE),
		maxWorkItemSizes: this.device.getInfo(cl.DEVICE_MAX_WORK_ITEM_SIZES)
	};
	this.context = cl.createContext(this.device);
	this.queue = this.context.createCommandQueue(this.device);
	this.program = this.context.createProgram(source);
	try {
		/* Chromium-WebCL requires a list of devices */
		this.program.build([this.device]);
	} catch (e) {
		if (e.name === "INVALID_DEVICE") {
			/* Nokia-WebCL only works with no arguments to WebCLProgram.build */
			this.program.build();
		} else {
			throw e;
		}
	}
	this.kernels = createKernels(this.program);
	/* Context is ready for computations */
	callback(this);
}

/**
 * Returns the names of devices that can be used for computation.
 * Any of these names can be passed as a "device" option when creating a WebCL context.
 *
 * @static
 * @method getAvailableDevices
 * @return {String[]} - a possibly empty list of available device names.
 */
WebCLContext.getAvailableDevices = function() {
	if (WebCLContext.isUsable()) {
		return availableDevicesDescriptions;
	} else {
		return [];
	}
};

/**
 * Returns the name of the default device used for computation.
 *
 * @static
 * @method getDefaultDevice
 * @return {String} - the name of the default WebCL device or null if no suitable device available.
 */
WebCLContext.getDefaultDevice = function() {
	var deviceIndex = getDefaultDeviceIndex();
	if (deviceIndex < 0) {
		return null;
	} else {
		return availableDevicesDescriptions[deviceIndex];
	}
};

/**
 * Checks if WebCL is supported by the environment.
 *
 * @static
 * @method isSupported
 * @return {Boolean} - true if WebCL is supported on this system and false otherwise.
 */
WebCLContext.isSupported = function() {
	return initWebCL() !== null;
};

/**
 * Checks if WebCL can be used for computation.
 * WebCL is usable for computations if it is supported by JS engine (or Node.js) and there is at least one CPU or GPU device with KHR_fp64 extension.
 *
 * @static
 * @method isUsable
 * @return {Boolean} - true if WebCL is usable on this system and false otherwise.
 */
WebCLContext.isUsable = function() {
	var webcl = initWebCL();
	if (webcl === null) {
		return false;
	}
	var availableDevices = getAvailableDevices();
	return availableDevices.length !== 0;
};

WebCLContext.prototype.empty = function(shape, dataType) {
	shape = util.checkShape(shape);
	if (typeof dataType === "undefined") {
		dataType = new DataType("f64");
	} else if (!(dataType instanceof DataType)) {
		throw new TypeError(dataType + " is not an instance of DataType");
	}
	var array = new NDArray(shape, dataType, this);
	array._buffer = this.context.createBuffer(cl.MEM_READ_WRITE, array.length * dataType.size);
	return array;
};

WebCLContext.prototype.zeros = function(shape, dataType) {
	shape = util.checkShape(shape);
	if (typeof dataType === "undefined") {
		dataType = new DataType("f64");
	} else if (!(dataType instanceof DataType)) {
		throw new TypeError(dataType + " is not an instance of DataType");
	}
	var array = new NDArray(shape, dataType, this);
	array._buffer = this.context.createBuffer(cl.MEM_READ_WRITE, array.length * dataType.size);
	var kernel = this.kernels.set[dataType.type];
	kernel.setArg(0, new Uint32Array([array.length]));
	kernel.setArg(1, array._buffer);
	kernel.setArg(2, new dataType.arrayType([0.0]));
	this.queue.enqueueNDRangeKernel(kernel, 1, null, [array.length]);
	return array;
};

WebCLContext.prototype.ones = function(shape, dataType) {
	shape = util.checkShape(shape);
	if (typeof dataType === "undefined") {
		dataType = new DataType("f64");
	} else if (!(dataType instanceof DataType)) {
		throw new TypeError(dataType + " is not an instance of DataType");
	}
	var array = new NDArray(shape, dataType, this);
	array._buffer = this.context.createBuffer(cl.MEM_READ_WRITE, array.length * dataType.size);
	var kernel = this.kernels.set[dataType.type];
	kernel.setArg(0, new Uint32Array([array.length]));
	kernel.setArg(1, array._buffer);
	kernel.setArg(2, new dataType.arrayType([1.0]));
	this.queue.enqueueNDRangeKernel(kernel, 1, null, [array.length]);
	return array;
};

WebCLContext.prototype.array = function(data, dataType) {
	if (typeof dataType === "undefined") {
		dataType = new DataType("f64");
	} else {
		dataType = util.checkDataType(dataType);
	}
	var shape = [];
	util.discoverArrayShapeRecursive(data, shape, 0);
	var array = new NDArray(shape, dataType, this);
	var buffer = new dataType.arrayType(array.length);
	util.copyArrayDataRecursive(buffer, data, shape, 0, 0);
	if (useBufferCreationWithInit) {
		array._buffer = this.context.createBuffer(cl.MEM_READ_WRITE, buffer.byteLength, buffer);
	} else {
		array._buffer = this.context.createBuffer(cl.MEM_READ_WRITE, buffer.byteLength);
		this.queue.enqueueWriteBuffer(array._buffer, false, 0, buffer.byteLength, buffer);
	}
	return array;
};

WebCLContext.prototype.linspace = function(start, stop, samples, closed) {
	if (!util.isReal(start)) {
		throw new TypeError(start + " is not a real number");
	}
	if (!util.isReal(stop)) {
		throw new TypeError(stop + " is not a real number");
	}
	if (typeof samples === "undefined") {
		/* Default value in NumPy */
		samples = 50;
	} else if (!util.isInt(samples)) {
		throw new TypeError(samples + " is not an integer");
	} else if (samples <= 0) {
		throw new RangeError("The number of samples must be positive");
	}
	if (typeof closed === "undefined") {
		closed = true;
	}
	if (closed && (samples === 1)) {
		throw new RangeError("The number of samples must be a least 2 (for start and end points)");
	}

	var dataType = new DataType("f64");
	var array = new NDArray(samples, dataType, this);
	array._buffer = this.context.createBuffer(cl.MEM_READ_WRITE, samples * dataType.size);

	var range = stop - start;
	var n = (closed) ? samples - 1 : samples;
	var step = range / n;

	var kernel = this.kernels.linspace[dataType.type];
	kernel.setArg(0, new Uint32Array([array.length]));
	kernel.setArg(1, array._buffer);
	kernel.setArg(2, new dataType.arrayType([start]));
	kernel.setArg(3, new dataType.arrayType([step]));
	this.queue.enqueueNDRangeKernel(kernel, 1, null, [array.length]);

	return array;
};

WebCLContext.prototype._invalidate = function(array) {
	if (array._buffer !== null) {
		/* Work-around for Chromium-WebCL that currently lacks WebCLMemObject.release method */
		if (typeof array._buffer.release !== "undefined") {
			array._buffer.release();
		}
		array._buffer = null;
	}
};

WebCLContext.prototype.fetch = function() {
	if (arguments.length === 0) {
		throw new Error("Callback argument missing");
	}
	var callback = arguments[arguments.length - 1];
	/* Validate arguments */
	if (arguments.length === 1) {
		throw new Error("At least one NDArray argument expected");
	}
	for (var i = 0; i < arguments.length - 1; i++) {
		if (!(arguments[i] instanceof NDArray)) {
			throw new TypeError("Argument " + i + " is not an NDArray");
		}
	}
	var callbackWaitArguments = arguments.length - 1;
	var callbackArguments = new Array(callbackWaitArguments);
	if (this.asyncCallbacks) {
		var asyncEvents = [];
		for (var i = 0; i < callbackWaitArguments; i++) {
			var array = arguments[i];
			(function(queue, i, shape, ArrayType) {
				var buffer = new ArrayType(array.length);
				var readFinishEvent = createEvent();
				asyncEvents.push(readFinishEvent);
				queue.enqueueReadBuffer(array._buffer, false, 0, buffer.byteLength, buffer, null, readFinishEvent);
				readFinishEvent.setCallback(cl.COMPLETE, function() {
					readFinishEvent.release();
					callbackArguments[i] = buffer;
					if (--callbackWaitArguments === 0) {
						callback.apply(null, callbackArguments);
						/* OpenCL standard: commands enqueued in a callback won't start until clFlush */
						queue.flush();
					}
				});
			})(this.queue, i, array.shape, array.dataType.arrayType);
			/* This line mostly serializes execution. Unfortunately, without it nothing works */
			cl.waitForEvents(asyncEvents);
		}
	} else {
		for (var i = 0; i < callbackWaitArguments; i++) {
			var array = arguments[i];
			var buffer = new array.dataType.arrayType(array.length);
			this.queue.enqueueReadBuffer(array._buffer, true, 0, buffer.byteLength, buffer);
			callbackArguments[i] = buffer;
		}
		callback.apply(null, callbackArguments);
	}
};

WebCLContext.prototype.get = function() {
	if (arguments.length === 0) {
		throw new Error("Callback argument missing");
	}
	var callback = arguments[arguments.length - 1];
	/* Validate arguments */
	if (arguments.length === 1) {
		throw new Error("At least one NDArray argument expected");
	}
	for (var i = 0; i < arguments.length - 1; i++) {
		if (!(arguments[i] instanceof NDArray)) {
			throw new TypeError("Argument " + i + " is not an NDArray");
		}
	}
	var callbackWaitArguments = arguments.length - 1;
	var callbackArguments = new Array(callbackWaitArguments);
	if (this.asyncCallbacks) {
		var asyncEvents = [];
		for (var i = 0; i < callbackWaitArguments; i++) {
			var array = arguments[i];
			(function(queue, i, shape, ArrayType) {
				var buffer = new ArrayType(array.length);
				var readFinishEvent = createEvent();
				asyncEvents.push(readFinishEvent);
				queue.enqueueReadBuffer(array._buffer, false, 0, buffer.byteLength, buffer, null, readFinishEvent);
				if (shape.length === 0) {
					readFinishEvent.setCallback(cl.COMPLETE, function() {
						readFinishEvent.release();
						callbackArguments[i] = buffer[0];
						if (--callbackWaitArguments === 0) {
							callback.apply(null, callbackArguments);
							/* OpenCL standard: commands enqueued in a callback won't start until clFlush */
							queue.flush();
						}
					});
				} else {
					readFinishEvent.setCallback(cl.COMPLETE, function() {
						readFinishEvent.release();
						var jsarray = new Array(shape[0]);
						util.createArrayRecursive(new ArrayType(buffer), jsarray, shape, 0, 0);
						callbackArguments[i] = jsarray;
						if (--callbackWaitArguments === 0) {
							callback.apply(null, callbackArguments);
							/* OpenCL standard: commands enqueued in a callback won't start until clFlush */
							queue.flush();
						}
					});
				}
			})(this.queue, i, array.shape, array.dataType.arrayType);
			/* This line mostly serializes execution. Unfortunately, without it nothing works */
			cl.waitForEvents(asyncEvents);
		}
	} else {
		for (var i = 0; i < callbackWaitArguments; i++) {
			var array = arguments[i];
			var buffer = new array.dataType.arrayType(array.length);
			this.queue.enqueueReadBuffer(array._buffer, true, 0, buffer.byteLength, buffer);
			if (array.shape.length === 0) {
				callbackArguments[i] = buffer[0];
			} else {
				var jsarray = new Array(array.shape[0]);
				util.createArrayRecursive(new array.dataType.arrayType(buffer), jsarray, array.shape, 0, 0);
				callbackArguments[i] = jsarray;
			}
		}
		callback.apply(null, callbackArguments);
	}
};

WebCLContext.prototype.barrier = function(callback) {
	var barrierEvent = createEvent();
	this.queue.enqueueMarker(barrierEvent);
	if (this.asyncCallbacks) {
		var queue = this.queue;
		barrierEvent.setCallback(cl.COMPLETE, function() {
			barrierEvent.release();
			callback();
			/* OpenCL standard: commands enqueued in a callback won't start until clFlush */
			queue.flush();
		});
		cl.waitForEvents([barrierEvent]);
	} else {
		cl.waitForEvents([barrierEvent]);
		callback();
	}
};

WebCLContext.prototype.reshape = function(a, shape) {
	shape = util.checkShape(shape);
	if (util.computeLength(shape) !== a.length) {
		throw new RangeError("The shape is not compatible with the array");
	}
	var out = new NDArray(shape, a.dataType, this);
	if (a._decRef()) {
		out._buffer = this.context.createBuffer(webcl.MEM_READ_WRITE, out.length * out.dataType.size);
		this.queue.enqueueCopyBuffer(a._buffer, out._buffer, 0, 0, out.length * out.dataType.size);
	} else {
		out._buffer = a._buffer;
		a._buffer = null;
	}
	return out;
};

WebCLContext.prototype.repeat = function(a, repeats, axis, out) {
	util.checkNDArray(a, "a");
	repeats = util.checkRepeats(repeats);
	axis = util.checkAxis(axis, a.shape.length);
	var shapeA = a.shape;
	var shapeOut = shapeA.slice(0);
	shapeOut[axis] *= repeats;
	a._decRef();
	try {
		if (typeof out === "undefined") {
			out = new NDArray(shapeOut, a.dataType, this);
			out._buffer = this.context.createBuffer(cl.MEM_READ_WRITE, out.length * out.dataType.size);
		} else {
			util.checkNDArray(out, "out");
			util.checkShapesCompatibility(out.shape, shapeOut);
			util.checkDataTypesCompatibility(a.dataType, out.dataType);
			out._incRef();
		}
		var outerStride = util.computeOuterStride(shapeA, axis);
		var expansionDim = shapeA[axis];
		var innerStride = util.computeInnerStride(shapeA, axis);
		var kernel = this.kernels.repeat[a.dataType.type];
		kernel.setArg(0, new Uint32Array([expansionDim]));
		kernel.setArg(1, new Uint32Array([innerStride]));
		kernel.setArg(2, new Uint32Array([repeats]));
		kernel.setArg(3, a._buffer);
		kernel.setArg(4, out._buffer);
		this.queue.enqueueNDRangeKernel(kernel, 3, null, [outerStride, expansionDim, innerStride]);
	} catch (e) {
		a._incRef();
		throw e;
	}
	a._tryInvalidate();
	return out;
};

var binaryArithOp = function(a, b, out, furiousContext, binaryOpKernels, binaryConstOpKernels, binaryRevConstKernels) {
	var shapeOut = null, dataTypeOut = null;
	var bufferA = null, bufferB = null;
	if (a instanceof NDArray) {
		bufferA = a._buffer;
		shapeOut = a.shape;
		dataTypeOut = a.dataType;
		if (b instanceof NDArray) {
			bufferB = b._buffer;
			util.checkShapesCompatibility(a.shape, b.shape);
			util.checkDataTypesCompatibility(a.dataType, b.dataType);
		} else if (!util.isNumber(b)) {
			throw new TypeError("Unsupported type of b");
		}
	} else if (util.isNumber(a)) {
		util.checkNDArray(b, "b");
		bufferB = b._buffer;
		shapeOut = b.shape;
		dataTypeOut = b.dataType;
	} else {
		throw new TypeError("Unsupported type of a");
	}
	if (a instanceof NDArray) {
		a._decRef();
	}
	if (b instanceof NDArray) {
		b._decRef();
	}
	try {
		if (typeof out === "undefined") {
			out = new NDArray(shapeOut, dataTypeOut, furiousContext);
			if ((a instanceof NDArray) && !a._hasRefs()) {
				out._buffer = a._buffer;
				a._buffer = null;
			} else if ((b instanceof NDArray) && !b._hasRefs()) {
				out._buffer = b._buffer;
				b._buffer = null;
			} else {
				out._buffer = furiousContext.context.createBuffer(cl.MEM_READ_WRITE, out.length * out.dataType.size);
			}
		} else {
			util.checkNDArray(out, "out");
			util.checkShapesCompatibility(shapeOut, out.shape);
			util.checkDataTypesCompatibility(dataTypeOut, out.dataType);
			out._incRef();
		}
		if (a instanceof NDArray) {
			if (b instanceof NDArray) {
				var kernel = binaryOpKernels[dataTypeOut.type];
				kernel.setArg(0, new Uint32Array([out.length]));
				kernel.setArg(1, bufferA);
				kernel.setArg(2, bufferB);
				kernel.setArg(3, out._buffer);
				furiousContext.queue.enqueueNDRangeKernel(kernel, 1, null, [out.length]);
			} else {
				var kernel = binaryConstOpKernels[dataTypeOut.type];
				kernel.setArg(0, new Uint32Array([out.length]));
				kernel.setArg(1, bufferA);
				kernel.setArg(2, new dataTypeOut.arrayType([b]));
				kernel.setArg(3, out._buffer);
				furiousContext.queue.enqueueNDRangeKernel(kernel, 1, null, [out.length]);
			}
		} else {
			var kernel = binaryRevConstKernels[dataTypeOut.type];
			kernel.setArg(0, new Uint32Array([out.length]));
			kernel.setArg(1, bufferB);
			kernel.setArg(2, new dataTypeOut.arrayType([a]));
			kernel.setArg(3, out._buffer);
			furiousContext.queue.enqueueNDRangeKernel(kernel, 1, null, [out.length]);
		}
	} catch (e) {
		/* Restore the previous state */
		if (a instanceof NDArray) {
			a._incRef();
		}
		if (b instanceof NDArray) {
			b._incRef();
		}
		throw e;
	}
	if (a instanceof NDArray) {
		a._tryInvalidate();
	}
	if (b instanceof NDArray) {
		b._tryInvalidate();
	}
	return out;
};

var unaryArithOp = function(a, out, furiousContext, unaryOpKernels) {
	util.checkNDArray(a, "a");
	a._decRef();
	var bufferA = a._buffer;
	try {
		if (typeof out === "undefined") {
			out = new NDArray(a.shape, a.dataType, furiousContext);
			if ((a instanceof NDArray) && !a._hasRefs()) {
				out._buffer = a._buffer;
				a._buffer = null;
			} else {
				out._buffer = furiousContext.context.createBuffer(cl.MEM_READ_WRITE, out.length * out.dataType.size);
			}
		} else {
			util.checkNDArray(out, "out");
			util.checkShapesCompatibility(a.shape, out.shape);
			util.checkDataTypesCompatibility(a.dataType, out.dataType);
			out._incRef();
		}
		var kernel = unaryOpKernels[a.dataType.type];
		kernel.setArg(0, new Uint32Array([out.length]));
		kernel.setArg(1, bufferA);
		kernel.setArg(2, out._buffer);
		furiousContext.queue.enqueueNDRangeKernel(kernel, 1, null, [out.length]);
	} catch (e) {
		/* Restore the previous state */
		a._incRef();
		throw e;
	}
	a._tryInvalidate();
	return out;
};

var axisReduceOp = function(a, axis, out, furiousContext, reduceKernels, axisReduceKernels) {
	util.checkNDArray(a, "a");
	if (typeof axis === "undefined") {
		if (typeof out === "undefined") {
			out = new NDArray([], a.dataType, furiousContext);
			out._buffer = furiousContext.context.createBuffer(cl.MEM_READ_WRITE, a.dataType.size);
		} else {
			util.checkNDArray(out, "out");
			util.checkShapesCompatibility([], out.shape);
			util.checkDataTypesCompatibility(a.dataType, out.dataType);
			out._incRef();
		}
		var lengthA = a.length;
		var maxWorkItemsPerCU = Math.min(
			Math.min(furiousContext.deviceInfo.maxWorkGroupSize,
				furiousContext.deviceInfo.maxWorkItemSizes[0]), 
			furiousContext.deviceInfo.localMemorySize / a.dataType.size);
		/* The minimal ammount of parallelism that justifies switching to two-pass reduction */
		var parallelisationThreshold = 16;
		var kernel = reduceKernels[a.dataType.type];
		if (lengthA < maxWorkItemsPerCU * parallelisationThreshold) {
			/* One reduction is enough */
			kernel.setArg(0, new Uint32Array([lengthA]));
			kernel.setArg(1, a._buffer);
			kernel.setArg(2, new Uint32Array([maxWorkItemsPerCU * a.dataType.size]));
			kernel.setArg(3, out._buffer);
			/* Important: use only one work group */
			furiousContext.queue.enqueueNDRangeKernel(kernel, 1, null, [maxWorkItemsPerCU], [maxWorkItemsPerCU]);
		} else {
			/* Two-step reduction */
			var maxComputeUnits = furiousContext.deviceInfo.maxComputeUnits;
			var workGroupSizeMultiple = kernel.getWorkGroupInfo(furiousContext.device, cl.KERNEL_PREFERRED_WORK_GROUP_SIZE_MULTIPLE);
			var tempBuffer = furiousContext.context.createBuffer(cl.MEM_READ_WRITE, maxComputeUnits * a.dataType.size);

			kernel.setArg(0, new Uint32Array([lengthA]));
			kernel.setArg(1, a._buffer);
			kernel.setArg(2, new Uint32Array([maxWorkItemsPerCU * a.dataType.size]));
			kernel.setArg(3, tempBuffer);
			furiousContext.queue.enqueueNDRangeKernel(kernel, 1, null,
				[maxWorkItemsPerCU * maxComputeUnits],
				[maxWorkItemsPerCU]);

			var workGroupSize = Math.min(maxWorkItemsPerCU,
				util.roundUp(maxComputeUnits, workGroupSizeMultiple));
			kernel.setArg(0, new Uint32Array([maxComputeUnits]));
			kernel.setArg(1, tempBuffer);
			kernel.setArg(2, new Uint32Array([workGroupSize * a.dataType.size]));
			kernel.setArg(3, out._buffer);
			/* Important: use only one work group */
			furiousContext.queue.enqueueNDRangeKernel(kernel, 1, null,
				[workGroupSize],
				[workGroupSize]);

			tempBuffer.release();
		}
		a._tryRelease();
		return out;
	} else {
		axis = util.checkAxis(axis, a.shape.length);
		var shapeOut = util.computeAxisReductionOutShape(a.shape, axis);
		if (typeof out === "undefined") {
			out = new NDArray(shapeOut, a.dataType, furiousContext);
			out._buffer = furiousContext.context.createBuffer(cl.MEM_READ_WRITE, a.dataType.size * out.length);
		} else {
			util.checkNDArray(out, "out");
			util.checkShapesCompatibility([], out.shape);
			util.checkDataTypesCompatibility(a.dataType, out.dataType);
			out._incRef();
		}
		var outerStride = util.computeOuterStride(a.shape, axis);
		var reductionDim = a.shape[axis];
		var innerStride = util.computeInnerStride(a.shape, axis);
		var kernel = axisReduceKernels[a.dataType.type];
		kernel.setArg(0, new Uint32Array([reductionDim]));
		kernel.setArg(1, a._buffer);
		kernel.setArg(2, out._buffer);
		furiousContext.queue.enqueueNDRangeKernel(kernel, 2, null,
			[outerStride, innerStride]);
		a._tryRelease();
		return out;
	}
};


WebCLContext.prototype.add = function(a, b, out) {
	return binaryArithOp(a, b, out, this, this.kernels.add, this.kernels.addc, this.kernels.addc);
};

WebCLContext.prototype.sub = function(a, b, out) {
	return binaryArithOp(a, b, out, this, this.kernels.sub, this.kernels.subc, this.kernels.subrc);
};

WebCLContext.prototype.mul = function(a, b, out) {
	return binaryArithOp(a, b, out, this, this.kernels.mul, this.kernels.mulc, this.kernels.mulc);
};

WebCLContext.prototype.div = function(a, b, out) {
	return binaryArithOp(a, b, out, this, this.kernels.div, this.kernels.divc, this.kernels.divrc);
};

WebCLContext.prototype.neg = function(a, out) {
	return unaryArithOp(a, out, this, this.kernels.neg);
};

WebCLContext.prototype.abs = function(a, out) {
	return unaryArithOp(a, out, this, this.kernels.abs);
};

WebCLContext.prototype.exp = function(a, out) {
	return unaryArithOp(a, out, this, this.kernels.exp);
};

WebCLContext.prototype.log = function(a, out) {
	return unaryArithOp(a, out, this, this.kernels.log);
};

WebCLContext.prototype.sqrt = function(a, out) {
	return unaryArithOp(a, out, this, this.kernels.sqrt);
};

WebCLContext.prototype.square = function(a, out) {
	return unaryArithOp(a, out, this, this.kernels.square);
};

WebCLContext.prototype.min = function(a, axis, out) {
	return axisReduceOp(a, axis, out, this, this.kernels.min, this.kernels.amin);
};

WebCLContext.prototype.max = function(a, axis, out) {
	return axisReduceOp(a, axis, out, this, this.kernels.max, this.kernels.amax);
};

WebCLContext.prototype.sum = function(a, axis, out) {
	return axisReduceOp(a, axis, out, this, this.kernels.sum, this.kernels.asum);
};

WebCLContext.prototype.dot = function(a, b, out) {
	util.checkNDArray(a, "a");
	util.checkNDArray(b, "b");
	util.checkDataTypesCompatibility(a.dataType, b.dataType);

	/* The axis of b used in reduction: axis 0 for 1D array, second-to-last axis for ND array */
	var aAxis = Math.max(a.shape.length - 1, 0);
	var bAxis = Math.max(b.shape.length - 2, 0);
	var reductionDim = a.shape[aAxis];
	if (reductionDim !== b.shape[bAxis]) {
		throw new RangeError("Arrays have incompatible reduction dimensions");
	}
	var shapeOut = [], strideA = 1, outerStrideB = 1, innerStrideB = 1;
	for (var i = 0; i < aAxis; i++) {
		shapeOut.push(a.shape[i]);
		strideA *= a.shape[i];
	}
	for (var i = 0; i < b.shape.length; i++) {
		var dim = b.shape[i];
		if (i < bAxis) {
			outerStrideB *= dim;
			shapeOut.push(dim);
		} else if (i > bAxis) {
			innerStrideB *= dim;
			shapeOut.push(dim);
		}
	}
	if (typeof out === "undefined") {
		out = this.empty(shapeOut, a.dataType);
	} else if (out instanceof NDArray) {
		util.checkNDArray(out, "out");
		util.checkShapesCompatibility(out.shape, shapeOut);
		util.checkDataTypesCompatibility(out.dataType, a.dataType);
		util.checkDifferentNDArrays(a, out, "a", "out");
		util.checkDifferentNDArrays(b, out, "b", "out");
		out._incRef();
	}
	var kernel = this.kernels.dot[out.dataType.type];
	kernel.setArg(0, new Uint32Array([reductionDim]));
	kernel.setArg(1, a._buffer);
	kernel.setArg(2, b._buffer);
	kernel.setArg(3, out._buffer);
	this.queue.enqueueNDRangeKernel(kernel, 3, null,
		[strideA, outerStrideB, innerStrideB]);
	a._tryRelease();
	b._tryRelease();
	return out;
};

module.exports = WebCLContext;

},{"../DataType":1,"../NDArray":2,"../util":12}],14:[function(require,module,exports){
module.exports = require('./lib/chai');

},{"./lib/chai":15}],15:[function(require,module,exports){
/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

var used = []
  , exports = module.exports = {};

/*!
 * Chai version
 */

exports.version = '1.9.1';

/*!
 * Assertion Error
 */

exports.AssertionError = require('assertion-error');

/*!
 * Utils for plugins (not exported)
 */

var util = require('./chai/utils');

/**
 * # .use(function)
 *
 * Provides a way to extend the internals of Chai
 *
 * @param {Function}
 * @returns {this} for chaining
 * @api public
 */

exports.use = function (fn) {
  if (!~used.indexOf(fn)) {
    fn(this, util);
    used.push(fn);
  }

  return this;
};

/*!
 * Configuration
 */

var config = require('./chai/config');
exports.config = config;

/*!
 * Primary `Assertion` prototype
 */

var assertion = require('./chai/assertion');
exports.use(assertion);

/*!
 * Core Assertions
 */

var core = require('./chai/core/assertions');
exports.use(core);

/*!
 * Expect interface
 */

var expect = require('./chai/interface/expect');
exports.use(expect);

/*!
 * Should interface
 */

var should = require('./chai/interface/should');
exports.use(should);

/*!
 * Assert interface
 */

var assert = require('./chai/interface/assert');
exports.use(assert);

},{"./chai/assertion":16,"./chai/config":17,"./chai/core/assertions":18,"./chai/interface/assert":19,"./chai/interface/expect":20,"./chai/interface/should":21,"./chai/utils":32,"assertion-error":41}],16:[function(require,module,exports){
/*!
 * chai
 * http://chaijs.com
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

var config = require('./config');

module.exports = function (_chai, util) {
  /*!
   * Module dependencies.
   */

  var AssertionError = _chai.AssertionError
    , flag = util.flag;

  /*!
   * Module export.
   */

  _chai.Assertion = Assertion;

  /*!
   * Assertion Constructor
   *
   * Creates object for chaining.
   *
   * @api private
   */

  function Assertion (obj, msg, stack) {
    flag(this, 'ssfi', stack || arguments.callee);
    flag(this, 'object', obj);
    flag(this, 'message', msg);
  }

  Object.defineProperty(Assertion, 'includeStack', {
    get: function() {
      console.warn('Assertion.includeStack is deprecated, use chai.config.includeStack instead.');
      return config.includeStack;
    },
    set: function(value) {
      console.warn('Assertion.includeStack is deprecated, use chai.config.includeStack instead.');
      config.includeStack = value;
    }
  });

  Object.defineProperty(Assertion, 'showDiff', {
    get: function() {
      console.warn('Assertion.showDiff is deprecated, use chai.config.showDiff instead.');
      return config.showDiff;
    },
    set: function(value) {
      console.warn('Assertion.showDiff is deprecated, use chai.config.showDiff instead.');
      config.showDiff = value;
    }
  });

  Assertion.addProperty = function (name, fn) {
    util.addProperty(this.prototype, name, fn);
  };

  Assertion.addMethod = function (name, fn) {
    util.addMethod(this.prototype, name, fn);
  };

  Assertion.addChainableMethod = function (name, fn, chainingBehavior) {
    util.addChainableMethod(this.prototype, name, fn, chainingBehavior);
  };

  Assertion.overwriteProperty = function (name, fn) {
    util.overwriteProperty(this.prototype, name, fn);
  };

  Assertion.overwriteMethod = function (name, fn) {
    util.overwriteMethod(this.prototype, name, fn);
  };

  Assertion.overwriteChainableMethod = function (name, fn, chainingBehavior) {
    util.overwriteChainableMethod(this.prototype, name, fn, chainingBehavior);
  };

  /*!
   * ### .assert(expression, message, negateMessage, expected, actual)
   *
   * Executes an expression and check expectations. Throws AssertionError for reporting if test doesn't pass.
   *
   * @name assert
   * @param {Philosophical} expression to be tested
   * @param {String} message to display if fails
   * @param {String} negatedMessage to display if negated expression fails
   * @param {Mixed} expected value (remember to check for negation)
   * @param {Mixed} actual (optional) will default to `this.obj`
   * @api private
   */

  Assertion.prototype.assert = function (expr, msg, negateMsg, expected, _actual, showDiff) {
    var ok = util.test(this, arguments);
    if (true !== showDiff) showDiff = false;
    if (true !== config.showDiff) showDiff = false;

    if (!ok) {
      var msg = util.getMessage(this, arguments)
        , actual = util.getActual(this, arguments);
      throw new AssertionError(msg, {
          actual: actual
        , expected: expected
        , showDiff: showDiff
      }, (config.includeStack) ? this.assert : flag(this, 'ssfi'));
    }
  };

  /*!
   * ### ._obj
   *
   * Quick reference to stored `actual` value for plugin developers.
   *
   * @api private
   */

  Object.defineProperty(Assertion.prototype, '_obj',
    { get: function () {
        return flag(this, 'object');
      }
    , set: function (val) {
        flag(this, 'object', val);
      }
  });
};

},{"./config":17}],17:[function(require,module,exports){
module.exports = {

  /**
   * ### config.includeStack
   *
   * User configurable property, influences whether stack trace
   * is included in Assertion error message. Default of false
   * suppresses stack trace in the error message.
   *
   *     chai.config.includeStack = true;  // enable stack on error
   *
   * @param {Boolean}
   * @api public
   */

   includeStack: false,

  /**
   * ### config.showDiff
   *
   * User configurable property, influences whether or not
   * the `showDiff` flag should be included in the thrown
   * AssertionErrors. `false` will always be `false`; `true`
   * will be true when the assertion has requested a diff
   * be shown.
   *
   * @param {Boolean}
   * @api public
   */

  showDiff: true,

  /**
   * ### config.truncateThreshold
   *
   * User configurable property, sets length threshold for actual and
   * expected values in assertion errors. If this threshold is exceeded,
   * the value is truncated.
   *
   * Set it to zero if you want to disable truncating altogether.
   *
   *     chai.config.truncateThreshold = 0;  // disable truncating
   *
   * @param {Number}
   * @api public
   */

  truncateThreshold: 40

};

},{}],18:[function(require,module,exports){
/*!
 * chai
 * http://chaijs.com
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

module.exports = function (chai, _) {
  var Assertion = chai.Assertion
    , toString = Object.prototype.toString
    , flag = _.flag;

  /**
   * ### Language Chains
   *
   * The following are provided as chainable getters to
   * improve the readability of your assertions. They
   * do not provide testing capabilities unless they
   * have been overwritten by a plugin.
   *
   * **Chains**
   *
   * - to
   * - be
   * - been
   * - is
   * - that
   * - and
   * - has
   * - have
   * - with
   * - at
   * - of
   * - same
   *
   * @name language chains
   * @api public
   */

  [ 'to', 'be', 'been'
  , 'is', 'and', 'has', 'have'
  , 'with', 'that', 'at'
  , 'of', 'same' ].forEach(function (chain) {
    Assertion.addProperty(chain, function () {
      return this;
    });
  });

  /**
   * ### .not
   *
   * Negates any of assertions following in the chain.
   *
   *     expect(foo).to.not.equal('bar');
   *     expect(goodFn).to.not.throw(Error);
   *     expect({ foo: 'baz' }).to.have.property('foo')
   *       .and.not.equal('bar');
   *
   * @name not
   * @api public
   */

  Assertion.addProperty('not', function () {
    flag(this, 'negate', true);
  });

  /**
   * ### .deep
   *
   * Sets the `deep` flag, later used by the `equal` and
   * `property` assertions.
   *
   *     expect(foo).to.deep.equal({ bar: 'baz' });
   *     expect({ foo: { bar: { baz: 'quux' } } })
   *       .to.have.deep.property('foo.bar.baz', 'quux');
   *
   * @name deep
   * @api public
   */

  Assertion.addProperty('deep', function () {
    flag(this, 'deep', true);
  });

  /**
   * ### .a(type)
   *
   * The `a` and `an` assertions are aliases that can be
   * used either as language chains or to assert a value's
   * type.
   *
   *     // typeof
   *     expect('test').to.be.a('string');
   *     expect({ foo: 'bar' }).to.be.an('object');
   *     expect(null).to.be.a('null');
   *     expect(undefined).to.be.an('undefined');
   *
   *     // language chain
   *     expect(foo).to.be.an.instanceof(Foo);
   *
   * @name a
   * @alias an
   * @param {String} type
   * @param {String} message _optional_
   * @api public
   */

  function an (type, msg) {
    if (msg) flag(this, 'message', msg);
    type = type.toLowerCase();
    var obj = flag(this, 'object')
      , article = ~[ 'a', 'e', 'i', 'o', 'u' ].indexOf(type.charAt(0)) ? 'an ' : 'a ';

    this.assert(
        type === _.type(obj)
      , 'expected #{this} to be ' + article + type
      , 'expected #{this} not to be ' + article + type
    );
  }

  Assertion.addChainableMethod('an', an);
  Assertion.addChainableMethod('a', an);

  /**
   * ### .include(value)
   *
   * The `include` and `contain` assertions can be used as either property
   * based language chains or as methods to assert the inclusion of an object
   * in an array or a substring in a string. When used as language chains,
   * they toggle the `contain` flag for the `keys` assertion.
   *
   *     expect([1,2,3]).to.include(2);
   *     expect('foobar').to.contain('foo');
   *     expect({ foo: 'bar', hello: 'universe' }).to.include.keys('foo');
   *
   * @name include
   * @alias contain
   * @param {Object|String|Number} obj
   * @param {String} message _optional_
   * @api public
   */

  function includeChainingBehavior () {
    flag(this, 'contains', true);
  }

  function include (val, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    var expected = false;
    if (_.type(obj) === 'array' && _.type(val) === 'object') {
      for (var i in obj) {
        if (_.eql(obj[i], val)) {
          expected = true;
          break;
        }
      }
    } else if (_.type(val) === 'object') {
      if (!flag(this, 'negate')) {
        for (var k in val) new Assertion(obj).property(k, val[k]);
        return;
      }
      var subset = {}
      for (var k in val) subset[k] = obj[k]
      expected = _.eql(subset, val);
    } else {
      expected = obj && ~obj.indexOf(val)
    }
    this.assert(
        expected
      , 'expected #{this} to include ' + _.inspect(val)
      , 'expected #{this} to not include ' + _.inspect(val));
  }

  Assertion.addChainableMethod('include', include, includeChainingBehavior);
  Assertion.addChainableMethod('contain', include, includeChainingBehavior);

  /**
   * ### .ok
   *
   * Asserts that the target is truthy.
   *
   *     expect('everthing').to.be.ok;
   *     expect(1).to.be.ok;
   *     expect(false).to.not.be.ok;
   *     expect(undefined).to.not.be.ok;
   *     expect(null).to.not.be.ok;
   *
   * @name ok
   * @api public
   */

  Assertion.addProperty('ok', function () {
    this.assert(
        flag(this, 'object')
      , 'expected #{this} to be truthy'
      , 'expected #{this} to be falsy');
  });

  /**
   * ### .true
   *
   * Asserts that the target is `true`.
   *
   *     expect(true).to.be.true;
   *     expect(1).to.not.be.true;
   *
   * @name true
   * @api public
   */

  Assertion.addProperty('true', function () {
    this.assert(
        true === flag(this, 'object')
      , 'expected #{this} to be true'
      , 'expected #{this} to be false'
      , this.negate ? false : true
    );
  });

  /**
   * ### .false
   *
   * Asserts that the target is `false`.
   *
   *     expect(false).to.be.false;
   *     expect(0).to.not.be.false;
   *
   * @name false
   * @api public
   */

  Assertion.addProperty('false', function () {
    this.assert(
        false === flag(this, 'object')
      , 'expected #{this} to be false'
      , 'expected #{this} to be true'
      , this.negate ? true : false
    );
  });

  /**
   * ### .null
   *
   * Asserts that the target is `null`.
   *
   *     expect(null).to.be.null;
   *     expect(undefined).not.to.be.null;
   *
   * @name null
   * @api public
   */

  Assertion.addProperty('null', function () {
    this.assert(
        null === flag(this, 'object')
      , 'expected #{this} to be null'
      , 'expected #{this} not to be null'
    );
  });

  /**
   * ### .undefined
   *
   * Asserts that the target is `undefined`.
   *
   *     expect(undefined).to.be.undefined;
   *     expect(null).to.not.be.undefined;
   *
   * @name undefined
   * @api public
   */

  Assertion.addProperty('undefined', function () {
    this.assert(
        undefined === flag(this, 'object')
      , 'expected #{this} to be undefined'
      , 'expected #{this} not to be undefined'
    );
  });

  /**
   * ### .exist
   *
   * Asserts that the target is neither `null` nor `undefined`.
   *
   *     var foo = 'hi'
   *       , bar = null
   *       , baz;
   *
   *     expect(foo).to.exist;
   *     expect(bar).to.not.exist;
   *     expect(baz).to.not.exist;
   *
   * @name exist
   * @api public
   */

  Assertion.addProperty('exist', function () {
    this.assert(
        null != flag(this, 'object')
      , 'expected #{this} to exist'
      , 'expected #{this} to not exist'
    );
  });


  /**
   * ### .empty
   *
   * Asserts that the target's length is `0`. For arrays, it checks
   * the `length` property. For objects, it gets the count of
   * enumerable keys.
   *
   *     expect([]).to.be.empty;
   *     expect('').to.be.empty;
   *     expect({}).to.be.empty;
   *
   * @name empty
   * @api public
   */

  Assertion.addProperty('empty', function () {
    var obj = flag(this, 'object')
      , expected = obj;

    if (Array.isArray(obj) || 'string' === typeof object) {
      expected = obj.length;
    } else if (typeof obj === 'object') {
      expected = Object.keys(obj).length;
    }

    this.assert(
        !expected
      , 'expected #{this} to be empty'
      , 'expected #{this} not to be empty'
    );
  });

  /**
   * ### .arguments
   *
   * Asserts that the target is an arguments object.
   *
   *     function test () {
   *       expect(arguments).to.be.arguments;
   *     }
   *
   * @name arguments
   * @alias Arguments
   * @api public
   */

  function checkArguments () {
    var obj = flag(this, 'object')
      , type = Object.prototype.toString.call(obj);
    this.assert(
        '[object Arguments]' === type
      , 'expected #{this} to be arguments but got ' + type
      , 'expected #{this} to not be arguments'
    );
  }

  Assertion.addProperty('arguments', checkArguments);
  Assertion.addProperty('Arguments', checkArguments);

  /**
   * ### .equal(value)
   *
   * Asserts that the target is strictly equal (`===`) to `value`.
   * Alternately, if the `deep` flag is set, asserts that
   * the target is deeply equal to `value`.
   *
   *     expect('hello').to.equal('hello');
   *     expect(42).to.equal(42);
   *     expect(1).to.not.equal(true);
   *     expect({ foo: 'bar' }).to.not.equal({ foo: 'bar' });
   *     expect({ foo: 'bar' }).to.deep.equal({ foo: 'bar' });
   *
   * @name equal
   * @alias equals
   * @alias eq
   * @alias deep.equal
   * @param {Mixed} value
   * @param {String} message _optional_
   * @api public
   */

  function assertEqual (val, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    if (flag(this, 'deep')) {
      return this.eql(val);
    } else {
      this.assert(
          val === obj
        , 'expected #{this} to equal #{exp}'
        , 'expected #{this} to not equal #{exp}'
        , val
        , this._obj
        , true
      );
    }
  }

  Assertion.addMethod('equal', assertEqual);
  Assertion.addMethod('equals', assertEqual);
  Assertion.addMethod('eq', assertEqual);

  /**
   * ### .eql(value)
   *
   * Asserts that the target is deeply equal to `value`.
   *
   *     expect({ foo: 'bar' }).to.eql({ foo: 'bar' });
   *     expect([ 1, 2, 3 ]).to.eql([ 1, 2, 3 ]);
   *
   * @name eql
   * @alias eqls
   * @param {Mixed} value
   * @param {String} message _optional_
   * @api public
   */

  function assertEql(obj, msg) {
    if (msg) flag(this, 'message', msg);
    this.assert(
        _.eql(obj, flag(this, 'object'))
      , 'expected #{this} to deeply equal #{exp}'
      , 'expected #{this} to not deeply equal #{exp}'
      , obj
      , this._obj
      , true
    );
  }

  Assertion.addMethod('eql', assertEql);
  Assertion.addMethod('eqls', assertEql);

  /**
   * ### .above(value)
   *
   * Asserts that the target is greater than `value`.
   *
   *     expect(10).to.be.above(5);
   *
   * Can also be used in conjunction with `length` to
   * assert a minimum length. The benefit being a
   * more informative error message than if the length
   * was supplied directly.
   *
   *     expect('foo').to.have.length.above(2);
   *     expect([ 1, 2, 3 ]).to.have.length.above(2);
   *
   * @name above
   * @alias gt
   * @alias greaterThan
   * @param {Number} value
   * @param {String} message _optional_
   * @api public
   */

  function assertAbove (n, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    if (flag(this, 'doLength')) {
      new Assertion(obj, msg).to.have.property('length');
      var len = obj.length;
      this.assert(
          len > n
        , 'expected #{this} to have a length above #{exp} but got #{act}'
        , 'expected #{this} to not have a length above #{exp}'
        , n
        , len
      );
    } else {
      this.assert(
          obj > n
        , 'expected #{this} to be above ' + n
        , 'expected #{this} to be at most ' + n
      );
    }
  }

  Assertion.addMethod('above', assertAbove);
  Assertion.addMethod('gt', assertAbove);
  Assertion.addMethod('greaterThan', assertAbove);

  /**
   * ### .least(value)
   *
   * Asserts that the target is greater than or equal to `value`.
   *
   *     expect(10).to.be.at.least(10);
   *
   * Can also be used in conjunction with `length` to
   * assert a minimum length. The benefit being a
   * more informative error message than if the length
   * was supplied directly.
   *
   *     expect('foo').to.have.length.of.at.least(2);
   *     expect([ 1, 2, 3 ]).to.have.length.of.at.least(3);
   *
   * @name least
   * @alias gte
   * @param {Number} value
   * @param {String} message _optional_
   * @api public
   */

  function assertLeast (n, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    if (flag(this, 'doLength')) {
      new Assertion(obj, msg).to.have.property('length');
      var len = obj.length;
      this.assert(
          len >= n
        , 'expected #{this} to have a length at least #{exp} but got #{act}'
        , 'expected #{this} to have a length below #{exp}'
        , n
        , len
      );
    } else {
      this.assert(
          obj >= n
        , 'expected #{this} to be at least ' + n
        , 'expected #{this} to be below ' + n
      );
    }
  }

  Assertion.addMethod('least', assertLeast);
  Assertion.addMethod('gte', assertLeast);

  /**
   * ### .below(value)
   *
   * Asserts that the target is less than `value`.
   *
   *     expect(5).to.be.below(10);
   *
   * Can also be used in conjunction with `length` to
   * assert a maximum length. The benefit being a
   * more informative error message than if the length
   * was supplied directly.
   *
   *     expect('foo').to.have.length.below(4);
   *     expect([ 1, 2, 3 ]).to.have.length.below(4);
   *
   * @name below
   * @alias lt
   * @alias lessThan
   * @param {Number} value
   * @param {String} message _optional_
   * @api public
   */

  function assertBelow (n, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    if (flag(this, 'doLength')) {
      new Assertion(obj, msg).to.have.property('length');
      var len = obj.length;
      this.assert(
          len < n
        , 'expected #{this} to have a length below #{exp} but got #{act}'
        , 'expected #{this} to not have a length below #{exp}'
        , n
        , len
      );
    } else {
      this.assert(
          obj < n
        , 'expected #{this} to be below ' + n
        , 'expected #{this} to be at least ' + n
      );
    }
  }

  Assertion.addMethod('below', assertBelow);
  Assertion.addMethod('lt', assertBelow);
  Assertion.addMethod('lessThan', assertBelow);

  /**
   * ### .most(value)
   *
   * Asserts that the target is less than or equal to `value`.
   *
   *     expect(5).to.be.at.most(5);
   *
   * Can also be used in conjunction with `length` to
   * assert a maximum length. The benefit being a
   * more informative error message than if the length
   * was supplied directly.
   *
   *     expect('foo').to.have.length.of.at.most(4);
   *     expect([ 1, 2, 3 ]).to.have.length.of.at.most(3);
   *
   * @name most
   * @alias lte
   * @param {Number} value
   * @param {String} message _optional_
   * @api public
   */

  function assertMost (n, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    if (flag(this, 'doLength')) {
      new Assertion(obj, msg).to.have.property('length');
      var len = obj.length;
      this.assert(
          len <= n
        , 'expected #{this} to have a length at most #{exp} but got #{act}'
        , 'expected #{this} to have a length above #{exp}'
        , n
        , len
      );
    } else {
      this.assert(
          obj <= n
        , 'expected #{this} to be at most ' + n
        , 'expected #{this} to be above ' + n
      );
    }
  }

  Assertion.addMethod('most', assertMost);
  Assertion.addMethod('lte', assertMost);

  /**
   * ### .within(start, finish)
   *
   * Asserts that the target is within a range.
   *
   *     expect(7).to.be.within(5,10);
   *
   * Can also be used in conjunction with `length` to
   * assert a length range. The benefit being a
   * more informative error message than if the length
   * was supplied directly.
   *
   *     expect('foo').to.have.length.within(2,4);
   *     expect([ 1, 2, 3 ]).to.have.length.within(2,4);
   *
   * @name within
   * @param {Number} start lowerbound inclusive
   * @param {Number} finish upperbound inclusive
   * @param {String} message _optional_
   * @api public
   */

  Assertion.addMethod('within', function (start, finish, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object')
      , range = start + '..' + finish;
    if (flag(this, 'doLength')) {
      new Assertion(obj, msg).to.have.property('length');
      var len = obj.length;
      this.assert(
          len >= start && len <= finish
        , 'expected #{this} to have a length within ' + range
        , 'expected #{this} to not have a length within ' + range
      );
    } else {
      this.assert(
          obj >= start && obj <= finish
        , 'expected #{this} to be within ' + range
        , 'expected #{this} to not be within ' + range
      );
    }
  });

  /**
   * ### .instanceof(constructor)
   *
   * Asserts that the target is an instance of `constructor`.
   *
   *     var Tea = function (name) { this.name = name; }
   *       , Chai = new Tea('chai');
   *
   *     expect(Chai).to.be.an.instanceof(Tea);
   *     expect([ 1, 2, 3 ]).to.be.instanceof(Array);
   *
   * @name instanceof
   * @param {Constructor} constructor
   * @param {String} message _optional_
   * @alias instanceOf
   * @api public
   */

  function assertInstanceOf (constructor, msg) {
    if (msg) flag(this, 'message', msg);
    var name = _.getName(constructor);
    this.assert(
        flag(this, 'object') instanceof constructor
      , 'expected #{this} to be an instance of ' + name
      , 'expected #{this} to not be an instance of ' + name
    );
  };

  Assertion.addMethod('instanceof', assertInstanceOf);
  Assertion.addMethod('instanceOf', assertInstanceOf);

  /**
   * ### .property(name, [value])
   *
   * Asserts that the target has a property `name`, optionally asserting that
   * the value of that property is strictly equal to  `value`.
   * If the `deep` flag is set, you can use dot- and bracket-notation for deep
   * references into objects and arrays.
   *
   *     // simple referencing
   *     var obj = { foo: 'bar' };
   *     expect(obj).to.have.property('foo');
   *     expect(obj).to.have.property('foo', 'bar');
   *
   *     // deep referencing
   *     var deepObj = {
   *         green: { tea: 'matcha' }
   *       , teas: [ 'chai', 'matcha', { tea: 'konacha' } ]
   *     };

   *     expect(deepObj).to.have.deep.property('green.tea', 'matcha');
   *     expect(deepObj).to.have.deep.property('teas[1]', 'matcha');
   *     expect(deepObj).to.have.deep.property('teas[2].tea', 'konacha');
   *
   * You can also use an array as the starting point of a `deep.property`
   * assertion, or traverse nested arrays.
   *
   *     var arr = [
   *         [ 'chai', 'matcha', 'konacha' ]
   *       , [ { tea: 'chai' }
   *         , { tea: 'matcha' }
   *         , { tea: 'konacha' } ]
   *     ];
   *
   *     expect(arr).to.have.deep.property('[0][1]', 'matcha');
   *     expect(arr).to.have.deep.property('[1][2].tea', 'konacha');
   *
   * Furthermore, `property` changes the subject of the assertion
   * to be the value of that property from the original object. This
   * permits for further chainable assertions on that property.
   *
   *     expect(obj).to.have.property('foo')
   *       .that.is.a('string');
   *     expect(deepObj).to.have.property('green')
   *       .that.is.an('object')
   *       .that.deep.equals({ tea: 'matcha' });
   *     expect(deepObj).to.have.property('teas')
   *       .that.is.an('array')
   *       .with.deep.property('[2]')
   *         .that.deep.equals({ tea: 'konacha' });
   *
   * @name property
   * @alias deep.property
   * @param {String} name
   * @param {Mixed} value (optional)
   * @param {String} message _optional_
   * @returns value of property for chaining
   * @api public
   */

  Assertion.addMethod('property', function (name, val, msg) {
    if (msg) flag(this, 'message', msg);

    var descriptor = flag(this, 'deep') ? 'deep property ' : 'property '
      , negate = flag(this, 'negate')
      , obj = flag(this, 'object')
      , value = flag(this, 'deep')
        ? _.getPathValue(name, obj)
        : obj[name];

    if (negate && undefined !== val) {
      if (undefined === value) {
        msg = (msg != null) ? msg + ': ' : '';
        throw new Error(msg + _.inspect(obj) + ' has no ' + descriptor + _.inspect(name));
      }
    } else {
      this.assert(
          undefined !== value
        , 'expected #{this} to have a ' + descriptor + _.inspect(name)
        , 'expected #{this} to not have ' + descriptor + _.inspect(name));
    }

    if (undefined !== val) {
      this.assert(
          val === value
        , 'expected #{this} to have a ' + descriptor + _.inspect(name) + ' of #{exp}, but got #{act}'
        , 'expected #{this} to not have a ' + descriptor + _.inspect(name) + ' of #{act}'
        , val
        , value
      );
    }

    flag(this, 'object', value);
  });


  /**
   * ### .ownProperty(name)
   *
   * Asserts that the target has an own property `name`.
   *
   *     expect('test').to.have.ownProperty('length');
   *
   * @name ownProperty
   * @alias haveOwnProperty
   * @param {String} name
   * @param {String} message _optional_
   * @api public
   */

  function assertOwnProperty (name, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    this.assert(
        obj.hasOwnProperty(name)
      , 'expected #{this} to have own property ' + _.inspect(name)
      , 'expected #{this} to not have own property ' + _.inspect(name)
    );
  }

  Assertion.addMethod('ownProperty', assertOwnProperty);
  Assertion.addMethod('haveOwnProperty', assertOwnProperty);

  /**
   * ### .length(value)
   *
   * Asserts that the target's `length` property has
   * the expected value.
   *
   *     expect([ 1, 2, 3]).to.have.length(3);
   *     expect('foobar').to.have.length(6);
   *
   * Can also be used as a chain precursor to a value
   * comparison for the length property.
   *
   *     expect('foo').to.have.length.above(2);
   *     expect([ 1, 2, 3 ]).to.have.length.above(2);
   *     expect('foo').to.have.length.below(4);
   *     expect([ 1, 2, 3 ]).to.have.length.below(4);
   *     expect('foo').to.have.length.within(2,4);
   *     expect([ 1, 2, 3 ]).to.have.length.within(2,4);
   *
   * @name length
   * @alias lengthOf
   * @param {Number} length
   * @param {String} message _optional_
   * @api public
   */

  function assertLengthChain () {
    flag(this, 'doLength', true);
  }

  function assertLength (n, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    new Assertion(obj, msg).to.have.property('length');
    var len = obj.length;

    this.assert(
        len == n
      , 'expected #{this} to have a length of #{exp} but got #{act}'
      , 'expected #{this} to not have a length of #{act}'
      , n
      , len
    );
  }

  Assertion.addChainableMethod('length', assertLength, assertLengthChain);
  Assertion.addMethod('lengthOf', assertLength, assertLengthChain);

  /**
   * ### .match(regexp)
   *
   * Asserts that the target matches a regular expression.
   *
   *     expect('foobar').to.match(/^foo/);
   *
   * @name match
   * @param {RegExp} RegularExpression
   * @param {String} message _optional_
   * @api public
   */

  Assertion.addMethod('match', function (re, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    this.assert(
        re.exec(obj)
      , 'expected #{this} to match ' + re
      , 'expected #{this} not to match ' + re
    );
  });

  /**
   * ### .string(string)
   *
   * Asserts that the string target contains another string.
   *
   *     expect('foobar').to.have.string('bar');
   *
   * @name string
   * @param {String} string
   * @param {String} message _optional_
   * @api public
   */

  Assertion.addMethod('string', function (str, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    new Assertion(obj, msg).is.a('string');

    this.assert(
        ~obj.indexOf(str)
      , 'expected #{this} to contain ' + _.inspect(str)
      , 'expected #{this} to not contain ' + _.inspect(str)
    );
  });


  /**
   * ### .keys(key1, [key2], [...])
   *
   * Asserts that the target has exactly the given keys, or
   * asserts the inclusion of some keys when using the
   * `include` or `contain` modifiers.
   *
   *     expect({ foo: 1, bar: 2 }).to.have.keys(['foo', 'bar']);
   *     expect({ foo: 1, bar: 2, baz: 3 }).to.contain.keys('foo', 'bar');
   *
   * @name keys
   * @alias key
   * @param {String...|Array} keys
   * @api public
   */

  function assertKeys (keys) {
    var obj = flag(this, 'object')
      , str
      , ok = true;

    keys = keys instanceof Array
      ? keys
      : Array.prototype.slice.call(arguments);

    if (!keys.length) throw new Error('keys required');

    var actual = Object.keys(obj)
      , len = keys.length;

    // Inclusion
    ok = keys.every(function(key){
      return ~actual.indexOf(key);
    });

    // Strict
    if (!flag(this, 'negate') && !flag(this, 'contains')) {
      ok = ok && keys.length == actual.length;
    }

    // Key string
    if (len > 1) {
      keys = keys.map(function(key){
        return _.inspect(key);
      });
      var last = keys.pop();
      str = keys.join(', ') + ', and ' + last;
    } else {
      str = _.inspect(keys[0]);
    }

    // Form
    str = (len > 1 ? 'keys ' : 'key ') + str;

    // Have / include
    str = (flag(this, 'contains') ? 'contain ' : 'have ') + str;

    // Assertion
    this.assert(
        ok
      , 'expected #{this} to ' + str
      , 'expected #{this} to not ' + str
    );
  }

  Assertion.addMethod('keys', assertKeys);
  Assertion.addMethod('key', assertKeys);

  /**
   * ### .throw(constructor)
   *
   * Asserts that the function target will throw a specific error, or specific type of error
   * (as determined using `instanceof`), optionally with a RegExp or string inclusion test
   * for the error's message.
   *
   *     var err = new ReferenceError('This is a bad function.');
   *     var fn = function () { throw err; }
   *     expect(fn).to.throw(ReferenceError);
   *     expect(fn).to.throw(Error);
   *     expect(fn).to.throw(/bad function/);
   *     expect(fn).to.not.throw('good function');
   *     expect(fn).to.throw(ReferenceError, /bad function/);
   *     expect(fn).to.throw(err);
   *     expect(fn).to.not.throw(new RangeError('Out of range.'));
   *
   * Please note that when a throw expectation is negated, it will check each
   * parameter independently, starting with error constructor type. The appropriate way
   * to check for the existence of a type of error but for a message that does not match
   * is to use `and`.
   *
   *     expect(fn).to.throw(ReferenceError)
   *        .and.not.throw(/good function/);
   *
   * @name throw
   * @alias throws
   * @alias Throw
   * @param {ErrorConstructor} constructor
   * @param {String|RegExp} expected error message
   * @param {String} message _optional_
   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
   * @returns error for chaining (null if no error)
   * @api public
   */

  function assertThrows (constructor, errMsg, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    new Assertion(obj, msg).is.a('function');

    var thrown = false
      , desiredError = null
      , name = null
      , thrownError = null;

    if (arguments.length === 0) {
      errMsg = null;
      constructor = null;
    } else if (constructor && (constructor instanceof RegExp || 'string' === typeof constructor)) {
      errMsg = constructor;
      constructor = null;
    } else if (constructor && constructor instanceof Error) {
      desiredError = constructor;
      constructor = null;
      errMsg = null;
    } else if (typeof constructor === 'function') {
      name = constructor.prototype.name || constructor.name;
      if (name === 'Error' && constructor !== Error) {
        name = (new constructor()).name;
      }
    } else {
      constructor = null;
    }

    try {
      obj();
    } catch (err) {
      // first, check desired error
      if (desiredError) {
        this.assert(
            err === desiredError
          , 'expected #{this} to throw #{exp} but #{act} was thrown'
          , 'expected #{this} to not throw #{exp}'
          , (desiredError instanceof Error ? desiredError.toString() : desiredError)
          , (err instanceof Error ? err.toString() : err)
        );

        flag(this, 'object', err);
        return this;
      }

      // next, check constructor
      if (constructor) {
        this.assert(
            err instanceof constructor
          , 'expected #{this} to throw #{exp} but #{act} was thrown'
          , 'expected #{this} to not throw #{exp} but #{act} was thrown'
          , name
          , (err instanceof Error ? err.toString() : err)
        );

        if (!errMsg) {
          flag(this, 'object', err);
          return this;
        }
      }

      // next, check message
      var message = 'object' === _.type(err) && "message" in err
        ? err.message
        : '' + err;

      if ((message != null) && errMsg && errMsg instanceof RegExp) {
        this.assert(
            errMsg.exec(message)
          , 'expected #{this} to throw error matching #{exp} but got #{act}'
          , 'expected #{this} to throw error not matching #{exp}'
          , errMsg
          , message
        );

        flag(this, 'object', err);
        return this;
      } else if ((message != null) && errMsg && 'string' === typeof errMsg) {
        this.assert(
            ~message.indexOf(errMsg)
          , 'expected #{this} to throw error including #{exp} but got #{act}'
          , 'expected #{this} to throw error not including #{act}'
          , errMsg
          , message
        );

        flag(this, 'object', err);
        return this;
      } else {
        thrown = true;
        thrownError = err;
      }
    }

    var actuallyGot = ''
      , expectedThrown = name !== null
        ? name
        : desiredError
          ? '#{exp}' //_.inspect(desiredError)
          : 'an error';

    if (thrown) {
      actuallyGot = ' but #{act} was thrown'
    }

    this.assert(
        thrown === true
      , 'expected #{this} to throw ' + expectedThrown + actuallyGot
      , 'expected #{this} to not throw ' + expectedThrown + actuallyGot
      , (desiredError instanceof Error ? desiredError.toString() : desiredError)
      , (thrownError instanceof Error ? thrownError.toString() : thrownError)
    );

    flag(this, 'object', thrownError);
  };

  Assertion.addMethod('throw', assertThrows);
  Assertion.addMethod('throws', assertThrows);
  Assertion.addMethod('Throw', assertThrows);

  /**
   * ### .respondTo(method)
   *
   * Asserts that the object or class target will respond to a method.
   *
   *     Klass.prototype.bar = function(){};
   *     expect(Klass).to.respondTo('bar');
   *     expect(obj).to.respondTo('bar');
   *
   * To check if a constructor will respond to a static function,
   * set the `itself` flag.
   *
   *     Klass.baz = function(){};
   *     expect(Klass).itself.to.respondTo('baz');
   *
   * @name respondTo
   * @param {String} method
   * @param {String} message _optional_
   * @api public
   */

  Assertion.addMethod('respondTo', function (method, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object')
      , itself = flag(this, 'itself')
      , context = ('function' === _.type(obj) && !itself)
        ? obj.prototype[method]
        : obj[method];

    this.assert(
        'function' === typeof context
      , 'expected #{this} to respond to ' + _.inspect(method)
      , 'expected #{this} to not respond to ' + _.inspect(method)
    );
  });

  /**
   * ### .itself
   *
   * Sets the `itself` flag, later used by the `respondTo` assertion.
   *
   *     function Foo() {}
   *     Foo.bar = function() {}
   *     Foo.prototype.baz = function() {}
   *
   *     expect(Foo).itself.to.respondTo('bar');
   *     expect(Foo).itself.not.to.respondTo('baz');
   *
   * @name itself
   * @api public
   */

  Assertion.addProperty('itself', function () {
    flag(this, 'itself', true);
  });

  /**
   * ### .satisfy(method)
   *
   * Asserts that the target passes a given truth test.
   *
   *     expect(1).to.satisfy(function(num) { return num > 0; });
   *
   * @name satisfy
   * @param {Function} matcher
   * @param {String} message _optional_
   * @api public
   */

  Assertion.addMethod('satisfy', function (matcher, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    this.assert(
        matcher(obj)
      , 'expected #{this} to satisfy ' + _.objDisplay(matcher)
      , 'expected #{this} to not satisfy' + _.objDisplay(matcher)
      , this.negate ? false : true
      , matcher(obj)
    );
  });

  /**
   * ### .closeTo(expected, delta)
   *
   * Asserts that the target is equal `expected`, to within a +/- `delta` range.
   *
   *     expect(1.5).to.be.closeTo(1, 0.5);
   *
   * @name closeTo
   * @param {Number} expected
   * @param {Number} delta
   * @param {String} message _optional_
   * @api public
   */

  Assertion.addMethod('closeTo', function (expected, delta, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    this.assert(
        Math.abs(obj - expected) <= delta
      , 'expected #{this} to be close to ' + expected + ' +/- ' + delta
      , 'expected #{this} not to be close to ' + expected + ' +/- ' + delta
    );
  });

  function isSubsetOf(subset, superset, cmp) {
    return subset.every(function(elem) {
      if (!cmp) return superset.indexOf(elem) !== -1;

      return superset.some(function(elem2) {
        return cmp(elem, elem2);
      });
    })
  }

  /**
   * ### .members(set)
   *
   * Asserts that the target is a superset of `set`,
   * or that the target and `set` have the same strictly-equal (===) members.
   * Alternately, if the `deep` flag is set, set members are compared for deep
   * equality.
   *
   *     expect([1, 2, 3]).to.include.members([3, 2]);
   *     expect([1, 2, 3]).to.not.include.members([3, 2, 8]);
   *
   *     expect([4, 2]).to.have.members([2, 4]);
   *     expect([5, 2]).to.not.have.members([5, 2, 1]);
   *
   *     expect([{ id: 1 }]).to.deep.include.members([{ id: 1 }]);
   *
   * @name members
   * @param {Array} set
   * @param {String} message _optional_
   * @api public
   */

  Assertion.addMethod('members', function (subset, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');

    new Assertion(obj).to.be.an('array');
    new Assertion(subset).to.be.an('array');

    var cmp = flag(this, 'deep') ? _.eql : undefined;

    if (flag(this, 'contains')) {
      return this.assert(
          isSubsetOf(subset, obj, cmp)
        , 'expected #{this} to be a superset of #{act}'
        , 'expected #{this} to not be a superset of #{act}'
        , obj
        , subset
      );
    }

    this.assert(
        isSubsetOf(obj, subset, cmp) && isSubsetOf(subset, obj, cmp)
        , 'expected #{this} to have the same members as #{act}'
        , 'expected #{this} to not have the same members as #{act}'
        , obj
        , subset
    );
  });
};

},{}],19:[function(require,module,exports){
/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */


module.exports = function (chai, util) {

  /*!
   * Chai dependencies.
   */

  var Assertion = chai.Assertion
    , flag = util.flag;

  /*!
   * Module export.
   */

  /**
   * ### assert(expression, message)
   *
   * Write your own test expressions.
   *
   *     assert('foo' !== 'bar', 'foo is not bar');
   *     assert(Array.isArray([]), 'empty arrays are arrays');
   *
   * @param {Mixed} expression to test for truthiness
   * @param {String} message to display on error
   * @name assert
   * @api public
   */

  var assert = chai.assert = function (express, errmsg) {
    var test = new Assertion(null, null, chai.assert);
    test.assert(
        express
      , errmsg
      , '[ negation message unavailable ]'
    );
  };

  /**
   * ### .fail(actual, expected, [message], [operator])
   *
   * Throw a failure. Node.js `assert` module-compatible.
   *
   * @name fail
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @param {String} operator
   * @api public
   */

  assert.fail = function (actual, expected, message, operator) {
    message = message || 'assert.fail()';
    throw new chai.AssertionError(message, {
        actual: actual
      , expected: expected
      , operator: operator
    }, assert.fail);
  };

  /**
   * ### .ok(object, [message])
   *
   * Asserts that `object` is truthy.
   *
   *     assert.ok('everything', 'everything is ok');
   *     assert.ok(false, 'this will fail');
   *
   * @name ok
   * @param {Mixed} object to test
   * @param {String} message
   * @api public
   */

  assert.ok = function (val, msg) {
    new Assertion(val, msg).is.ok;
  };

  /**
   * ### .notOk(object, [message])
   *
   * Asserts that `object` is falsy.
   *
   *     assert.notOk('everything', 'this will fail');
   *     assert.notOk(false, 'this will pass');
   *
   * @name notOk
   * @param {Mixed} object to test
   * @param {String} message
   * @api public
   */

  assert.notOk = function (val, msg) {
    new Assertion(val, msg).is.not.ok;
  };

  /**
   * ### .equal(actual, expected, [message])
   *
   * Asserts non-strict equality (`==`) of `actual` and `expected`.
   *
   *     assert.equal(3, '3', '== coerces values to strings');
   *
   * @name equal
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @api public
   */

  assert.equal = function (act, exp, msg) {
    var test = new Assertion(act, msg, assert.equal);

    test.assert(
        exp == flag(test, 'object')
      , 'expected #{this} to equal #{exp}'
      , 'expected #{this} to not equal #{act}'
      , exp
      , act
    );
  };

  /**
   * ### .notEqual(actual, expected, [message])
   *
   * Asserts non-strict inequality (`!=`) of `actual` and `expected`.
   *
   *     assert.notEqual(3, 4, 'these numbers are not equal');
   *
   * @name notEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @api public
   */

  assert.notEqual = function (act, exp, msg) {
    var test = new Assertion(act, msg, assert.notEqual);

    test.assert(
        exp != flag(test, 'object')
      , 'expected #{this} to not equal #{exp}'
      , 'expected #{this} to equal #{act}'
      , exp
      , act
    );
  };

  /**
   * ### .strictEqual(actual, expected, [message])
   *
   * Asserts strict equality (`===`) of `actual` and `expected`.
   *
   *     assert.strictEqual(true, true, 'these booleans are strictly equal');
   *
   * @name strictEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @api public
   */

  assert.strictEqual = function (act, exp, msg) {
    new Assertion(act, msg).to.equal(exp);
  };

  /**
   * ### .notStrictEqual(actual, expected, [message])
   *
   * Asserts strict inequality (`!==`) of `actual` and `expected`.
   *
   *     assert.notStrictEqual(3, '3', 'no coercion for strict equality');
   *
   * @name notStrictEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @api public
   */

  assert.notStrictEqual = function (act, exp, msg) {
    new Assertion(act, msg).to.not.equal(exp);
  };

  /**
   * ### .deepEqual(actual, expected, [message])
   *
   * Asserts that `actual` is deeply equal to `expected`.
   *
   *     assert.deepEqual({ tea: 'green' }, { tea: 'green' });
   *
   * @name deepEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @api public
   */

  assert.deepEqual = function (act, exp, msg) {
    new Assertion(act, msg).to.eql(exp);
  };

  /**
   * ### .notDeepEqual(actual, expected, [message])
   *
   * Assert that `actual` is not deeply equal to `expected`.
   *
   *     assert.notDeepEqual({ tea: 'green' }, { tea: 'jasmine' });
   *
   * @name notDeepEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @api public
   */

  assert.notDeepEqual = function (act, exp, msg) {
    new Assertion(act, msg).to.not.eql(exp);
  };

  /**
   * ### .isTrue(value, [message])
   *
   * Asserts that `value` is true.
   *
   *     var teaServed = true;
   *     assert.isTrue(teaServed, 'the tea has been served');
   *
   * @name isTrue
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isTrue = function (val, msg) {
    new Assertion(val, msg).is['true'];
  };

  /**
   * ### .isFalse(value, [message])
   *
   * Asserts that `value` is false.
   *
   *     var teaServed = false;
   *     assert.isFalse(teaServed, 'no tea yet? hmm...');
   *
   * @name isFalse
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isFalse = function (val, msg) {
    new Assertion(val, msg).is['false'];
  };

  /**
   * ### .isNull(value, [message])
   *
   * Asserts that `value` is null.
   *
   *     assert.isNull(err, 'there was no error');
   *
   * @name isNull
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isNull = function (val, msg) {
    new Assertion(val, msg).to.equal(null);
  };

  /**
   * ### .isNotNull(value, [message])
   *
   * Asserts that `value` is not null.
   *
   *     var tea = 'tasty chai';
   *     assert.isNotNull(tea, 'great, time for tea!');
   *
   * @name isNotNull
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isNotNull = function (val, msg) {
    new Assertion(val, msg).to.not.equal(null);
  };

  /**
   * ### .isUndefined(value, [message])
   *
   * Asserts that `value` is `undefined`.
   *
   *     var tea;
   *     assert.isUndefined(tea, 'no tea defined');
   *
   * @name isUndefined
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isUndefined = function (val, msg) {
    new Assertion(val, msg).to.equal(undefined);
  };

  /**
   * ### .isDefined(value, [message])
   *
   * Asserts that `value` is not `undefined`.
   *
   *     var tea = 'cup of chai';
   *     assert.isDefined(tea, 'tea has been defined');
   *
   * @name isDefined
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isDefined = function (val, msg) {
    new Assertion(val, msg).to.not.equal(undefined);
  };

  /**
   * ### .isFunction(value, [message])
   *
   * Asserts that `value` is a function.
   *
   *     function serveTea() { return 'cup of tea'; };
   *     assert.isFunction(serveTea, 'great, we can have tea now');
   *
   * @name isFunction
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isFunction = function (val, msg) {
    new Assertion(val, msg).to.be.a('function');
  };

  /**
   * ### .isNotFunction(value, [message])
   *
   * Asserts that `value` is _not_ a function.
   *
   *     var serveTea = [ 'heat', 'pour', 'sip' ];
   *     assert.isNotFunction(serveTea, 'great, we have listed the steps');
   *
   * @name isNotFunction
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isNotFunction = function (val, msg) {
    new Assertion(val, msg).to.not.be.a('function');
  };

  /**
   * ### .isObject(value, [message])
   *
   * Asserts that `value` is an object (as revealed by
   * `Object.prototype.toString`).
   *
   *     var selection = { name: 'Chai', serve: 'with spices' };
   *     assert.isObject(selection, 'tea selection is an object');
   *
   * @name isObject
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isObject = function (val, msg) {
    new Assertion(val, msg).to.be.a('object');
  };

  /**
   * ### .isNotObject(value, [message])
   *
   * Asserts that `value` is _not_ an object.
   *
   *     var selection = 'chai'
   *     assert.isNotObject(selection, 'tea selection is not an object');
   *     assert.isNotObject(null, 'null is not an object');
   *
   * @name isNotObject
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isNotObject = function (val, msg) {
    new Assertion(val, msg).to.not.be.a('object');
  };

  /**
   * ### .isArray(value, [message])
   *
   * Asserts that `value` is an array.
   *
   *     var menu = [ 'green', 'chai', 'oolong' ];
   *     assert.isArray(menu, 'what kind of tea do we want?');
   *
   * @name isArray
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isArray = function (val, msg) {
    new Assertion(val, msg).to.be.an('array');
  };

  /**
   * ### .isNotArray(value, [message])
   *
   * Asserts that `value` is _not_ an array.
   *
   *     var menu = 'green|chai|oolong';
   *     assert.isNotArray(menu, 'what kind of tea do we want?');
   *
   * @name isNotArray
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isNotArray = function (val, msg) {
    new Assertion(val, msg).to.not.be.an('array');
  };

  /**
   * ### .isString(value, [message])
   *
   * Asserts that `value` is a string.
   *
   *     var teaOrder = 'chai';
   *     assert.isString(teaOrder, 'order placed');
   *
   * @name isString
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isString = function (val, msg) {
    new Assertion(val, msg).to.be.a('string');
  };

  /**
   * ### .isNotString(value, [message])
   *
   * Asserts that `value` is _not_ a string.
   *
   *     var teaOrder = 4;
   *     assert.isNotString(teaOrder, 'order placed');
   *
   * @name isNotString
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isNotString = function (val, msg) {
    new Assertion(val, msg).to.not.be.a('string');
  };

  /**
   * ### .isNumber(value, [message])
   *
   * Asserts that `value` is a number.
   *
   *     var cups = 2;
   *     assert.isNumber(cups, 'how many cups');
   *
   * @name isNumber
   * @param {Number} value
   * @param {String} message
   * @api public
   */

  assert.isNumber = function (val, msg) {
    new Assertion(val, msg).to.be.a('number');
  };

  /**
   * ### .isNotNumber(value, [message])
   *
   * Asserts that `value` is _not_ a number.
   *
   *     var cups = '2 cups please';
   *     assert.isNotNumber(cups, 'how many cups');
   *
   * @name isNotNumber
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isNotNumber = function (val, msg) {
    new Assertion(val, msg).to.not.be.a('number');
  };

  /**
   * ### .isBoolean(value, [message])
   *
   * Asserts that `value` is a boolean.
   *
   *     var teaReady = true
   *       , teaServed = false;
   *
   *     assert.isBoolean(teaReady, 'is the tea ready');
   *     assert.isBoolean(teaServed, 'has tea been served');
   *
   * @name isBoolean
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isBoolean = function (val, msg) {
    new Assertion(val, msg).to.be.a('boolean');
  };

  /**
   * ### .isNotBoolean(value, [message])
   *
   * Asserts that `value` is _not_ a boolean.
   *
   *     var teaReady = 'yep'
   *       , teaServed = 'nope';
   *
   *     assert.isNotBoolean(teaReady, 'is the tea ready');
   *     assert.isNotBoolean(teaServed, 'has tea been served');
   *
   * @name isNotBoolean
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isNotBoolean = function (val, msg) {
    new Assertion(val, msg).to.not.be.a('boolean');
  };

  /**
   * ### .typeOf(value, name, [message])
   *
   * Asserts that `value`'s type is `name`, as determined by
   * `Object.prototype.toString`.
   *
   *     assert.typeOf({ tea: 'chai' }, 'object', 'we have an object');
   *     assert.typeOf(['chai', 'jasmine'], 'array', 'we have an array');
   *     assert.typeOf('tea', 'string', 'we have a string');
   *     assert.typeOf(/tea/, 'regexp', 'we have a regular expression');
   *     assert.typeOf(null, 'null', 'we have a null');
   *     assert.typeOf(undefined, 'undefined', 'we have an undefined');
   *
   * @name typeOf
   * @param {Mixed} value
   * @param {String} name
   * @param {String} message
   * @api public
   */

  assert.typeOf = function (val, type, msg) {
    new Assertion(val, msg).to.be.a(type);
  };

  /**
   * ### .notTypeOf(value, name, [message])
   *
   * Asserts that `value`'s type is _not_ `name`, as determined by
   * `Object.prototype.toString`.
   *
   *     assert.notTypeOf('tea', 'number', 'strings are not numbers');
   *
   * @name notTypeOf
   * @param {Mixed} value
   * @param {String} typeof name
   * @param {String} message
   * @api public
   */

  assert.notTypeOf = function (val, type, msg) {
    new Assertion(val, msg).to.not.be.a(type);
  };

  /**
   * ### .instanceOf(object, constructor, [message])
   *
   * Asserts that `value` is an instance of `constructor`.
   *
   *     var Tea = function (name) { this.name = name; }
   *       , chai = new Tea('chai');
   *
   *     assert.instanceOf(chai, Tea, 'chai is an instance of tea');
   *
   * @name instanceOf
   * @param {Object} object
   * @param {Constructor} constructor
   * @param {String} message
   * @api public
   */

  assert.instanceOf = function (val, type, msg) {
    new Assertion(val, msg).to.be.instanceOf(type);
  };

  /**
   * ### .notInstanceOf(object, constructor, [message])
   *
   * Asserts `value` is not an instance of `constructor`.
   *
   *     var Tea = function (name) { this.name = name; }
   *       , chai = new String('chai');
   *
   *     assert.notInstanceOf(chai, Tea, 'chai is not an instance of tea');
   *
   * @name notInstanceOf
   * @param {Object} object
   * @param {Constructor} constructor
   * @param {String} message
   * @api public
   */

  assert.notInstanceOf = function (val, type, msg) {
    new Assertion(val, msg).to.not.be.instanceOf(type);
  };

  /**
   * ### .include(haystack, needle, [message])
   *
   * Asserts that `haystack` includes `needle`. Works
   * for strings and arrays.
   *
   *     assert.include('foobar', 'bar', 'foobar contains string "bar"');
   *     assert.include([ 1, 2, 3 ], 3, 'array contains value');
   *
   * @name include
   * @param {Array|String} haystack
   * @param {Mixed} needle
   * @param {String} message
   * @api public
   */

  assert.include = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.include).include(inc);
  };

  /**
   * ### .notInclude(haystack, needle, [message])
   *
   * Asserts that `haystack` does not include `needle`. Works
   * for strings and arrays.
   *i
   *     assert.notInclude('foobar', 'baz', 'string not include substring');
   *     assert.notInclude([ 1, 2, 3 ], 4, 'array not include contain value');
   *
   * @name notInclude
   * @param {Array|String} haystack
   * @param {Mixed} needle
   * @param {String} message
   * @api public
   */

  assert.notInclude = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.notInclude).not.include(inc);
  };

  /**
   * ### .match(value, regexp, [message])
   *
   * Asserts that `value` matches the regular expression `regexp`.
   *
   *     assert.match('foobar', /^foo/, 'regexp matches');
   *
   * @name match
   * @param {Mixed} value
   * @param {RegExp} regexp
   * @param {String} message
   * @api public
   */

  assert.match = function (exp, re, msg) {
    new Assertion(exp, msg).to.match(re);
  };

  /**
   * ### .notMatch(value, regexp, [message])
   *
   * Asserts that `value` does not match the regular expression `regexp`.
   *
   *     assert.notMatch('foobar', /^foo/, 'regexp does not match');
   *
   * @name notMatch
   * @param {Mixed} value
   * @param {RegExp} regexp
   * @param {String} message
   * @api public
   */

  assert.notMatch = function (exp, re, msg) {
    new Assertion(exp, msg).to.not.match(re);
  };

  /**
   * ### .property(object, property, [message])
   *
   * Asserts that `object` has a property named by `property`.
   *
   *     assert.property({ tea: { green: 'matcha' }}, 'tea');
   *
   * @name property
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @api public
   */

  assert.property = function (obj, prop, msg) {
    new Assertion(obj, msg).to.have.property(prop);
  };

  /**
   * ### .notProperty(object, property, [message])
   *
   * Asserts that `object` does _not_ have a property named by `property`.
   *
   *     assert.notProperty({ tea: { green: 'matcha' }}, 'coffee');
   *
   * @name notProperty
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @api public
   */

  assert.notProperty = function (obj, prop, msg) {
    new Assertion(obj, msg).to.not.have.property(prop);
  };

  /**
   * ### .deepProperty(object, property, [message])
   *
   * Asserts that `object` has a property named by `property`, which can be a
   * string using dot- and bracket-notation for deep reference.
   *
   *     assert.deepProperty({ tea: { green: 'matcha' }}, 'tea.green');
   *
   * @name deepProperty
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @api public
   */

  assert.deepProperty = function (obj, prop, msg) {
    new Assertion(obj, msg).to.have.deep.property(prop);
  };

  /**
   * ### .notDeepProperty(object, property, [message])
   *
   * Asserts that `object` does _not_ have a property named by `property`, which
   * can be a string using dot- and bracket-notation for deep reference.
   *
   *     assert.notDeepProperty({ tea: { green: 'matcha' }}, 'tea.oolong');
   *
   * @name notDeepProperty
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @api public
   */

  assert.notDeepProperty = function (obj, prop, msg) {
    new Assertion(obj, msg).to.not.have.deep.property(prop);
  };

  /**
   * ### .propertyVal(object, property, value, [message])
   *
   * Asserts that `object` has a property named by `property` with value given
   * by `value`.
   *
   *     assert.propertyVal({ tea: 'is good' }, 'tea', 'is good');
   *
   * @name propertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.propertyVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg).to.have.property(prop, val);
  };

  /**
   * ### .propertyNotVal(object, property, value, [message])
   *
   * Asserts that `object` has a property named by `property`, but with a value
   * different from that given by `value`.
   *
   *     assert.propertyNotVal({ tea: 'is good' }, 'tea', 'is bad');
   *
   * @name propertyNotVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.propertyNotVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg).to.not.have.property(prop, val);
  };

  /**
   * ### .deepPropertyVal(object, property, value, [message])
   *
   * Asserts that `object` has a property named by `property` with value given
   * by `value`. `property` can use dot- and bracket-notation for deep
   * reference.
   *
   *     assert.deepPropertyVal({ tea: { green: 'matcha' }}, 'tea.green', 'matcha');
   *
   * @name deepPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.deepPropertyVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg).to.have.deep.property(prop, val);
  };

  /**
   * ### .deepPropertyNotVal(object, property, value, [message])
   *
   * Asserts that `object` has a property named by `property`, but with a value
   * different from that given by `value`. `property` can use dot- and
   * bracket-notation for deep reference.
   *
   *     assert.deepPropertyNotVal({ tea: { green: 'matcha' }}, 'tea.green', 'konacha');
   *
   * @name deepPropertyNotVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.deepPropertyNotVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg).to.not.have.deep.property(prop, val);
  };

  /**
   * ### .lengthOf(object, length, [message])
   *
   * Asserts that `object` has a `length` property with the expected value.
   *
   *     assert.lengthOf([1,2,3], 3, 'array has length of 3');
   *     assert.lengthOf('foobar', 5, 'string has length of 6');
   *
   * @name lengthOf
   * @param {Mixed} object
   * @param {Number} length
   * @param {String} message
   * @api public
   */

  assert.lengthOf = function (exp, len, msg) {
    new Assertion(exp, msg).to.have.length(len);
  };

  /**
   * ### .throws(function, [constructor/string/regexp], [string/regexp], [message])
   *
   * Asserts that `function` will throw an error that is an instance of
   * `constructor`, or alternately that it will throw an error with message
   * matching `regexp`.
   *
   *     assert.throw(fn, 'function throws a reference error');
   *     assert.throw(fn, /function throws a reference error/);
   *     assert.throw(fn, ReferenceError);
   *     assert.throw(fn, ReferenceError, 'function throws a reference error');
   *     assert.throw(fn, ReferenceError, /function throws a reference error/);
   *
   * @name throws
   * @alias throw
   * @alias Throw
   * @param {Function} function
   * @param {ErrorConstructor} constructor
   * @param {RegExp} regexp
   * @param {String} message
   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
   * @api public
   */

  assert.Throw = function (fn, errt, errs, msg) {
    if ('string' === typeof errt || errt instanceof RegExp) {
      errs = errt;
      errt = null;
    }

    var assertErr = new Assertion(fn, msg).to.Throw(errt, errs);
    return flag(assertErr, 'object');
  };

  /**
   * ### .doesNotThrow(function, [constructor/regexp], [message])
   *
   * Asserts that `function` will _not_ throw an error that is an instance of
   * `constructor`, or alternately that it will not throw an error with message
   * matching `regexp`.
   *
   *     assert.doesNotThrow(fn, Error, 'function does not throw');
   *
   * @name doesNotThrow
   * @param {Function} function
   * @param {ErrorConstructor} constructor
   * @param {RegExp} regexp
   * @param {String} message
   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
   * @api public
   */

  assert.doesNotThrow = function (fn, type, msg) {
    if ('string' === typeof type) {
      msg = type;
      type = null;
    }

    new Assertion(fn, msg).to.not.Throw(type);
  };

  /**
   * ### .operator(val1, operator, val2, [message])
   *
   * Compares two values using `operator`.
   *
   *     assert.operator(1, '<', 2, 'everything is ok');
   *     assert.operator(1, '>', 2, 'this will fail');
   *
   * @name operator
   * @param {Mixed} val1
   * @param {String} operator
   * @param {Mixed} val2
   * @param {String} message
   * @api public
   */

  assert.operator = function (val, operator, val2, msg) {
    if (!~['==', '===', '>', '>=', '<', '<=', '!=', '!=='].indexOf(operator)) {
      throw new Error('Invalid operator "' + operator + '"');
    }
    var test = new Assertion(eval(val + operator + val2), msg);
    test.assert(
        true === flag(test, 'object')
      , 'expected ' + util.inspect(val) + ' to be ' + operator + ' ' + util.inspect(val2)
      , 'expected ' + util.inspect(val) + ' to not be ' + operator + ' ' + util.inspect(val2) );
  };

  /**
   * ### .closeTo(actual, expected, delta, [message])
   *
   * Asserts that the target is equal `expected`, to within a +/- `delta` range.
   *
   *     assert.closeTo(1.5, 1, 0.5, 'numbers are close');
   *
   * @name closeTo
   * @param {Number} actual
   * @param {Number} expected
   * @param {Number} delta
   * @param {String} message
   * @api public
   */

  assert.closeTo = function (act, exp, delta, msg) {
    new Assertion(act, msg).to.be.closeTo(exp, delta);
  };

  /**
   * ### .sameMembers(set1, set2, [message])
   *
   * Asserts that `set1` and `set2` have the same members.
   * Order is not taken into account.
   *
   *     assert.sameMembers([ 1, 2, 3 ], [ 2, 1, 3 ], 'same members');
   *
   * @name sameMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @api public
   */

  assert.sameMembers = function (set1, set2, msg) {
    new Assertion(set1, msg).to.have.same.members(set2);
  }

  /**
   * ### .includeMembers(superset, subset, [message])
   *
   * Asserts that `subset` is included in `superset`.
   * Order is not taken into account.
   *
   *     assert.includeMembers([ 1, 2, 3 ], [ 2, 1 ], 'include members');
   *
   * @name includeMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @api public
   */

  assert.includeMembers = function (superset, subset, msg) {
    new Assertion(superset, msg).to.include.members(subset);
  }

  /*!
   * Undocumented / untested
   */

  assert.ifError = function (val, msg) {
    new Assertion(val, msg).to.not.be.ok;
  };

  /*!
   * Aliases.
   */

  (function alias(name, as){
    assert[as] = assert[name];
    return alias;
  })
  ('Throw', 'throw')
  ('Throw', 'throws');
};

},{}],20:[function(require,module,exports){
/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

module.exports = function (chai, util) {
  chai.expect = function (val, message) {
    return new chai.Assertion(val, message);
  };
};


},{}],21:[function(require,module,exports){
/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

module.exports = function (chai, util) {
  var Assertion = chai.Assertion;

  function loadShould () {
    // explicitly define this method as function as to have it's name to include as `ssfi`
    function shouldGetter() {
      if (this instanceof String || this instanceof Number) {
        return new Assertion(this.constructor(this), null, shouldGetter);
      } else if (this instanceof Boolean) {
        return new Assertion(this == true, null, shouldGetter);
      }
      return new Assertion(this, null, shouldGetter);
    }
    function shouldSetter(value) {
      // See https://github.com/chaijs/chai/issues/86: this makes
      // `whatever.should = someValue` actually set `someValue`, which is
      // especially useful for `global.should = require('chai').should()`.
      //
      // Note that we have to use [[DefineProperty]] instead of [[Put]]
      // since otherwise we would trigger this very setter!
      Object.defineProperty(this, 'should', {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    }
    // modify Object.prototype to have `should`
    Object.defineProperty(Object.prototype, 'should', {
      set: shouldSetter
      , get: shouldGetter
      , configurable: true
    });

    var should = {};

    should.equal = function (val1, val2, msg) {
      new Assertion(val1, msg).to.equal(val2);
    };

    should.Throw = function (fn, errt, errs, msg) {
      new Assertion(fn, msg).to.Throw(errt, errs);
    };

    should.exist = function (val, msg) {
      new Assertion(val, msg).to.exist;
    }

    // negation
    should.not = {}

    should.not.equal = function (val1, val2, msg) {
      new Assertion(val1, msg).to.not.equal(val2);
    };

    should.not.Throw = function (fn, errt, errs, msg) {
      new Assertion(fn, msg).to.not.Throw(errt, errs);
    };

    should.not.exist = function (val, msg) {
      new Assertion(val, msg).to.not.exist;
    }

    should['throw'] = should['Throw'];
    should.not['throw'] = should.not['Throw'];

    return should;
  };

  chai.should = loadShould;
  chai.Should = loadShould;
};

},{}],22:[function(require,module,exports){
/*!
 * Chai - addChainingMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependencies
 */

var transferFlags = require('./transferFlags');
var flag = require('./flag');
var config = require('../config');

/*!
 * Module variables
 */

// Check whether `__proto__` is supported
var hasProtoSupport = '__proto__' in Object;

// Without `__proto__` support, this module will need to add properties to a function.
// However, some Function.prototype methods cannot be overwritten,
// and there seems no easy cross-platform way to detect them (@see chaijs/chai/issues/69).
var excludeNames = /^(?:length|name|arguments|caller)$/;

// Cache `Function` properties
var call  = Function.prototype.call,
    apply = Function.prototype.apply;

/**
 * ### addChainableMethod (ctx, name, method, chainingBehavior)
 *
 * Adds a method to an object, such that the method can also be chained.
 *
 *     utils.addChainableMethod(chai.Assertion.prototype, 'foo', function (str) {
 *       var obj = utils.flag(this, 'object');
 *       new chai.Assertion(obj).to.be.equal(str);
 *     });
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.addChainableMethod('foo', fn, chainingBehavior);
 *
 * The result can then be used as both a method assertion, executing both `method` and
 * `chainingBehavior`, or as a language chain, which only executes `chainingBehavior`.
 *
 *     expect(fooStr).to.be.foo('bar');
 *     expect(fooStr).to.be.foo.equal('foo');
 *
 * @param {Object} ctx object to which the method is added
 * @param {String} name of method to add
 * @param {Function} method function to be used for `name`, when called
 * @param {Function} chainingBehavior function to be called every time the property is accessed
 * @name addChainableMethod
 * @api public
 */

module.exports = function (ctx, name, method, chainingBehavior) {
  if (typeof chainingBehavior !== 'function') {
    chainingBehavior = function () { };
  }

  var chainableBehavior = {
      method: method
    , chainingBehavior: chainingBehavior
  };

  // save the methods so we can overwrite them later, if we need to.
  if (!ctx.__methods) {
    ctx.__methods = {};
  }
  ctx.__methods[name] = chainableBehavior;

  Object.defineProperty(ctx, name,
    { get: function () {
        chainableBehavior.chainingBehavior.call(this);

        var assert = function assert() {
          var old_ssfi = flag(this, 'ssfi');
          if (old_ssfi && config.includeStack === false)
            flag(this, 'ssfi', assert);
          var result = chainableBehavior.method.apply(this, arguments);
          return result === undefined ? this : result;
        };

        // Use `__proto__` if available
        if (hasProtoSupport) {
          // Inherit all properties from the object by replacing the `Function` prototype
          var prototype = assert.__proto__ = Object.create(this);
          // Restore the `call` and `apply` methods from `Function`
          prototype.call = call;
          prototype.apply = apply;
        }
        // Otherwise, redefine all properties (slow!)
        else {
          var asserterNames = Object.getOwnPropertyNames(ctx);
          asserterNames.forEach(function (asserterName) {
            if (!excludeNames.test(asserterName)) {
              var pd = Object.getOwnPropertyDescriptor(ctx, asserterName);
              Object.defineProperty(assert, asserterName, pd);
            }
          });
        }

        transferFlags(this, assert);
        return assert;
      }
    , configurable: true
  });
};

},{"../config":17,"./flag":25,"./transferFlags":39}],23:[function(require,module,exports){
/*!
 * Chai - addMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

var config = require('../config');

/**
 * ### .addMethod (ctx, name, method)
 *
 * Adds a method to the prototype of an object.
 *
 *     utils.addMethod(chai.Assertion.prototype, 'foo', function (str) {
 *       var obj = utils.flag(this, 'object');
 *       new chai.Assertion(obj).to.be.equal(str);
 *     });
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.addMethod('foo', fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(fooStr).to.be.foo('bar');
 *
 * @param {Object} ctx object to which the method is added
 * @param {String} name of method to add
 * @param {Function} method function to be used for name
 * @name addMethod
 * @api public
 */
var flag = require('./flag');

module.exports = function (ctx, name, method) {
  ctx[name] = function () {
    var old_ssfi = flag(this, 'ssfi');
    if (old_ssfi && config.includeStack === false)
      flag(this, 'ssfi', ctx[name]);
    var result = method.apply(this, arguments);
    return result === undefined ? this : result;
  };
};

},{"../config":17,"./flag":25}],24:[function(require,module,exports){
/*!
 * Chai - addProperty utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### addProperty (ctx, name, getter)
 *
 * Adds a property to the prototype of an object.
 *
 *     utils.addProperty(chai.Assertion.prototype, 'foo', function () {
 *       var obj = utils.flag(this, 'object');
 *       new chai.Assertion(obj).to.be.instanceof(Foo);
 *     });
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.addProperty('foo', fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(myFoo).to.be.foo;
 *
 * @param {Object} ctx object to which the property is added
 * @param {String} name of property to add
 * @param {Function} getter function to be used for name
 * @name addProperty
 * @api public
 */

module.exports = function (ctx, name, getter) {
  Object.defineProperty(ctx, name,
    { get: function () {
        var result = getter.call(this);
        return result === undefined ? this : result;
      }
    , configurable: true
  });
};

},{}],25:[function(require,module,exports){
/*!
 * Chai - flag utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### flag(object ,key, [value])
 *
 * Get or set a flag value on an object. If a
 * value is provided it will be set, else it will
 * return the currently set value or `undefined` if
 * the value is not set.
 *
 *     utils.flag(this, 'foo', 'bar'); // setter
 *     utils.flag(this, 'foo'); // getter, returns `bar`
 *
 * @param {Object} object (constructed Assertion
 * @param {String} key
 * @param {Mixed} value (optional)
 * @name flag
 * @api private
 */

module.exports = function (obj, key, value) {
  var flags = obj.__flags || (obj.__flags = Object.create(null));
  if (arguments.length === 3) {
    flags[key] = value;
  } else {
    return flags[key];
  }
};

},{}],26:[function(require,module,exports){
/*!
 * Chai - getActual utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * # getActual(object, [actual])
 *
 * Returns the `actual` value for an Assertion
 *
 * @param {Object} object (constructed Assertion)
 * @param {Arguments} chai.Assertion.prototype.assert arguments
 */

module.exports = function (obj, args) {
  return args.length > 4 ? args[4] : obj._obj;
};

},{}],27:[function(require,module,exports){
/*!
 * Chai - getEnumerableProperties utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .getEnumerableProperties(object)
 *
 * This allows the retrieval of enumerable property names of an object,
 * inherited or not.
 *
 * @param {Object} object
 * @returns {Array}
 * @name getEnumerableProperties
 * @api public
 */

module.exports = function getEnumerableProperties(object) {
  var result = [];
  for (var name in object) {
    result.push(name);
  }
  return result;
};

},{}],28:[function(require,module,exports){
/*!
 * Chai - message composition utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependancies
 */

var flag = require('./flag')
  , getActual = require('./getActual')
  , inspect = require('./inspect')
  , objDisplay = require('./objDisplay');

/**
 * ### .getMessage(object, message, negateMessage)
 *
 * Construct the error message based on flags
 * and template tags. Template tags will return
 * a stringified inspection of the object referenced.
 *
 * Message template tags:
 * - `#{this}` current asserted object
 * - `#{act}` actual value
 * - `#{exp}` expected value
 *
 * @param {Object} object (constructed Assertion)
 * @param {Arguments} chai.Assertion.prototype.assert arguments
 * @name getMessage
 * @api public
 */

module.exports = function (obj, args) {
  var negate = flag(obj, 'negate')
    , val = flag(obj, 'object')
    , expected = args[3]
    , actual = getActual(obj, args)
    , msg = negate ? args[2] : args[1]
    , flagMsg = flag(obj, 'message');

  msg = msg || '';
  msg = msg
    .replace(/#{this}/g, objDisplay(val))
    .replace(/#{act}/g, objDisplay(actual))
    .replace(/#{exp}/g, objDisplay(expected));

  return flagMsg ? flagMsg + ': ' + msg : msg;
};

},{"./flag":25,"./getActual":26,"./inspect":33,"./objDisplay":34}],29:[function(require,module,exports){
/*!
 * Chai - getName utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * # getName(func)
 *
 * Gets the name of a function, in a cross-browser way.
 *
 * @param {Function} a function (usually a constructor)
 */

module.exports = function (func) {
  if (func.name) return func.name;

  var match = /^\s?function ([^(]*)\(/.exec(func);
  return match && match[1] ? match[1] : "";
};

},{}],30:[function(require,module,exports){
/*!
 * Chai - getPathValue utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * @see https://github.com/logicalparadox/filtr
 * MIT Licensed
 */

/**
 * ### .getPathValue(path, object)
 *
 * This allows the retrieval of values in an
 * object given a string path.
 *
 *     var obj = {
 *         prop1: {
 *             arr: ['a', 'b', 'c']
 *           , str: 'Hello'
 *         }
 *       , prop2: {
 *             arr: [ { nested: 'Universe' } ]
 *           , str: 'Hello again!'
 *         }
 *     }
 *
 * The following would be the results.
 *
 *     getPathValue('prop1.str', obj); // Hello
 *     getPathValue('prop1.att[2]', obj); // b
 *     getPathValue('prop2.arr[0].nested', obj); // Universe
 *
 * @param {String} path
 * @param {Object} object
 * @returns {Object} value or `undefined`
 * @name getPathValue
 * @api public
 */

var getPathValue = module.exports = function (path, obj) {
  var parsed = parsePath(path);
  return _getPathValue(parsed, obj);
};

/*!
 * ## parsePath(path)
 *
 * Helper function used to parse string object
 * paths. Use in conjunction with `_getPathValue`.
 *
 *      var parsed = parsePath('myobject.property.subprop');
 *
 * ### Paths:
 *
 * * Can be as near infinitely deep and nested
 * * Arrays are also valid using the formal `myobject.document[3].property`.
 *
 * @param {String} path
 * @returns {Object} parsed
 * @api private
 */

function parsePath (path) {
  var str = path.replace(/\[/g, '.[')
    , parts = str.match(/(\\\.|[^.]+?)+/g);
  return parts.map(function (value) {
    var re = /\[(\d+)\]$/
      , mArr = re.exec(value)
    if (mArr) return { i: parseFloat(mArr[1]) };
    else return { p: value };
  });
};

/*!
 * ## _getPathValue(parsed, obj)
 *
 * Helper companion function for `.parsePath` that returns
 * the value located at the parsed address.
 *
 *      var value = getPathValue(parsed, obj);
 *
 * @param {Object} parsed definition from `parsePath`.
 * @param {Object} object to search against
 * @returns {Object|Undefined} value
 * @api private
 */

function _getPathValue (parsed, obj) {
  var tmp = obj
    , res;
  for (var i = 0, l = parsed.length; i < l; i++) {
    var part = parsed[i];
    if (tmp) {
      if ('undefined' !== typeof part.p)
        tmp = tmp[part.p];
      else if ('undefined' !== typeof part.i)
        tmp = tmp[part.i];
      if (i == (l - 1)) res = tmp;
    } else {
      res = undefined;
    }
  }
  return res;
};

},{}],31:[function(require,module,exports){
/*!
 * Chai - getProperties utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .getProperties(object)
 *
 * This allows the retrieval of property names of an object, enumerable or not,
 * inherited or not.
 *
 * @param {Object} object
 * @returns {Array}
 * @name getProperties
 * @api public
 */

module.exports = function getProperties(object) {
  var result = Object.getOwnPropertyNames(subject);

  function addProperty(property) {
    if (result.indexOf(property) === -1) {
      result.push(property);
    }
  }

  var proto = Object.getPrototypeOf(subject);
  while (proto !== null) {
    Object.getOwnPropertyNames(proto).forEach(addProperty);
    proto = Object.getPrototypeOf(proto);
  }

  return result;
};

},{}],32:[function(require,module,exports){
/*!
 * chai
 * Copyright(c) 2011 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Main exports
 */

var exports = module.exports = {};

/*!
 * test utility
 */

exports.test = require('./test');

/*!
 * type utility
 */

exports.type = require('./type');

/*!
 * message utility
 */

exports.getMessage = require('./getMessage');

/*!
 * actual utility
 */

exports.getActual = require('./getActual');

/*!
 * Inspect util
 */

exports.inspect = require('./inspect');

/*!
 * Object Display util
 */

exports.objDisplay = require('./objDisplay');

/*!
 * Flag utility
 */

exports.flag = require('./flag');

/*!
 * Flag transferring utility
 */

exports.transferFlags = require('./transferFlags');

/*!
 * Deep equal utility
 */

exports.eql = require('deep-eql');

/*!
 * Deep path value
 */

exports.getPathValue = require('./getPathValue');

/*!
 * Function name
 */

exports.getName = require('./getName');

/*!
 * add Property
 */

exports.addProperty = require('./addProperty');

/*!
 * add Method
 */

exports.addMethod = require('./addMethod');

/*!
 * overwrite Property
 */

exports.overwriteProperty = require('./overwriteProperty');

/*!
 * overwrite Method
 */

exports.overwriteMethod = require('./overwriteMethod');

/*!
 * Add a chainable method
 */

exports.addChainableMethod = require('./addChainableMethod');

/*!
 * Overwrite chainable method
 */

exports.overwriteChainableMethod = require('./overwriteChainableMethod');


},{"./addChainableMethod":22,"./addMethod":23,"./addProperty":24,"./flag":25,"./getActual":26,"./getMessage":28,"./getName":29,"./getPathValue":30,"./inspect":33,"./objDisplay":34,"./overwriteChainableMethod":35,"./overwriteMethod":36,"./overwriteProperty":37,"./test":38,"./transferFlags":39,"./type":40,"deep-eql":42}],33:[function(require,module,exports){
// This is (almost) directly from Node.js utils
// https://github.com/joyent/node/blob/f8c335d0caf47f16d31413f89aa28eda3878e3aa/lib/util.js

var getName = require('./getName');
var getProperties = require('./getProperties');
var getEnumerableProperties = require('./getEnumerableProperties');

module.exports = inspect;

/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Boolean} showHidden Flag that shows hidden (not enumerable)
 *    properties of objects.
 * @param {Number} depth Depth in which to descend in object. Default is 2.
 * @param {Boolean} colors Flag to turn on ANSI escape codes to color the
 *    output. Default is false (no coloring).
 */
function inspect(obj, showHidden, depth, colors) {
  var ctx = {
    showHidden: showHidden,
    seen: [],
    stylize: function (str) { return str; }
  };
  return formatValue(ctx, obj, (typeof depth === 'undefined' ? 2 : depth));
}

// https://gist.github.com/1044128/
var getOuterHTML = function(element) {
  if ('outerHTML' in element) return element.outerHTML;
  var ns = "http://www.w3.org/1999/xhtml";
  var container = document.createElementNS(ns, '_');
  var elemProto = (window.HTMLElement || window.Element).prototype;
  var xmlSerializer = new XMLSerializer();
  var html;
  if (document.xmlVersion) {
    return xmlSerializer.serializeToString(element);
  } else {
    container.appendChild(element.cloneNode(false));
    html = container.innerHTML.replace('><', '>' + element.innerHTML + '<');
    container.innerHTML = '';
    return html;
  }
};

// Returns true if object is a DOM element.
var isDOMElement = function (object) {
  if (typeof HTMLElement === 'object') {
    return object instanceof HTMLElement;
  } else {
    return object &&
      typeof object === 'object' &&
      object.nodeType === 1 &&
      typeof object.nodeName === 'string';
  }
};

function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (value && typeof value.inspect === 'function' &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes);
    if (typeof ret !== 'string') {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // If it's DOM elem, get outer HTML.
  if (isDOMElement(value)) {
    return getOuterHTML(value);
  }

  // Look up the keys of the object.
  var visibleKeys = getEnumerableProperties(value);
  var keys = ctx.showHidden ? getProperties(value) : visibleKeys;

  // Some type of object without properties can be shortcutted.
  // In IE, errors have a single `stack` property, or if they are vanilla `Error`,
  // a `stack` plus `description` property; ignore those for consistency.
  if (keys.length === 0 || (isError(value) && (
      (keys.length === 1 && keys[0] === 'stack') ||
      (keys.length === 2 && keys[0] === 'description' && keys[1] === 'stack')
     ))) {
    if (typeof value === 'function') {
      var name = getName(value);
      var nameSuffix = name ? ': ' + name : '';
      return ctx.stylize('[Function' + nameSuffix + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toUTCString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (typeof value === 'function') {
    var name = getName(value);
    var nameSuffix = name ? ': ' + name : '';
    base = ' [Function' + nameSuffix + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    return formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  switch (typeof value) {
    case 'undefined':
      return ctx.stylize('undefined', 'undefined');

    case 'string':
      var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                               .replace(/'/g, "\\'")
                                               .replace(/\\"/g, '"') + '\'';
      return ctx.stylize(simple, 'string');

    case 'number':
      return ctx.stylize('' + value, 'number');

    case 'boolean':
      return ctx.stylize('' + value, 'boolean');
  }
  // For some reason typeof null is "object", so special case here.
  if (value === null) {
    return ctx.stylize('null', 'null');
  }
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (Object.prototype.hasOwnProperty.call(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str;
  if (value.__lookupGetter__) {
    if (value.__lookupGetter__(key)) {
      if (value.__lookupSetter__(key)) {
        str = ctx.stylize('[Getter/Setter]', 'special');
      } else {
        str = ctx.stylize('[Getter]', 'special');
      }
    } else {
      if (value.__lookupSetter__(key)) {
        str = ctx.stylize('[Setter]', 'special');
      }
    }
  }
  if (visibleKeys.indexOf(key) < 0) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(value[key]) < 0) {
      if (recurseTimes === null) {
        str = formatValue(ctx, value[key], null);
      } else {
        str = formatValue(ctx, value[key], recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (typeof name === 'undefined') {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}

function isArray(ar) {
  return Array.isArray(ar) ||
         (typeof ar === 'object' && objectToString(ar) === '[object Array]');
}

function isRegExp(re) {
  return typeof re === 'object' && objectToString(re) === '[object RegExp]';
}

function isDate(d) {
  return typeof d === 'object' && objectToString(d) === '[object Date]';
}

function isError(e) {
  return typeof e === 'object' && objectToString(e) === '[object Error]';
}

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

},{"./getEnumerableProperties":27,"./getName":29,"./getProperties":31}],34:[function(require,module,exports){
/*!
 * Chai - flag utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependancies
 */

var inspect = require('./inspect');
var config = require('../config');

/**
 * ### .objDisplay (object)
 *
 * Determines if an object or an array matches
 * criteria to be inspected in-line for error
 * messages or should be truncated.
 *
 * @param {Mixed} javascript object to inspect
 * @name objDisplay
 * @api public
 */

module.exports = function (obj) {
  var str = inspect(obj)
    , type = Object.prototype.toString.call(obj);

  if (config.truncateThreshold && str.length >= config.truncateThreshold) {
    if (type === '[object Function]') {
      return !obj.name || obj.name === ''
        ? '[Function]'
        : '[Function: ' + obj.name + ']';
    } else if (type === '[object Array]') {
      return '[ Array(' + obj.length + ') ]';
    } else if (type === '[object Object]') {
      var keys = Object.keys(obj)
        , kstr = keys.length > 2
          ? keys.splice(0, 2).join(', ') + ', ...'
          : keys.join(', ');
      return '{ Object (' + kstr + ') }';
    } else {
      return str;
    }
  } else {
    return str;
  }
};

},{"../config":17,"./inspect":33}],35:[function(require,module,exports){
/*!
 * Chai - overwriteChainableMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### overwriteChainableMethod (ctx, name, fn)
 *
 * Overwites an already existing chainable method
 * and provides access to the previous function or
 * property.  Must return functions to be used for
 * name.
 *
 *     utils.overwriteChainableMethod(chai.Assertion.prototype, 'length',
 *       function (_super) {
 *       }
 *     , function (_super) {
 *       }
 *     );
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.overwriteChainableMethod('foo', fn, fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(myFoo).to.have.length(3);
 *     expect(myFoo).to.have.length.above(3);
 *
 * @param {Object} ctx object whose method / property is to be overwritten
 * @param {String} name of method / property to overwrite
 * @param {Function} method function that returns a function to be used for name
 * @param {Function} chainingBehavior function that returns a function to be used for property
 * @name overwriteChainableMethod
 * @api public
 */

module.exports = function (ctx, name, method, chainingBehavior) {
  var chainableBehavior = ctx.__methods[name];

  var _chainingBehavior = chainableBehavior.chainingBehavior;
  chainableBehavior.chainingBehavior = function () {
    var result = chainingBehavior(_chainingBehavior).call(this);
    return result === undefined ? this : result;
  };

  var _method = chainableBehavior.method;
  chainableBehavior.method = function () {
    var result = method(_method).apply(this, arguments);
    return result === undefined ? this : result;
  };
};

},{}],36:[function(require,module,exports){
/*!
 * Chai - overwriteMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### overwriteMethod (ctx, name, fn)
 *
 * Overwites an already existing method and provides
 * access to previous function. Must return function
 * to be used for name.
 *
 *     utils.overwriteMethod(chai.Assertion.prototype, 'equal', function (_super) {
 *       return function (str) {
 *         var obj = utils.flag(this, 'object');
 *         if (obj instanceof Foo) {
 *           new chai.Assertion(obj.value).to.equal(str);
 *         } else {
 *           _super.apply(this, arguments);
 *         }
 *       }
 *     });
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.overwriteMethod('foo', fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(myFoo).to.equal('bar');
 *
 * @param {Object} ctx object whose method is to be overwritten
 * @param {String} name of method to overwrite
 * @param {Function} method function that returns a function to be used for name
 * @name overwriteMethod
 * @api public
 */

module.exports = function (ctx, name, method) {
  var _method = ctx[name]
    , _super = function () { return this; };

  if (_method && 'function' === typeof _method)
    _super = _method;

  ctx[name] = function () {
    var result = method(_super).apply(this, arguments);
    return result === undefined ? this : result;
  }
};

},{}],37:[function(require,module,exports){
/*!
 * Chai - overwriteProperty utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### overwriteProperty (ctx, name, fn)
 *
 * Overwites an already existing property getter and provides
 * access to previous value. Must return function to use as getter.
 *
 *     utils.overwriteProperty(chai.Assertion.prototype, 'ok', function (_super) {
 *       return function () {
 *         var obj = utils.flag(this, 'object');
 *         if (obj instanceof Foo) {
 *           new chai.Assertion(obj.name).to.equal('bar');
 *         } else {
 *           _super.call(this);
 *         }
 *       }
 *     });
 *
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.overwriteProperty('foo', fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(myFoo).to.be.ok;
 *
 * @param {Object} ctx object whose property is to be overwritten
 * @param {String} name of property to overwrite
 * @param {Function} getter function that returns a getter function to be used for name
 * @name overwriteProperty
 * @api public
 */

module.exports = function (ctx, name, getter) {
  var _get = Object.getOwnPropertyDescriptor(ctx, name)
    , _super = function () {};

  if (_get && 'function' === typeof _get.get)
    _super = _get.get

  Object.defineProperty(ctx, name,
    { get: function () {
        var result = getter(_super).call(this);
        return result === undefined ? this : result;
      }
    , configurable: true
  });
};

},{}],38:[function(require,module,exports){
/*!
 * Chai - test utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependancies
 */

var flag = require('./flag');

/**
 * # test(object, expression)
 *
 * Test and object for expression.
 *
 * @param {Object} object (constructed Assertion)
 * @param {Arguments} chai.Assertion.prototype.assert arguments
 */

module.exports = function (obj, args) {
  var negate = flag(obj, 'negate')
    , expr = args[0];
  return negate ? !expr : expr;
};

},{"./flag":25}],39:[function(require,module,exports){
/*!
 * Chai - transferFlags utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### transferFlags(assertion, object, includeAll = true)
 *
 * Transfer all the flags for `assertion` to `object`. If
 * `includeAll` is set to `false`, then the base Chai
 * assertion flags (namely `object`, `ssfi`, and `message`)
 * will not be transferred.
 *
 *
 *     var newAssertion = new Assertion();
 *     utils.transferFlags(assertion, newAssertion);
 *
 *     var anotherAsseriton = new Assertion(myObj);
 *     utils.transferFlags(assertion, anotherAssertion, false);
 *
 * @param {Assertion} assertion the assertion to transfer the flags from
 * @param {Object} object the object to transfer the flags too; usually a new assertion
 * @param {Boolean} includeAll
 * @name getAllFlags
 * @api private
 */

module.exports = function (assertion, object, includeAll) {
  var flags = assertion.__flags || (assertion.__flags = Object.create(null));

  if (!object.__flags) {
    object.__flags = Object.create(null);
  }

  includeAll = arguments.length === 3 ? includeAll : true;

  for (var flag in flags) {
    if (includeAll ||
        (flag !== 'object' && flag !== 'ssfi' && flag != 'message')) {
      object.__flags[flag] = flags[flag];
    }
  }
};

},{}],40:[function(require,module,exports){
/*!
 * Chai - type utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Detectable javascript natives
 */

var natives = {
    '[object Arguments]': 'arguments'
  , '[object Array]': 'array'
  , '[object Date]': 'date'
  , '[object Function]': 'function'
  , '[object Number]': 'number'
  , '[object RegExp]': 'regexp'
  , '[object String]': 'string'
};

/**
 * ### type(object)
 *
 * Better implementation of `typeof` detection that can
 * be used cross-browser. Handles the inconsistencies of
 * Array, `null`, and `undefined` detection.
 *
 *     utils.type({}) // 'object'
 *     utils.type(null) // `null'
 *     utils.type(undefined) // `undefined`
 *     utils.type([]) // `array`
 *
 * @param {Mixed} object to detect type of
 * @name type
 * @api private
 */

module.exports = function (obj) {
  var str = Object.prototype.toString.call(obj);
  if (natives[str]) return natives[str];
  if (obj === null) return 'null';
  if (obj === undefined) return 'undefined';
  if (obj === Object(obj)) return 'object';
  return typeof obj;
};

},{}],41:[function(require,module,exports){
/*!
 * assertion-error
 * Copyright(c) 2013 Jake Luer <jake@qualiancy.com>
 * MIT Licensed
 */

/*!
 * Return a function that will copy properties from
 * one object to another excluding any originally
 * listed. Returned function will create a new `{}`.
 *
 * @param {String} excluded properties ...
 * @return {Function}
 */

function exclude () {
  var excludes = [].slice.call(arguments);

  function excludeProps (res, obj) {
    Object.keys(obj).forEach(function (key) {
      if (!~excludes.indexOf(key)) res[key] = obj[key];
    });
  }

  return function extendExclude () {
    var args = [].slice.call(arguments)
      , i = 0
      , res = {};

    for (; i < args.length; i++) {
      excludeProps(res, args[i]);
    }

    return res;
  };
};

/*!
 * Primary Exports
 */

module.exports = AssertionError;

/**
 * ### AssertionError
 *
 * An extension of the JavaScript `Error` constructor for
 * assertion and validation scenarios.
 *
 * @param {String} message
 * @param {Object} properties to include (optional)
 * @param {callee} start stack function (optional)
 */

function AssertionError (message, _props, ssf) {
  var extend = exclude('name', 'message', 'stack', 'constructor', 'toJSON')
    , props = extend(_props || {});

  // default values
  this.message = message || 'Unspecified AssertionError';
  this.showDiff = false;

  // copy from properties
  for (var key in props) {
    this[key] = props[key];
  }

  // capture stack trace
  ssf = ssf || arguments.callee;
  if (ssf && Error.captureStackTrace) {
    Error.captureStackTrace(this, ssf);
  }
}

/*!
 * Inherit from Error.prototype
 */

AssertionError.prototype = Object.create(Error.prototype);

/*!
 * Statically set name
 */

AssertionError.prototype.name = 'AssertionError';

/*!
 * Ensure correct constructor
 */

AssertionError.prototype.constructor = AssertionError;

/**
 * Allow errors to be converted to JSON for static transfer.
 *
 * @param {Boolean} include stack (default: `true`)
 * @return {Object} object that can be `JSON.stringify`
 */

AssertionError.prototype.toJSON = function (stack) {
  var extend = exclude('constructor', 'toJSON', 'stack')
    , props = extend({ name: this.name }, this);

  // include stack if exists and not turned off
  if (false !== stack && this.stack) {
    props.stack = this.stack;
  }

  return props;
};

},{}],42:[function(require,module,exports){
module.exports = require('./lib/eql');

},{"./lib/eql":43}],43:[function(require,module,exports){
/*!
 * deep-eql
 * Copyright(c) 2013 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependencies
 */

var type = require('type-detect');

/*!
 * Buffer.isBuffer browser shim
 */

var Buffer;
try { Buffer = require('buffer').Buffer; }
catch(ex) {
  Buffer = {};
  Buffer.isBuffer = function() { return false; }
}

/*!
 * Primary Export
 */

module.exports = deepEqual;

/**
 * Assert super-strict (egal) equality between
 * two objects of any type.
 *
 * @param {Mixed} a
 * @param {Mixed} b
 * @param {Array} memoised (optional)
 * @return {Boolean} equal match
 */

function deepEqual(a, b, m) {
  if (sameValue(a, b)) {
    return true;
  } else if ('date' === type(a)) {
    return dateEqual(a, b);
  } else if ('regexp' === type(a)) {
    return regexpEqual(a, b);
  } else if (Buffer.isBuffer(a)) {
    return bufferEqual(a, b);
  } else if ('arguments' === type(a)) {
    return argumentsEqual(a, b, m);
  } else if (!typeEqual(a, b)) {
    return false;
  } else if (('object' !== type(a) && 'object' !== type(b))
  && ('array' !== type(a) && 'array' !== type(b))) {
    return sameValue(a, b);
  } else {
    return objectEqual(a, b, m);
  }
}

/*!
 * Strict (egal) equality test. Ensures that NaN always
 * equals NaN and `-0` does not equal `+0`.
 *
 * @param {Mixed} a
 * @param {Mixed} b
 * @return {Boolean} equal match
 */

function sameValue(a, b) {
  if (a === b) return a !== 0 || 1 / a === 1 / b;
  return a !== a && b !== b;
}

/*!
 * Compare the types of two given objects and
 * return if they are equal. Note that an Array
 * has a type of `array` (not `object`) and arguments
 * have a type of `arguments` (not `array`/`object`).
 *
 * @param {Mixed} a
 * @param {Mixed} b
 * @return {Boolean} result
 */

function typeEqual(a, b) {
  return type(a) === type(b);
}

/*!
 * Compare two Date objects by asserting that
 * the time values are equal using `saveValue`.
 *
 * @param {Date} a
 * @param {Date} b
 * @return {Boolean} result
 */

function dateEqual(a, b) {
  if ('date' !== type(b)) return false;
  return sameValue(a.getTime(), b.getTime());
}

/*!
 * Compare two regular expressions by converting them
 * to string and checking for `sameValue`.
 *
 * @param {RegExp} a
 * @param {RegExp} b
 * @return {Boolean} result
 */

function regexpEqual(a, b) {
  if ('regexp' !== type(b)) return false;
  return sameValue(a.toString(), b.toString());
}

/*!
 * Assert deep equality of two `arguments` objects.
 * Unfortunately, these must be sliced to arrays
 * prior to test to ensure no bad behavior.
 *
 * @param {Arguments} a
 * @param {Arguments} b
 * @param {Array} memoize (optional)
 * @return {Boolean} result
 */

function argumentsEqual(a, b, m) {
  if ('arguments' !== type(b)) return false;
  a = [].slice.call(a);
  b = [].slice.call(b);
  return deepEqual(a, b, m);
}

/*!
 * Get enumerable properties of a given object.
 *
 * @param {Object} a
 * @return {Array} property names
 */

function enumerable(a) {
  var res = [];
  for (var key in a) res.push(key);
  return res;
}

/*!
 * Simple equality for flat iterable objects
 * such as Arrays or Node.js buffers.
 *
 * @param {Iterable} a
 * @param {Iterable} b
 * @return {Boolean} result
 */

function iterableEqual(a, b) {
  if (a.length !==  b.length) return false;

  var i = 0;
  var match = true;

  for (; i < a.length; i++) {
    if (a[i] !== b[i]) {
      match = false;
      break;
    }
  }

  return match;
}

/*!
 * Extension to `iterableEqual` specifically
 * for Node.js Buffers.
 *
 * @param {Buffer} a
 * @param {Mixed} b
 * @return {Boolean} result
 */

function bufferEqual(a, b) {
  if (!Buffer.isBuffer(b)) return false;
  return iterableEqual(a, b);
}

/*!
 * Block for `objectEqual` ensuring non-existing
 * values don't get in.
 *
 * @param {Mixed} object
 * @return {Boolean} result
 */

function isValue(a) {
  return a !== null && a !== undefined;
}

/*!
 * Recursively check the equality of two objects.
 * Once basic sameness has been established it will
 * defer to `deepEqual` for each enumerable key
 * in the object.
 *
 * @param {Mixed} a
 * @param {Mixed} b
 * @return {Boolean} result
 */

function objectEqual(a, b, m) {
  if (!isValue(a) || !isValue(b)) {
    return false;
  }

  if (a.prototype !== b.prototype) {
    return false;
  }

  var i;
  if (m) {
    for (i = 0; i < m.length; i++) {
      if ((m[i][0] === a && m[i][1] === b)
      ||  (m[i][0] === b && m[i][1] === a)) {
        return true;
      }
    }
  } else {
    m = [];
  }

  try {
    var ka = enumerable(a);
    var kb = enumerable(b);
  } catch (ex) {
    return false;
  }

  ka.sort();
  kb.sort();

  if (!iterableEqual(ka, kb)) {
    return false;
  }

  m.push([ a, b ]);

  var key;
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!deepEqual(a[key], b[key], m)) {
      return false;
    }
  }

  return true;
}

},{"buffer":47,"type-detect":44}],44:[function(require,module,exports){
module.exports = require('./lib/type');

},{"./lib/type":45}],45:[function(require,module,exports){
/*!
 * type-detect
 * Copyright(c) 2013 jake luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Primary Exports
 */

var exports = module.exports = getType;

/*!
 * Detectable javascript natives
 */

var natives = {
    '[object Array]': 'array'
  , '[object RegExp]': 'regexp'
  , '[object Function]': 'function'
  , '[object Arguments]': 'arguments'
  , '[object Date]': 'date'
};

/**
 * ### typeOf (obj)
 *
 * Use several different techniques to determine
 * the type of object being tested.
 *
 *
 * @param {Mixed} object
 * @return {String} object type
 * @api public
 */

function getType (obj) {
  var str = Object.prototype.toString.call(obj);
  if (natives[str]) return natives[str];
  if (obj === null) return 'null';
  if (obj === undefined) return 'undefined';
  if (obj === Object(obj)) return 'object';
  return typeof obj;
}

exports.Library = Library;

/**
 * ### Library
 *
 * Create a repository for custom type detection.
 *
 * ```js
 * var lib = new type.Library;
 * ```
 *
 */

function Library () {
  this.tests = {};
}

/**
 * #### .of (obj)
 *
 * Expose replacement `typeof` detection to the library.
 *
 * ```js
 * if ('string' === lib.of('hello world')) {
 *   // ...
 * }
 * ```
 *
 * @param {Mixed} object to test
 * @return {String} type
 */

Library.prototype.of = getType;

/**
 * #### .define (type, test)
 *
 * Add a test to for the `.test()` assertion.
 *
 * Can be defined as a regular expression:
 *
 * ```js
 * lib.define('int', /^[0-9]+$/);
 * ```
 *
 * ... or as a function:
 *
 * ```js
 * lib.define('bln', function (obj) {
 *   if ('boolean' === lib.of(obj)) return true;
 *   var blns = [ 'yes', 'no', 'true', 'false', 1, 0 ];
 *   if ('string' === lib.of(obj)) obj = obj.toLowerCase();
 *   return !! ~blns.indexOf(obj);
 * });
 * ```
 *
 * @param {String} type
 * @param {RegExp|Function} test
 * @api public
 */

Library.prototype.define = function (type, test) {
  if (arguments.length === 1) return this.tests[type];
  this.tests[type] = test;
  return this;
};

/**
 * #### .test (obj, test)
 *
 * Assert that an object is of type. Will first
 * check natives, and if that does not pass it will
 * use the user defined custom tests.
 *
 * ```js
 * assert(lib.test('1', 'int'));
 * assert(lib.test('yes', 'bln'));
 * ```
 *
 * @param {Mixed} object
 * @param {String} type
 * @return {Boolean} result
 * @api public
 */

Library.prototype.test = function (obj, type) {
  if (type === getType(obj)) return true;
  var test = this.tests[type];

  if (test && 'regexp' === getType(test)) {
    return test.test(obj);
  } else if (test && 'function' === getType(test)) {
    return test(obj);
  } else {
    throw new ReferenceError('Type test "' + type + '" not defined or invalid.');
  }
};

},{}],46:[function(require,module,exports){

},{}],47:[function(require,module,exports){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = Buffer
exports.INSPECT_MAX_BYTES = 50
Buffer.poolSize = 8192

/**
 * If `TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Note:
 *
 * - Implementation must support adding new properties to `Uint8Array` instances.
 *   Firefox 4-29 lacked support, fixed in Firefox 30+.
 *   See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *  - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *  - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *    incorrect length in some situations.
 *
 * We detect these buggy browsers and set `TYPED_ARRAY_SUPPORT` to `false` so they will
 * get the Object implementation, which is slower but will work correctly.
 */
var TYPED_ARRAY_SUPPORT = (function () {
  try {
    var buf = new ArrayBuffer(0)
    var arr = new Uint8Array(buf)
    arr.foo = function () { return 42 }
    return 42 === arr.foo() && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        new Uint8Array(1).subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
})()

/**
 * Class: Buffer
 * =============
 *
 * The Buffer constructor returns instances of `Uint8Array` that are augmented
 * with function properties for all the node `Buffer` API functions. We use
 * `Uint8Array` so that square bracket notation works as expected -- it returns
 * a single octet.
 *
 * By augmenting the instances, we can avoid modifying the `Uint8Array`
 * prototype.
 */
function Buffer (subject, encoding, noZero) {
  if (!(this instanceof Buffer))
    return new Buffer(subject, encoding, noZero)

  var type = typeof subject

  // Find the length
  var length
  if (type === 'number')
    length = subject > 0 ? subject >>> 0 : 0
  else if (type === 'string') {
    if (encoding === 'base64')
      subject = base64clean(subject)
    length = Buffer.byteLength(subject, encoding)
  } else if (type === 'object' && subject !== null) { // assume object is array-like
    if (subject.type === 'Buffer' && isArray(subject.data))
      subject = subject.data
    length = +subject.length > 0 ? Math.floor(+subject.length) : 0
  } else
    throw new Error('First argument needs to be a number, array or string.')

  var buf
  if (TYPED_ARRAY_SUPPORT) {
    // Preferred: Return an augmented `Uint8Array` instance for best performance
    buf = Buffer._augment(new Uint8Array(length))
  } else {
    // Fallback: Return THIS instance of Buffer (created by `new`)
    buf = this
    buf.length = length
    buf._isBuffer = true
  }

  var i
  if (TYPED_ARRAY_SUPPORT && typeof subject.byteLength === 'number') {
    // Speed optimization -- use set if we're copying from a typed array
    buf._set(subject)
  } else if (isArrayish(subject)) {
    // Treat array-ish objects as a byte array
    if (Buffer.isBuffer(subject)) {
      for (i = 0; i < length; i++)
        buf[i] = subject.readUInt8(i)
    } else {
      for (i = 0; i < length; i++)
        buf[i] = ((subject[i] % 256) + 256) % 256
    }
  } else if (type === 'string') {
    buf.write(subject, 0, encoding)
  } else if (type === 'number' && !TYPED_ARRAY_SUPPORT && !noZero) {
    for (i = 0; i < length; i++) {
      buf[i] = 0
    }
  }

  return buf
}

// STATIC METHODS
// ==============

Buffer.isEncoding = function (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'raw':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.isBuffer = function (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.byteLength = function (str, encoding) {
  var ret
  str = str.toString()
  switch (encoding || 'utf8') {
    case 'hex':
      ret = str.length / 2
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8ToBytes(str).length
      break
    case 'ascii':
    case 'binary':
    case 'raw':
      ret = str.length
      break
    case 'base64':
      ret = base64ToBytes(str).length
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = str.length * 2
      break
    default:
      throw new Error('Unknown encoding')
  }
  return ret
}

Buffer.concat = function (list, totalLength) {
  assert(isArray(list), 'Usage: Buffer.concat(list[, length])')

  if (list.length === 0) {
    return new Buffer(0)
  } else if (list.length === 1) {
    return list[0]
  }

  var i
  if (totalLength === undefined) {
    totalLength = 0
    for (i = 0; i < list.length; i++) {
      totalLength += list[i].length
    }
  }

  var buf = new Buffer(totalLength)
  var pos = 0
  for (i = 0; i < list.length; i++) {
    var item = list[i]
    item.copy(buf, pos)
    pos += item.length
  }
  return buf
}

Buffer.compare = function (a, b) {
  assert(Buffer.isBuffer(a) && Buffer.isBuffer(b), 'Arguments must be Buffers')
  var x = a.length
  var y = b.length
  for (var i = 0, len = Math.min(x, y); i < len && a[i] === b[i]; i++) {}
  if (i !== len) {
    x = a[i]
    y = b[i]
  }
  if (x < y) {
    return -1
  }
  if (y < x) {
    return 1
  }
  return 0
}

// BUFFER INSTANCE METHODS
// =======================

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  assert(strLen % 2 === 0, 'Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; i++) {
    var byte = parseInt(string.substr(i * 2, 2), 16)
    assert(!isNaN(byte), 'Invalid hex string')
    buf[offset + i] = byte
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  var charsWritten = blitBuffer(utf8ToBytes(string), buf, offset, length)
  return charsWritten
}

function asciiWrite (buf, string, offset, length) {
  var charsWritten = blitBuffer(asciiToBytes(string), buf, offset, length)
  return charsWritten
}

function binaryWrite (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  var charsWritten = blitBuffer(base64ToBytes(string), buf, offset, length)
  return charsWritten
}

function utf16leWrite (buf, string, offset, length) {
  var charsWritten = blitBuffer(utf16leToBytes(string), buf, offset, length)
  return charsWritten
}

Buffer.prototype.write = function (string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length
      length = undefined
    }
  } else {  // legacy
    var swap = encoding
    encoding = offset
    offset = length
    length = swap
  }

  offset = Number(offset) || 0
  var remaining = this.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase()

  var ret
  switch (encoding) {
    case 'hex':
      ret = hexWrite(this, string, offset, length)
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8Write(this, string, offset, length)
      break
    case 'ascii':
      ret = asciiWrite(this, string, offset, length)
      break
    case 'binary':
      ret = binaryWrite(this, string, offset, length)
      break
    case 'base64':
      ret = base64Write(this, string, offset, length)
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = utf16leWrite(this, string, offset, length)
      break
    default:
      throw new Error('Unknown encoding')
  }
  return ret
}

Buffer.prototype.toString = function (encoding, start, end) {
  var self = this

  encoding = String(encoding || 'utf8').toLowerCase()
  start = Number(start) || 0
  end = (end === undefined) ? self.length : Number(end)

  // Fastpath empty strings
  if (end === start)
    return ''

  var ret
  switch (encoding) {
    case 'hex':
      ret = hexSlice(self, start, end)
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8Slice(self, start, end)
      break
    case 'ascii':
      ret = asciiSlice(self, start, end)
      break
    case 'binary':
      ret = binarySlice(self, start, end)
      break
    case 'base64':
      ret = base64Slice(self, start, end)
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = utf16leSlice(self, start, end)
      break
    default:
      throw new Error('Unknown encoding')
  }
  return ret
}

Buffer.prototype.toJSON = function () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

Buffer.prototype.equals = function (b) {
  assert(Buffer.isBuffer(b), 'Argument must be a Buffer')
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.compare = function (b) {
  assert(Buffer.isBuffer(b), 'Argument must be a Buffer')
  return Buffer.compare(this, b)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function (target, target_start, start, end) {
  var source = this

  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (!target_start) target_start = 0

  // Copy 0 bytes; we're done
  if (end === start) return
  if (target.length === 0 || source.length === 0) return

  // Fatal error conditions
  assert(end >= start, 'sourceEnd < sourceStart')
  assert(target_start >= 0 && target_start < target.length,
      'targetStart out of bounds')
  assert(start >= 0 && start < source.length, 'sourceStart out of bounds')
  assert(end >= 0 && end <= source.length, 'sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length)
    end = this.length
  if (target.length - target_start < end - start)
    end = target.length - target_start + start

  var len = end - start

  if (len < 100 || !TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < len; i++) {
      target[i + target_start] = this[i + start]
    }
  } else {
    target._set(this.subarray(start, start + len), target_start)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  var res = ''
  var tmp = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    if (buf[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i])
      tmp = ''
    } else {
      tmp += '%' + buf[i].toString(16)
    }
  }

  return res + decodeUtf8Char(tmp)
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function binarySlice (buf, start, end) {
  return asciiSlice(buf, start, end)
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; i++) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len;
    if (start < 0)
      start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0)
      end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start)
    end = start

  if (TYPED_ARRAY_SUPPORT) {
    return Buffer._augment(this.subarray(start, end))
  } else {
    var sliceLen = end - start
    var newBuf = new Buffer(sliceLen, undefined, true)
    for (var i = 0; i < sliceLen; i++) {
      newBuf[i] = this[i + start]
    }
    return newBuf
  }
}

// `get` will be removed in Node 0.13+
Buffer.prototype.get = function (offset) {
  console.log('.get() is deprecated. Access using array indexes instead.')
  return this.readUInt8(offset)
}

// `set` will be removed in Node 0.13+
Buffer.prototype.set = function (v, offset) {
  console.log('.set() is deprecated. Access using array indexes instead.')
  return this.writeUInt8(v, offset)
}

Buffer.prototype.readUInt8 = function (offset, noAssert) {
  if (!noAssert) {
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < this.length, 'Trying to read beyond buffer length')
  }

  if (offset >= this.length)
    return

  return this[offset]
}

function readUInt16 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val
  if (littleEndian) {
    val = buf[offset]
    if (offset + 1 < len)
      val |= buf[offset + 1] << 8
  } else {
    val = buf[offset] << 8
    if (offset + 1 < len)
      val |= buf[offset + 1]
  }
  return val
}

Buffer.prototype.readUInt16LE = function (offset, noAssert) {
  return readUInt16(this, offset, true, noAssert)
}

Buffer.prototype.readUInt16BE = function (offset, noAssert) {
  return readUInt16(this, offset, false, noAssert)
}

function readUInt32 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val
  if (littleEndian) {
    if (offset + 2 < len)
      val = buf[offset + 2] << 16
    if (offset + 1 < len)
      val |= buf[offset + 1] << 8
    val |= buf[offset]
    if (offset + 3 < len)
      val = val + (buf[offset + 3] << 24 >>> 0)
  } else {
    if (offset + 1 < len)
      val = buf[offset + 1] << 16
    if (offset + 2 < len)
      val |= buf[offset + 2] << 8
    if (offset + 3 < len)
      val |= buf[offset + 3]
    val = val + (buf[offset] << 24 >>> 0)
  }
  return val
}

Buffer.prototype.readUInt32LE = function (offset, noAssert) {
  return readUInt32(this, offset, true, noAssert)
}

Buffer.prototype.readUInt32BE = function (offset, noAssert) {
  return readUInt32(this, offset, false, noAssert)
}

Buffer.prototype.readInt8 = function (offset, noAssert) {
  if (!noAssert) {
    assert(offset !== undefined && offset !== null,
        'missing offset')
    assert(offset < this.length, 'Trying to read beyond buffer length')
  }

  if (offset >= this.length)
    return

  var neg = this[offset] & 0x80
  if (neg)
    return (0xff - this[offset] + 1) * -1
  else
    return this[offset]
}

function readInt16 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val = readUInt16(buf, offset, littleEndian, true)
  var neg = val & 0x8000
  if (neg)
    return (0xffff - val + 1) * -1
  else
    return val
}

Buffer.prototype.readInt16LE = function (offset, noAssert) {
  return readInt16(this, offset, true, noAssert)
}

Buffer.prototype.readInt16BE = function (offset, noAssert) {
  return readInt16(this, offset, false, noAssert)
}

function readInt32 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val = readUInt32(buf, offset, littleEndian, true)
  var neg = val & 0x80000000
  if (neg)
    return (0xffffffff - val + 1) * -1
  else
    return val
}

Buffer.prototype.readInt32LE = function (offset, noAssert) {
  return readInt32(this, offset, true, noAssert)
}

Buffer.prototype.readInt32BE = function (offset, noAssert) {
  return readInt32(this, offset, false, noAssert)
}

function readFloat (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  return ieee754.read(buf, offset, littleEndian, 23, 4)
}

Buffer.prototype.readFloatLE = function (offset, noAssert) {
  return readFloat(this, offset, true, noAssert)
}

Buffer.prototype.readFloatBE = function (offset, noAssert) {
  return readFloat(this, offset, false, noAssert)
}

function readDouble (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset + 7 < buf.length, 'Trying to read beyond buffer length')
  }

  return ieee754.read(buf, offset, littleEndian, 52, 8)
}

Buffer.prototype.readDoubleLE = function (offset, noAssert) {
  return readDouble(this, offset, true, noAssert)
}

Buffer.prototype.readDoubleBE = function (offset, noAssert) {
  return readDouble(this, offset, false, noAssert)
}

Buffer.prototype.writeUInt8 = function (value, offset, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < this.length, 'trying to write beyond buffer length')
    verifuint(value, 0xff)
  }

  if (offset >= this.length) return

  this[offset] = value
  return offset + 1
}

function writeUInt16 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'trying to write beyond buffer length')
    verifuint(value, 0xffff)
  }

  var len = buf.length
  if (offset >= len)
    return

  for (var i = 0, j = Math.min(len - offset, 2); i < j; i++) {
    buf[offset + i] =
        (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
            (littleEndian ? i : 1 - i) * 8
  }
  return offset + 2
}

Buffer.prototype.writeUInt16LE = function (value, offset, noAssert) {
  return writeUInt16(this, value, offset, true, noAssert)
}

Buffer.prototype.writeUInt16BE = function (value, offset, noAssert) {
  return writeUInt16(this, value, offset, false, noAssert)
}

function writeUInt32 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'trying to write beyond buffer length')
    verifuint(value, 0xffffffff)
  }

  var len = buf.length
  if (offset >= len)
    return

  for (var i = 0, j = Math.min(len - offset, 4); i < j; i++) {
    buf[offset + i] =
        (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
  return offset + 4
}

Buffer.prototype.writeUInt32LE = function (value, offset, noAssert) {
  return writeUInt32(this, value, offset, true, noAssert)
}

Buffer.prototype.writeUInt32BE = function (value, offset, noAssert) {
  return writeUInt32(this, value, offset, false, noAssert)
}

Buffer.prototype.writeInt8 = function (value, offset, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < this.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7f, -0x80)
  }

  if (offset >= this.length)
    return

  if (value >= 0)
    this.writeUInt8(value, offset, noAssert)
  else
    this.writeUInt8(0xff + value + 1, offset, noAssert)
  return offset + 1
}

function writeInt16 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7fff, -0x8000)
  }

  var len = buf.length
  if (offset >= len)
    return

  if (value >= 0)
    writeUInt16(buf, value, offset, littleEndian, noAssert)
  else
    writeUInt16(buf, 0xffff + value + 1, offset, littleEndian, noAssert)
  return offset + 2
}

Buffer.prototype.writeInt16LE = function (value, offset, noAssert) {
  return writeInt16(this, value, offset, true, noAssert)
}

Buffer.prototype.writeInt16BE = function (value, offset, noAssert) {
  return writeInt16(this, value, offset, false, noAssert)
}

function writeInt32 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7fffffff, -0x80000000)
  }

  var len = buf.length
  if (offset >= len)
    return

  if (value >= 0)
    writeUInt32(buf, value, offset, littleEndian, noAssert)
  else
    writeUInt32(buf, 0xffffffff + value + 1, offset, littleEndian, noAssert)
  return offset + 4
}

Buffer.prototype.writeInt32LE = function (value, offset, noAssert) {
  return writeInt32(this, value, offset, true, noAssert)
}

Buffer.prototype.writeInt32BE = function (value, offset, noAssert) {
  return writeInt32(this, value, offset, false, noAssert)
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to write beyond buffer length')
    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }

  var len = buf.length
  if (offset >= len)
    return

  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 7 < buf.length,
        'Trying to write beyond buffer length')
    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }

  var len = buf.length
  if (offset >= len)
    return

  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function (value, start, end) {
  if (!value) value = 0
  if (!start) start = 0
  if (!end) end = this.length

  assert(end >= start, 'end < start')

  // Fill 0 bytes; we're done
  if (end === start) return
  if (this.length === 0) return

  assert(start >= 0 && start < this.length, 'start out of bounds')
  assert(end >= 0 && end <= this.length, 'end out of bounds')

  var i
  if (typeof value === 'number') {
    for (i = start; i < end; i++) {
      this[i] = value
    }
  } else {
    var bytes = utf8ToBytes(value.toString())
    var len = bytes.length
    for (i = start; i < end; i++) {
      this[i] = bytes[i % len]
    }
  }

  return this
}

Buffer.prototype.inspect = function () {
  var out = []
  var len = this.length
  for (var i = 0; i < len; i++) {
    out[i] = toHex(this[i])
    if (i === exports.INSPECT_MAX_BYTES) {
      out[i + 1] = '...'
      break
    }
  }
  return '<Buffer ' + out.join(' ') + '>'
}

/**
 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
 */
Buffer.prototype.toArrayBuffer = function () {
  if (typeof Uint8Array !== 'undefined') {
    if (TYPED_ARRAY_SUPPORT) {
      return (new Buffer(this)).buffer
    } else {
      var buf = new Uint8Array(this.length)
      for (var i = 0, len = buf.length; i < len; i += 1) {
        buf[i] = this[i]
      }
      return buf.buffer
    }
  } else {
    throw new Error('Buffer.toArrayBuffer not supported in this browser')
  }
}

// HELPER FUNCTIONS
// ================

var BP = Buffer.prototype

/**
 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
 */
Buffer._augment = function (arr) {
  arr._isBuffer = true

  // save reference to original Uint8Array get/set methods before overwriting
  arr._get = arr.get
  arr._set = arr.set

  // deprecated, will be removed in node 0.13+
  arr.get = BP.get
  arr.set = BP.set

  arr.write = BP.write
  arr.toString = BP.toString
  arr.toLocaleString = BP.toString
  arr.toJSON = BP.toJSON
  arr.equals = BP.equals
  arr.compare = BP.compare
  arr.copy = BP.copy
  arr.slice = BP.slice
  arr.readUInt8 = BP.readUInt8
  arr.readUInt16LE = BP.readUInt16LE
  arr.readUInt16BE = BP.readUInt16BE
  arr.readUInt32LE = BP.readUInt32LE
  arr.readUInt32BE = BP.readUInt32BE
  arr.readInt8 = BP.readInt8
  arr.readInt16LE = BP.readInt16LE
  arr.readInt16BE = BP.readInt16BE
  arr.readInt32LE = BP.readInt32LE
  arr.readInt32BE = BP.readInt32BE
  arr.readFloatLE = BP.readFloatLE
  arr.readFloatBE = BP.readFloatBE
  arr.readDoubleLE = BP.readDoubleLE
  arr.readDoubleBE = BP.readDoubleBE
  arr.writeUInt8 = BP.writeUInt8
  arr.writeUInt16LE = BP.writeUInt16LE
  arr.writeUInt16BE = BP.writeUInt16BE
  arr.writeUInt32LE = BP.writeUInt32LE
  arr.writeUInt32BE = BP.writeUInt32BE
  arr.writeInt8 = BP.writeInt8
  arr.writeInt16LE = BP.writeInt16LE
  arr.writeInt16BE = BP.writeInt16BE
  arr.writeInt32LE = BP.writeInt32LE
  arr.writeInt32BE = BP.writeInt32BE
  arr.writeFloatLE = BP.writeFloatLE
  arr.writeFloatBE = BP.writeFloatBE
  arr.writeDoubleLE = BP.writeDoubleLE
  arr.writeDoubleBE = BP.writeDoubleBE
  arr.fill = BP.fill
  arr.inspect = BP.inspect
  arr.toArrayBuffer = BP.toArrayBuffer

  return arr
}

var INVALID_BASE64_RE = /[^+\/0-9A-z]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function isArray (subject) {
  return (Array.isArray || function (subject) {
    return Object.prototype.toString.call(subject) === '[object Array]'
  })(subject)
}

function isArrayish (subject) {
  return isArray(subject) || Buffer.isBuffer(subject) ||
      subject && typeof subject === 'object' &&
      typeof subject.length === 'number'
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    var b = str.charCodeAt(i)
    if (b <= 0x7F) {
      byteArray.push(b)
    } else {
      var start = i
      if (b >= 0xD800 && b <= 0xDFFF) i++
      var h = encodeURIComponent(str.slice(start, i+1)).substr(1).split('%')
      for (var j = 0; j < h.length; j++) {
        byteArray.push(parseInt(h[j], 16))
      }
    }
  }
  return byteArray
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(str)
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; i++) {
    if ((i + offset >= dst.length) || (i >= src.length))
      break
    dst[i + offset] = src[i]
  }
  return i
}

function decodeUtf8Char (str) {
  try {
    return decodeURIComponent(str)
  } catch (err) {
    return String.fromCharCode(0xFFFD) // UTF 8 invalid char
  }
}

/*
 * We have to make sure that the value is a valid integer. This means that it
 * is non-negative. It has no fractional component and that it does not
 * exceed the maximum allowed value.
 */
function verifuint (value, max) {
  assert(typeof value === 'number', 'cannot write a non-number as a number')
  assert(value >= 0, 'specified a negative value for writing an unsigned value')
  assert(value <= max, 'value is larger than maximum value for type')
  assert(Math.floor(value) === value, 'value has a fractional component')
}

function verifsint (value, max, min) {
  assert(typeof value === 'number', 'cannot write a non-number as a number')
  assert(value <= max, 'value larger than maximum allowed value')
  assert(value >= min, 'value smaller than minimum allowed value')
  assert(Math.floor(value) === value, 'value has a fractional component')
}

function verifIEEE754 (value, max, min) {
  assert(typeof value === 'number', 'cannot write a non-number as a number')
  assert(value <= max, 'value larger than maximum allowed value')
  assert(value >= min, 'value smaller than minimum allowed value')
}

function assert (test, message) {
  if (!test) throw new Error(message || 'Failed assertion')
}

},{"base64-js":48,"ieee754":49}],48:[function(require,module,exports){
var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

;(function (exports) {
	'use strict';

  var Arr = (typeof Uint8Array !== 'undefined')
    ? Uint8Array
    : Array

	var PLUS   = '+'.charCodeAt(0)
	var SLASH  = '/'.charCodeAt(0)
	var NUMBER = '0'.charCodeAt(0)
	var LOWER  = 'a'.charCodeAt(0)
	var UPPER  = 'A'.charCodeAt(0)

	function decode (elt) {
		var code = elt.charCodeAt(0)
		if (code === PLUS)
			return 62 // '+'
		if (code === SLASH)
			return 63 // '/'
		if (code < NUMBER)
			return -1 //no match
		if (code < NUMBER + 10)
			return code - NUMBER + 26 + 26
		if (code < UPPER + 26)
			return code - UPPER
		if (code < LOWER + 26)
			return code - LOWER + 26
	}

	function b64ToByteArray (b64) {
		var i, j, l, tmp, placeHolders, arr

		if (b64.length % 4 > 0) {
			throw new Error('Invalid string. Length must be a multiple of 4')
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		var len = b64.length
		placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

		// base64 is 4/3 + up to two characters of the original data
		arr = new Arr(b64.length * 3 / 4 - placeHolders)

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length

		var L = 0

		function push (v) {
			arr[L++] = v
		}

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
			push((tmp & 0xFF0000) >> 16)
			push((tmp & 0xFF00) >> 8)
			push(tmp & 0xFF)
		}

		if (placeHolders === 2) {
			tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
			push(tmp & 0xFF)
		} else if (placeHolders === 1) {
			tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
			push((tmp >> 8) & 0xFF)
			push(tmp & 0xFF)
		}

		return arr
	}

	function uint8ToBase64 (uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length

		function encode (num) {
			return lookup.charAt(num)
		}

		function tripletToBase64 (num) {
			return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
		}

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
			output += tripletToBase64(temp)
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1]
				output += encode(temp >> 2)
				output += encode((temp << 4) & 0x3F)
				output += '=='
				break
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
				output += encode(temp >> 10)
				output += encode((temp >> 4) & 0x3F)
				output += encode((temp << 2) & 0x3F)
				output += '='
				break
		}

		return output
	}

	exports.toByteArray = b64ToByteArray
	exports.fromByteArray = uint8ToBase64
}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))

},{}],49:[function(require,module,exports){
exports.read = function(buffer, offset, isLE, mLen, nBytes) {
  var e, m,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      nBits = -7,
      i = isLE ? (nBytes - 1) : 0,
      d = isLE ? -1 : 1,
      s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity);
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
      i = isLE ? 0 : (nBytes - 1),
      d = isLE ? 1 : -1,
      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);

  buffer[offset + i - d] |= s * 128;
};

},{}],50:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this,require("+NscNm"))
},{"+NscNm":51}],51:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            var source = ev.source;
            if ((source === window || source === null) && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}],52:[function(require,module,exports){
/*
 Copyright 2013 Daniel Wirtz <dcode@dcode.io>

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 */

/**
 * @license ProtoBuf.js (c) 2013 Daniel Wirtz <dcode@dcode.io>
 * Released under the Apache License, Version 2.0
 * see: https://github.com/dcodeIO/ProtoBuf.js for details
 */
(function(global) {
    "use strict";

    function init(ByteBuffer) {

        /**
         * The ProtoBuf namespace.
         * @exports ProtoBuf
         * @namespace
         * @expose
         */
        var ProtoBuf = {};

        /**
         * ProtoBuf.js version.
         * @type {string}
         * @const
         * @expose
         */
        ProtoBuf.VERSION = "3.2.1";

        /**
         * Wire types.
         * @type {Object.<string,number>}
         * @const
         * @expose
         */
        ProtoBuf.WIRE_TYPES = {};

        /**
         * Varint wire type.
         * @type {number}
         * @expose
         */
        ProtoBuf.WIRE_TYPES.VARINT = 0;

        /**
         * Fixed 64 bits wire type.
         * @type {number}
         * @const
         * @expose
         */
        ProtoBuf.WIRE_TYPES.BITS64 = 1;

        /**
         * Length delimited wire type.
         * @type {number}
         * @const
         * @expose
         */
        ProtoBuf.WIRE_TYPES.LDELIM = 2;

        /**
         * Start group wire type.
         * @type {number}
         * @const
         * @expose
         */
        ProtoBuf.WIRE_TYPES.STARTGROUP = 3;

        /**
         * End group wire type.
         * @type {number}
         * @const
         * @expose
         */
        ProtoBuf.WIRE_TYPES.ENDGROUP = 4;

        /**
         * Fixed 32 bits wire type.
         * @type {number}
         * @const
         * @expose
         */
        ProtoBuf.WIRE_TYPES.BITS32 = 5;

        /**
         * Packable wire types.
         * @type {!Array.<number>}
         * @const
         * @expose
         */
        ProtoBuf.PACKABLE_WIRE_TYPES = [
            ProtoBuf.WIRE_TYPES.VARINT,
            ProtoBuf.WIRE_TYPES.BITS64,
            ProtoBuf.WIRE_TYPES.BITS32
        ];

        /**
         * Types.
         * @dict
         * @type {Object.<string,{name: string, wireType: number}>}
         * @const
         * @expose
         */
        ProtoBuf.TYPES = {
            // According to the protobuf spec.
            "int32": {
                name: "int32",
                wireType: ProtoBuf.WIRE_TYPES.VARINT
            },
            "uint32": {
                name: "uint32",
                wireType: ProtoBuf.WIRE_TYPES.VARINT
            },
            "sint32": {
                name: "sint32",
                wireType: ProtoBuf.WIRE_TYPES.VARINT
            },
            "int64": {
                name: "int64",
                wireType: ProtoBuf.WIRE_TYPES.VARINT
            },
            "uint64": {
                name: "uint64",
                wireType: ProtoBuf.WIRE_TYPES.VARINT
            },
            "sint64": {
                name: "sint64",
                wireType: ProtoBuf.WIRE_TYPES.VARINT
            },
            "bool": {
                name: "bool",
                wireType: ProtoBuf.WIRE_TYPES.VARINT
            },
            "double": {
                name: "double",
                wireType: ProtoBuf.WIRE_TYPES.BITS64
            },
            "string": {
                name: "string",
                wireType: ProtoBuf.WIRE_TYPES.LDELIM
            },
            "bytes": {
                name: "bytes",
                wireType: ProtoBuf.WIRE_TYPES.LDELIM
            },
            "fixed32": {
                name: "fixed32",
                wireType: ProtoBuf.WIRE_TYPES.BITS32
            },
            "sfixed32": {
                name: "sfixed32",
                wireType: ProtoBuf.WIRE_TYPES.BITS32
            },
            "fixed64": {
                name: "fixed64",
                wireType: ProtoBuf.WIRE_TYPES.BITS64
            },
            "sfixed64": {
                name: "sfixed64",
                wireType: ProtoBuf.WIRE_TYPES.BITS64
            },
            "float": {
                name: "float",
                wireType: ProtoBuf.WIRE_TYPES.BITS32
            },
            "enum": {
                name: "enum",
                wireType: ProtoBuf.WIRE_TYPES.VARINT
            },
            "message": {
                name: "message",
                wireType: ProtoBuf.WIRE_TYPES.LDELIM
            },
            "group": {
                name: "group",
                wireType: ProtoBuf.WIRE_TYPES.STARTGROUP
            }
        };

        /**
         * Minimum field id.
         * @type {number}
         * @const
         * @expose
         */
        ProtoBuf.ID_MIN = 1;

        /**
         * Maximum field id.
         * @type {number}
         * @const
         * @expose
         */
        ProtoBuf.ID_MAX = 0x1FFFFFFF;

        /**
         * @type {!function(new: ByteBuffer, ...[*])}
         * @expose
         */
        ProtoBuf.ByteBuffer = ByteBuffer;

        /**
         * @type {?function(new: Long, ...[*])}
         * @expose
         */
        ProtoBuf.Long = ByteBuffer.Long || null;

        /**
         * If set to `true`, field names will be converted from underscore notation to camel case. Defaults to `false`.
         *  Must be set prior to parsing.
         * @type {boolean}
         * @expose
         */
        ProtoBuf.convertFieldsToCamelCase = false;

        /**
         * @alias ProtoBuf.Util
         * @expose
         */
        ProtoBuf.Util = (function() {
            "use strict";

            // Object.create polyfill
            // ref: https://developer.mozilla.org/de/docs/JavaScript/Reference/Global_Objects/Object/create
            if (!Object.create)
                /** @expose */
                Object.create = function (o) {
                    if (arguments.length > 1)
                        throw Error('Object.create polyfill only accepts the first parameter.');
                    function F() {}
                    F.prototype = o;
                    return new F();
                };

            /**
             * ProtoBuf utilities.
             * @exports ProtoBuf.Util
             * @namespace
             */
            var Util = {};

            /**
             * Flag if running in node (fs is available) or not.
             * @type {boolean}
             * @const
             * @expose
             */
            Util.IS_NODE = false;
            try {
                // There is no reliable way to detect node.js as an environment, so our
                // best bet is to feature-detect what we actually need.
                Util.IS_NODE =
                    typeof require === 'function' &&
                    typeof require("fs").readFileSync === 'function' &&
                    typeof require("path").resolve === 'function';
            } catch (e) {}

            /**
             * Constructs a XMLHttpRequest object.
             * @return {XMLHttpRequest}
             * @throws {Error} If XMLHttpRequest is not supported
             * @expose
             */
            Util.XHR = function() {
                // No dependencies please, ref: http://www.quirksmode.org/js/xmlhttp.html
                var XMLHttpFactories = [
                    function () {return new XMLHttpRequest()},
                    function () {return new ActiveXObject("Msxml2.XMLHTTP")},
                    function () {return new ActiveXObject("Msxml3.XMLHTTP")},
                    function () {return new ActiveXObject("Microsoft.XMLHTTP")}
                ];
                /** @type {?XMLHttpRequest} */
                var xhr = null;
                for (var i=0;i<XMLHttpFactories.length;i++) {
                    try { xhr = XMLHttpFactories[i](); }
                    catch (e) { continue; }
                    break;
                }
                if (!xhr)
                    throw Error("XMLHttpRequest is not supported");
                return xhr;
            };

            /**
             * Fetches a resource.
             * @param {string} path Resource path
             * @param {function(?string)=} callback Callback receiving the resource's contents. If omitted the resource will
             *   be fetched synchronously. If the request failed, contents will be null.
             * @return {?string|undefined} Resource contents if callback is omitted (null if the request failed), else undefined.
             * @expose
             */
            Util.fetch = function(path, callback) {
                if (callback && typeof callback != 'function')
                    callback = null;
                if (Util.IS_NODE) {
                    if (callback) {
                        require("fs").readFile(path, function(err, data) {
                            if (err)
                                callback(null);
                            else
                                callback(""+data);
                        });
                    } else
                        try {
                            return require("fs").readFileSync(path);
                        } catch (e) {
                            return null;
                        }
                } else {
                    var xhr = Util.XHR();
                    xhr.open('GET', path, callback ? true : false);
                    // xhr.setRequestHeader('User-Agent', 'XMLHTTP/1.0');
                    xhr.setRequestHeader('Accept', 'text/plain');
                    if (typeof xhr.overrideMimeType === 'function') xhr.overrideMimeType('text/plain');
                    if (callback) {
                        xhr.onreadystatechange = function() {
                            if (xhr.readyState != 4) return;
                            if (/* remote */ xhr.status == 200 || /* local */ (xhr.status == 0 && typeof xhr.responseText === 'string'))
                                callback(xhr.responseText);
                            else
                                callback(null);
                        };
                        if (xhr.readyState == 4)
                            return;
                        xhr.send(null);
                    } else {
                        xhr.send(null);
                        if (/* remote */ xhr.status == 200 || /* local */ (xhr.status == 0 && typeof xhr.responseText === 'string'))
                            return xhr.responseText;
                        return null;
                    }
                }
            };

            /**
             * Tests if an object is an array.
             * @function
             * @param {*} obj Object to test
             * @returns {boolean} true if it is an array, else false
             * @expose
             */
            Util.isArray = Array.isArray || function(obj) {
                return Object.prototype.toString.call(obj) === "[object Array]";
            };

            return Util;
        })();

        /**
         * Language expressions.
         * @exports ProtoBuf.Lang
         * @type {Object.<string,string|RegExp>}
         * @namespace
         * @expose
         */
        ProtoBuf.Lang = {
            OPEN: "{",
            CLOSE: "}",
            OPTOPEN: "[",
            OPTCLOSE: "]",
            OPTEND: ",",
            EQUAL: "=",
            END: ";",
            STRINGOPEN: '"',
            STRINGCLOSE: '"',
            STRINGOPEN_SQ: "'",
            STRINGCLOSE_SQ: "'",
            COPTOPEN: '(',
            COPTCLOSE: ')',
            DELIM: /[\s\{\}=;\[\],'"\(\)]/g,
            // KEYWORD: /^(?:package|option|import|message|enum|extend|service|syntax|extensions|group)$/,
            RULE: /^(?:required|optional|repeated)$/,
            TYPE: /^(?:double|float|int32|uint32|sint32|int64|uint64|sint64|fixed32|sfixed32|fixed64|sfixed64|bool|string|bytes)$/,
            NAME: /^[a-zA-Z_][a-zA-Z_0-9]*$/,
            TYPEDEF: /^[a-zA-Z][a-zA-Z_0-9]*$/,
            TYPEREF: /^(?:\.?[a-zA-Z_][a-zA-Z_0-9]*)+$/,
            FQTYPEREF: /^(?:\.[a-zA-Z][a-zA-Z_0-9]*)+$/,
            NUMBER: /^-?(?:[1-9][0-9]*|0|0x[0-9a-fA-F]+|0[0-7]+|([0-9]*\.[0-9]+([Ee][+-]?[0-9]+)?))$/,
            NUMBER_DEC: /^(?:[1-9][0-9]*|0)$/,
            NUMBER_HEX: /^0x[0-9a-fA-F]+$/,
            NUMBER_OCT: /^0[0-7]+$/,
            NUMBER_FLT: /^[0-9]*\.[0-9]+([Ee][+-]?[0-9]+)?$/,
            ID: /^(?:[1-9][0-9]*|0|0x[0-9a-fA-F]+|0[0-7]+)$/,
            NEGID: /^\-?(?:[1-9][0-9]*|0|0x[0-9a-fA-F]+|0[0-7]+)$/,
            WHITESPACE: /\s/,
            STRING: /['"]([^'"\\]*(\\.[^"\\]*)*)['"]/g,
            BOOL: /^(?:true|false)$/i
        };

        /**
         * @alias ProtoBuf.DotProto
         * @expose
         */
        ProtoBuf.DotProto = (function(ProtoBuf, Lang) {
            "use strict";

            /**
             * Utilities to parse .proto files.
             * @exports ProtoBuf.DotProto
             * @namespace
             */
            var DotProto = {};

            /**
             * Constructs a new Tokenizer.
             * @exports ProtoBuf.DotProto.Tokenizer
             * @class proto tokenizer
             * @param {string} proto Proto to tokenize
             * @constructor
             */
            var Tokenizer = function(proto) {

                /**
                 * Source to parse.
                 * @type {string}
                 * @expose
                 */
                this.source = ""+proto; // In case it's a buffer

                /**
                 * Current index.
                 * @type {number}
                 * @expose
                 */
                this.index = 0;

                /**
                 * Current line.
                 * @type {number}
                 * @expose
                 */
                this.line = 1;

                /**
                 * Stacked values.
                 * @type {Array}
                 * @expose
                 */
                this.stack = [];

                /**
                 * Whether currently reading a string or not.
                 * @type {boolean}
                 * @expose
                 */
                this.readingString = false;

                /**
                 * Whatever character ends the string. Either a single or double quote character.
                 * @type {string}
                 * @expose
                 */
                this.stringEndsWith = Lang.STRINGCLOSE;
            };

            /**
             * Reads a string beginning at the current index.
             * @return {string} The string
             * @throws {Error} If it's not a valid string
             * @private
             */
            Tokenizer.prototype._readString = function() {
                Lang.STRING.lastIndex = this.index-1; // Include the open quote
                var match;
                if ((match = Lang.STRING.exec(this.source)) !== null) {
                    var s = match[1];
                    this.index = Lang.STRING.lastIndex;
                    this.stack.push(this.stringEndsWith);
                    return s;
                }
                throw Error("Illegal string value at line "+this.line+", index "+this.index);
            };

            /**
             * Gets the next token and advances by one.
             * @return {?string} Token or `null` on EOF
             * @throws {Error} If it's not a valid proto file
             * @expose
             */
            Tokenizer.prototype.next = function() {
                if (this.stack.length > 0)
                    return this.stack.shift();
                if (this.index >= this.source.length)
                    return null; // No more tokens
                if (this.readingString) {
                    this.readingString = false;
                    return this._readString();
                }
                var repeat, last;
                do {
                    repeat = false;
                    // Strip white spaces
                    while (Lang.WHITESPACE.test(last = this.source.charAt(this.index))) {
                        this.index++;
                        if (last === "\n")
                            this.line++;
                        if (this.index === this.source.length)
                            return null;
                    }
                    // Strip comments
                    if (this.source.charAt(this.index) === '/') {
                        if (this.source.charAt(++this.index) === '/') { // Single line
                            while (this.source.charAt(this.index) !== "\n") {
                                this.index++;
                                if (this.index == this.source.length)
                                    return null;
                            }
                            this.index++;
                            this.line++;
                            repeat = true;
                        } else if (this.source.charAt(this.index) === '*') { /* Block */
                            last = '';
                            while (last+(last=this.source.charAt(this.index)) !== '*/') {
                                this.index++;
                                if (last === "\n")
                                    this.line++;
                                if (this.index === this.source.length)
                                    return null;
                            }
                            this.index++;
                            repeat = true;
                        } else
                            throw Error("Invalid comment at line "+this.line+": /"+this.source.charAt(this.index)+" ('/' or '*' expected)");
                    }
                } while (repeat);
                if (this.index === this.source.length) return null;

                // Read the next token
                var end = this.index;
                Lang.DELIM.lastIndex = 0;
                var delim = Lang.DELIM.test(this.source.charAt(end));
                if (!delim) {
                    ++end;
                    while(end < this.source.length && !Lang.DELIM.test(this.source.charAt(end)))
                        end++;
                } else
                    ++end;
                var token = this.source.substring(this.index, this.index = end);
                if (token === Lang.STRINGOPEN)
                    this.readingString = true,
                    this.stringEndsWith = Lang.STRINGCLOSE;
                else if (token === Lang.STRINGOPEN_SQ)
                    this.readingString = true,
                    this.stringEndsWith = Lang.STRINGCLOSE_SQ;
                return token;
            };

            /**
             * Peeks for the next token.
             * @return {?string} Token or `null` on EOF
             * @throws {Error} If it's not a valid proto file
             * @expose
             */
            Tokenizer.prototype.peek = function() {
                if (this.stack.length === 0) {
                    var token = this.next();
                    if (token === null)
                        return null;
                    this.stack.push(token);
                }
                return this.stack[0];
            };

            /**
             * Returns a string representation of this object.
             * @return {string} String representation as of "Tokenizer(index/length)"
             * @expose
             */
            Tokenizer.prototype.toString = function() {
                return "Tokenizer("+this.index+"/"+this.source.length+" at line "+this.line+")";
            };

            /**
             * @alias ProtoBuf.DotProto.Tokenizer
             * @expose
             */
            DotProto.Tokenizer = Tokenizer;

            /**
             * Constructs a new Parser.
             * @exports ProtoBuf.DotProto.Parser
             * @class proto parser
             * @param {string} proto Protocol source
             * @constructor
             */
            var Parser = function(proto) {

                /**
                 * Tokenizer.
                 * @type {ProtoBuf.DotProto.Tokenizer}
                 * @expose
                 */
                this.tn = new Tokenizer(proto);
            };

            /**
             * Runs the parser.
             * @return {{package: string|null, messages: Array.<object>, enums: Array.<object>, imports: Array.<string>, options: object<string,*>}}
             * @throws {Error} If the source cannot be parsed
             * @expose
             */
            Parser.prototype.parse = function() {
                var topLevel = {
                    "name": "[ROOT]", // temporary
                    "package": null,
                    "messages": [],
                    "enums": [],
                    "imports": [],
                    "options": {},
                    "services": []
                };
                var token, header = true;
                while(token = this.tn.next()) {
                    switch (token) {
                        case 'package':
                            if (!header || topLevel["package"] !== null)
                                throw Error("Illegal package at line "+this.tn.line);
                            topLevel["package"] = this._parsePackage(token);
                            break;
                        case 'import':
                            if (!header)
                                throw Error("Illegal import at line "+this.tn.line);
                            topLevel.imports.push(this._parseImport(token));
                            break;
                        case 'message':
                            this._parseMessage(topLevel, null, token);
                            header = false;
                            break;
                        case 'enum':
                            this._parseEnum(topLevel, token);
                            header = false;
                            break;
                        case 'option':
                            if (!header)
                                throw Error("Illegal option at line "+this.tn.line);
                            this._parseOption(topLevel, token);
                            break;
                        case 'service':
                            this._parseService(topLevel, token);
                            break;
                        case 'extend':
                            this._parseExtend(topLevel, token);
                            break;
                        case 'syntax':
                            this._parseIgnoredStatement(topLevel, token);
                            break;
                        default:
                            throw Error("Illegal token at line "+this.tn.line+": "+token);
                    }
                }
                delete topLevel["name"];
                return topLevel;
            };

            /**
             * Parses a number value.
             * @param {string} val Number value to parse
             * @return {number} Number
             * @throws {Error} If the number value is invalid
             * @private
             */
            Parser.prototype._parseNumber = function(val) {
                var sign = 1;
                if (val.charAt(0) == '-')
                    sign = -1,
                    val = val.substring(1);
                if (Lang.NUMBER_DEC.test(val))
                    return sign*parseInt(val, 10);
                else if (Lang.NUMBER_HEX.test(val))
                    return sign*parseInt(val.substring(2), 16);
                else if (Lang.NUMBER_OCT.test(val))
                    return sign*parseInt(val.substring(1), 8);
                else if (Lang.NUMBER_FLT.test(val))
                    return sign*parseFloat(val);
                throw Error("Illegal number at line "+this.tn.line+": "+(sign < 0 ? '-' : '')+val);
            };

            /**
             * Parses an ID value.
             * @param {string} val ID value to parse
             * @param {boolean=} neg Whether the ID may be negative, defaults to `false`
             * @returns {number} ID
             * @throws {Error} If the ID value is invalid
             * @private
             */
            Parser.prototype._parseId = function(val, neg) {
                var id = -1;
                var sign = 1;
                if (val.charAt(0) == '-')
                    sign = -1,
                    val = val.substring(1);
                if (Lang.NUMBER_DEC.test(val))
                    id = parseInt(val);
                else if (Lang.NUMBER_HEX.test(val))
                    id = parseInt(val.substring(2), 16);
                else if (Lang.NUMBER_OCT.test(val))
                    id = parseInt(val.substring(1), 8);
                else
                    throw Error("Illegal ID at line "+this.tn.line+": "+(sign < 0 ? '-' : '')+val);
                id = (sign*id)|0; // Force to 32bit
                if (!neg && id < 0)
                    throw Error("Illegal ID at line "+this.tn.line+": "+(sign < 0 ? '-' : '')+val);
                return id;
            };

            /**
             * Parses the package definition.
             * @param {string} token Initial token
             * @return {string} Package name
             * @throws {Error} If the package definition cannot be parsed
             * @private
             */
            Parser.prototype._parsePackage = function(token) {
                token = this.tn.next();
                if (!Lang.TYPEREF.test(token))
                    throw Error("Illegal package at line "+this.tn.line+": "+token);
                var pkg = token;
                token = this.tn.next();
                if (token != Lang.END)
                    throw Error("Illegal end of package at line "+this.tn.line+": "+token+" ('"+Lang.END+"' expected)");
                return pkg;
            };

            /**
             * Parses an import definition.
             * @param {string} token Initial token
             * @return {string} Import file name
             * @throws {Error} If the import definition cannot be parsed
             * @private
             */
            Parser.prototype._parseImport = function(token) {
                token = this.tn.next();
                if (token === "public")
                    token = this.tn.next();
                if (token !== Lang.STRINGOPEN && token !== Lang.STRINGOPEN_SQ)
                    throw Error("Illegal import at line "+this.tn.line+": "+token+" ('"+Lang.STRINGOPEN+"' or '"+Lang.STRINGOPEN_SQ+"' expected)");
                var imported = this.tn.next();
                token = this.tn.next();
                if (token !== this.tn.stringEndsWith)
                    throw Error("Illegal import at line "+this.tn.line+": "+token+" ('"+this.tn.stringEndsWith+"' expected)");
                token = this.tn.next();
                if (token !== Lang.END)
                    throw Error("Illegal import at line "+this.tn.line+": "+token+" ('"+Lang.END+"' expected)");
                return imported;
            };

            /**
             * Parses a namespace option.
             * @param {Object} parent Parent definition
             * @param {string} token Initial token
             * @throws {Error} If the option cannot be parsed
             * @private
             */
            Parser.prototype._parseOption = function(parent, token) {
                token = this.tn.next();
                var custom = false;
                if (token == Lang.COPTOPEN)
                    custom = true,
                    token = this.tn.next();
                if (!Lang.TYPEREF.test(token))
                    // we can allow options of the form google.protobuf.* since they will just get ignored anyways
                    if (!/google\.protobuf\./.test(token))
                        throw Error("Illegal option in message "+parent.name+" at line "+this.tn.line+": "+token);
                var name = token;
                token = this.tn.next();
                if (custom) { // (my_method_option).foo, (my_method_option), some_method_option, (foo.my_option).bar
                    if (token !== Lang.COPTCLOSE)
                        throw Error("Illegal option in message "+parent.name+", option "+name+" at line "+this.tn.line+": "+token+" ('"+Lang.COPTCLOSE+"' expected)");
                    name = '('+name+')';
                    token = this.tn.next();
                    if (Lang.FQTYPEREF.test(token))
                        name += token,
                        token = this.tn.next();
                }
                if (token !== Lang.EQUAL)
                    throw Error("Illegal option operator in message "+parent.name+", option "+name+" at line "+this.tn.line+": "+token+" ('"+Lang.EQUAL+"' expected)");
                var value;
                token = this.tn.next();
                if (token === Lang.STRINGOPEN || token === Lang.STRINGOPEN_SQ) {
                    value = this.tn.next();
                    token = this.tn.next();
                    if (token !== this.tn.stringEndsWith)
                        throw Error("Illegal end of option value in message "+parent.name+", option "+name+" at line "+this.tn.line+": "+token+" ('"+this.tn.stringEndsWith+"' expected)");
                } else {
                    if (Lang.NUMBER.test(token))
                        value = this._parseNumber(token, true);
                    else if (Lang.BOOL.test(token))
                        value = token === 'true';
                    else if (Lang.TYPEREF.test(token))
                        value = token;
                    else
                        throw Error("Illegal option value in message "+parent.name+", option "+name+" at line "+this.tn.line+": "+token);
                }
                token = this.tn.next();
                if (token !== Lang.END)
                    throw Error("Illegal end of option in message "+parent.name+", option "+name+" at line "+this.tn.line+": "+token+" ('"+Lang.END+"' expected)");
                parent["options"][name] = value;
            };

            /**
             * Parses an ignored statement of the form ['keyword', ..., ';'].
             * @param {Object} parent Parent definition
             * @param {string} keyword Initial token
             * @throws {Error} If the directive cannot be parsed
             * @private
             */
            Parser.prototype._parseIgnoredStatement = function(parent, keyword) {
                var token;
                do {
                    token = this.tn.next();
                    if (token === null)
                        throw Error("Unexpected EOF in "+parent.name+", "+keyword+" (ignored) at line "+this.tn.line);
                    if (token === Lang.END)
                        break;
                } while (true);
            };

            /**
             * Parses a service definition.
             * @param {Object} parent Parent definition
             * @param {string} token Initial token
             * @throws {Error} If the service cannot be parsed
             * @private
             */
            Parser.prototype._parseService = function(parent, token) {
                token = this.tn.next();
                if (!Lang.NAME.test(token))
                    throw Error("Illegal service name at line "+this.tn.line+": "+token);
                var name = token;
                var svc = {
                    "name": name,
                    "rpc": {},
                    "options": {}
                };
                token = this.tn.next();
                if (token !== Lang.OPEN)
                    throw Error("Illegal OPEN after service "+name+" at line "+this.tn.line+": "+token+" ('"+Lang.OPEN+"' expected)");
                do {
                    token = this.tn.next();
                    if (token === "option")
                        this._parseOption(svc, token);
                    else if (token === 'rpc')
                        this._parseServiceRPC(svc, token);
                    else if (token !== Lang.CLOSE)
                        throw Error("Illegal type for service "+name+" at line "+this.tn.line+": "+token);
                } while (token !== Lang.CLOSE);
                parent["services"].push(svc);
            };

            /**
             * Parses a RPC service definition of the form ['rpc', name, (request), 'returns', (response)].
             * @param {Object} svc Parent definition
             * @param {string} token Initial token
             * @private
             */
            Parser.prototype._parseServiceRPC = function(svc, token) {
                var type = token;
                token = this.tn.next();
                if (!Lang.NAME.test(token))
                    throw Error("Illegal RPC method name in service "+svc["name"]+" at line "+this.tn.line+": "+token);
                var name = token;
                var method = {
                    "request": null,
                    "response": null,
                    "options": {}
                };
                token = this.tn.next();
                if (token !== Lang.COPTOPEN)
                    throw Error("Illegal start of request type in RPC service "+svc["name"]+"#"+name+" at line "+this.tn.line+": "+token+" ('"+Lang.COPTOPEN+"' expected)");
                token = this.tn.next();
                if (!Lang.TYPEREF.test(token))
                    throw Error("Illegal request type in RPC service "+svc["name"]+"#"+name+" at line "+this.tn.line+": "+token);
                method["request"] = token;
                token = this.tn.next();
                if (token != Lang.COPTCLOSE)
                    throw Error("Illegal end of request type in RPC service "+svc["name"]+"#"+name+" at line "+this.tn.line+": "+token+" ('"+Lang.COPTCLOSE+"' expected)");
                token = this.tn.next();
                if (token.toLowerCase() !== "returns")
                    throw Error("Illegal request/response delimiter in RPC service "+svc["name"]+"#"+name+" at line "+this.tn.line+": "+token+" ('returns' expected)");
                token = this.tn.next();
                if (token != Lang.COPTOPEN)
                    throw Error("Illegal start of response type in RPC service "+svc["name"]+"#"+name+" at line "+this.tn.line+": "+token+" ('"+Lang.COPTOPEN+"' expected)");
                token = this.tn.next();
                method["response"] = token;
                token = this.tn.next();
                if (token !== Lang.COPTCLOSE)
                    throw Error("Illegal end of response type in RPC service "+svc["name"]+"#"+name+" at line "+this.tn.line+": "+token+" ('"+Lang.COPTCLOSE+"' expected)");
                token = this.tn.next();
                if (token === Lang.OPEN) {
                    do {
                        token = this.tn.next();
                        if (token === 'option')
                            this._parseOption(method, token); // <- will fail for the custom-options example
                        else if (token !== Lang.CLOSE)
                            throw Error("Illegal start of option in RPC service "+svc["name"]+"#"+name+" at line "+this.tn.line+": "+token+" ('option' expected)");
                    } while (token !== Lang.CLOSE);
                    if (this.tn.peek() === Lang.END)
                        this.tn.next();
                } else if (token !== Lang.END)
                    throw Error("Illegal method delimiter in RPC service "+svc["name"]+"#"+name+" at line "+this.tn.line+": "+token+" ('"+Lang.END+"' or '"+Lang.OPEN+"' expected)");
                if (typeof svc[type] === 'undefined')
                    svc[type] = {};
                svc[type][name] = method;
            };

            /**
             * Parses a message definition.
             * @param {Object} parent Parent definition
             * @param {Object} fld Field definition if this is a group, otherwise `null`
             * @param {string} token First token
             * @return {Object}
             * @throws {Error} If the message cannot be parsed
             * @private
             */
            Parser.prototype._parseMessage = function(parent, fld, token) {
                /** @dict */
                var msg = {}; // Note: At some point we might want to exclude the parser, so we need a dict.
                var isGroup = token === "group";
                token = this.tn.next();
                if (!Lang.NAME.test(token))
                    throw Error("Illegal "+(isGroup ? "group" : "message")+" name"+(parent ? " in message "+parent["name"] : "")+" at line "+this.tn.line+": "+token);
                msg["name"] = token;
                if (isGroup) {
                    token = this.tn.next();
                    if (token !== Lang.EQUAL)
                        throw Error("Illegal id assignment after group "+msg.name+" at line "+this.tn.line+": "+token+" ('"+Lang.EQUAL+"' expected)");
                    token = this.tn.next();
                    try {
                        fld["id"] = this._parseId(token);
                    } catch (e) {
                        throw Error("Illegal field id value for group "+msg.name+"#"+fld.name+" at line "+this.tn.line+": "+token);
                    }
                    msg["isGroup"] = true;
                }
                msg["fields"] = []; // Note: Using arrays to support also browser that cannot preserve order of object keys.
                msg["enums"] = [];
                msg["messages"] = [];
                msg["options"] = {};
                token = this.tn.next();
                if (token === Lang.OPTOPEN && fld)
                    this._parseFieldOptions(msg, fld, token),
                    token = this.tn.next();
                if (token !== Lang.OPEN)
                    throw Error("Illegal OPEN after "+(isGroup ? "group" : "message")+" "+msg.name+" at line "+this.tn.line+": "+token+" ('"+Lang.OPEN+"' expected)");
                // msg["extensions"] = undefined
                do {
                    token = this.tn.next();
                    if (token === Lang.CLOSE) {
                        token = this.tn.peek();
                        if (token === Lang.END)
                            this.tn.next();
                        break;
                    } else if (Lang.RULE.test(token))
                        this._parseMessageField(msg, token);
                    else if (token === "enum")
                        this._parseEnum(msg, token);
                    else if (token === "message")
                        this._parseMessage(msg, null, token);
                    else if (token === "option")
                        this._parseOption(msg, token);
                    else if (token === "extensions")
                        msg["extensions"] = this._parseExtensions(msg, token);
                    else if (token === "extend")
                        this._parseExtend(msg, token);
                    else
                        throw Error("Illegal token in message "+msg.name+" at line "+this.tn.line+": "+token+" (type or '"+Lang.CLOSE+"' expected)");
                } while (true);
                parent["messages"].push(msg);
                return msg;
            };

            /**
             * Parses a message field.
             * @param {Object} msg Message definition
             * @param {string} token Initial token
             * @throws {Error} If the message field cannot be parsed
             * @private
             */
            Parser.prototype._parseMessageField = function(msg, token) {
                /** @dict */
                var fld = {}, grp = null;
                fld["rule"] = token;
                /** @dict */
                fld["options"] = {};
                token = this.tn.next();
                if (token === "group") {
                    // "A [legacy] group simply combines a nested message type and a field into a single declaration. In your
                    // code, you can treat this message just as if it had a Result type field called result (the latter name is
                    // converted to lower-case so that it does not conflict with the former)."
                    grp = this._parseMessage(msg, fld, token);
                    if (!/^[A-Z]/.test(grp["name"]))
                        throw Error('Group names must start with a capital letter');
                    fld["type"] = grp["name"];
                    fld["name"] = grp["name"].toLowerCase();
                    token = this.tn.peek();
                    if (token === Lang.END)
                        this.tn.next();
                } else {
                    if (!Lang.TYPE.test(token) && !Lang.TYPEREF.test(token))
                        throw Error("Illegal field type in message "+msg.name+" at line "+this.tn.line+": "+token);
                    fld["type"] = token;
                    token = this.tn.next();
                    if (!Lang.NAME.test(token))
                        throw Error("Illegal field name in message "+msg.name+" at line "+this.tn.line+": "+token);
                    fld["name"] = token;
                    token = this.tn.next();
                    if (token !== Lang.EQUAL)
                        throw Error("Illegal field id assignment in message "+msg.name+"#"+fld.name+" at line "+this.tn.line+": "+token+" ('"+Lang.EQUAL+"' expected)");
                    token = this.tn.next();
                    try {
                        fld["id"] = this._parseId(token);
                    } catch (e) {
                        throw Error("Illegal field id value in message "+msg.name+"#"+fld.name+" at line "+this.tn.line+": "+token);
                    }
                    token = this.tn.next();
                    if (token === Lang.OPTOPEN)
                        this._parseFieldOptions(msg, fld, token),
                        token = this.tn.next();
                    if (token !== Lang.END)
                        throw Error("Illegal field delimiter in message "+msg.name+"#"+fld.name+" at line "+this.tn.line+": "+token+" ('"+Lang.END+"' expected)");
                }
                msg["fields"].push(fld);
            };

            /**
             * Parses a set of field option definitions.
             * @param {Object} msg Message definition
             * @param {Object} fld Field definition
             * @param {string} token Initial token
             * @throws {Error} If the message field options cannot be parsed
             * @private
             */
            Parser.prototype._parseFieldOptions = function(msg, fld, token) {
                var first = true;
                do {
                    token = this.tn.next();
                    if (token === Lang.OPTCLOSE)
                        break;
                    else if (token === Lang.OPTEND) {
                        if (first)
                            throw Error("Illegal start of message field options in message "+msg.name+"#"+fld.name+" at line "+this.tn.line+": "+token);
                        token = this.tn.next();
                    }
                    this._parseFieldOption(msg, fld, token);
                    first = false;
                } while (true);
            };

            /**
             * Parses a single field option.
             * @param {Object} msg Message definition
             * @param {Object} fld Field definition
             * @param {string} token Initial token
             * @throws {Error} If the mesage field option cannot be parsed
             * @private
             */
            Parser.prototype._parseFieldOption = function(msg, fld, token) {
                var custom = false;
                if (token === Lang.COPTOPEN)
                    token = this.tn.next(),
                    custom = true;
                if (!Lang.TYPEREF.test(token))
                    throw Error("Illegal field option in message "+msg.name+"#"+fld.name+" at line "+this.tn.line+": "+token);
                var name = token;
                token = this.tn.next();
                if (custom) {
                    if (token !== Lang.COPTCLOSE)
                        throw Error("Illegal custom field option name delimiter in message "+msg.name+"#"+fld.name+" at line "+this.tn.line+": "+token+" (')' expected)");
                    name = '('+name+')';
                    token = this.tn.next();
                    if (Lang.FQTYPEREF.test(token))
                        name += token,
                        token = this.tn.next();
                }
                if (token !== Lang.EQUAL)
                    throw Error("Illegal field option operation in message "+msg.name+"#"+fld.name+" at line "+this.tn.line+": "+token+" ('=' expected)");
                var value;
                token = this.tn.next();
                if (token === Lang.STRINGOPEN || token === Lang.STRINGOPEN_SQ) {
                    value = this.tn.next();
                    token = this.tn.next();
                    if (token != this.tn.stringEndsWith)
                        throw Error("Illegal end of field value in message "+msg.name+"#"+fld.name+", option "+name+" at line "+this.tn.line+": "+token+" ('"+this.tn.stringEndsWith+"' expected)");
                } else if (Lang.NUMBER.test(token, true))
                    value = this._parseNumber(token, true);
                else if (Lang.BOOL.test(token))
                    value = token.toLowerCase() === 'true';
                else if (Lang.TYPEREF.test(token))
                    value = token; // TODO: Resolve?
                else
                    throw Error("Illegal field option value in message "+msg.name+"#"+fld.name+", option "+name+" at line "+this.tn.line+": "+token);
                fld["options"][name] = value;
            };

            /**
             * Parses an enum.
             * @param {Object} msg Message definition
             * @param {string} token Initial token
             * @throws {Error} If the enum cannot be parsed
             * @private
             */
            Parser.prototype._parseEnum = function(msg, token) {
                /** @dict */
                var enm = {};
                token = this.tn.next();
                if (!Lang.NAME.test(token))
                    throw Error("Illegal enum name in message "+msg.name+" at line "+this.tn.line+": "+token);
                enm["name"] = token;
                token = this.tn.next();
                if (token !== Lang.OPEN)
                    throw Error("Illegal OPEN after enum "+enm.name+" at line "+this.tn.line+": "+token);
                enm["values"] = [];
                enm["options"] = {};
                do {
                    token = this.tn.next();
                    if (token === Lang.CLOSE) {
                        token = this.tn.peek();
                        if (token === Lang.END)
                            this.tn.next();
                        break;
                    }
                    if (token == 'option')
                        this._parseOption(enm, token);
                    else {
                        if (!Lang.NAME.test(token))
                            throw Error("Illegal enum value name in enum "+enm.name+" at line "+this.tn.line+": "+token);
                        this._parseEnumValue(enm, token);
                    }
                } while (true);
                msg["enums"].push(enm);
            };

            /**
             * Parses an enum value.
             * @param {Object} enm Enum definition
             * @param {string} token Initial token
             * @throws {Error} If the enum value cannot be parsed
             * @private
             */
            Parser.prototype._parseEnumValue = function(enm, token) {
                /** @dict */
                var val = {};
                val["name"] = token;
                token = this.tn.next();
                if (token !== Lang.EQUAL)
                    throw Error("Illegal enum value operator in enum "+enm.name+" at line "+this.tn.line+": "+token+" ('"+Lang.EQUAL+"' expected)");
                token = this.tn.next();
                try {
                    val["id"] = this._parseId(token, true);
                } catch (e) {
                    throw Error("Illegal enum value id in enum "+enm.name+" at line "+this.tn.line+": "+token);
                }
                enm["values"].push(val);
                token = this.tn.next();
                if (token === Lang.OPTOPEN) {
                    var opt = { 'options' : {} }; // TODO: Actually expose them somehow.
                    this._parseFieldOptions(enm, opt, token);
                    token = this.tn.next();
                }
                if (token !== Lang.END)
                    throw Error("Illegal enum value delimiter in enum "+enm.name+" at line "+this.tn.line+": "+token+" ('"+Lang.END+"' expected)");
            };

            /**
             * Parses an extensions statement.
             * @param {Object} msg Message object
             * @param {string} token Initial token
             * @throws {Error} If the extensions statement cannot be parsed
             * @private
             */
            Parser.prototype._parseExtensions = function(msg, token) {
                /** @type {Array.<number>} */
                var range = [];
                token = this.tn.next();
                if (token === "min") // FIXME: Does the official implementation support this?
                    range.push(ProtoBuf.ID_MIN);
                else if (token === "max")
                    range.push(ProtoBuf.ID_MAX);
                else
                    range.push(this._parseNumber(token));
                token = this.tn.next();
                if (token !== 'to')
                    throw Error("Illegal extensions delimiter in message "+msg.name+" at line "+this.tn.line+" ('to' expected)");
                token = this.tn.next();
                if (token === "min")
                    range.push(ProtoBuf.ID_MIN);
                else if (token === "max")
                    range.push(ProtoBuf.ID_MAX);
                else
                    range.push(this._parseNumber(token));
                token = this.tn.next();
                if (token !== Lang.END)
                    throw Error("Illegal extension delimiter in message "+msg.name+" at line "+this.tn.line+": "+token+" ('"+Lang.END+"' expected)");
                return range;
            };

            /**
             * Parses an extend block.
             * @param {Object} parent Parent object
             * @param {string} token Initial token
             * @throws {Error} If the extend block cannot be parsed
             * @private
             */
            Parser.prototype._parseExtend = function(parent, token) {
                token = this.tn.next();
                if (!Lang.TYPEREF.test(token))
                    throw Error("Illegal extended message name at line "+this.tn.line+": "+token);
                /** @dict */
                var ext = {};
                ext["ref"] = token;
                ext["fields"] = [];
                token = this.tn.next();
                if (token !== Lang.OPEN)
                    throw Error("Illegal OPEN in extend "+ext.name+" at line "+this.tn.line+": "+token+" ('"+Lang.OPEN+"' expected)");
                do {
                    token = this.tn.next();
                    if (token === Lang.CLOSE) {
                        token = this.tn.peek();
                        if (token == Lang.END)
                            this.tn.next();
                        break;
                    } else if (Lang.RULE.test(token))
                        this._parseMessageField(ext, token);
                    else
                        throw Error("Illegal token in extend "+ext.name+" at line "+this.tn.line+": "+token+" (rule or '"+Lang.CLOSE+"' expected)");
                } while (true);
                parent["messages"].push(ext);
                return ext;
            };

            /**
             * Returns a string representation of this object.
             * @returns {string} String representation as of "Parser"
             */
            Parser.prototype.toString = function() {
                return "Parser";
            };

            /**
             * @alias ProtoBuf.DotProto.Parser
             * @expose
             */
            DotProto.Parser = Parser;

            return DotProto;

        })(ProtoBuf, ProtoBuf.Lang);

        /**
         * @alias ProtoBuf.Reflect
         * @expose
         */
        ProtoBuf.Reflect = (function(ProtoBuf) {
            "use strict";

            /**
             * Reflection types.
             * @exports ProtoBuf.Reflect
             * @namespace
             */
            var Reflect = {};

            /**
             * Constructs a Reflect base class.
             * @exports ProtoBuf.Reflect.T
             * @constructor
             * @abstract
             * @param {ProtoBuf.Reflect.T} parent Parent object
             * @param {string} name Object name
             */
            var T = function(parent, name) {

                /**
                 * Parent object.
                 * @type {ProtoBuf.Reflect.T|null}
                 * @expose
                 */
                this.parent = parent;

                /**
                 * Object name in namespace.
                 * @type {string}
                 * @expose
                 */
                this.name = name;

                /**
                 * Fully qualified class name
                 * @type {string}
                 * @expose
                 */
                this.className;
            };

            /**
             * Returns the fully qualified name of this object.
             * @returns {string} Fully qualified name as of ".PATH.TO.THIS"
             * @expose
             */
            T.prototype.fqn = function() {
                var name = this.name,
                    ptr = this;
                do {
                    ptr = ptr.parent;
                    if (ptr == null)
                        break;
                    name = ptr.name+"."+name;
                } while (true);
                return name;
            };

            /**
             * Returns a string representation of this Reflect object (its fully qualified name).
             * @param {boolean=} includeClass Set to true to include the class name. Defaults to false.
             * @return String representation
             * @expose
             */
            T.prototype.toString = function(includeClass) {
                return (includeClass ? this.className + " " : "") + this.fqn();
            };

            /**
             * Builds this type.
             * @throws {Error} If this type cannot be built directly
             * @expose
             */
            T.prototype.build = function() {
                throw Error(this.toString(true)+" cannot be built directly");
            };

            /**
             * @alias ProtoBuf.Reflect.T
             * @expose
             */
            Reflect.T = T;

            /**
             * Constructs a new Namespace.
             * @exports ProtoBuf.Reflect.Namespace
             * @param {ProtoBuf.Reflect.Namespace|null} parent Namespace parent
             * @param {string} name Namespace name
             * @param {Object.<string,*>} options Namespace options
             * @constructor
             * @extends ProtoBuf.Reflect.T
             */
            var Namespace = function(parent, name, options) {
                T.call(this, parent, name);

                /**
                 * @override
                 */
                this.className = "Namespace";

                /**
                 * Children inside the namespace.
                 * @type {Array.<ProtoBuf.Reflect.T>}
                 */
                this.children = [];

                /**
                 * Options.
                 * @type {Object.<string, *>}
                 */
                this.options = options || {};
            };

            // Extends T
            Namespace.prototype = Object.create(T.prototype);

            /**
             * Returns an array of the namespace's children.
             * @param {ProtoBuf.Reflect.T=} type Filter type (returns instances of this type only). Defaults to null (all children).
             * @return {Array.<ProtoBuf.Reflect.T>}
             * @expose
             */
            Namespace.prototype.getChildren = function(type) {
                type = type || null;
                if (type == null)
                    return this.children.slice();
                var children = [];
                for (var i=0, k=this.children.length; i<k; ++i)
                    if (this.children[i] instanceof type)
                        // We also need to distinguish between Field and ExtensionField which is an instance of Field
                        if (type !== Message.Field || !(this.children[i] instanceof Message.ExtensionField))
                            children.push(this.children[i]);
                return children;
            };

            /**
             * Adds a child to the namespace.
             * @param {ProtoBuf.Reflect.T} child Child
             * @throws {Error} If the child cannot be added (duplicate)
             * @expose
             */
            Namespace.prototype.addChild = function(child) {
                var other;
                if (other = this.getChild(child.name)) {
                    // Try to revert camelcase transformation on collision
                    if (other instanceof Message.Field && other.name !== other.originalName && !this.hasChild(other.originalName))
                        other.name = other.originalName; // Revert previous first (effectively keeps both originals)
                    else if (child instanceof Message.Field && child.name !== child.originalName && !this.hasChild(child.originalName))
                        child.name = child.originalName;
                    else
                        throw Error("Duplicate name in namespace "+this.toString(true)+": "+child.name);
                }
                this.children.push(child);
            };

            /**
             * Tests if this namespace has a child with the specified name.
             * @param {string|number} nameOrId Child name or id
             * @returns {boolean} true if there is one, else false
             * @expose
             */
            Namespace.prototype.hasChild = function(nameOrId) {
                return this._indexOf(nameOrId) > -1;
            };

            /**
             * Gets a child by its name.
             * @param {string|number} nameOrId Child name or id
             * @return {?ProtoBuf.Reflect.T} The child or null if not found
             * @expose
             */
            Namespace.prototype.getChild = function(nameOrId) {
                var index = this._indexOf(nameOrId);
                return index > -1 ? this.children[index] : null;
            };

            /**
             * Returns child index by its name or id.
             * @param {string|number} nameOrId Child name or id
             * @return {Number} The child index
             * @private
             */
            Namespace.prototype._indexOf = function(nameOrId) {
                var key = typeof nameOrId === 'number' ? 'id' : 'name';
                for (var i=0; i<this.children.length; i++)
                    if (typeof this.children[i][key] !== 'undefined' && this.children[i][key] == nameOrId)
                        return i;
                return -1;
            };

            /**
             * Resolves a reflect object inside of this namespace.
             * @param {string} qn Qualified name to resolve
             * @param {boolean=} excludeFields Excludes fields, defaults to `false`
             * @return {ProtoBuf.Reflect.Namespace|null} The resolved type or null if not found
             * @expose
             */
            Namespace.prototype.resolve = function(qn, excludeFields) {
                var part = qn.split(".");
                var ptr = this, i=0;
                if (part[i] == "") { // Fully qualified name, e.g. ".My.Message'
                    while (ptr.parent != null)
                        ptr = ptr.parent;
                    i++;
                }
                var child;
                do {
                    do {
                        child = ptr.getChild(part[i]);
                        if (!child || !(child instanceof Reflect.T) || (excludeFields && child instanceof Reflect.Message.Field)) {
                            ptr = null;
                            break;
                        }
                        ptr = child; i++;
                    } while (i < part.length);
                    if (ptr != null)
                        break; // Found
                    // Else search the parent
                    if (this.parent !== null) {
                        return this.parent.resolve(qn, excludeFields);
                    }
                } while (ptr != null);
                return ptr;
            };

            /**
             * Builds the namespace and returns the runtime counterpart.
             * @return {Object.<string,Function|Object>} Runtime namespace
             * @expose
             */
            Namespace.prototype.build = function() {
                /** @dict */
                var ns = {};
                var children = this.getChildren(), child;
                for (var i=0, k=children.length; i<k; ++i) {
                    child = children[i];
                    if (child instanceof Namespace)
                        ns[child.name] = child.build();
                }
                if (Object.defineProperty)
                    Object.defineProperty(ns, "$options", { "value": this.buildOpt() });
                return ns;
            };

            /**
             * Builds the namespace's '$options' property.
             * @return {Object.<string,*>}
             */
            Namespace.prototype.buildOpt = function() {
                var opt = {};
                var keys = Object.keys(this.options);
                for (var i=0; i<keys.length; i++) {
                    var key = keys[i],
                        val = this.options[keys[i]];
                    // TODO: Options are not resolved, yet.
                    // if (val instanceof Namespace) {
                    //     opt[key] = val.build();
                    // } else {
                    opt[key] = val;
                    // }
                }
                return opt;
            };

            /**
             * Gets the value assigned to the option with the specified name.
             * @param {string=} name Returns the option value if specified, otherwise all options are returned.
             * @return {*|Object.<string,*>}null} Option value or NULL if there is no such option
             */
            Namespace.prototype.getOption = function(name) {
                if (typeof name === 'undefined')
                    return this.options;
                return typeof this.options[name] !== 'undefined' ? this.options[name] : null;
            };

            /**
             * @alias ProtoBuf.Reflect.Namespace
             * @expose
             */
            Reflect.Namespace = Namespace;

            /**
             * Constructs a new Message.
             * @exports ProtoBuf.Reflect.Message
             * @param {ProtoBuf.Reflect.Namespace} parent Parent message or namespace
             * @param {string} name Message name
             * @param {Object.<string,*>} options Message options
             * @param {boolean=} isGroup `true` if this is a legacy group
             * @constructor
             * @extends ProtoBuf.Reflect.Namespace
             */
            var Message = function(parent, name, options, isGroup) {
                Namespace.call(this, parent, name, options);

                /**
                 * @override
                 */
                this.className = "Message";

                /**
                 * Extensions range.
                 * @type {!Array.<number>}
                 * @expose
                 */
                this.extensions = [ProtoBuf.ID_MIN, ProtoBuf.ID_MAX];

                /**
                 * Runtime message class.
                 * @type {?function(new:ProtoBuf.Builder.Message)}
                 * @expose
                 */
                this.clazz = null;

                /**
                 * Whether this is a legacy group or not.
                 * @type {boolean}
                 * @expose
                 */
                this.isGroup = !!isGroup;
            };

            // Extends Namespace
            Message.prototype = Object.create(Namespace.prototype);

            /**
             * Builds the message and returns the runtime counterpart, which is a fully functional class.
             * @see ProtoBuf.Builder.Message
             * @param {boolean=} rebuild Whether to rebuild or not, defaults to false
             * @return {ProtoBuf.Reflect.Message} Message class
             * @throws {Error} If the message cannot be built
             * @expose
             */
            Message.prototype.build = function(rebuild) {
                if (this.clazz && !rebuild) return this.clazz;

                // We need to create a prototyped Message class in an isolated scope
                var clazz = (function(ProtoBuf, T) {

                    var fields = T.getChildren(ProtoBuf.Reflect.Message.Field);

                    /**
                     * Constructs a new runtime Message.
                     * @name ProtoBuf.Builder.Message
                     * @class Barebone of all runtime messages.
                     * @param {Object.<string,*>|...[string]} values Preset values
                     * @constructor
                     * @throws {Error} If the message cannot be created
                     */
                    var Message = function(values) {
                        ProtoBuf.Builder.Message.call(this);
                        var i, field;

                        // Create fields on the object itself to allow setting and getting through Message#fieldname
                        for (i=0; i<fields.length; i++) {
                            field = fields[i];
                            this[field.name] = (field.repeated) ? [] : null;
                        }
                        // Set the default values
                        for (i=0; i<fields.length; i++) {
                            field = fields[i];
                            if (typeof field.options['default'] != 'undefined') {
                                try {
                                    this.$set(field.name, field.options['default']); // Should not throw
                                } catch (e) {
                                    throw Error("[INTERNAL] "+e);
                                }
                            }
                        }
                        // Set field values from a values object
                        if (arguments.length == 1 && typeof values == 'object' &&
                            /* not another Message */ typeof values.encode != 'function' &&
                            /* not a repeated field */ !ProtoBuf.Util.isArray(values) &&
                            /* not a ByteBuffer */ !(values instanceof ByteBuffer) &&
                            /* not an ArrayBuffer */ !(values instanceof ArrayBuffer) &&
                            /* not a Long */ !(ProtoBuf.Long && values instanceof ProtoBuf.Long)) {
                            var keys = Object.keys(values);
                            for (i=0; i<keys.length; i++)
                                this.$set(keys[i], values[keys[i]]); // May throw
                            // Else set field values from arguments, in correct order
                        } else
                            for (i=0; i<arguments.length; i++)
                                if (i<fields.length)
                                    this.$set(fields[i].name, arguments[i]); // May throw
                    };

                    // Extends ProtoBuf.Builder.Message
                    Message.prototype = Object.create(ProtoBuf.Builder.Message.prototype);

                    /**
                     * Adds a value to a repeated field.
                     * @name ProtoBuf.Builder.Message#add
                     * @function
                     * @param {string} key Field name
                     * @param {*} value Value to add
                     * @param {boolean=} noAssert Whether to assert the value or not (asserts by default)
                     * @throws {Error} If the value cannot be added
                     * @expose
                     */
                    Message.prototype.add = function(key, value, noAssert) {
                        var field = T.getChild(key);
                        if (!field)
                            throw Error(this+"#"+key+" is undefined");
                        if (!(field instanceof ProtoBuf.Reflect.Message.Field))
                            throw Error(this+"#"+key+" is not a field: "+field.toString(true)); // May throw if it's an enum or embedded message
                        if (!field.repeated)
                            throw Error(this+"#"+key+" is not a repeated field");
                        if (this[field.name] === null)
                            this[field.name] = [];
                        this[field.name].push(noAssert ? value : field.verifyValue(value, true));
                    };

                    /**
                     * Adds a value to a repeated field. This is an alias for {@link ProtoBuf.Builder.Message#add}.
                     * @name ProtoBuf.Builder.Message#$add
                     * @function
                     * @param {string} key Field name
                     * @param {*} value Value to add
                     * @param {boolean=} noAssert Whether to assert the value or not (asserts by default)
                     * @throws {Error} If the value cannot be added
                     * @expose
                     */
                    Message.prototype.$add = Message.prototype.add;

                    /**
                     * Sets a field's value.
                     * @name ProtoBuf.Builder.Message#set
                     * @function
                     * @param {string} key Key
                     * @param {*} value Value to set
                     * @param {boolean=} noAssert Whether to assert the value or not (asserts by default)
                     * @throws {Error} If the value cannot be set
                     * @expose
                     */
                    Message.prototype.set = function(key, value, noAssert) {
                        var field = T.getChild(key);
                        if (!field)
                            throw Error(this+"#"+key+" is not a field: undefined");
                        if (!(field instanceof ProtoBuf.Reflect.Message.Field))
                            throw Error(this+"#"+key+" is not a field: "+field.toString(true));
                        this[field.name] = noAssert ? value : field.verifyValue(value); // May throw
                    };

                    /**
                     * Sets a field's value. This is an alias for [@link ProtoBuf.Builder.Message#set}.
                     * @name ProtoBuf.Builder.Message#$set
                     * @function
                     * @param {string} key Key
                     * @param {*} value Value to set
                     * @param {boolean=} noAssert Whether to assert the value or not (asserts by default)
                     * @throws {Error} If the value cannot be set
                     * @expose
                     */
                    Message.prototype.$set = Message.prototype.set;

                    /**
                     * Gets a field's value.
                     * @name ProtoBuf.Builder.Message#get
                     * @function
                     * @param {string} key Key
                     * @return {*} Value
                     * @throws {Error} If there is no such field
                     * @expose
                     */
                    Message.prototype.get = function(key) {
                        var field = T.getChild(key);
                        if (!field || !(field instanceof ProtoBuf.Reflect.Message.Field))
                            throw Error(this+"#"+key+" is not a field: undefined");
                        if (!(field instanceof ProtoBuf.Reflect.Message.Field))
                            throw Error(this+"#"+key+" is not a field: "+field.toString(true));
                        return this[field.name];
                    };

                    /**
                     * Gets a field's value. This is an alias for {@link ProtoBuf.Builder.Message#$get}.
                     * @name ProtoBuf.Builder.Message#$get
                     * @function
                     * @param {string} key Key
                     * @return {*} Value
                     * @throws {Error} If there is no such field
                     * @expose
                     */
                    Message.prototype.$get = Message.prototype.get;

                    // Getters and setters

                    for (var i=0; i<fields.length; i++) {
                        var field = fields[i];

                        (function(field) {
                            // set/get[SomeValue]
                            var Name = field.originalName.replace(/(_[a-zA-Z])/g, function(match) {
                                return match.toUpperCase().replace('_','');
                            });
                            Name = Name.substring(0,1).toUpperCase()+Name.substring(1);

                            // set/get_[some_value]
                            var name = field.originalName.replace(/([A-Z])/g, function(match) {
                                return "_"+match;
                            });

                            /**
                             * Sets a value. This method is present for each field, but only if there is no name conflict with
                             * another field.
                             * @name ProtoBuf.Builder.Message#set[SomeField]
                             * @function
                             * @param {*} value Value to set
                             * @abstract
                             * @throws {Error} If the value cannot be set
                             */
                            if (!T.hasChild("set"+Name))
                                Message.prototype["set"+Name] = function(value) {
                                    this.$set(field.name, value);
                                };

                            /**
                             * Sets a value. This method is present for each field, but only if there is no name conflict with
                             * another field.
                             * @name ProtoBuf.Builder.Message#set_[some_field]
                             * @function
                             * @param {*} value Value to set
                             * @abstract
                             * @throws {Error} If the value cannot be set
                             */
                            if (!T.hasChild("set_"+name))
                                Message.prototype["set_"+name] = function(value) {
                                    this.$set(field.name, value);
                                };

                            /**
                             * Gets a value. This method is present for each field, but only if there is no name conflict with
                             * another field.
                             * @name ProtoBuf.Builder.Message#get[SomeField]
                             * @function
                             * @abstract
                             * @return {*} The value
                             */
                            if (!T.hasChild("get"+Name))
                                Message.prototype["get"+Name] = function() {
                                    return this.$get(field.name); // Does not throw, field exists
                                }

                            /**
                             * Gets a value. This method is present for each field, but only if there is no name conflict with
                             * another field.
                             * @name ProtoBuf.Builder.Message#get_[some_field]
                             * @function
                             * @return {*} The value
                             * @abstract
                             */
                            if (!T.hasChild("get_"+name))
                                Message.prototype["get_"+name] = function() {
                                    return this.$get(field.name); // Does not throw, field exists
                                };

                        })(field);
                    }

                    // En-/decoding

                    /**
                     * Encodes the message.
                     * @name ProtoBuf.Builder.Message#$encode
                     * @function
                     * @param {(!ByteBuffer|boolean)=} buffer ByteBuffer to encode to. Will create a new one and flip it if omitted.
                     * @return {!ByteBuffer} Encoded message as a ByteBuffer
                     * @throws {Error} If the message cannot be encoded or if required fields are missing. The later still
                     *  returns the encoded ByteBuffer in the `encoded` property on the error.
                     * @expose
                     * @see ProtoBuf.Builder.Message#encode64
                     * @see ProtoBuf.Builder.Message#encodeHex
                     * @see ProtoBuf.Builder.Message#encodeAB
                     */
                    Message.prototype.encode = function(buffer) {
                        var isNew = false;
                        if (!buffer)
                            buffer = new ByteBuffer(), isNew = true;
                        var le = buffer.littleEndian;
                        try {
                            T.encode(this, buffer.LE());
                            return (isNew ? buffer.flip() : buffer).LE(le);
                        } catch (e) {
                            buffer.LE(le);
                            throw(e);
                        }
                    };

                    /**
                     * Calculates the byte length of the message.
                     * @name ProtoBuf.Builder.Message#calculate
                     * @function
                     * @returns {number} Byte length
                     * @throws {Error} If the message cannot be calculated or if required fields are missing.
                     * @expose
                     */
                    Message.prototype.calculate = function() {
                        return T.calculate(this);
                    };

                    /**
                     * Encodes the varint32 length-delimited message.
                     * @name ProtoBuf.Builder.Message#encodeDelimited
                     * @function
                     * @param {(!ByteBuffer|boolean)=} buffer ByteBuffer to encode to. Will create a new one and flip it if omitted.
                     * @return {!ByteBuffer} Encoded message as a ByteBuffer
                     * @throws {Error} If the message cannot be encoded or if required fields are missing. The later still
                     *  returns the encoded ByteBuffer in the `encoded` property on the error.
                     * @expose
                     */
                    Message.prototype.encodeDelimited = function(buffer) {
                        var isNew = false;
                        if (!buffer)
                            buffer = new ByteBuffer(), isNew = true;
                        var enc = new ByteBuffer().LE();
                        T.encode(this, enc).flip();
                        buffer.writeVarint32(enc.remaining());
                        buffer.append(enc);
                        return isNew ? buffer.flip() : buffer;
                    };

                    /**
                     * Directly encodes the message to an ArrayBuffer.
                     * @name ProtoBuf.Builder.Message#encodeAB
                     * @function
                     * @return {ArrayBuffer} Encoded message as ArrayBuffer
                     * @throws {Error} If the message cannot be encoded or if required fields are missing. The later still
                     *  returns the encoded ArrayBuffer in the `encoded` property on the error.
                     * @expose
                     */
                    Message.prototype.encodeAB = function() {
                        try {
                            return this.encode().toArrayBuffer();
                        } catch (e) {
                            if (e["encoded"]) e["encoded"] = e["encoded"].toArrayBuffer();
                            throw(e);
                        }
                    };

                    /**
                     * Returns the message as an ArrayBuffer. This is an alias for {@link ProtoBuf.Builder.Message#encodeAB}.
                     * @name ProtoBuf.Builder.Message#toArrayBuffer
                     * @function
                     * @return {ArrayBuffer} Encoded message as ArrayBuffer
                     * @throws {Error} If the message cannot be encoded or if required fields are missing. The later still
                     *  returns the encoded ArrayBuffer in the `encoded` property on the error.
                     * @expose
                     */
                    Message.prototype.toArrayBuffer = Message.prototype.encodeAB;

                    /**
                     * Directly encodes the message to a node Buffer.
                     * @name ProtoBuf.Builder.Message#encodeNB
                     * @function
                     * @return {!Buffer}
                     * @throws {Error} If the message cannot be encoded, not running under node.js or if required fields are
                     *  missing. The later still returns the encoded node Buffer in the `encoded` property on the error.
                     * @expose
                     */
                    Message.prototype.encodeNB = function() {
                        try {
                            return this.encode().toBuffer();
                        } catch (e) {
                            if (e["encoded"]) e["encoded"] = e["encoded"].toBuffer();
                            throw(e);
                        }
                    };

                    /**
                     * Returns the message as a node Buffer. This is an alias for {@link ProtoBuf.Builder.Message#encodeNB}.
                     * @name ProtoBuf.Builder.Message#toBuffer
                     * @function
                     * @return {!Buffer}
                     * @throws {Error} If the message cannot be encoded or if required fields are missing. The later still
                     *  returns the encoded node Buffer in the `encoded` property on the error.
                     * @expose
                     */
                    Message.prototype.toBuffer = Message.prototype.encodeNB;

                    /**
                     * Directly encodes the message to a base64 encoded string.
                     * @name ProtoBuf.Builder.Message#encode64
                     * @function
                     * @return {string} Base64 encoded string
                     * @throws {Error} If the underlying buffer cannot be encoded or if required fields are missing. The later
                     *  still returns the encoded base64 string in the `encoded` property on the error.
                     * @expose
                     */
                    Message.prototype.encode64 = function() {
                        try {
                            return this.encode().toBase64();
                        } catch (e) {
                            if (e["encoded"]) e["encoded"] = e["encoded"].toBase64();
                            throw(e);
                        }
                    };

                    /**
                     * Returns the message as a base64 encoded string. This is an alias for {@link ProtoBuf.Builder.Message#encode64}.
                     * @name ProtoBuf.Builder.Message#toBase64
                     * @function
                     * @return {string} Base64 encoded string
                     * @throws {Error} If the message cannot be encoded or if required fields are missing. The later still
                     *  returns the encoded base64 string in the `encoded` property on the error.
                     * @expose
                     */
                    Message.prototype.toBase64 = Message.prototype.encode64;

                    /**
                     * Directly encodes the message to a hex encoded string.
                     * @name ProtoBuf.Builder.Message#encodeHex
                     * @function
                     * @return {string} Hex encoded string
                     * @throws {Error} If the underlying buffer cannot be encoded or if required fields are missing. The later
                     *  still returns the encoded hex string in the `encoded` property on the error.
                     * @expose
                     */
                    Message.prototype.encodeHex = function() {
                        try {
                            return this.encode().toHex();
                        } catch (e) {
                            if (e["encoded"]) e["encoded"] = e["encoded"].toHex();
                            throw(e);
                        }
                    };

                    /**
                     * Returns the message as a hex encoded string. This is an alias for {@link ProtoBuf.Builder.Message#encodeHex}.
                     * @name ProtoBuf.Builder.Message#toHex
                     * @function
                     * @return {string} Hex encoded string
                     * @throws {Error} If the message cannot be encoded or if required fields are missing. The later still
                     *  returns the encoded hex string in the `encoded` property on the error.
                     * @expose
                     */
                    Message.prototype.toHex = Message.prototype.encodeHex;

                    /**
                     * Clones a message object to a raw object.
                     * @param {*} obj Object to clone
                     * @param {boolean} includeBuffers Whether to include native buffer data or not
                     * @returns {*} Cloned object
                     * @inner
                     */
                    function cloneRaw(obj, includeBuffers) {
                        var clone = {};
                        for (var i in obj)
                            if (obj.hasOwnProperty(i)) {
                                if (obj[i] === null || typeof obj[i] !== 'object')
                                    clone[i] = obj[i];
                                else if (obj[i] instanceof ByteBuffer) {
                                    if (includeBuffers)
                                        clone[i] = obj.toBuffer();
                                } else // is a non-null object
                                    clone[i] = cloneRaw(obj[i], includeBuffers);
                            }
                        return clone;
                    }

                    /**
                     * Returns the message's raw payload.
                     * @param {boolean=} includeBuffers Whether to include native buffer data or not, defaults to `false`
                     * @returns {Object.<string,*>} Raw payload
                     * @expose
                     */
                    Message.prototype.toRaw = function(includeBuffers) {
                        return cloneRaw(this, !!includeBuffers);
                    };

                    /**
                     * Decodes a message from the specified buffer or string.
                     * @name ProtoBuf.Builder.Message.decode
                     * @function
                     * @param {!ByteBuffer|!ArrayBuffer|!Buffer|string} buffer Buffer to decode from
                     * @param {string=} enc Encoding if buffer is a string: hex, utf8 (not recommended), defaults to base64
                     * @return {!ProtoBuf.Builder.Message} Decoded message
                     * @throws {Error} If the message cannot be decoded or if required fields are missing. The later still
                     *  returns the decoded message with missing fields in the `decoded` property on the error.
                     * @expose
                     * @see ProtoBuf.Builder.Message.decode64
                     * @see ProtoBuf.Builder.Message.decodeHex
                     */
                    Message.decode = function(buffer, enc) {
                        if (typeof buffer === 'string')
                            buffer = ByteBuffer.wrap(buffer, enc ? enc : "base64");
                        buffer = buffer instanceof ByteBuffer ? buffer : ByteBuffer.wrap(buffer); // May throw
                        var le = buffer.littleEndian;
                        try {
                            var msg = T.decode(buffer.LE());
                            buffer.LE(le);
                            return msg;
                        } catch (e) {
                            buffer.LE(le);
                            throw(e);
                        }
                    };

                    /**
                     * Decodes a varint32 length-delimited message from the specified buffer or string.
                     * @name ProtoBuf.Builder.Message.decodeDelimited
                     * @function
                     * @param {!ByteBuffer|!ArrayBuffer|!Buffer|string} buffer Buffer to decode from
                     * @param {string=} enc Encoding if buffer is a string: hex, utf8 (not recommended), defaults to base64
                     * @return {!ProtoBuf.Builder.Message} Decoded message
                     * @throws {Error} If the message cannot be decoded or if required fields are missing. The later still
                     *  returns the decoded message with missing fields in the `decoded` property on the error.
                     * @expose
                     */
                    Message.decodeDelimited = function(buffer, enc) {
                        if (typeof buffer === 'string')
                            buffer = ByteBuffer.wrap(buffer, enc ? enc : "base64");
                        buffer = buffer instanceof ByteBuffer ? buffer : ByteBuffer.wrap(buffer); // May throw
                        var len = buffer.readVarint32();
                        var msg = T.decode(buffer.slice(buffer.offset, buffer.offset + len).LE());
                        buffer.offset += len;
                        return msg;
                    };

                    /**
                     * Decodes the message from the specified base64 encoded string.
                     * @name ProtoBuf.Builder.Message.decode64
                     * @function
                     * @param {string} str String to decode from
                     * @return {!ProtoBuf.Builder.Message} Decoded message
                     * @throws {Error} If the message cannot be decoded or if required fields are missing. The later still
                     *  returns the decoded message with missing fields in the `decoded` property on the error.
                     * @expose
                     */
                    Message.decode64 = function(str) {
                        return Message.decode(str, "base64");
                    };

                    /**
                     * Decodes the message from the specified hex encoded string.
                     * @name ProtoBuf.Builder.Message.decodeHex
                     * @function
                     * @param {string} str String to decode from
                     * @return {!ProtoBuf.Builder.Message} Decoded message
                     * @throws {Error} If the message cannot be decoded or if required fields are missing. The later still
                     *  returns the decoded message with missing fields in the `decoded` property on the error.
                     * @expose
                     */
                    Message.decodeHex = function(str) {
                        return Message.decode(str, "hex");
                    };

                    // Utility

                    /**
                     * Returns a string representation of this Message.
                     * @name ProtoBuf.Builder.Message#toString
                     * @function
                     * @return {string} String representation as of ".Fully.Qualified.MessageName"
                     * @expose
                     */
                    Message.prototype.toString = function() {
                        return T.toString();
                    };

                    // Static

                    /**
                     * Options.
                     * @name ProtoBuf.Builder.Message.$options
                     * @type {Object.<string,*>}
                     * @expose
                     */
                    var $options; // for cc

                    if (Object.defineProperty)
                        Object.defineProperty(Message, '$options', { "value": T.buildOpt() });

                    return Message;

                })(ProtoBuf, this);

                // Static enums and prototyped sub-messages
                var children = this.getChildren();
                for (var i=0; i<children.length; i++) {
                    if (children[i] instanceof Enum)
                        clazz[children[i]['name']] = children[i].build();
                    else if (children[i] instanceof Message)
                        clazz[children[i]['name']] = children[i].build();
                    else if (children[i] instanceof Message.Field) {
                        // Ignore
                    } else
                        throw Error("Illegal reflect child of "+this.toString(true)+": "+children[i].toString(true));
                }
                return this.clazz = clazz;
            };

            /**
             * Encodes a runtime message's contents to the specified buffer.
             * @param {!ProtoBuf.Builder.Message} message Runtime message to encode
             * @param {ByteBuffer} buffer ByteBuffer to write to
             * @return {ByteBuffer} The ByteBuffer for chaining
             * @throws {Error} If required fields are missing or the message cannot be encoded for another reason
             * @expose
             */
            Message.prototype.encode = function(message, buffer) {
                var fields = this.getChildren(Message.Field),
                    fieldMissing = null;
                for (var i=0, val; i<fields.length; i++) {
                    val = message.$get(fields[i].name);
                    if (fields[i].required && val === null) {
                        if (fieldMissing === null)
                            fieldMissing = fields[i];
                    } else
                        fields[i].encode(val, buffer);
                }
                if (fieldMissing !== null) {
                    var err = Error("Missing at least one required field for "+this.toString(true)+": "+fieldMissing);
                    err["encoded"] = buffer; // Still expose what we got
                    throw(err);
                }
                return buffer;
            };

            /**
             * Calculates a runtime message's byte length.
             * @param {!ProtoBuf.Builder.Message} message Runtime message to encode
             * @returns {number} Byte length
             * @throws {Error} If required fields are missing or the message cannot be calculated for another reason
             * @expose
             */
            Message.prototype.calculate = function(message) {
                var fields = this.getChildren(Message.Field),
                    n = 0;
                for (var i=0, val; i<fields.length; i++) {
                    val = message.$get(fields[i].name);
                    if (fields[i].required && val === null)
                       throw Error("Missing at least one required field for "+this.toString(true)+": "+fields[i]);
                    else
                        n += fields[i].calculate(val);
                }
                return n;
            };

            /**
             * Skips all data until the end of the specified group has been reached.
             * @param {number} expectedId Expected GROUPEND id
             * @param {!ByteBuffer} buf ByteBuffer
             * @returns {boolean} `true` if a value as been skipped, `false` if the end has been reached
             * @throws {Error} If it wasn't possible to find the end of the group (buffer overrun or end tag mismatch)
             * @inner
             */
            function skipTillGroupEnd(expectedId, buf) {
                var tag = buf.readVarint32(), // Throws on OOB
                    wireType = tag & 0x07,
                    id = tag >> 3;
                switch (wireType) {
                    case ProtoBuf.WIRE_TYPES.VARINT:
                        do tag = buf.readUint8();
                        while ((tag & 0x80) === 0x80);
                        break;
                    case ProtoBuf.WIRE_TYPES.BITS64:
                        buf.offset += 8;
                        break;
                    case ProtoBuf.WIRE_TYPES.LDELIM:
                        tag = buf.readVarint32(); // reads the varint
                        buf.offset += tag;        // skips n bytes
                        break;
                    case ProtoBuf.WIRE_TYPES.STARTGROUP:
                        skipTillGroupEnd(id, buf);
                        break;
                    case ProtoBuf.WIRE_TYPES.ENDGROUP:
                        if (id === expectedId)
                            return false;
                        else
                            throw Error("Illegal GROUPEND after unknown group: "+id+" ("+expectedId+" expected)");
                    case ProtoBuf.WIRE_TYPES.BITS32:
                        buf.offset += 4;
                        break;
                    default:
                        throw Error("Illegal wire type in unknown group "+expectedId+": "+wireType);
                }
                return true;
            }

            /**
             * Decodes an encoded message and returns the decoded message.
             * @param {ByteBuffer} buffer ByteBuffer to decode from
             * @param {number=} length Message length. Defaults to decode all the available data.
             * @param {number=} expectedGroupEndId Expected GROUPEND id if this is a legacy group
             * @return {ProtoBuf.Builder.Message} Decoded message
             * @throws {Error} If the message cannot be decoded
             * @expose
             */
            Message.prototype.decode = function(buffer, length, expectedGroupEndId) {
                length = typeof length === 'number' ? length : -1;
                var start = buffer.offset;
                var msg = new (this.clazz)();
                var tag, wireType, id;
                while (buffer.offset < start+length || (length == -1 && buffer.remaining() > 0)) {
                    tag = buffer.readVarint32();
                    wireType = tag & 0x07;
                    id = tag >> 3;
                    if (wireType === ProtoBuf.WIRE_TYPES.ENDGROUP) {
                        if (id !== expectedGroupEndId)
                            throw Error("Illegal group end indicator for "+this.toString(true)+": "+id+" ("+(expectedGroupEndId ? expectedGroupEndId+" expected" : "not a group")+")");
                        break;
                    }
                    var field = this.getChild(id); // Message.Field only
                    if (!field) {
                        // "messages created by your new code can be parsed by your old code: old binaries simply ignore the new field when parsing."
                        switch (wireType) {
                            case ProtoBuf.WIRE_TYPES.VARINT:
                                buffer.readVarint32();
                                break;
                            case ProtoBuf.WIRE_TYPES.BITS32:
                                buffer.offset += 4;
                                break;
                            case ProtoBuf.WIRE_TYPES.BITS64:
                                buffer.offset += 8;
                                break;
                            case ProtoBuf.WIRE_TYPES.LDELIM:
                                var len = buffer.readVarint32();
                                buffer.offset += len;
                                break;
                            case ProtoBuf.WIRE_TYPES.STARTGROUP:
                                while (skipTillGroupEnd(id, buffer)) {}
                                break;
                            default:
                                throw Error("Illegal wire type for unknown field "+id+" in "+this.toString(true)+"#decode: "+wireType);
                        }
                        continue;
                    }
                    if (field.repeated && !field.options["packed"])
                        msg.$add(field.name, field.decode(wireType, buffer), true);
                    else
                        msg.$set(field.name, field.decode(wireType, buffer), true);
                }

                // Check if all required fields are present
                var fields = this.getChildren(ProtoBuf.Reflect.Field);
                for (var i=0; i<fields.length; i++)
                    if (fields[i].required && msg[fields[i].name] === null) {
                        var err = Error("Missing at least one required field for "+this.toString(true)+": "+fields[i].name);
                        err["decoded"] = msg; // Still expose what we got
                        throw(err);
                    }
                return msg;
            };

            /**
             * @alias ProtoBuf.Reflect.Message
             * @expose
             */
            Reflect.Message = Message;

            /**
             * Constructs a new Message Field.
             * @exports ProtoBuf.Reflect.Message.Field
             * @param {ProtoBuf.Reflect.Message} message Message reference
             * @param {string} rule Rule, one of requried, optional, repeated
             * @param {string} type Data type, e.g. int32
             * @param {string} name Field name
             * @param {number} id Unique field id
             * @param {Object.<string.*>=} options Options
             * @constructor
             * @extends ProtoBuf.Reflect.T
             */
            var Field = function(message, rule, type, name, id, options) {
                T.call(this, message, name);

                /**
                 * @override
                 */
                this.className = "Message.Field";

                /**
                 * Message field required flag.
                 * @type {boolean}
                 * @expose
                 */
                this.required = rule == "required";

                /**
                 * Message field repeated flag.
                 * @type {boolean}
                 * @expose
                 */
                this.repeated = rule == "repeated";

                /**
                 * Message field type. Type reference string if unresolved, protobuf type if resolved.
                 * @type {string|{name: string, wireType: number}}
                 * @expose
                 */
                this.type = type;

                /**
                 * Resolved type reference inside the global namespace.
                 * @type {ProtoBuf.Reflect.T|null}
                 * @expose
                 */
                this.resolvedType = null;

                /**
                 * Unique message field id.
                 * @type {number}
                 * @expose
                 */
                this.id = id;

                /**
                 * Message field options.
                 * @type {!Object.<string,*>}
                 * @dict
                 * @expose
                 */
                this.options = options || {};

                /**
                 * Original field name.
                 * @type {string}
                 * @expose
                 */
                this.originalName = this.name; // Used to revert camelcase transformation on naming collisions

                // Convert field names to camel case notation if the override is set
                if (ProtoBuf.convertFieldsToCamelCase) {
                    this.name = this.name.replace(/_([a-zA-Z])/g, function($0, $1) {
                        return $1.toUpperCase();
                    });
                }
            };

            // Extends T
            Field.prototype = Object.create(T.prototype);

            /**
             * Makes a Long from a value.
             * @param {{low: number, high: number, unsigned: boolean}|string|number} value Value
             * @param {boolean=} unsigned Whether unsigned or not, defaults to reuse it from Long-like objects or to signed for
             *  strings and numbers
             * @returns {!Long}
             * @throws {Error} If the value cannot be converted to a Long
             * @inner
             */
            function mkLong(value, unsigned) {
                if (value && typeof value.low === 'number' && typeof value.high === 'number' && typeof value.unsigned === 'boolean'
                    && value.low === value.low && value.high === value.high)
                    return new ProtoBuf.Long(value.low, value.high, typeof unsigned === 'undefined' ? value.unsigned : unsigned);
                if (typeof value === 'string')
                    return ProtoBuf.Long.fromString(value, unsigned || false, 10);
                if (typeof value === 'number')
                    return ProtoBuf.Long.fromNumber(value, unsigned || false);
                throw Error("not convertible to Long");
            }

            /**
             * Checks if the given value can be set for this field.
             * @param {*} value Value to check
             * @param {boolean=} skipRepeated Whether to skip the repeated value check or not. Defaults to false.
             * @return {*} Verified, maybe adjusted, value
             * @throws {Error} If the value cannot be set for this field
             * @expose
             */
            Field.prototype.verifyValue = function(value, skipRepeated) {
                skipRepeated = skipRepeated || false;
                var fail = function(val, msg) {
                    throw Error("Illegal value for "+this.toString(true)+" of type "+this.type.name+": "+val+" ("+msg+")");
                }.bind(this);
                if (value === null) { // NULL values for optional fields
                    if (this.required)
                        fail(typeof value, "required");
                    return null;
                }
                var i;
                if (this.repeated && !skipRepeated) { // Repeated values as arrays
                    if (!ProtoBuf.Util.isArray(value))
                        value = [value];
                    var res = [];
                    for (i=0; i<value.length; i++)
                        res.push(this.verifyValue(value[i], true));
                    return res;
                }
                // All non-repeated fields expect no array
                if (!this.repeated && ProtoBuf.Util.isArray(value))
                    fail(typeof value, "no array expected");

                switch (this.type) {
                    // Signed 32bit
                    case ProtoBuf.TYPES["int32"]:
                    case ProtoBuf.TYPES["sint32"]:
                    case ProtoBuf.TYPES["sfixed32"]:
                        // Account for !NaN: value === value
                        if (typeof value !== 'number' || (value === value && value % 1 !== 0))
                            fail(typeof value, "not an integer");
                        return value > 4294967295 ? value | 0 : value;

                    // Unsigned 32bit
                    case ProtoBuf.TYPES["uint32"]:
                    case ProtoBuf.TYPES["fixed32"]:
                        if (typeof value !== 'number' || (value === value && value % 1 !== 0))
                            fail(typeof value, "not an integer");
                        return value < 0 ? value >>> 0 : value;

                    // Signed 64bit
                    case ProtoBuf.TYPES["int64"]:
                    case ProtoBuf.TYPES["sint64"]:
                    case ProtoBuf.TYPES["sfixed64"]: {
                        if (ProtoBuf.Long)
                            try {
                                return mkLong(value, false);
                            } catch (e) {
                                fail(typeof value, e.message);
                            }
                        else
                            fail(typeof value, "requires Long.js");
                    }

                    // Unsigned 64bit
                    case ProtoBuf.TYPES["uint64"]:
                    case ProtoBuf.TYPES["fixed64"]: {
                        if (ProtoBuf.Long)
                            try {
                                return mkLong(value, true);
                            } catch (e) {
                                fail(typeof value, e.message);
                            }
                        else
                            fail(typeof value, "requires Long.js");
                    }

                    // Bool
                    case ProtoBuf.TYPES["bool"]:
                        if (typeof value !== 'boolean')
                            fail(typeof value, "not a boolean");
                        return value;

                    // Float
                    case ProtoBuf.TYPES["float"]:
                    case ProtoBuf.TYPES["double"]:
                        if (typeof value !== 'number')
                            fail(typeof value, "not a number");
                        return value;

                    // Length-delimited string
                    case ProtoBuf.TYPES["string"]:
                        if (typeof value !== 'string' && !(value && value instanceof String))
                            fail(typeof value, "not a string");
                        return ""+value; // Convert String object to string

                    // Length-delimited bytes
                    case ProtoBuf.TYPES["bytes"]:
                        return value && value instanceof ByteBuffer
                            ? value
                            : ByteBuffer.wrap(value);

                    // Constant enum value
                    case ProtoBuf.TYPES["enum"]: {
                        var values = this.resolvedType.getChildren(Enum.Value);
                        for (i=0; i<values.length; i++) {
                            if (values[i].name == value) {
                                return values[i].id;
                            } else if (values[i].id == value) {
                                return values[i].id;
                            }
                        }
                        fail(value, "not a valid enum value");
                    }
                    // Embedded message
                    case ProtoBuf.TYPES["group"]:
                    case ProtoBuf.TYPES["message"]: {
                        if (!value || typeof value !== 'object')
                            fail(typeof value, "object expected");
                        if (value instanceof this.resolvedType.clazz)
                            return value;
                        // Else let's try to construct one from a key-value object
                        return new (this.resolvedType.clazz)(value); // May throw for a hundred of reasons
                    }
                }

                // We should never end here
                throw Error("[INTERNAL] Illegal value for "+this.toString(true)+": "+value+" (undefined type "+this.type+")");
            };

            /**
             * Encodes the specified field value to the specified buffer.
             * @param {*} value Field value
             * @param {ByteBuffer} buffer ByteBuffer to encode to
             * @return {ByteBuffer} The ByteBuffer for chaining
             * @throws {Error} If the field cannot be encoded
             * @expose
             */
            Field.prototype.encode = function(value, buffer) {
                value = this.verifyValue(value); // May throw
                if (this.type === null || typeof this.type !== 'object')
                    throw Error("[INTERNAL] Unresolved type in "+this.toString(true)+": "+this.type);
                if (value === null || (this.repeated && value.length == 0))
                    return buffer; // Optional omitted
                try {
                    if (this.repeated) {
                        var i;
                        // "Only repeated fields of primitive numeric types (types which use the varint, 32-bit, or 64-bit wire
                        // types) can be declared 'packed'."
                        if (this.options["packed"] && ProtoBuf.PACKABLE_WIRE_TYPES.indexOf(this.type.wireType) >= 0) {
                            // "All of the elements of the field are packed into a single key-value pair with wire type 2
                            // (length-delimited). Each element is encoded the same way it would be normally, except without a
                            // tag preceding it."
                            buffer.writeVarint32((this.id << 3) | ProtoBuf.WIRE_TYPES.LDELIM);
                            buffer.ensureCapacity(buffer.offset += 1); // We do not know the length yet, so let's assume a varint of length 1
                            var start = buffer.offset; // Remember where the contents begin
                            for (i=0; i<value.length; i++)
                                this.encodeValue(value[i], buffer);
                            var len = buffer.offset-start;
                            var varintLen = ByteBuffer.calculateVarint32(len);
                            if (varintLen > 1) { // We need to move the contents
                                var contents = buffer.slice(start, buffer.offset);
                                start += varintLen-1;
                                buffer.offset = start;
                                buffer.append(contents);
                            }
                            buffer.writeVarint32(len, start-varintLen);
                        } else {
                            // "If your message definition has repeated elements (without the [packed=true] option), the encoded
                            // message has zero or more key-value pairs with the same tag number"
                            for (i=0; i<value.length; i++)
                                buffer.writeVarint32((this.id << 3) | this.type.wireType),
                                this.encodeValue(value[i], buffer);
                        }
                    } else
                        buffer.writeVarint32((this.id << 3) | this.type.wireType),
                        this.encodeValue(value, buffer);
                } catch (e) {
                    throw Error("Illegal value for "+this.toString(true)+": "+value+" ("+e+")");
                }
                return buffer;
            };

            /**
             * Encodes a value to the specified buffer. Does not encode the key.
             * @param {*} value Field value
             * @param {ByteBuffer} buffer ByteBuffer to encode to
             * @return {ByteBuffer} The ByteBuffer for chaining
             * @throws {Error} If the value cannot be encoded
             * @expose
             */
            Field.prototype.encodeValue = function(value, buffer) {
                if (value === null) return buffer; // Nothing to encode
                // Tag has already been written

                switch (this.type) {
                    // 32bit signed varint
                    case ProtoBuf.TYPES["int32"]:
                        // "If you use int32 or int64 as the type for a negative number, the resulting varint is always ten bytes
                        // long  it is, effectively, treated like a very large unsigned integer." (see #122)
                        if (value < 0)
                            buffer.writeVarint64(value);
                        else
                            buffer.writeVarint32(value);
                        break;

                    // 32bit unsigned varint
                    case ProtoBuf.TYPES["uint32"]:
                        buffer.writeVarint32(value);
                        break;

                    // 32bit varint zig-zag
                    case ProtoBuf.TYPES["sint32"]:
                        buffer.writeVarint32ZigZag(value);
                        break;

                    // Fixed unsigned 32bit
                    case ProtoBuf.TYPES["fixed32"]:
                        buffer.writeUint32(value);
                        break;

                    // Fixed signed 32bit
                    case ProtoBuf.TYPES["sfixed32"]:
                        buffer.writeInt32(value);
                        break;

                    // 64bit varint as-is
                    case ProtoBuf.TYPES["int64"]:
                    case ProtoBuf.TYPES["uint64"]:
                        buffer.writeVarint64(value); // throws
                        break;

                    // 64bit varint zig-zag
                    case ProtoBuf.TYPES["sint64"]:
                        buffer.writeVarint64ZigZag(value); // throws
                        break;

                    // Fixed unsigned 64bit
                    case ProtoBuf.TYPES["fixed64"]:
                        buffer.writeUint64(value); // throws
                        break;

                    // Fixed signed 64bit
                    case ProtoBuf.TYPES["sfixed64"]:
                        buffer.writeInt64(value); // throws
                        break;

                    // Bool
                    case ProtoBuf.TYPES["bool"]:
                        if (typeof value === 'string')
                            buffer.writeVarint32(value.toLowerCase() === 'false' ? 0 : !!value);
                        else
                            buffer.writeVarint32(value ? 1 : 0);
                        break;

                    // Constant enum value
                    case ProtoBuf.TYPES["enum"]:
                        buffer.writeVarint32(value);
                        break;

                    // 32bit float
                    case ProtoBuf.TYPES["float"]:
                        buffer.writeFloat32(value);
                        break;

                    // 64bit float
                    case ProtoBuf.TYPES["double"]:
                        buffer.writeFloat64(value);
                        break;

                    // Length-delimited string
                    case ProtoBuf.TYPES["string"]:
                        buffer.writeVString(value);
                        break;

                    // Length-delimited bytes
                    case ProtoBuf.TYPES["bytes"]:
                        if (value.remaining() < 0)
                            throw Error("Illegal value for "+this.toString(true)+": "+value.remaining()+" bytes remaining");
                        var prevOffset = value.offset;
                        buffer.writeVarint32(value.remaining());
                        buffer.append(value);
                        value.offset = prevOffset;
                        break;

                    // Embedded message
                    case ProtoBuf.TYPES["message"]:
                        var bb = new ByteBuffer().LE();
                        this.resolvedType.encode(value, bb);
                        buffer.writeVarint32(bb.offset);
                        buffer.append(bb.flip());
                        break;

                    // Legacy group
                    case ProtoBuf.TYPES["group"]:
                        this.resolvedType.encode(value, buffer);
                        buffer.writeVarint32((this.id << 3) | ProtoBuf.WIRE_TYPES.ENDGROUP);
                        break;

                    default:
                        // We should never end here
                        throw Error("[INTERNAL] Illegal value to encode in "+this.toString(true)+": "+value+" (unknown type)");
                }
                return buffer;
            };

            /**
             * Calculates the length of this field's value on the network level.
             * @param {*} value Field value
             * @returns {number} Byte length
             * @expose
             */
            Field.prototype.calculate = function(value) {
                value = this.verifyValue(value); // May throw
                if (this.type === null || typeof this.type !== 'object')
                    throw Error("[INTERNAL] Unresolved type in "+this.toString(true)+": "+this.type);
                if (value === null || (this.repeated && value.length == 0))
                    return 0; // Optional omitted
                var n = 0;
                try {
                    if (this.repeated) {
                        var i, ni;
                        if (this.options["packed"] && ProtoBuf.PACKABLE_WIRE_TYPES.indexOf(this.type.wireType) >= 0) {
                            n += ByteBuffer.calculateVarint32((this.id << 3) | ProtoBuf.WIRE_TYPES.LDELIM);
                            ni = 0;
                            for (i=0; i<value.length; i++)
                                ni += this.calculateValue(value[i]);
                            n += ByteBuffer.calculateVarint32(ni);
                            n += ni;
                        } else {
                            for (i=0; i<value.length; i++)
                                n += ByteBuffer.calculateVarint32((this.id << 3) | this.type.wireType),
                                n += this.calculateValue(value[i]);
                        }
                    } else {
                        n += ByteBuffer.calculateVarint32((this.id << 3) | this.type.wireType);
                        n += this.calculateValue(value);
                    }
                } catch (e) {
                    throw Error("Illegal value for "+this.toString(true)+": "+value+" ("+e+")");
                }
                return n;
            };

            /**
             * Calculates the byte length of a value.
             * @param {*} value Field value
             * @returns {number} Byte length
             * @throws {Error} If the value cannot be calculated
             * @expose
             */
            Field.prototype.calculateValue = function(value) {
                if (value === null) return 0; // Nothing to encode
                // Tag has already been written
                var n;
                switch (this.type) {
                    case ProtoBuf.TYPES["int32"]:
                        return value < 0 ? ByteBuffer.calculateVarint64(value) : ByteBuffer.calculateVarint32(value);
                    case ProtoBuf.TYPES["uint32"]:
                        return ByteBuffer.calculateVarint32(value);
                    case ProtoBuf.TYPES["sint32"]:
                        return ByteBuffer.calculateVarint32(ByteBuffer.zigZagEncode32(value));
                    case ProtoBuf.TYPES["fixed32"]:
                    case ProtoBuf.TYPES["sfixed32"]:
                    case ProtoBuf.TYPES["float"]:
                        return 4;
                    case ProtoBuf.TYPES["int64"]:
                    case ProtoBuf.TYPES["uint64"]:
                        return ByteBuffer.calculateVarint64(value);
                    case ProtoBuf.TYPES["sint64"]:
                        return ByteBuffer.calculateVarint64(ByteBuffer.zigZagEncode64(value));
                    case ProtoBuf.TYPES["fixed64"]:
                    case ProtoBuf.TYPES["sfixed64"]:
                        return 8;
                    case ProtoBuf.TYPES["bool"]:
                        return 1;
                    case ProtoBuf.TYPES["enum"]:
                        return ByteBuffer.calculateVarint32(value);
                    case ProtoBuf.TYPES["double"]:
                        return 8;
                    case ProtoBuf.TYPES["string"]:
                        n = ByteBuffer.calculateUTF8Bytes(value);
                        return ByteBuffer.calculateVarint32(n) + n;
                    case ProtoBuf.TYPES["bytes"]:
                        if (value.remaining() < 0)
                            throw Error("Illegal value for "+this.toString(true)+": "+value.remaining()+" bytes remaining");
                        return ByteBuffer.calculateVarint32(value.remaining()) + value.remaining();
                    case ProtoBuf.TYPES["message"]:
                        n = this.resolvedType.calculate(value);
                        return ByteBuffer.calculateVarint32(n) + n;
                    case ProtoBuf.TYPES["group"]:
                        n = this.resolvedType.calculate(value);
                        return n + ByteBuffer.calculateVarint32((this.id << 3) | ProtoBuf.WIRE_TYPES.ENDGROUP);
                }
                // We should never end here
                throw Error("[INTERNAL] Illegal value to encode in "+this.toString(true)+": "+value+" (unknown type)");
            };

            /**
             * Decode the field value from the specified buffer.
             * @param {number} wireType Leading wire type
             * @param {ByteBuffer} buffer ByteBuffer to decode from
             * @param {boolean=} skipRepeated Whether to skip the repeated check or not. Defaults to false.
             * @return {*} Decoded value
             * @throws {Error} If the field cannot be decoded
             * @expose
             */
            Field.prototype.decode = function(wireType, buffer, skipRepeated) {
                var value, nBytes;
                if (wireType != this.type.wireType && (skipRepeated || (wireType != ProtoBuf.WIRE_TYPES.LDELIM || !this.repeated)))
                    throw Error("Illegal wire type for field "+this.toString(true)+": "+wireType+" ("+this.type.wireType+" expected)");
                if (wireType == ProtoBuf.WIRE_TYPES.LDELIM && this.repeated && this.options["packed"]) {
                    if (!skipRepeated) {
                        nBytes = buffer.readVarint32();
                        nBytes = buffer.offset + nBytes; // Limit
                        var values = [];
                        while (buffer.offset < nBytes)
                            values.push(this.decode(this.type.wireType, buffer, true));
                        return values;
                    }
                    // Read the next value otherwise...
                }
                switch (this.type) {
                    // 32bit signed varint
                    case ProtoBuf.TYPES["int32"]:
                        return buffer.readVarint32() | 0;

                    // 32bit unsigned varint
                    case ProtoBuf.TYPES["uint32"]:
                        return buffer.readVarint32() >>> 0;

                    // 32bit signed varint zig-zag
                    case ProtoBuf.TYPES["sint32"]:
                        return buffer.readVarint32ZigZag() | 0;

                    // Fixed 32bit unsigned
                    case ProtoBuf.TYPES["fixed32"]:
                        return buffer.readUint32() >>> 0;

                    case ProtoBuf.TYPES["sfixed32"]:
                        return buffer.readInt32() | 0;

                    // 64bit signed varint
                    case ProtoBuf.TYPES["int64"]:
                        return buffer.readVarint64();

                    // 64bit unsigned varint
                    case ProtoBuf.TYPES["uint64"]:
                        return buffer.readVarint64().toUnsigned();

                    // 64bit signed varint zig-zag
                    case ProtoBuf.TYPES["sint64"]:
                        return buffer.readVarint64ZigZag();

                    // Fixed 64bit unsigned
                    case ProtoBuf.TYPES["fixed64"]:
                        return buffer.readUint64();

                    // Fixed 64bit signed
                    case ProtoBuf.TYPES["sfixed64"]:
                        return buffer.readInt64();

                    // Bool varint
                    case ProtoBuf.TYPES["bool"]:
                        return !!buffer.readVarint32();

                    // Constant enum value (varint)
                    case ProtoBuf.TYPES["enum"]:
                        // The following Builder.Message#set will already throw
                        return buffer.readVarint32();

                    // 32bit float
                    case ProtoBuf.TYPES["float"]:
                        return buffer.readFloat();

                    // 64bit float
                    case ProtoBuf.TYPES["double"]:
                        return buffer.readDouble();

                    // Length-delimited string
                    case ProtoBuf.TYPES["string"]:
                        return buffer.readVString();

                    // Length-delimited bytes
                    case ProtoBuf.TYPES["bytes"]: {
                        nBytes = buffer.readVarint32();
                        if (buffer.remaining() < nBytes)
                            throw Error("Illegal number of bytes for "+this.toString(true)+": "+nBytes+" required but got only "+buffer.remaining());
                        value = buffer.clone(); // Offset already set
                        value.limit = value.offset+nBytes;
                        buffer.offset += nBytes;
                        return value;
                    }

                    // Length-delimited embedded message
                    case ProtoBuf.TYPES["message"]: {
                        nBytes = buffer.readVarint32();
                        return this.resolvedType.decode(buffer, nBytes);
                    }

                    // Legacy group
                    case ProtoBuf.TYPES["group"]:
                        return this.resolvedType.decode(buffer, -1, this.id);
                }

                // We should never end here
                throw Error("[INTERNAL] Illegal wire type for "+this.toString(true)+": "+wireType);
            }

            /**
             * @alias ProtoBuf.Reflect.Message.Field
             * @expose
             */
            Reflect.Message.Field = Field;

            /**
             * Constructs a new Message ExtensionField.
             * @exports ProtoBuf.Reflect.Message.ExtensionField
             * @param {ProtoBuf.Reflect.Message} message Message reference
             * @param {string} rule Rule, one of requried, optional, repeated
             * @param {string} type Data type, e.g. int32
             * @param {string} name Field name
             * @param {number} id Unique field id
             * @param {Object.<string.*>=} options Options
             * @constructor
             * @extends ProtoBuf.Reflect.Message.Field
             */
            var ExtensionField = function(message, rule, type, name, id, options) {
                Field.call(this, message, rule, type, name, id, options);
            };

            // Extends Field
            ExtensionField.prototype = Object.create(Field.prototype);

            /**
             * @alias ProtoBuf.Reflect.Message.ExtensionField
             * @expose
             */
            Reflect.Message.ExtensionField = ExtensionField;

            /**
             * Constructs a new Enum.
             * @exports ProtoBuf.Reflect.Enum
             * @param {!ProtoBuf.Reflect.T} parent Parent Reflect object
             * @param {string} name Enum name
             * @param {Object.<string.*>=} options Enum options
             * @constructor
             * @extends ProtoBuf.Reflect.Namespace
             */
            var Enum = function(parent, name, options) {
                Namespace.call(this, parent, name, options);

                /**
                 * @override
                 */
                this.className = "Enum";

                /**
                 * Runtime enum object.
                 * @type {Object.<string,number>|null}
                 * @expose
                 */
                this.object = null;
            };

            // Extends Namespace
            Enum.prototype = Object.create(Namespace.prototype);

            /**
             * Builds this enum and returns the runtime counterpart.
             * @return {Object<string,*>}
             * @expose
             */
            Enum.prototype.build = function() {
                var enm = {};
                var values = this.getChildren(Enum.Value);
                for (var i=0; i<values.length; i++)
                    enm[values[i]['name']] = values[i]['id'];
                if (Object.defineProperty)
                    Object.defineProperty(enm, '$options', { "value": this.buildOpt() });
                return this.object = enm;
            };

            /**
             * @alias ProtoBuf.Reflect.Enum
             * @expose
             */
            Reflect.Enum = Enum;

            /**
             * Constructs a new Enum Value.
             * @exports ProtoBuf.Reflect.Enum.Value
             * @param {!ProtoBuf.Reflect.Enum} enm Enum reference
             * @param {string} name Field name
             * @param {number} id Unique field id
             * @constructor
             * @extends ProtoBuf.Reflect.T
             */
            var Value = function(enm, name, id) {
                T.call(this, enm, name);

                /**
                 * @override
                 */
                this.className = "Enum.Value";

                /**
                 * Unique enum value id.
                 * @type {number}
                 * @expose
                 */
                this.id = id;
            };

            // Extends T
            Value.prototype = Object.create(T.prototype);

            /**
             * @alias ProtoBuf.Reflect.Enum.Value
             * @expose
             */
            Reflect.Enum.Value = Value;

            /**
             * Constructs a new Service.
             * @exports ProtoBuf.Reflect.Service
             * @param {!ProtoBuf.Reflect.Namespace} root Root
             * @param {string} name Service name
             * @param {Object.<string,*>=} options Options
             * @constructor
             * @extends ProtoBuf.Reflect.Namespace
             */
            var Service = function(root, name, options) {
                Namespace.call(this, root, name, options);

                /**
                 * @override
                 */
                this.className = "Service";

                /**
                 * Built runtime service class.
                 * @type {?function(new:ProtoBuf.Builder.Service)}
                 */
                this.clazz = null;
            };

            // Extends Namespace
            Service.prototype = Object.create(Namespace.prototype);

            /**
             * Builds the service and returns the runtime counterpart, which is a fully functional class.
             * @see ProtoBuf.Builder.Service
             * @param {boolean=} rebuild Whether to rebuild or not
             * @return {Function} Service class
             * @throws {Error} If the message cannot be built
             * @expose
             */
            Service.prototype.build = function(rebuild) {
                if (this.clazz && !rebuild) return this.clazz;
                return this.clazz = (function(ProtoBuf, T) {

                    /**
                     * Constructs a new runtime Service.
                     * @name ProtoBuf.Builder.Service
                     * @param {function(string, ProtoBuf.Builder.Message, function(Error, ProtoBuf.Builder.Message=))=} rpcImpl RPC implementation receiving the method name and the message
                     * @class Barebone of all runtime services.
                     * @constructor
                     * @throws {Error} If the service cannot be created
                     */
                    var Service = function(rpcImpl) {
                        ProtoBuf.Builder.Service.call(this);

                        /**
                         * Service implementation.
                         * @name ProtoBuf.Builder.Service#rpcImpl
                         * @type {!function(string, ProtoBuf.Builder.Message, function(Error, ProtoBuf.Builder.Message=))}
                         * @expose
                         */
                        this.rpcImpl = rpcImpl || function(name, msg, callback) {
                            // This is what a user has to implement: A function receiving the method name, the actual message to
                            // send (type checked) and the callback that's either provided with the error as its first
                            // argument or null and the actual response message.
                            setTimeout(callback.bind(this, Error("Not implemented, see: https://github.com/dcodeIO/ProtoBuf.js/wiki/Services")), 0); // Must be async!
                        };
                    };

                    // Extends ProtoBuf.Builder.Service
                    Service.prototype = Object.create(ProtoBuf.Builder.Service.prototype);

                    if (Object.defineProperty)
                        Object.defineProperty(Service, "$options", { "value": T.buildOpt() }),
                        Object.defineProperty(Service.prototype, "$options", { "value": Service["$options"] });

                    /**
                     * Asynchronously performs an RPC call using the given RPC implementation.
                     * @name ProtoBuf.Builder.Service.[Method]
                     * @function
                     * @param {!function(string, ProtoBuf.Builder.Message, function(Error, ProtoBuf.Builder.Message=))} rpcImpl RPC implementation
                     * @param {ProtoBuf.Builder.Message} req Request
                     * @param {function(Error, (ProtoBuf.Builder.Message|ByteBuffer|Buffer|string)=)} callback Callback receiving
                     *  the error if any and the response either as a pre-parsed message or as its raw bytes
                     * @abstract
                     */

                    /**
                     * Asynchronously performs an RPC call using the instance's RPC implementation.
                     * @name ProtoBuf.Builder.Service#[Method]
                     * @function
                     * @param {ProtoBuf.Builder.Message} req Request
                     * @param {function(Error, (ProtoBuf.Builder.Message|ByteBuffer|Buffer|string)=)} callback Callback receiving
                     *  the error if any and the response either as a pre-parsed message or as its raw bytes
                     * @abstract
                     */

                    var rpc = T.getChildren(ProtoBuf.Reflect.Service.RPCMethod);
                    for (var i=0; i<rpc.length; i++) {
                        (function(method) {

                            // service#Method(message, callback)
                            Service.prototype[method.name] = function(req, callback) {
                                try {
                                    if (!req || !(req instanceof method.resolvedRequestType.clazz)) {
                                        setTimeout(callback.bind(this, Error("Illegal request type provided to service method "+T.name+"#"+method.name)), 0);
                                        return;
                                    }
                                    this.rpcImpl(method.fqn(), req, function(err, res) { // Assumes that this is properly async
                                        if (err) {
                                            callback(err);
                                            return;
                                        }
                                        try { res = method.resolvedResponseType.clazz.decode(res); } catch (notABuffer) {}
                                        if (!res || !(res instanceof method.resolvedResponseType.clazz)) {
                                            callback(Error("Illegal response type received in service method "+ T.name+"#"+method.name));
                                            return;
                                        }
                                        callback(null, res);
                                    });
                                } catch (err) {
                                    setTimeout(callback.bind(this, err), 0);
                                }
                            };

                            // Service.Method(rpcImpl, message, callback)
                            Service[method.name] = function(rpcImpl, req, callback) {
                                new Service(rpcImpl)[method.name](req, callback);
                            };

                            if (Object.defineProperty)
                                Object.defineProperty(Service[method.name], "$options", { "value": method.buildOpt() }),
                                Object.defineProperty(Service.prototype[method.name], "$options", { "value": Service[method.name]["$options"] });
                        })(rpc[i]);
                    }

                    return Service;

                })(ProtoBuf, this);
            };

            /**
             * @alias ProtoBuf.Reflect.Service
             * @expose
             */
            Reflect.Service = Service;

            /**
             * Abstract service method.
             * @exports ProtoBuf.Reflect.Service.Method
             * @param {!ProtoBuf.Reflect.Service} svc Service
             * @param {string} name Method name
             * @param {Object.<string,*>=} options Options
             * @constructor
             * @extends ProtoBuf.Reflect.T
             */
            var Method = function(svc, name, options) {
                T.call(this, svc, name);

                /**
                 * @override
                 */
                this.className = "Service.Method";

                /**
                 * Options.
                 * @type {Object.<string, *>}
                 * @expose
                 */
                this.options = options || {};
            };

            // Extends T
            Method.prototype = Object.create(T.prototype);

            /**
             * Builds the method's '$options' property.
             * @name ProtoBuf.Reflect.Service.Method#buildOpt
             * @function
             * @return {Object.<string,*>}
             */
            Method.prototype.buildOpt = Namespace.prototype.buildOpt;

            /**
             * @alias ProtoBuf.Reflect.Service.Method
             * @expose
             */
            Reflect.Service.Method = Method;

            /**
             * RPC service method.
             * @exports ProtoBuf.Reflect.Service.RPCMethod
             * @param {!ProtoBuf.Reflect.Service} svc Service
             * @param {string} name Method name
             * @param {string} request Request message name
             * @param {string} response Response message name
             * @param {Object.<string,*>=} options Options
             * @constructor
             * @extends ProtoBuf.Reflect.Service.Method
             */
            var RPCMethod = function(svc, name, request, response, options) {
                Method.call(this, svc, name, options);

                /**
                 * @override
                 */
                this.className = "Service.RPCMethod";

                /**
                 * Request message name.
                 * @type {string}
                 * @expose
                 */
                this.requestName = request;

                /**
                 * Response message name.
                 * @type {string}
                 * @expose
                 */
                this.responseName = response;

                /**
                 * Resolved request message type.
                 * @type {ProtoBuf.Reflect.Message}
                 * @expose
                 */
                this.resolvedRequestType = null;

                /**
                 * Resolved response message type.
                 * @type {ProtoBuf.Reflect.Message}
                 * @expose
                 */
                this.resolvedResponseType = null;
            };

            // Extends Method
            RPCMethod.prototype = Object.create(Method.prototype);

            /**
             * @alias ProtoBuf.Reflect.Service.RPCMethod
             * @expose
             */
            Reflect.Service.RPCMethod = RPCMethod;

            return Reflect;
        })(ProtoBuf);

        /**
         * @alias ProtoBuf.Builder
         * @expose
         */
        ProtoBuf.Builder = (function(ProtoBuf, Lang, Reflect) {
            "use strict";

            /**
             * Constructs a new Builder.
             * @exports ProtoBuf.Builder
             * @class Provides the functionality to build protocol messages.
             * @constructor
             */
            var Builder = function() {

                /**
                 * Namespace.
                 * @type {ProtoBuf.Reflect.Namespace}
                 * @expose
                 */
                this.ns = new Reflect.Namespace(null, ""); // Global namespace

                /**
                 * Namespace pointer.
                 * @type {ProtoBuf.Reflect.T}
                 * @expose
                 */
                this.ptr = this.ns;

                /**
                 * Resolved flag.
                 * @type {boolean}
                 * @expose
                 */
                this.resolved = false;

                /**
                 * The current building result.
                 * @type {Object.<string,ProtoBuf.Builder.Message|Object>|null}
                 * @expose
                 */
                this.result = null;

                /**
                 * Imported files.
                 * @type {Array.<string>}
                 * @expose
                 */
                this.files = {};

                /**
                 * Import root override.
                 * @type {?string}
                 * @expose
                 */
                this.importRoot = null;
            };

            /**
             * Resets the pointer to the root namespace.
             * @expose
             */
            Builder.prototype.reset = function() {
                this.ptr = this.ns;
            };

            /**
             * Defines a package on top of the current pointer position and places the pointer on it.
             * @param {string} pkg
             * @param {Object.<string,*>=} options
             * @return {ProtoBuf.Builder} this
             * @throws {Error} If the package name is invalid
             * @expose
             */
            Builder.prototype.define = function(pkg, options) {
                if (typeof pkg !== 'string' || !Lang.TYPEREF.test(pkg))
                    throw Error("Illegal package: "+pkg);
                var part = pkg.split("."), i;
                for (i=0; i<part.length; i++) // To be absolutely sure
                    if (!Lang.NAME.test(part[i]))
                        throw Error("Illegal package: "+part[i]);
                for (i=0; i<part.length; i++) {
                    if (!this.ptr.hasChild(part[i])) // Keep existing namespace
                        this.ptr.addChild(new Reflect.Namespace(this.ptr, part[i], options));
                    this.ptr = this.ptr.getChild(part[i]);
                }
                return this;
            };

            /**
             * Tests if a definition is a valid message definition.
             * @param {Object.<string,*>} def Definition
             * @return {boolean} true if valid, else false
             * @expose
             */
            Builder.isValidMessage = function(def) {
                // Messages require a string name
                if (typeof def["name"] !== 'string' || !Lang.NAME.test(def["name"]))
                    return false;
                // Messages must not contain values (that'd be an enum) or methods (that'd be a service)
                if (typeof def["values"] !== 'undefined' || typeof def["rpc"] !== 'undefined')
                    return false;
                // Fields, enums and messages are arrays if provided
                var i;
                if (typeof def["fields"] !== 'undefined') {
                    if (!ProtoBuf.Util.isArray(def["fields"]))
                        return false;
                    var ids = [], id; // IDs must be unique
                    for (i=0; i<def["fields"].length; i++) {
                        if (!Builder.isValidMessageField(def["fields"][i]))
                            return false;
                        id = parseInt(def["fields"][i]["id"], 10);
                        if (ids.indexOf(id) >= 0)
                            return false;
                        ids.push(id);
                    }
                    ids = null;
                }
                if (typeof def["enums"] !== 'undefined') {
                    if (!ProtoBuf.Util.isArray(def["enums"]))
                        return false;
                    for (i=0; i<def["enums"].length; i++)
                        if (!Builder.isValidEnum(def["enums"][i]))
                            return false;
                }
                if (typeof def["messages"] !== 'undefined') {
                    if (!ProtoBuf.Util.isArray(def["messages"]))
                        return false;
                    for (i=0; i<def["messages"].length; i++)
                        if (!Builder.isValidMessage(def["messages"][i]) && !Builder.isValidExtend(def["messages"][i]))
                            return false;
                }
                if (typeof def["extensions"] !== 'undefined')
                    if (!ProtoBuf.Util.isArray(def["extensions"]) || def["extensions"].length !== 2 || typeof def["extensions"][0] !== 'number' || typeof def["extensions"][1] !== 'number')
                        return false;
                return true;
            };

            /**
             * Tests if a definition is a valid message field definition.
             * @param {Object} def Definition
             * @return {boolean} true if valid, else false
             * @expose
             */
            Builder.isValidMessageField = function(def) {
                // Message fields require a string rule, name and type and an id
                if (typeof def["rule"] !== 'string' || typeof def["name"] !== 'string' || typeof def["type"] !== 'string' || typeof def["id"] === 'undefined')
                    return false;
                if (!Lang.RULE.test(def["rule"]) || !Lang.NAME.test(def["name"]) || !Lang.TYPEREF.test(def["type"]) || !Lang.ID.test(""+def["id"]))
                    return false;
                if (typeof def["options"] !== 'undefined') {
                    // Options are objects
                    if (typeof def["options"] !== 'object')
                        return false;
                    // Options are <string,string|number|boolean>
                    var keys = Object.keys(def["options"]);
                    for (var i=0, key; i<keys.length; i++)
                        if (typeof (key = keys[i]) !== 'string' || (typeof def["options"][key] !== 'string' && typeof def["options"][key] !== 'number' && typeof def["options"][key] !== 'boolean'))
                            return false;
                }
                return true;
            };

            /**
             * Tests if a definition is a valid enum definition.
             * @param {Object} def Definition
             * @return {boolean} true if valid, else false
             * @expose
             */
            Builder.isValidEnum = function(def) {
                // Enums require a string name
                if (typeof def["name"] !== 'string' || !Lang.NAME.test(def["name"]))
                    return false;
                // Enums require at least one value
                if (typeof def["values"] === 'undefined' || !ProtoBuf.Util.isArray(def["values"]) || def["values"].length == 0)
                    return false;
                for (var i=0; i<def["values"].length; i++) {
                    // Values are objects
                    if (typeof def["values"][i] != "object")
                        return false;
                    // Values require a string name and an id
                    if (typeof def["values"][i]["name"] !== 'string' || typeof def["values"][i]["id"] === 'undefined')
                        return false;
                    if (!Lang.NAME.test(def["values"][i]["name"]) || !Lang.NEGID.test(""+def["values"][i]["id"]))
                        return false;
                }
                // It's not important if there are other fields because ["values"] is already unique
                return true;
            };

            /**
             * Creates ths specified protocol types at the current pointer position.
             * @param {Array.<Object.<string,*>>} defs Messages, enums or services to create
             * @return {ProtoBuf.Builder} this
             * @throws {Error} If a message definition is invalid
             * @expose
             */
            Builder.prototype.create = function(defs) {
                if (!defs)
                    return this; // Nothing to create
                if (!ProtoBuf.Util.isArray(defs))
                    defs = [defs];
                if (defs.length == 0)
                    return this;

                // It's quite hard to keep track of scopes and memory here, so let's do this iteratively.
                var stack = [], def, obj, subObj, i, j;
                stack.push(defs); // One level [a, b, c]
                while (stack.length > 0) {
                    defs = stack.pop();
                    if (ProtoBuf.Util.isArray(defs)) { // Stack always contains entire namespaces
                        while (defs.length > 0) {
                            def = defs.shift(); // Namespace always contains an array of messages, enums and services
                            if (Builder.isValidMessage(def)) {
                                obj = new Reflect.Message(this.ptr, def["name"], def["options"], def["isGroup"]);
                                // Create fields
                                if (def["fields"] && def["fields"].length > 0) {
                                    for (i=0; i<def["fields"].length; i++) { // i=Fields
                                        if (obj.hasChild(def['fields'][i]['id']))
                                            throw Error("Duplicate field id in message "+obj.name+": "+def['fields'][i]['id']);
                                        if (def["fields"][i]["options"]) {
                                            subObj = Object.keys(def["fields"][i]["options"]);
                                            for (j=0; j<subObj.length; j++) { // j=Option names
                                                if (typeof subObj[j] !== 'string')
                                                    throw Error("Illegal field option name in message "+obj.name+"#"+def["fields"][i]["name"]+": "+subObj[j]);
                                                if (typeof def["fields"][i]["options"][subObj[j]] !== 'string' && typeof def["fields"][i]["options"][subObj[j]] !== 'number' && typeof def["fields"][i]["options"][subObj[j]] !== 'boolean')
                                                    throw Error("Illegal field option value in message "+obj.name+"#"+def["fields"][i]["name"]+"#"+subObj[j]+": "+def["fields"][i]["options"][subObj[j]]);
                                            }
                                            subObj = null;
                                        }
                                        obj.addChild(new Reflect.Message.Field(obj, def["fields"][i]["rule"], def["fields"][i]["type"], def["fields"][i]["name"], def["fields"][i]["id"], def["fields"][i]["options"]));
                                    }
                                }
                                // Push enums and messages to stack
                                subObj = [];
                                if (typeof def["enums"] !== 'undefined' && def['enums'].length > 0)
                                    for (i=0; i<def["enums"].length; i++)
                                        subObj.push(def["enums"][i]);
                                if (def["messages"] && def["messages"].length > 0)
                                    for (i=0; i<def["messages"].length; i++)
                                        subObj.push(def["messages"][i]);
                                // Set extension range
                                if (def["extensions"]) {
                                    obj.extensions = def["extensions"];
                                    if (obj.extensions[0] < ProtoBuf.ID_MIN)
                                        obj.extensions[0] = ProtoBuf.ID_MIN;
                                    if (obj.extensions[1] > ProtoBuf.ID_MAX)
                                        obj.extensions[1] = ProtoBuf.ID_MAX;
                                }
                                this.ptr.addChild(obj); // Add to current namespace
                                if (subObj.length > 0) {
                                    stack.push(defs); // Push the current level back
                                    defs = subObj; // Continue processing sub level
                                    subObj = null;
                                    this.ptr = obj; // And move the pointer to this namespace
                                    obj = null;
                                    continue;
                                }
                                subObj = null;
                                obj = null;
                            } else if (Builder.isValidEnum(def)) {
                                obj = new Reflect.Enum(this.ptr, def["name"], def["options"]);
                                for (i=0; i<def["values"].length; i++)
                                    obj.addChild(new Reflect.Enum.Value(obj, def["values"][i]["name"], def["values"][i]["id"]));
                                this.ptr.addChild(obj);
                                obj = null;
                            } else if (Builder.isValidService(def)) {
                                obj = new Reflect.Service(this.ptr, def["name"], def["options"]);
                                for (i in def["rpc"])
                                    if (def["rpc"].hasOwnProperty(i))
                                        obj.addChild(new Reflect.Service.RPCMethod(obj, i, def["rpc"][i]["request"], def["rpc"][i]["response"], def["rpc"][i]["options"]));
                                this.ptr.addChild(obj);
                                obj = null;
                            } else if (Builder.isValidExtend(def)) {
                                obj = this.ptr.resolve(def["ref"]);
                                if (obj) {
                                    for (i=0; i<def["fields"].length; i++) { // i=Fields
                                        if (obj.hasChild(def['fields'][i]['id']))
                                            throw Error("Duplicate extended field id in message "+obj.name+": "+def['fields'][i]['id']);
                                        if (def['fields'][i]['id'] < obj.extensions[0] || def['fields'][i]['id'] > obj.extensions[1])
                                            throw Error("Illegal extended field id in message "+obj.name+": "+def['fields'][i]['id']+" ("+obj.extensions.join(' to ')+" expected)");
                                        // TODO: See #161
                                        /* subObj = new (this.ptr instanceof Reflect.Message ? Reflect.Message.ExtensionField : Reflect.Message.Field)(obj, def["fields"][i]["rule"], def["fields"][i]["type"], def["fields"][i]["name"], def["fields"][i]["id"], def["fields"][i]["options"]);
                                        if (this.ptr instanceof Reflect.Message)
                                            this.ptr.addChild(subObj);
                                        else
                                            obj.addChild(subObj); */
                                        obj.addChild(new Reflect.Message.Field(obj, def["fields"][i]["rule"], def["fields"][i]["type"], def["fields"][i]["name"], def["fields"][i]["id"], def["fields"][i]["options"]));
                                    }
                                } else if (!/\.?google\.protobuf\./.test(def["ref"])) // Silently skip internal extensions
                                    throw Error("Extended message "+def["ref"]+" is not defined");
                            } else
                                throw Error("Not a valid definition: "+JSON.stringify(def));
                            def = null;
                        }
                        // Break goes here
                    } else
                        throw Error("Not a valid namespace: "+JSON.stringify(defs));
                    defs = null;
                    this.ptr = this.ptr.parent; // This namespace is s done
                }
                this.resolved = false; // Require re-resolve
                this.result = null; // Require re-build
                return this;
            };

            /**
             * Imports another definition into this builder.
             * @param {Object.<string,*>} json Parsed import
             * @param {(string|{root: string, file: string})=} filename Imported file name
             * @return {ProtoBuf.Builder} this
             * @throws {Error} If the definition or file cannot be imported
             * @expose
             */
            Builder.prototype["import"] = function(json, filename) {
                if (typeof filename === 'string') {
                    if (ProtoBuf.Util.IS_NODE)
                        filename = require("path")['resolve'](filename);
                    if (this.files[filename] === true) {
                        this.reset();
                        return this; // Skip duplicate imports
                    }
                    this.files[filename] = true;
                }
                if (!!json['imports'] && json['imports'].length > 0) {
                    var importRoot, delim = '/', resetRoot = false;
                    if (typeof filename === 'object') { // If an import root is specified, override
                        this.importRoot = filename["root"]; resetRoot = true; // ... and reset afterwards
                        importRoot = this.importRoot;
                        filename = filename["file"];
                        if (importRoot.indexOf("\\") >= 0 || filename.indexOf("\\") >= 0) delim = '\\';
                    } else if (typeof filename === 'string') {
                        if (this.importRoot) // If import root is overridden, use it
                            importRoot = this.importRoot;
                        else { // Otherwise compute from filename
                            if (filename.indexOf("/") >= 0) { // Unix
                                importRoot = filename.replace(/\/[^\/]*$/, "");
                                if (/* /file.proto */ importRoot === "")
                                    importRoot = "/";
                            } else if (filename.indexOf("\\") >= 0) { // Windows
                                importRoot = filename.replace(/\\[^\\]*$/, "");
                                delim = '\\';
                            } else
                                importRoot = ".";
                        }
                    } else
                        importRoot = null;

                    for (var i=0; i<json['imports'].length; i++) {
                        if (typeof json['imports'][i] === 'string') { // Import file
                            if (!importRoot)
                                throw Error("Cannot determine import root: File name is unknown");
                            var importFilename = json['imports'][i];
                            if (/^google\/protobuf\//.test(importFilename))
                                continue; // Not needed and therefore not used
                            importFilename = importRoot+delim+importFilename;
                            if (this.files[importFilename] === true)
                                continue; // Already imported
                            if (/\.proto$/i.test(importFilename) && !ProtoBuf.DotProto)     // If this is a NOPARSE build
                                importFilename = importFilename.replace(/\.proto$/, ".json"); // always load the JSON file
                            var contents = ProtoBuf.Util.fetch(importFilename);
                            if (contents === null)
                                throw Error("Failed to import '"+importFilename+"' in '"+filename+"': File not found");
                            if (/\.json$/i.test(importFilename)) // Always possible
                                this["import"](JSON.parse(contents+""), importFilename); // May throw
                            else
                                this["import"]((new ProtoBuf.DotProto.Parser(contents+"")).parse(), importFilename); // May throw
                        } else // Import structure
                            if (!filename)
                                this["import"](json['imports'][i]);
                            else if (/\.(\w+)$/.test(filename)) // With extension: Append _importN to the name portion to make it unique
                                this["import"](json['imports'][i], filename.replace(/^(.+)\.(\w+)$/, function($0, $1, $2) { return $1+"_import"+i+"."+$2; }));
                            else // Without extension: Append _importN to make it unique
                                this["import"](json['imports'][i], filename+"_import"+i);
                    }
                    if (resetRoot) // Reset import root override when all imports are done
                        this.importRoot = null;
                }
                if (json['messages']) {
                    if (json['package'])
                        this.define(json['package'], json["options"]);
                    this.create(json['messages']);
                    this.reset();
                }
                if (json['enums']) {
                    if (json['package'])
                        this.define(json['package'], json["options"]);
                    this.create(json['enums']);
                    this.reset();
                }
                if (json['services']) {
                    if (json['package'])
                        this.define(json['package'], json["options"]);
                    this.create(json['services']);
                    this.reset();
                }
                if (json['extends']) {
                    if (json['package'])
                        this.define(json['package'], json["options"]);
                    this.create(json['extends']);
                    this.reset();
                }
                return this;
            };

            /**
             * Tests if a definition is a valid service definition.
             * @param {Object} def Definition
             * @return {boolean} true if valid, else false
             * @expose
             */
            Builder.isValidService = function(def) {
                // Services require a string name and an rpc object
                return !(typeof def["name"] !== 'string' || !Lang.NAME.test(def["name"]) || typeof def["rpc"] !== 'object');
            };

            /**
             * Tests if a definition is a valid extension.
             * @param {Object} def Definition
             * @returns {boolean} true if valid, else false
             * @expose
            */
            Builder.isValidExtend = function(def) {
                if (typeof def["ref"] !== 'string' || !Lang.TYPEREF.test(def["ref"]))
                    return false;
                var i;
                if (typeof def["fields"] !== 'undefined') {
                    if (!ProtoBuf.Util.isArray(def["fields"]))
                        return false;
                    var ids = [], id; // IDs must be unique (does not yet test for the extended message's ids)
                    for (i=0; i<def["fields"].length; i++) {
                        if (!Builder.isValidMessageField(def["fields"][i]))
                            return false;
                        id = parseInt(def["id"], 10);
                        if (ids.indexOf(id) >= 0)
                            return false;
                        ids.push(id);
                    }
                    ids = null;
                }
                return true;
            };

            /**
             * Resolves all namespace objects.
             * @throws {Error} If a type cannot be resolved
             * @expose
             */
            Builder.prototype.resolveAll = function() {
                // Resolve all reflected objects
                var res;
                if (this.ptr == null || typeof this.ptr.type === 'object')
                    return; // Done (already resolved)
                if (this.ptr instanceof Reflect.Namespace) {
                    // Build all children
                    var children = this.ptr.getChildren();
                    for (var i=0; i<children.length; i++)
                        this.ptr = children[i], this.resolveAll();
                } else if (this.ptr instanceof Reflect.Message.Field) {
                    if (!Lang.TYPE.test(this.ptr.type)) { // Resolve type...
                        if (!Lang.TYPEREF.test(this.ptr.type))
                            throw Error("Illegal type reference in "+this.ptr.toString(true)+": "+this.ptr.type);
                        res = this.ptr.parent.resolve(this.ptr.type, true);
                        if (!res)
                            throw Error("Unresolvable type reference in "+this.ptr.toString(true)+": "+this.ptr.type);
                        this.ptr.resolvedType = res;
                        if (res instanceof Reflect.Enum)
                            this.ptr.type = ProtoBuf.TYPES["enum"];
                        else if (res instanceof Reflect.Message)
                            this.ptr.type = res.isGroup ? ProtoBuf.TYPES["group"] : ProtoBuf.TYPES["message"];
                        else
                            throw Error("Illegal type reference in "+this.ptr.toString(true)+": "+this.ptr.type);
                    } else
                        this.ptr.type = ProtoBuf.TYPES[this.ptr.type];
                } else if (this.ptr instanceof ProtoBuf.Reflect.Enum.Value) {
                    // No need to build enum values (built in enum)
                } else if (this.ptr instanceof ProtoBuf.Reflect.Service.Method) {
                    if (this.ptr instanceof ProtoBuf.Reflect.Service.RPCMethod) {
                        res = this.ptr.parent.resolve(this.ptr.requestName);
                        if (!res || !(res instanceof ProtoBuf.Reflect.Message))
                            throw Error("Illegal type reference in "+this.ptr.toString(true)+": "+this.ptr.requestName);
                        this.ptr.resolvedRequestType = res;
                        res = this.ptr.parent.resolve(this.ptr.responseName);
                        if (!res || !(res instanceof ProtoBuf.Reflect.Message))
                            throw Error("Illegal type reference in "+this.ptr.toString(true)+": "+this.ptr.responseName);
                        this.ptr.resolvedResponseType = res;
                    } else {
                        // Should not happen as nothing else is implemented
                        throw Error("Illegal service type in "+this.ptr.toString(true));
                    }
                } else
                    throw Error("Illegal object in namespace: "+typeof(this.ptr)+":"+this.ptr);
                this.reset();
            };

            /**
             * Builds the protocol. This will first try to resolve all definitions and, if this has been successful,
             * return the built package.
             * @param {string=} path Specifies what to return. If omitted, the entire namespace will be returned.
             * @return {ProtoBuf.Builder.Message|Object.<string,*>}
             * @throws {Error} If a type could not be resolved
             * @expose
             */
            Builder.prototype.build = function(path) {
                this.reset();
                if (!this.resolved)
                    this.resolveAll(),
                    this.resolved = true,
                    this.result = null; // Require re-build
                if (this.result == null) // (Re-)Build
                    this.result = this.ns.build();
                if (!path)
                    return this.result;
                else {
                    var part = path.split(".");
                    var ptr = this.result; // Build namespace pointer (no hasChild etc.)
                    for (var i=0; i<part.length; i++)
                        if (ptr[part[i]])
                            ptr = ptr[part[i]];
                        else {
                            ptr = null;
                            break;
                        }
                    return ptr;
                }
            };

            /**
             * Similar to {@link ProtoBuf.Builder#build}, but looks up the internal reflection descriptor.
             * @param {string=} path Specifies what to return. If omitted, the entire namespace wiil be returned.
             * @return {ProtoBuf.Reflect.T} Reflection descriptor or `null` if not found
             */
            Builder.prototype.lookup = function(path) {
                return path ? this.ns.resolve(path) : this.ns;
            };

            /**
             * Returns a string representation of this object.
             * @return {string} String representation as of "Builder"
             * @expose
             */
            Builder.prototype.toString = function() {
                return "Builder";
            };

            // Pseudo types documented in Reflect.js.
            // Exist for the sole purpose of being able to "... instanceof ProtoBuf.Builder.Message" etc.
            Builder.Message = function() {};
            Builder.Service = function() {};

            return Builder;

        })(ProtoBuf, ProtoBuf.Lang, ProtoBuf.Reflect);


        /**
         * Loads a .proto string and returns the Builder.
         * @param {string} proto .proto file contents
         * @param {(ProtoBuf.Builder|string|{root: string, file: string})=} builder Builder to append to. Will create a new one if omitted.
         * @param {(string|{root: string, file: string})=} filename The corresponding file name if known. Must be specified for imports.
         * @return {ProtoBuf.Builder} Builder to create new messages
         * @throws {Error} If the definition cannot be parsed or built
         * @expose
         */
        ProtoBuf.loadProto = function(proto, builder, filename) {
            if (typeof builder === 'string' || (builder && typeof builder["file"] === 'string' && typeof builder["root"] === 'string')) {
                filename = builder;
                builder = null;
            }
            return ProtoBuf.loadJson((new ProtoBuf.DotProto.Parser(proto)).parse(), builder, filename);
        };

        /**
         * Loads a .proto string and returns the Builder. This is an alias of {@link ProtoBuf.loadProto}.
         * @function
         * @param {string} proto .proto file contents
         * @param {(ProtoBuf.Builder|string)=} builder Builder to append to. Will create a new one if omitted.
         * @param {(string|{root: string, file: string})=} filename The corresponding file name if known. Must be specified for imports.
         * @return {ProtoBuf.Builder} Builder to create new messages
         * @throws {Error} If the definition cannot be parsed or built
         * @expose
         */
        ProtoBuf.protoFromString = ProtoBuf.loadProto; // Legacy

        /**
         * Loads a .proto file and returns the Builder.
         * @param {string|{root: string, file: string}} filename Path to proto file or an object specifying 'file' with
         *  an overridden 'root' path for all imported files.
         * @param {function(?Error, !ProtoBuf.Builder=)=} callback Callback that will receive `null` as the first and
         *  the Builder as its second argument on success, otherwise the error as its first argument. If omitted, the
         *  file will be read synchronously and this function will return the Builder.
         * @param {ProtoBuf.Builder=} builder Builder to append to. Will create a new one if omitted.
         * @return {?ProtoBuf.Builder|undefined} The Builder if synchronous (no callback specified, will be NULL if the
         *   request has failed), else undefined
         * @expose
         */
        ProtoBuf.loadProtoFile = function(filename, callback, builder) {
            if (callback && typeof callback === 'object')
                builder = callback,
                callback = null;
            else if (!callback || typeof callback !== 'function')
                callback = null;
            if (callback)
                return ProtoBuf.Util.fetch(typeof filename === 'string' ? filename : filename["root"]+"/"+filename["file"], function(contents) {
                    if (contents === null) {
                        callback(Error("Failed to fetch file"));
                        return;
                    }
                    try {
                        callback(null, ProtoBuf.loadProto(contents, builder, filename));
                    } catch (e) {
                        callback(e);
                    }
                });
            var contents = ProtoBuf.Util.fetch(typeof filename === 'object' ? filename["root"]+"/"+filename["file"] : filename);
            return contents === null ? null : ProtoBuf.loadProto(contents, builder, filename);
        };

        /**
         * Loads a .proto file and returns the Builder. This is an alias of {@link ProtoBuf.loadProtoFile}.
         * @function
         * @param {string|{root: string, file: string}} filename Path to proto file or an object specifying 'file' with
         *  an overridden 'root' path for all imported files.
         * @param {function(?Error, !ProtoBuf.Builder=)=} callback Callback that will receive `null` as the first and
         *  the Builder as its second argument on success, otherwise the error as its first argument. If omitted, the
         *  file will be read synchronously and this function will return the Builder.
         * @param {ProtoBuf.Builder=} builder Builder to append to. Will create a new one if omitted.
         * @return {!ProtoBuf.Builder|undefined} The Builder if synchronous (no callback specified, will be NULL if the
         *   request has failed), else undefined
         * @expose
         */
        ProtoBuf.protoFromFile = ProtoBuf.loadProtoFile; // Legacy


        /**
         * Constructs a new Builder with the specified package defined.
         * @param {string=} pkg Package name as fully qualified name, e.g. "My.Game". If no package is specified, the
         * builder will only contain a global namespace.
         * @param {Object.<string,*>=} options Top level options
         * @return {ProtoBuf.Builder} New Builder
         * @expose
         */
        ProtoBuf.newBuilder = function(pkg, options) {
            var builder = new ProtoBuf.Builder();
            if (typeof pkg !== 'undefined' && pkg !== null)
                builder.define(pkg, options);
            return builder;
        };

        /**
         * Loads a .json definition and returns the Builder.
         * @param {!*|string} json JSON definition
         * @param {(ProtoBuf.Builder|string|{root: string, file: string})=} builder Builder to append to. Will create a new one if omitted.
         * @param {(string|{root: string, file: string})=} filename The corresponding file name if known. Must be specified for imports.
         * @return {ProtoBuf.Builder} Builder to create new messages
         * @throws {Error} If the definition cannot be parsed or built
         * @expose
         */
        ProtoBuf.loadJson = function(json, builder, filename) {
            if (typeof builder === 'string' || (builder && typeof builder["file"] === 'string' && typeof builder["root"] === 'string'))
                filename = builder,
                builder = null;
            if (!builder || typeof builder !== 'object')
                builder = ProtoBuf.newBuilder();
            if (typeof json === 'string')
                json = JSON.parse(json);
            builder["import"](json, filename);
            builder.resolveAll();
            builder.build();
            return builder;
        };

        /**
         * Loads a .json file and returns the Builder.
         * @param {string|!{root: string, file: string}} filename Path to json file or an object specifying 'file' with
         *  an overridden 'root' path for all imported files.
         * @param {function(?Error, !ProtoBuf.Builder=)=} callback Callback that will receive `null` as the first and
         *  the Builder as its second argument on success, otherwise the error as its first argument. If omitted, the
         *  file will be read synchronously and this function will return the Builder.
         * @param {ProtoBuf.Builder=} builder Builder to append to. Will create a new one if omitted.
         * @return {?ProtoBuf.Builder|undefined} The Builder if synchronous (no callback specified, will be NULL if the
         *   request has failed), else undefined
         * @expose
         */
        ProtoBuf.loadJsonFile = function(filename, callback, builder) {
            if (callback && typeof callback === 'object')
                builder = callback,
                callback = null;
            else if (!callback || typeof callback !== 'function')
                callback = null;
            if (callback)
                return ProtoBuf.Util.fetch(typeof filename === 'string' ? filename : filename["root"]+"/"+filename["file"], function(contents) {
                    if (contents === null) {
                        callback(Error("Failed to fetch file"));
                        return;
                    }
                    try {
                        callback(null, ProtoBuf.loadJson(JSON.parse(contents), builder, filename));
                    } catch (e) {
                        callback(e);
                    }
                });
            var contents = ProtoBuf.Util.fetch(typeof filename === 'object' ? filename["root"]+"/"+filename["file"] : filename);
            return contents === null ? null : ProtoBuf.loadJson(JSON.parse(contents), builder, filename);
        };

        return ProtoBuf;
    }

    /* CommonJS */ if (typeof module !== 'undefined' && module["exports"])
        module["exports"] = init(require("bytebuffer"));
    /* AMD */ else if (typeof define === 'function' && define["amd"])
        define(["ByteBuffer"], init);
    /* Global */ else
        (global["dcodeIO"] = global["dcodeIO"] || {})["ProtoBuf"] = init(global["dcodeIO"]["ByteBuffer"]);

})(this);

},{"bytebuffer":54,"fs":46,"path":50}],53:[function(require,module,exports){
/*
 Copyright 2013 Daniel Wirtz <dcode@dcode.io>

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 */
var ProtoBuf = require("./dist/ProtoBuf.js");

module.exports = ProtoBuf;

},{"./dist/ProtoBuf.js":52}],54:[function(require,module,exports){
/*
 ByteBuffer.js (c) 2013-2014 Daniel Wirtz <dcode@dcode.io>
 This version of ByteBuffer.js uses an ArrayBuffer (AB) as its backing buffer and is compatible with modern browsers.
 Released under the Apache License, Version 2.0
 see: https://github.com/dcodeIO/ByteBuffer.js for details
*/
(function(r){function s(l){function d(a,b,c){"undefined"===typeof a&&(a=d.DEFAULT_CAPACITY);"undefined"===typeof b&&(b=d.DEFAULT_ENDIAN);"undefined"===typeof c&&(c=d.DEFAULT_NOASSERT);if(!c){a|=0;if(0>a)throw new RangeError("Illegal capacity: 0 <= "+a);if("boolean"!==typeof b)throw new TypeError("Illegal littleEndian: Not a boolean");if("boolean"!==typeof c)throw new TypeError("Illegal noAssert: Not a boolean");}this.buffer=0===a?r:new ArrayBuffer(a);this.view=0===a?null:new DataView(this.buffer);
this.offset=0;this.markedOffset=-1;this.limit=a;this.littleEndian="undefined"!==typeof b?!!b:!1;this.noAssert=!!c}d.VERSION="3.1.0";d.LITTLE_ENDIAN=!0;d.BIG_ENDIAN=!1;d.DEFAULT_CAPACITY=16;d.DEFAULT_ENDIAN=d.BIG_ENDIAN;d.DEFAULT_NOASSERT=!1;d.Long=l||null;var r=new ArrayBuffer(0);d.allocate=function(a,b,c){return new d(a,b,c)};d.concat=function(a,b,c,e){if("boolean"===typeof b||"string"!==typeof b)e=c,c=b,b=void 0;for(var h=0,f=0,g=a.length,n;f<g;++f)d.isByteBuffer(a[f])||(a[f]=d.wrap(a[f],b)),n=
a[f].limit-a[f].offset,0<n&&(h+=n);if(0===h)return new d(0,c,e);b=new d(h,c,e);e=new Uint8Array(b.buffer);for(f=0;f<g;)c=a[f++],n=c.limit-c.offset,0>=n||(e.set((new Uint8Array(c.buffer)).subarray(c.offset,c.limit),b.offset),b.offset+=n);b.limit=b.offset;b.offset=0;return b};d.isByteBuffer=function(a){return a&&a instanceof d};d.type=function(){return ArrayBuffer};d.wrap=function(a,b,c,e){"string"!==typeof b&&(e=c,c=b,b=void 0);if("string"===typeof a)switch("undefined"===typeof b&&(b="utf8"),b){case "base64":return d.fromBase64(a,
c);case "hex":return d.fromHex(a,c);case "binary":return d.fromBinary(a,c);case "utf8":return d.fromUTF8(a,c);case "debug":return d.fromDebug(a,c);default:throw new TypeError("Unsupported encoding: "+b);}if(null===a||"object"!==typeof a)throw new TypeError("Illegal buffer: null or non-object");if(d.isByteBuffer(a))return b=d.prototype.clone.call(a),b.markedOffset=-1,b;if(a instanceof Uint8Array)b=new d(0,c,e),0<a.length&&(b.buffer=a.buffer,b.offset=a.byteOffset,b.limit=a.byteOffset+a.length,b.view=
0<a.length?new DataView(a.buffer):null);else if(a instanceof ArrayBuffer)b=new d(0,c,e),0<a.byteLength&&(b.buffer=a,b.offset=0,b.limit=a.byteLength,b.view=0<a.byteLength?new DataView(a):null);else if("[object Array]"===Object.prototype.toString.call(a))for(b=new d(a.length,c,e),b.limit=a.length,i=0;i<a.length;++i)b.view.setUint8(i,a[i]);else throw new TypeError("Illegal buffer");return b};d.prototype.writeInt8=function(a,b){var c="undefined"===typeof b;c&&(b=this.offset);if(!this.noAssert){if("number"!==
typeof a||0!==a%1)throw new TypeError("Illegal value: "+a+" (not an integer)");a|=0;if("number"!==typeof b||0!==b%1)throw new TypeError("Illegal offset: "+b+" (not an integer)");b>>>=0;if(0>b||b+0>this.buffer.byteLength)throw new RangeError("Illegal offset: 0 <= "+b+" (+0) <= "+this.buffer.byteLength);}b+=1;var e=this.buffer.byteLength;b>e&&this.resize((e*=2)>b?e:b);this.view.setInt8(b-1,a);c&&(this.offset+=1);return this};d.prototype.writeByte=d.prototype.writeInt8;d.prototype.readInt8=function(a){var b=
"undefined"===typeof a;b&&(a=this.offset);if(!this.noAssert){if("number"!==typeof a||0!==a%1)throw new TypeError("Illegal offset: "+a+" (not an integer)");a>>>=0;if(0>a||a+1>this.buffer.byteLength)throw new RangeError("Illegal offset: 0 <= "+a+" (+1) <= "+this.buffer.byteLength);}a=this.view.getInt8(a);b&&(this.offset+=1);return a};d.prototype.readByte=d.prototype.readInt8;d.prototype.writeUint8=function(a,b){var c="undefined"===typeof b;c&&(b=this.offset);if(!this.noAssert){if("number"!==typeof a||
0!==a%1)throw new TypeError("Illegal value: "+a+" (not an integer)");a>>>=0;if("number"!==typeof b||0!==b%1)throw new TypeError("Illegal offset: "+b+" (not an integer)");b>>>=0;if(0>b||b+0>this.buffer.byteLength)throw new RangeError("Illegal offset: 0 <= "+b+" (+0) <= "+this.buffer.byteLength);}b+=1;var e=this.buffer.byteLength;b>e&&this.resize((e*=2)>b?e:b);this.view.setUint8(b-1,a);c&&(this.offset+=1);return this};d.prototype.readUint8=function(a){var b="undefined"===typeof a;b&&(a=this.offset);
if(!this.noAssert){if("number"!==typeof a||0!==a%1)throw new TypeError("Illegal offset: "+a+" (not an integer)");a>>>=0;if(0>a||a+1>this.buffer.byteLength)throw new RangeError("Illegal offset: 0 <= "+a+" (+1) <= "+this.buffer.byteLength);}a=this.view.getUint8(a);b&&(this.offset+=1);return a};d.prototype.writeInt16=function(a,b){var c="undefined"===typeof b;c&&(b=this.offset);if(!this.noAssert){if("number"!==typeof a||0!==a%1)throw new TypeError("Illegal value: "+a+" (not an integer)");a|=0;if("number"!==
typeof b||0!==b%1)throw new TypeError("Illegal offset: "+b+" (not an integer)");b>>>=0;if(0>b||b+0>this.buffer.byteLength)throw new RangeError("Illegal offset: 0 <= "+b+" (+0) <= "+this.buffer.byteLength);}b+=2;var e=this.buffer.byteLength;b>e&&this.resize((e*=2)>b?e:b);this.view.setInt16(b-2,a,this.littleEndian);c&&(this.offset+=2);return this};d.prototype.writeShort=d.prototype.writeInt16;d.prototype.readInt16=function(a){var b="undefined"===typeof a;b&&(a=this.offset);if(!this.noAssert){if("number"!==
typeof a||0!==a%1)throw new TypeError("Illegal offset: "+a+" (not an integer)");a>>>=0;if(0>a||a+2>this.buffer.byteLength)throw new RangeError("Illegal offset: 0 <= "+a+" (+2) <= "+this.buffer.byteLength);}a=this.view.getInt16(a,this.littleEndian);b&&(this.offset+=2);return a};d.prototype.readShort=d.prototype.readInt16;d.prototype.writeUint16=function(a,b){var c="undefined"===typeof b;c&&(b=this.offset);if(!this.noAssert){if("number"!==typeof a||0!==a%1)throw new TypeError("Illegal value: "+a+" (not an integer)");
a>>>=0;if("number"!==typeof b||0!==b%1)throw new TypeError("Illegal offset: "+b+" (not an integer)");b>>>=0;if(0>b||b+0>this.buffer.byteLength)throw new RangeError("Illegal offset: 0 <= "+b+" (+0) <= "+this.buffer.byteLength);}b+=2;var e=this.buffer.byteLength;b>e&&this.resize((e*=2)>b?e:b);this.view.setUint16(b-2,a,this.littleEndian);c&&(this.offset+=2);return this};d.prototype.readUint16=function(a){var b="undefined"===typeof a;b&&(a=this.offset);if(!this.noAssert){if("number"!==typeof a||0!==a%
1)throw new TypeError("Illegal offset: "+a+" (not an integer)");a>>>=0;if(0>a||a+2>this.buffer.byteLength)throw new RangeError("Illegal offset: 0 <= "+a+" (+2) <= "+this.buffer.byteLength);}a=this.view.getUint16(a,this.littleEndian);b&&(this.offset+=2);return a};d.prototype.writeInt32=function(a,b){var c="undefined"===typeof b;c&&(b=this.offset);if(!this.noAssert){if("number"!==typeof a||0!==a%1)throw new TypeError("Illegal value: "+a+" (not an integer)");a|=0;if("number"!==typeof b||0!==b%1)throw new TypeError("Illegal offset: "+
b+" (not an integer)");b>>>=0;if(0>b||b+0>this.buffer.byteLength)throw new RangeError("Illegal offset: 0 <= "+b+" (+0) <= "+this.buffer.byteLength);}b+=4;var e=this.buffer.byteLength;b>e&&this.resize((e*=2)>b?e:b);this.view.setInt32(b-4,a,this.littleEndian);c&&(this.offset+=4);return this};d.prototype.writeInt=d.prototype.writeInt32;d.prototype.readInt32=function(a){var b="undefined"===typeof a;b&&(a=this.offset);if(!this.noAssert){if("number"!==typeof a||0!==a%1)throw new TypeError("Illegal offset: "+
a+" (not an integer)");a>>>=0;if(0>a||a+4>this.buffer.byteLength)throw new RangeError("Illegal offset: 0 <= "+a+" (+4) <= "+this.buffer.byteLength);}a=this.view.getInt32(a,this.littleEndian);b&&(this.offset+=4);return a};d.prototype.readInt=d.prototype.readInt32;d.prototype.writeUint32=function(a,b){var c="undefined"===typeof b;c&&(b=this.offset);if(!this.noAssert){if("number"!==typeof a||0!==a%1)throw new TypeError("Illegal value: "+a+" (not an integer)");a>>>=0;if("number"!==typeof b||0!==b%1)throw new TypeError("Illegal offset: "+
b+" (not an integer)");b>>>=0;if(0>b||b+0>this.buffer.byteLength)throw new RangeError("Illegal offset: 0 <= "+b+" (+0) <= "+this.buffer.byteLength);}b+=4;var e=this.buffer.byteLength;b>e&&this.resize((e*=2)>b?e:b);this.view.setUint32(b-4,a,this.littleEndian);c&&(this.offset+=4);return this};d.prototype.readUint32=function(a){var b="undefined"===typeof a;b&&(a=this.offset);if(!this.noAssert){if("number"!==typeof a||0!==a%1)throw new TypeError("Illegal offset: "+a+" (not an integer)");a>>>=0;if(0>a||
a+4>this.buffer.byteLength)throw new RangeError("Illegal offset: 0 <= "+a+" (+4) <= "+this.buffer.byteLength);}a=this.view.getUint32(a,this.littleEndian);b&&(this.offset+=4);return a};l&&(d.prototype.writeInt64=function(a,b){var c="undefined"===typeof b;c&&(b=this.offset);if(!this.noAssert){if("number"===typeof a)a=l.fromNumber(a);else if(!(a&&a instanceof l))throw new TypeError("Illegal value: "+a+" (not an integer or Long)");if("number"!==typeof b||0!==b%1)throw new TypeError("Illegal offset: "+
b+" (not an integer)");b>>>=0;if(0>b||b+0>this.buffer.byteLength)throw new RangeError("Illegal offset: 0 <= "+b+" (+0) <= "+this.buffer.byteLength);}"number"===typeof a&&(a=l.fromNumber(a));b+=8;var e=this.buffer.byteLength;b>e&&this.resize((e*=2)>b?e:b);b-=8;this.littleEndian?(this.view.setInt32(b,a.low,!0),this.view.setInt32(b+4,a.high,!0)):(this.view.setInt32(b,a.high,!1),this.view.setInt32(b+4,a.low,!1));c&&(this.offset+=8);return this},d.prototype.writeLong=d.prototype.writeInt64,d.prototype.readInt64=
function(a){var b="undefined"===typeof a;b&&(a=this.offset);if(!this.noAssert){if("number"!==typeof a||0!==a%1)throw new TypeError("Illegal offset: "+a+" (not an integer)");a>>>=0;if(0>a||a+8>this.buffer.byteLength)throw new RangeError("Illegal offset: 0 <= "+a+" (+8) <= "+this.buffer.byteLength);}a=this.littleEndian?new l(this.view.getInt32(a,!0),this.view.getInt32(a+4,!0),!1):new l(this.view.getInt32(a+4,!1),this.view.getInt32(a,!1),!1);b&&(this.offset+=8);return a},d.prototype.readLong=d.prototype.readInt64,
d.prototype.writeUint64=function(a,b){var c="undefined"===typeof b;c&&(b=this.offset);if(!this.noAssert){if("number"===typeof a)a=l.fromNumber(a);else if(!(a&&a instanceof l))throw new TypeError("Illegal value: "+a+" (not an integer or Long)");if("number"!==typeof b||0!==b%1)throw new TypeError("Illegal offset: "+b+" (not an integer)");b>>>=0;if(0>b||b+0>this.buffer.byteLength)throw new RangeError("Illegal offset: 0 <= "+b+" (+0) <= "+this.buffer.byteLength);}"number"===typeof a&&(a=l.fromNumber(a));
b+=8;var e=this.buffer.byteLength;b>e&&this.resize((e*=2)>b?e:b);b-=8;this.littleEndian?(this.view.setInt32(b,a.low,!0),this.view.setInt32(b+4,a.high,!0)):(this.view.setInt32(b,a.high,!1),this.view.setInt32(b+4,a.low,!1));c&&(this.offset+=8);return this},d.prototype.readUint64=function(a){var b="undefined"===typeof a;b&&(a=this.offset);if(!this.noAssert){if("number"!==typeof a||0!==a%1)throw new TypeError("Illegal offset: "+a+" (not an integer)");a>>>=0;if(0>a||a+8>this.buffer.byteLength)throw new RangeError("Illegal offset: 0 <= "+
a+" (+8) <= "+this.buffer.byteLength);}a=this.littleEndian?new l(this.view.getInt32(a,!0),this.view.getInt32(a+4,!0),!0):new l(this.view.getInt32(a+4,!1),this.view.getInt32(a,!1),!0);b&&(this.offset+=8);return a});d.prototype.writeFloat32=function(a,b){var c="undefined"===typeof b;c&&(b=this.offset);if(!this.noAssert){if("number"!==typeof a)throw new TypeError("Illegal value: "+a+" (not a number)");if("number"!==typeof b||0!==b%1)throw new TypeError("Illegal offset: "+b+" (not an integer)");b>>>=
0;if(0>b||b+0>this.buffer.byteLength)throw new RangeError("Illegal offset: 0 <= "+b+" (+0) <= "+this.buffer.byteLength);}b+=4;var e=this.buffer.byteLength;b>e&&this.resize((e*=2)>b?e:b);this.view.setFloat32(b-4,a,this.littleEndian);c&&(this.offset+=4);return this};d.prototype.writeFloat=d.prototype.writeFloat32;d.prototype.readFloat32=function(a){var b="undefined"===typeof a;b&&(a=this.offset);if(!this.noAssert){if("number"!==typeof a||0!==a%1)throw new TypeError("Illegal offset: "+a+" (not an integer)");
a>>>=0;if(0>a||a+4>this.buffer.byteLength)throw new RangeError("Illegal offset: 0 <= "+a+" (+4) <= "+this.buffer.byteLength);}a=this.view.getFloat32(a,this.littleEndian);b&&(this.offset+=4);return a};d.prototype.readFloat=d.prototype.readFloat32;d.prototype.writeFloat64=function(a,b){var c="undefined"===typeof b;c&&(b=this.offset);if(!this.noAssert){if("number"!==typeof a)throw new TypeError("Illegal value: "+a+" (not a number)");if("number"!==typeof b||0!==b%1)throw new TypeError("Illegal offset: "+
b+" (not an integer)");b>>>=0;if(0>b||b+0>this.buffer.byteLength)throw new RangeError("Illegal offset: 0 <= "+b+" (+0) <= "+this.buffer.byteLength);}b+=8;var e=this.buffer.byteLength;b>e&&this.resize((e*=2)>b?e:b);this.view.setFloat64(b-8,a,this.littleEndian);c&&(this.offset+=8);return this};d.prototype.writeDouble=d.prototype.writeFloat64;d.prototype.readFloat64=function(a){var b="undefined"===typeof a;b&&(a=this.offset);if(!this.noAssert){if("number"!==typeof a||0!==a%1)throw new TypeError("Illegal offset: "+
a+" (not an integer)");a>>>=0;if(0>a||a+8>this.buffer.byteLength)throw new RangeError("Illegal offset: 0 <= "+a+" (+8) <= "+this.buffer.byteLength);}a=this.view.getFloat64(a,this.littleEndian);b&&(this.offset+=8);return a};d.prototype.readDouble=d.prototype.readFloat64;d.MAX_VARINT32_BYTES=5;d.calculateVarint32=function(a){a>>>=0;return 128>a?1:16384>a?2:2097152>a?3:268435456>a?4:5};d.zigZagEncode32=function(a){return((a|=0)<<1^a>>31)>>>0};d.zigZagDecode32=function(a){return a>>>1^-(a&1)|0};d.prototype.writeVarint32=
function(a,b){var c="undefined"===typeof b;c&&(b=this.offset);if(!this.noAssert){if("number"!==typeof a||0!==a%1)throw new TypeError("Illegal value: "+a+" (not an integer)");a|=0;if("number"!==typeof b||0!==b%1)throw new TypeError("Illegal offset: "+b+" (not an integer)");b>>>=0;if(0>b||b+0>this.buffer.byteLength)throw new RangeError("Illegal offset: 0 <= "+b+" (+0) <= "+this.buffer.byteLength);}var e=d.calculateVarint32(a);b+=e;var h=this.buffer.byteLength;b>h&&this.resize((h*=2)>b?h:b);b-=e;this.view.setUint8(b,
e=a|128);a>>>=0;128<=a?(e=a>>7|128,this.view.setUint8(b+1,e),16384<=a?(e=a>>14|128,this.view.setUint8(b+2,e),2097152<=a?(e=a>>21|128,this.view.setUint8(b+3,e),268435456<=a?(this.view.setUint8(b+4,a>>28&15),e=5):(this.view.setUint8(b+3,e&127),e=4)):(this.view.setUint8(b+2,e&127),e=3)):(this.view.setUint8(b+1,e&127),e=2)):(this.view.setUint8(b,e&127),e=1);return c?(this.offset+=e,this):e};d.prototype.writeVarint32ZigZag=function(a,b){return this.writeVarint32(d.zigZagEncode32(a),b)};d.prototype.readVarint32=
function(a){var b="undefined"===typeof a;b&&(a=this.offset);if(!this.noAssert){if("number"!==typeof a||0!==a%1)throw new TypeError("Illegal offset: "+a+" (not an integer)");a>>>=0;if(0>a||a+1>this.buffer.byteLength)throw new RangeError("Illegal offset: 0 <= "+a+" (+1) <= "+this.buffer.byteLength);}var c=0,e=0,d;do d=this.view.getUint8(a+c),5>c&&(e|=(d&127)<<7*c>>>0),++c;while(128===(d&128));e|=0;return b?(this.offset+=c,e):{value:e,length:c}};d.prototype.readVarint32ZigZag=function(a){a=this.readVarint32(a);
"object"===typeof a?a.value=d.zigZagDecode32(a.value):a=d.zigZagDecode32(a);return a};l&&(d.MAX_VARINT64_BYTES=10,d.calculateVarint64=function(a){"number"===typeof a&&(a=l.fromNumber(a));var b=a.toInt()>>>0,c=a.shiftRightUnsigned(28).toInt()>>>0;a=a.shiftRightUnsigned(56).toInt()>>>0;return 0==a?0==c?16384>b?128>b?1:2:2097152>b?3:4:16384>c?128>c?5:6:2097152>c?7:8:128>a?9:10},d.zigZagEncode64=function(a){"number"===typeof a?a=l.fromNumber(a,!1):!1!==a.unsigned&&(a=a.toSigned());return a.shiftLeft(1).xor(a.shiftRight(63)).toUnsigned()},
d.zigZagDecode64=function(a){"number"===typeof a?a=l.fromNumber(a,!1):!1!==a.unsigned&&(a=a.toSigned());return a.shiftRightUnsigned(1).xor(a.and(l.ONE).toSigned().negate()).toSigned()},d.prototype.writeVarint64=function(a,b){var c="undefined"===typeof b;c&&(b=this.offset);if(!this.noAssert){if("number"===typeof a)a=l.fromNumber(a);else if(!(a&&a instanceof l))throw new TypeError("Illegal value: "+a+" (not an integer or Long)");if("number"!==typeof b||0!==b%1)throw new TypeError("Illegal offset: "+
b+" (not an integer)");b>>>=0;if(0>b||b+0>this.buffer.byteLength)throw new RangeError("Illegal offset: 0 <= "+b+" (+0) <= "+this.buffer.byteLength);}"number"===typeof a?a=l.fromNumber(a,!1):!1!==a.unsigned&&(a=a.toSigned());var e=d.calculateVarint64(a),h=a.toInt()>>>0,f=a.shiftRightUnsigned(28).toInt()>>>0,g=a.shiftRightUnsigned(56).toInt()>>>0;b+=e;var n=this.buffer.byteLength;b>n&&this.resize((n*=2)>b?n:b);b-=e;switch(e){case 10:this.view.setUint8(b+9,g>>>7&1);case 9:this.view.setUint8(b+8,9!==
e?g|128:g&127);case 8:this.view.setUint8(b+7,8!==e?f>>>21|128:f>>>21&127);case 7:this.view.setUint8(b+6,7!==e?f>>>14|128:f>>>14&127);case 6:this.view.setUint8(b+5,6!==e?f>>>7|128:f>>>7&127);case 5:this.view.setUint8(b+4,5!==e?f|128:f&127);case 4:this.view.setUint8(b+3,4!==e?h>>>21|128:h>>>21&127);case 3:this.view.setUint8(b+2,3!==e?h>>>14|128:h>>>14&127);case 2:this.view.setUint8(b+1,2!==e?h>>>7|128:h>>>7&127);case 1:this.view.setUint8(b,1!==e?h|128:h&127)}return c?(this.offset+=e,this):e},d.prototype.writeVarint64ZigZag=
function(a,b){return this.writeVarint64(d.zigZagEncode64(a),b)},d.prototype.readVarint64=function(a){var b="undefined"===typeof a;b&&(a=this.offset);if(!this.noAssert){if("number"!==typeof a||0!==a%1)throw new TypeError("Illegal offset: "+a+" (not an integer)");a>>>=0;if(0>a||a+1>this.buffer.byteLength)throw new RangeError("Illegal offset: 0 <= "+a+" (+1) <= "+this.buffer.byteLength);}var c=a,e=0,d=0,f=0,g=0,g=this.view.getUint8(a++),e=g&127;if(g&128&&(g=this.view.getUint8(a++),e|=(g&127)<<7,g&128&&
(g=this.view.getUint8(a++),e|=(g&127)<<14,g&128&&(g=this.view.getUint8(a++),e|=(g&127)<<21,g&128&&(g=this.view.getUint8(a++),d=g&127,g&128&&(g=this.view.getUint8(a++),d|=(g&127)<<7,g&128&&(g=this.view.getUint8(a++),d|=(g&127)<<14,g&128&&(g=this.view.getUint8(a++),d|=(g&127)<<21,g&128&&(g=this.view.getUint8(a++),f=g&127,g&128&&(g=this.view.getUint8(a++),f|=(g&127)<<7,g&128))))))))))throw Error("Data must be corrupt: Buffer overrun");e=l.from28Bits(e,d,f,!1);return b?(this.offset=a,e):{value:e,length:a-
c}},d.prototype.readVarint64ZigZag=function(a){(a=this.readVarint64(a))&&a.value instanceof l?a.value=d.zigZagDecode64(a.value):a=d.zigZagDecode64(a);return a});d.prototype.writeCString=function(a,b){var c="undefined"===typeof b;c&&(b=this.offset);var e,d=a.length;if(!this.noAssert){if("string"!==typeof a)throw new TypeError("Illegal str: Not a string");for(e=0;e<d;++e)if(0===a.charCodeAt(e))throw new RangeError("Illegal str: Contains NULL-characters");if("number"!==typeof b||0!==b%1)throw new TypeError("Illegal offset: "+
b+" (not an integer)");b>>>=0;if(0>b||b+0>this.buffer.byteLength)throw new RangeError("Illegal offset: 0 <= "+b+" (+0) <= "+this.buffer.byteLength);}e=b;d=k.b(k.a(a))[1];b+=d+1;var f=this.buffer.byteLength;b>f&&this.resize((f*=2)>b?f:b);b-=d+1;k.e(k.a(a),function(a){this.view.setUint8(b++,a)}.bind(this));this.view.setUint8(b++,0);return c?(this.offset=b-e,this):d};d.prototype.readCString=function(a){var b="undefined"===typeof a;b&&(a=this.offset);if(!this.noAssert){if("number"!==typeof a||0!==a%1)throw new TypeError("Illegal offset: "+
a+" (not an integer)");a>>>=0;if(0>a||a+1>this.buffer.byteLength)throw new RangeError("Illegal offset: 0 <= "+a+" (+1) <= "+this.buffer.byteLength);}var c=a,e,d=-1;k.d(function(){if(0===d)return null;if(a>=this.limit)throw RangeError("Illegal range: Truncated data, "+a+" < "+this.limit);return 0===(d=this.view.getUint8(a++))?null:d}.bind(this),e=k.c(),!0);return b?(this.offset=a,e()):{string:e(),length:a-c}};d.prototype.writeIString=function(a,b){var c="undefined"===typeof b;c&&(b=this.offset);if(!this.noAssert){if("string"!==
typeof a)throw new TypeError("Illegal str: Not a string");if("number"!==typeof b||0!==b%1)throw new TypeError("Illegal offset: "+b+" (not an integer)");b>>>=0;if(0>b||b+0>this.buffer.byteLength)throw new RangeError("Illegal offset: 0 <= "+b+" (+0) <= "+this.buffer.byteLength);}var e=b,d;d=k.b(k.a(a),this.noAssert)[1];b+=4+d;var f=this.buffer.byteLength;b>f&&this.resize((f*=2)>b?f:b);b-=4+d;this.view.setUint32(b,d,this.littleEndian);b+=4;k.e(k.a(a),function(a){this.view.setUint8(b++,a)}.bind(this));
if(b!==e+4+d)throw new RangeError("Illegal range: Truncated data, "+b+" == "+(b+4+d));return c?(this.offset=b,this):b-e};d.prototype.readIString=function(a){var b="undefined"===typeof a;b&&(a=this.offset);if(!this.noAssert){if("number"!==typeof a||0!==a%1)throw new TypeError("Illegal offset: "+a+" (not an integer)");a>>>=0;if(0>a||a+4>this.buffer.byteLength)throw new RangeError("Illegal offset: 0 <= "+a+" (+4) <= "+this.buffer.byteLength);}var c=0,e=a,c=this.view.getUint32(a,this.littleEndian);a+=
4;var d=a+c;k.d(function(){return a<d?this.view.getUint8(a++):null}.bind(this),c=k.c(),this.noAssert);c=c();return b?(this.offset=a,c):{string:c,length:a-e}};d.METRICS_CHARS="c";d.METRICS_BYTES="b";d.prototype.writeUTF8String=function(a,b){var c="undefined"===typeof b;c&&(b=this.offset);if(!this.noAssert){if("number"!==typeof b||0!==b%1)throw new TypeError("Illegal offset: "+b+" (not an integer)");b>>>=0;if(0>b||b+0>this.buffer.byteLength)throw new RangeError("Illegal offset: 0 <= "+b+" (+0) <= "+
this.buffer.byteLength);}var e,d=b;e=k.b(k.a(a))[1];b+=e;var f=this.buffer.byteLength;b>f&&this.resize((f*=2)>b?f:b);b-=e;k.e(k.a(a),function(a){this.view.setUint8(b++,a)}.bind(this));return c?(this.offset=b,this):b-d};d.prototype.writeString=d.prototype.writeUTF8String;d.calculateUTF8Chars=function(a){return k.b(k.a(a))[0]};d.calculateUTF8Bytes=function(a){return k.b(k.a(a))[1]};d.prototype.readUTF8String=function(a,b,c){"number"===typeof b&&(c=b,b=void 0);var e="undefined"===typeof c;e&&(c=this.offset);
"undefined"===typeof b&&(b=d.METRICS_CHARS);if(!this.noAssert){if("number"!==typeof a||0!==a%1)throw new TypeError("Illegal length: "+a+" (not an integer)");a|=0;if("number"!==typeof c||0!==c%1)throw new TypeError("Illegal offset: "+c+" (not an integer)");c>>>=0;if(0>c||c+0>this.buffer.byteLength)throw new RangeError("Illegal offset: 0 <= "+c+" (+0) <= "+this.buffer.byteLength);}var h=0,f=c,g;if(b===d.METRICS_CHARS){g=k.c();k.i(function(){return h<a&&c<this.limit?this.view.getUint8(c++):null}.bind(this),
function(a){++h;k.g(a,g)}.bind(this));if(h!==a)throw new RangeError("Illegal range: Truncated data, "+h+" == "+a);return e?(this.offset=c,g()):{string:g(),length:c-f}}if(b===d.METRICS_BYTES){if(!this.noAssert){if("number"!==typeof c||0!==c%1)throw new TypeError("Illegal offset: "+c+" (not an integer)");c>>>=0;if(0>c||c+a>this.buffer.byteLength)throw new RangeError("Illegal offset: 0 <= "+c+" (+"+a+") <= "+this.buffer.byteLength);}var n=c+a;k.d(function(){return c<n?this.view.getUint8(c++):null}.bind(this),
g=k.c(),this.noAssert);if(c!==n)throw new RangeError("Illegal range: Truncated data, "+c+" == "+n);return e?(this.offset=c,g()):{string:g(),length:c-f}}throw new TypeError("Unsupported metrics: "+b);};d.prototype.readString=d.prototype.readUTF8String;d.prototype.writeVString=function(a,b){var c="undefined"===typeof b;c&&(b=this.offset);if(!this.noAssert){if("string"!==typeof a)throw new TypeError("Illegal str: Not a string");if("number"!==typeof b||0!==b%1)throw new TypeError("Illegal offset: "+b+
" (not an integer)");b>>>=0;if(0>b||b+0>this.buffer.byteLength)throw new RangeError("Illegal offset: 0 <= "+b+" (+0) <= "+this.buffer.byteLength);}var e=b,h,f;h=k.b(k.a(a),this.noAssert)[1];f=d.calculateVarint32(h);b+=f+h;var g=this.buffer.byteLength;b>g&&this.resize((g*=2)>b?g:b);b-=f+h;b+=this.writeVarint32(h,b);k.e(k.a(a),function(a){this.view.setUint8(b++,a)}.bind(this));if(b!==e+h+f)throw new RangeError("Illegal range: Truncated data, "+b+" == "+(b+h+f));return c?(this.offset=b,this):b-e};d.prototype.readVString=
function(a){var b="undefined"===typeof a;b&&(a=this.offset);if(!this.noAssert){if("number"!==typeof a||0!==a%1)throw new TypeError("Illegal offset: "+a+" (not an integer)");a>>>=0;if(0>a||a+1>this.buffer.byteLength)throw new RangeError("Illegal offset: 0 <= "+a+" (+1) <= "+this.buffer.byteLength);}var c=this.readVarint32(a),e=a;a+=c.length;var c=c.value,d=a+c,c=k.c();k.d(function(){return a<d?this.view.getUint8(a++):null}.bind(this),c,this.noAssert);c=c();return b?(this.offset=a,c):{string:c,length:a-
e}};d.prototype.append=function(a,b,c){if("number"===typeof b||"string"!==typeof b)c=b,b=void 0;var e="undefined"===typeof c;e&&(c=this.offset);if(!this.noAssert){if("number"!==typeof c||0!==c%1)throw new TypeError("Illegal offset: "+c+" (not an integer)");c>>>=0;if(0>c||c+0>this.buffer.byteLength)throw new RangeError("Illegal offset: 0 <= "+c+" (+0) <= "+this.buffer.byteLength);}a instanceof d||(a=d.wrap(a,b));b=a.limit-a.offset;if(0>=b)return this;c+=b;var h=this.buffer.byteLength;c>h&&this.resize((h*=
2)>c?h:c);(new Uint8Array(this.buffer,c-b)).set((new Uint8Array(a.buffer)).subarray(a.offset,a.limit));a.offset+=b;e&&(this.offset+=b);return this};d.prototype.appendTo=function(a,b){a.append(this,b);return this};d.prototype.assert=function(a){this.noAssert=!a;return this};d.prototype.capacity=function(){return this.buffer.byteLength};d.prototype.clear=function(){this.offset=0;this.limit=this.buffer.byteLength;this.markedOffset=-1;return this};d.prototype.clone=function(a){var b=new d(0,this.littleEndian,
this.noAssert);a?(a=new ArrayBuffer(this.buffer.byteLength),(new Uint8Array(a)).set(this.buffer),b.buffer=a,b.view=new DataView(a)):(b.buffer=this.buffer,b.view=this.view);b.offset=this.offset;b.markedOffset=this.markedOffset;b.limit=this.limit;return b};d.prototype.compact=function(a,b){"undefined"===typeof a&&(a=this.offset);"undefined"===typeof b&&(b=this.limit);if(!this.noAssert){if("number"!==typeof a||0!==a%1)throw new TypeError("Illegal begin: Not an integer");a>>>=0;if("number"!==typeof b||
0!==b%1)throw new TypeError("Illegal end: Not an integer");b>>>=0;if(0>a||a>b||b>this.buffer.byteLength)throw new RangeError("Illegal range: 0 <= "+a+" <= "+b+" <= "+this.buffer.byteLength);}if(0===a&&b===this.buffer.byteLength)return this;var c=b-a;if(0===c)return this.buffer=r,this.view=null,0<=this.markedOffset&&(this.markedOffset-=a),this.limit=this.offset=0,this;var e=new ArrayBuffer(c);(new Uint8Array(e)).set((new Uint8Array(this.buffer)).subarray(a,b));this.buffer=e;this.view=new DataView(e);
0<=this.markedOffset&&(this.markedOffset-=a);this.offset=0;this.limit=c;return this};d.prototype.copy=function(a,b){"undefined"===typeof a&&(a=this.offset);"undefined"===typeof b&&(b=this.limit);if(!this.noAssert){if("number"!==typeof a||0!==a%1)throw new TypeError("Illegal begin: Not an integer");a>>>=0;if("number"!==typeof b||0!==b%1)throw new TypeError("Illegal end: Not an integer");b>>>=0;if(0>a||a>b||b>this.buffer.byteLength)throw new RangeError("Illegal range: 0 <= "+a+" <= "+b+" <= "+this.buffer.byteLength);
}if(a===b)return new d(0,this.littleEndian,this.noAssert);var c=b-a,e=new d(c,this.littleEndian,this.noAssert);e.offset=0;e.limit=c;0<=e.markedOffset&&(e.markedOffset-=a);this.copyTo(e,0,a,b);return e};d.prototype.copyTo=function(a,b,c,e){var h,f;if(!this.noAssert&&!d.isByteBuffer(a))throw new TypeError("Illegal target: Not a ByteBuffer");b=(f="undefined"===typeof b)?a.offset:b|0;c=(h="undefined"===typeof c)?this.offset:c|0;e="undefined"===typeof e?this.limit:e|0;if(0>b||b>a.buffer.byteLength)throw new RangeError("Illegal target range: 0 <= "+
b+" <= "+a.buffer.byteLength);if(0>c||e>this.buffer.byteLength)throw new RangeError("Illegal source range: 0 <= "+c+" <= "+this.buffer.byteLength);var g=e-c;if(0===g)return a;a.ensureCapacity(b+g);(new Uint8Array(a.buffer)).set((new Uint8Array(this.buffer)).subarray(c,e),b);h&&(this.offset+=g);f&&(a.offset+=g);return this};d.prototype.ensureCapacity=function(a){var b=this.buffer.byteLength;return b<a?this.resize((b*=2)>a?b:a):this};d.prototype.fill=function(a,b,c){var e="undefined"===typeof b;e&&
(b=this.offset);"string"===typeof a&&0<a.length&&(a=a.charCodeAt(0));"undefined"===typeof b&&(b=this.offset);"undefined"===typeof c&&(c=this.limit);if(!this.noAssert){if("number"!==typeof a||0!==a%1)throw new TypeError("Illegal value: "+a+" (not an integer)");a|=0;if("number"!==typeof b||0!==b%1)throw new TypeError("Illegal begin: Not an integer");b>>>=0;if("number"!==typeof c||0!==c%1)throw new TypeError("Illegal end: Not an integer");c>>>=0;if(0>b||b>c||c>this.buffer.byteLength)throw new RangeError("Illegal range: 0 <= "+
b+" <= "+c+" <= "+this.buffer.byteLength);}if(b>=c)return this;for(;b<c;)this.view.setUint8(b++,a);e&&(this.offset=b);return this};d.prototype.flip=function(){this.limit=this.offset;this.offset=0;return this};d.prototype.mark=function(a){a="undefined"===typeof a?this.offset:a;if(!this.noAssert){if("number"!==typeof a||0!==a%1)throw new TypeError("Illegal offset: "+a+" (not an integer)");a>>>=0;if(0>a||a+0>this.buffer.byteLength)throw new RangeError("Illegal offset: 0 <= "+a+" (+0) <= "+this.buffer.byteLength);
}this.markedOffset=a;return this};d.prototype.order=function(a){if(!this.noAssert&&"boolean"!==typeof a)throw new TypeError("Illegal littleEndian: Not a boolean");this.littleEndian=!!a;return this};d.prototype.LE=function(a){this.littleEndian="undefined"!==typeof a?!!a:!0;return this};d.prototype.BE=function(a){this.littleEndian="undefined"!==typeof a?!a:!1;return this};d.prototype.prepend=function(a,b,c){if("number"===typeof b||"string"!==typeof b)c=b,b=void 0;var e="undefined"===typeof c;e&&(c=
this.offset);if(!this.noAssert){if("number"!==typeof c||0!==c%1)throw new TypeError("Illegal offset: "+c+" (not an integer)");c>>>=0;if(0>c||c+0>this.buffer.byteLength)throw new RangeError("Illegal offset: 0 <= "+c+" (+0) <= "+this.buffer.byteLength);}a instanceof d||(a=d.wrap(a,b));b=a.limit-a.offset;if(0>=b)return this;var h=b-c,f;if(0<h){var g=new ArrayBuffer(this.buffer.byteLength+h);f=new Uint8Array(g);f.set((new Uint8Array(this.buffer)).subarray(c,this.buffer.byteLength),b);this.buffer=g;this.view=
new DataView(g);this.offset+=h;0<=this.markedOffset&&(this.markedOffset+=h);this.limit+=h;c+=h}else f=new Uint8Array(this.buffer);f.set((new Uint8Array(a.buffer)).subarray(a.offset,a.limit),c-b);a.offset=a.limit;e&&(this.offset-=b);return this};d.prototype.prependTo=function(a,b){a.prepend(this,b);return this};d.prototype.printDebug=function(a){"function"!==typeof a&&(a=console.log.bind(console));a(this.toString()+"\n-------------------------------------------------------------------\n"+this.toDebug(!0))};
d.prototype.remaining=function(){return this.limit-this.offset};d.prototype.reset=function(){0<=this.markedOffset?(this.offset=this.markedOffset,this.markedOffset=-1):this.offset=0;return this};d.prototype.resize=function(a){if(!this.noAssert){if("number"!==typeof a||0!==a%1)throw new TypeError("Illegal capacity: "+a+" (not an integer)");a|=0;if(0>a)throw new RangeError("Illegal capacity: 0 <= "+a);}this.buffer.byteLength<a&&(a=new ArrayBuffer(a),(new Uint8Array(a)).set(new Uint8Array(this.buffer)),
this.buffer=a,this.view=new DataView(a));return this};d.prototype.reverse=function(a,b){"undefined"===typeof a&&(a=this.offset);"undefined"===typeof b&&(b=this.limit);if(!this.noAssert){if("number"!==typeof a||0!==a%1)throw new TypeError("Illegal begin: Not an integer");a>>>=0;if("number"!==typeof b||0!==b%1)throw new TypeError("Illegal end: Not an integer");b>>>=0;if(0>a||a>b||b>this.buffer.byteLength)throw new RangeError("Illegal range: 0 <= "+a+" <= "+b+" <= "+this.buffer.byteLength);}if(a===b)return this;
Array.prototype.reverse.call((new Uint8Array(this.buffer)).subarray(a,b));this.view=new DataView(this.buffer);return this};d.prototype.skip=function(a){if(!this.noAssert){if("number"!==typeof a||0!==a%1)throw new TypeError("Illegal length: "+a+" (not an integer)");a|=0}var b=this.offset+a;if(!this.noAssert&&(0>b||b>this.buffer.byteLength))throw new RangeError("Illegal length: 0 <= "+this.offset+" + "+a+" <= "+this.buffer.byteLength);this.offset=b;return this};d.prototype.slice=function(a,b){"undefined"===
typeof a&&(a=this.offset);"undefined"===typeof b&&(b=this.limit);if(!this.noAssert){if("number"!==typeof a||0!==a%1)throw new TypeError("Illegal begin: Not an integer");a>>>=0;if("number"!==typeof b||0!==b%1)throw new TypeError("Illegal end: Not an integer");b>>>=0;if(0>a||a>b||b>this.buffer.byteLength)throw new RangeError("Illegal range: 0 <= "+a+" <= "+b+" <= "+this.buffer.byteLength);}var c=this.clone();c.offset=a;c.limit=b;return c};d.prototype.toBuffer=function(a){var b=this.offset,c=this.limit;
if(b>c)var e=b,b=c,c=e;if(!this.noAssert){if("number"!==typeof b||0!==b%1)throw new TypeError("Illegal offset: Not an integer");b>>>=0;if("number"!==typeof c||0!==c%1)throw new TypeError("Illegal limit: Not an integer");c>>>=0;if(0>b||b>c||c>this.buffer.byteLength)throw new RangeError("Illegal range: 0 <= "+b+" <= "+c+" <= "+this.buffer.byteLength);}if(!a&&0===b&&c===this.buffer.byteLength)return this.buffer;if(b===c)return r;a=new ArrayBuffer(c-b);(new Uint8Array(a)).set((new Uint8Array(this.buffer)).subarray(b,
c),0);return a};d.prototype.toArrayBuffer=d.prototype.toBuffer;d.prototype.toString=function(a){if("undefined"===typeof a)return"ByteBufferAB(offset="+this.offset+",markedOffset="+this.markedOffset+",limit="+this.limit+",capacity="+this.capacity()+")";switch(a){case "utf8":return this.toUTF8();case "base64":return this.toBase64();case "hex":return this.toHex();case "binary":return this.toBinary();case "debug":return this.toDebug();case "columns":return this.o();default:throw Error("Unsupported encoding: "+
a);}};var m="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",m=m+"";d.prototype.toBase64=function(a,b){"undefined"===typeof a&&(a=this.offset);"undefined"===typeof b&&(b=this.limit);if(!this.noAssert){if("number"!==typeof a||0!==a%1)throw new TypeError("Illegal begin: Not an integer");a>>>=0;if("number"!==typeof b||0!==b%1)throw new TypeError("Illegal end: Not an integer");b>>>=0;if(0>a||a>b||b>this.buffer.byteLength)throw new RangeError("Illegal range: 0 <= "+a+" <= "+b+" <= "+
this.buffer.byteLength);}if(a===b)return"";for(var c,e,d,f,g,k,l="";a<b;)c=this.view.getUint8(a++),e=(f=a<b)?this.view.getUint8(a++):0,d=(g=a<b)?this.view.getUint8(a++):0,k=c>>2,c=(c&3)<<4|e>>4,e=(e&15)<<2|d>>6,d&=63,g||(d=64,f||(e=64)),l+=m.charAt(k)+m.charAt(c)+m.charAt(e)+m.charAt(d);return l};d.fromBase64=function(a,b,c){if(!c){if("string"!==typeof a)throw new TypeError("Illegal str: Not a string");if(0!==a.length%4)throw new TypeError("Illegal str: Length not a multiple of 4");}var e=a.length,
h=0,f;for(f=a.length-1;0<=f;--f)if("="===a.charAt(f))h++;else break;if(2<h)throw new TypeError("Illegal str: Suffix is too large");if(0===e)return new d(0,b,c);var g,k,l,p=new d(e/4*3-h,b,c);for(b=f=0;f<e;){h=m.indexOf(a.charAt(f++));g=f<e?m.indexOf(a.charAt(f++)):0;k=f<e?m.indexOf(a.charAt(f++)):0;l=f<e?m.indexOf(a.charAt(f++)):0;if(!c&&(0>h||0>g||0>k||0>l))throw new TypeError("Illegal str: Contains non-base64 characters");p.view.setUint8(b++,h<<2|g>>4);64!==k&&(p.view.setUint8(b++,g<<4&240|k>>2,
b),64!==l&&p.view.setUint8(b++,k<<6&192|l))}p.limit=b;return p};d.btoa=function(a){return d.fromBinary(a).toBase64()};d.atob=function(a){return d.fromBase64(a).toBinary()};d.prototype.toBinary=function(a,b){a="undefined"===typeof a?this.offset:a;b="undefined"===typeof b?this.limit:b;if(!this.noAssert){if("number"!==typeof a||0!==a%1)throw new TypeError("Illegal begin: Not an integer");a>>>=0;if("number"!==typeof b||0!==b%1)throw new TypeError("Illegal end: Not an integer");b>>>=0;if(0>a||a>b||b>this.buffer.byteLength)throw new RangeError("Illegal range: 0 <= "+
a+" <= "+b+" <= "+this.buffer.byteLength);}if(a===b)return"";for(var c=[];a<b;)c.push(this.view.getUint8(a++));return String.fromCharCode.apply(String,c)};d.fromBinary=function(a,b,c){if(!c&&"string"!==typeof a)throw new TypeError("Illegal str: Not a string");for(var e=0,h=a.length,f=new d(h,b,c);e<h;){b=a.charCodeAt(e);if(!c&&255<b)throw new TypeError("Illegal charCode at "+e+": 0 <= "+b+" <= 255");f.view.setUint8(e++,b)}f.limit=h;return f};d.prototype.toDebug=function(a){for(var b=-1,c=this.buffer.byteLength,
e,d="",f="",g="";b<c;){-1!==b&&(e=this.view.getUint8(b),d=16>e?d+("0"+e.toString(16).toUpperCase()):d+e.toString(16).toUpperCase(),a&&(f+=32<e&&127>e?String.fromCharCode(e):"."));++b;if(a&&0<b&&0===b%16&&b!==c){for(;51>d.length;)d+=" ";g+=d+f+"\n";d=f=""}d=b===this.offset&&b===this.limit?d+(b===this.markedOffset?"!":"|"):b===this.offset?d+(b===this.markedOffset?"[":"<"):b===this.limit?d+(b===this.markedOffset?"]":">"):d+(b===this.markedOffset?"'":a||0!==b&&b!==c?" ":"")}if(a&&" "!==d){for(;51>d.length;)d+=
" ";g+=d+f+"\n"}return a?g:d};d.fromDebug=function(a,b,c){var e=a.length;b=new d((e+1)/3|0,b,c);for(var h=0,f=0,g,k=!1,l=!1,p=!1,m=!1,q=!1;h<e;){switch(g=a.charAt(h++)){case "!":if(!c){if(l||p||m){q=!0;break}l=p=m=!0}b.offset=b.markedOffset=b.limit=f;k=!1;break;case "|":if(!c){if(l||m){q=!0;break}l=m=!0}b.offset=b.limit=f;k=!1;break;case "[":if(!c){if(l||p){q=!0;break}l=p=!0}b.offset=b.markedOffset=f;k=!1;break;case "<":if(!c){if(l){q=!0;break}l=!0}b.offset=f;k=!1;break;case "]":if(!c){if(m||p){q=
!0;break}m=p=!0}b.limit=b.markedOffset=f;k=!1;break;case ">":if(!c){if(m){q=!0;break}m=!0}b.limit=f;k=!1;break;case "'":if(!c){if(p){q=!0;break}p=!0}b.markedOffset=f;k=!1;break;case " ":k=!1;break;default:if(!c&&k){q=!0;break}g=parseInt(g+a.charAt(h++),16);if(!c&&(isNaN(g)||0>g||255<g))throw new TypeError("Illegal str: Not a debug encoded string");b.view.setUint8(f++,g);k=!0}if(q)throw new TypeError("Illegal str: Invalid symbol at "+h);}if(!c){if(!l||!m)throw new TypeError("Illegal str: Missing offset or limit");
if(f<b.buffer.byteLength)throw new TypeError("Illegal str: Not a debug encoded string (is it hex?) "+f+" < "+e);}return b};d.prototype.toHex=function(a,b){a="undefined"===typeof a?this.offset:a;b="undefined"===typeof b?this.limit:b;if(!this.noAssert){if("number"!==typeof a||0!==a%1)throw new TypeError("Illegal begin: Not an integer");a>>>=0;if("number"!==typeof b||0!==b%1)throw new TypeError("Illegal end: Not an integer");b>>>=0;if(0>a||a>b||b>this.buffer.byteLength)throw new RangeError("Illegal range: 0 <= "+
a+" <= "+b+" <= "+this.buffer.byteLength);}for(var c=Array(b-a),e;a<b;)e=this.view.getUint8(a++),16>e?c.push("0",e.toString(16)):c.push(e.toString(16));return c.join("")};d.fromHex=function(a,b,c){if(!c){if("string"!==typeof a)throw new TypeError("Illegal str: Not a string");if(0!==a.length%2)throw new TypeError("Illegal str: Length not a multiple of 2");}var e=a.length;b=new d(e/2|0,b);for(var h,f=0,g=0;f<e;f+=2){h=parseInt(a.substring(f,f+2),16);if(!c&&(!isFinite(h)||0>h||255<h))throw new TypeError("Illegal str: Contains non-hex characters");
b.view.setUint8(g++,h)}b.limit=g;return b};var k=function(){var a={j:function(a,c){var e=null;"number"===typeof a&&(e=a,a=function(){return null});for(;null!==e||null!==(e=a());)128>e?c(e&127):(2048>e?c(e>>6&31|192):(65536>e?c(e>>12&15|224):(c(e>>18&7|240),c(e>>12&63|128)),c(e>>6&63|128)),c(e&63|128)),e=null},i:function(a,c){function e(a){a=a.slice(0,a.indexOf(null));var b=Error(a.toString());b.name="TruncatedError";b.bytes=a;throw b;}for(var d,f,g,k;null!==(d=a());)if(0===(d&128))c(d);else if(192===
(d&224))null===(f=a())&&e([d,f]),c((d&31)<<6|f&63);else if(224===(d&240))null!==(f=a())&&null!==(g=a())||e([d,f,g]),c((d&15)<<12|(f&63)<<6|g&63);else if(240===(d&248))null!==(f=a())&&null!==(g=a())&&null!==(k=a())||e([d,f,g,k]),c((d&7)<<18|(f&63)<<12|(g&63)<<6|k&63);else throw RangeError("Illegal starting byte: "+d);},f:function(a,c){for(var e,d=null;null!==(e=null!==d?d:a());)55296<=e&&57343>=e&&null!==(d=a())&&56320<=d&&57343>=d?(c(1024*(e-55296)+d-56320+65536),d=null):c(e);null!==d&&c(d)},g:function(a,
c){var e=null;"number"===typeof a&&(e=a,a=function(){return null});for(;null!==e||null!==(e=a());)65535>=e?c(e):(e-=65536,c((e>>10)+55296),c(e%1024+56320)),e=null},e:function(b,c){a.f(b,function(b){a.j(b,c)})},d:function(b,c){a.i(b,function(b){a.g(b,c)})},k:function(a){if("number"!==typeof a||a!==a)throw TypeError("Illegal byte: "+typeof a);if(-128>a||255<a)throw RangeError("Illegal byte: "+a);return a},l:function(a){if("number"!==typeof a||a!==a)throw TypeError("Illegal char code: "+typeof a);if(0>
a||65535<a)throw RangeError("Illegal char code: "+a);return a},m:function(a){if("number"!==typeof a||a!==a)throw TypeError("Illegal code point: "+typeof a);if(0>a||1114111<a)throw RangeError("Illegal code point: "+a);return a},h:function(a){return 128>a?1:2048>a?2:65536>a?3:4},n:function(b){for(var c,d=0;null!==(c=b());)d+=a.h(c);return d},b:function(b){var c=0,d=0;a.f(b,function(b){++c;d+=a.h(b)});return[c,d]}};return a}(),s=String.fromCharCode;k.a=function(a){var b=0;return function(){return b<
a.length?a.charCodeAt(b++):null}};k.c=function(){var a=[],b=[];return function(){if(0===arguments.length)return b.join("")+s.apply(String,a);1024<a.length+arguments.length&&(b.push(s.apply(String,a)),a.length=0);Array.prototype.push.apply(a,arguments)}};d.prototype.toUTF8=function(a,b){"undefined"===typeof a&&(a=this.offset);"undefined"===typeof b&&(b=this.limit);if(!this.noAssert){if("number"!==typeof a||0!==a%1)throw new TypeError("Illegal begin: Not an integer");a>>>=0;if("number"!==typeof b||
0!==b%1)throw new TypeError("Illegal end: Not an integer");b>>>=0;if(0>a||a>b||b>this.buffer.byteLength)throw new RangeError("Illegal range: 0 <= "+a+" <= "+b+" <= "+this.buffer.byteLength);}var c=this,d;try{k.d(function(){return a<b?c.view.getUint8(a++):null},d=k.c())}catch(h){if(a!==b)throw new RangeError("Illegal range: Truncated data, "+a+" != "+b);}return d()};d.fromUTF8=function(a,b,c){if(!c&&"string"!==typeof a)throw new TypeError("Illegal str: Not a string");var e=new d(k.b(k.a(a),!0)[1],
b,c),h=0;k.e(k.a(a),function(a){e.view.setUint8(h++,a)});e.limit=h;return e};return d}"undefined"!=typeof module&&module.exports?module.exports=s(require("long")):"undefined"!==typeof define&&define.amd?define("ByteBuffer",["Math/Long"],function(l){return s(l)}):(r.dcodeIO||(r.dcodeIO={}),r.dcodeIO.ByteBuffer=s(r.dcodeIO.Long))})(this);

},{"long":56}],55:[function(require,module,exports){
/*
 Copyright 2013 Daniel Wirtz <dcode@dcode.io>
 Copyright 2009 The Closure Library Authors. All Rights Reserved.

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS-IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 */
/**
 * @license Long.js (c) 2013 Daniel Wirtz <dcode@dcode.io>
 * Released under the Apache License, Version 2.0
 * Derived from goog.math.Long from the Closure Library
 * see: https://github.com/dcodeIO/Long.js for details
 */
(function(global) {
    "use strict";

    /**
     * Constructs a 64-bit two's-complement integer, given its low and high 32-bit
     * values as *signed* integers.  See the from* functions below for more
     * convenient ways of constructing Longs.
     *
     * The internal representation of a long is the two given signed, 32-bit values.
     * We use 32-bit pieces because these are the size of integers on which
     * Javascript performs bit-operations.  For operations like addition and
     * multiplication, we split each number into 16-bit pieces, which can easily be
     * multiplied within Javascript's floating-point representation without overflow
     * or change in sign.
     *
     * In the algorithms below, we frequently reduce the negative case to the
     * positive case by negating the input(s) and then post-processing the result.
     * Note that we must ALWAYS check specially whether those values are MIN_VALUE
     * (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as
     * a positive number, it overflows back into a negative).  Not handling this
     * case would often result in infinite recursion.
     * 
     * @exports Long
     * @class A Long class for representing a 64-bit two's-complement integer value.
     * @param {number|!{low: number, high: number, unsigned: boolean}} low The low (signed) 32 bits of the long.
     *  Optionally accepts a Long-like object as the first parameter.
     * @param {number=} high The high (signed) 32 bits of the long.
     * @param {boolean=} unsigned Whether unsigned or not. Defaults to `false` (signed).
     * @constructor
     */
    var Long = function(low, high, unsigned) {
        if (low && typeof low === 'object') {
            high = low.high;
            unsigned = low.unsigned;
            low = low.low;
        }
        
        /**
         * The low 32 bits as a signed value.
         * @type {number}
         * @expose
         */
        this.low = low | 0;

        /**
         * The high 32 bits as a signed value.
         * @type {number}
         * @expose
         */
        this.high = high | 0;

        /**
         * Whether unsigned or not.
         * @type {boolean}
         * @expose
         */
        this.unsigned = !!unsigned;
    };

    // NOTE: Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from* methods on which they depend.

    // NOTE: The following cache variables are used internally only and are therefore not exposed as properties of the
    // Long class.
    
    /**
     * A cache of the Long representations of small integer values.
     * @type {!Object}
     */
    var INT_CACHE = {};

    /**
     * A cache of the Long representations of small unsigned integer values.
     * @type {!Object}
     */
    var UINT_CACHE = {};

    /**
     * Returns a Long representing the given (32-bit) integer value.
     * @param {number} value The 32-bit integer in question.
     * @param {boolean=} unsigned Whether unsigned or not. Defaults to false (signed).
     * @return {!Long} The corresponding Long value.
     * @expose
     */
    Long.fromInt = function(value, unsigned) {
        var obj, cachedObj;
        if (!unsigned) {
            value = value | 0;
            if (-128 <= value && value < 128) {
                cachedObj = INT_CACHE[value];
                if (cachedObj) return cachedObj;
            }
            obj = new Long(value, value < 0 ? -1 : 0, false);
            if (-128 <= value && value < 128) {
                INT_CACHE[value] = obj;
            }
            return obj;
        } else {
            value = value >>> 0;
            if (0 <= value && value < 256) {
                cachedObj = UINT_CACHE[value];
                if (cachedObj) return cachedObj;
            }
            obj = new Long(value, (value | 0) < 0 ? -1 : 0, true);
            if (0 <= value && value < 256) {
                UINT_CACHE[value] = obj;
            }
            return obj;
        }
    };

    /**
     * Returns a Long representing the given value, provided that it is a finite
     * number.  Otherwise, zero is returned.
     * @param {number} value The number in question.
     * @param {boolean=} unsigned Whether unsigned or not. Defaults to false (signed).
     * @return {!Long} The corresponding Long value.
     * @expose
     */
    Long.fromNumber = function(value, unsigned) {
        unsigned = !!unsigned;
        if (isNaN(value) || !isFinite(value)) {
            return Long.ZERO;
        } else if (!unsigned && value <= -TWO_PWR_63_DBL) {
            return Long.MIN_SIGNED_VALUE;
        } else if (unsigned && value <= 0) {
            return Long.MIN_UNSIGNED_VALUE;
        } else if (!unsigned && value + 1 >= TWO_PWR_63_DBL) {
            return Long.MAX_SIGNED_VALUE;
        } else if (unsigned && value >= TWO_PWR_64_DBL) {
            return Long.MAX_UNSIGNED_VALUE;
        } else if (value < 0) {
            return Long.fromNumber(-value, false).negate();
        } else {
            return new Long((value % TWO_PWR_32_DBL) | 0, (value / TWO_PWR_32_DBL) | 0, unsigned);
        }
    };

    /**
     * Returns a Long representing the 64bit integer that comes by concatenating the given low and high bits. Each is
     *  assumed to use 32 bits.
     * @param {number} lowBits The low 32 bits.
     * @param {number} highBits The high 32 bits.
     * @param {boolean=} unsigned Whether unsigned or not. Defaults to false (signed).
     * @return {!Long} The corresponding Long value.
     * @expose
     */
    Long.fromBits = function(lowBits, highBits, unsigned) {
        return new Long(lowBits, highBits, unsigned);
    };

    /**
     * Returns a Long representing the 64bit integer that comes by concatenating the given low, middle and high bits.
     *  Each is assumed to use 28 bits.
     * @param {number} part0 The low 28 bits
     * @param {number} part1 The middle 28 bits
     * @param {number} part2 The high 28 (8) bits
     * @param {boolean=} unsigned Whether unsigned or not. Defaults to false (signed).
     * @return {!Long}
     * @expose
     */
    Long.from28Bits = function(part0, part1, part2, unsigned) {
        // 00000000000000000000000000001111 11111111111111111111111122222222 2222222222222
        // LLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH
        return Long.fromBits(part0 | (part1 << 28), (part1 >>> 4) | (part2) << 24, unsigned);
    };

    /**
     * Returns a Long representation of the given string, written using the given
     * radix.
     * @param {string} str The textual representation of the Long.
     * @param {(boolean|number)=} unsigned Whether unsigned or not. Defaults to false (signed).
     * @param {number=} radix The radix in which the text is written.
     * @return {!Long} The corresponding Long value.
     * @expose
     */
    Long.fromString = function(str, unsigned, radix) {
        if (str.length == 0) {
            throw(new Error('number format error: empty string'));
        }
        if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity") {
            return Long.ZERO;
        }
        if (typeof unsigned === 'number') { // For goog.math.Long compatibility
            radix = unsigned;
            unsigned = false;
        }
        radix = radix || 10;
        if (radix < 2 || 36 < radix) {
            throw(new Error('radix out of range: ' + radix));
        }

        if (str.charAt(0) == '-') {
            return Long.fromString(str.substring(1), unsigned, radix).negate();
        } else if (str.indexOf('-') >= 0) {
            throw(new Error('number format error: interior "-" character: ' + str));
        }

        // Do several (8) digits each time through the loop, so as to
        // minimize the calls to the very expensive emulated div.
        var radixToPower = Long.fromNumber(Math.pow(radix, 8));

        var result = Long.ZERO;
        for (var i = 0; i < str.length; i += 8) {
            var size = Math.min(8, str.length - i);
            var value = parseInt(str.substring(i, i + size), radix);
            if (size < 8) {
                var power = Long.fromNumber(Math.pow(radix, size));
                result = result.multiply(power).add(Long.fromNumber(value));
            } else {
                result = result.multiply(radixToPower);
                result = result.add(Long.fromNumber(value));
            }
        }
        result.unsigned = unsigned;
        return result;
    };

    // NOTE: the compiler should inline these constant values below and then remove these variables, so there should be
    // no runtime penalty for these.
    
    // NOTE: The following constant values are used internally only and are therefore not exposed as properties of the
    // Long class.

    /**
     * @type {number}
     */
    var TWO_PWR_16_DBL = 1 << 16;

    /**
     * @type {number}
     */
    var TWO_PWR_24_DBL = 1 << 24;

    /**
     * @type {number}
     */
    var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;

    /**
     * @type {number}
     */
    var TWO_PWR_31_DBL = TWO_PWR_32_DBL / 2;

    /**
     * @type {number}
     */
    var TWO_PWR_48_DBL = TWO_PWR_32_DBL * TWO_PWR_16_DBL;

    /**
     * @type {number}
     */
    var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;

    /**
     * @type {number}
     */
    var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;

    /**
     * @type {!Long}
     */
    var TWO_PWR_24 = Long.fromInt(1 << 24);

    /**
     * @type {!Long}
     * @expose
     */
    Long.ZERO = Long.fromInt(0);

    /**
     * @type {!Long}
     * @expose
     */
    Long.UZERO = Long.fromInt(0, true);

    /**
     * @type {!Long}
     * @expose
     */
    Long.ONE = Long.fromInt(1);

    /**
     * @type {!Long}
     * @expose
     */
    Long.UONE = Long.fromInt(1, true);

    /**
     * @type {!Long}
     * @expose
     */
    Long.NEG_ONE = Long.fromInt(-1);

    /**
     * @type {!Long}
     * @expose
     */
    Long.MAX_SIGNED_VALUE = Long.fromBits(0xFFFFFFFF | 0, 0x7FFFFFFF | 0, false);

    /**
     * @type {!Long}
     * @expose
     */
    Long.MAX_UNSIGNED_VALUE = Long.fromBits(0xFFFFFFFF | 0, 0xFFFFFFFF | 0, true);

    /**
     * Alias of {@link Long.MAX_SIGNED_VALUE} for goog.math.Long compatibility.
     * @type {!Long}
     * @expose
     */
    Long.MAX_VALUE = Long.MAX_SIGNED_VALUE;

    /**
     * @type {!Long}
     * @expose
     */
    Long.MIN_SIGNED_VALUE = Long.fromBits(0, 0x80000000 | 0, false);

    /**
     * @type {!Long}
     * @expose
     */
    Long.MIN_UNSIGNED_VALUE = Long.fromBits(0, 0, true);

    /**
     * Alias of {@link Long.MIN_SIGNED_VALUE}  for goog.math.Long compatibility.
     * @type {!Long}
     * @expose
     */
    Long.MIN_VALUE = Long.MIN_SIGNED_VALUE;

    /**
     * @return {number} The value, assuming it is a 32-bit integer.
     * @expose
     */
    Long.prototype.toInt = function() {
        return this.unsigned ? this.low >>> 0 : this.low;
    };

    /**
     * @return {number} The closest floating-point representation to this value.
     * @expose
     */
    Long.prototype.toNumber = function() {
        if (this.unsigned) {
            return ((this.high >>> 0) * TWO_PWR_32_DBL) + (this.low >>> 0);
        }
        return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
    };

    /**
     * @param {number=} radix The radix in which the text should be written.
     * @return {string} The textual representation of this value.
     * @override
     * @expose
     */
    Long.prototype.toString = function(radix) {
        radix = radix || 10;
        if (radix < 2 || 36 < radix) {
            throw(new Error('radix out of range: ' + radix));
        }
        if (this.isZero()) {
            return '0';
        }
        var rem;
        if (this.isNegative()) { // Unsigned Longs are never negative
            if (this.equals(Long.MIN_SIGNED_VALUE)) {
                // We need to change the Long value before it can be negated, so we remove
                // the bottom-most digit in this base and then recurse to do the rest.
                var radixLong = Long.fromNumber(radix);
                var div = this.div(radixLong);
                rem = div.multiply(radixLong).subtract(this);
                return div.toString(radix) + rem.toInt().toString(radix);
            } else {
                return '-' + this.negate().toString(radix);
            }
        }

        // Do several (6) digits each time through the loop, so as to
        // minimize the calls to the very expensive emulated div.
        var radixToPower = Long.fromNumber(Math.pow(radix, 6));
        rem = this;
        var result = '';
        while (true) {
            var remDiv = rem.div(radixToPower);
            var intval = rem.subtract(remDiv.multiply(radixToPower)).toInt();
            var digits = intval.toString(radix);
            rem = remDiv;
            if (rem.isZero()) {
                return digits + result;
            } else {
                while (digits.length < 6) {
                    digits = '0' + digits;
                }
                result = '' + digits + result;
            }
        }
    };

    /**
     * @return {number} The high 32 bits as a signed value.
     * @expose
     */
    Long.prototype.getHighBits = function() {
        return this.high;
    };

    /**
     * @return {number} The high 32 bits as an unsigned value.
     * @expose
     */
    Long.prototype.getHighBitsUnsigned = function() {
        return this.high >>> 0;
    };

    /**
     * @return {number} The low 32 bits as a signed value.
     * @expose
     */
    Long.prototype.getLowBits = function() {
        return this.low;
    };

    /**
     * @return {number} The low 32 bits as an unsigned value.
     * @expose
     */
    Long.prototype.getLowBitsUnsigned = function() {
        return this.low >>> 0;
    };

    /**
     * @return {number} Returns the number of bits needed to represent the absolute
     *     value of this Long.
     * @expose
     */
    Long.prototype.getNumBitsAbs = function() {
        if (this.isNegative()) { // Unsigned Longs are never negative
            if (this.equals(Long.MIN_SIGNED_VALUE)) {
                return 64;
            } else {
                return this.negate().getNumBitsAbs();
            }
        } else {
            var val = this.high != 0 ? this.high : this.low;
            for (var bit = 31; bit > 0; bit--) {
                if ((val & (1 << bit)) != 0) {
                    break;
                }
            }
            return this.high != 0 ? bit + 33 : bit + 1;
        }
    };

    /**
     * @return {boolean} Whether this value is zero.
     * @expose
     */
    Long.prototype.isZero = function() {
        return this.high == 0 && this.low == 0;
    };

    /**
     * @return {boolean} Whether this value is negative.
     * @expose
     */
    Long.prototype.isNegative = function() {
        return !this.unsigned && this.high < 0;
    };

    /**
     * @return {boolean} Whether this value is odd.
     * @expose
     */
    Long.prototype.isOdd = function() {
        return (this.low & 1) == 1;
    };

    /**
     * @return {boolean} Whether this value is even.
     */
    Long.prototype.isEven = function() {
        return (this.low & 1) == 0;
    };

    /**
     * @param {Long} other Long to compare against.
     * @return {boolean} Whether this Long equals the other.
     * @expose
     */
    Long.prototype.equals = function(other) {
        if (this.unsigned != other.unsigned && (this.high >>> 31) != (other.high >>> 31)) return false;
        return (this.high == other.high) && (this.low == other.low);
    };

    /**
     * @param {Long} other Long to compare against.
     * @return {boolean} Whether this Long does not equal the other.
     * @expose
     */
    Long.prototype.notEquals = function(other) {
        return !this.equals(other);
    };

    /**
     * @param {Long} other Long to compare against.
     * @return {boolean} Whether this Long is less than the other.
     * @expose
     */
    Long.prototype.lessThan = function(other) {
        return this.compare(other) < 0;
    };

    /**
     * @param {Long} other Long to compare against.
     * @return {boolean} Whether this Long is less than or equal to the other.
     * @expose
     */
    Long.prototype.lessThanOrEqual = function(other) {
        return this.compare(other) <= 0;
    };

    /**
     * @param {Long} other Long to compare against.
     * @return {boolean} Whether this Long is greater than the other.
     * @expose
     */
    Long.prototype.greaterThan = function(other) {
        return this.compare(other) > 0;
    };

    /**
     * @param {Long} other Long to compare against.
     * @return {boolean} Whether this Long is greater than or equal to the other.
     * @expose
     */
    Long.prototype.greaterThanOrEqual = function(other) {
        return this.compare(other) >= 0;
    };

    /**
     * Compares this Long with the given one.
     * @param {Long} other Long to compare against.
     * @return {number} 0 if they are the same, 1 if the this is greater, and -1
     *     if the given one is greater.
     * @expose
     */
    Long.prototype.compare = function(other) {
        if (this.equals(other)) {
            return 0;
        }
        var thisNeg = this.isNegative();
        var otherNeg = other.isNegative();
        if (thisNeg && !otherNeg) return -1;
        if (!thisNeg && otherNeg) return 1;
        if (!this.unsigned) {
            // At this point the signs are the same
            return this.subtract(other).isNegative() ? -1 : 1;
        } else {
            // Both are positive if at least one is unsigned
            return (other.high >>> 0) > (this.high >>> 0) || (other.high == this.high && (other.low >>> 0) > (this.low >>> 0)) ? -1 : 1;
        }
    };

    /**
     * @return {!Long} The negation of this value.
     * @expose
     */
    Long.prototype.negate = function() {
        if (!this.unsigned && this.equals(Long.MIN_SIGNED_VALUE)) {
            return Long.MIN_SIGNED_VALUE;
        }
        return this.not().add(Long.ONE);
    };

    /**
     * Returns the sum of this and the given Long.
     * @param {Long} other Long to add to this one.
     * @return {!Long} The sum of this and the given Long.
     * @expose
     */
    Long.prototype.add = function(other) {
        // Divide each number into 4 chunks of 16 bits, and then sum the chunks.
        
        var a48 = this.high >>> 16;
        var a32 = this.high & 0xFFFF;
        var a16 = this.low >>> 16;
        var a00 = this.low & 0xFFFF;

        var b48 = other.high >>> 16;
        var b32 = other.high & 0xFFFF;
        var b16 = other.low >>> 16;
        var b00 = other.low & 0xFFFF;

        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
        c00 += a00 + b00;
        c16 += c00 >>> 16;
        c00 &= 0xFFFF;
        c16 += a16 + b16;
        c32 += c16 >>> 16;
        c16 &= 0xFFFF;
        c32 += a32 + b32;
        c48 += c32 >>> 16;
        c32 &= 0xFFFF;
        c48 += a48 + b48;
        c48 &= 0xFFFF;
        return Long.fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
    };

    /**
     * Returns the difference of this and the given Long.
     * @param {Long} other Long to subtract from this.
     * @return {!Long} The difference of this and the given Long.
     * @expose
     */
    Long.prototype.subtract = function(other) {
        return this.add(other.negate());
    };

    /**
     * Returns the product of this and the given long.
     * @param {Long} other Long to multiply with this.
     * @return {!Long} The product of this and the other.
     * @expose
     */
    Long.prototype.multiply = function(other) {
        if (this.isZero()) {
            return Long.ZERO;
        } else if (other.isZero()) {
            return Long.ZERO;
        }

        if (this.equals(Long.MIN_VALUE)) {
            return other.isOdd() ? Long.MIN_VALUE : Long.ZERO;
        } else if (other.equals(Long.MIN_VALUE)) {
            return this.isOdd() ? Long.MIN_VALUE : Long.ZERO;
        }

        if (this.isNegative()) {
            if (other.isNegative()) {
                return this.negate().multiply(other.negate());
            } else {
                return this.negate().multiply(other).negate();
            }
        } else if (other.isNegative()) {
            return this.multiply(other.negate()).negate();
        }
        // If both longs are small, use float multiplication
        if (this.lessThan(TWO_PWR_24) &&
            other.lessThan(TWO_PWR_24)) {
            return Long.fromNumber(this.toNumber() * other.toNumber(), this.unsigned);
        }

        // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.
        // We can skip products that would overflow.
        
        var a48 = this.high >>> 16;
        var a32 = this.high & 0xFFFF;
        var a16 = this.low >>> 16;
        var a00 = this.low & 0xFFFF;

        var b48 = other.high >>> 16;
        var b32 = other.high & 0xFFFF;
        var b16 = other.low >>> 16;
        var b00 = other.low & 0xFFFF;

        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
        c00 += a00 * b00;
        c16 += c00 >>> 16;
        c00 &= 0xFFFF;
        c16 += a16 * b00;
        c32 += c16 >>> 16;
        c16 &= 0xFFFF;
        c16 += a00 * b16;
        c32 += c16 >>> 16;
        c16 &= 0xFFFF;
        c32 += a32 * b00;
        c48 += c32 >>> 16;
        c32 &= 0xFFFF;
        c32 += a16 * b16;
        c48 += c32 >>> 16;
        c32 &= 0xFFFF;
        c32 += a00 * b32;
        c48 += c32 >>> 16;
        c32 &= 0xFFFF;
        c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
        c48 &= 0xFFFF;
        return Long.fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
    };

    /**
     * Returns this Long divided by the given one.
     * @param {Long} other Long by which to divide.
     * @return {!Long} This Long divided by the given one.
     * @expose
     */
    Long.prototype.div = function(other) {
        if (other.isZero()) {
            throw(new Error('division by zero'));
        } else if (this.isZero()) {
            return this.unsigned ? Long.UZERO : Long.ZERO;
        }
        var approx, rem, res;
        if (this.equals(Long.MIN_SIGNED_VALUE)) {
            if (other.equals(Long.ONE) || other.equals(Long.NEG_ONE)) {
                return Long.MIN_SIGNED_VALUE;  // recall that -MIN_VALUE == MIN_VALUE
            } else if (other.equals(Long.MIN_SIGNED_VALUE)) {
                return Long.ONE;
            } else {
                // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.
                var halfThis = this.shiftRight(1);
                approx = halfThis.div(other).shiftLeft(1);
                if (approx.equals(Long.ZERO)) {
                    return other.isNegative() ? Long.ONE : Long.NEG_ONE;
                } else {
                    rem = this.subtract(other.multiply(approx));
                    res = approx.add(rem.div(other));
                    return res;
                }
            }
        } else if (other.equals(Long.MIN_SIGNED_VALUE)) {
            return this.unsigned ? Long.UZERO : Long.ZERO;
        }
        if (this.isNegative()) {
            if (other.isNegative()) {
                return this.negate().div(other.negate());
            } else {
                return this.negate().div(other).negate();
            }
        } else if (other.isNegative()) {
            return this.div(other.negate()).negate();
        }
        
        // Repeat the following until the remainder is less than other:  find a
        // floating-point that approximates remainder / other *from below*, add this
        // into the result, and subtract it from the remainder.  It is critical that
        // the approximate value is less than or equal to the real value so that the
        // remainder never becomes negative.
        res = Long.ZERO;
        rem = this;
        while (rem.greaterThanOrEqual(other)) {
            // Approximate the result of division. This may be a little greater or
            // smaller than the actual value.
            approx = Math.max(1, Math.floor(rem.toNumber() / other.toNumber()));

            // We will tweak the approximate result by changing it in the 48-th digit or
            // the smallest non-fractional digit, whichever is larger.
            var log2 = Math.ceil(Math.log(approx) / Math.LN2);
            var delta = (log2 <= 48) ? 1 : Math.pow(2, log2 - 48);

            // Decrease the approximation until it is smaller than the remainder.  Note
            // that if it is too large, the product overflows and is negative.
            var approxRes = Long.fromNumber(approx, this.unsigned);
            var approxRem = approxRes.multiply(other);
            while (approxRem.isNegative() || approxRem.greaterThan(rem)) {
                approx -= delta;
                approxRes = Long.fromNumber(approx, this.unsigned);
                approxRem = approxRes.multiply(other);
            }

            // We know the answer can't be zero... and actually, zero would cause
            // infinite recursion since we would make no progress.
            if (approxRes.isZero()) {
                approxRes = Long.ONE;
            }

            res = res.add(approxRes);
            rem = rem.subtract(approxRem);
        }
        return res;
    };

    /**
     * Returns this Long modulo the given one.
     * @param {Long} other Long by which to mod.
     * @return {!Long} This Long modulo the given one.
     * @expose
     */
    Long.prototype.modulo = function(other) {
        return this.subtract(this.div(other).multiply(other));
    };

    /**
     * @return {!Long} The bitwise-NOT of this value.
     * @expose
     */
    Long.prototype.not = function() {
        return Long.fromBits(~this.low, ~this.high, this.unsigned);
    };

    /**
     * Returns the bitwise-AND of this Long and the given one.
     * @param {Long} other The Long with which to AND.
     * @return {!Long} The bitwise-AND of this and the other.
     * @expose
     */
    Long.prototype.and = function(other) {
        return Long.fromBits(this.low & other.low, this.high & other.high, this.unsigned);
    };

    /**
     * Returns the bitwise-OR of this Long and the given one.
     * @param {Long} other The Long with which to OR.
     * @return {!Long} The bitwise-OR of this and the other.
     * @expose
     */
    Long.prototype.or = function(other) {
        return Long.fromBits(this.low | other.low, this.high | other.high, this.unsigned);
    };

    /**
     * Returns the bitwise-XOR of this Long and the given one.
     * @param {Long} other The Long with which to XOR.
     * @return {!Long} The bitwise-XOR of this and the other.
     * @expose
     */
    Long.prototype.xor = function(other) {
        return Long.fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
    };

    /**
     * Returns this Long with bits shifted to the left by the given amount.
     * @param {number} numBits The number of bits by which to shift.
     * @return {!Long} This shifted to the left by the given amount.
     * @expose
     */
    Long.prototype.shiftLeft = function(numBits) {
        numBits &= 63;
        if (numBits == 0) {
            return this;
        } else {
            var low = this.low;
            if (numBits < 32) {
                var high = this.high;
                return Long.fromBits(low << numBits, (high << numBits) | (low >>> (32 - numBits)), this.unsigned);
            } else {
                return Long.fromBits(0, low << (numBits - 32), this.unsigned);
            }
        }
    };

    /**
     * Returns this Long with bits shifted to the right by the given amount.
     * @param {number} numBits The number of bits by which to shift.
     * @return {!Long} This shifted to the right by the given amount.
     * @expose
     */
    Long.prototype.shiftRight = function(numBits) {
        numBits &= 63;
        if (numBits == 0) {
            return this;
        } else {
            var high = this.high;
            if (numBits < 32) {
                var low = this.low;
                return Long.fromBits((low >>> numBits) | (high << (32 - numBits)), high >> numBits, this.unsigned);
            } else {
                return Long.fromBits(high >> (numBits - 32), high >= 0 ? 0 : -1, this.unsigned);
            }
        }
    };

    /**
     * Returns this Long with bits shifted to the right by the given amount, with
     * the new top bits matching the current sign bit.
     * @param {number} numBits The number of bits by which to shift.
     * @return {!Long} This shifted to the right by the given amount, with
     *     zeros placed into the new leading bits.
     * @expose
     */
    Long.prototype.shiftRightUnsigned = function(numBits) {
        numBits &= 63;
        if (numBits == 0) {
            return this;
        } else {
            var high = this.high;
            if (numBits < 32) {
                var low = this.low;
                return Long.fromBits((low >>> numBits) | (high << (32 - numBits)), high >>> numBits, this.unsigned);
            } else if (numBits == 32) {
                return Long.fromBits(high, 0, this.unsigned);
            } else {
                return Long.fromBits(high >>> (numBits - 32), 0, this.unsigned);
            }
        }
    };

    /**
     * @return {!Long} Signed long
     * @expose
     */
    Long.prototype.toSigned = function() {
        var l = this.clone();
        l.unsigned = false;
        return l;
    };

    /**
     * @return {!Long} Unsigned long
     * @expose
     */
    Long.prototype.toUnsigned = function() {
        var l = this.clone();
        l.unsigned = true;
        return l;
    };
    
    /**
     * @return {Long} Cloned instance with the same low/high bits and unsigned flag.
     * @expose
     */
    Long.prototype.clone = function() {
        return new Long(this.low, this.high, this.unsigned);
    };

    // Enable module loading if available
    if (typeof module != 'undefined' && module["exports"]) { // CommonJS
        module["exports"] = Long;
    } else if (typeof define != 'undefined' && define["amd"]) { // AMD
        define("Math/Long", [], function() { return Long; });
    } else { // Shim
        if (!global["dcodeIO"]) {
            global["dcodeIO"] = {};
        }
        global["dcodeIO"]["Long"] = Long;
    }

})(this);

},{}],56:[function(require,module,exports){
/*
 Copyright 2013 Daniel Wirtz <dcode@dcode.io>
 Copyright 2009 The Closure Library Authors. All Rights Reserved.

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS-IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 */

module.exports = require("./dist/Long.js");

},{"./dist/Long.js":55}],57:[function(require,module,exports){
var furious = require("../lib/furious.js");
var expect = require("chai").expect;

var context = null;
before(function(done) {
	furious.init(function(ctx) {
		context = ctx;
		done();
	});
});

describe("Context", function(){
	describe("barrier", function() {
		it("Calls the callback", function(done) {
			context.barrier(function () {
				done();
			});
		});
		it("Executes after preceeding commands have finished", function(done) {
			var x = context.zeros([3, 3]);
			var getHasFinished = false;
			x.get(function(data) {
				getHasFinished = true;
			});
			context.barrier(function (){
				expect(getHasFinished).to.be.true;
				done();
			});
		});
		it("Executes before subsequent commands have started", function(done) {
			var x = context.zeros([3, 3]);
			var barrierHasFinished = false;
			context.barrier(function (){
				barrierHasFinished = true;
			});
			x.get(function(x) {
				expect(barrierHasFinished).to.be.true;
				done();
			});
		});
	});
	describe("empty", function(){
		it("Creates array with specified shape", function() {
			var x = context.empty(42);
			var y = context.empty([42]);
			var z = context.empty([4, 2]);
			expect(x.shape).to.deep.equal([42]);
			expect(y.shape).to.deep.equal([42]);
			expect(z.shape).to.deep.equal([4, 2]);
			x.invalidate();
			y.invalidate();
			z.invalidate();
		});
		it("Creates array with specified data type (f64 by default)", function() {
			var x = context.empty([4, 2]);
			var y = context.empty([4, 2], new furious.DataType("f64"));
			var z = context.empty([4, 2], new furious.DataType("f32"));
			expect(x.dataType.equals(new furious.DataType("f64"))).to.be.true;
			expect(y.dataType.equals(new furious.DataType("f64"))).to.be.true;
			expect(z.dataType.equals(new furious.DataType("f32"))).to.be.true;
			x.invalidate();
			y.invalidate();
			z.invalidate();
		});
	});
	describe("zeros", function(){
		it("Creates array with specified shape", function() {
			var x = context.zeros(42);
			var y = context.zeros([42]);
			var z = context.zeros([4, 2]);
			expect(x.shape).to.deep.equal([42]);
			expect(y.shape).to.deep.equal([42]);
			expect(z.shape).to.deep.equal([4, 2]);
			x.invalidate();
			y.invalidate();
			z.invalidate();
		});
		it("Creates array with specified data type (f64 by default)", function() {
			var x = context.zeros([4, 2]);
			var y = context.zeros([4, 2], new furious.DataType("f64"));
			var z = context.zeros([4, 2], new furious.DataType("f32"));
			expect(x.dataType.equals(new furious.DataType("f64"))).to.be.true;
			expect(y.dataType.equals(new furious.DataType("f64"))).to.be.true;
			expect(z.dataType.equals(new furious.DataType("f32"))).to.be.true;
			x.invalidate();
			y.invalidate();
			z.invalidate();
		});
		it("Creates array with all elements initialized to zero", function(done) {
			var x = context.zeros([3, 2], new furious.DataType("f64"));
			var y = context.zeros([2, 3], new furious.DataType("f32"));
			context.get(x, y, function(x, y) {
				expect(x).to.deep.equal([[0.0, 0.0],
				                         [0.0, 0.0],
				                         [0.0, 0.0]]);
				expect(y).to.deep.equal([[0.0, 0.0, 0.0],
				                         [0.0, 0.0, 0.0]]);
				done();
			});
		});
	});
	describe("ones", function(){
		it("Creates array with specified shape", function() {
			var x = context.ones(42);
			var y = context.ones([42]);
			var z = context.ones([4, 2]);
			expect(x.shape).to.deep.equal([42]);
			expect(y.shape).to.deep.equal([42]);
			expect(z.shape).to.deep.equal([4, 2]);
			x.invalidate();
			y.invalidate();
			z.invalidate();
		});
		it("Creates array with specified data type (f64 by default)", function() {
			var x = context.ones([4, 2]);
			var y = context.ones([4, 2], new furious.DataType("f64"));
			var z = context.ones([4, 2], new furious.DataType("f32"));
			expect(x.dataType.equals(new furious.DataType("f64"))).to.be.true;
			expect(y.dataType.equals(new furious.DataType("f64"))).to.be.true;
			expect(z.dataType.equals(new furious.DataType("f32"))).to.be.true;
			x.invalidate();
			y.invalidate();
			z.invalidate();
		});
		it("Creates array with all elements initialized to one", function(done) {
			var x = context.ones([3, 2], new furious.DataType("f64"));
			var y = context.ones([2, 3], new furious.DataType("f32"));
			context.get(x, y, function(x, y) {
				expect(x).to.deep.equal([[1.0, 1.0],
				                         [1.0, 1.0],
				                         [1.0, 1.0]]);
				expect(y).to.deep.equal([[1.0, 1.0, 1.0],
				                         [1.0, 1.0, 1.0]]);
				done();
			});
		});
	});
	describe("array", function(){
		it("Creates array of the same length as the provided array", function(){
			var x = context.array([0, 1]);
			var y = context.array([[0, 1],
			                       [2, 3],
			                       [3, 4]]);
			expect(x.length).to.equal(2);
			expect(y.length).to.equal(6);
			x.invalidate();
			y.invalidate();
		});
		it("Creates array of the same shape as the provided array", function(){
			var x = context.array([0, 1]);
			var y = context.array([[0, 1],
			                       [2, 3],
			                       [3, 4]]);
			var z = context.array([[[1, 2, 3], [ 4,  5,  6]],
			                       [[7, 8, 9], [10, 11, 12]]]);
			expect(x.shape).to.deep.equal([2]);
			expect(y.shape).to.deep.equal([3, 2]);
			expect(z.shape).to.deep.equal([2, 2, 3]);
			x.invalidate();
			y.invalidate();
			z.invalidate();
		});
		it("Creates array with the same data as the provided array", function(done){
			var array = [[[1, 2, 3], [ 4,  5,  6]],
			             [[7, 8, 9], [10, 11, 12]]];
			var x = context.array(array, new furious.DataType("f64"));
			var y = context.array(array, new furious.DataType("f32"));
			context.get(x, y, function(x, y) {
				expect(x).to.deep.equal(array);
				expect(y).to.deep.equal(array);
				done();
			});
		});
	});
	describe("linspace", function(){
		it("Has length of 50 with default arguments", function(){
			expect((context.linspace(0, 1)).length).to.equal(50);
		});
		it("Has the specified number of samples", function(){
			expect((context.linspace(0, 1, 243)).length).to.equal(243);
		});
		it("Has expected values", function(done){
			var start = 50;
			var stop = 99;
			var x = context.linspace(start, stop);
			x.get(function(result) {
				for (var i = 0; i < result.length; i++) {
					expect(result[i]).to.equal(start+i);
				}
				done();
			});
		});
		describe("with includeStop === false", function(){
			it("Has the specified number of samples", function(){
				expect((context.linspace(0, 1, 243, false)).length).to.equal(243);
			});
			it("Does not contain the right endpoint", function(done){
				var x = context.linspace(-1, 1, 1000, false);
				x.get(function(result) {
					expect(result[result.length - 1]).to.not.equal(1);
					done();
				});
			});
		});
	});
	describe("neg", function() {
		var xRef = [ 1, -7.5,  0, -15];
		var yRef = [-1,  7.5, -0,  15];
		var dataTypes = ["f32", "f64"];

		describe("With no output array supplied", function() {
			it("Creates an output array with the same shape as input array", function() {
				var x = context.ones([2, 3, 4]);
				var y = context.neg(x);
				expect(y.shape).to.deep.equal([2, 3, 4]);
				y.invalidate();
			});

			for (var i = 0; i < dataTypes.length; i++) {
				(function(dataType) {
					it("Creates an output array with the same data type as input array (" + dataType + " data type)", function() {
						var x = context.array(xRef, new furious.DataType(dataType));
						var y = context.neg(x);
						expect(y.dataType.equals(new furious.DataType(dataType))).to.be.true;
						y.invalidate();
					});
				})(dataTypes[i]);
			}

			for (var i = 0; i < dataTypes.length; i++) {
				(function(dataType) {
					it("Creates an output array with negated elements (" + dataType + " data type)", function(done) {
						var x = context.array(xRef, new furious.DataType(dataType));
						var y = context.neg(x);
						y.get(function(y) {
							expect(y).to.deep.equal(yRef);
							done();
						});
					});
				})(dataTypes[i]);
			}
		});
		describe("With an output array", function() {
			for (var i = 0; i < dataTypes.length; i++) {
				(function(dataType) {
					it("Populates the output array with negated elements (" + dataType + " data type)", function(done) {
						var x = context.array(xRef, new furious.DataType(dataType));
						var y = context.ones(x.shape, x.dataType);
						context.neg(x, y);
						y.get(function(y) {
							expect(y).to.deep.equal(yRef);
							done();
						});
					});
				})(dataTypes[i]);
			}
		});
	});
	describe("abs", function() {
		var xRef = [1, -7.5, 0, -15];
		var yRef = [1,  7.5, 0,  15];
		var dataTypes = ["f32", "f64"];

		describe("With no output array supplied", function() {
			it("Creates an output array with the same shape as input array", function() {
				var x = context.ones([2, 3, 4]);
				var y = context.abs(x);
				expect(y.shape).to.deep.equal([2, 3, 4]);
				y.invalidate();
			});

			for (var i = 0; i < dataTypes.length; i++) {
				(function(dataType) {
					it("Creates an output array with the same data type as input array (" + dataType + " data type)", function() {
						var x = context.array(xRef, new furious.DataType(dataType));
						var y = context.abs(x);
						expect(y.dataType.equals(new furious.DataType(dataType))).to.be.true;
						y.invalidate();
					});
				})(dataTypes[i]);
			}

			for (var i = 0; i < dataTypes.length; i++) {
				(function(dataType) {
					it("Creates an output array with absolute values of elements (" + dataType + " data type)", function(done) {
						var x = context.array(xRef, new furious.DataType(dataType));
						var y = context.abs(x);
						y.get(function(y) {
							expect(y).to.deep.equal(yRef);
							done();
						});
					});
				})(dataTypes[i]);
			}
		});
		describe("With an output array", function() {
			for (var i = 0; i < dataTypes.length; i++) {
				(function(dataType) {
					it("Populates the output array with absolute values of elements (" + dataType + " data type)", function(done) {
						var x = context.array(xRef, new furious.DataType(dataType));
						var y = context.ones(x.shape, x.dataType);
						context.abs(x, y);
						y.get(function(y) {
							expect(y).to.deep.equal(yRef);
							done();
						});
					});
				})(dataTypes[i]);
			}
		});
	});
	describe("exp", function() {
		var xRef = [1, -1, 0];
		var dataTypes = ["f32", "f64"];

		describe("With no output array supplied", function() {
			it("Creates an output array with the same shape as input array", function() {
				var x = context.ones([2, 3, 4]);
				var y = context.exp(x);
				expect(y.shape).to.deep.equal([2, 3, 4]);
				y.invalidate();
			});

			for (var i = 0; i < dataTypes.length; i++) {
				(function(dataType) {
					it("Creates an output array with the same data type as input array (" + dataType + " data type)", function() {
						var x = context.array(xRef, new furious.DataType(dataType));
						var y = context.exp(x);
						expect(y.dataType.equals(new furious.DataType(dataType))).to.be.true;
						y.invalidate();
					});
				})(dataTypes[i]);
			}

			for (var i = 0; i < dataTypes.length; i++) {
				(function(dataType) {
					it("Creates an output array with absolute values of elements (" + dataType + " data type)", function(done) {
						var x = context.array(xRef, new furious.DataType(dataType));
						var y = context.exp(x);
						y.get(function(y) {
							for (var k = 0; k < y.length; k++) {
								expect(y[k]).to.be.closeTo(Math.exp(xRef[k]), Math.exp(xRef[k]) * 3 * x.dataType.epsilon);
							}
							done();
						});
					});
				})(dataTypes[i]);
			}
		});
		describe("With an output array", function() {
			for (var i = 0; i < dataTypes.length; i++) {
				(function(dataType) {
					it("Populates the output array with absolute values of elements (" + dataType + " data type)", function(done) {
						var x = context.array(xRef, new furious.DataType(dataType));
						var y = context.ones(x.shape, x.dataType);
						context.exp(x, y);
						y.get(function(y) {
							for (var k = 0; k < y.length; k++) {
								expect(y[k]).to.be.closeTo(Math.exp(xRef[k]), Math.exp(xRef[k]) * 3 * x.dataType.epsilon);
							}
							done();
						});
					});
				})(dataTypes[i]);
			}
		});
	});
	describe("log", function() {
		var xRef = [1, 3, 10];
		var dataTypes = ["f32", "f64"];

		describe("With no output array supplied", function() {
			it("Creates an output array with the same shape as input array", function() {
				var x = context.ones([2, 3, 4]);
				var y = context.log(x);
				expect(y.shape).to.deep.equal([2, 3, 4]);
				y.invalidate();
			});

			for (var i = 0; i < dataTypes.length; i++) {
				(function(dataType) {
					it("Creates an output array with the same data type as input array (" + dataType + " data type)", function() {
						var x = context.array(xRef, new furious.DataType(dataType));
						var y = context.log(x);
						expect(y.dataType.equals(new furious.DataType(dataType))).to.be.true;
						y.invalidate();
					});
				})(dataTypes[i]);
			}

			for (var i = 0; i < dataTypes.length; i++) {
				(function(dataType) {
					it("Creates an output array with absolute values of elements (" + dataType + " data type)", function(done) {
						var x = context.array(xRef, new furious.DataType(dataType));
						var y = context.log(x);
						y.get(function(y) {
							for (var k = 0; k < y.length; k++) {
								expect(y[k]).to.be.closeTo(Math.log(xRef[k]), Math.log(xRef[k]) * 3 * x.dataType.epsilon);
							}
							done();
						});
					});
				})(dataTypes[i]);
			}
		});
		describe("With an output array", function() {
			for (var i = 0; i < dataTypes.length; i++) {
				(function(dataType) {
					it("Populates the output array with absolute values of elements (" + dataType + " data type)", function(done) {
						var x = context.array(xRef, new furious.DataType(dataType));
						var y = context.ones(x.shape, x.dataType);
						context.log(x, y);
						y.get(function(y) {
							for (var k = 0; k < y.length; k++) {
								expect(y[k]).to.be.closeTo(Math.log(xRef[k]), Math.log(xRef[k]) * 3 * x.dataType.epsilon);
							}
							done();
						});
					});
				})(dataTypes[i]);
			}
		});
	});
	describe("sqrt", function() {
		var xRef = [0, 0.25, 1, 9, 10];
		var dataTypes = ["f32", "f64"];

		describe("With no output array supplied", function() {
			it("Creates an output array with the same shape as input array", function() {
				var x = context.ones([2, 3, 4]);
				var y = context.sqrt(x);
				expect(y.shape).to.deep.equal([2, 3, 4]);
				y.invalidate();
			});

			for (var i = 0; i < dataTypes.length; i++) {
				(function(dataType) {
					it("Creates an output array with the same data type as input array (" + dataType + " data type)", function() {
						var x = context.array(xRef, new furious.DataType(dataType));
						var y = context.sqrt(x);
						expect(y.dataType.equals(new furious.DataType(dataType))).to.be.true;
						y.invalidate();
					});
				})(dataTypes[i]);
			}

			for (var i = 0; i < dataTypes.length; i++) {
				(function(dataType) {
					it("Creates an output array with absolute values of elements (" + dataType + " data type)", function(done) {
						var x = context.array(xRef, new furious.DataType(dataType));
						var y = context.sqrt(x);
						y.get(function(y) {
							for (var k = 0; k < y.length; k++) {
								expect(y[k]).to.be.closeTo(Math.sqrt(xRef[k]), Math.sqrt(xRef[k]) * 3 * x.dataType.epsilon);
							}
							done();
						});
					});
				})(dataTypes[i]);
			}
		});
		describe("With an output array", function() {
			for (var i = 0; i < dataTypes.length; i++) {
				(function(dataType) {
					it("Populates the output array with absolute values of elements (" + dataType + " data type)", function(done) {
						var x = context.array(xRef, new furious.DataType(dataType));
						var y = context.ones(x.shape, x.dataType);
						context.sqrt(x, y);
						y.get(function(y) {
							for (var k = 0; k < y.length; k++) {
								expect(y[k]).to.be.closeTo(Math.sqrt(xRef[k]), Math.sqrt(xRef[k]) * 3 * x.dataType.epsilon);
							}
							done();
						});
					});
				})(dataTypes[i]);
			}
		});
	});
	describe("square", function() {
		var xRef = [-2, 0, 0.5, 1, 3];
		var dataTypes = ["f32", "f64"];

		describe("With no output array supplied", function() {
			it("Creates an output array with the same shape as input array", function() {
				var x = context.ones([2, 3, 4]);
				var y = context.square(x);
				expect(y.shape).to.deep.equal([2, 3, 4]);
				y.invalidate();
			});

			for (var i = 0; i < dataTypes.length; i++) {
				(function(dataType) {
					it("Creates an output array with the same data type as input array (" + dataType + " data type)", function() {
						var x = context.array(xRef, new furious.DataType(dataType));
						var y = context.square(x);
						expect(y.dataType.equals(new furious.DataType(dataType))).to.be.true;
						y.invalidate();
					});
				})(dataTypes[i]);
			}

			for (var i = 0; i < dataTypes.length; i++) {
				(function(dataType) {
					it("Creates an output array with absolute values of elements (" + dataType + " data type)", function(done) {
						var x = context.array(xRef, new furious.DataType(dataType));
						var y = context.square(x);
						y.get(function(y) {
							for (var k = 0; k < y.length; k++) {
								expect(y[k]).to.be.closeTo(xRef[k] * xRef[k], xRef[k] * xRef[k] * x.dataType.epsilon);
							}
							done();
						});
					});
				})(dataTypes[i]);
			}
		});
		describe("With an output array", function() {
			for (var i = 0; i < dataTypes.length; i++) {
				(function(dataType) {
					it("Populates the output array with absolute values of elements (" + dataType + " data type)", function(done) {
						var x = context.array(xRef, new furious.DataType(dataType));
						var y = context.ones(x.shape, x.dataType);
						context.square(x, y);
						y.get(function(y) {
							for (var k = 0; k < y.length; k++) {
								expect(y[k]).to.be.closeTo(xRef[k] * xRef[k], xRef[k] * xRef[k] * x.dataType.epsilon);
							}
							done();
						});
					});
				})(dataTypes[i]);
			}
		});
	});
});

},{"../lib/furious.js":6,"chai":14}],58:[function(require,module,exports){
var furious = require("../lib/furious.js");
var expect = require("chai").expect;

describe("DataType", function(){
	describe("f32", function(){
		it("should have size 4", function(){
			var dtype = new furious.DataType("f32");
			expect(dtype.size).to.equal(4);
		});

		it("should have type \"f32\"", function(){
			var dtype = new furious.DataType("f32");
			expect(dtype.type).to.equal("f32");
		});
	});
	describe("f64", function(){
		it("should have size 8", function(){
			var dtype = new furious.DataType("f64");
			expect(dtype.size).to.equal(8);
		});

		it("should have type \"f64\"", function(){
			var dtype = new furious.DataType("f64");
			expect(dtype.type).to.equal("f64");
		});
	});
});

},{"../lib/furious.js":6,"chai":14}],59:[function(require,module,exports){
var furious = require("../lib/furious.js");
var expect = require("chai").expect;

var context = null;
before(function(done) {
	furious.init(function(ctx) {
		context = ctx;
		done();
	});
});

describe("NDArray", function() {
	describe("length", function() {
		it("Equals to the number passed in constructor", function() {
			var x = context.empty(42);
			expect(x.length).to.equal(42);
			x.invalidate();
		});
		it("Equals to the number passed in constructor as an array", function() {
			var x = context.empty([42]);
			expect(x.length).to.equal(42);
			x.invalidate();
		});
		it("Equals to the product of dimensions", function() {
			var x = context.empty([2, 5, 3]);
			expect(x.length).to.equal(30);
			x.invalidate();
		});
	});
	describe("reshape", function() {
		it("Preserves length", function() {
			var x = context.empty([7,5,3]);
			var y = x.reshape([21,5]);
			expect(y.length).to.equal(x.length);
			y.invalidate();
		});
		it("Changes shape", function() {
			var x = context.empty([7,5,3]);
			var y = x.reshape([21,5]);
			expect(y.shape).to.deep.equal([21,5]);
			y.invalidate();
		});
		it("Rearranges data", function(done) {
			var x = context.linspace(1, 8, 8).reshape([2, 2, 2]);
			x.get(function(result) {
				expect(result).to.deep.equal([[[ 1,  2], [ 3,  4]],
											  [[ 5,  6], [ 7,  8]]]);
				done();
			});
		});
	});
	describe("repeat", function() {
		it("Repeats array elements along axis 0", function(done) {
			var x = context.array([[8, 1, 6],
			                       [3, 5, 7],
			                       [4, 9, 2]]);
			x.repeat(2, 0).get(function(y) {
				expect(y).to.deep.equal([[8, 1, 6],
				                         [8, 1, 6],
				                         [3, 5, 7],
				                         [3, 5, 7],
				                         [4, 9, 2],
				                         [4, 9, 2]]);
				done();
			});
		});
		it("Repeats array elements along axis 1", function(done) {
			var x = context.array([[8, 1, 6],
			                       [3, 5, 7],
			                       [4, 9, 2]]);
			x.repeat(2, 1).get(function(y) {
				expect(y).to.deep.equal([[8, 8, 1, 1, 6, 6],
				                         [3, 3, 5, 5, 7, 7],
				                         [4, 4, 9, 9, 2, 2]]);
				done();
			});
		});
	});
	describe("get", function(){
		it("Works with 1-dimensional array", function(done) {
			var x = context.array([42, 10]);
			x.get(function(y) {
				expect(y).to.deep.equal([42, 10]);
				done();
			});
		});
		it("Works with 2-dimensional array", function(done) {
			var array = [[16,  2,  3, 13,  5],
						 [11, 10,  8,  9,  7],
						 [ 6, 12,  4, 14, 15]];
			var x = context.array(array);
			x.get(function(y) {
				expect(y).to.deep.equal(array);
				done();
			});
		});
	});
	describe("add", function() {
		describe("Add array", function() {
			it("Correct result for 1-dimensional arrays", function(done) {
				var x = context.array([1, 4, 9]);
				var y = context.array([8, -1, 10]);
				var z = x.add(y);
				z.get(function(z) {
					expect(z).to.deep.equal([9, 3, 19]);
					done();
				});
			});
			it("Correct result for 2-dimensional arrays", function(done) {
				var x = context.array([[1, 4], [9, -17]]);
				var y = context.array([[8, -1], [10, -21]]);
				var z = x.add(y);
				z.get(function(result) {
					expect(result).to.deep.equal([[9, 3], [19, -38]]);
					done();
				});
			});
		});
		describe("Add scalar", function(){
			it("Correct result for 1-dimensional arrays", function(done) {
				var x = context.array([1, 4, 9]);
				var z = x.add(-7);
				z.get(function(z) {
					expect(z).to.deep.equal([-6, -3, 2]);
					done();
				});
			});
			it("Correct result for 2-dimensional arrays", function(done) {
				var x = context.array([[1, 4], [9, -17]]);
				var z = x.add(42);
				z.get(function(z) {
					expect(z).to.deep.equal([[43, 46], [51, 25]]);
					done();
				});
			});
		});
	});
	describe("sub", function() {
		describe("Subtract array", function() {
			it("Correct result for 1-dimensional arrays", function(done) {
				var x = context.array([1, 4, 9]);
				var y = context.array([8, -1, 10]);
				var z = x.sub(y);
				z.get(function(result) {
					expect(result).to.deep.equal([-7, 5, -1]);
					done();
				});
			});
			it("Correct result for 2-dimensional arrays", function(done) {
				var x = context.array([[1, 4], [9, -17]]);
				var y = context.array([[8, -1], [10, -21]]);
				var z = x.sub(y);
				z.get(function(result) {
					expect(result).to.deep.equal([[-7, 5], [-1, 4]]);
					done();
				});
			});
		});
		describe("Subtract scalar", function() {
			it("Correct result for 1-dimensional arrays", function(done) {
				var x = context.array([1, 4, 9]);
				var y = x.sub(-7);
				y.get(function(y) {
					expect(y).to.deep.equal([8, 11, 16]);
					done();
				});
			});
			it("Correct result for 2-dimensional arrays", function(done) {
				var x = context.array([[1, 4], [9, -17]]);
				var y = x.sub(42);
				y.get(function(y) {
					expect(y).to.deep.equal([[-41, -38], [-33, -59]]);
					done();
				});
			});
		});
	});
	describe("mul", function() {
		describe("Multiply by array", function() {
			it("Correct result for 1-dimensional arrays", function(done) {
				var x = context.array([1, 4, 9]);
				var y = context.array([8, -1, 10]);
				var z = x.mul(y);
				z.get(function(z) {
					expect(z).to.deep.equal([8, -4, 90]);
					done();
				});
			});
			it("Correct result for 2-dimensional arrays", function(done) {
				var x = context.array([[1, 4], [9, -17]]);
				var y = context.array([[8, -1], [10, -21]]);
				var z = x.mul(y);
				z.get(function(z) {
					expect(z).to.deep.equal([[8, -4], [90, 357]]);
					done();
				});
			});
		});
		describe("Multiply by scalar", function() {
			it("Correct result for 1-dimensional arrays", function(done) {
				var x = context.array([1, 4, 9]);
				var y = x.mul(-10);
				y.get(function(y) {
					expect(y).to.deep.equal([-10, -40, -90]);
					done();
				});
			});
			it("Correct result for 2-dimensional arrays", function(done) {
				var x = context.array([[1, 4], [9, -17]]);
				var y = x.mul(10);
				y.get(function(y) {
					expect(y).to.deep.equal([[10, 40], [90, -170]]);
					done();
				});
			});
		});
	});
	describe("div", function(){
		describe("Divide by array", function(){
			it("Correct result for 1-dimensional arrays", function(done) {
				var x = context.array([1, 4, 9]);
				var y = context.array([2, -4, 8]);
				var z = x.div(y);
				z.get(function(z) {
					expect(z).to.deep.equal([0.5, -1, 1.125]);
					done();
				});
			});
			it("Correct result for 2-dimensional arrays", function(done) {
				var x = context.array([[1, 4], [9, -17]]);
				var y = context.array([[-2, 4], [-8, 16]]);
				var z = x.div(y);
				z.get(function(z) {
					expect(z).to.deep.equal([[-0.5, 1], [-1.125, -1.0625]]);
					done();
				});
			});
		});
		describe("Divide by scalar", function() {
			it("Correct result for 1-dimensional arrays", function() {
				var x = context.array([1, 4, 9]);
				var y = x.div(-2);
				y.get(function(y) {
					expect(y).to.deep.equal([-0.5, -2, -4.5]);
				});
			});
			it("Correct result for 2-dimensional arrays", function() {
				var x = context.array([[1, 4], [9, -17]]);
				var y = x.div(-4);
				y.get(function(y) {
					expect(y).to.deep.equal([[-0.25, -1], [-2.25, 4.25]]);
				});
			});
		});
	});
	describe("min", function(){
		describe("All elements", function(){
			it("Returns zero-dimensional array of length one", function() {
				var x = context.zeros([20, 30]);
				var y = x.min();
				expect(y.shape).to.deep.equal([]);
				expect(y.length).to.equal(1);
				y.invalidate();
			});
			it("Computes the minimum of all elements in an array", function(done) {
				var x = context.linspace(-50, 100, 100000).reshape([200, 500]);
				x.min().get(function(y) {
					expect(y).to.equal(-50);
					done();
				});
			});
		});
		describe("Along an axis", function() {
			it("Correct shape for 3-dimensional arrays", function() {
				var x = context.linspace(1, 24, 24).reshape([2, 3, 4]).lock();
				expect(x.min(0).shape).to.deep.equal([3, 4]);
				expect(x.min(1).shape).to.deep.equal([2, 4]);
				expect(x.min(2).shape).to.deep.equal([2, 3]);
				x.invalidate();
			});
			it("Correct result for 3-dimensional arrays, axis 0", function(done) {
				var x = context.linspace(1, 24, 24).reshape([2, 3, 4]);
				x.min(0).get(function(y) {
					expect(y).to.deep.equal([[ 1,  2,  3,  4],
					                         [ 5,  6,  7,  8],
					                         [ 9, 10, 11, 12]]);
					done();
				});
			});
			it("Correct result for 3-dimensional arrays, axis 1", function(done) {
				var x = context.linspace(1, 24, 24).reshape([2, 3, 4]);
				x.min(1).get(function(y) {
					expect(y).to.deep.equal([[  1,  2,  3,  4],
					                         [ 13, 14, 15, 16]]);
					done();
				});
			});
			it("Correct result for 3-dimensional arrays, axis 2", function(done) {
				var x = context.linspace(1, 24, 24).reshape([2, 3, 4]);
				x.min(2).get(function(y) {
					expect(y).to.deep.equal([[  1,  5,  9],
					                         [ 13, 17, 21]]);
					done();
				});
			});
		});
	});
	describe("max", function() {
		describe("All elements", function() {
			it("Returns zero-dimensional array of length one", function() {
				var x = context.zeros([20, 30]);
				var y = x.max();
				expect(y.shape).to.deep.equal([]);
				expect(y.length).to.equal(1);
				y.invalidate();
			});
			it("Computes the maximum of all elements in an array", function(done) {
				var x = context.linspace(-50, 100, 100000).reshape([200, 500]);
				x.max().get(function(y) {
					expect(y).to.equal(100);
					done();
				});
			});
		});
		describe("Along an axis", function() {
			it("Correct shape for 3-dimensional arrays", function() {
				var x = context.linspace(1, 24, 24).reshape([2, 3, 4]).lock();
				expect(x.max(0).shape).to.deep.equal([3, 4]);
				expect(x.max(1).shape).to.deep.equal([2, 4]);
				expect(x.max(2).shape).to.deep.equal([2, 3]);
				x.invalidate();
			});
			it("Correct result for 3-dimensional arrays, axis 0", function(done) {
				var x = context.linspace(1, 24, 24).reshape([2, 3, 4]);
				x.max(0).get(function(y) {
					expect(y).to.deep.equal([[ 13, 14, 15, 16],
					                         [ 17, 18, 19, 20],
					                         [ 21, 22, 23, 24]]);
					done();
				});
			});
			it("Correct result for 3-dimensional arrays, axis 1", function(done) {
				var x = context.linspace(1, 24, 24).reshape([2, 3, 4]);
				x.max(1).get(function(y) {
					expect(y).to.deep.equal([[  9, 10, 11, 12],
					                         [ 21, 22, 23, 24]]);
					done();
				});
			});
			it("Correct result for 3-dimensional arrays, axis 2", function(done) {
				var x = context.linspace(1, 24, 24).reshape([2, 3, 4]);
				x.max(2).get(function(y) {
					expect(y).to.deep.equal([[  4,  8, 12],
					                         [ 16, 20, 24]]);
					done();
				});
			});
		});
	});
	describe("sum", function() {
		describe("All elements", function() {
			it("Returns zero-dimensional array of length one", function() {
				var x = context.zeros([20, 30]);
				var y = x.sum();
				expect(y.shape).to.deep.equal([]);
				expect(y.length).to.equal(1);
				y.invalidate();
			});
			it("Computes the sum of all elements in an array", function(done) {
				var x = context.linspace(1, 100000, 100000).reshape([200, 500]);
				x.sum().get(function(y) {
					expect(y).to.equal(5000050000);
					done();
				});
			});
		});
		describe("Along an axis", function() {
			it("Correct shape for 3-dimensional arrays", function() {
				var x = context.linspace(1, 24, 24).reshape([2, 3, 4]).lock();
				expect(x.sum(0).shape).to.deep.equal([3, 4]);
				expect(x.sum(1).shape).to.deep.equal([2, 4]);
				expect(x.sum(2).shape).to.deep.equal([2, 3]);
				x.invalidate();
			});
			it("Correct result for 3-dimensional arrays, axis 0", function(done) {
				var x = context.linspace(1, 24, 24).reshape([2, 3, 4]);
				x.sum(0).get(function(y) {
					expect(y).to.deep.equal([[ 14, 16, 18, 20],
					                         [ 22, 24, 26, 28],
					                         [ 30, 32, 34, 36]]);
					done();
				});
			});
			it("Correct result for 3-dimensional arrays, axis 1", function(done) {
				var x = context.linspace(1, 24, 24).reshape([2, 3, 4]);
				x.sum(1).get(function(y) {
					expect(y).to.deep.equal([[ 15,  18,  21,  24],
					                         [ 51,  54,  57,  60]]);
					done();
				});
			});
			it("Correct result for 3-dimensional arrays, axis 2", function(done) {
				var x = context.linspace(1, 24, 24).reshape([2, 3, 4]);
				x.sum(2).get(function(y) {
					expect(y).to.deep.equal([[ 10,  26,  42],
					                         [ 58,  74,  90]]);
					done();
				});
			});
		});
	});
	describe("dot", function() {
		it("Correct shape for 2-dimensional arrays", function() {
			var x = context.empty([2, 5]);
			var y = context.empty([5, 11]);
			var z = context.dot(x, y);
			expect(z.shape).to.deep.equal([2, 11]);
			z.invalidate();
		});
		it("Correct shape for 3-dimensional arrays", function() {
			var x = context.empty([2, 3, 4]);
			var y = context.empty([7, 4, 8]);
			var z = context.dot(x, y);
			expect(z.shape).to.deep.equal([2, 3, 7, 8]);
			z.invalidate();
		});
		it("Correct shape for 4-dimensional arrays", function() {
			var x = context.empty([2, 3, 4, 5]);
			var y = context.empty([6, 7, 5, 8]);
			var z = context.dot(x, y);
			expect(z.shape).to.deep.equal([2, 3, 4, 6, 7, 8]);
			z.invalidate();
		});
		it("Correct value for 1-dimensional arrays", function(done) {
			var x = context.array([2, 5]);
			var y = context.array([5, 11]);
			context.dot(x, y).get(function(z) {
				expect(z).to.deep.equal(65);
				done();
			});
		});
		it("Correct value for 2-dimensional arrays", function(done) {
			var x = context.array([[64,  2,  3],
			                       [61, 60,  6]]);
			var y = context.array([[92, 99,  1,  8, 15],
			                       [67, 74, 51, 58, 40],
			                       [98, 80,  7, 14, 16]]);
			var z = context.dot(x, y);
			z.get(function(result) {
				expect(result).to.deep.equal([[  6316,  6724,  187,  670, 1088],
				                              [ 10220, 10959, 3163, 4052, 3411]]);
				done();
			});
		});
	});
});

},{"../lib/furious.js":6,"chai":14}]},{},[57,58,59])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkM6XFxQcm9qZWN0c1xcZnVyaW91cy5qc1xcbm9kZV9tb2R1bGVzXFxncnVudC1icm93c2VyaWZ5XFxub2RlX21vZHVsZXNcXGJyb3dzZXJpZnlcXG5vZGVfbW9kdWxlc1xcYnJvd3Nlci1wYWNrXFxfcHJlbHVkZS5qcyIsIkM6L1Byb2plY3RzL2Z1cmlvdXMuanMvbGliL0RhdGFUeXBlLmpzIiwiQzovUHJvamVjdHMvZnVyaW91cy5qcy9saWIvTkRBcnJheS5qcyIsIkM6L1Byb2plY3RzL2Z1cmlvdXMuanMvbGliL1BCQ29udGV4dC5qcyIsIkM6L1Byb2plY3RzL2Z1cmlvdXMuanMvbGliL1BOYUNsQ29udGV4dC5qcyIsIkM6L1Byb2plY3RzL2Z1cmlvdXMuanMvbGliL2FsbG9jYXRvci5qcyIsIkM6L1Byb2plY3RzL2Z1cmlvdXMuanMvbGliL2Z1cmlvdXMuanMiLCJDOi9Qcm9qZWN0cy9mdXJpb3VzLmpzL2xpYi9qcy9KU0NvbnRleHQuanMiLCJDOi9Qcm9qZWN0cy9mdXJpb3VzLmpzL2xpYi9qcy9XZWJXb3JrZXJDb250ZXh0LmpzIiwiQzovUHJvamVjdHMvZnVyaW91cy5qcy9saWIvanMvanNtYXRoLmpzIiwiQzovUHJvamVjdHMvZnVyaW91cy5qcy9saWIvcmVxdWVzdHMucGIuanMiLCJDOi9Qcm9qZWN0cy9mdXJpb3VzLmpzL2xpYi9yZXNwb25zZXMucGIuanMiLCJDOi9Qcm9qZWN0cy9mdXJpb3VzLmpzL2xpYi91dGlsLmpzIiwiQzovUHJvamVjdHMvZnVyaW91cy5qcy9saWIvd2ViY2wvV2ViQ0xDb250ZXh0LmpzIiwiQzovUHJvamVjdHMvZnVyaW91cy5qcy9ub2RlX21vZHVsZXMvY2hhaS9pbmRleC5qcyIsIkM6L1Byb2plY3RzL2Z1cmlvdXMuanMvbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkuanMiLCJDOi9Qcm9qZWN0cy9mdXJpb3VzLmpzL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL2Fzc2VydGlvbi5qcyIsIkM6L1Byb2plY3RzL2Z1cmlvdXMuanMvbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvY29uZmlnLmpzIiwiQzovUHJvamVjdHMvZnVyaW91cy5qcy9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS9jb3JlL2Fzc2VydGlvbnMuanMiLCJDOi9Qcm9qZWN0cy9mdXJpb3VzLmpzL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL2ludGVyZmFjZS9hc3NlcnQuanMiLCJDOi9Qcm9qZWN0cy9mdXJpb3VzLmpzL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL2ludGVyZmFjZS9leHBlY3QuanMiLCJDOi9Qcm9qZWN0cy9mdXJpb3VzLmpzL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL2ludGVyZmFjZS9zaG91bGQuanMiLCJDOi9Qcm9qZWN0cy9mdXJpb3VzLmpzL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL3V0aWxzL2FkZENoYWluYWJsZU1ldGhvZC5qcyIsIkM6L1Byb2plY3RzL2Z1cmlvdXMuanMvbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvYWRkTWV0aG9kLmpzIiwiQzovUHJvamVjdHMvZnVyaW91cy5qcy9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS91dGlscy9hZGRQcm9wZXJ0eS5qcyIsIkM6L1Byb2plY3RzL2Z1cmlvdXMuanMvbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvZmxhZy5qcyIsIkM6L1Byb2plY3RzL2Z1cmlvdXMuanMvbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvZ2V0QWN0dWFsLmpzIiwiQzovUHJvamVjdHMvZnVyaW91cy5qcy9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS91dGlscy9nZXRFbnVtZXJhYmxlUHJvcGVydGllcy5qcyIsIkM6L1Byb2plY3RzL2Z1cmlvdXMuanMvbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvZ2V0TWVzc2FnZS5qcyIsIkM6L1Byb2plY3RzL2Z1cmlvdXMuanMvbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvZ2V0TmFtZS5qcyIsIkM6L1Byb2plY3RzL2Z1cmlvdXMuanMvbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvZ2V0UGF0aFZhbHVlLmpzIiwiQzovUHJvamVjdHMvZnVyaW91cy5qcy9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS91dGlscy9nZXRQcm9wZXJ0aWVzLmpzIiwiQzovUHJvamVjdHMvZnVyaW91cy5qcy9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS91dGlscy9pbmRleC5qcyIsIkM6L1Byb2plY3RzL2Z1cmlvdXMuanMvbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvaW5zcGVjdC5qcyIsIkM6L1Byb2plY3RzL2Z1cmlvdXMuanMvbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvb2JqRGlzcGxheS5qcyIsIkM6L1Byb2plY3RzL2Z1cmlvdXMuanMvbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvb3ZlcndyaXRlQ2hhaW5hYmxlTWV0aG9kLmpzIiwiQzovUHJvamVjdHMvZnVyaW91cy5qcy9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS91dGlscy9vdmVyd3JpdGVNZXRob2QuanMiLCJDOi9Qcm9qZWN0cy9mdXJpb3VzLmpzL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL3V0aWxzL292ZXJ3cml0ZVByb3BlcnR5LmpzIiwiQzovUHJvamVjdHMvZnVyaW91cy5qcy9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS91dGlscy90ZXN0LmpzIiwiQzovUHJvamVjdHMvZnVyaW91cy5qcy9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS91dGlscy90cmFuc2ZlckZsYWdzLmpzIiwiQzovUHJvamVjdHMvZnVyaW91cy5qcy9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS91dGlscy90eXBlLmpzIiwiQzovUHJvamVjdHMvZnVyaW91cy5qcy9ub2RlX21vZHVsZXMvY2hhaS9ub2RlX21vZHVsZXMvYXNzZXJ0aW9uLWVycm9yL2luZGV4LmpzIiwiQzovUHJvamVjdHMvZnVyaW91cy5qcy9ub2RlX21vZHVsZXMvY2hhaS9ub2RlX21vZHVsZXMvZGVlcC1lcWwvaW5kZXguanMiLCJDOi9Qcm9qZWN0cy9mdXJpb3VzLmpzL25vZGVfbW9kdWxlcy9jaGFpL25vZGVfbW9kdWxlcy9kZWVwLWVxbC9saWIvZXFsLmpzIiwiQzovUHJvamVjdHMvZnVyaW91cy5qcy9ub2RlX21vZHVsZXMvY2hhaS9ub2RlX21vZHVsZXMvZGVlcC1lcWwvbm9kZV9tb2R1bGVzL3R5cGUtZGV0ZWN0L2luZGV4LmpzIiwiQzovUHJvamVjdHMvZnVyaW91cy5qcy9ub2RlX21vZHVsZXMvY2hhaS9ub2RlX21vZHVsZXMvZGVlcC1lcWwvbm9kZV9tb2R1bGVzL3R5cGUtZGV0ZWN0L2xpYi90eXBlLmpzIiwiQzovUHJvamVjdHMvZnVyaW91cy5qcy9ub2RlX21vZHVsZXMvZ3J1bnQtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9saWIvX2VtcHR5LmpzIiwiQzovUHJvamVjdHMvZnVyaW91cy5qcy9ub2RlX21vZHVsZXMvZ3J1bnQtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnVmZmVyL2luZGV4LmpzIiwiQzovUHJvamVjdHMvZnVyaW91cy5qcy9ub2RlX21vZHVsZXMvZ3J1bnQtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnVmZmVyL25vZGVfbW9kdWxlcy9iYXNlNjQtanMvbGliL2I2NC5qcyIsIkM6L1Byb2plY3RzL2Z1cmlvdXMuanMvbm9kZV9tb2R1bGVzL2dydW50LWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2J1ZmZlci9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIsIkM6L1Byb2plY3RzL2Z1cmlvdXMuanMvbm9kZV9tb2R1bGVzL2dydW50LWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3BhdGgtYnJvd3NlcmlmeS9pbmRleC5qcyIsIkM6L1Byb2plY3RzL2Z1cmlvdXMuanMvbm9kZV9tb2R1bGVzL2dydW50LWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIkM6L1Byb2plY3RzL2Z1cmlvdXMuanMvbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvZGlzdC9Qcm90b0J1Zi5qcyIsIkM6L1Byb2plY3RzL2Z1cmlvdXMuanMvbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvaW5kZXguanMiLCJDOi9Qcm9qZWN0cy9mdXJpb3VzLmpzL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL25vZGVfbW9kdWxlcy9ieXRlYnVmZmVyL2Rpc3QvQnl0ZUJ1ZmZlckFCLm1pbi5qcyIsIkM6L1Byb2plY3RzL2Z1cmlvdXMuanMvbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvbm9kZV9tb2R1bGVzL2J5dGVidWZmZXIvbm9kZV9tb2R1bGVzL2xvbmcvZGlzdC9Mb25nLmpzIiwiQzovUHJvamVjdHMvZnVyaW91cy5qcy9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9ub2RlX21vZHVsZXMvYnl0ZWJ1ZmZlci9ub2RlX21vZHVsZXMvbG9uZy9pbmRleC5qcyIsIkM6L1Byb2plY3RzL2Z1cmlvdXMuanMvdGVzdC9Db250ZXh0LnRlc3QuanMiLCJDOi9Qcm9qZWN0cy9mdXJpb3VzLmpzL3Rlc3QvRGF0YVR5cGUudGVzdC5qcyIsIkM6L1Byb2plY3RzL2Z1cmlvdXMuanMvdGVzdC9OREFycmF5LnRlc3QuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3J5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3haQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbGZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3psQ0E7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNseUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hpQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9HQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaFVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3REQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5R0E7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDalFBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5SUE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3NUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdDdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3Rocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIil9dmFyIGY9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGYuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sZixmLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxuLyoqXHJcbiAqIEEgbnVtZXJpY2FsIGRhdGEgdHlwZSBvYmplY3QuXHJcbiAqXHJcbiAqIEBjbGFzcyBEYXRhVHlwZVxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgLSB0aGUgYWJicmV2aWF0ZWQgbmFtZSBvZiB0aGUgZGF0YSB0eXBlLiBUaGUgZm9sbG93aW5nIG5hbWVzIGFyZSBzdXBwb3J0ZWQ6XHJcbiAqXHJcbiAqICAgICA8dGFibGU+XHJcbiAqICAgICAgICAgPHRyPlxyXG4gKiAgICAgICAgICAgICA8dGg+QWJicmV2aWF0ZWQgTmFtZTwvdGg+XHJcbiAqICAgICAgICAgICAgIDx0aD5JbnRlcnByZXRhdGlvbjwvdGg+XHJcbiAqICAgICAgICAgPC90cj5cclxuICogICAgICAgICA8dHI+XHJcbiAqICAgICAgICAgICAgIDx0ZD5cImYzMlwiPC90ZD5cclxuICogICAgICAgICAgICAgPHRkPlNpbmdsZS1wcmVjaXNpb24gKDMyLWJpdCkgSUVFRS03NTQgZmxvYXRpbmctcG9pbnQgdHlwZS48L3RkPlxyXG4gKiAgICAgICAgIDwvdHI+XHJcbiAqICAgICAgICAgPHRyPlxyXG4gKiAgICAgICAgICAgICA8dGQ+XCJmNjRcIjwvdGQ+XHJcbiAqICAgICAgICAgICAgIDx0ZD5Eb3VibGUtcHJlY2lzaW9uICg2NC1iaXQpIElFRUUtNzU0IGZsb2F0aW5nLXBvaW50IHR5cGUuPC90ZD5cclxuICogICAgICAgICA8L3RyPlxyXG4gKiAgICAgPC90YWJsZT5cclxuICpcclxuICovXHJcbmZ1bmN0aW9uIERhdGFUeXBlKHR5cGUpIHtcclxuXHRpZiAoW1wiZjMyXCIsIFwiZjY0XCJdLmluZGV4T2YodHlwZSkgPj0gMCkge1xyXG5cdFx0dGhpcy50eXBlID0gdHlwZTtcclxuXHRcdHRoaXMuc2l6ZSA9IHtcImYzMlwiOiA0LCBcImY2NFwiOiA4fVt0eXBlXTtcclxuXHRcdHRoaXMuZXBzaWxvbiA9IHtcImYzMlwiOiAxLjE5MjA5Mjg5NTUwNzgxMjVlLTcsIFwiZjY0XCI6IDIuMjIwNDQ2MDQ5MjUwMzEzMWUtMTZ9W3R5cGVdO1xyXG5cdFx0dGhpcy5hcnJheVR5cGUgPSB7XCJmMzJcIjogRmxvYXQzMkFycmF5LCBcImY2NFwiOiBGbG9hdDY0QXJyYXl9W3R5cGVdO1xyXG5cdH0gZWxzZSB7XHJcblx0XHR0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlR5cGUgXCIgKyB0eXBlICsgXCIgaXMgbm90IHN1cHBvcnRlZFwiKTtcclxuXHR9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDb21wYXJlcyB0d28gZGF0YSB0eXBlIG9iamVjdHMgZm9yIGVxdWFsaXR5LlxyXG4gKlxyXG4gKiBAbWV0aG9kIGVxdWFsc1xyXG4gKiBAcGFyYW0ge2FueX0gb3RoZXIgLSBhbiBvYmplY3QgdG8gY29tcGFyZSB0by5cclxuICovXHJcbkRhdGFUeXBlLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbihvdGhlcikge1xyXG5cdHJldHVybiAob3RoZXIgaW5zdGFuY2VvZiBEYXRhVHlwZSkgJiYgKHRoaXMuYXJyYXlUeXBlID09PSBvdGhlci5hcnJheVR5cGUpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBEYXRhVHlwZTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XHJcbnZhciBEYXRhVHlwZSA9IHJlcXVpcmUoXCIuL0RhdGFUeXBlXCIpO1xyXG5cclxuLyoqXHJcbiAqIEFuIG9wYXF1ZSBOLWRpbWVuc2lvbmFsIGFycmF5IG9iamVjdC5cclxuICpcclxuICogQGNsYXNzIE5EQXJyYXlcclxuICovXHJcblxyXG4vKipcclxuICogQ29uc3RydWN0cyBhbiBOREFycmF5IG9iamVjdCB3aXRob3V0IGRhdGEuXHJcbiAqIE5vcm1hbGx5IHRoaXMgY29uc3RydWN0b3IgaXMgY2FsbGVkIGZyb20gYXJyYXkgY29uc3RydWN0aW9uIG1ldGhvZHMgb2YgY29tcHV0YXRpb25hbCBjb250ZXh0cy5cclxuICogVGhlIGNhbGxpbmcgZnVuY3Rpb24gaXMgcmVzcG9uc2libGUgZm9yIGluaXRpYWxpemluZyB0aGUgZGF0YSBmb3IgdGhlIGFycmF5LlxyXG4gKlxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIE5EQXJyYXkoc2hhcGUsIGRhdGFUeXBlLCBjb250ZXh0KSB7XHJcblx0aWYgKHR5cGVvZiBjb250ZXh0ID09PSBcInVuZGVmaW5lZFwiKSB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJDb250ZXh0IG5vdCBkZWZpbmVkXCIpO1xyXG5cdH1cclxuXHRpZiAoIXV0aWwuaXNQb3NpdGl2ZUludEFycmF5KHNoYXBlKSAmJiAhdXRpbC5pc1Bvc2l0aXZlSW50KHNoYXBlKSkge1xyXG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihzaGFwZSArIFwiIGlzIG5vdCBhIHZhbGlkIGFycmF5IHNoYXBlXCIpO1xyXG5cdH1cclxuXHRpZiAodHlwZW9mIGRhdGFUeXBlID09PSBcInVuZGVmaW5lZFwiKSB7XHJcblx0XHRkYXRhVHlwZSA9IG5ldyBEYXRhVHlwZShcImY2NFwiKTtcclxuXHR9IGVsc2UgaWYgKCEoZGF0YVR5cGUgaW5zdGFuY2VvZiBEYXRhVHlwZSkpIHtcclxuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoZGF0YVR5cGUgKyBcIiBpcyBub3QgYW4gaW5zdGFuY2Ugb2YgRGF0YVR5cGVcIik7XHJcblx0fVxyXG5cdHRoaXMuc2hhcGUgPSBzaGFwZTtcclxuXHR0aGlzLmRhdGFUeXBlID0gZGF0YVR5cGU7XHJcblx0dGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XHJcblx0dGhpcy5sZW5ndGggPSB1dGlsLmNvbXB1dGVMZW5ndGgodGhpcy5zaGFwZSk7XHJcblx0dGhpcy5fbG9ja0NvdW50ID0gMDtcclxuXHR0aGlzLl9yZWZDb3VudCA9IDE7XHJcblx0dGhpcy5faXNWYWxpZCA9IHRydWU7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBMb2NrcyB0aGUgYXJyYXkgcmVmZXJlbmNlIGNvdW50ZXIuXHJcbiAqIFdoaWxlIHRoZSBhcnJheSBpcyBsb2NrZWQsIGZ1bmN0aW9ucyBhbmQgbWV0aG9kcyB0aGF0IG9wZXJhdGUgb24gdGhpcyBhcnJheSBkbyBub3QgZGVjcmVhc2UgaXRzIHJlZmVyZW5jZSBjb3VudC5cclxuICogVGhlIGFycmF5IGNhbiBiZSBsb2NrZWQgbXVsdGlwbGUgdGltZXMsIGFuZCB3b3VsZCBuZWVkIGp1c3QgYXMgbWFueSB1bmxvY2sgY2FsbHMgdG8gbGlmdCB0aGUgbG9jay5cclxuICogSWYgdGhlIGFycmF5IGlzIG5vdCB2YWxpZCwgdGhpcyBvcGVyYXRpb24gd2lsbCBmYWlsIHdpdGggYW4gZXJyb3IuXHJcbiAqXHJcbiAqIEBtZXRob2QgbG9ja1xyXG4gKiBAY2hhaW5hYmxlXHJcbiAqL1xyXG5OREFycmF5LnByb3RvdHlwZS5sb2NrID0gZnVuY3Rpb24oKSB7XHJcblx0aWYgKCF0aGlzLmlzVmFsaWQoKSkge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiQXR0ZW1wdGVkIHRvIGxvY2sgYW4gaW52YWxpZGF0ZWQgYXJyYXlcIik7XHJcblx0fVxyXG5cdHRoaXMuX2xvY2tDb3VudCsrO1xyXG5cdHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFVubG9ja3MgdGhlIGFycmF5IHJlZmVyZW5jZSBjb3VudGVyLlxyXG4gKiBPbmNlIHRoZSBhcnJheSBpcyB1bmxvY2tlZCwgZnVuY3Rpb25zIGFuZCBtZXRob2RzIHRoYXQgb3BlcmF0ZSBvbiB0aGlzIGFycmF5IGRlY3JlYXNlIGl0cyByZWZlcmVuY2UgY291bnQgYW5kLCBpZiB0aGUgcmVmZXJlbmNlIGNvdW50IHJlYWNoZXMgemVybywgaW52YWxpZGF0ZSB0aGUgYXJyYXkuXHJcbiAqIElmIHRoZSBhcnJheSB3YXMgbG9ja2VkIG11bHRpcGxlIHRpbWVzLCBpdCB3b3VsZCBuZWVkIGp1c3QgYXMgbWFueSB1bmxvY2sgY2FsbHMgdG8gbGlmdCB0aGUgbG9jay5cclxuICogSWYgdGhlIGFycmF5IGlzIG5vdCBsb2NrZWQsIHRoaXMgb3BlcmF0aW9uIHdpbGwgZmFpbCB3aXRoIGFuIGVycm9yLlxyXG4gKlxyXG4gKiBAbWV0aG9kIHVubG9ja1xyXG4gKiBAY2hhaW5hYmxlXHJcbiAqL1xyXG5OREFycmF5LnByb3RvdHlwZS51bmxvY2sgPSBmdW5jdGlvbigpIHtcclxuXHRpZiAoIXRoaXMuaXNMb2NrZWQoKSkge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiQXR0ZW1wdGVkIHRvIGxvY2sgYSB1bmxvY2tlZCBhcnJheVwiKTtcclxuXHR9XHJcblx0dGhpcy5fbG9ja0NvdW50LS07XHJcblx0cmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogQ2hlY2tlcyBpZiB0aGUgYXJyYXkgaXMgaW4gdGhlIGxvY2tlZCBzdGF0ZS5cclxuICogSWYgdGhlIGFycmF5IGlzIG5vdCB2YWxpZCwgdGhpcyBtZXRob2QgcmV0dXJuIGZhbHNlLlxyXG4gKlxyXG4gKiBAbWV0aG9kIGlzTG9ja2VkXHJcbiAqXHJcbiAqIEByZXR1cm4ge0Jvb2xlYW59IC0gdHJ1ZSBpcyB0aGUgYXJyYXkgaXMgbG9ja2VkIGFuZCBmYWxzZSBvdGhlcndpc2VcclxuICovXHJcbk5EQXJyYXkucHJvdG90eXBlLmlzTG9ja2VkID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXMuX2xvY2tDb3VudCA+IDA7XHJcbn07XHJcblxyXG4vKipcclxuICogSW5jcmVtZW50cyB0aGUgYXJyYXkgcmVmZXJlbmNlIGNvdW50LlxyXG4gKiBJZiB0aGUgYXJyYXkgaXMgaW52YWxpZCBvciBsb2NrZWQsIHRoaXMgb3BlcmF0aW9uIHdpbGwgZmFpbCB3aXRoIGFuIGVycm9yLlxyXG4gKlxyXG4gKiBAbWV0aG9kIHJldGFpblxyXG4gKiBAY2hhaW5hYmxlXHJcbiAqL1xyXG5OREFycmF5LnByb3RvdHlwZS5yZXRhaW4gPSBmdW5jdGlvbigpIHtcclxuXHRpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJBdHRlbXB0ZWQgdG8gcmVsZWFzZSBhbiBpbnZhbGlkYXRlZCBhcnJheVwiKTtcclxuXHR9XHJcblx0aWYgKHRoaXMuaXNMb2NrZWQoKSkge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiQXR0ZW1wdGVkIHRvIHJldGFpbiBhIGxvY2tlZCBhcnJheVwiKTtcclxuXHR9XHJcblx0dGhpcy5fcmVmQ291bnQrKztcclxuXHRyZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBEZWNyZW1lbnRzIHRoZSBhcnJheSByZWZlcmVuY2UgY291bnQuIElmIHRoZSByZWZlcmVuY2UgY291bnQgdHVybnMgemVybywgdGhlIGFycmF5IGJlY29tZXMgaW52YWxpZCBhbmQgaXRzIGRhdGEgYnVmZmVyIGlzIGRlYWxsb2NhdGVkLlxyXG4gKiBJZiB0aGUgYXJyYXkgaXMgaW52YWxpZCBvciBsb2NrZWQsIHRoaXMgb3BlcmF0aW9uIHdpbGwgZmFpbCB3aXRoIGFuIGVycm9yLlxyXG4gKlxyXG4gKiBAbWV0aG9kIHJlbGVhc2VcclxuICogQGNoYWluYWJsZVxyXG4gKi9cclxuTkRBcnJheS5wcm90b3R5cGUucmVsZWFzZSA9IGZ1bmN0aW9uKCkge1xyXG5cdGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcihcIkF0dGVtcHRlZCB0byByZWxlYXNlIGFuIGludmFsaWRhdGVkIGFycmF5XCIpO1xyXG5cdH1cclxuXHRpZiAodGhpcy5pc0xvY2tlZCgpKSB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJBdHRlbXB0ZWQgdG8gcmVsZWFzZSBhIGxvY2tlZCBhcnJheVwiKTtcclxuXHR9XHJcblx0aWYgKC0tdGhpcy5fcmVmQ291bnQgPT09IDApIHtcclxuXHRcdHRoaXMuX2NvbnRleHQuX2ludmFsaWRhdGUodGhpcyk7XHJcblx0fVxyXG5cdHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEZvciBhIG5vbi1sb2NrZWQgYXJyYXksIGRlY3JlbWVudHMgdGhlIGFycmF5IHJlZmVyZW5jZSBjb3VudC4gSWYgdGhlIHJlZmVyZW5jZSBjb3VudCB0dXJucyB6ZXJvLCB0aGUgYXJyYXkgYmVjb21lcyBpbnZhbGlkIGFuZCBpdHMgZGF0YSBidWZmZXIgaXMgZGVhbGxvY2F0ZWQuXHJcbiAqIElmIHRoZSBhcnJheSBpcyBpbnZhbGlkLCB0aGlzIG9wZXJhdGlvbiB3aWxsIGZhaWwgd2l0aCBhbiBlcnJvci5cclxuICpcclxuICogQG1ldGhvZCB0cnlSZWxlYXNlXHJcbiAqIEBjaGFpbmFibGVcclxuICovXHJcbk5EQXJyYXkucHJvdG90eXBlLnRyeVJlbGVhc2UgPSBmdW5jdGlvbigpIHtcclxuXHRpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJBdHRlbXB0ZWQgdG8gcmVsZWFzZSBhbiBpbnZhbGlkYXRlZCBhcnJheVwiKTtcclxuXHR9XHJcblx0aWYgKCF0aGlzLmlzTG9ja2VkKCkpIHtcclxuXHRcdGlmICgtLXRoaXMuX3JlZkNvdW50ID09PSAwKSB7XHJcblx0XHRcdHRoaXMuX2NvbnRleHQuX2ludmFsaWRhdGUodGhpcyk7XHJcblx0XHR9XHJcblx0fVxyXG5cdHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEZvciBhIG5vbi1sb2NrZWQgYXJyYXksIGRlY3JlbWVudHMgdGhlIGFycmF5IHJlZmVyZW5jZSBjb3VudC4gSWYgdGhlIHJlZmVyZW5jZSBjb3VudCB0dXJucyB6ZXJvLCB0aGUgYXJyYXkgYmVjb21lcyBpbnZhbGlkIGFuZCBpdHMgZGF0YSBidWZmZXIgaXMgZGVhbGxvY2F0ZWQuXHJcbiAqIFRoZSBhcnJheSBtdXN0IGJlIHZhbGlkIHRvIHBlcmZvcm0gdGhpcyBvcGVyYXRpb24uXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBtZXRob2QgX3RyeVJlbGVhc2VcclxuICogQGNoYWluYWJsZVxyXG4gKi9cclxuTkRBcnJheS5wcm90b3R5cGUuX3RyeVJlbGVhc2UgPSBmdW5jdGlvbigpIHtcclxuXHRpZiAoIXRoaXMuaXNMb2NrZWQoKSkge1xyXG5cdFx0aWYgKC0tdGhpcy5fcmVmQ291bnQgPT09IDApIHtcclxuXHRcdFx0dGhpcy5fY29udGV4dC5faW52YWxpZGF0ZSh0aGlzKTtcclxuXHRcdH1cclxuXHR9XHJcblx0cmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogSW52YWxpZGF0ZXMgdGhlIGFycmF5IGFuZCBkZWFsbG9jYXRlcyBpdHMgZGF0YSBidWZmZXIsIHJlZ2FyZGxlc3Mgb2YgbG9ja3MgYW5kIHJlZmVyZW5jZSBjb3VudC5cclxuICogQ2FsbGluZyB0aGlzIG1ldGhvZCBvbiBhbiBpbnZhbGlkYXRlZCBhcnJheSBoYXMgbm8gZWZmZWN0LlxyXG4gKlxyXG4gKiBAbWV0aG9kIGludmFsaWRhdGVcclxuICogQGNoYWluYWJsZVxyXG4gKi9cclxuTkRBcnJheS5wcm90b3R5cGUuaW52YWxpZGF0ZSA9IGZ1bmN0aW9uKCkge1xyXG5cdGlmICh0aGlzLmlzVmFsaWQoKSkge1xyXG5cdFx0dGhpcy5fY29udGV4dC5faW52YWxpZGF0ZSh0aGlzKTtcclxuXHRcdHRoaXMuX2lzVmFsaWQgPSBmYWxzZTtcclxuXHRcdHRoaXMuX3JlZkNvdW50ID0gMDtcclxuXHRcdHRoaXMuX2xvY2tDb3VudCA9IDA7XHJcblx0fVxyXG5cdHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENoZWNrZXMgaWYgdGhlIGFycmF5IGlzIGluIGEgdmFsaWQgc3RhdGUuXHJcbiAqIElmIHRoZSBhcnJheSBpcyBub3QgaW4gYSB2YWxpZCBzdGF0ZSwgaXRzIGRhdGEgYnVmZmVyIHdhcyBkZWFsbG9jYXRlZCwgYW5kIGFueSBvcGVyYXRpb25zIG9uIHRoZSBhcnJheSB3aWxsIHRocm93IGFuIGVycm9yLlxyXG4gKlxyXG4gKiBAbWV0aG9kIGlzVmFsaWRcclxuICpcclxuICogQHJldHVybiB7Qm9vbGVhbn0gLSB0cnVlIGlzIHRoZSBhcnJheSBpcyB2YWxpZCBhbmQgZmFsc2Ugb3RoZXJ3aXNlXHJcbiAqL1xyXG5OREFycmF5LnByb3RvdHlwZS5pc1ZhbGlkID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXMuX2lzVmFsaWQ7XHJcbn07XHJcblxyXG4vKipcclxuICogRGVjcmVtZW50cyB0aGUgYXJyYXkgcmVmZXJlbmNlIGNvdW50IGlmIHRoZSBhcnJheSBpcyBub3QgbG9ja2VkLlxyXG4gKiBUaGlzIGZ1bmN0aW9uIGRvZXMgbm90IGludmFsaWRhdGUgdGhlIGFycmF5IHdoZW4gdGhlIHJlZmVyZW5jZSBjb3VudCByZWFjaCB6ZXJvLlxyXG4gKiBUaGUgY2FsbGVyIGlzIHJlc3BvbnNpYmxlIGZvciBpbnZhbGlkYXRpbmcgYXJyYXkgaWYgaXRzIHJlZmVyZW5jZSBjb3VudCBpcyB6ZXJvIGFmdGVyIHRoZSBvcGVyYXRpb24uXHJcbiAqXHJcbiAqIEZvciBhIGxvY2tlZCBhcnJheSB0aGUgbWV0aG9kIGhhcyBubyBlZmZlY3QgYW5kIGFsd2F5cyByZXR1cm5zIHRydWUuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBtZXRob2QgX2RlY1JlZlxyXG4gKiBAcGFyYW0ge05EQXJyYXl9IGFycmF5IC0gdGhlIGFycmF5IHRvIGRlY3JlbWVudCB0aGUgcmVmZXJlbmNlIGNvdW50IGZvci4gTXVzdCBiZSB2YWxpZCBiZWZvcmUgdGhlIGNhbGwuXHJcbiAqIEByZXR1cm4ge0Jvb2xlYW59IC0gdHJ1ZSBpZiB0aGUgcmVmZXJlbmNlIGNvdW50IGlzIG5vbi16ZXJvIGFmdGVyIHRoZSBvcGVyYXRpb24gYW5kIGZhbHNlIG90aGVyd2lzZS5cclxuICovXHJcbk5EQXJyYXkucHJvdG90eXBlLl9kZWNSZWYgPSBmdW5jdGlvbihhcnJheSkge1xyXG5cdGlmICh0aGlzLl9sb2NrQ291bnQgPT09IDApIHtcclxuXHRcdC0tdGhpcy5fcmVmQ291bnQ7XHJcblx0fVxyXG5cdHJldHVybiB0aGlzLl9yZWZDb3VudCAhPT0gMDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBJbmNyZW1lbnRzIHRoZSBhcnJheSByZWZlcmVuY2UgY291bnQgaWYgdGhlIGFycmF5IGlzIG5vdCBsb2NrZWQuXHJcbiAqIEZvciBhIGxvY2tlZCBhcnJheSB0aGUgbWV0aG9kIGhhcyBubyBlZmZlY3QuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBtZXRob2QgX2luY1JlZlxyXG4gKiBAY2hhaW5hYmxlXHJcbiAqIEBwYXJhbSB7TkRBcnJheX0gYXJyYXkgLSB0aGUgYXJyYXkgdG8gaW5jcmVtZW50IHRoZSByZWZlcmVuY2UgY291bnQgZm9yLiBNdXN0IGJlIHZhbGlkIGJlZm9yZSB0aGUgY2FsbCwgYnV0IG1heSBoYXZlIHplcm8gcmVmZXJlbmNlIGNvdW50LlxyXG4gKi9cclxuTkRBcnJheS5wcm90b3R5cGUuX2luY1JlZiA9IGZ1bmN0aW9uKGFycmF5KSB7XHJcblx0aWYgKHRoaXMuX2xvY2tDb3VudCA9PT0gMCkge1xyXG5cdFx0Kyt0aGlzLl9yZWZDb3VudDtcclxuXHR9XHJcblx0cmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogQ2hlY2tzIGlmIHRoZSBhcnJheSBpcyBsb2NrZWQgb3IgaGFzIGFueSByZWZlcmVuY2VzLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAbWV0aG9kIF9oYXNSZWZzXHJcbiAqIEBwYXJhbSB7TkRBcnJheX0gYXJyYXkgLSB0aGUgYXJyYXkgdG8gY2hlY2suIE11c3QgYmUgdmFsaWQgYmVmb3JlIHRoZSBjYWxsLCBidXQgbWF5IGhhdmUgemVybyByZWZlcmVuY2UgY291bnQuXHJcbiAqIEByZXR1cm4ge0Jvb2xlYW59IC0gdHJ1ZSBpZiB0aGUgYXJyYXkgaXMgbG9ja2VkIG9yIGhhcyByZWZlcmVuY2VzIGFuZCBmYWxzZSBvdGhlcndpc2UuXHJcbiAqL1xyXG5OREFycmF5LnByb3RvdHlwZS5faGFzUmVmcyA9IGZ1bmN0aW9uKGFycmF5KSB7XHJcblx0cmV0dXJuICh0aGlzLl9sb2NrQ291bnQgIT09IDApIHx8ICh0aGlzLl9yZWZDb3VudCAhPT0gMCk7XHJcbn07XHJcblxyXG4vKipcclxuICogSW52YWxpZGF0ZXMgdGhlIGFycmF5IGlmIGl0IHZhbGlkLCBub3QgbG9ja2VkLCBhbmQgaGFzIHplcm8gcmVmZXJlbmNlIGNvdW50LlxyXG4gKiBIYXMgbm8gZWZmZWN0IGluIGFsbCBvdGhlciBjYXNlcy5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQG1ldGhvZCBfdHJ5SW52YWxpZGF0ZVxyXG4gKiBAcGFyYW0ge05EQXJyYXl9IGFycmF5IC0gdGhlIGFycmF5IHRvIHRyeSB0byBpbnZhbGlkYXRlLiBDYW4gYmUgaW52YWxpZC5cclxuICogQHJldHVybiB7Qm9vbGVhbn0gLSB0cnVlIGlmIHRoZSBhcnJheSB3YXMgaW52YWxpZGF0ZWQgYnkgdGhpcyBjYWxsIGFuZCBmYWxzZSBvdGhlcndpc2UuXHJcbiAqL1xyXG5OREFycmF5LnByb3RvdHlwZS5fdHJ5SW52YWxpZGF0ZSA9IGZ1bmN0aW9uKGFycmF5KSB7XHJcblx0aWYgKHRoaXMuaXNWYWxpZCgpICYmICF0aGlzLl9oYXNSZWZzKCkpIHtcclxuXHRcdHRoaXMuX2NvbnRleHQuX2ludmFsaWRhdGUodGhpcyk7XHJcblx0XHR0aGlzLl9pc1ZhbGlkID0gZmFsc2U7XHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBBZGRzIGFub3RoZXIgYXJyYXkgb3IgYSBudW1iZXIgdG8gdGhpcyBhcnJheS5cclxuICpcclxuICogQG1ldGhvZCBhZGRcclxuICogQHBhcmFtIHsoTkRBcnJheXxOdW1iZXIpfSBvdGhlciAtIHRoZSBhcnJheSBvciBzY2FsYXIgdG8gYmUgYWRkZWQuXHJcbiAqIEByZXR1cm4ge05EQXJyYXl9XHJcbiAqL1xyXG5OREFycmF5LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihvdGhlcikge1xyXG5cdHJldHVybiB0aGlzLl9jb250ZXh0LmFkZCh0aGlzLCBvdGhlcik7XHJcbn07XHJcblxyXG4vKipcclxuICogU3VidHJhY3RzIGFub3RoZXIgYXJyYXkgb3IgYSBudW1iZXIgZnJvbSB0aGlzIGFycmF5LlxyXG4gKlxyXG4gKiBAbWV0aG9kIHN1YlxyXG4gKiBAcGFyYW0geyhOREFycmF5fE51bWJlcil9IG90aGVyIC0gdGhlIGFycmF5IG9yIHNjYWxhciB0byBiZSBzdWJ0cmFjdGVkLlxyXG4gKiBAcmV0dXJuIHtOREFycmF5fVxyXG4gKi9cclxuTkRBcnJheS5wcm90b3R5cGUuc3ViID0gZnVuY3Rpb24ob3RoZXIpIHtcclxuXHRyZXR1cm4gdGhpcy5fY29udGV4dC5zdWIodGhpcywgb3RoZXIpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIE11bHRpcGxpZXMgYXJyYXkgZWxlbWVudHMgYnkgYW5vdGhlciBhcnJheSBvciBieSBhIG51bWJlci5cclxuICpcclxuICogQG1ldGhvZCBtdWxcclxuICogQHBhcmFtIHsoTkRBcnJheXxOdW1iZXIpfSBvdGhlciAtIHRoZSBhcnJheSBvciBzY2FsYXIgdG8gbXVsdGlwbHkgZWxlbWVudHMgYnkuXHJcbiAqIEByZXR1cm4ge05EQXJyYXl9XHJcbiAqL1xyXG5OREFycmF5LnByb3RvdHlwZS5tdWwgPSBmdW5jdGlvbihvdGhlcikge1xyXG5cdHJldHVybiB0aGlzLl9jb250ZXh0Lm11bCh0aGlzLCBvdGhlcik7XHJcbn07XHJcblxyXG4vKipcclxuICogRGl2aWRlcyBhcnJheSBlbGVtZW50cyBieSBhbm90aGVyIGFycmF5IG9yIGJ5IGEgbnVtYmVyLlxyXG4gKlxyXG4gKiBAbWV0aG9kIGRpdlxyXG4gKiBAcGFyYW0geyhOREFycmF5fE51bWJlcil9IG90aGVyIC0gdGhlIGFycmF5IG9yIHNjYWxhciB0byBkaXZpZGUgZWxlbWVudHMgYnkuXHJcbiAqIEByZXR1cm4ge05EQXJyYXl9XHJcbiAqL1xyXG5OREFycmF5LnByb3RvdHlwZS5kaXYgPSBmdW5jdGlvbihvdGhlcikge1xyXG5cdHJldHVybiB0aGlzLl9jb250ZXh0LmRpdih0aGlzLCBvdGhlcik7XHJcbn07XHJcblxyXG4vKipcclxuICogUmVkdWNlcyBhcnJheSBlbGVtZW50cyB1c2luZyBtaW5pbXVtIG9wZXJhdGlvbi5cclxuICogSWYgdGhlIGF4aXMgYXJndW1lbnQgaXMgcHJvdmlkZWQsIHRoZSBtZXRob2QgY29tcHV0ZXMgbWluaW11bSBvZiBlbGVtZW50cyBhbG9uZyB0aGUgc3BlY2lmaWVkIGF4aXMuXHJcbiAqIE90aGVyd2lzZSwgdGhlIG1ldGhvZCBjb21wdXRlcyBhbiBhbGwtYXJyYXkgbWluaW11bSBvZiB0aGUgZWxlbWVudHMgYW5kIHJldHVybnMgdGhlbSBhcyBhIDEtZWxlbWVudCBhcnJheS5cclxuICpcclxuICogQG1ldGhvZCBtaW5cclxuICogQHBhcmFtIHtOdW1iZXJ9IFtheGlzXSAtIHRoZSBheGlzIGFsb25nIHdoaWNoIHRoZSBtaW5pbXVtIGlzIGNvbXB1dGVkLlxyXG4gKiBAcmV0dXJuIHtOREFycmF5fVxyXG4gKi9cclxuTkRBcnJheS5wcm90b3R5cGUubWluID0gZnVuY3Rpb24oYXhpcykge1xyXG5cdHJldHVybiB0aGlzLl9jb250ZXh0Lm1pbih0aGlzLCBheGlzKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZWR1Y2VzIGFycmF5IGVsZW1lbnRzIHVzaW5nIG1heGltdW0gb3BlcmF0aW9uLlxyXG4gKiBJZiB0aGUgYXhpcyBhcmd1bWVudCBpcyBwcm92aWRlZCwgdGhlIG1ldGhvZCBjb21wdXRlcyBtYXhpbXVtIG9mIGVsZW1lbnRzIGFsb25nIHRoZSBzcGVjaWZpZWQgYXhpcy5cclxuICogT3RoZXJ3aXNlLCB0aGUgbWV0aG9kIGNvbXB1dGVzIGFuIGFsbC1hcnJheSBtYXhpbXVtIG9mIHRoZSBlbGVtZW50cyBhbmQgcmV0dXJucyB0aGVtIGFzIGEgMS1lbGVtZW50IGFycmF5LlxyXG4gKlxyXG4gKiBAbWV0aG9kIG1pblxyXG4gKiBAcGFyYW0ge051bWJlcn0gW2F4aXNdIC0gdGhlIGF4aXMgYWxvbmcgd2hpY2ggdGhlIG1heGltdW0gaXMgY29tcHV0ZWQuXHJcbiAqIEByZXR1cm4ge05EQXJyYXl9XHJcbiAqL1xyXG5OREFycmF5LnByb3RvdHlwZS5tYXggPSBmdW5jdGlvbihheGlzKSB7XHJcblx0cmV0dXJuIHRoaXMuX2NvbnRleHQubWF4KHRoaXMsIGF4aXMpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlZHVjZXMgYXJyYXkgZWxlbWVudHMgdXNpbmcgc3VtIG9wZXJhdGlvbi5cclxuICogSWYgdGhlIGF4aXMgYXJndW1lbnQgaXMgcHJvdmlkZWQsIHRoZSBtZXRob2QgY29tcHV0ZXMgc3VtIG9mIGVsZW1lbnRzIGFsb25nIHRoZSBzcGVjaWZpZWQgYXhpcy5cclxuICogT3RoZXJ3aXNlLCB0aGUgbWV0aG9kIGNvbXB1dGVzIGFuIGFsbC1hcnJheSBzdW0gb2YgdGhlIGVsZW1lbnRzIGFuZCByZXR1cm5zIHRoZW0gYXMgYSAxLWVsZW1lbnQgYXJyYXkuXHJcbiAqXHJcbiAqIEBtZXRob2QgbWluXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbYXhpc10gLSB0aGUgYXhpcyBhbG9uZyB3aGljaCB0aGUgc3VtIGlzIGNvbXB1dGVkLlxyXG4gKiBAcmV0dXJuIHtOREFycmF5fVxyXG4gKi9cclxuTkRBcnJheS5wcm90b3R5cGUuc3VtID0gZnVuY3Rpb24oYXhpcykge1xyXG5cdHJldHVybiB0aGlzLl9jb250ZXh0LnN1bSh0aGlzLCBheGlzKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGFub3RoZXIgYXJyYXkgd2l0aCB0aGUgc2FtZSBkYXRhLCBidXQgZGlmZmVyZW50IGRpbWVuc2lvbnMuXHJcbiAqXHJcbiAqIEBtZXRob2QgcmVzaGFwZVxyXG4gKiBAcGFyYW0geyhOREFycmF5fE51bWJlcil9IG90aGVyIC0gZGltZW5zaW9ucyBvZiB0aGUgbmV3IGFycmF5LlxyXG4gKiBAcmV0dXJuIHtOREFycmF5fVxyXG4gKi9cclxuTkRBcnJheS5wcm90b3R5cGUucmVzaGFwZSA9IGZ1bmN0aW9uKG5ld1NoYXBlKSB7XHJcblx0cmV0dXJuIHRoaXMuX2NvbnRleHQucmVzaGFwZSh0aGlzLCBuZXdTaGFwZSk7XHJcbn07XHJcblxyXG4vKipcclxuICogRHVwbGljYXRlcyBhcnJheSBlbGVtZW50cyBhbG9uZyB0aGUgc3BlY2lmaWVkIGF4aXMuXHJcbiAqXHJcbiAqIEBtZXRob2QgcmVwZWF0XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSByZXBlYXRzIC0gdGhlIG51bWJlciBvZiB0aW1lcyB0byByZXBlYXQgZWFjaCBlbGVtZW50LlxyXG4gKiBAcGFyYW0ge051bWJlcn0gYXhpcyAtIHRoZSBheGlzIGFsb25nIHdoaWNoIHRoZSBlbGVtZW50cyB3aWxsIGJlIGR1cGxpY2F0ZWQuXHJcbiAqIEByZXR1cm4ge05EQXJyYXl9XHJcbiAqL1xyXG5OREFycmF5LnByb3RvdHlwZS5yZXBlYXQgPSBmdW5jdGlvbihyZXBlYXRzLCBheGlzKSB7XHJcblx0cmV0dXJuIHRoaXMuX2NvbnRleHQucmVwZWF0KHRoaXMsIHJlcGVhdHMsIGF4aXMpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIHRoZSBkYXRhIHRvIGEgSmF2YVNjcmlwdCBBcnJheS5cclxuICpcclxuICogQG1ldGhvZCBnZXRcclxuICogQGFzeW5jXHJcbiAqL1xyXG5OREFycmF5LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihjYWxsYmFjaykge1xyXG5cdHRoaXMuX2NvbnRleHQuZ2V0KHRoaXMsIGNhbGxiYWNrKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTkRBcnJheTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG52YXIgTkRBcnJheSA9IHJlcXVpcmUoXCIuL05EQXJyYXlcIik7XHJcbnZhciBEYXRhVHlwZSA9IHJlcXVpcmUoXCIuL0RhdGFUeXBlXCIpO1xyXG52YXIgYWxsb2NhdG9yID0gcmVxdWlyZShcIi4vYWxsb2NhdG9yXCIpO1xyXG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XHJcbnZhciByZXF1ZXN0cyA9IHJlcXVpcmUoXCIuL3JlcXVlc3RzLnBiXCIpO1xyXG52YXIgUmVxdWVzdCA9IHJlcXVlc3RzLlJlcXVlc3Q7XHJcbnZhciBFbXB0eUFycmF5UmVxdWVzdCA9IHJlcXVlc3RzLkVtcHR5QXJyYXlSZXF1ZXN0O1xyXG52YXIgRGF0YUFycmF5UmVxdWVzdCA9IHJlcXVlc3RzLkRhdGFBcnJheVJlcXVlc3Q7XHJcbnZhciBDb25zdEFycmF5UmVxdWVzdCA9IHJlcXVlc3RzLkNvbnN0QXJyYXlSZXF1ZXN0O1xyXG52YXIgTGluc3BhY2VSZXF1ZXN0ID0gcmVxdWVzdHMuTGluc3BhY2VSZXF1ZXN0O1xyXG52YXIgUmVzaGFwZVJlcXVlc3QgPSByZXF1ZXN0cy5SZXNoYXBlUmVxdWVzdDtcclxudmFyIFJlcGVhdFJlcXVlc3QgPSByZXF1ZXN0cy5SZXBlYXRSZXF1ZXN0O1xyXG52YXIgRGVhbGxvY2F0ZVJlcXVlc3QgPSByZXF1ZXN0cy5EZWFsbG9jYXRlUmVxdWVzdDtcclxudmFyIEZldGNoUmVxdWVzdCA9IHJlcXVlc3RzLkZldGNoUmVxdWVzdDtcclxudmFyIEJpbmFyeU9wZXJhdGlvblJlcXVlc3QgPSByZXF1ZXN0cy5CaW5hcnlPcGVyYXRpb25SZXF1ZXN0O1xyXG52YXIgQmluYXJ5Q29uc3RPcGVyYXRpb25SZXF1ZXN0ID0gcmVxdWVzdHMuQmluYXJ5Q29uc3RPcGVyYXRpb25SZXF1ZXN0O1xyXG52YXIgVW5hcnlPcGVyYXRpb25SZXF1ZXN0ID0gcmVxdWVzdHMuVW5hcnlPcGVyYXRpb25SZXF1ZXN0O1xyXG52YXIgUmVkdWN0aW9uUmVxdWVzdCA9IHJlcXVlc3RzLlJlZHVjdGlvblJlcXVlc3Q7XHJcbnZhciBBeGlzUmVkdWN0aW9uUmVxdWVzdCA9IHJlcXVlc3RzLkF4aXNSZWR1Y3Rpb25SZXF1ZXN0O1xyXG52YXIgRG90T3BlcmF0aW9uUmVxdWVzdCA9IHJlcXVlc3RzLkRvdE9wZXJhdGlvblJlcXVlc3Q7XHJcbnZhciBSZXNwb25zZSA9IHJlcXVpcmUoXCIuL3Jlc3BvbnNlcy5wYlwiKS5SZXNwb25zZTtcclxuXHJcbnZhciBkYXRhVHlwZU1hcCA9IHtcclxuXHRcImYzMlwiOiByZXF1ZXN0cy5EYXRhVHlwZS5GTE9BVDMyLFxyXG5cdFwiZjY0XCI6IHJlcXVlc3RzLkRhdGFUeXBlLkZMT0FUNjRcclxufTtcclxuXHJcbmZ1bmN0aW9uIFBCQ29udGV4dChvcHRpb25zLCBwb3N0TWVzc2FnZSwgY2FsbGJhY2spIHtcclxuXHR2YXIgY29udGV4dCA9IHRoaXM7XHJcblx0dGhpcy5fcG9zdE1lc3NhZ2UgPSBwb3N0TWVzc2FnZTtcclxuXHR0aGlzLl9jYWxsYmFja3MgPSB7fTtcclxuXHR0aGlzLl9jYWxsYmFja3NbMF0gPSBmdW5jdGlvbihsaW1pdHMpIHtcclxuXHRcdGNhbGxiYWNrKGNvbnRleHQsIGxpbWl0cyk7XHJcblx0fTtcclxufVxyXG5cclxuUEJDb250ZXh0LnByb3RvdHlwZS5fb25NZXNzYWdlID0gZnVuY3Rpb24obWVzc2FnZSkge1xyXG5cdHZhciByZXNwb25zZSA9IFJlc3BvbnNlLmRlY29kZShtZXNzYWdlLmRhdGEpO1xyXG5cdHZhciBpZCA9IHJlc3BvbnNlLmlkO1xyXG5cdHZhciBjYWxsYmFjayA9IHRoaXMuX2NhbGxiYWNrc1tpZF07XHJcblx0ZGVsZXRlIHRoaXMuX2NhbGxiYWNrc1tpZF07XHJcblx0c3dpdGNoIChyZXNwb25zZS50eXBlKSB7XHJcblx0XHRjYXNlIFJlc3BvbnNlLlR5cGUuSU5JVDpcclxuXHRcdFx0dmFyIGxpbWl0cyA9IHt9O1xyXG5cdFx0XHR2YXIgaW5pdFJlc3BvbnNlID0gcmVzcG9uc2UuaW5pdFJlc3BvbnNlO1xyXG5cdFx0XHRpZiAoaW5pdFJlc3BvbnNlLmNvbmN1cnJlbmN5ICE9PSBudWxsKSB7XHJcblx0XHRcdFx0bGltaXRzLmNvbmN1cnJlbmN5ID0gaW5pdFJlc3BvbnNlLmNvbmN1cnJlbmN5O1xyXG5cdFx0XHR9XHJcblx0XHRcdGNhbGxiYWNrKGxpbWl0cyk7XHJcblx0XHRcdGJyZWFrO1xyXG5cdFx0Y2FzZSBSZXNwb25zZS5UeXBlLkJBUlJJRVI6XHJcblx0XHRcdGNhbGxiYWNrKCk7XHJcblx0XHRcdGJyZWFrO1xyXG5cdFx0Y2FzZSBSZXNwb25zZS5UeXBlLkZFVENIOlxyXG5cdFx0XHRjYWxsYmFjayhyZXNwb25zZS5mZXRjaFJlc3BvbnNlLmRhdGFCdWZmZXIudG9BcnJheUJ1ZmZlcigpKTtcclxuXHRcdFx0YnJlYWs7XHJcblx0XHRjYXNlIFJlc3BvbnNlLlR5cGUuRVJST1I6XHJcblx0XHRcdGJyZWFrO1xyXG5cdFx0Y2FzZSBSZXNwb25zZS5UeXBlLklORk86XHJcblx0XHRcdGJyZWFrO1xyXG5cdH1cclxufTtcclxuXHJcblBCQ29udGV4dC5wcm90b3R5cGUuZW1wdHkgPSBmdW5jdGlvbihzaGFwZSwgZGF0YVR5cGUpIHtcclxuXHRzaGFwZSA9IHV0aWwuY2hlY2tTaGFwZShzaGFwZSk7XHJcblx0aWYgKHR5cGVvZiBkYXRhVHlwZSA9PT0gXCJ1bmRlZmluZWRcIikge1xyXG5cdFx0ZGF0YVR5cGUgPSBuZXcgRGF0YVR5cGUoXCJmNjRcIik7XHJcblx0fSBlbHNlIGlmICghKGRhdGFUeXBlIGluc3RhbmNlb2YgRGF0YVR5cGUpKSB7XHJcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKGRhdGFUeXBlICsgXCIgaXMgbm90IGFuIGluc3RhbmNlIG9mIERhdGFUeXBlXCIpO1xyXG5cdH1cclxuXHR2YXIgYXJyYXkgPSBuZXcgTkRBcnJheShzaGFwZSwgZGF0YVR5cGUsIHRoaXMpO1xyXG5cdGFycmF5Ll9pZCA9IGFsbG9jYXRvci5uZXdBcnJheUlkKCk7XHJcblxyXG5cdHZhciByZXF1ZXN0ID0gbmV3IFJlcXVlc3QoKTtcclxuXHRyZXF1ZXN0LmlkID0gYWxsb2NhdG9yLm5ld01lc3NhZ2VJZCgpO1xyXG5cdHJlcXVlc3QudHlwZSA9IFJlcXVlc3QuVHlwZS5FTVBUWV9BUlJBWTtcclxuXHR2YXIgZW1wdHlBcnJheVJlcXVlc3QgPSBuZXcgRW1wdHlBcnJheVJlcXVlc3QoKTtcclxuXHRlbXB0eUFycmF5UmVxdWVzdC5pZE91dCA9IGFycmF5Ll9pZDtcclxuXHRlbXB0eUFycmF5UmVxdWVzdC5zaGFwZSA9IHNoYXBlO1xyXG5cdGVtcHR5QXJyYXlSZXF1ZXN0LmRhdGFUeXBlID0gZGF0YVR5cGVNYXBbZGF0YVR5cGUudHlwZV07XHJcblx0cmVxdWVzdC5lbXB0eUFycmF5UmVxdWVzdCA9IGVtcHR5QXJyYXlSZXF1ZXN0O1xyXG5cdHRoaXMuX3Bvc3RNZXNzYWdlKHJlcXVlc3QuZW5jb2RlQUIoKSk7XHJcblxyXG5cdHJldHVybiBhcnJheTtcclxufTtcclxuXHJcblBCQ29udGV4dC5wcm90b3R5cGUuemVyb3MgPSBmdW5jdGlvbihzaGFwZSwgZGF0YVR5cGUpIHtcclxuXHRzaGFwZSA9IHV0aWwuY2hlY2tTaGFwZShzaGFwZSk7XHJcblx0aWYgKHR5cGVvZiBkYXRhVHlwZSA9PT0gXCJ1bmRlZmluZWRcIikge1xyXG5cdFx0ZGF0YVR5cGUgPSBuZXcgRGF0YVR5cGUoXCJmNjRcIik7XHJcblx0fSBlbHNlIGlmICghKGRhdGFUeXBlIGluc3RhbmNlb2YgRGF0YVR5cGUpKSB7XHJcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKGRhdGFUeXBlICsgXCIgaXMgbm90IGFuIGluc3RhbmNlIG9mIERhdGFUeXBlXCIpO1xyXG5cdH1cclxuXHR2YXIgYXJyYXkgPSBuZXcgTkRBcnJheShzaGFwZSwgZGF0YVR5cGUsIHRoaXMpO1xyXG5cdGFycmF5Ll9pZCA9IGFsbG9jYXRvci5uZXdBcnJheUlkKCk7XHJcblxyXG5cdHZhciByZXF1ZXN0ID0gbmV3IFJlcXVlc3QoKTtcclxuXHRyZXF1ZXN0LmlkID0gYWxsb2NhdG9yLm5ld01lc3NhZ2VJZCgpO1xyXG5cdHJlcXVlc3QudHlwZSA9IFJlcXVlc3QuVHlwZS5DT05TVF9BUlJBWTtcclxuXHR2YXIgY29uc3RBcnJheVJlcXVlc3QgPSBuZXcgQ29uc3RBcnJheVJlcXVlc3QoKTtcclxuXHRjb25zdEFycmF5UmVxdWVzdC5pZE91dCA9IGFycmF5Ll9pZDtcclxuXHRjb25zdEFycmF5UmVxdWVzdC5zaGFwZSA9IHNoYXBlO1xyXG5cdGNvbnN0QXJyYXlSZXF1ZXN0LmRhdGFUeXBlID0gZGF0YVR5cGVNYXBbZGF0YVR5cGUudHlwZV07XHJcblx0Y29uc3RBcnJheVJlcXVlc3QuZmlsbFZhbHVlID0gMC4wO1xyXG5cdHJlcXVlc3QuY29uc3RBcnJheVJlcXVlc3QgPSBjb25zdEFycmF5UmVxdWVzdDtcclxuXHR0aGlzLl9wb3N0TWVzc2FnZShyZXF1ZXN0LmVuY29kZUFCKCkpO1xyXG5cclxuXHRyZXR1cm4gYXJyYXk7XHJcbn07XHJcblxyXG5QQkNvbnRleHQucHJvdG90eXBlLm9uZXMgPSBmdW5jdGlvbihzaGFwZSwgZGF0YVR5cGUpIHtcclxuXHRzaGFwZSA9IHV0aWwuY2hlY2tTaGFwZShzaGFwZSk7XHJcblx0aWYgKHR5cGVvZiBkYXRhVHlwZSA9PT0gXCJ1bmRlZmluZWRcIikge1xyXG5cdFx0ZGF0YVR5cGUgPSBuZXcgRGF0YVR5cGUoXCJmNjRcIik7XHJcblx0fSBlbHNlIGlmICghKGRhdGFUeXBlIGluc3RhbmNlb2YgRGF0YVR5cGUpKSB7XHJcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKGRhdGFUeXBlICsgXCIgaXMgbm90IGFuIGluc3RhbmNlIG9mIERhdGFUeXBlXCIpO1xyXG5cdH1cclxuXHR2YXIgYXJyYXkgPSBuZXcgTkRBcnJheShzaGFwZSwgZGF0YVR5cGUsIHRoaXMpO1xyXG5cdGFycmF5Ll9pZCA9IGFsbG9jYXRvci5uZXdBcnJheUlkKCk7XHJcblxyXG5cdHZhciByZXF1ZXN0ID0gbmV3IFJlcXVlc3QoKTtcclxuXHRyZXF1ZXN0LmlkID0gYWxsb2NhdG9yLm5ld01lc3NhZ2VJZCgpO1xyXG5cdHJlcXVlc3QudHlwZSA9IFJlcXVlc3QuVHlwZS5DT05TVF9BUlJBWTtcclxuXHR2YXIgY29uc3RBcnJheVJlcXVlc3QgPSBuZXcgQ29uc3RBcnJheVJlcXVlc3QoKTtcclxuXHRjb25zdEFycmF5UmVxdWVzdC5pZE91dCA9IGFycmF5Ll9pZDtcclxuXHRjb25zdEFycmF5UmVxdWVzdC5zaGFwZSA9IHNoYXBlO1xyXG5cdGNvbnN0QXJyYXlSZXF1ZXN0LmRhdGFUeXBlID0gZGF0YVR5cGVNYXBbZGF0YVR5cGUudHlwZV07XHJcblx0Y29uc3RBcnJheVJlcXVlc3QuZmlsbFZhbHVlID0gMS4wO1xyXG5cdHJlcXVlc3QuY29uc3RBcnJheVJlcXVlc3QgPSBjb25zdEFycmF5UmVxdWVzdDtcclxuXHR0aGlzLl9wb3N0TWVzc2FnZShyZXF1ZXN0LmVuY29kZUFCKCkpO1xyXG5cclxuXHRyZXR1cm4gYXJyYXk7XHJcbn07XHJcblxyXG5QQkNvbnRleHQucHJvdG90eXBlLmFycmF5ID0gZnVuY3Rpb24oZGF0YSwgZGF0YVR5cGUpIHtcclxuXHR2YXIgc2hhcGUgPSBbXTtcclxuXHR1dGlsLmRpc2NvdmVyQXJyYXlTaGFwZVJlY3Vyc2l2ZShkYXRhLCBzaGFwZSwgMCk7XHJcblx0aWYgKHR5cGVvZiBkYXRhVHlwZSA9PT0gXCJ1bmRlZmluZWRcIikge1xyXG5cdFx0ZGF0YVR5cGUgPSBuZXcgRGF0YVR5cGUoXCJmNjRcIik7XHJcblx0fSBlbHNlIGlmICghKGRhdGFUeXBlIGluc3RhbmNlb2YgRGF0YVR5cGUpKSB7XHJcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKGRhdGFUeXBlICsgXCIgaXMgbm90IGFuIGluc3RhbmNlIG9mIERhdGFUeXBlXCIpO1xyXG5cdH1cclxuXHR2YXIgYXJyYXkgPSBuZXcgTkRBcnJheShzaGFwZSwgZGF0YVR5cGUsIHRoaXMpO1xyXG5cdGFycmF5Ll9pZCA9IGFsbG9jYXRvci5uZXdBcnJheUlkKCk7XHJcblx0dmFyIGFycmF5QnVmZmVyID0gbmV3IGRhdGFUeXBlLmFycmF5VHlwZShhcnJheS5sZW5ndGgpO1xyXG5cdHV0aWwuY29weUFycmF5RGF0YVJlY3Vyc2l2ZShhcnJheUJ1ZmZlciwgZGF0YSwgc2hhcGUsIDAsIDApO1xyXG5cclxuXHR2YXIgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KCk7XHJcblx0cmVxdWVzdC5pZCA9IGFsbG9jYXRvci5uZXdNZXNzYWdlSWQoKTtcclxuXHRyZXF1ZXN0LnR5cGUgPSBSZXF1ZXN0LlR5cGUuREFUQV9BUlJBWTtcclxuXHR2YXIgZGF0YUFycmF5UmVxdWVzdCA9IG5ldyBEYXRhQXJyYXlSZXF1ZXN0KCk7XHJcblx0ZGF0YUFycmF5UmVxdWVzdC5pZE91dCA9IGFycmF5Ll9pZDtcclxuXHRkYXRhQXJyYXlSZXF1ZXN0LnNoYXBlID0gc2hhcGU7XHJcblx0ZGF0YUFycmF5UmVxdWVzdC5kYXRhVHlwZSA9IGRhdGFUeXBlTWFwW2RhdGFUeXBlLnR5cGVdO1xyXG5cdGRhdGFBcnJheVJlcXVlc3QuZGF0YUJ1ZmZlciA9IGFycmF5QnVmZmVyLmJ1ZmZlcjtcclxuXHRyZXF1ZXN0LmRhdGFBcnJheVJlcXVlc3QgPSBkYXRhQXJyYXlSZXF1ZXN0O1xyXG5cdHRoaXMuX3Bvc3RNZXNzYWdlKHJlcXVlc3QuZW5jb2RlQUIoKSk7XHJcblxyXG5cdHJldHVybiBhcnJheTtcclxufTtcclxuXHJcblBCQ29udGV4dC5wcm90b3R5cGUubGluc3BhY2UgPSBmdW5jdGlvbihzdGFydCwgc3RvcCwgc2FtcGxlcywgaW5jbHVkZVN0b3ApIHtcclxuXHRpZiAoIXV0aWwuaXNSZWFsKHN0YXJ0KSkge1xyXG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihzdGFydCArIFwiIGlzIG5vdCBhIHJlYWwgbnVtYmVyXCIpO1xyXG5cdH1cclxuXHRpZiAoIXV0aWwuaXNSZWFsKHN0b3ApKSB7XHJcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKHN0b3AgKyBcIiBpcyBub3QgYSByZWFsIG51bWJlclwiKTtcclxuXHR9XHJcblx0aWYgKHR5cGVvZiBzYW1wbGVzID09PSBcInVuZGVmaW5lZFwiKSB7XHJcblx0XHQvKiBEZWZhdWx0IHZhbHVlIGluIE51bVB5ICovXHJcblx0XHRzYW1wbGVzID0gNTA7XHJcblx0fSBlbHNlIGlmICghdXRpbC5pc0ludChzYW1wbGVzKSkge1xyXG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihzYW1wbGVzICsgXCIgaXMgbm90IGFuIGludGVnZXJcIik7XHJcblx0fSBlbHNlIGlmIChzYW1wbGVzIDw9IDApIHtcclxuXHRcdHRocm93IG5ldyBSYW5nZUVycm9yKFwiVGhlIG51bWJlciBvZiBzYW1wbGVzIG11c3QgYmUgcG9zaXRpdmVcIik7XHJcblx0fVxyXG5cdGlmICh0eXBlb2YgaW5jbHVkZVN0b3AgPT09IFwidW5kZWZpbmVkXCIpIHtcclxuXHRcdGluY2x1ZGVTdG9wID0gdHJ1ZTtcclxuXHR9XHJcblx0aWYgKGluY2x1ZGVTdG9wICYmIChzYW1wbGVzID09PSAxKSkge1xyXG5cdFx0dGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUaGUgbnVtYmVyIG9mIHNhbXBsZXMgbXVzdCBiZSBhIGxlYXN0IDIgKGZvciBzdGFydCBhbmQgZW5kIHBvaW50cylcIik7XHJcblx0fVxyXG5cdHZhciBkYXRhVHlwZSA9IG5ldyBEYXRhVHlwZShcImY2NFwiKTtcclxuXHR2YXIgYXJyYXkgPSBuZXcgTkRBcnJheShbc2FtcGxlc10sIGRhdGFUeXBlLCB0aGlzKTtcclxuXHRhcnJheS5faWQgPSBhbGxvY2F0b3IubmV3QXJyYXlJZCgpO1xyXG5cclxuXHR2YXIgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KCk7XHJcblx0cmVxdWVzdC5pZCA9IGFsbG9jYXRvci5uZXdNZXNzYWdlSWQoKTtcclxuXHRyZXF1ZXN0LnR5cGUgPSBSZXF1ZXN0LlR5cGUuTElOU1BBQ0U7XHJcblx0dmFyIGxpbnNwYWNlUmVxdWVzdCA9IG5ldyBMaW5zcGFjZVJlcXVlc3QoKTtcclxuXHRsaW5zcGFjZVJlcXVlc3QuaWRPdXQgPSBhcnJheS5faWQ7XHJcblx0bGluc3BhY2VSZXF1ZXN0LnN0YXJ0ID0gc3RhcnQ7XHJcblx0bGluc3BhY2VSZXF1ZXN0LnN0b3AgPSBzdG9wO1xyXG5cdGxpbnNwYWNlUmVxdWVzdC5zYW1wbGVzID0gc2FtcGxlcztcclxuXHRsaW5zcGFjZVJlcXVlc3QuY2xvc2VkID0gaW5jbHVkZVN0b3A7XHJcblx0bGluc3BhY2VSZXF1ZXN0LmRhdGFUeXBlID0gZGF0YVR5cGVNYXBbZGF0YVR5cGUudHlwZV07XHJcblx0cmVxdWVzdC5saW5zcGFjZVJlcXVlc3QgPSBsaW5zcGFjZVJlcXVlc3Q7XHJcblx0dGhpcy5fcG9zdE1lc3NhZ2UocmVxdWVzdC5lbmNvZGVBQigpKTtcclxuXHJcblx0cmV0dXJuIGFycmF5O1xyXG59O1xyXG5cclxuUEJDb250ZXh0LnByb3RvdHlwZS5yZXNoYXBlID0gZnVuY3Rpb24oYSwgc2hhcGUpIHtcclxuXHR1dGlsLmNoZWNrTkRBcnJheShhLCBcImFcIik7XHJcblx0c2hhcGUgPSB1dGlsLmNoZWNrU2hhcGUoc2hhcGUpO1xyXG5cdGlmICh1dGlsLmNvbXB1dGVMZW5ndGgoc2hhcGUpICE9PSBhLmxlbmd0aCkge1xyXG5cdFx0dGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUaGUgc2hhcGUgaXMgbm90IGNvbXBhdGlibGUgd2l0aCB0aGUgYXJyYXlcIik7XHJcblx0fVxyXG5cdHZhciBpZEEgPSBhLl9pZDtcclxuXHR2YXIgcmVsZWFzZUEgPSAhYS5fZGVjUmVmKCk7XHJcblx0dmFyIG91dCA9IG5ldyBOREFycmF5KHNoYXBlLCBhLmRhdGFUeXBlLCB0aGlzKTtcclxuXHRpZiAocmVsZWFzZUEpIHtcclxuXHRcdG91dC5faWQgPSBpZEE7XHJcblx0XHRhLl9pZCA9IDA7XHJcblx0XHRyZWxlYXNlQSA9IGZhbHNlO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRvdXQuX2lkID0gYWxsb2NhdG9yLm5ld0FycmF5SWQoKTtcclxuXHR9XHJcblxyXG5cdHZhciByZXF1ZXN0ID0gbmV3IFJlcXVlc3QoKTtcclxuXHRyZXF1ZXN0LmlkID0gYWxsb2NhdG9yLm5ld01lc3NhZ2VJZCgpO1xyXG5cdHJlcXVlc3QudHlwZSA9IFJlcXVlc3QuVHlwZS5SRVNIQVBFO1xyXG5cdHZhciByZXNoYXBlUmVxdWVzdCA9IG5ldyBSZXNoYXBlUmVxdWVzdCgpO1xyXG5cdHJlc2hhcGVSZXF1ZXN0LmlkQSA9IGlkQTtcclxuXHRyZXNoYXBlUmVxdWVzdC5pZE91dCA9IG91dC5faWQ7XHJcblx0cmVzaGFwZVJlcXVlc3Quc2hhcGVPdXQgPSBzaGFwZTtcclxuXHRyZXF1ZXN0LnJlc2hhcGVSZXF1ZXN0ID0gcmVzaGFwZVJlcXVlc3Q7XHJcblx0dGhpcy5fcG9zdE1lc3NhZ2UocmVxdWVzdC5lbmNvZGVBQigpKTtcclxuXHJcblx0YS5fdHJ5SW52YWxpZGF0ZSgpO1xyXG5cdHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG5QQkNvbnRleHQucHJvdG90eXBlLnJlcGVhdCA9IGZ1bmN0aW9uKGEsIHJlcGVhdHMsIGF4aXMsIG91dCkge1xyXG5cdHV0aWwuY2hlY2tOREFycmF5KGEsIFwiYVwiKTtcclxuXHRyZXBlYXRzID0gdXRpbC5jaGVja1JlcGVhdHMocmVwZWF0cyk7XHJcblx0YXhpcyA9IHV0aWwuY2hlY2tBeGlzKGF4aXMsIGEuc2hhcGUubGVuZ3RoKTtcclxuXHR2YXIgc2hhcGVBID0gYS5zaGFwZTtcclxuXHR2YXIgc2hhcGVPdXQgPSBzaGFwZUEuc2xpY2UoMCk7XHJcblx0c2hhcGVPdXRbYXhpc10gKj0gcmVwZWF0cztcclxuXHRpZiAodHlwZW9mIG91dCA9PT0gXCJ1bmRlZmluZWRcIikge1xyXG5cdFx0b3V0ID0gbmV3IE5EQXJyYXkoc2hhcGVPdXQsIGEuZGF0YVR5cGUsIHRoaXMpO1xyXG5cdFx0b3V0Ll9pZCA9IGFsbG9jYXRvci5uZXdBcnJheUlkKCk7XHJcblx0fSBlbHNlIHtcclxuXHRcdHV0aWwuY2hlY2tOREFycmF5KG91dCwgXCJvdXRcIik7XHJcblx0XHR1dGlsLmNoZWNrU2hhcGVzQ29tcGF0aWJpbGl0eShvdXQuc2hhcGUsIHNoYXBlT3V0KTtcclxuXHRcdHV0aWwuY2hlY2tEYXRhVHlwZXNDb21wYXRpYmlsaXR5KGEuZGF0YVR5cGUsIG91dC5kYXRhVHlwZSk7XHJcblx0XHRvdXQuX2luY1JlZigpO1xyXG5cdH1cclxuXHR2YXIgaWRBID0gYS5faWQ7XHJcblx0aWYgKCFhLl9kZWNSZWYoKSkge1xyXG5cdFx0aWRBID0gLWlkQTtcclxuXHRcdGEuX2lkID0gMDtcclxuXHR9XHJcblxyXG5cdHZhciByZXF1ZXN0ID0gbmV3IFJlcXVlc3QoKTtcclxuXHRyZXF1ZXN0LmlkID0gYWxsb2NhdG9yLm5ld01lc3NhZ2VJZCgpO1xyXG5cdHJlcXVlc3QudHlwZSA9IFJlcXVlc3QuVHlwZS5SRVBFQVQ7XHJcblx0dmFyIHJlcGVhdFJlcXVlc3QgPSBuZXcgUmVwZWF0UmVxdWVzdCgpO1xyXG5cdHJlcGVhdFJlcXVlc3QuaWRBID0gaWRBO1xyXG5cdHJlcGVhdFJlcXVlc3QuaWRPdXQgPSBvdXQuX2lkO1xyXG5cdHJlcGVhdFJlcXVlc3QuYXhpcyA9IGF4aXM7XHJcblx0cmVwZWF0UmVxdWVzdC5yZXBlYXRzID0gcmVwZWF0cztcclxuXHRyZXF1ZXN0LnJlcGVhdFJlcXVlc3QgPSByZXBlYXRSZXF1ZXN0O1xyXG5cdHRoaXMuX3Bvc3RNZXNzYWdlKHJlcXVlc3QuZW5jb2RlQUIoKSk7XHJcblxyXG5cdGEuX3RyeUludmFsaWRhdGUoKTtcclxuXHRyZXR1cm4gb3V0O1xyXG59O1xyXG5cclxuUEJDb250ZXh0LnByb3RvdHlwZS5faW52YWxpZGF0ZSA9IGZ1bmN0aW9uKGFycmF5KSB7XHJcblx0aWYgKGFycmF5Ll9pZCAhPT0gMCkge1xyXG5cdFx0dmFyIHJlcXVlc3QgPSBuZXcgUmVxdWVzdCgpO1xyXG5cdFx0cmVxdWVzdC5pZCA9IGFsbG9jYXRvci5uZXdNZXNzYWdlSWQoKTtcclxuXHRcdHJlcXVlc3QudHlwZSA9IFJlcXVlc3QuVHlwZS5ERUFMTE9DQVRFO1xyXG5cdFx0dmFyIGRlYWxsb2NhdGVSZXF1ZXN0ID0gbmV3IERlYWxsb2NhdGVSZXF1ZXN0KCk7XHJcblx0XHRkZWFsbG9jYXRlUmVxdWVzdC5pZEEgPSBhcnJheS5faWQ7XHJcblx0XHRyZXF1ZXN0LmRlYWxsb2NhdGVSZXF1ZXN0ID0gZGVhbGxvY2F0ZVJlcXVlc3Q7XHJcblx0XHR0aGlzLl9wb3N0TWVzc2FnZShyZXF1ZXN0LmVuY29kZUFCKCkpO1xyXG5cdH1cclxufTtcclxuXHJcblBCQ29udGV4dC5wcm90b3R5cGUuZmV0Y2ggPSBmdW5jdGlvbigpIHtcclxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiQ2FsbGJhY2sgYXJndW1lbnQgbWlzc2luZ1wiKTtcclxuXHR9XHJcblx0dmFyIGNhbGxiYWNrID0gYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAxXTtcclxuXHQvKiBWYWxpZGF0ZSBhcmd1bWVudHMgKi9cclxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiQXQgbGVhc3Qgb25lIE5EQXJyYXkgYXJndW1lbnQgZXhwZWN0ZWRcIik7XHJcblx0fVxyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aCAtIDE7ICsraSkge1xyXG5cdFx0dXRpbC5jaGVja05EQXJyYXkoYXJndW1lbnRzW2ldLCBcImFyZ3VtZW50IFwiICsgaSk7XHJcblx0fVxyXG5cdHZhciByZWxlYXNlID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGggLSAxOyArK2kpIHtcclxuXHRcdHJlbGVhc2VbaV0gPSAhYXJndW1lbnRzW2ldLl9kZWNSZWYoKTtcclxuXHR9XHJcblx0dmFyIGNhbGxiYWNrV2FpdEFyZ3VtZW50cyA9IGFyZ3VtZW50cy5sZW5ndGggLSAxO1xyXG5cdHZhciBjYWxsYmFja0FyZ3VtZW50cyA9IG5ldyBBcnJheShjYWxsYmFja1dhaXRBcmd1bWVudHMpO1xyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgY2FsbGJhY2tXYWl0QXJndW1lbnRzOyBpKyspIHtcclxuXHRcdHZhciBhcnJheSA9IGFyZ3VtZW50c1tpXTtcclxuXHRcdHZhciBtZXNzYWdlSWQgPSBhbGxvY2F0b3IubmV3TWVzc2FnZUlkKCk7XHJcblx0XHR0aGlzLl9jYWxsYmFja3NbbWVzc2FnZUlkXSA9IChmdW5jdGlvbihpLCBBcnJheVR5cGUpIHtcclxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKGJ1ZmZlcikge1xyXG5cdFx0XHRcdGNhbGxiYWNrQXJndW1lbnRzW2ldID0gbmV3IEFycmF5VHlwZShidWZmZXIpO1xyXG5cdFx0XHRcdGlmICgtLWNhbGxiYWNrV2FpdEFyZ3VtZW50cyA9PT0gMCkge1xyXG5cdFx0XHRcdFx0Y2FsbGJhY2suYXBwbHkobnVsbCwgY2FsbGJhY2tBcmd1bWVudHMpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fTtcclxuXHRcdH0pKGksIGFycmF5LmRhdGFUeXBlLmFycmF5VHlwZSk7XHJcblx0XHR2YXIgYXJyYXlJZCA9IGFycmF5Ll9pZDtcclxuXHRcdGlmIChyZWxlYXNlW2ldKSB7XHJcblx0XHRcdGFycmF5Ll9pZCA9IDA7XHJcblx0XHRcdGFycmF5SWQgPSAtYXJyYXlJZDtcclxuXHRcdFx0YXJyYXkuX3RyeUludmFsaWRhdGUoKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KCk7XHJcblx0XHRyZXF1ZXN0LmlkID0gbWVzc2FnZUlkO1xyXG5cdFx0cmVxdWVzdC50eXBlID0gUmVxdWVzdC5UeXBlLkZFVENIO1xyXG5cdFx0dmFyIGZldGNoUmVxdWVzdCA9IG5ldyBGZXRjaFJlcXVlc3QoKTtcclxuXHRcdGZldGNoUmVxdWVzdC5pZEEgPSBhcnJheUlkO1xyXG5cdFx0cmVxdWVzdC5mZXRjaFJlcXVlc3QgPSBmZXRjaFJlcXVlc3Q7XHJcblx0XHR0aGlzLl9wb3N0TWVzc2FnZShyZXF1ZXN0LmVuY29kZUFCKCkpO1xyXG5cdH1cclxufTtcclxuXHJcblBCQ29udGV4dC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oKSB7XHJcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcihcIkNhbGxiYWNrIGFyZ3VtZW50IG1pc3NpbmdcIik7XHJcblx0fVxyXG5cdHZhciBjYWxsYmFjayA9IGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoIC0gMV07XHJcblx0LyogVmFsaWRhdGUgYXJndW1lbnRzICovXHJcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcihcIkF0IGxlYXN0IG9uZSBOREFycmF5IGFyZ3VtZW50IGV4cGVjdGVkXCIpO1xyXG5cdH1cclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGggLSAxOyArK2kpIHtcclxuXHRcdHV0aWwuY2hlY2tOREFycmF5KGFyZ3VtZW50c1tpXSwgXCJhcmd1bWVudCBcIiArIGkpO1xyXG5cdH1cclxuXHR2YXIgcmVsZWFzZSA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XHJcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoIC0gMTsgKytpKSB7XHJcblx0XHRyZWxlYXNlW2ldID0gIWFyZ3VtZW50c1tpXS5fZGVjUmVmKCk7XHJcblx0fVxyXG5cdHZhciBjYWxsYmFja1dhaXRBcmd1bWVudHMgPSBhcmd1bWVudHMubGVuZ3RoIC0gMTtcclxuXHR2YXIgY2FsbGJhY2tBcmd1bWVudHMgPSBuZXcgQXJyYXkoY2FsbGJhY2tXYWl0QXJndW1lbnRzKTtcclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGNhbGxiYWNrV2FpdEFyZ3VtZW50czsgaSsrKSB7XHJcblx0XHR2YXIgYXJyYXkgPSBhcmd1bWVudHNbaV07XHJcblx0XHR2YXIgbWVzc2FnZUlkID0gYWxsb2NhdG9yLm5ld01lc3NhZ2VJZCgpO1xyXG5cdFx0aWYgKGFycmF5LnNoYXBlLmxlbmd0aCA9PT0gMCkge1xyXG5cdFx0XHR0aGlzLl9jYWxsYmFja3NbbWVzc2FnZUlkXSA9IChmdW5jdGlvbihpLCBBcnJheVR5cGUpIHtcclxuXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oYnVmZmVyKSB7XHJcblx0XHRcdFx0XHR2YXIgdHlwZWRBcnJheSA9IG5ldyBBcnJheVR5cGUoYnVmZmVyKTtcclxuXHRcdFx0XHRcdGNhbGxiYWNrQXJndW1lbnRzW2ldID0gdHlwZWRBcnJheVswXTtcclxuXHRcdFx0XHRcdGlmICgtLWNhbGxiYWNrV2FpdEFyZ3VtZW50cyA9PT0gMCkge1xyXG5cdFx0XHRcdFx0XHRjYWxsYmFjay5hcHBseShudWxsLCBjYWxsYmFja0FyZ3VtZW50cyk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fTtcclxuXHRcdFx0fSkoaSwgYXJyYXkuZGF0YVR5cGUuYXJyYXlUeXBlKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRoaXMuX2NhbGxiYWNrc1ttZXNzYWdlSWRdID0gKGZ1bmN0aW9uKGksIEFycmF5VHlwZSwgc2hhcGUpIHtcclxuXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oYnVmZmVyKSB7XHJcblx0XHRcdFx0XHR2YXIganNhcnJheSA9IG5ldyBBcnJheShzaGFwZVswXSk7XHJcblx0XHRcdFx0XHR1dGlsLmNyZWF0ZUFycmF5UmVjdXJzaXZlKG5ldyBBcnJheVR5cGUoYnVmZmVyKSwganNhcnJheSwgc2hhcGUsIDAsIDApO1xyXG5cdFx0XHRcdFx0Y2FsbGJhY2tBcmd1bWVudHNbaV0gPSBqc2FycmF5O1xyXG5cdFx0XHRcdFx0aWYgKC0tY2FsbGJhY2tXYWl0QXJndW1lbnRzID09PSAwKSB7XHJcblx0XHRcdFx0XHRcdGNhbGxiYWNrLmFwcGx5KG51bGwsIGNhbGxiYWNrQXJndW1lbnRzKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9O1xyXG5cdFx0XHR9KShpLCBhcnJheS5kYXRhVHlwZS5hcnJheVR5cGUsIGFycmF5LnNoYXBlKTtcclxuXHRcdH1cclxuXHRcdHZhciBhcnJheUlkID0gYXJyYXkuX2lkO1xyXG5cdFx0aWYgKHJlbGVhc2VbaV0pIHtcclxuXHRcdFx0YXJyYXkuX2lkID0gMDtcclxuXHRcdFx0YXJyYXlJZCA9IC1hcnJheUlkO1xyXG5cdFx0XHRhcnJheS5fdHJ5SW52YWxpZGF0ZSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciByZXF1ZXN0ID0gbmV3IFJlcXVlc3QoKTtcclxuXHRcdHJlcXVlc3QuaWQgPSBtZXNzYWdlSWQ7XHJcblx0XHRyZXF1ZXN0LnR5cGUgPSBSZXF1ZXN0LlR5cGUuRkVUQ0g7XHJcblx0XHR2YXIgZmV0Y2hSZXF1ZXN0ID0gbmV3IEZldGNoUmVxdWVzdCgpO1xyXG5cdFx0ZmV0Y2hSZXF1ZXN0LmlkQSA9IGFycmF5SWQ7XHJcblx0XHRyZXF1ZXN0LmZldGNoUmVxdWVzdCA9IGZldGNoUmVxdWVzdDtcclxuXHRcdHRoaXMuX3Bvc3RNZXNzYWdlKHJlcXVlc3QuZW5jb2RlQUIoKSk7XHJcblx0fVxyXG59O1xyXG5cclxuUEJDb250ZXh0LnByb3RvdHlwZS5pbmZvID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcclxuXHR0aHJvdyBuZXcgRXJyb3IoXCJOb3QgaW1wbGVtZW50ZWRcIik7XHJcbi8qXHR2YXIgbWVzc2FnZUlkID0gYWxsb2NhdG9yLm5ld01lc3NhZ2VJZCgpO1xyXG5cdG1lc3NhZ2VDYWxsYmFja3NbbWVzc2FnZUlkXSA9IGNhbGxiYWNrO1xyXG5cdHRoaXMuX3BuYWNsT2JqZWN0LnBvc3RNZXNzYWdlKHtcclxuXHRcdFwiaWRcIjogbWVzc2FnZUlkLFxyXG5cdFx0XCJjb21tYW5kXCI6IFwiaW5mb1wiXHJcblx0fSk7Ki9cclxufTtcclxuXHJcblBCQ29udGV4dC5wcm90b3R5cGUuYmFycmllciA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XHJcblx0dmFyIG1lc3NhZ2VJZCA9IGFsbG9jYXRvci5uZXdNZXNzYWdlSWQoKTtcclxuXHR0aGlzLl9jYWxsYmFja3NbbWVzc2FnZUlkXSA9IGNhbGxiYWNrO1xyXG5cclxuXHR2YXIgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KCk7XHJcblx0cmVxdWVzdC5pZCA9IG1lc3NhZ2VJZDtcclxuXHRyZXF1ZXN0LnR5cGUgPSBSZXF1ZXN0LlR5cGUuQkFSUklFUjtcclxuXHR0aGlzLl9wb3N0TWVzc2FnZShyZXF1ZXN0LmVuY29kZUFCKCkpO1xyXG59O1xyXG5cclxudmFyIGJpbmFyeUFyaXRoT3AgPSBmdW5jdGlvbihhLCBiLCBvdXQsIGNvbnRleHQsIG9wZXJhdGlvbiwgY29uc3RPcGVyYXRpb24sIHJldkNvbnN0T3BlcmF0aW9uKSB7XHJcblx0dmFyIHNoYXBlT3V0ID0gbnVsbCwgZGF0YVR5cGVPdXQgPSBudWxsLCByZWxlYXNlSWRBID0gZmFsc2UsIHJlbGVhc2VJZEIgPSBmYWxzZSwgaWRBID0gMCwgaWRCID0gMDtcclxuXHRpZiAoYSBpbnN0YW5jZW9mIE5EQXJyYXkpIHtcclxuXHRcdGlkQSA9IGEuX2lkO1xyXG5cdFx0c2hhcGVPdXQgPSBhLnNoYXBlO1xyXG5cdFx0ZGF0YVR5cGVPdXQgPSBhLmRhdGFUeXBlO1xyXG5cdFx0aWYgKGIgaW5zdGFuY2VvZiBOREFycmF5KSB7XHJcblx0XHRcdGlkQiA9IGIuX2lkO1xyXG5cdFx0XHR1dGlsLmNoZWNrU2hhcGVzQ29tcGF0aWJpbGl0eShhLnNoYXBlLCBiLnNoYXBlKTtcclxuXHRcdFx0dXRpbC5jaGVja0RhdGFUeXBlc0NvbXBhdGliaWxpdHkoYS5kYXRhVHlwZSwgYi5kYXRhVHlwZSk7XHJcblx0XHR9IGVsc2UgaWYgKCF1dGlsLmlzTnVtYmVyKGIpKSB7XHJcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoXCJVbnN1cHBvcnRlZCB0eXBlIG9mIGJcIik7XHJcblx0XHR9XHJcblx0fSBlbHNlIGlmICh1dGlsLmlzTnVtYmVyKGEpKSB7XHJcblx0XHRpZEIgPSBiLl9pZDtcclxuXHRcdHNoYXBlT3V0ID0gYi5zaGFwZTtcclxuXHRcdGRhdGFUeXBlT3V0ID0gYi5kYXRhVHlwZTtcclxuXHRcdHV0aWwuY2hlY2tOREFycmF5KGIsIFwiYlwiKTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihcIlVuc3VwcG9ydGVkIHR5cGUgb2YgYVwiKTtcclxuXHR9XHJcblx0LyogVGhlIElEcyBvZiBhIGFuZCBiIG11c3QgYmUgaW52YWxpZGF0ZWQgYmVmb3JlIHdlIGFzc2lnbiBJRCB0byBvdXQgYmVjYXVzZSBhL2IgYW5kIG91dCBtYXkgYmUgdGhlIHNhbWUgYXJyYXlzICovXHJcblx0aWYgKGlkQSAhPT0gMCkge1xyXG5cdFx0cmVsZWFzZUlkQSA9ICFhLl9kZWNSZWYoKTtcclxuXHRcdGlmIChyZWxlYXNlSWRBKSB7XHJcblx0XHRcdGEuX2lkID0gMDtcclxuXHRcdH1cclxuXHR9XHJcblx0aWYgKGlkQiAhPT0gMCkge1xyXG5cdFx0cmVsZWFzZUlkQiA9ICFiLl9kZWNSZWYoKTtcclxuXHRcdGlmIChyZWxlYXNlSWRCKSB7XHJcblx0XHRcdGIuX2lkID0gMDtcclxuXHRcdH1cclxuXHR9XHJcblx0dHJ5IHtcclxuXHRcdGlmICh0eXBlb2Ygb3V0ID09PSBcInVuZGVmaW5lZFwiKSB7XHJcblx0XHRcdG91dCA9IG5ldyBOREFycmF5KHNoYXBlT3V0LCBkYXRhVHlwZU91dCwgY29udGV4dCk7XHJcblx0XHRcdGlmIChyZWxlYXNlSWRBKSB7XHJcblx0XHRcdFx0b3V0Ll9pZCA9IGlkQTtcclxuXHRcdFx0XHRyZWxlYXNlSWRBID0gZmFsc2U7XHJcblx0XHRcdH0gZWxzZSBpZiAocmVsZWFzZUlkQikge1xyXG5cdFx0XHRcdG91dC5faWQgPSBpZEI7XHJcblx0XHRcdFx0cmVsZWFzZUlkQiA9IGZhbHNlO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdG91dC5faWQgPSBhbGxvY2F0b3IubmV3QXJyYXlJZCgpO1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR1dGlsLmNoZWNrTkRBcnJheShvdXQsIFwib3V0XCIpO1xyXG5cdFx0XHR1dGlsLmNoZWNrU2hhcGVzQ29tcGF0aWJpbGl0eShzaGFwZU91dCwgb3V0LnNoYXBlKTtcclxuXHRcdFx0dXRpbC5jaGVja0RhdGFUeXBlc0NvbXBhdGliaWxpdHkoZGF0YVR5cGVPdXQsIG91dC5kYXRhVHlwZSk7XHJcblx0XHRcdG91dC5faW5jUmVmKCk7XHJcblx0XHR9XHJcblx0XHR2YXIgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KCk7XHJcblx0XHRyZXF1ZXN0LmlkID0gYWxsb2NhdG9yLm5ld01lc3NhZ2VJZCgpO1xyXG5cdFx0aWYgKGlkQSAhPT0gMCkge1xyXG5cdFx0XHRpZiAoaWRCICE9PSAwKSB7XHJcblx0XHRcdFx0cmVxdWVzdC50eXBlID0gUmVxdWVzdC5UeXBlLkJJTkFSWV9PUEVSQVRJT047XHJcblx0XHRcdFx0dmFyIGJpbmFyeU9wZXJhdGlvblJlcXVlc3QgPSBuZXcgQmluYXJ5T3BlcmF0aW9uUmVxdWVzdCgpO1xyXG5cdFx0XHRcdGJpbmFyeU9wZXJhdGlvblJlcXVlc3QudHlwZSA9IG9wZXJhdGlvbjtcclxuXHRcdFx0XHRiaW5hcnlPcGVyYXRpb25SZXF1ZXN0LmlkQSA9IChyZWxlYXNlSWRBID8gLWlkQSA6IGlkQSk7XHJcblx0XHRcdFx0YmluYXJ5T3BlcmF0aW9uUmVxdWVzdC5pZEIgPSAocmVsZWFzZUlkQiA/IC1pZEIgOiBpZEIpO1xyXG5cdFx0XHRcdGJpbmFyeU9wZXJhdGlvblJlcXVlc3QuaWRPdXQgPSBvdXQuX2lkO1xyXG5cdFx0XHRcdHJlcXVlc3QuYmluYXJ5T3BlcmF0aW9uUmVxdWVzdCA9IGJpbmFyeU9wZXJhdGlvblJlcXVlc3Q7XHJcblx0XHRcdFx0Y29udGV4dC5fcG9zdE1lc3NhZ2UocmVxdWVzdC5lbmNvZGVBQigpKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRyZXF1ZXN0LnR5cGUgPSBSZXF1ZXN0LlR5cGUuQklOQVJZX0NPTlNUX09QRVJBVElPTjtcclxuXHRcdFx0XHR2YXIgYmluYXJ5Q29uc3RPcGVyYXRpb25SZXF1ZXN0ID0gbmV3IEJpbmFyeUNvbnN0T3BlcmF0aW9uUmVxdWVzdCgpO1xyXG5cdFx0XHRcdGJpbmFyeUNvbnN0T3BlcmF0aW9uUmVxdWVzdC50eXBlID0gY29uc3RPcGVyYXRpb247XHJcblx0XHRcdFx0YmluYXJ5Q29uc3RPcGVyYXRpb25SZXF1ZXN0LmlkQSA9IChyZWxlYXNlSWRBID8gLWlkQSA6IGlkQSk7XHJcblx0XHRcdFx0YmluYXJ5Q29uc3RPcGVyYXRpb25SZXF1ZXN0LnZhbHVlQiA9IGI7XHJcblx0XHRcdFx0YmluYXJ5Q29uc3RPcGVyYXRpb25SZXF1ZXN0LmlkT3V0ID0gb3V0Ll9pZDtcclxuXHRcdFx0XHRyZXF1ZXN0LmJpbmFyeUNvbnN0T3BlcmF0aW9uUmVxdWVzdCA9IGJpbmFyeUNvbnN0T3BlcmF0aW9uUmVxdWVzdDtcclxuXHRcdFx0XHRjb250ZXh0Ll9wb3N0TWVzc2FnZShyZXF1ZXN0LmVuY29kZUFCKCkpO1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRyZXF1ZXN0LnR5cGUgPSBSZXF1ZXN0LlR5cGUuQklOQVJZX0NPTlNUX09QRVJBVElPTjtcclxuXHRcdFx0dmFyIGJpbmFyeUNvbnN0T3BlcmF0aW9uUmVxdWVzdCA9IG5ldyBCaW5hcnlDb25zdE9wZXJhdGlvblJlcXVlc3QoKTtcclxuXHRcdFx0YmluYXJ5Q29uc3RPcGVyYXRpb25SZXF1ZXN0LnR5cGUgPSByZXZDb25zdE9wZXJhdGlvbjtcclxuXHRcdFx0YmluYXJ5Q29uc3RPcGVyYXRpb25SZXF1ZXN0LmlkQSA9IChyZWxlYXNlSWRCID8gLWlkQiA6IGlkQik7XHJcblx0XHRcdGJpbmFyeUNvbnN0T3BlcmF0aW9uUmVxdWVzdC52YWx1ZUIgPSBhO1xyXG5cdFx0XHRiaW5hcnlDb25zdE9wZXJhdGlvblJlcXVlc3QuaWRPdXQgPSBvdXQuX2lkO1xyXG5cdFx0XHRyZXF1ZXN0LmJpbmFyeUNvbnN0T3BlcmF0aW9uUmVxdWVzdCA9IGJpbmFyeUNvbnN0T3BlcmF0aW9uUmVxdWVzdDtcclxuXHRcdFx0Y29udGV4dC5fcG9zdE1lc3NhZ2UocmVxdWVzdC5lbmNvZGVBQigpKTtcclxuXHRcdH1cclxuXHR9IGNhdGNoIChlKSB7XHJcblx0XHQvKiBSZXN0b3JlIHRoZSBwcmV2aW91cyBzdGF0ZSAqL1xyXG5cdFx0aWYgKGlkQSAhPT0gMCkge1xyXG5cdFx0XHRhLl9pZCA9IGlkQTtcclxuXHRcdFx0YS5faW5jUmVmKCk7XHJcblx0XHR9XHJcblx0XHRpZiAoaWRCICE9PSAwKSB7XHJcblx0XHRcdGIuX2lkID0gaWRCO1xyXG5cdFx0XHRiLl9pbmNSZWYoKTtcclxuXHRcdH1cclxuXHRcdHRocm93IGU7XHJcblx0fVxyXG5cdC8qXHJcblx0ICogSWYgYSBvciBiIGFyZSBhcnJheXMsIGludmFsaWRhdGUgdGhlbSBhcyBuZWVkZWQuXHJcblx0ICogSWYgYS9iIGFuZCBvdXQgYXJlIHRoZSBzYW1lLCB0aGVpciByZWYgY291bnQgaXMgbm9uLXplcm8gYXQgdGhpcyBwb2ludCwgc28gdGhleSB3aWxsIHN0YXkgdmFsaWQuXHJcblx0ICovXHJcblx0aWYgKGlkQSAhPT0gMCkge1xyXG5cdFx0YS5fdHJ5SW52YWxpZGF0ZSgpO1xyXG5cdH1cclxuXHRpZiAoaWRCICE9PSAwKSB7XHJcblx0XHRiLl90cnlJbnZhbGlkYXRlKCk7XHJcblx0fVxyXG5cdHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG52YXIgdW5hcnlBcml0aE9wID0gZnVuY3Rpb24oYSwgb3V0LCBjb250ZXh0LCBvcGVyYXRpb24pIHtcclxuXHR1dGlsLmNoZWNrTkRBcnJheShhLCBcImFcIik7XHJcblx0dmFyIGlkQSA9IGEuX2lkO1xyXG5cdHZhciByZWxlYXNlSWRBID0gIWEuX2RlY1JlZigpO1xyXG5cdC8qIFRoZSBJRCBvZiBhIG11c3QgYmUgaW52YWxpZGF0ZWQgYmVmb3JlIHdlIGFzc2lnbiBJRCB0byBvdXQgYmVjYXVzZSBhIGFuZCBvdXQgbWF5IGJlIHRoZSBzYW1lIGFycmF5cyAqL1xyXG5cdGlmIChyZWxlYXNlSWRBKSB7XHJcblx0XHRhLl9pZCA9IDA7XHJcblx0fVxyXG5cdHRyeSB7XHJcblx0XHRpZiAodHlwZW9mIG91dCA9PT0gXCJ1bmRlZmluZWRcIikge1xyXG5cdFx0XHRvdXQgPSBuZXcgTkRBcnJheShhLnNoYXBlLCBhLmRhdGFUeXBlLCBjb250ZXh0KTtcclxuXHRcdFx0aWYgKHJlbGVhc2VJZEEpIHtcclxuXHRcdFx0XHRvdXQuX2lkID0gaWRBO1xyXG5cdFx0XHRcdHJlbGVhc2VJZEEgPSBmYWxzZTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRvdXQuX2lkID0gYWxsb2NhdG9yLm5ld0FycmF5SWQoKTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dXRpbC5jaGVja05EQXJyYXkob3V0LCBcIm91dFwiKTtcclxuXHRcdFx0dXRpbC5jaGVja1NoYXBlc0NvbXBhdGliaWxpdHkoYS5zaGFwZSwgb3V0LnNoYXBlKTtcclxuXHRcdFx0dXRpbC5jaGVja0RhdGFUeXBlc0NvbXBhdGliaWxpdHkoYS5kYXRhVHlwZSwgb3V0LmRhdGFUeXBlKTtcclxuXHRcdFx0b3V0Ll9pbmNSZWYoKTtcclxuXHRcdH1cclxuXHR9IGNhdGNoIChlKSB7XHJcblx0XHQvKiBSZXN0b3JlIHRoZSBwcmV2aW91cyBzdGF0ZSAqL1xyXG5cdFx0YS5faWQgPSBpZEE7XHJcblx0XHRhLl9pbmNSZWYoKTtcclxuXHRcdHRocm93IGU7XHJcblx0fVxyXG5cclxuXHR2YXIgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KCk7XHJcblx0cmVxdWVzdC5pZCA9IGFsbG9jYXRvci5uZXdNZXNzYWdlSWQoKTtcclxuXHRyZXF1ZXN0LnR5cGUgPSBSZXF1ZXN0LlR5cGUuVU5BUllfT1BFUkFUSU9OO1xyXG5cdHZhciB1bmFyeU9wZXJhdGlvblJlcXVlc3QgPSBuZXcgVW5hcnlPcGVyYXRpb25SZXF1ZXN0KCk7XHJcblx0dW5hcnlPcGVyYXRpb25SZXF1ZXN0LnR5cGUgPSBvcGVyYXRpb247XHJcblx0dW5hcnlPcGVyYXRpb25SZXF1ZXN0LmlkQSA9IChyZWxlYXNlSWRBID8gLWlkQSA6IGlkQSk7XHJcblx0dW5hcnlPcGVyYXRpb25SZXF1ZXN0LmlkT3V0ID0gb3V0Ll9pZDtcclxuXHRyZXF1ZXN0LnVuYXJ5T3BlcmF0aW9uUmVxdWVzdCA9IHVuYXJ5T3BlcmF0aW9uUmVxdWVzdDtcclxuXHRjb250ZXh0Ll9wb3N0TWVzc2FnZShyZXF1ZXN0LmVuY29kZUFCKCkpO1xyXG5cclxuXHQvKiBJZiBhIGFuZCBvdXQgYXJlIHRoZSBzYW1lLCB0aGVpciByZWYgY291bnQgaXMgbm9uLXplcm8gYXQgdGhpcyBwb2ludCwgc28gdGhleSB3aWxsIHN0YXkgdmFsaWQuICovXHJcblx0YS5fdHJ5SW52YWxpZGF0ZSgpO1xyXG5cdHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG52YXIgcmVkdWNlQXJpdGhPcCA9IGZ1bmN0aW9uKGEsIG91dCwgY29udGV4dCwgb3BlcmF0aW9uKSB7XHJcblx0dXRpbC5jaGVja05EQXJyYXkoYSwgXCJhXCIpO1xyXG5cdHZhciBpZEEgPSBhLl9pZDtcclxuXHR2YXIgcmVsZWFzZUlkQSA9ICFhLl9kZWNSZWYoKTtcclxuXHRpZiAocmVsZWFzZUlkQSkge1xyXG5cdFx0YS5faWQgPSAwO1xyXG5cdH1cclxuXHR0cnkge1xyXG5cdFx0aWYgKHR5cGVvZiBvdXQgPT09IFwidW5kZWZpbmVkXCIpIHtcclxuXHRcdFx0b3V0ID0gbmV3IE5EQXJyYXkoW10sIGEuZGF0YVR5cGUsIGNvbnRleHQpO1xyXG5cdFx0XHRvdXQuX2lkID0gYWxsb2NhdG9yLm5ld0FycmF5SWQoKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHV0aWwuY2hlY2tOREFycmF5KG91dCwgXCJvdXRcIik7XHJcblx0XHRcdHV0aWwuY2hlY2tTaGFwZXNDb21wYXRpYmlsaXR5KG91dC5zaGFwZSwgW10pO1xyXG5cdFx0XHR1dGlsLmNoZWNrRGF0YVR5cGVzQ29tcGF0aWJpbGl0eShhLmRhdGFUeXBlLCBvdXQuZGF0YVR5cGUpO1xyXG5cdFx0XHRvdXQuX2luY1JlZigpO1xyXG5cdFx0fVxyXG5cdH0gY2F0Y2ggKGUpIHtcclxuXHRcdC8qIFJlc3RvcmUgdGhlIHByZXZpb3VzIHN0YXRlICovXHJcblx0XHRhLl9pZCA9IGlkQTtcclxuXHRcdGEuX2luY1JlZigpO1xyXG5cdFx0dGhyb3cgZTtcclxuXHR9XHJcblxyXG5cdHZhciByZXF1ZXN0ID0gbmV3IFJlcXVlc3QoKTtcclxuXHRyZXF1ZXN0LmlkID0gYWxsb2NhdG9yLm5ld01lc3NhZ2VJZCgpO1xyXG5cdHJlcXVlc3QudHlwZSA9IFJlcXVlc3QuVHlwZS5SRURVQ1RJT05fT1BFUkFUSU9OO1xyXG5cdHZhciByZWR1Y3Rpb25SZXF1ZXN0ID0gbmV3IFJlZHVjdGlvblJlcXVlc3QoKTtcclxuXHRyZWR1Y3Rpb25SZXF1ZXN0LnR5cGUgPSBvcGVyYXRpb247XHJcblx0cmVkdWN0aW9uUmVxdWVzdC5pZEEgPSAocmVsZWFzZUlkQSA/IC1pZEEgOiBpZEEpO1xyXG5cdHJlZHVjdGlvblJlcXVlc3QuaWRPdXQgPSBvdXQuX2lkO1xyXG5cdHJlcXVlc3QucmVkdWN0aW9uUmVxdWVzdCA9IHJlZHVjdGlvblJlcXVlc3Q7XHJcblx0Y29udGV4dC5fcG9zdE1lc3NhZ2UocmVxdWVzdC5lbmNvZGVBQigpKTtcclxuXHJcblx0YS5fdHJ5SW52YWxpZGF0ZSgpO1xyXG5cdHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG52YXIgYXhpc1JlZHVjZUFyaXRoT3AgPSBmdW5jdGlvbihhLCBheGlzLCBvdXQsIGNvbnRleHQsIG9wZXJhdGlvbikge1xyXG5cdHV0aWwuY2hlY2tOREFycmF5KGEsIFwiYVwiKTtcclxuXHR2YXIgaWRBID0gYS5faWQ7XHJcblx0dmFyIHJlbGVhc2VJZEEgPSAhYS5fZGVjUmVmKCk7XHJcblx0aWYgKHJlbGVhc2VJZEEpIHtcclxuXHRcdGEuX2lkID0gMDtcclxuXHR9XHJcblx0dHJ5IHtcclxuXHRcdHV0aWwuY2hlY2tBeGlzKGF4aXMpO1xyXG5cdFx0aWYgKHR5cGVvZiBvdXQgPT09IFwidW5kZWZpbmVkXCIpIHtcclxuXHRcdFx0b3V0ID0gbmV3IE5EQXJyYXkodXRpbC5jb21wdXRlQXhpc1JlZHVjdGlvbk91dFNoYXBlKGEuc2hhcGUsIGF4aXMpLCBhLmRhdGFUeXBlLCBjb250ZXh0KTtcclxuXHRcdFx0b3V0Ll9pZCA9IGFsbG9jYXRvci5uZXdBcnJheUlkKCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR1dGlsLmNoZWNrTkRBcnJheShvdXQsIFwib3V0XCIpO1xyXG5cdFx0XHR1dGlsLmNoZWNrU2hhcGVzQ29tcGF0aWJpbGl0eShvdXQuc2hhcGUsIFtdKTtcclxuXHRcdFx0dXRpbC5jaGVja0RhdGFUeXBlc0NvbXBhdGliaWxpdHkoYS5kYXRhVHlwZSwgb3V0LmRhdGFUeXBlKTtcclxuXHRcdFx0b3V0Ll9pbmNSZWYoKTtcclxuXHRcdH1cclxuXHR9IGNhdGNoIChlKSB7XHJcblx0XHQvKiBSZXN0b3JlIHRoZSBwcmV2aW91cyBzdGF0ZSAqL1xyXG5cdFx0YS5faWQgPSBpZEE7XHJcblx0XHRhLl9pbmNSZWYoKTtcclxuXHRcdHRocm93IGU7XHJcblx0fVxyXG5cclxuXHR2YXIgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KCk7XHJcblx0cmVxdWVzdC5pZCA9IGFsbG9jYXRvci5uZXdNZXNzYWdlSWQoKTtcclxuXHRyZXF1ZXN0LnR5cGUgPSBSZXF1ZXN0LlR5cGUuQVhJU19SRURVQ1RJT05fT1BFUkFUSU9OO1xyXG5cdHZhciBheGlzUmVkdWN0aW9uUmVxdWVzdCA9IG5ldyBBeGlzUmVkdWN0aW9uUmVxdWVzdCgpO1xyXG5cdGF4aXNSZWR1Y3Rpb25SZXF1ZXN0LnR5cGUgPSBvcGVyYXRpb247XHJcblx0YXhpc1JlZHVjdGlvblJlcXVlc3QuaWRBID0gKHJlbGVhc2VJZEEgPyAtaWRBIDogaWRBKTtcclxuXHRheGlzUmVkdWN0aW9uUmVxdWVzdC5heGlzID0gYXhpcztcclxuXHRheGlzUmVkdWN0aW9uUmVxdWVzdC5pZE91dCA9IG91dC5faWQ7XHJcblx0cmVxdWVzdC5heGlzUmVkdWN0aW9uUmVxdWVzdCA9IGF4aXNSZWR1Y3Rpb25SZXF1ZXN0O1xyXG5cdGNvbnRleHQuX3Bvc3RNZXNzYWdlKHJlcXVlc3QuZW5jb2RlQUIoKSk7XHJcblxyXG5cdGEuX3RyeUludmFsaWRhdGUoKTtcclxuXHRyZXR1cm4gb3V0O1xyXG59O1xyXG5cclxudmFyIGRvdEFyaXRoT3AgPSBmdW5jdGlvbihhLCBiLCBvdXQsIGNvbnRleHQpIHtcclxuXHR1dGlsLmNoZWNrTkRBcnJheShhLCBcImFcIik7XHJcblx0dXRpbC5jaGVja05EQXJyYXkoYiwgXCJiXCIpO1xyXG5cdHV0aWwuY2hlY2tEYXRhVHlwZXNDb21wYXRpYmlsaXR5KGEuZGF0YVR5cGUsIGIuZGF0YVR5cGUpO1xyXG5cdHZhciBpZEEgPSBhLl9pZDtcclxuXHR2YXIgcmVsZWFzZUlkQSA9ICFhLl9kZWNSZWYoKTtcclxuXHRpZiAocmVsZWFzZUlkQSkge1xyXG5cdFx0YS5faWQgPSAwO1xyXG5cdH1cclxuXHR2YXIgaWRCID0gYi5faWQ7XHJcblx0dmFyIHJlbGVhc2VJZEIgPSAhYi5fZGVjUmVmKCk7XHJcblx0aWYgKHJlbGVhc2VJZEIpIHtcclxuXHRcdGIuX2lkID0gMDtcclxuXHR9XHJcblx0dHJ5IHtcclxuXHRcdGlmICh0eXBlb2Ygb3V0ID09PSBcInVuZGVmaW5lZFwiKSB7XHJcblx0XHRcdHZhciBzaGFwZUEgPSBhLnNoYXBlO1xyXG5cdFx0XHR2YXIgc2hhcGVCID0gYi5zaGFwZTtcclxuXHRcdFx0dmFyIGF4aXNBID0gTWF0aC5tYXgoc2hhcGVBLmxlbmd0aCAtIDEsIDApO1xyXG5cdFx0XHR2YXIgYXhpc0IgPSBNYXRoLm1heChzaGFwZUIubGVuZ3RoIC0gMiwgMCk7XHJcblx0XHRcdGlmIChzaGFwZUFbYXhpc0FdICE9IHNoYXBlQltheGlzQl0pIHtcclxuXHRcdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKFwiTWlzbWF0Y2ggaW4gcmVkdWN0aW9uIGRpbWVuc2lvbnNcIik7XHJcblx0XHRcdH1cclxuXHRcdFx0dmFyIHNoYXBlT3V0ID0gW107XHJcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYXhpc0E7IGkrKykge1xyXG5cdFx0XHRcdHNoYXBlT3V0LnB1c2goc2hhcGVBW2ldKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAoc2hhcGVCLmxlbmd0aCA+IDEpIHtcclxuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGF4aXNCOyBpKyspIHtcclxuXHRcdFx0XHRcdHNoYXBlT3V0LnB1c2goc2hhcGVCW2ldKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0c2hhcGVPdXQucHVzaChzaGFwZUJbc2hhcGVCLmxlbmd0aCAtIDFdKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRvdXQgPSBuZXcgTkRBcnJheShzaGFwZU91dCwgYS5kYXRhVHlwZSwgY29udGV4dCk7XHJcblx0XHRcdG91dC5faWQgPSBhbGxvY2F0b3IubmV3QXJyYXlJZCgpO1xyXG5cdFx0fSBlbHNlIGlmIChvdXQgaW5zdGFuY2VvZiBOREFycmF5KSB7XHJcblx0XHRcdHV0aWwuY2hlY2tOREFycmF5KG91dCwgXCJvdXRcIik7XHJcblx0XHRcdHV0aWwuY2hlY2tEYXRhVHlwZXNDb21wYXRpYmlsaXR5KGEuZGF0YVR5cGUsIG91dC5kYXRhVHlwZSk7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZFwiKTtcclxuXHRcdH1cclxuXHR9IGNhdGNoIChlKSB7XHJcblx0XHQvKiBSZXN0b3JlIHRoZSBwcmV2aW91cyBzdGF0ZSAqL1xyXG5cdFx0YS5faWQgPSBpZEE7XHJcblx0XHRhLl9pbmNSZWYoKTtcclxuXHRcdGIuX2lkID0gaWRCO1xyXG5cdFx0Yi5faW5jUmVmKCk7XHJcblx0XHR0aHJvdyBlO1xyXG5cdH1cclxuXHJcblx0dmFyIHJlcXVlc3QgPSBuZXcgUmVxdWVzdCgpO1xyXG5cdHJlcXVlc3QuaWQgPSBhbGxvY2F0b3IubmV3TWVzc2FnZUlkKCk7XHJcblx0cmVxdWVzdC50eXBlID0gUmVxdWVzdC5UeXBlLkRPVF9PUEVSQVRJT047XHJcblx0dmFyIGRvdE9wZXJhdGlvblJlcXVlc3QgPSBuZXcgRG90T3BlcmF0aW9uUmVxdWVzdCgpO1xyXG5cdGRvdE9wZXJhdGlvblJlcXVlc3QuaWRBID0gKHJlbGVhc2VJZEEgPyAtaWRBIDogaWRBKTtcclxuXHRkb3RPcGVyYXRpb25SZXF1ZXN0LmlkQiA9IChyZWxlYXNlSWRCID8gLWlkQiA6IGlkQik7XHJcblx0ZG90T3BlcmF0aW9uUmVxdWVzdC5pZE91dCA9IG91dC5faWQ7XHJcblx0cmVxdWVzdC5kb3RPcGVyYXRpb25SZXF1ZXN0ID0gZG90T3BlcmF0aW9uUmVxdWVzdDtcclxuXHRjb250ZXh0Ll9wb3N0TWVzc2FnZShyZXF1ZXN0LmVuY29kZUFCKCkpO1xyXG5cclxuXHRhLl90cnlJbnZhbGlkYXRlKCk7XHJcblx0Yi5fdHJ5SW52YWxpZGF0ZSgpO1xyXG5cdHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG5QQkNvbnRleHQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKGEsIGIsIG91dCkge1xyXG5cdHJldHVybiBiaW5hcnlBcml0aE9wKGEsIGIsIG91dCwgdGhpcyxcclxuXHRcdEJpbmFyeU9wZXJhdGlvblJlcXVlc3QuVHlwZS5BREQsXHJcblx0XHRCaW5hcnlDb25zdE9wZXJhdGlvblJlcXVlc3QuVHlwZS5BRERDLFxyXG5cdFx0QmluYXJ5Q29uc3RPcGVyYXRpb25SZXF1ZXN0LlR5cGUuQUREQyk7XHJcbn07XHJcblxyXG5QQkNvbnRleHQucHJvdG90eXBlLnN1YiA9IGZ1bmN0aW9uKGEsIGIsIG91dCkge1xyXG5cdHJldHVybiBiaW5hcnlBcml0aE9wKGEsIGIsIG91dCwgdGhpcyxcclxuXHRcdEJpbmFyeU9wZXJhdGlvblJlcXVlc3QuVHlwZS5TVUIsXHJcblx0XHRCaW5hcnlDb25zdE9wZXJhdGlvblJlcXVlc3QuVHlwZS5TVUJDLFxyXG5cdFx0QmluYXJ5Q29uc3RPcGVyYXRpb25SZXF1ZXN0LlR5cGUuU1VCUkMpO1xyXG59O1xyXG5cclxuUEJDb250ZXh0LnByb3RvdHlwZS5tdWwgPSBmdW5jdGlvbihhLCBiLCBvdXQpIHtcclxuXHRyZXR1cm4gYmluYXJ5QXJpdGhPcChhLCBiLCBvdXQsIHRoaXMsXHJcblx0XHRCaW5hcnlPcGVyYXRpb25SZXF1ZXN0LlR5cGUuTVVMLFxyXG5cdFx0QmluYXJ5Q29uc3RPcGVyYXRpb25SZXF1ZXN0LlR5cGUuTVVMQyxcclxuXHRcdEJpbmFyeUNvbnN0T3BlcmF0aW9uUmVxdWVzdC5UeXBlLk1VTEMpO1xyXG59O1xyXG5cclxuUEJDb250ZXh0LnByb3RvdHlwZS5kaXYgPSBmdW5jdGlvbihhLCBiLCBvdXQpIHtcclxuXHRyZXR1cm4gYmluYXJ5QXJpdGhPcChhLCBiLCBvdXQsIHRoaXMsXHJcblx0XHRCaW5hcnlPcGVyYXRpb25SZXF1ZXN0LlR5cGUuRElWLFxyXG5cdFx0QmluYXJ5Q29uc3RPcGVyYXRpb25SZXF1ZXN0LlR5cGUuRElWQyxcclxuXHRcdEJpbmFyeUNvbnN0T3BlcmF0aW9uUmVxdWVzdC5UeXBlLkRJVlJDKTtcclxufTtcclxuXHJcblBCQ29udGV4dC5wcm90b3R5cGUubmVnID0gZnVuY3Rpb24oYSwgb3V0KSB7XHJcblx0cmV0dXJuIHVuYXJ5QXJpdGhPcChhLCBvdXQsIHRoaXMsXHJcblx0XHRVbmFyeU9wZXJhdGlvblJlcXVlc3QuVHlwZS5ORUcpO1xyXG59O1xyXG5cclxuUEJDb250ZXh0LnByb3RvdHlwZS5hYnMgPSBmdW5jdGlvbihhLCBvdXQpIHtcclxuXHRyZXR1cm4gdW5hcnlBcml0aE9wKGEsIG91dCwgdGhpcyxcclxuXHRcdFVuYXJ5T3BlcmF0aW9uUmVxdWVzdC5UeXBlLkFCUyk7XHJcbn07XHJcblxyXG5QQkNvbnRleHQucHJvdG90eXBlLmV4cCA9IGZ1bmN0aW9uKGEsIG91dCkge1xyXG5cdHJldHVybiB1bmFyeUFyaXRoT3AoYSwgb3V0LCB0aGlzLFxyXG5cdFx0VW5hcnlPcGVyYXRpb25SZXF1ZXN0LlR5cGUuRVhQKTtcclxufTtcclxuXHJcblBCQ29udGV4dC5wcm90b3R5cGUubG9nID0gZnVuY3Rpb24oYSwgb3V0KSB7XHJcblx0cmV0dXJuIHVuYXJ5QXJpdGhPcChhLCBvdXQsIHRoaXMsXHJcblx0XHRVbmFyeU9wZXJhdGlvblJlcXVlc3QuVHlwZS5MT0cpO1xyXG59O1xyXG5cclxuUEJDb250ZXh0LnByb3RvdHlwZS5zcXJ0ID0gZnVuY3Rpb24oYSwgb3V0KSB7XHJcblx0cmV0dXJuIHVuYXJ5QXJpdGhPcChhLCBvdXQsIHRoaXMsXHJcblx0XHRVbmFyeU9wZXJhdGlvblJlcXVlc3QuVHlwZS5TUVJUKTtcclxufTtcclxuXHJcblBCQ29udGV4dC5wcm90b3R5cGUuc3F1YXJlID0gZnVuY3Rpb24oYSwgb3V0KSB7XHJcblx0cmV0dXJuIHVuYXJ5QXJpdGhPcChhLCBvdXQsIHRoaXMsXHJcblx0XHRVbmFyeU9wZXJhdGlvblJlcXVlc3QuVHlwZS5TUVVBUkUpO1xyXG59O1xyXG5cclxuUEJDb250ZXh0LnByb3RvdHlwZS5taW4gPSBmdW5jdGlvbihhLCBheGlzKSB7XHJcblx0aWYgKHR5cGVvZiBheGlzID09PSBcInVuZGVmaW5lZFwiKSB7XHJcblx0XHRyZXR1cm4gcmVkdWNlQXJpdGhPcChhLCB1bmRlZmluZWQsIHRoaXMsXHJcblx0XHRcdFJlZHVjdGlvblJlcXVlc3QuVHlwZS5NSU4pO1xyXG5cdH0gZWxzZSBpZiAodXRpbC5pc0ludChheGlzKSkge1xyXG5cdFx0cmV0dXJuIGF4aXNSZWR1Y2VBcml0aE9wKGEsIGF4aXMsIHVuZGVmaW5lZCwgdGhpcyxcclxuXHRcdFx0QXhpc1JlZHVjdGlvblJlcXVlc3QuVHlwZS5NSU4pO1xyXG5cdH0gZWxzZSB7XHJcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5zdXBwb3J0ZWQgYXhpcyB0eXBlXCIpO1xyXG5cdH1cclxufTtcclxuXHJcblBCQ29udGV4dC5wcm90b3R5cGUubWF4ID0gZnVuY3Rpb24oYSwgYXhpcykge1xyXG5cdGlmICh0eXBlb2YgYXhpcyA9PT0gXCJ1bmRlZmluZWRcIikge1xyXG5cdFx0cmV0dXJuIHJlZHVjZUFyaXRoT3AoYSwgdW5kZWZpbmVkLCB0aGlzLFxyXG5cdFx0XHRSZWR1Y3Rpb25SZXF1ZXN0LlR5cGUuTUFYKTtcclxuXHR9IGVsc2UgaWYgKHV0aWwuaXNJbnQoYXhpcykpIHtcclxuXHRcdHJldHVybiBheGlzUmVkdWNlQXJpdGhPcChhLCBheGlzLCB1bmRlZmluZWQsIHRoaXMsXHJcblx0XHRcdEF4aXNSZWR1Y3Rpb25SZXF1ZXN0LlR5cGUuTUFYKTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihcIlVuc3VwcG9ydGVkIGF4aXMgdHlwZVwiKTtcclxuXHR9XHJcbn07XHJcblxyXG5QQkNvbnRleHQucHJvdG90eXBlLnN1bSA9IGZ1bmN0aW9uKGEsIGF4aXMpIHtcclxuXHRpZiAodHlwZW9mIGF4aXMgPT09IFwidW5kZWZpbmVkXCIpIHtcclxuXHRcdHJldHVybiByZWR1Y2VBcml0aE9wKGEsIHVuZGVmaW5lZCwgdGhpcyxcclxuXHRcdFx0UmVkdWN0aW9uUmVxdWVzdC5UeXBlLlNVTSk7XHJcblx0fSBlbHNlIGlmICh1dGlsLmlzSW50KGF4aXMpKSB7XHJcblx0XHRyZXR1cm4gYXhpc1JlZHVjZUFyaXRoT3AoYSwgYXhpcywgdW5kZWZpbmVkLCB0aGlzLFxyXG5cdFx0XHRBeGlzUmVkdWN0aW9uUmVxdWVzdC5UeXBlLlNVTSk7XHJcblx0fSBlbHNlIHtcclxuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoXCJVbnN1cHBvcnRlZCBheGlzIHR5cGVcIik7XHJcblx0fVxyXG59O1xyXG5cclxuUEJDb250ZXh0LnByb3RvdHlwZS5kb3QgPSBmdW5jdGlvbihhLCBiLCBvdXQpIHtcclxuXHRyZXR1cm4gZG90QXJpdGhPcChhLCBiLCBvdXQsIHRoaXMpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBQQkNvbnRleHQ7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxudmFyIFBCQ29udGV4dCA9IHJlcXVpcmUoXCIuL1BCQ29udGV4dFwiKTtcclxuXHJcbmZ1bmN0aW9uIFBOYUNsQ29udGV4dChvcHRpb25zLCBjYWxsYmFjaykge1xyXG5cdHZhciBzZWxmID0gdGhpcztcclxuXHR0aGlzLl9wbmFjbE9iamVjdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJvYmplY3RcIik7XHJcblx0dGhpcy5fcG5hY2xPYmplY3Qud2lkdGggPSAwO1xyXG5cdHRoaXMuX3BuYWNsT2JqZWN0LmhlaWdodCA9IDA7XHJcblx0dGhpcy5fcG5hY2xPYmplY3QuZGF0YSA9IFBOYUNsQ29udGV4dC5nZXRNYW5pZmVzdFVSTChvcHRpb25zLmJhc2VVcmwpO1xyXG5cdHRoaXMuX3BuYWNsT2JqZWN0LnR5cGUgPSBcImFwcGxpY2F0aW9uL3gtcG5hY2xcIjtcclxuXHR0aGlzLl9wbmFjbE9iamVjdC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBmdW5jdGlvbihlKSB7XHJcblx0XHRzZWxmLl9tZXNzYWdpbmdDb250ZXh0Ll9vbk1lc3NhZ2UoZSk7XHJcblx0fSwgdHJ1ZSk7XHJcblx0dGhpcy5fbWVzc2FnaW5nQ29udGV4dCA9IG5ldyBQQkNvbnRleHQob3B0aW9ucywgZnVuY3Rpb24obWVzc2FnZSkge1xyXG5cdFx0c2VsZi5fcG5hY2xPYmplY3QucG9zdE1lc3NhZ2UobWVzc2FnZSk7XHJcblx0fSwgY2FsbGJhY2spO1xyXG5cdGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5fcG5hY2xPYmplY3QpO1xyXG59XHJcblxyXG5QTmFDbENvbnRleHQuaXNTdXBwb3J0ZWQgPSBmdW5jdGlvbigpIHtcclxuXHR0cnkge1xyXG5cdFx0cmV0dXJuICh0eXBlb2YgbmF2aWdhdG9yLm1pbWVUeXBlc1tcImFwcGxpY2F0aW9uL3gtcG5hY2xcIl0pICE9PSBcInVuZGVmaW5lZFwiO1xyXG5cdH0gY2F0Y2ggKGUpIHtcclxuXHR9XHJcblx0cmV0dXJuIGZhbHNlO1xyXG59O1xyXG5cclxuUE5hQ2xDb250ZXh0LmdldE1hbmlmZXN0VVJMID0gZnVuY3Rpb24oYmFzZVVybCkge1xyXG5cdGlmIChiYXNlVXJsKSB7XHJcblx0XHRyZXR1cm4gYmFzZVVybCArIFwiZnVyaW91cy5ubWZcIjtcclxuXHR9IGVsc2Uge1xyXG5cdFx0cmV0dXJuIFwiZnVyaW91cy5ubWZcIjtcclxuXHR9XHJcbn07XHJcblxyXG5QTmFDbENvbnRleHQucHJvdG90eXBlLmVtcHR5ID0gZnVuY3Rpb24oc2hhcGUsIGRhdGFUeXBlKSB7XHJcblx0cmV0dXJuIHRoaXMuX21lc3NhZ2luZ0NvbnRleHQuZW1wdHkoc2hhcGUsIGRhdGFUeXBlKTtcclxufTtcclxuXHJcblBOYUNsQ29udGV4dC5wcm90b3R5cGUuemVyb3MgPSBmdW5jdGlvbihzaGFwZSwgZGF0YVR5cGUpIHtcclxuXHRyZXR1cm4gdGhpcy5fbWVzc2FnaW5nQ29udGV4dC56ZXJvcyhzaGFwZSwgZGF0YVR5cGUpO1xyXG59O1xyXG5cclxuUE5hQ2xDb250ZXh0LnByb3RvdHlwZS5vbmVzID0gZnVuY3Rpb24oc2hhcGUsIGRhdGFUeXBlKSB7XHJcblx0cmV0dXJuIHRoaXMuX21lc3NhZ2luZ0NvbnRleHQub25lcyhzaGFwZSwgZGF0YVR5cGUpO1xyXG59O1xyXG5cclxuUE5hQ2xDb250ZXh0LnByb3RvdHlwZS5hcnJheSA9IGZ1bmN0aW9uKGRhdGEsIGRhdGFUeXBlKSB7XHJcblx0cmV0dXJuIHRoaXMuX21lc3NhZ2luZ0NvbnRleHQuYXJyYXkoZGF0YSwgZGF0YVR5cGUpO1xyXG59O1xyXG5cclxuUE5hQ2xDb250ZXh0LnByb3RvdHlwZS5saW5zcGFjZSA9IGZ1bmN0aW9uKHN0YXJ0LCBzdG9wLCBzYW1wbGVzLCBjbG9zZWQpIHtcclxuXHRyZXR1cm4gdGhpcy5fbWVzc2FnaW5nQ29udGV4dC5saW5zcGFjZShzdGFydCwgc3RvcCwgc2FtcGxlcywgY2xvc2VkKTtcclxufTtcclxuXHJcblBOYUNsQ29udGV4dC5wcm90b3R5cGUucmVzaGFwZSA9IGZ1bmN0aW9uKGEsIHNoYXBlKSB7XHJcblx0cmV0dXJuIHRoaXMuX21lc3NhZ2luZ0NvbnRleHQucmVzaGFwZShhLCBzaGFwZSk7XHJcbn07XHJcblxyXG5QTmFDbENvbnRleHQucHJvdG90eXBlLnJlcGVhdCA9IGZ1bmN0aW9uKGEsIHJlcGVhdHMsIGF4aXMsIG91dCkge1xyXG5cdHJldHVybiB0aGlzLl9tZXNzYWdpbmdDb250ZXh0LnJlcGVhdChhLCByZXBlYXRzLCBheGlzLCBvdXQpO1xyXG59O1xyXG5cclxuUE5hQ2xDb250ZXh0LnByb3RvdHlwZS5faW52YWxpZGF0ZSA9IGZ1bmN0aW9uKGFycmF5KSB7XHJcblx0cmV0dXJuIHRoaXMuX21lc3NhZ2luZ0NvbnRleHQuX2ludmFsaWRhdGUoYXJyYXkpO1xyXG59O1xyXG5cclxuUE5hQ2xDb250ZXh0LnByb3RvdHlwZS5mZXRjaCA9IGZ1bmN0aW9uKCkge1xyXG5cdHRoaXMuX21lc3NhZ2luZ0NvbnRleHQuZmV0Y2guYXBwbHkodGhpcy5fbWVzc2FnaW5nQ29udGV4dCwgYXJndW1lbnRzKTtcclxufTtcclxuXHJcblBOYUNsQ29udGV4dC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oKSB7XHJcblx0dGhpcy5fbWVzc2FnaW5nQ29udGV4dC5nZXQuYXBwbHkodGhpcy5fbWVzc2FnaW5nQ29udGV4dCwgYXJndW1lbnRzKTtcclxufTtcclxuXHJcblBOYUNsQ29udGV4dC5wcm90b3R5cGUuaW5mbyA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XHJcblx0dGhpcy5fbWVzc2FnaW5nQ29udGV4dC5pbmZvKGNhbGxiYWNrKTtcclxufTtcclxuXHJcblBOYUNsQ29udGV4dC5wcm90b3R5cGUuYmFycmllciA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XHJcblx0dGhpcy5fbWVzc2FnaW5nQ29udGV4dC5iYXJyaWVyKGNhbGxiYWNrKTtcclxufTtcclxuXHJcblBOYUNsQ29udGV4dC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24oYSwgYiwgb3V0KSB7XHJcblx0cmV0dXJuIHRoaXMuX21lc3NhZ2luZ0NvbnRleHQuYWRkKGEsIGIsIG91dCk7XHJcbn07XHJcblxyXG5QTmFDbENvbnRleHQucHJvdG90eXBlLnN1YiA9IGZ1bmN0aW9uKGEsIGIsIG91dCkge1xyXG5cdHJldHVybiB0aGlzLl9tZXNzYWdpbmdDb250ZXh0LnN1YihhLCBiLCBvdXQpO1xyXG59O1xyXG5cclxuUE5hQ2xDb250ZXh0LnByb3RvdHlwZS5tdWwgPSBmdW5jdGlvbihhLCBiLCBvdXQpIHtcclxuXHRyZXR1cm4gdGhpcy5fbWVzc2FnaW5nQ29udGV4dC5tdWwoYSwgYiwgb3V0KTtcclxufTtcclxuXHJcblBOYUNsQ29udGV4dC5wcm90b3R5cGUuZGl2ID0gZnVuY3Rpb24oYSwgYiwgb3V0KSB7XHJcblx0cmV0dXJuIHRoaXMuX21lc3NhZ2luZ0NvbnRleHQuZGl2KGEsIGIsIG91dCk7XHJcbn07XHJcblxyXG5QTmFDbENvbnRleHQucHJvdG90eXBlLm5lZyA9IGZ1bmN0aW9uKGEsIG91dCkge1xyXG5cdHJldHVybiB0aGlzLl9tZXNzYWdpbmdDb250ZXh0Lm5lZyhhLCBvdXQpO1xyXG59O1xyXG5cclxuUE5hQ2xDb250ZXh0LnByb3RvdHlwZS5hYnMgPSBmdW5jdGlvbihhLCBvdXQpIHtcclxuXHRyZXR1cm4gdGhpcy5fbWVzc2FnaW5nQ29udGV4dC5hYnMoYSwgb3V0KTtcclxufTtcclxuXHJcblBOYUNsQ29udGV4dC5wcm90b3R5cGUuZXhwID0gZnVuY3Rpb24oYSwgb3V0KSB7XHJcblx0cmV0dXJuIHRoaXMuX21lc3NhZ2luZ0NvbnRleHQuZXhwKGEsIG91dCk7XHJcbn07XHJcblxyXG5QTmFDbENvbnRleHQucHJvdG90eXBlLmxvZyA9IGZ1bmN0aW9uKGEsIG91dCkge1xyXG5cdHJldHVybiB0aGlzLl9tZXNzYWdpbmdDb250ZXh0LmxvZyhhLCBvdXQpO1xyXG59O1xyXG5cclxuUE5hQ2xDb250ZXh0LnByb3RvdHlwZS5zcXJ0ID0gZnVuY3Rpb24oYSwgb3V0KSB7XHJcblx0cmV0dXJuIHRoaXMuX21lc3NhZ2luZ0NvbnRleHQuc3FydChhLCBvdXQpO1xyXG59O1xyXG5cclxuUE5hQ2xDb250ZXh0LnByb3RvdHlwZS5zcXVhcmUgPSBmdW5jdGlvbihhLCBvdXQpIHtcclxuXHRyZXR1cm4gdGhpcy5fbWVzc2FnaW5nQ29udGV4dC5zcXVhcmUoYSwgb3V0KTtcclxufTtcclxuXHJcblBOYUNsQ29udGV4dC5wcm90b3R5cGUubWluID0gZnVuY3Rpb24oYSwgYXhpcykge1xyXG5cdHJldHVybiB0aGlzLl9tZXNzYWdpbmdDb250ZXh0Lm1pbihhLCBheGlzKTtcclxufTtcclxuXHJcblBOYUNsQ29udGV4dC5wcm90b3R5cGUubWF4ID0gZnVuY3Rpb24oYSwgYXhpcykge1xyXG5cdHJldHVybiB0aGlzLl9tZXNzYWdpbmdDb250ZXh0Lm1heChhLCBheGlzKTtcclxufTtcclxuXHJcblBOYUNsQ29udGV4dC5wcm90b3R5cGUuc3VtID0gZnVuY3Rpb24oYSwgYXhpcykge1xyXG5cdHJldHVybiB0aGlzLl9tZXNzYWdpbmdDb250ZXh0LnN1bShhLCBheGlzKTtcclxufTtcclxuXHJcblBOYUNsQ29udGV4dC5wcm90b3R5cGUuZG90ID0gZnVuY3Rpb24oYSwgYiwgb3V0KSB7XHJcblx0cmV0dXJuIHRoaXMuX21lc3NhZ2luZ0NvbnRleHQuZG90KGEsIGIsIG91dCk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFBOYUNsQ29udGV4dDtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG52YXIgbWVzc2FnZUlkID0gMTtcclxudmFyIGFycmF5SWQgPSAxO1xyXG5cclxuZXhwb3J0cy5uZXdNZXNzYWdlSWQgPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgaWQgPSBtZXNzYWdlSWQ7XHJcblx0bWVzc2FnZUlkID0gKG1lc3NhZ2VJZCsxKXwwO1xyXG5cdHJldHVybiBpZDtcclxufTtcclxuXHJcbmV4cG9ydHMubmV3QXJyYXlJZCA9IGZ1bmN0aW9uICgpIHtcclxuXHR2YXIgaWQgPSBhcnJheUlkO1xyXG5cdGFycmF5SWQgPSAoYXJyYXlJZCsxKXwwO1xyXG5cdHJldHVybiBpZDtcclxufTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4vKipcclxuICogUHJvdmlkZXMgaW5mb3JtYXRpb24gYW5kIHN1cHBvcnQgZnVuY3Rpb25zXHJcbiAqXHJcbiAqIEBjbGFzcyBmdXJpb3VzXHJcbiAqL1xyXG5cclxudmFyIERhdGFUeXBlID0gcmVxdWlyZShcIi4vRGF0YVR5cGVcIik7XHJcbnZhciBKU0NvbnRleHQgPSByZXF1aXJlKFwiLi9qcy9KU0NvbnRleHRcIik7XHJcbnZhciBXZWJXb3JrZXJDb250ZXh0ID0gcmVxdWlyZShcIi4vanMvV2ViV29ya2VyQ29udGV4dFwiKTtcclxudmFyIFBOYUNsQ29udGV4dCA9IHJlcXVpcmUoXCIuL1BOYUNsQ29udGV4dFwiKTtcclxudmFyIFdlYkNMQ29udGV4dCA9IHJlcXVpcmUoXCIuL3dlYmNsL1dlYkNMQ29udGV4dFwiKTtcclxuXHJcbnZhciBjdXJyZW50U2NyaXB0VXJpID0gbnVsbDtcclxudHJ5IHtcclxuXHRjdXJyZW50U2NyaXB0VXJpID0gZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmM7XHJcbn0gY2F0Y2ggKGUpIHtcclxuXHR0cnkge1xyXG5cdFx0dmFyIHNjcmlwdHMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInNjcmlwdFwiKTtcclxuXHRcdGN1cnJlbnRTY3JpcHRVcmkgPSBzY3JpcHRzW3NjcmlwdHMubGVuZ3RoIC0gMV0uc3JjO1xyXG5cdH0gY2F0Y2ggKGUpIHtcclxuXHR9XHJcbn1cclxudmFyIGN1cnJlbnRTY3JpcHREaXIgPSBudWxsO1xyXG5pZiAoY3VycmVudFNjcmlwdFVyaSAhPT0gbnVsbCkge1xyXG5cdHZhciBzZXBhcmF0b3JQb3MgPSBjdXJyZW50U2NyaXB0VXJpLmxhc3RJbmRleE9mKFwiL1wiKTtcclxuXHR2YXIgY3VycmVudFNjcmlwdERpciA9IGN1cnJlbnRTY3JpcHRVcmkuc3Vic3RyKDAsIHNlcGFyYXRvclBvcyArIDEpO1xyXG59XHJcblxyXG4vKipcclxuICogSW5pdGlhbGl6ZXMgYSBjb21wdXRhdGlvbmFsIGNvbnRleHQuXHJcbiAqXHJcbiAqIEBzdGF0aWNcclxuICogQG1ldGhvZCBpbml0XHJcbiAqIEBhc3luY1xyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gW2JhY2tlbmRdIC0gQSBzdHJpbmcgaWRlbnRpZmllciBmb3IgdGhlIGJhY2tlbmQgdG8gdXNlLiBUaGUgZm9sbG93aW5nIHZhbHVlcyBhcmUgc3VwcG9ydGVkOlxyXG4gKlxyXG4gKiAgICAgPHRhYmxlPlxyXG4gKiAgICAgICAgIDx0cj5cclxuICogICAgICAgICAgICAgPHRoPkJhY2tlbmQgSWRlbnRpZmllcjwvdGg+XHJcbiAqICAgICAgICAgICAgIDx0aD5JbnRlcnByZXRhdGlvbjwvdGg+XHJcbiAqICAgICAgICAgPC90cj5cclxuICogICAgICAgICA8dHI+XHJcbiAqICAgICAgICAgICAgIDx0ZD5cImphdmFzY3JpcHRcIjwvdGQ+XHJcbiAqICAgICAgICAgICAgIDx0ZD5KYXZhU2NyaXB0IGJhY2tlbmQuIFdvcmtzIGluIGFsbCBicm93c2VycyBhbmQgTm9kZS5qcywgYnV0IGNhbiBub3QgZGVsaXZlciBvcHRpbWFsIHBlcmZvcm1hbmNlLjwvdGQ+XHJcbiAqICAgICAgICAgPC90cj5cclxuICogICAgICAgICA8dHI+XHJcbiAqICAgICAgICAgICAgIDx0ZD5cInBuYWNsXCI8L3RkPlxyXG4gKiAgICAgICAgICAgICA8dGQ+UG9ydGFibGUgTmF0aXZlIENsaWVudCAoUE5hQ2wpIGJhY2tlbmQuIFdvcmtzIGluIENocm9taXVtLWJhc2VkIGJyb3dzZXJzLiBDYW4gYWNjZWxlcmF0ZSBjb21wdXRhdGlvbnMgdGhyb3VnaCB0aGUgdXNlIG9mIGFkdmFuY2VkIENQVSBvcHRpbWl6YXRpb24gdGVjaG5vbG9naWVzLCBzdWNoIGFzIG11bHRpLXRocmVhZGluZyBhbmQgU0lNRCBpbnN0cnVjdGlvbnMuPC90ZD5cclxuICogICAgICAgICA8L3RyPlxyXG4gKiAgICAgICAgIDx0cj5cclxuICogICAgICAgICAgICAgPHRkPlwid2ViY2xcIjwvdGQ+XHJcbiAqICAgICAgICAgICAgIDx0ZD5XZWJDTCBiYWNrZW5kLiBXb3JrcyBpbiBicm93c2VycyBhbmQgTm9kZS5qcyB3aGVuIGEgV2ViQ0wgcGx1Z2luIGlzIGF2YWlsYWJsZS4gQ2FuIHVzZSBmdWxsIHBvd2VyIG9mIENQVXMgYW5kIEdQVXMgdG8gYWNjZWxlcmF0ZSBjb21wdXRhdGlvbnMuPC90ZD5cclxuICogICAgICAgICA8L3RyPlxyXG4gKiAgICAgPC90YWJsZT5cclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBCYWNrZW5kLXNwZWNpZmljIG9wdGlvbnMuXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gQSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aGVuIHRoZSBiYWNrZW5kIGZpbmlzaCBpbml0aWFsaXphdGlvbi5cclxuICogQHBhcmFtIHtDb250ZXh0fSBjYWxsYmFjay5jb250ZXh0IC0gQSByZWFkeSB0byB1c2UgY29tcHV0YXRpb25hbCBjb250ZXh0LlxyXG4gKi9cclxudmFyIGluaXQgPSBmdW5jdGlvbihiYWNrZW5kLCBvcHRpb25zLCBjYWxsYmFjaykge1xyXG5cdGlmICh0eXBlb2YgY2FsbGJhY2sgPT09IFwidW5kZWZpbmVkXCIpIHtcclxuXHRcdGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJ1bmRlZmluZWRcIikge1xyXG5cdFx0XHQvKiBDYWxsZWQgd2l0aCBvbmUgcGFyYW1ldGVyOiBjYWxsYmFjayAqL1xyXG5cdFx0XHRjYWxsYmFjayA9IGJhY2tlbmQ7XHJcblx0XHRcdG9wdGlvbnMgPSB1bmRlZmluZWQ7XHJcblx0XHRcdGJhY2tlbmQgPSB1bmRlZmluZWQ7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHQvKiBDYWxsZWQgd2l0aCB0d28gcGFyYW1ldGVyczogYmFja2VuZCBhbmQgY2FsbGJhY2sgKi9cclxuXHRcdFx0Y2FsbGJhY2sgPSBvcHRpb25zO1xyXG5cdFx0XHRvcHRpb25zID0gdW5kZWZpbmVkO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRpZiAodHlwZW9mIGJhY2tlbmQgPT09IFwidW5kZWZpbmVkXCIpIHtcclxuXHRcdGJhY2tlbmQgPSBnZXREZWZhdWx0QmFja2VuZCgpO1xyXG5cdH1cclxuXHRpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwidW5kZWZpbmVkXCIpIHtcclxuXHRcdG9wdGlvbnMgPSB7fTtcclxuXHR9XHJcblx0aWYgKGJhY2tlbmQgPT09IFwiamF2YXNjcmlwdFwiKSB7XHJcblx0XHR2YXIgYXN5bmMgPSBvcHRpb25zLmFzeW5jO1xyXG5cdFx0aWYgKHR5cGVvZiBhc3luYyA9PT0gXCJ1bmRlZmluZWRcIikge1xyXG5cdFx0XHRhc3luYyA9IFdlYldvcmtlckNvbnRleHQuaXNTdXBwb3J0ZWQoKTtcclxuXHRcdH1cclxuXHRcdGlmIChhc3luYykge1xyXG5cdFx0XHRvcHRpb25zLmJhc2VVcmwgPSBjdXJyZW50U2NyaXB0RGlyO1xyXG5cdFx0XHRyZXR1cm4gbmV3IFdlYldvcmtlckNvbnRleHQob3B0aW9ucywgY2FsbGJhY2spO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cmV0dXJuIG5ldyBKU0NvbnRleHQob3B0aW9ucywgY2FsbGJhY2spO1xyXG5cdFx0fVxyXG5cdH0gZWxzZSBpZiAoYmFja2VuZCA9PT0gXCJwbmFjbFwiKSB7XHJcblx0XHRvcHRpb25zLmJhc2VVcmwgPSBjdXJyZW50U2NyaXB0RGlyO1xyXG5cdFx0cmV0dXJuIG5ldyBQTmFDbENvbnRleHQob3B0aW9ucywgY2FsbGJhY2spO1xyXG5cdH0gZWxzZSBpZiAoYmFja2VuZCA9PT0gXCJ3ZWJjbFwiKSB7XHJcblx0XHRyZXR1cm4gbmV3IFdlYkNMQ29udGV4dChvcHRpb25zLCBjYWxsYmFjayk7XHJcblx0fSBlbHNlIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIGJhY2tlbmQ6IFwiICsgYmFja2VuZCk7XHJcblx0fVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIERldGVjdHMgdGhlIG9wdGltYWwgYmFja2VuZCBzdXBwb3J0ZWQgYnkgdGhlIGJyb3dzZXIgb3IgSmF2YVNjcmlwdCBlbmdpbmUuXHJcbiAqXHJcbiAqIEBzdGF0aWNcclxuICogQG1ldGhvZCBnZXREZWZhdWx0QmFja2VuZFxyXG4gKlxyXG4gKiBAcmV0dXJuIHtTdHJpbmd9IC0gRGVmYXVsdCBiYWNrZW5kIGlkZW50aWZpZXIgZnJvbSB0aGUgZm9sbG93aW5nIHRhYmxlOlxyXG4gKlxyXG4gKiAgICAgPHRhYmxlPlxyXG4gKiAgICAgICAgIDx0cj5cclxuICogICAgICAgICAgICAgPHRoPkJhY2tlbmQgSWRlbnRpZmllcjwvdGg+XHJcbiAqICAgICAgICAgICAgIDx0aD5JbnRlcnByZXRhdGlvbjwvdGg+XHJcbiAqICAgICAgICAgPC90cj5cclxuICogICAgICAgICA8dHI+XHJcbiAqICAgICAgICAgICAgIDx0ZD5cImphdmFzY3JpcHRcIjwvdGQ+XHJcbiAqICAgICAgICAgICAgIDx0ZD5KYXZhU2NyaXB0IGJhY2tlbmQuIFdvcmtzIGluIGFsbCBicm93c2VycyBhbmQgTm9kZS5qcywgYnV0IGNhbiBub3QgZGVsaXZlciBvcHRpbWFsIHBlcmZvcm1hbmNlLjwvdGQ+XHJcbiAqICAgICAgICAgPC90cj5cclxuICogICAgICAgICA8dHI+XHJcbiAqICAgICAgICAgICAgIDx0ZD5cImFzbWpzXCI8L3RkPlxyXG4gKiAgICAgICAgICAgICA8dGQ+QXNtLmpzIGJhY2tlbmQuIFdvcmtzIGluIEZpcmVmb3ggMjkgYW5kIGxhdGVyLiBDYW4gYWNjZWxlcmF0ZSBjb21wdXRhdGlvbnMgd2l0aCBhIGxpbWl0ZWQgdXNlIG9mIG5hdGl2ZSBDUFUgaW5zdHJ1Y3Rpb25zLjwvdGQ+XHJcbiAqICAgICAgICAgPC90cj5cclxuICogICAgICAgICA8dHI+XHJcbiAqICAgICAgICAgICAgIDx0ZD5cInBuYWNsXCI8L3RkPlxyXG4gKiAgICAgICAgICAgICA8dGQ+UG9ydGFibGUgTmF0aXZlIENsaWVudCAoUE5hQ2wpIGJhY2tlbmQuIFdvcmtzIGluIENocm9taXVtLWJhc2VkIGJyb3dzZXJzLiBDYW4gYWNjZWxlcmF0ZSBjb21wdXRhdGlvbnMgdGhyb3VnaCB0aGUgdXNlIG9mIGFkdmFuY2VkIENQVSBvcHRpbWl6YXRpb24gdGVjaG5vbG9naWVzLCBzdWNoIGFzIG11bHRpLXRocmVhZGluZyBhbmQgU0lNRCBpbnN0cnVjdGlvbnMuPC90ZD5cclxuICogICAgICAgICA8L3RyPlxyXG4gKiAgICAgICAgIDx0cj5cclxuICogICAgICAgICAgICAgPHRkPlwid2ViY2xcIjwvdGQ+XHJcbiAqICAgICAgICAgICAgIDx0ZD5XZWJDTCBiYWNrZW5kLiBXb3JrcyBpbiBicm93c2VycyBhbmQgTm9kZS5qcyB3aGVuIGEgV2ViQ0wgcGx1Z2luIGlzIGF2YWlsYWJsZS4gQ2FuIHVzZSBmdWxsIHBvd2VyIG9mIENQVXMgYW5kIEdQVXMgdG8gYWNjZWxlcmF0ZSBjb21wdXRhdGlvbnMuPC90ZD5cclxuICogICAgICAgICA8L3RyPlxyXG4gKiAgICAgPC90YWJsZT5cclxuICovXHJcbnZhciBnZXREZWZhdWx0QmFja2VuZCA9IGZ1bmN0aW9uKCkge1xyXG5cdGlmIChXZWJDTENvbnRleHQuaXNVc2FibGUoKSkge1xyXG5cdFx0cmV0dXJuIFwid2ViY2xcIjtcclxuXHR9IGVsc2UgaWYgKFBOYUNsQ29udGV4dC5pc1N1cHBvcnRlZCgpKSB7XHJcblx0XHRyZXR1cm4gXCJwbmFjbFwiO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRyZXR1cm4gXCJqYXZhc2NyaXB0XCI7XHJcblx0fVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIERldGVjdHMgd2hpY2ggYmFja2VuZHMgYXJlIHN1cHBvcnRlZCBieSB0aGUgc3lzdGVtLlxyXG4gKlxyXG4gKiBAc3RhdGljXHJcbiAqIEBtZXRob2QgZ2V0U3VwcG9ydGVkQmFja2VuZHNcclxuICpcclxuICogQHJldHVybiB7U3RyaW5nW119IC0gQW4gYXJyYXkgb2Ygc3VwcG9ydGVkIGJhY2tlbmQgaWRlbnRpZmllcnMgaW4gcHJpb3JpdHkgb3JkZXIgKHByaW9yaXRpemVkIGJhY2tlbmRzIGZpcnN0KS4gVGhlIGZvbGxvd2luZyBpZGVudGlmaWVycyBjb3VsZCBiZSBwcmVzZW50OlxyXG4gKlxyXG4gKiAgICAgPHRhYmxlPlxyXG4gKiAgICAgICAgIDx0cj5cclxuICogICAgICAgICAgICAgPHRoPkJhY2tlbmQgSWRlbnRpZmllcjwvdGg+XHJcbiAqICAgICAgICAgICAgIDx0aD5JbnRlcnByZXRhdGlvbjwvdGg+XHJcbiAqICAgICAgICAgPC90cj5cclxuICogICAgICAgICA8dHI+XHJcbiAqICAgICAgICAgICAgIDx0ZD5cImphdmFzY3JpcHRcIjwvdGQ+XHJcbiAqICAgICAgICAgICAgIDx0ZD5KYXZhU2NyaXB0IGJhY2tlbmQuIFdvcmtzIGluIGFsbCBicm93c2VycyBhbmQgTm9kZS5qcywgYnV0IGNhbiBub3QgZGVsaXZlciBvcHRpbWFsIHBlcmZvcm1hbmNlLjwvdGQ+XHJcbiAqICAgICAgICAgPC90cj5cclxuICogICAgICAgICA8dHI+XHJcbiAqICAgICAgICAgICAgIDx0ZD5cImFzbWpzXCI8L3RkPlxyXG4gKiAgICAgICAgICAgICA8dGQ+QXNtLmpzIGJhY2tlbmQuIFdvcmtzIGluIEZpcmVmb3ggMjkgYW5kIGxhdGVyLiBDYW4gYWNjZWxlcmF0ZSBjb21wdXRhdGlvbnMgd2l0aCBhIGxpbWl0ZWQgdXNlIG9mIG5hdGl2ZSBDUFUgaW5zdHJ1Y3Rpb25zLjwvdGQ+XHJcbiAqICAgICAgICAgPC90cj5cclxuICogICAgICAgICA8dHI+XHJcbiAqICAgICAgICAgICAgIDx0ZD5cInBuYWNsXCI8L3RkPlxyXG4gKiAgICAgICAgICAgICA8dGQ+UG9ydGFibGUgTmF0aXZlIENsaWVudCAoUE5hQ2wpIGJhY2tlbmQuIFdvcmtzIGluIENocm9taXVtLWJhc2VkIGJyb3dzZXJzLiBDYW4gYWNjZWxlcmF0ZSBjb21wdXRhdGlvbnMgdGhyb3VnaCB0aGUgdXNlIG9mIGFkdmFuY2VkIENQVSBvcHRpbWl6YXRpb24gdGVjaG5vbG9naWVzLCBzdWNoIGFzIG11bHRpLXRocmVhZGluZyBhbmQgU0lNRCBpbnN0cnVjdGlvbnMuPC90ZD5cclxuICogICAgICAgICA8L3RyPlxyXG4gKiAgICAgICAgIDx0cj5cclxuICogICAgICAgICAgICAgPHRkPlwid2ViY2xcIjwvdGQ+XHJcbiAqICAgICAgICAgICAgIDx0ZD5XZWJDTCBiYWNrZW5kLiBXb3JrcyBpbiBicm93c2VycyBhbmQgTm9kZS5qcyB3aGVuIGEgV2ViQ0wgcGx1Z2luIGlzIGF2YWlsYWJsZS4gQ2FuIHVzZSBmdWxsIHBvd2VyIG9mIENQVXMgYW5kIEdQVXMgdG8gYWNjZWxlcmF0ZSBjb21wdXRhdGlvbnMuPC90ZD5cclxuICogICAgICAgICA8L3RyPlxyXG4gKiAgICAgPC90YWJsZT5cclxuICovXHJcbnZhciBnZXRTdXBwb3J0ZWRCYWNrZW5kcyA9IGZ1bmN0aW9uKCkge1xyXG5cdHZhciBiYWNrZW5kcyA9IFtdO1xyXG5cdGlmIChXZWJDTENvbnRleHQuaXNVc2FibGUoKSkge1xyXG5cdFx0YmFja2VuZHMucHVzaChcIndlYmNsXCIpO1xyXG5cdH1cclxuXHRpZiAoUE5hQ2xDb250ZXh0LmlzU3VwcG9ydGVkKCkpIHtcclxuXHRcdGJhY2tlbmRzLnB1c2goXCJwbmFjbFwiKTtcclxuXHR9XHJcblx0aWYgKGhhc0ZlYXR1cmUoXCJhc20uanNcIikpIHtcclxuXHRcdGJhY2tlbmRzLnB1c2goXCJhc20uanNcIik7XHJcblx0fVxyXG5cdGJhY2tlbmRzLnB1c2goXCJqYXZhc2NyaXB0XCIpO1xyXG5cdHJldHVybiBiYWNrZW5kcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBRdWVyaWVzIHBvc3NpYmxlIGJhY2tlbmQgb3B0aW9ucyBhdmFpbGFibGUgb24gdGhpcyBwbGF0Zm9ybS5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGJhY2tlbmQgLSBuYW1lIG9mIHRoZSBiYWNrZW5kIHRvIHF1ZXJ5IG9wdGlvbnMgZm9yLlxyXG4gKlxyXG4gKiBAc3RhdGljXHJcbiAqIEBtZXRob2QgZ2V0QmFja2VuZE9wdGlvbnNcclxuICpcclxuICogQHJldHVybiB7T2JqZWN0fSAtIEFuIG9iamVjdCB0aGF0IGRlc2NyaWJlcyBhdmFpbGFibGUgb3B0aW9ucy5cclxuICogVGhlIG5hbWVzIG9mIG9iamVjdCdzIHByb3BlcnRpZXMgY29ycmVzcG9uZCB0byBiYWNrZW5kIG9wdGlvbiBuYW1lcy5cclxuICogT2JqZWN0J3MgcHJvcGVydGllcyBoYXZlIGFycmF5IHZhbHVlcyB3aXRoIHBvc3NpYmxlIG9wdGlvbiB2YWx1ZXMuXHJcbiAqIEJlbG93IGFyZSB0aGUgYmFja2VuZCBvcHRpb25zIGZvciB0aGUgYnVpbHQtaW4gYmFja2VuZHM6XHJcbiAqXHJcbiAqICAgICA8dGFibGU+XHJcbiAqICAgICAgICAgPGNhcHRpb24+T3B0aW9ucyBvZiBcImphdmFzY3JpcHRcIiBhbmQgXCJhc21qc1wiIGJhY2tlbmRzPC9jYXB0aW9uPlxyXG4gKiAgICAgICAgIDx0cj5cclxuICogICAgICAgICAgICAgPHRoPk9wdGlvbiBuYW1lPC90aD5cclxuICogICAgICAgICAgICAgPHRoPk9wdGlvbiB2YWx1ZXM8L3RoPlxyXG4gKiAgICAgICAgICAgICA8dGg+RGVmYXVsdCB2YWx1ZTwvdGg+XHJcbiAqICAgICAgICAgPC90cj5cclxuICogICAgICAgICA8dHI+XHJcbiAqICAgICAgICAgICAgIDx0ZD5cImFzeW5jXCI8L3RkPlxyXG4gKiAgICAgICAgICAgICA8dGQ+W3RydWUsIGZhbHNlXTwvdGQ+XHJcbiAqICAgICAgICAgICAgIDx0ZD50cnVlPC90ZD5cclxuICogICAgICAgICA8L3RyPlxyXG4gKiAgICAgPC90YWJsZT5cclxuICpcclxuICogICAgIDx0YWJsZT5cclxuICogICAgICAgICA8Y2FwdGlvbj5PcHRpb25zIG9mIFwicG5hY2xcIiBiYWNrZW5kPC9jYXB0aW9uPlxyXG4gKiAgICAgICAgIDx0cj5cclxuICogICAgICAgICAgICAgPHRoPk9wdGlvbiBuYW1lPC90aD5cclxuICogICAgICAgICAgICAgPHRoPk9wdGlvbiB2YWx1ZXM8L3RoPlxyXG4gKiAgICAgICAgICAgICA8dGg+RGVmYXVsdCB2YWx1ZTwvdGg+XHJcbiAqICAgICAgICAgPC90cj5cclxuICogICAgICAgICA8dHI+XHJcbiAqICAgICAgICAgICAgIDx0ZD5cIm1hbmlmZXN0XCI8L3RkPlxyXG4gKiAgICAgICAgICAgICA8dGQ+dW5kZWZpbmVkPC90ZD5cclxuICogICAgICAgICAgICAgPHRkPlVSTCBvZiBcImZ1cmlvdXMubm1mXCIgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkgYXMgXCJmdXJpb3VzLmpzXCIgbGlicmFyeTwvdGQ+XHJcbiAqICAgICAgICAgPC90cj5cclxuICogICAgIDwvdGFibGU+XHJcbiAqXHJcbiAqICAgICA8dGFibGU+XHJcbiAqICAgICAgICAgPGNhcHRpb24+T3B0aW9ucyBvZiBcIndlYmNsXCIgYmFja2VuZDwvY2FwdGlvbj5cclxuICogICAgICAgICA8dHI+XHJcbiAqICAgICAgICAgICAgIDx0aD5PcHRpb24gbmFtZTwvdGg+XHJcbiAqICAgICAgICAgICAgIDx0aD5PcHRpb24gdmFsdWVzPC90aD5cclxuICogICAgICAgICAgICAgPHRoPkRlZmF1bHQgdmFsdWU8L3RoPlxyXG4gKiAgICAgICAgIDwvdHI+XHJcbiAqICAgICAgICAgPHRyPlxyXG4gKiAgICAgICAgICAgICA8dGQ+XCJkZXZpY2VcIjwvdGQ+XHJcbiAqICAgICAgICAgICAgIDx0ZD5EZXBlbmRzIG9uIHRoZSBwbGF0Zm9ybTwvdGQ+XHJcbiAqICAgICAgICAgICAgIDx0ZD5EaXNjcmV0ZSBHUFUgZGV2aWNlLCBpZiBhdmFpbGFibGUuIE90aGVyd2lzZSBpbnRlZ3JhdGVkIEdQVSBkZXZpY2UsIGlmIGF2YWlsYWJsZS4gT3RoZXJ3aXNlIENQVSBkZXZpY2UuPC90ZD5cclxuICogICAgICAgICA8L3RyPlxyXG4gKiAgICAgPC90YWJsZT5cclxuICovXHJcbnZhciBnZXRCYWNrZW5kT3B0aW9ucyA9IGZ1bmN0aW9uKGJhY2tlbmQpIHtcclxuXHRpZiAoYmFja2VuZCA9PT0gXCJqYXZhc2NyaXB0XCIpIHtcclxuXHRcdGlmIChXZWJXb3JrZXJDb250ZXh0LmlzU3VwcG9ydGVkKCkpIHtcclxuXHRcdFx0cmV0dXJuIHtcclxuXHRcdFx0XHRcImFzeW5jXCI6IFt0cnVlLCBmYWxzZV1cclxuXHRcdFx0fTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHJldHVybiB7fTtcclxuXHRcdH1cclxuXHR9IGVsc2UgaWYgKGJhY2tlbmQgPT09IFwicG5hY2xcIikge1xyXG5cdFx0cmV0dXJuIHt9O1xyXG5cdH0gZWxzZSBpZiAoYmFja2VuZCA9PT0gXCJ3ZWJjbFwiKSB7XHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHRcImRldmljZVwiOiBXZWJDTENvbnRleHQuZ2V0QXZhaWxhYmxlRGV2aWNlcygpXHJcblx0XHR9O1xyXG5cdH0gZWxzZSB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBiYWNrZW5kOiBcIiArIGJhY2tlbmQpO1xyXG5cdH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBRdWVyaWVzIGRlZmF1bHQgYmFja2VuZCBvcHRpb25zIG9uIHRoaXMgcGxhdGZvcm0uXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBiYWNrZW5kIC0gbmFtZSBvZiB0aGUgYmFja2VuZCB0byBxdWVyeSBvcHRpb25zIGZvci5cclxuICpcclxuICogQHN0YXRpY1xyXG4gKiBAbWV0aG9kIGdldEJhY2tlbmRPcHRpb25zXHJcbiAqXHJcbiAqIEByZXR1cm4ge09iamVjdH0gLSBBbiBvYmplY3QgdGhhdCBkZXNjcmliZXMgYXZhaWxhYmxlIG9wdGlvbnMuXHJcbiAqIFRoZSBuYW1lcyBvZiBvYmplY3QncyBwcm9wZXJ0aWVzIGNvcnJlc3BvbmQgdG8gYmFja2VuZCBvcHRpb24gbmFtZXMuXHJcbiAqIFRoZSB2YWx1ZXMgb2Ygb2JqZWN0J3MgcHJvcGVydGllcyBjb3JyZXNwb25kIHRvIGRlZmF1bHQgb3B0aW9uIHZhbHVlcy5cclxuICovXHJcbnZhciBnZXREZWZhdWx0QmFja2VuZE9wdGlvbnMgPSBmdW5jdGlvbihiYWNrZW5kKSB7XHJcblx0aWYgKGJhY2tlbmQgPT09IFwiamF2YXNjcmlwdFwiKSB7XHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHRcImFzeW5jXCI6IHRydWVcclxuXHRcdH07XHJcblx0fSBlbHNlIGlmIChiYWNrZW5kID09PSBcInBuYWNsXCIpIHtcclxuXHRcdGlmIChQTmFDbENvbnRleHQuaXNTdXBwb3J0ZWQoKSkge1xyXG5cdFx0XHRyZXR1cm4ge1xyXG5cdFx0XHRcdFwibWFuaWZlc3RcIjogUE5hQ2xDb250ZXh0LmdldERlZmF1bHRNYW5pZmVzdFVSTCgpXHJcblx0XHRcdH07XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRyZXR1cm4ge307XHJcblx0XHR9XHJcblx0fSBlbHNlIGlmIChiYWNrZW5kID09PSBcIndlYmNsXCIpIHtcclxuXHRcdHJldHVybiB7XHJcblx0XHRcdFwiZGV2aWNlXCI6IFdlYkNMQ29udGV4dC5nZXREZWZhdWx0RGV2aWNlKClcclxuXHRcdH07XHJcblx0fSBlbHNlIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIGJhY2tlbmQ6IFwiICsgYmFja2VuZCk7XHJcblx0fVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIERldGVjdHMgd2hldGhlciB0aGUgcmVxdWVzdGVkIGNvbXB1dGluZyBmZWF0dXJlIGlzIGF2YWlsYWJsZVxyXG4gKlxyXG4gKiBAc3RhdGljXHJcbiAqIEBtZXRob2QgaGFzRmVhdHVyZVxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIGFuIGlkZW50aWZpZXIgb2YgdGhlIG9wdGlvbmFsIGZlYXR1cmUgdG8gZGV0ZWN0LiBUaGUgZm9sbG93aW5nIGlkZW50aWZpZXJzIGFyZSBzdXBwb3J0ZWQ6XHJcbiAqXHJcbiAqICAgICA8dGFibGU+XHJcbiAqICAgICAgICAgPHRyPlxyXG4gKiAgICAgICAgICAgICA8dGg+RmVhdHVyZSBJZGVudGlmaWVyPC90aD5cclxuICogICAgICAgICAgICAgPHRoPkludGVycHJldGF0aW9uPC90aD5cclxuICogICAgICAgICA8L3RyPlxyXG4gKiAgICAgICAgIDx0cj5cclxuICogICAgICAgICAgICAgPHRkPlwid2Vid29ya2Vyc1wiPC90ZD5cclxuICogICAgICAgICAgICAgPHRkPkRldGVjdCBpZiB0aGUgSmF2YVNjcmlwdCBlbmdpbmUgY2FuIHNwYXduIGRlZGljYXRlZCBXZWIgV29ya2Vycy48L3RkPlxyXG4gKiAgICAgICAgIDwvdHI+XHJcbiAqICAgICAgICAgPHRyPlxyXG4gKiAgICAgICAgICAgICA8dGQ+XCJhc20uanNcIjwvdGQ+XHJcbiAqICAgICAgICAgICAgIDx0ZD5EZXRlY3QgaWYgdGhlIEphdmFTY3JpcHQgZW5naW5lIHJlY29nbml6ZXMgQXNtLmpzIGRpcmVjdGl2ZS48L3RkPlxyXG4gKiAgICAgICAgIDwvdHI+XHJcbiAqICAgICAgICAgPHRyPlxyXG4gKiAgICAgICAgICAgICA8dGQ+XCJzaW1kLmpzXCI8L3RkPlxyXG4gKiAgICAgICAgICAgICA8dGQ+RGV0ZWN0IGlmIHRoZSBKYXZhU2NyaXB0IGVuZ2luZSBwcm92aWRlIFNJTUQuZmxvYXQzMng0LCBTSU1ELmludDMyeDQsIEZsb2F0MzJ4NEFycmF5LCBhbmQgSW50MzJ4NEFycmF5IG9mIFNJTUQuanM8L3RkPlxyXG4gKiAgICAgICAgIDwvdHI+XHJcbiAqICAgICAgICAgPHRyPlxyXG4gKiAgICAgICAgICAgICA8dGQ+XCJ3ZWJnbFwiPC90ZD5cclxuICogICAgICAgICAgICAgPHRkPkRldGVjdCBpZiB0aGUgZW52aXJvbm1lbnQgc3VwcG9ydHMgV2ViR0wgKGVpdGhlciBleHBlcmltZW50YWwgb3Igc3RhYmxlIGltcGxlbWVudGF0aW9uKTwvdGQ+XHJcbiAqICAgICAgICAgPC90cj5cclxuICogICAgICAgICA8dHI+XHJcbiAqICAgICAgICAgICAgIDx0ZD5cIndlYmNsXCI8L3RkPlxyXG4gKiAgICAgICAgICAgICA8dGQ+RGV0ZWN0IGlmIHRoZSBlbnZpcm9ubWVudCBzdXBwb3J0cyBXZWJDTDwvdGQ+XHJcbiAqICAgICAgICAgPC90cj5cclxuICogICAgICAgICA8dHI+XHJcbiAqICAgICAgICAgICAgIDx0ZD5cInBuYWNsXCI8L3RkPlxyXG4gKiAgICAgICAgICAgICA8dGQ+RGV0ZWN0IGlmIFBvcnRhYmxlIE5hdGl2ZSBDbGllbnQgKFBOYUNsKSBpcyBzdXBwb3J0ZWQgYW5kIGVuYWJsZWQ8L3RkPlxyXG4gKiAgICAgICAgIDwvdHI+XHJcbiAqICAgICAgICAgPHRyPlxyXG4gKiAgICAgICAgICAgICA8dGQ+XCJuYWNsXCI8L3RkPlxyXG4gKiAgICAgICAgICAgICA8dGQ+RGV0ZWN0IGlmIE5hdGl2ZSBDbGllbnQgKE5hQ2wpIGlzIHN1cHBvcnRlZCBhbmQgZW5hYmxlZDwvdGQ+XHJcbiAqICAgICAgICAgPC90cj5cclxuICogICAgIDwvdGFibGU+XHJcbiAqXHJcbiAqIEByZXR1cm4ge0Jvb2xlYW59IC0gdHJ1ZSBpZiB0aGUgZmVhdHVyZSBpcyBzdXBwb3J0ZWQsIGZhbHNlIG90aGVyd2lzZVxyXG4gKi9cclxudmFyIGhhc0ZlYXR1cmUgPSBmdW5jdGlvbihuYW1lKSB7XHJcblx0c3dpdGNoIChuYW1lKSB7XHJcblx0XHRjYXNlIFwiYXNtLmpzXCI6XHJcblx0XHRcdHRyeSB7XHJcblx0XHRcdFx0dmFyIHVzZXJBZ2VudCA9IHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50O1xyXG5cdFx0XHRcdHZhciB1c2VyQWdlbnRDb21wb25lbnRzID0gdXNlckFnZW50LnNwbGl0KC9cXHMrLyk7XHJcblx0XHRcdFx0dmFyIGZpcmVmb3hSZWdleHAgPSAvW0ZmXWlyZWZveFxcLyhcXGQrKS9nO1xyXG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdXNlckFnZW50Q29tcG9uZW50cy5sZW5ndGg7ICsraSkge1xyXG5cdFx0XHRcdFx0dmFyIGNvbXBvbmVudCA9IHVzZXJBZ2VudENvbXBvbmVudHNbaV07XHJcblx0XHRcdFx0XHR2YXIgbWF0Y2ggPSBmaXJlZm94UmVnZXhwLmV4ZWMoY29tcG9uZW50KTtcclxuXHRcdFx0XHRcdGlmIChtYXRjaCAhPT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0XHR2YXIgZmlyZWZveFZlcnNpb24gPSBwYXJzZUludChtYXRjaFsxXSk7XHJcblx0XHRcdFx0XHRcdHJldHVybiBmaXJlZm94VmVyc2lvbiA+PSAyOTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHR9IGNhdGNoIChlKSB7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0Y2FzZSBcInNpbWQuanNcIjpcclxuXHRcdFx0cmV0dXJuICh0eXBlb2YgU0lNRCAhPT0gXCJ1bmRlZmluZWRcIikgJiZcclxuXHRcdFx0XHQodHlwZW9mIEZsb2F0MzJ4NEFycmF5ICE9PSBcInVuZGVmaW5lZFwiKSAmJlxyXG5cdFx0XHRcdCh0eXBlb2YgSW50MzJ4NEFycmF5ICE9PSBcInVuZGVmaW5lZFwiKTtcclxuXHRcdGNhc2UgXCJ3ZWJ3b3JrZXJzXCI6XHJcblx0XHRcdHJldHVybiAodHlwZW9mIFdvcmtlciAhPT0gXCJ1bmRlZmluZWRcIik7XHJcblx0XHRjYXNlIFwid2ViZ2xcIjpcclxuXHRcdFx0dHJ5IHtcclxuXHRcdFx0XHR2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcclxuXHRcdFx0XHR0cnkge1xyXG5cdFx0XHRcdFx0aWYgKGNhbnZhcy5nZXRDb250ZXh0KFwid2ViZ2xcIikgIT09IG51bGwpIHtcclxuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fSBjYXRjaCAoZSkge1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHR0cnkge1xyXG5cdFx0XHRcdFx0aWYgKGNhbnZhcy5nZXRDb250ZXh0KFwiZXhwZXJpbWVudGFsLXdlYmdsXCIpICE9PSBudWxsKSB7XHJcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0gY2F0Y2ggKGUpIHtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0gY2F0Y2ggKGUpIHtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRjYXNlIFwid2ViY2xcIjpcclxuXHRcdFx0cmV0dXJuIFdlYkNMQ29udGV4dC5pc1N1cHBvcnRlZCgpO1xyXG5cdFx0Y2FzZSBcInBuYWNsXCI6XHJcblx0XHRcdHJldHVybiBQTmFDbENvbnRleHQuaXNTdXBwb3J0ZWQoKTtcclxuXHRcdGNhc2UgXCJuYWNsXCI6XHJcblx0XHRcdHRyeSB7XHJcblx0XHRcdFx0cmV0dXJuICh0eXBlb2YgbmF2aWdhdG9yLm1pbWVUeXBlc1tcImFwcGxpY2F0aW9uL3gtbmFjbFwiXSkgIT09IFwidW5kZWZpbmVkXCI7XHJcblx0XHRcdH0gY2F0Y2ggKGUpIHtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRkZWZhdWx0OlxyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGZlYXR1cmU6IFwiICsgbmFtZSk7XHJcblx0fVxyXG59O1xyXG5cclxuZXhwb3J0cy5pbml0ID0gaW5pdDtcclxuZXhwb3J0cy5oYXNGZWF0dXJlID0gaGFzRmVhdHVyZTtcclxuZXhwb3J0cy5nZXREZWZhdWx0QmFja2VuZCA9IGdldERlZmF1bHRCYWNrZW5kO1xyXG5leHBvcnRzLmdldFN1cHBvcnRlZEJhY2tlbmRzID0gZ2V0U3VwcG9ydGVkQmFja2VuZHM7XHJcbmV4cG9ydHMuZ2V0QmFja2VuZE9wdGlvbnMgPSBnZXRCYWNrZW5kT3B0aW9ucztcclxuZXhwb3J0cy5nZXREZWZhdWx0QmFja2VuZE9wdGlvbnMgPSBnZXREZWZhdWx0QmFja2VuZE9wdGlvbnM7XHJcbmV4cG9ydHMuRGF0YVR5cGUgPSBEYXRhVHlwZTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG52YXIgTkRBcnJheSA9IHJlcXVpcmUoXCIuLy4uL05EQXJyYXlcIik7XHJcbnZhciBEYXRhVHlwZSA9IHJlcXVpcmUoXCIuLy4uL0RhdGFUeXBlXCIpO1xyXG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLy4uL3V0aWxcIik7XHJcbnZhciBqc21hdGggPSByZXF1aXJlKFwiLi9qc21hdGhcIik7XHJcblxyXG4vKipcclxuICogUHJvdmlkZXMgbWV0aG9kcyBmb3IgY3JlYXRpb24sIG1hbmlwdWxhdGlvbiwgYW5kIGRlc3RydWN0aW9uIG9mIE4tZGltZW5zaW9uYWwgYXJyYXlzLlxyXG4gKiBBcml0aG1ldGljIG9wZXJhdGlvbnMgYXJlIHBvc3NpYmxlIG9ubHkgb24gYXJyYXlzIHRoYXQgYmVsb25nIHRvIHRoZSBzYW1lIGNvbnRleHQuXHJcbiAqXHJcbiAqIEBjbGFzcyBDb250ZXh0XHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxuZnVuY3Rpb24gSlNDb250ZXh0KG9wdGlvbnMsIGNhbGxiYWNrKSB7XHJcblx0Y2FsbGJhY2sodGhpcyk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDb25zdHJ1Y3RzIGFuIHVuaW5pYWxpemVkIE4tZGltZW5zaW9uYWwgYXJyYXkuXHJcbiAqXHJcbiAqIEBtZXRob2QgZW1wdHlcclxuICogQHBhcmFtIHtOdW1iZXJ9IHNoYXBlIC0gdGhlIGRpbWVuc2lvbnMgb2YgdGhlIGFycmF5XHJcbiAqIEBwYXJhbSB7RGF0YVR5cGV9IGRhdGFUeXBlIC0gdGhlIHR5cGUgb2YgZWxlbWVudHMgaW4gdGhlIGFycmF5LlxyXG4gKi9cclxuSlNDb250ZXh0LnByb3RvdHlwZS5lbXB0eSA9IGZ1bmN0aW9uKHNoYXBlLCBkYXRhVHlwZSkge1xyXG5cdC8qIFRoZSBpcyBubyB3YXkgdG8gY3JlYXRlIHVuaW5pdGlhbGl6ZWQgdHlwZWQgYXJyYXkgaW4gSmF2YVNjcmlwdCAqL1xyXG5cdHJldHVybiB0aGlzLnplcm9zKHNoYXBlLCBkYXRhVHlwZSk7XHJcbn07XHJcblxyXG4vKipcclxuICogQ29uc3RydWN0cyBhbiBOLWRpbWVuc2lvbmFsIGFycmF5IHdpdGggZWxlbWVudHMgaW5pdGlhbGl6ZWQgdG8gemVyby5cclxuICpcclxuICogQG1ldGhvZCB6ZXJvc1xyXG4gKiBAcGFyYW0ge051bWJlcn0gc2hhcGUgLSB0aGUgZGltZW5zaW9ucyBvZiB0aGUgYXJyYXlcclxuICogQHBhcmFtIHtEYXRhVHlwZX0gZGF0YVR5cGUgLSB0aGUgdHlwZSBvZiBlbGVtZW50cyBpbiB0aGUgYXJyYXkuXHJcbiAqL1xyXG5KU0NvbnRleHQucHJvdG90eXBlLnplcm9zID0gZnVuY3Rpb24oc2hhcGUsIGRhdGFUeXBlKSB7XHJcblx0c2hhcGUgPSB1dGlsLmNoZWNrU2hhcGUoc2hhcGUpO1xyXG5cdGlmICh0eXBlb2YgZGF0YVR5cGUgPT09IFwidW5kZWZpbmVkXCIpIHtcclxuXHRcdGRhdGFUeXBlID0gbmV3IERhdGFUeXBlKFwiZjY0XCIpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRkYXRhVHlwZSA9IHV0aWwuY2hlY2tEYXRhVHlwZShkYXRhVHlwZSk7XHJcblx0fVxyXG5cdHZhciBhcnJheSA9IG5ldyBOREFycmF5KHNoYXBlLCBkYXRhVHlwZSwgdGhpcyk7XHJcblx0YXJyYXkuX2RhdGEgPSBuZXcgZGF0YVR5cGUuYXJyYXlUeXBlKGFycmF5Lmxlbmd0aCk7XHJcblx0cmV0dXJuIGFycmF5O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvbnN0cnVjdHMgYW4gTi1kaW1lbnNpb25hbCBhcnJheSB3aXRoIGVsZW1lbnRzIGluaXRpYWxpemVkIHRvIG9uZS5cclxuICpcclxuICogQG1ldGhvZCBvbmVzXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBzaGFwZSAtIHRoZSBkaW1lbnNpb25zIG9mIHRoZSBhcnJheVxyXG4gKiBAcGFyYW0ge0RhdGFUeXBlfSBkYXRhVHlwZSAtIHRoZSB0eXBlIG9mIGVsZW1lbnRzIGluIHRoZSBhcnJheS5cclxuICovXHJcbkpTQ29udGV4dC5wcm90b3R5cGUub25lcyA9IGZ1bmN0aW9uKHNoYXBlLCBkYXRhVHlwZSkge1xyXG5cdC8qIFRoZSBpcyBubyB3YXkgdG8gY3JlYXRlIHVuaW5pdGlhbGl6ZWQgdHlwZWQgYXJyYXkgaW4gSmF2YVNjcmlwdCAqL1xyXG5cdHZhciBhcnJheSA9IHRoaXMuemVyb3Moc2hhcGUsIGRhdGFUeXBlKTtcclxuXHRqc21hdGguZmlsbChhcnJheS5fZGF0YSwgMS4wKTtcclxuXHRyZXR1cm4gYXJyYXk7XHJcbn07XHJcblxyXG4vKipcclxuICogQ29uc3RydWN0cyBhbiBOLWRpbWVuc2lvbmFsIGFycmF5IG9iamVjdCB3aXRoIHRoZSBwcm92aWRlZCBkYXRhLlxyXG4gKlxyXG4gKiBAbWV0aG9kIGFycmF5XHJcbiAqIEBwYXJhbSB7TnVtYmVyW119IGRhdGEgLSB0aGUgYXJyYXkgZGF0YVxyXG4gKiBAcGFyYW0ge0RhdGFUeXBlfSBkYXRhVHlwZSAtIHRoZSB0eXBlIG9mIGVsZW1lbnRzIGluIHRoZSBhcnJheS5cclxuICovXHJcbkpTQ29udGV4dC5wcm90b3R5cGUuYXJyYXkgPSBmdW5jdGlvbihkYXRhLCBkYXRhVHlwZSkge1xyXG5cdGlmICh0eXBlb2YgZGF0YVR5cGUgPT09IFwidW5kZWZpbmVkXCIpIHtcclxuXHRcdGRhdGFUeXBlID0gbmV3IERhdGFUeXBlKFwiZjY0XCIpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRkYXRhVHlwZSA9IHV0aWwuY2hlY2tEYXRhVHlwZShkYXRhVHlwZSk7XHJcblx0fVxyXG5cdHZhciBzaGFwZSA9IFtdO1xyXG5cdHV0aWwuZGlzY292ZXJBcnJheVNoYXBlUmVjdXJzaXZlKGRhdGEsIHNoYXBlLCAwKTtcclxuXHR2YXIgYXJyYXkgPSB0aGlzLmVtcHR5KHNoYXBlLCBkYXRhVHlwZSk7XHJcblx0dXRpbC5jb3B5QXJyYXlEYXRhUmVjdXJzaXZlKGFycmF5Ll9kYXRhLCBkYXRhLCBzaGFwZSwgMCwgMCk7XHJcblx0cmV0dXJuIGFycmF5O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIERlLWFsbG9jYXRlcyBkYXRhIGFzc29jaWF0ZWQgd2l0aCB0aGUgYXJyYXkuXHJcbiAqXHJcbiAqIEBtZXRob2QgX2ludmFsaWRhdGVcclxuICogQHByaXZhdGVcclxuICpcclxuICogQHBhcmFtIHtOREFycmF5fSBhcnJheSAtIHRoZSBuLWRpbWVuc2lvbmFsIGFycmF5IG9iamVjdCB3aXRoIGRhdGEgdG8gYmUgZGUtYWxsb2NhdGVkLlxyXG4gKi9cclxuSlNDb250ZXh0LnByb3RvdHlwZS5faW52YWxpZGF0ZSA9IGZ1bmN0aW9uKGFycmF5KSB7XHJcblx0dXRpbC5jaGVja05EQXJyYXkoYXJyYXksIFwiYXJyYXlcIik7XHJcblx0YXJyYXkuX2RhdGEgPSBudWxsO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEZldGNoZXMgTkRBcnJheSBkYXRhIGFuZCBhc3luY2hyb25vdXNseSByZXR1cm5zIGl0IGFzIEphdmFTY3JpcHQgdHlwZWQgYXJyYXlzLlxyXG4gKlxyXG4gKiBAbWV0aG9kIGZldGNoXHJcbiAqIEBhc3luY1xyXG4gKlxyXG4gKiBAcGFyYW0ge05EQXJyYXl9IGFycmF5cyogLSBOREFycmF5cyB0byBmZXRjaC5cclxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBBIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCB3aXRoIHRoZSBkYXRhIHdoZW4gaXQgaXMgYXZhaWxhYmxlLlxyXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyVmlld30gY2FsbGJhY2suYXJyYXlzKiAtIHR5cGVkIGFycmF5cyB3aXRoIHRoZSBkYXRhLiBUaGUgZWxlbWVudCB0eXBlIG9mIHRoZSB0eXBlZCBhcnJheSBtYXRjaGVzIHRoZSBkYXRhIHR5cGUgb2YgdGhlIE5EQXJyYXkuIEZvciB6ZXJvLWRpbWVuc2lvbmFsIGFycmF5cyB0aGUgb3V0cHV0IGlzIHJldHVybmVkIGFzIGEgdHlwZWQgYXJyYXkgd2l0aCBhIHNpbmdsZSBlbGVtZW50LiBNdWx0aS1kaW1lbnNpb25hbCBhcnJheXMgYXJlIHJldHVybmVkIGluIHJvdy1tYWpvciBzdG9yYWdlIGZvcm1hdC5cclxuICovXHJcbkpTQ29udGV4dC5wcm90b3R5cGUuZmV0Y2ggPSBmdW5jdGlvbigpIHtcclxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiQ2FsbGJhY2sgYXJndW1lbnQgbWlzc2luZ1wiKTtcclxuXHR9XHJcblx0dmFyIGNhbGxiYWNrID0gYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAxXTtcclxuXHQvKiBWYWxpZGF0ZSBhcmd1bWVudHMgKi9cclxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiQXQgbGVhc3Qgb25lIE5EQXJyYXkgYXJndW1lbnQgZXhwZWN0ZWRcIik7XHJcblx0fVxyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aCAtIDE7ICsraSkge1xyXG5cdFx0dXRpbC5jaGVja05EQXJyYXkoYXJndW1lbnRzW2ldLCBcImFyZ3VtZW50IFwiICsgaSk7XHJcblx0fVxyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aCAtIDE7ICsraSkge1xyXG5cdFx0YXJndW1lbnRzW2ldLl9kZWNSZWYoKTtcclxuXHR9XHJcblx0dmFyIGNhbGxiYWNrQXJndW1lbnRzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGNhbGxiYWNrQXJndW1lbnRzLmxlbmd0aDsgKytpKSB7XHJcblx0XHR2YXIgYXJyYXkgPSBhcmd1bWVudHNbaV07XHJcblx0XHRjYWxsYmFja0FyZ3VtZW50c1tpXSA9IG5ldyBhcnJheS5kYXRhVHlwZS5hcnJheVR5cGUoYXJyYXkuX2RhdGEpO1xyXG5cdH1cclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGggLSAxOyArK2kpIHtcclxuXHRcdGFyZ3VtZW50c1tpXS5fdHJ5SW52YWxpZGF0ZSgpO1xyXG5cdH1cclxuXHRjYWxsYmFjay5hcHBseShudWxsLCBjYWxsYmFja0FyZ3VtZW50cyk7XHJcbn07XHJcblxyXG4vKipcclxuICogRmV0Y2hlcyBOREFycmF5IGRhdGEgYW5kIGFzeW5jaHJvbm91c2x5IHJldHVybnMgaXQgYXMgSmF2YVNjcmlwdCBhcnJheXMgb3IgbnVtYmVycy5cclxuICpcclxuICogQG1ldGhvZCBnZXRcclxuICogQGFzeW5jXHJcbiAqXHJcbiAqIEBwYXJhbSB7TkRBcnJheX0gYXJyYXlzKiAtIE5EQXJyYXlzIHRvIGZldGNoLlxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIEEgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIHdpdGggdGhlIGRhdGEgd2hlbiBpdCBpcyBhdmFpbGFibGUuXHJcbiAqIEBwYXJhbSB7TnVtYmVyfE51bWJlcltdfSBjYWxsYmFjay5hcnJheXMqIC0gSmF2YVNjcmlwdCBudW1iZXJzIG9yIG11bHRpZGltZW5zaW9uYWwgYXJyYXlzIHdpdGggdGhlIGRhdGEuIFRoZSBudW1iZXIgYW5kIG9yZGVyIG9mIGFyZ3VtZW50cyBtYXRjaGVzIHRoZSBOREFycmF5cyBwYXNzZWQgdG8gdGhlIG1ldGhvZCBjYWxsLlxyXG4gKi9cclxuSlNDb250ZXh0LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbigpIHtcclxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiQ2FsbGJhY2sgYXJndW1lbnQgbWlzc2luZ1wiKTtcclxuXHR9XHJcblx0dmFyIGNhbGxiYWNrID0gYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAxXTtcclxuXHQvKiBWYWxpZGF0ZSBhcmd1bWVudHMgKi9cclxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiQXQgbGVhc3Qgb25lIE5EQXJyYXkgYXJndW1lbnQgZXhwZWN0ZWRcIik7XHJcblx0fVxyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aCAtIDE7ICsraSkge1xyXG5cdFx0dXRpbC5jaGVja05EQXJyYXkoYXJndW1lbnRzW2ldLCBcImFyZ3VtZW50IFwiICsgaSk7XHJcblx0fVxyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aCAtIDE7ICsraSkge1xyXG5cdFx0YXJndW1lbnRzW2ldLl9kZWNSZWYoKTtcclxuXHR9XHJcblx0dmFyIGNhbGxiYWNrQXJndW1lbnRzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGNhbGxiYWNrQXJndW1lbnRzLmxlbmd0aDsgKytpKSB7XHJcblx0XHR2YXIgYXJyYXkgPSBhcmd1bWVudHNbaV07XHJcblx0XHRpZiAoYXJyYXkuc2hhcGUubGVuZ3RoID09PSAwKSB7XHJcblx0XHRcdGNhbGxiYWNrQXJndW1lbnRzW2ldID0gYXJyYXkuX2RhdGFbMF07XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR2YXIganNhcnJheSA9IG5ldyBBcnJheShhcnJheS5zaGFwZVswXSk7XHJcblx0XHRcdHV0aWwuY3JlYXRlQXJyYXlSZWN1cnNpdmUoYXJyYXkuX2RhdGEsIGpzYXJyYXksIGFycmF5LnNoYXBlLCAwLCAwKTtcclxuXHRcdFx0Y2FsbGJhY2tBcmd1bWVudHNbaV0gPSBqc2FycmF5O1xyXG5cdFx0fVxyXG5cdH1cclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGggLSAxOyArK2kpIHtcclxuXHRcdGFyZ3VtZW50c1tpXS5fdHJ5SW52YWxpZGF0ZSgpO1xyXG5cdH1cclxuXHRjYWxsYmFjay5hcHBseShudWxsLCBjYWxsYmFja0FyZ3VtZW50cyk7XHJcbn07XHJcblxyXG4vKipcclxuICogV2FpdHMgdW50aWwgcHJldmlvdXMgY29tbWFuZHMgZmluaXNoZWQgZXhlY3V0aW9uIGFuZCBjYWxscyB0aGUgY2FsbGJhY2suXHJcbiAqXHJcbiAqIEBtZXRob2QgYmFycmllclxyXG4gKiBAYXN5bmNcclxuICpcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBBIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCBhZnRlciB0aGUgcHJldmlvdXMgY29tbWFuZHMgcmV0aXJlLlxyXG4gKi9cclxuSlNDb250ZXh0LnByb3RvdHlwZS5iYXJyaWVyID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcclxuXHRjYWxsYmFjaygpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgYW5vdGhlciBhcnJheSB3aXRoIHRoZSBzYW1lIGRhdGEsIGJ1dCBkaWZmZXJlbnQgZGltZW5zaW9ucy5cclxuICpcclxuICogQG1ldGhvZCByZXNoYXBlXHJcbiAqIEBwYXJhbSB7KE5EQXJyYXl8TnVtYmVyKX0gc2hhcGUgLSBkaW1lbnNpb25zIG9mIHRoZSBuZXcgYXJyYXkuXHJcbiAqL1xyXG5KU0NvbnRleHQucHJvdG90eXBlLnJlc2hhcGUgPSBmdW5jdGlvbihhcnJheSwgc2hhcGUpIHtcclxuXHRzaGFwZSA9IHV0aWwuY2hlY2tTaGFwZShzaGFwZSk7XHJcblx0aWYgKHV0aWwuY29tcHV0ZUxlbmd0aChzaGFwZSkgIT09IGFycmF5Lmxlbmd0aCkge1xyXG5cdFx0dGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUaGUgc2hhcGUgaXMgbm90IGNvbXBhdGlibGUgd2l0aCB0aGUgYXJyYXlcIik7XHJcblx0fVxyXG5cdHZhciBvdXQgPSBuZXcgTkRBcnJheShzaGFwZSwgYXJyYXkuZGF0YVR5cGUsIHRoaXMpO1xyXG5cdGlmIChhcnJheS5fZGVjUmVmKCkpIHtcclxuXHRcdG91dC5fZGF0YSA9IG5ldyBvdXQuZGF0YVR5cGUuYXJyYXlUeXBlKG91dC5sZW5ndGgpO1xyXG5cdFx0b3V0Ll9kYXRhLnNldChhcnJheS5fZGF0YSk7XHJcblx0fSBlbHNlIHtcclxuXHRcdG91dC5fZGF0YSA9IGFycmF5Ll9kYXRhO1xyXG5cdFx0YXJyYXkuX3RyeUludmFsaWRhdGUoKTtcclxuXHR9XHJcblx0cmV0dXJuIG91dDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBEdXBsaWNhdGVzIGFycmF5IGVsZW1lbnRzIGFsb25nIHRoZSBzcGVjaWZpZWQgYXhpcy5cclxuICpcclxuICogQG1ldGhvZCByZXBlYXRcclxuICogQHBhcmFtIHtOREFycmF5fSBhIC0gdGhlIGlucHV0IGFycmF5LlxyXG4gKiBAcGFyYW0ge051bWJlcn0gcmVwZWF0cyAtIHRoZSBudW1iZXIgb2YgdGltZXMgdG8gcmVwZWF0IGVhY2ggZWxlbWVudC5cclxuICogQHBhcmFtIHtOdW1iZXJ9IGF4aXMgLSB0aGUgYXhpcyBhbG9uZyB3aGljaCB0aGUgZWxlbWVudHMgd2lsbCBiZSBkdXBsaWNhdGVkLlxyXG4gKiBAcGFyYW0ge05EQXJyYXl9IFtvdXRdIC0gYW4gb3V0cHV0IGFycmF5IHRvIHN0b3JlIHRoZSByZXN1bHQuXHJcbiAqIEByZXR1cm4ge05EQXJyYXl9IC0gYW4gTi1kaW1lbnNpb25hbCBhcnJheSB3aXRoIHJlcGVhdGVkIGVsZW1lbnRzIG9mIGFycmF5ICoqYSoqLlxyXG4gKi9cclxuSlNDb250ZXh0LnByb3RvdHlwZS5yZXBlYXQgPSBmdW5jdGlvbihhLCByZXBlYXRzLCBheGlzLCBvdXQpIHtcclxuXHR1dGlsLmNoZWNrTkRBcnJheShhLCBcImFcIik7XHJcblx0cmVwZWF0cyA9IHV0aWwuY2hlY2tSZXBlYXRzKHJlcGVhdHMpO1xyXG5cdGF4aXMgPSB1dGlsLmNoZWNrQXhpcyhheGlzLCBhLnNoYXBlLmxlbmd0aCk7XHJcblx0dmFyIHNoYXBlQSA9IGEuc2hhcGU7XHJcblx0dmFyIHNoYXBlT3V0ID0gc2hhcGVBLnNsaWNlKDApO1xyXG5cdHNoYXBlT3V0W2F4aXNdICo9IHJlcGVhdHM7XHJcblx0YS5fZGVjUmVmKCk7XHJcblx0dHJ5IHtcclxuXHRcdGlmICh0eXBlb2Ygb3V0ID09PSBcInVuZGVmaW5lZFwiKSB7XHJcblx0XHRcdG91dCA9IHRoaXMuZW1wdHkoc2hhcGVPdXQsIGEuZGF0YVR5cGUpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dXRpbC5jaGVja05EQXJyYXkob3V0LCBcIm91dFwiKTtcclxuXHRcdFx0dXRpbC5jaGVja1NoYXBlc0NvbXBhdGliaWxpdHkob3V0LnNoYXBlLCBzaGFwZU91dCk7XHJcblx0XHRcdHV0aWwuY2hlY2tEYXRhVHlwZXNDb21wYXRpYmlsaXR5KGEuZGF0YVR5cGUsIG91dC5kYXRhVHlwZSk7XHJcblx0XHRcdG91dC5faW5jUmVmKCk7XHJcblx0XHR9XHJcblx0XHR2YXIgb3V0ZXJTdHJpZGUgPSB1dGlsLmNvbXB1dGVPdXRlclN0cmlkZShzaGFwZUEsIGF4aXMpO1xyXG5cdFx0dmFyIGlubmVyU3RyaWRlID0gdXRpbC5jb21wdXRlSW5uZXJTdHJpZGUoc2hhcGVBLCBheGlzKTtcclxuXHRcdGpzbWF0aC5yZXBlYXQoYS5fZGF0YSwgb3V0Ll9kYXRhLCBvdXRlclN0cmlkZSwgaW5uZXJTdHJpZGUsIHNoYXBlQVtheGlzXSwgcmVwZWF0cyk7XHJcblx0fSBjYXRjaCAoZSkge1xyXG5cdFx0YS5faW5jUmVmKCk7XHJcblx0XHR0aHJvdyBlO1xyXG5cdH1cclxuXHRhLl90cnlJbnZhbGlkYXRlKCk7XHJcblx0cmV0dXJuIG91dDtcclxufTtcclxuXHJcbnZhciBiaW5hcnlBcml0aE9wID0gZnVuY3Rpb24oYSwgYiwgb3V0LCBjb250ZXh0LCBvcGVyYXRpb24sIG9wZXJhdGlvbkNvbnN0LCBvcGVyYXRpb25SZXZDb25zdCkge1xyXG5cdHZhciBzaGFwZU91dCA9IG51bGwsIGRhdGFUeXBlT3V0ID0gbnVsbDtcclxuXHRpZiAoYSBpbnN0YW5jZW9mIE5EQXJyYXkpIHtcclxuXHRcdHNoYXBlT3V0ID0gYS5zaGFwZTtcclxuXHRcdGRhdGFUeXBlT3V0ID0gYS5kYXRhVHlwZTtcclxuXHRcdGlmIChiIGluc3RhbmNlb2YgTkRBcnJheSkge1xyXG5cdFx0XHR1dGlsLmNoZWNrU2hhcGVzQ29tcGF0aWJpbGl0eShhLnNoYXBlLCBiLnNoYXBlKTtcclxuXHRcdFx0dXRpbC5jaGVja0RhdGFUeXBlc0NvbXBhdGliaWxpdHkoYS5kYXRhVHlwZSwgYi5kYXRhVHlwZSk7XHJcblx0XHR9IGVsc2UgaWYgKCF1dGlsLmlzTnVtYmVyKGIpKSB7XHJcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoXCJVbnN1cHBvcnRlZCB0eXBlIG9mIGJcIik7XHJcblx0XHR9XHJcblx0fSBlbHNlIGlmICh1dGlsLmlzTnVtYmVyKGEpKSB7XHJcblx0XHRzaGFwZU91dCA9IGIuc2hhcGU7XHJcblx0XHRkYXRhVHlwZU91dCA9IGIuZGF0YVR5cGU7XHJcblx0XHR1dGlsLmNoZWNrTkRBcnJheShiLCBcImJcIik7XHJcblx0fSBlbHNlIHtcclxuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoXCJVbnN1cHBvcnRlZCB0eXBlIG9mIGFcIik7XHJcblx0fVxyXG5cdGlmIChhIGluc3RhbmNlb2YgTkRBcnJheSkge1xyXG5cdFx0YS5fZGVjUmVmKCk7XHJcblx0fVxyXG5cdGlmIChiIGluc3RhbmNlb2YgTkRBcnJheSkge1xyXG5cdFx0Yi5fZGVjUmVmKCk7XHJcblx0fVxyXG5cdHRyeSB7XHJcblx0XHRpZiAodHlwZW9mIG91dCA9PT0gXCJ1bmRlZmluZWRcIikge1xyXG5cdFx0XHRvdXQgPSBuZXcgTkRBcnJheShzaGFwZU91dCwgZGF0YVR5cGVPdXQsIGNvbnRleHQpO1xyXG5cdFx0XHRpZiAoKGEgaW5zdGFuY2VvZiBOREFycmF5KSAmJiAhYS5faGFzUmVmcygpKSB7XHJcblx0XHRcdFx0b3V0Ll9kYXRhID0gYS5fZGF0YTtcclxuXHRcdFx0fSBlbHNlIGlmICgoYiBpbnN0YW5jZW9mIE5EQXJyYXkpICYmICFiLl9oYXNSZWZzKCkpIHtcclxuXHRcdFx0XHRvdXQuX2RhdGEgPSBiLl9kYXRhO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdG91dC5fZGF0YSA9IG5ldyBkYXRhVHlwZU91dC5hcnJheVR5cGUob3V0Lmxlbmd0aCk7XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHV0aWwuY2hlY2tOREFycmF5KG91dCwgXCJvdXRcIik7XHJcblx0XHRcdHV0aWwuY2hlY2tTaGFwZXNDb21wYXRpYmlsaXR5KHNoYXBlT3V0LCBvdXQuc2hhcGUpO1xyXG5cdFx0XHR1dGlsLmNoZWNrRGF0YVR5cGVzQ29tcGF0aWJpbGl0eShkYXRhVHlwZU91dCwgb3V0LmRhdGFUeXBlKTtcclxuXHRcdFx0b3V0Ll9pbmNSZWYoKTtcclxuXHRcdH1cclxuXHRcdGlmIChhIGluc3RhbmNlb2YgTkRBcnJheSkge1xyXG5cdFx0XHRpZiAoYiBpbnN0YW5jZW9mIE5EQXJyYXkpIHtcclxuXHRcdFx0XHRvcGVyYXRpb24oYS5fZGF0YSwgYi5fZGF0YSwgb3V0Ll9kYXRhKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRvcGVyYXRpb25Db25zdChhLl9kYXRhLCArYiwgb3V0Ll9kYXRhKTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0b3BlcmF0aW9uUmV2Q29uc3QoYi5fZGF0YSwgK2EsIG91dC5fZGF0YSk7XHJcblx0XHR9XHJcblx0fSBjYXRjaCAoZSkge1xyXG5cdFx0LyogUmVzdG9yZSB0aGUgcHJldmlvdXMgc3RhdGUgKi9cclxuXHRcdGlmIChhIGluc3RhbmNlb2YgTkRBcnJheSkge1xyXG5cdFx0XHRhLl9pbmNSZWYoKTtcclxuXHRcdH1cclxuXHRcdGlmIChiIGluc3RhbmNlb2YgTkRBcnJheSkge1xyXG5cdFx0XHRiLl9pbmNSZWYoKTtcclxuXHRcdH1cclxuXHRcdHRocm93IGU7XHJcblx0fVxyXG5cdGlmIChhIGluc3RhbmNlb2YgTkRBcnJheSkge1xyXG5cdFx0YS5fdHJ5SW52YWxpZGF0ZSgpO1xyXG5cdH1cclxuXHRpZiAoYiBpbnN0YW5jZW9mIE5EQXJyYXkpIHtcclxuXHRcdGIuX3RyeUludmFsaWRhdGUoKTtcclxuXHR9XHJcblx0cmV0dXJuIG91dDtcclxufTtcclxuXHJcbnZhciB1bmFyeUFyaXRoT3AgPSBmdW5jdGlvbihhLCBvdXQsIGNvbnRleHQsIG9wZXJhdGlvbikge1xyXG5cdHV0aWwuY2hlY2tOREFycmF5KGEsIFwiYVwiKTtcclxuXHRhLl9kZWNSZWYoKTtcclxuXHR0cnkge1xyXG5cdFx0aWYgKHR5cGVvZiBvdXQgPT09IFwidW5kZWZpbmVkXCIpIHtcclxuXHRcdFx0b3V0ID0gbmV3IE5EQXJyYXkoYS5zaGFwZSwgYS5kYXRhVHlwZSwgY29udGV4dCk7XHJcblx0XHRcdGlmICgoYSBpbnN0YW5jZW9mIE5EQXJyYXkpICYmICFhLl9oYXNSZWZzKCkpIHtcclxuXHRcdFx0XHRvdXQuX2RhdGEgPSBhLl9kYXRhO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdG91dC5fZGF0YSA9IG5ldyBhLmRhdGFUeXBlLmFycmF5VHlwZShvdXQubGVuZ3RoKTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dXRpbC5jaGVja05EQXJyYXkob3V0LCBcIm91dFwiKTtcclxuXHRcdFx0dXRpbC5jaGVja1NoYXBlc0NvbXBhdGliaWxpdHkoYS5zaGFwZSwgb3V0LnNoYXBlKTtcclxuXHRcdFx0dXRpbC5jaGVja0RhdGFUeXBlc0NvbXBhdGliaWxpdHkoYS5kYXRhVHlwZSwgb3V0LmRhdGFUeXBlKTtcclxuXHRcdFx0b3V0Ll9pbmNSZWYoKTtcclxuXHRcdH1cclxuXHRcdG9wZXJhdGlvbihhLl9kYXRhLCBvdXQuX2RhdGEpO1xyXG5cdH0gY2F0Y2ggKGUpIHtcclxuXHRcdC8qIFJlc3RvcmUgdGhlIHByZXZpb3VzIHN0YXRlICovXHJcblx0XHRhLl9pbmNSZWYoKTtcclxuXHRcdHRocm93IGU7XHJcblx0fVxyXG5cdGEuX3RyeUludmFsaWRhdGUoKTtcclxuXHRyZXR1cm4gb3V0O1xyXG59O1xyXG5cclxudmFyIGF4aXNSZWR1Y2VPcCA9IGZ1bmN0aW9uKGEsIGF4aXMsIG91dCwgY29udGV4dCwgb3BlcmF0aW9uLCBheGlzT3BlcmF0aW9uKSB7XHJcblx0dXRpbC5jaGVja05EQXJyYXkoYSwgXCJhXCIpO1xyXG5cdGlmICh0eXBlb2YgYXhpcyA9PT0gXCJ1bmRlZmluZWRcIikge1xyXG5cdFx0aWYgKHR5cGVvZiBvdXQgPT09IFwidW5kZWZpbmVkXCIpIHtcclxuXHRcdFx0b3V0ID0gY29udGV4dC5lbXB0eShbXSwgYS5kYXRhVHlwZSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR1dGlsLmNoZWNrTkRBcnJheShvdXQsIFwib3V0XCIpO1xyXG5cdFx0XHR1dGlsLmNoZWNrU2hhcGVzQ29tcGF0aWJpbGl0eShbXSwgb3V0LnNoYXBlKTtcclxuXHRcdFx0dXRpbC5jaGVja0RhdGFUeXBlc0NvbXBhdGliaWxpdHkoYS5kYXRhVHlwZSwgb3V0LmRhdGFUeXBlKTtcclxuXHRcdFx0b3V0Ll9pbmNSZWYoKTtcclxuXHRcdH1cclxuXHRcdG9wZXJhdGlvbihhLl9kYXRhLCBvdXQuX2RhdGEpO1xyXG5cdFx0YS5fdHJ5UmVsZWFzZSgpO1xyXG5cdFx0cmV0dXJuIG91dDtcclxuXHR9IGVsc2Uge1xyXG5cdFx0YXhpcyA9IHV0aWwuY2hlY2tBeGlzKGF4aXMsIGEuc2hhcGUubGVuZ3RoKTtcclxuXHRcdHZhciBzaGFwZU91dCA9IHV0aWwuY29tcHV0ZUF4aXNSZWR1Y3Rpb25PdXRTaGFwZShhLnNoYXBlLCBheGlzKTtcclxuXHRcdGlmICh0eXBlb2Ygb3V0ID09PSBcInVuZGVmaW5lZFwiKSB7XHJcblx0XHRcdG91dCA9IGNvbnRleHQuZW1wdHkoc2hhcGVPdXQsIGEuZGF0YVR5cGUpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dXRpbC5jaGVja05EQXJyYXkob3V0LCBcIm91dFwiKTtcclxuXHRcdFx0dXRpbC5jaGVja1NoYXBlc0NvbXBhdGliaWxpdHkoW10sIG91dC5zaGFwZSk7XHJcblx0XHRcdHV0aWwuY2hlY2tEYXRhVHlwZXNDb21wYXRpYmlsaXR5KGEuZGF0YVR5cGUsIG91dC5kYXRhVHlwZSk7XHJcblx0XHRcdG91dC5faW5jUmVmKCk7XHJcblx0XHR9XHJcblx0XHRheGlzT3BlcmF0aW9uKGEuX2RhdGEsIG91dC5fZGF0YSxcclxuXHRcdFx0dXRpbC5jb21wdXRlT3V0ZXJTdHJpZGUoYS5zaGFwZSwgYXhpcyksXHJcblx0XHRcdHV0aWwuY29tcHV0ZUlubmVyU3RyaWRlKGEuc2hhcGUsIGF4aXMpLFxyXG5cdFx0XHRhLnNoYXBlW2F4aXNdKTtcclxuXHRcdGEuX3RyeVJlbGVhc2UoKTtcclxuXHRcdHJldHVybiBvdXQ7XHJcblx0fVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEFkZHMgb25lIG51bWJlciBvciBhcnJheSB3aXRoIGFub3RoZXIgbnVtYmVyIG9yIGFycmF5LlxyXG4gKiBBZGRpdGlvbiBpcyBwZXJmb3JtZWQgZWxlbWVudC1ieS1lbGVtZW50LlxyXG4gKlxyXG4gKiBAbWV0aG9kIGFkZFxyXG4gKiBAcGFyYW0geyhOREFycmF5fE51bWJlcil9IGEgLSBvbmUgbnVtYmVyIG9yIGFycmF5IHRvIGFkZC4gSWYgKipiKiogaXMgYSAqTnVtYmVyKiwgKiphKiogbXVzdCBiZSBhbiAqTkRBcnJheSouXHJcbiAqIEBwYXJhbSB7KE5EQXJyYXl8TnVtYmVyKX0gYiAtIGFub3RoZXIgbnVtYmVyIG9yIGFycmF5IHRvIGFkZC4gSWYgKiphKiogaXMgYSAqTnVtYmVyKiwgKipiKiogbXVzdCBiZSBhbiAqTkRBcnJheSouXHJcbiAqIEBwYXJhbSB7TkRBcnJheX0gW291dF0gLSB0aGUgYXJyYXkgd2hlcmUgdGhlIHJlc3VsdCBpcyB0byBiZSBzdG9yZWQuIElmIHByb3ZpZGVkLCBtdXN0IG1hdGNoIHRoZSBzaGFwZSBhbmQgZGF0YSB0eXBlIG9mIGlucHV0IGFycmF5cy5cclxuICogQHJldHVybiB7TkRBcnJheX0gLSB0aGUgcmVzdWx0IG9mIGVsZW1lbnQtd2lzZSBhZGRpdGlvbiBvZiAqKmEqKiBhbmQgKipiKiouXHJcbiAqL1xyXG5KU0NvbnRleHQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKGEsIGIsIG91dCkge1xyXG5cdHJldHVybiBiaW5hcnlBcml0aE9wKGEsIGIsIG91dCwgdGhpcywganNtYXRoLmFkZCwganNtYXRoLmFkZENvbnN0LCBqc21hdGguYWRkQ29uc3QpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFN1YnRyYWN0cyBvbmUgbnVtYmVyIG9yIGFycmF5IGZyb20gYW5vdGhlciBudW1iZXIgb3IgYXJyYXkuXHJcbiAqIFN1YnRyYWN0aW9uIGlzIHBlcmZvcm1lZCBlbGVtZW50LWJ5LWVsZW1lbnQuXHJcbiAqXHJcbiAqIEBtZXRob2Qgc3ViXHJcbiAqIEBwYXJhbSB7KE5EQXJyYXl8TnVtYmVyKX0gYSAtIHRoZSBudW1iZXIgb3IgYXJyYXkgdG8gc3VidHJhY3QgZnJvbS4gSWYgKipiKiogaXMgYSAqTnVtYmVyKiwgKiphKiogbXVzdCBiZSBhbiAqTkRBcnJheSouXHJcbiAqIEBwYXJhbSB7KE5EQXJyYXl8TnVtYmVyKX0gYiAtIHRoZSBudW1iZXIgb3IgYXJyYXkgdG8gc3VidHJhY3QuIElmICoqYSoqIGlzIGEgKk51bWJlciosICoqYioqIG11c3QgYmUgYW4gKk5EQXJyYXkqLlxyXG4gKiBAcGFyYW0ge05EQXJyYXl9IFtvdXRdIC0gdGhlIGFycmF5IHdoZXJlIHRoZSByZXN1bHQgaXMgdG8gYmUgc3RvcmVkLiBJZiBwcm92aWRlZCwgbXVzdCBtYXRjaCB0aGUgc2hhcGUgYW5kIGRhdGEgdHlwZSBvZiBpbnB1dCBhcnJheXMuXHJcbiAqIEByZXR1cm4ge05EQXJyYXl9IC0gdGhlIHJlc3VsdCBvZiBlbGVtZW50LXdpc2Ugc3VidHJhY3Rpb24gb2YgKipiKiogZnJvbSAqKmEqKi5cclxuICovXHJcbkpTQ29udGV4dC5wcm90b3R5cGUuc3ViID0gZnVuY3Rpb24oYSwgYiwgb3V0KSB7XHJcblx0cmV0dXJuIGJpbmFyeUFyaXRoT3AoYSwgYiwgb3V0LCB0aGlzLCBqc21hdGguc3ViLCBqc21hdGguc3ViQ29uc3QsIGpzbWF0aC5zdWJSZXZDb25zdCk7XHJcbn07XHJcblxyXG4vKipcclxuICogTXVsdGlwbGllcyBvbmUgbnVtYmVyIG9yIGFycmF5IGJ5IGFub3RoZXIgbnVtYmVyIG9yIGFycmF5LlxyXG4gKiBNdWx0aXBsaWNhdGlvbiBpcyBwZXJmb3JtZWQgZWxlbWVudC1ieS1lbGVtZW50LlxyXG4gKlxyXG4gKiBAbWV0aG9kIG11bFxyXG4gKiBAcGFyYW0geyhOREFycmF5fE51bWJlcil9IGEgLSBvbmUgbnVtYmVyIG9yIGFycmF5IHRvIG11bHRpcGx5LiBJZiAqKmIqKiBpcyBhICpOdW1iZXIqLCAqKmEqKiBtdXN0IGJlIGFuICpOREFycmF5Ki5cclxuICogQHBhcmFtIHsoTkRBcnJheXxOdW1iZXIpfSBiIC0gYW5vdGhlciBudW1iZXIgb3IgYXJyYXkgdG8gbXVsdGlwbHkuIElmICoqYSoqIGlzIGEgKk51bWJlciosICoqYioqIG11c3QgYmUgYW4gKk5EQXJyYXkqLlxyXG4gKiBAcGFyYW0ge05EQXJyYXl9IFtvdXRdIC0gdGhlIGFycmF5IHdoZXJlIHRoZSByZXN1bHQgaXMgdG8gYmUgc3RvcmVkLiBJZiBwcm92aWRlZCwgbXVzdCBtYXRjaCB0aGUgc2hhcGUgYW5kIGRhdGEgdHlwZSBvZiBpbnB1dCBhcnJheXMuXHJcbiAqIEByZXR1cm4ge05EQXJyYXl9IC0gdGhlIHJlc3VsdCBvZiBlbGVtZW50LXdpc2UgbXVsdGlwbGljYXRpb24gb2YgKiphKiogYW5kICoqYioqLlxyXG4gKi9cclxuSlNDb250ZXh0LnByb3RvdHlwZS5tdWwgPSBmdW5jdGlvbihhLCBiLCBvdXQpIHtcclxuXHRyZXR1cm4gYmluYXJ5QXJpdGhPcChhLCBiLCBvdXQsIHRoaXMsIGpzbWF0aC5tdWwsIGpzbWF0aC5tdWxDb25zdCwganNtYXRoLm11bENvbnN0KTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBEaXZpZGVzIG9uZSBudW1iZXIgb3IgYXJyYXkgYnkgYW5vdGhlciBudW1iZXIgb3IgYXJyYXkuXHJcbiAqIERpdmlzaW9uIGlzIHBlcmZvcm1lZCBlbGVtZW50LWJ5LWVsZW1lbnQuXHJcbiAqXHJcbiAqIEBtZXRob2QgZGl2XHJcbiAqIEBwYXJhbSB7KE5EQXJyYXl8TnVtYmVyKX0gYSAtIHRoZSBudW1iZXIgb3IgYXJyYXkgdG8gZGl2aWRlLiBJZiAqKmIqKiBpcyBhICpOdW1iZXIqLCAqKmEqKiBtdXN0IGJlIGFuICpOREFycmF5Ki5cclxuICogQHBhcmFtIHsoTkRBcnJheXxOdW1iZXIpfSBiIC0gdGhlIG51bWJlciBvciBhcnJheSB0byBkaXZpZGUgYnkuIElmICoqYSoqIGlzIGEgKk51bWJlciosICoqYioqIG11c3QgYmUgYW4gKk5EQXJyYXkqLlxyXG4gKiBAcGFyYW0ge05EQXJyYXl9IFtvdXRdIC0gdGhlIGFycmF5IHdoZXJlIHRoZSByZXN1bHQgaXMgdG8gYmUgc3RvcmVkLiBJZiBwcm92aWRlZCwgbXVzdCBtYXRjaCB0aGUgc2hhcGUgYW5kIGRhdGEgdHlwZSBvZiBpbnB1dCBhcnJheXMuXHJcbiAqIEByZXR1cm4ge05EQXJyYXl9IC0gdGhlIHJlc3VsdCBvZiBlbGVtZW50LXdpc2UgZGl2aXNpb24gb2YgKiphKiogYnkgKipiKiouXHJcbiAqL1xyXG5KU0NvbnRleHQucHJvdG90eXBlLmRpdiA9IGZ1bmN0aW9uKGEsIGIsIG91dCkge1xyXG5cdHJldHVybiBiaW5hcnlBcml0aE9wKGEsIGIsIG91dCwgdGhpcywganNtYXRoLmRpdiwganNtYXRoLmRpdkNvbnN0LCBqc21hdGguZGl2UmV2Q29uc3QpO1xyXG59O1xyXG5cclxuSlNDb250ZXh0LnByb3RvdHlwZS5taW4gPSBmdW5jdGlvbihhLCBheGlzLCBvdXQpIHtcclxuXHRyZXR1cm4gYXhpc1JlZHVjZU9wKGEsIGF4aXMsIG91dCwgdGhpcywganNtYXRoLm1pbiwganNtYXRoLmF4aXNNaW4pO1xyXG59O1xyXG5cclxuSlNDb250ZXh0LnByb3RvdHlwZS5tYXggPSBmdW5jdGlvbihhLCBheGlzLCBvdXQpIHtcclxuXHRyZXR1cm4gYXhpc1JlZHVjZU9wKGEsIGF4aXMsIG91dCwgdGhpcywganNtYXRoLm1heCwganNtYXRoLmF4aXNNYXgpO1xyXG59O1xyXG5cclxuSlNDb250ZXh0LnByb3RvdHlwZS5zdW0gPSBmdW5jdGlvbihhLCBheGlzLCBvdXQpIHtcclxuXHRyZXR1cm4gYXhpc1JlZHVjZU9wKGEsIGF4aXMsIG91dCwgdGhpcywganNtYXRoLnN1bSwganNtYXRoLmF4aXNTdW0pO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIE5lZ2F0ZXMgYXJyYXkgZWxlbWVudHMuXHJcbiAqXHJcbiAqIEBtZXRob2QgbmVnXHJcbiAqIEBwYXJhbSB7TkRBcnJheX0gYSAtIHRoZSBhcnJheSBvZiBlbGVtZW50cyB0byBiZSBuZWdhdGVkLlxyXG4gKiBAcGFyYW0ge05EQXJyYXl9IFtvdXRdIC0gdGhlIGFycmF5IGZvciBuZWdhdGVkIGVsZW1lbnRzLiBJZiBzdXBwbGllZCwgbXVzdCBtYXRjaCB0aGUgZGltZW5zaW9ucyBhbmQgZGF0YSB0eXBlIG9mIHRoZSAqKmEqKiBhcnJheS5cclxuICovXHJcbkpTQ29udGV4dC5wcm90b3R5cGUubmVnID0gZnVuY3Rpb24oYSwgb3V0KSB7XHJcblx0cmV0dXJuIHVuYXJ5QXJpdGhPcChhLCBvdXQsIHRoaXMsIGpzbWF0aC5uZWcpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvbXB1dGVzIGFic29sdXRlIHZhbHVlIG9mIGFycmF5IGVsZW1lbnRzLlxyXG4gKlxyXG4gKiBAbWV0aG9kIGFic1xyXG4gKiBAcGFyYW0ge05EQXJyYXl9IGEgLSB0aGUgYXJyYXkgb2YgaW5wdXQgZWxlbWVudHMuXHJcbiAqIEBwYXJhbSB7TkRBcnJheX0gW291dF0gLSB0aGUgYXJyYXkgZm9yIGNvbXB1dGVkIGFic29sdXRlIHZhbHVlcy4gSWYgc3VwcGxpZWQsIG11c3QgbWF0Y2ggdGhlIGRpbWVuc2lvbnMgYW5kIGRhdGEgdHlwZSBvZiB0aGUgKiphKiogYXJyYXkuXHJcbiAqL1xyXG5KU0NvbnRleHQucHJvdG90eXBlLmFicyA9IGZ1bmN0aW9uKGEsIG91dCkge1xyXG5cdHJldHVybiB1bmFyeUFyaXRoT3AoYSwgb3V0LCB0aGlzLCBqc21hdGguYWJzKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBFeHBvbmVudGlhdGVzIGFycmF5IGVsZW1lbnRzLlxyXG4gKlxyXG4gKiBAbWV0aG9kIGV4cFxyXG4gKiBAcGFyYW0ge05EQXJyYXl9IGEgLSB0aGUgYXJyYXkgb2YgZWxlbWVudHMgdG8gYmUgZXhwb25lbnRpYXRlZC5cclxuICogQHBhcmFtIHtOREFycmF5fSBbb3V0XSAtIHRoZSBhcnJheSBmb3IgZXhwb25lbnRpYXRlZCBlbGVtZW50cy4gSWYgc3VwcGxpZWQsIG11c3QgbWF0Y2ggdGhlIGRpbWVuc2lvbnMgYW5kIGRhdGEgdHlwZSBvZiB0aGUgKiphKiogYXJyYXkuXHJcbiAqL1xyXG5KU0NvbnRleHQucHJvdG90eXBlLmV4cCA9IGZ1bmN0aW9uKGEsIG91dCkge1xyXG5cdHJldHVybiB1bmFyeUFyaXRoT3AoYSwgb3V0LCB0aGlzLCBqc21hdGguZXhwKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb21wdXRlcyBsb2dhcml0aG0gb2YgYXJyYXkgZWxlbWVudHMuXHJcbiAqXHJcbiAqIEBtZXRob2QgbG9nXHJcbiAqIEBwYXJhbSB7TkRBcnJheX0gYSAtIHRoZSBhcnJheSBvZiBpbnB1dCBlbGVtZW50cy5cclxuICogQHBhcmFtIHtOREFycmF5fSBbb3V0XSAtIHRoZSBhcnJheSBmb3IgY29tcHV0ZWQgbG9nYXJpdGhtIHZhbHVlcy4gSWYgc3VwcGxpZWQsIG11c3QgbWF0Y2ggdGhlIGRpbWVuc2lvbnMgYW5kIGRhdGEgdHlwZSBvZiB0aGUgKiphKiogYXJyYXkuXHJcbiAqL1xyXG5KU0NvbnRleHQucHJvdG90eXBlLmxvZyA9IGZ1bmN0aW9uKGEsIG91dCkge1xyXG5cdHJldHVybiB1bmFyeUFyaXRoT3AoYSwgb3V0LCB0aGlzLCBqc21hdGgubG9nKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb21wdXRlcyBzcXVhcmUgcm9vdCBvZiBhcnJheSBlbGVtZW50cy5cclxuICpcclxuICogQG1ldGhvZCBzcXJ0XHJcbiAqIEBwYXJhbSB7TkRBcnJheX0gYSAtIHRoZSBhcnJheSBvZiBpbnB1dCBlbGVtZW50cy5cclxuICogQHBhcmFtIHtOREFycmF5fSBbb3V0XSAtIHRoZSBhcnJheSBmb3IgY29tcHV0ZWQgc3F1YXJlIHJvb3QgdmFsdWVzLiBJZiBzdXBwbGllZCwgbXVzdCBtYXRjaCB0aGUgZGltZW5zaW9ucyBhbmQgZGF0YSB0eXBlIG9mIHRoZSAqKmEqKiBhcnJheS5cclxuICovXHJcbkpTQ29udGV4dC5wcm90b3R5cGUuc3FydCA9IGZ1bmN0aW9uKGEsIG91dCkge1xyXG5cdHJldHVybiB1bmFyeUFyaXRoT3AoYSwgb3V0LCB0aGlzLCBqc21hdGguc3FydCk7XHJcbn07XHJcblxyXG4vKipcclxuICogU3F1YXJlcyBhcnJheSBlbGVtZW50cy5cclxuICpcclxuICogQG1ldGhvZCBzcXVhcmVcclxuICogQHBhcmFtIHtOREFycmF5fSBhIC0gdGhlIGFycmF5IG9mIGVsZW1lbnRzIHRvIGJlIHNxdWFyZWQuXHJcbiAqIEBwYXJhbSB7TkRBcnJheX0gW291dF0gLSB0aGUgYXJyYXkgZm9yIHNxdWFyZWQgZWxlbWVudHMuIElmIHN1cHBsaWVkLCBtdXN0IG1hdGNoIHRoZSBkaW1lbnNpb25zIGFuZCBkYXRhIHR5cGUgb2YgdGhlICoqYSoqIGFycmF5LlxyXG4gKi9cclxuSlNDb250ZXh0LnByb3RvdHlwZS5zcXVhcmUgPSBmdW5jdGlvbihhLCBvdXQpIHtcclxuXHRyZXR1cm4gdW5hcnlBcml0aE9wKGEsIG91dCwgdGhpcywganNtYXRoLnNxdWFyZSk7XHJcbn07XHJcblxyXG4vKipcclxuICogQ29tcHV0ZXMgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byBOLWRpbWVuc2lvbmFsIGFycmF5cy5cclxuICpcclxuICogQG1ldGhvZCBkb3RcclxuICogQHBhcmFtIHtOREFycmF5fSBhIC0gdGhlIGZpcnN0IGlucHV0IGFycmF5LlxyXG4gKiBAcGFyYW0ge05EQXJyYXl9IGIgLSB0aGUgc2Vjb25kIGlucHV0IGFycmF5LlxyXG4gKiBAcGFyYW0ge05EQXJyYXl9IFtvdXRdIC0gdGhlIG91dHB1dCBhcnJheS4gSWYgc3VwcGxpZWQsIG11c3QgbWF0Y2ggdGhlIGRhdGEgdHlwZSBvZiAqKmEqKiBhbmQgKipiKiogYXJyYXlzIGFuZCBoYXZlIHRoZSBleHBlY3RlZCBzaGFwZS4gQ2FuIG5vdCBiZSB0aGUgc2FtZSBhcnJheSBhcyAqKmEqKiBvciAqKmIqKi5cclxuICogQHJldHVybiB7TkRBcnJheX0gLSB0aGUgYXJyYXkgd2l0aCB0aGUgZG90IHByb2R1Y3Qgb2YgKiphKiogYW5kICoqYioqLlxyXG4gKi9cclxuSlNDb250ZXh0LnByb3RvdHlwZS5kb3QgPSBmdW5jdGlvbihhLCBiLCBvdXQpIHtcclxuXHR1dGlsLmNoZWNrTkRBcnJheShhLCBcImFcIik7XHJcblx0dXRpbC5jaGVja05EQXJyYXkoYiwgXCJiXCIpO1xyXG5cdHV0aWwuY2hlY2tEYXRhVHlwZXNDb21wYXRpYmlsaXR5KGEuZGF0YVR5cGUsIGIuZGF0YVR5cGUpO1xyXG5cclxuXHQvKiBUaGUgYXhpcyBvZiBiIHVzZWQgaW4gcmVkdWN0aW9uOiBheGlzIDAgZm9yIDFEIGFycmF5LCBzZWNvbmQtdG8tbGFzdCBheGlzIGZvciBORCBhcnJheSAqL1xyXG5cdHZhciBhQXhpcyA9IE1hdGgubWF4KGEuc2hhcGUubGVuZ3RoIC0gMSwgMCk7XHJcblx0dmFyIGJBeGlzID0gTWF0aC5tYXgoYi5zaGFwZS5sZW5ndGggLSAyLCAwKTtcclxuXHR2YXIgcmVkdWN0aW9uRGltID0gYS5zaGFwZVthQXhpc107XHJcblx0aWYgKHJlZHVjdGlvbkRpbSAhPT0gYi5zaGFwZVtiQXhpc10pIHtcclxuXHRcdHRocm93IG5ldyBSYW5nZUVycm9yKFwiQXJyYXlzIGhhdmUgaW5jb21wYXRpYmxlIHJlZHVjdGlvbiBkaW1lbnNpb25zXCIpO1xyXG5cdH1cclxuXHR2YXIgc2hhcGVPdXQgPSBbXSwgc3RyaWRlQSA9IDEsIG91dGVyU3RyaWRlQiA9IDEsIGlubmVyU3RyaWRlQiA9IDE7XHJcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhQXhpczsgaSsrKSB7XHJcblx0XHRzaGFwZU91dC5wdXNoKGEuc2hhcGVbaV0pO1xyXG5cdFx0c3RyaWRlQSAqPSBhLnNoYXBlW2ldO1xyXG5cdH1cclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGIuc2hhcGUubGVuZ3RoOyBpKyspIHtcclxuXHRcdHZhciBkaW0gPSBiLnNoYXBlW2ldO1xyXG5cdFx0aWYgKGkgPCBiQXhpcykge1xyXG5cdFx0XHRvdXRlclN0cmlkZUIgKj0gZGltO1xyXG5cdFx0XHRzaGFwZU91dC5wdXNoKGRpbSk7XHJcblx0XHR9IGVsc2UgaWYgKGkgPiBiQXhpcykge1xyXG5cdFx0XHRpbm5lclN0cmlkZUIgKj0gZGltO1xyXG5cdFx0XHRzaGFwZU91dC5wdXNoKGRpbSk7XHJcblx0XHR9XHJcblx0fVxyXG5cdGlmICh0eXBlb2Ygb3V0ID09PSBcInVuZGVmaW5lZFwiKSB7XHJcblx0XHRvdXQgPSB0aGlzLmVtcHR5KHNoYXBlT3V0LCBhLmRhdGFUeXBlKTtcclxuXHR9IGVsc2UgaWYgKG91dCBpbnN0YW5jZW9mIE5EQXJyYXkpIHtcclxuXHRcdHV0aWwuY2hlY2tOREFycmF5KG91dCwgXCJvdXRcIik7XHJcblx0XHR1dGlsLmNoZWNrU2hhcGVzQ29tcGF0aWJpbGl0eShvdXQuc2hhcGUsIHNoYXBlT3V0KTtcclxuXHRcdHV0aWwuY2hlY2tEYXRhVHlwZXNDb21wYXRpYmlsaXR5KG91dC5kYXRhVHlwZSwgYS5kYXRhVHlwZSk7XHJcblx0XHR1dGlsLmNoZWNrRGlmZmVyZW50TkRBcnJheXMoYSwgb3V0LCBcImFcIiwgXCJvdXRcIik7XHJcblx0XHR1dGlsLmNoZWNrRGlmZmVyZW50TkRBcnJheXMoYiwgb3V0LCBcImJcIiwgXCJvdXRcIik7XHJcblx0XHRvdXQuX2luY1JlZigpO1xyXG5cdH1cclxuXHRqc21hdGguZG90KGEuX2RhdGEsIGIuX2RhdGEsIG91dC5fZGF0YSwgc3RyaWRlQSwgb3V0ZXJTdHJpZGVCLCBpbm5lclN0cmlkZUIsIHJlZHVjdGlvbkRpbSk7XHJcblx0YS5fdHJ5UmVsZWFzZSgpO1xyXG5cdGIuX3RyeVJlbGVhc2UoKTtcclxuXHRyZXR1cm4gb3V0O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgYW4gYXJpdGhtZXRpYyBzZXF1ZW5jZS5cclxuICpcclxuICogQG1ldGhvZCBsaW5zcGFjZVxyXG4gKiBAcGFyYW0ge051bWJlcn0gc3RhcnQgLSB0aGUgc3RhcnRpbmcgZW5kcG9pbnQgb2YgdGhlIHNlcXVlbmNlLiBNdXN0IGJlIGEgZmluaXRlIG51bWJlci5cclxuICogQHBhcmFtIHtOdW1iZXJ9IHN0b3AgLSB0aGUgZmluYWwgZW5kcG9pbnQgb2YgdGhlIHNlcXVlbmNlLiBNdXN0IGJlIGEgZmluaXRlIG51bWJlci5cclxuICogQHBhcmFtIHtOdW1iZXJ9IFtzYW1wbGVzPTUwXSAtIHRoZSBudW1iZXIgb2Ygc2FtcGxlcyBpbiB0aGUgc2VxdWVuY3kuIE11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyLlxyXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtjbG9zZWQ9dHJ1ZV0gLSBhbiBpbmRpY2F0b3Igb2Ygd2hldGhlciB0aGUgZmluYWwgZW5kcG9pbnQgKGBzdG9wYCBhcmd1bWVudCkgc2hvdWxkIGJlIGluY2x1ZGVkIGluIHRoZSBzZXF1ZW5jZS5cclxuICovXHJcbkpTQ29udGV4dC5wcm90b3R5cGUubGluc3BhY2UgPSBmdW5jdGlvbihzdGFydCwgc3RvcCwgc2FtcGxlcywgY2xvc2VkKSB7XHJcblx0aWYgKCF1dGlsLmlzUmVhbChzdGFydCkpIHtcclxuXHRcdHRocm93IG5ldyBUeXBlRXJyb3Ioc3RhcnQgKyBcIiBpcyBub3QgYSByZWFsIG51bWJlclwiKTtcclxuXHR9XHJcblx0aWYgKCF1dGlsLmlzUmVhbChzdG9wKSkge1xyXG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihzdG9wICsgXCIgaXMgbm90IGEgcmVhbCBudW1iZXJcIik7XHJcblx0fVxyXG5cdGlmICh0eXBlb2Ygc2FtcGxlcyA9PT0gXCJ1bmRlZmluZWRcIikge1xyXG5cdFx0LyogRGVmYXVsdCB2YWx1ZSBpbiBOdW1QeSAqL1xyXG5cdFx0c2FtcGxlcyA9IDUwO1xyXG5cdH0gZWxzZSBpZiAoIXV0aWwuaXNJbnQoc2FtcGxlcykpIHtcclxuXHRcdHRocm93IG5ldyBUeXBlRXJyb3Ioc2FtcGxlcyArIFwiIGlzIG5vdCBhbiBpbnRlZ2VyXCIpO1xyXG5cdH0gZWxzZSBpZiAoc2FtcGxlcyA8PSAwKSB7XHJcblx0XHR0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlRoZSBudW1iZXIgb2Ygc2FtcGxlcyBtdXN0IGJlIHBvc2l0aXZlXCIpO1xyXG5cdH1cclxuXHRpZiAodHlwZW9mIGNsb3NlZCA9PT0gXCJ1bmRlZmluZWRcIikge1xyXG5cdFx0Y2xvc2VkID0gdHJ1ZTtcclxuXHR9XHJcblx0aWYgKGNsb3NlZCAmJiAoc2FtcGxlcyA9PT0gMSkpIHtcclxuXHRcdHRocm93IG5ldyBSYW5nZUVycm9yKFwiVGhlIG51bWJlciBvZiBzYW1wbGVzIG11c3QgYmUgYSBsZWFzdCAyIChmb3Igc3RhcnQgYW5kIGVuZCBwb2ludHMpXCIpO1xyXG5cdH1cclxuXHR2YXIgYXJyYXkgPSB0aGlzLmVtcHR5KHNhbXBsZXMsIG5ldyBEYXRhVHlwZShcImY2NFwiKSk7XHJcblx0dmFyIGRhdGEgPSBhcnJheS5fZGF0YTtcclxuXHR2YXIgcmFuZ2UgPSBzdG9wIC0gc3RhcnQ7XHJcblx0dmFyIG4gPSAoY2xvc2VkKSA/IHNhbXBsZXMgLSAxIDogc2FtcGxlcztcclxuXHR2YXIgc3RlcCA9IHJhbmdlIC8gbjtcclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IHNhbXBsZXM7IGkrKykge1xyXG5cdFx0ZGF0YVtpXSA9IHN0YXJ0ICsgc3RlcCAqIGk7XHJcblx0fVxyXG5cdHJldHVybiBhcnJheTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gSlNDb250ZXh0O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbnZhciBQQkNvbnRleHQgPSByZXF1aXJlKFwiLi8uLi9QQkNvbnRleHQuanNcIik7XHJcblxyXG5mdW5jdGlvbiBXZWJXb3JrZXJDb250ZXh0KG9wdGlvbnMsIGNhbGxiYWNrKSB7XHJcblx0dmFyIHNlbGYgPSB0aGlzO1xyXG5cdHRoaXMuX3dvcmtlciA9IG5ldyBXb3JrZXIoV2ViV29ya2VyQ29udGV4dC5nZXRXb3JrZXJVUkwob3B0aW9ucy5iYXNlVXJsKSk7XHJcblx0dGhpcy5fd29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGZ1bmN0aW9uKGUpIHtcclxuXHRcdHNlbGYuX21lc3NhZ2luZ0NvbnRleHQuX29uTWVzc2FnZShlKTtcclxuXHR9LCB0cnVlKTtcclxuXHR0aGlzLl9tZXNzYWdpbmdDb250ZXh0ID0gbmV3IFBCQ29udGV4dChvcHRpb25zLCBmdW5jdGlvbihtZXNzYWdlKSB7XHJcblx0XHRzZWxmLl93b3JrZXIucG9zdE1lc3NhZ2UobWVzc2FnZSwgW21lc3NhZ2VdKTtcclxuXHR9LCBjYWxsYmFjayk7XHJcbn1cclxuXHJcbldlYldvcmtlckNvbnRleHQuaXNTdXBwb3J0ZWQgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdHlwZW9mIFdvcmtlciAhPT0gXCJ1bmRlZmluZWRcIjtcclxufTtcclxuXHJcbldlYldvcmtlckNvbnRleHQuZ2V0V29ya2VyVVJMID0gZnVuY3Rpb24oYmFzZVVybCkge1xyXG5cdGlmIChiYXNlVXJsKSB7XHJcblx0XHRyZXR1cm4gYmFzZVVybCArIFwiZnVyaW91cy13b3JrZXIubWluLmpzXCI7XHJcblx0fSBlbHNlIHtcclxuXHRcdHJldHVybiBcImZ1cmlvdXMtd29ya2VyLm1pbi5qc1wiO1xyXG5cdH1cclxufTtcclxuXHJcbldlYldvcmtlckNvbnRleHQucHJvdG90eXBlLmVtcHR5ID0gZnVuY3Rpb24oc2hhcGUsIGRhdGFUeXBlKSB7XHJcblx0cmV0dXJuIHRoaXMuX21lc3NhZ2luZ0NvbnRleHQuZW1wdHkoc2hhcGUsIGRhdGFUeXBlKTtcclxufTtcclxuXHJcbldlYldvcmtlckNvbnRleHQucHJvdG90eXBlLnplcm9zID0gZnVuY3Rpb24oc2hhcGUsIGRhdGFUeXBlKSB7XHJcblx0cmV0dXJuIHRoaXMuX21lc3NhZ2luZ0NvbnRleHQuemVyb3Moc2hhcGUsIGRhdGFUeXBlKTtcclxufTtcclxuXHJcbldlYldvcmtlckNvbnRleHQucHJvdG90eXBlLm9uZXMgPSBmdW5jdGlvbihzaGFwZSwgZGF0YVR5cGUpIHtcclxuXHRyZXR1cm4gdGhpcy5fbWVzc2FnaW5nQ29udGV4dC5vbmVzKHNoYXBlLCBkYXRhVHlwZSk7XHJcbn07XHJcblxyXG5XZWJXb3JrZXJDb250ZXh0LnByb3RvdHlwZS5hcnJheSA9IGZ1bmN0aW9uKGRhdGEsIGRhdGFUeXBlKSB7XHJcblx0cmV0dXJuIHRoaXMuX21lc3NhZ2luZ0NvbnRleHQuYXJyYXkoZGF0YSwgZGF0YVR5cGUpO1xyXG59O1xyXG5cclxuV2ViV29ya2VyQ29udGV4dC5wcm90b3R5cGUubGluc3BhY2UgPSBmdW5jdGlvbihzdGFydCwgc3RvcCwgc2FtcGxlcywgY2xvc2VkKSB7XHJcblx0cmV0dXJuIHRoaXMuX21lc3NhZ2luZ0NvbnRleHQubGluc3BhY2Uoc3RhcnQsIHN0b3AsIHNhbXBsZXMsIGNsb3NlZCk7XHJcbn07XHJcblxyXG5XZWJXb3JrZXJDb250ZXh0LnByb3RvdHlwZS5yZXNoYXBlID0gZnVuY3Rpb24oYSwgc2hhcGUpIHtcclxuXHRyZXR1cm4gdGhpcy5fbWVzc2FnaW5nQ29udGV4dC5yZXNoYXBlKGEsIHNoYXBlKTtcclxufTtcclxuXHJcbldlYldvcmtlckNvbnRleHQucHJvdG90eXBlLnJlcGVhdCA9IGZ1bmN0aW9uKGEsIHJlcGVhdHMsIGF4aXMsIG91dCkge1xyXG5cdHJldHVybiB0aGlzLl9tZXNzYWdpbmdDb250ZXh0LnJlcGVhdChhLCByZXBlYXRzLCBheGlzLCBvdXQpO1xyXG59O1xyXG5cclxuV2ViV29ya2VyQ29udGV4dC5wcm90b3R5cGUuX2ludmFsaWRhdGUgPSBmdW5jdGlvbihhcnJheSkge1xyXG5cdHJldHVybiB0aGlzLl9tZXNzYWdpbmdDb250ZXh0Ll9pbnZhbGlkYXRlKGFycmF5KTtcclxufTtcclxuXHJcbldlYldvcmtlckNvbnRleHQucHJvdG90eXBlLmZldGNoID0gZnVuY3Rpb24oKSB7XHJcblx0dGhpcy5fbWVzc2FnaW5nQ29udGV4dC5mZXRjaC5hcHBseSh0aGlzLl9tZXNzYWdpbmdDb250ZXh0LCBhcmd1bWVudHMpO1xyXG59O1xyXG5cclxuV2ViV29ya2VyQ29udGV4dC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oKSB7XHJcblx0dGhpcy5fbWVzc2FnaW5nQ29udGV4dC5nZXQuYXBwbHkodGhpcy5fbWVzc2FnaW5nQ29udGV4dCwgYXJndW1lbnRzKTtcclxufTtcclxuXHJcbldlYldvcmtlckNvbnRleHQucHJvdG90eXBlLmluZm8gPSBmdW5jdGlvbihjYWxsYmFjaykge1xyXG5cdHRoaXMuX21lc3NhZ2luZ0NvbnRleHQuaW5mbyhjYWxsYmFjayk7XHJcbn07XHJcblxyXG5XZWJXb3JrZXJDb250ZXh0LnByb3RvdHlwZS5iYXJyaWVyID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcclxuXHR0aGlzLl9tZXNzYWdpbmdDb250ZXh0LmJhcnJpZXIoY2FsbGJhY2spO1xyXG59O1xyXG5cclxuV2ViV29ya2VyQ29udGV4dC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24oYSwgYiwgb3V0KSB7XHJcblx0cmV0dXJuIHRoaXMuX21lc3NhZ2luZ0NvbnRleHQuYWRkKGEsIGIsIG91dCk7XHJcbn07XHJcblxyXG5XZWJXb3JrZXJDb250ZXh0LnByb3RvdHlwZS5zdWIgPSBmdW5jdGlvbihhLCBiLCBvdXQpIHtcclxuXHRyZXR1cm4gdGhpcy5fbWVzc2FnaW5nQ29udGV4dC5zdWIoYSwgYiwgb3V0KTtcclxufTtcclxuXHJcbldlYldvcmtlckNvbnRleHQucHJvdG90eXBlLm11bCA9IGZ1bmN0aW9uKGEsIGIsIG91dCkge1xyXG5cdHJldHVybiB0aGlzLl9tZXNzYWdpbmdDb250ZXh0Lm11bChhLCBiLCBvdXQpO1xyXG59O1xyXG5cclxuV2ViV29ya2VyQ29udGV4dC5wcm90b3R5cGUuZGl2ID0gZnVuY3Rpb24oYSwgYiwgb3V0KSB7XHJcblx0cmV0dXJuIHRoaXMuX21lc3NhZ2luZ0NvbnRleHQuZGl2KGEsIGIsIG91dCk7XHJcbn07XHJcblxyXG5XZWJXb3JrZXJDb250ZXh0LnByb3RvdHlwZS5uZWcgPSBmdW5jdGlvbihhLCBvdXQpIHtcclxuXHRyZXR1cm4gdGhpcy5fbWVzc2FnaW5nQ29udGV4dC5uZWcoYSwgb3V0KTtcclxufTtcclxuXHJcbldlYldvcmtlckNvbnRleHQucHJvdG90eXBlLmFicyA9IGZ1bmN0aW9uKGEsIG91dCkge1xyXG5cdHJldHVybiB0aGlzLl9tZXNzYWdpbmdDb250ZXh0LmFicyhhLCBvdXQpO1xyXG59O1xyXG5cclxuV2ViV29ya2VyQ29udGV4dC5wcm90b3R5cGUuZXhwID0gZnVuY3Rpb24oYSwgb3V0KSB7XHJcblx0cmV0dXJuIHRoaXMuX21lc3NhZ2luZ0NvbnRleHQuZXhwKGEsIG91dCk7XHJcbn07XHJcblxyXG5XZWJXb3JrZXJDb250ZXh0LnByb3RvdHlwZS5sb2cgPSBmdW5jdGlvbihhLCBvdXQpIHtcclxuXHRyZXR1cm4gdGhpcy5fbWVzc2FnaW5nQ29udGV4dC5sb2coYSwgb3V0KTtcclxufTtcclxuXHJcbldlYldvcmtlckNvbnRleHQucHJvdG90eXBlLnNxcnQgPSBmdW5jdGlvbihhLCBvdXQpIHtcclxuXHRyZXR1cm4gdGhpcy5fbWVzc2FnaW5nQ29udGV4dC5zcXJ0KGEsIG91dCk7XHJcbn07XHJcblxyXG5XZWJXb3JrZXJDb250ZXh0LnByb3RvdHlwZS5zcXVhcmUgPSBmdW5jdGlvbihhLCBvdXQpIHtcclxuXHRyZXR1cm4gdGhpcy5fbWVzc2FnaW5nQ29udGV4dC5zcXVhcmUoYSwgb3V0KTtcclxufTtcclxuXHJcbldlYldvcmtlckNvbnRleHQucHJvdG90eXBlLm1pbiA9IGZ1bmN0aW9uKGEsIGF4aXMpIHtcclxuXHRyZXR1cm4gdGhpcy5fbWVzc2FnaW5nQ29udGV4dC5taW4oYSwgYXhpcyk7XHJcbn07XHJcblxyXG5XZWJXb3JrZXJDb250ZXh0LnByb3RvdHlwZS5tYXggPSBmdW5jdGlvbihhLCBheGlzKSB7XHJcblx0cmV0dXJuIHRoaXMuX21lc3NhZ2luZ0NvbnRleHQubWF4KGEsIGF4aXMpO1xyXG59O1xyXG5cclxuV2ViV29ya2VyQ29udGV4dC5wcm90b3R5cGUuc3VtID0gZnVuY3Rpb24oYSwgYXhpcykge1xyXG5cdHJldHVybiB0aGlzLl9tZXNzYWdpbmdDb250ZXh0LnN1bShhLCBheGlzKTtcclxufTtcclxuXHJcbldlYldvcmtlckNvbnRleHQucHJvdG90eXBlLmRvdCA9IGZ1bmN0aW9uKGEsIGIsIG91dCkge1xyXG5cdHJldHVybiB0aGlzLl9tZXNzYWdpbmdDb250ZXh0LmRvdChhLCBiLCBvdXQpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBXZWJXb3JrZXJDb250ZXh0O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbi8qKlxyXG4gKiBKYXZhU2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIGNvbXB1dGF0aW9uYWwgbWV0aG9kc1xyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAY2xhc3MgSlNNYXRoXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFNldHMgYWxsIGFycmF5IGVsZW1lbnRzIHRvIHRoZSBzcGVjaWZpZWQgdmFsdWUuXHJcbiAqXHJcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJWaWV3fSBkYXRhIC0gdGhlIGFycmF5IGRhdGEgYnVmZmVyLlxyXG4gKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSB0aGUgY29uc3RhbnQgdG8gZmlsbCB0aGUgYnVmZmVyIHdpdGguXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBzdGF0aWNcclxuICogQG1ldGhvZCBmaWxsXHJcbiAqL1xyXG5leHBvcnRzLmZpbGwgPSBmdW5jdGlvbihkYXRhLCB2YWx1ZSkge1xyXG5cdHZhciBuID0gZGF0YS5sZW5ndGg7XHJcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpIHtcclxuXHRcdGRhdGFbaV0gPSB2YWx1ZTtcclxuXHR9XHJcbn07XHJcblxyXG4vKipcclxuICogQWRkcyB0d28gYXJyYXlzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyVmlld30gZGF0YUEgLSB0aGUgaW5wdXQgYXVnZW5kIGFycmF5LlxyXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyVmlld30gZGF0YUIgLSB0aGUgaW5wdXQgYWRkZW5kIGFycmF5LlxyXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyVmlld30gZGF0YU91dCAtIHRoZSBvdXRwdXQgc3VtIGFycmF5LlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAc3RhdGljXHJcbiAqIEBtZXRob2QgYWRkXHJcbiAqL1xyXG5leHBvcnRzLmFkZCA9IGZ1bmN0aW9uKGRhdGFBLCBkYXRhQiwgZGF0YU91dCkge1xyXG5cdHZhciBuID0gZGF0YU91dC5sZW5ndGg7XHJcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpIHtcclxuXHRcdGRhdGFPdXRbaV0gPSBkYXRhQVtpXSArIGRhdGFCW2ldO1xyXG5cdH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBBZGRzIGEgY29uc3RhbnQgdG8gYW4gYXJyYXkuXHJcbiAqXHJcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJWaWV3fSBkYXRhQSAtIHRoZSBpbnB1dCBhdWdlbmQgYXJyYXkuXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZUIgLSB0aGUgYWRkZW5kIGNvbnN0YW50LlxyXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyVmlld30gZGF0YU91dCAtIHRoZSBvdXRwdXQgc3VtIGFycmF5LlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAc3RhdGljXHJcbiAqIEBtZXRob2QgYWRkQ29uc3RcclxuICovXHJcbmV4cG9ydHMuYWRkQ29uc3QgPSBmdW5jdGlvbihkYXRhQSwgdmFsdWVCLCBkYXRhT3V0KSB7XHJcblx0dmFyIG4gPSBkYXRhT3V0Lmxlbmd0aDtcclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSkge1xyXG5cdFx0ZGF0YU91dFtpXSA9IGRhdGFBW2ldICsgdmFsdWVCO1xyXG5cdH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBTdWJ0cmFjdHMgdHdvIGFycmF5cy5cclxuICpcclxuICogQHBhcmFtIHtBcnJheUJ1ZmZlclZpZXd9IGRhdGFBIC0gdGhlIGlucHV0IG1pbnVlbmQgYXJyYXkuXHJcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJWaWV3fSBkYXRhQiAtIHRoZSBpbnB1dCBzdWJ0cmFoZW5kIGFycmF5LlxyXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyVmlld30gZGF0YU91dCAtIHRoZSBvdXRwdXQgZGlmZmVyZW5jZSBhcnJheS5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQHN0YXRpY1xyXG4gKiBAbWV0aG9kIHN1YlxyXG4gKi9cclxuZXhwb3J0cy5zdWIgPSBmdW5jdGlvbihkYXRhQSwgZGF0YUIsIGRhdGFPdXQpIHtcclxuXHR2YXIgbiA9IGRhdGFPdXQubGVuZ3RoO1xyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKSB7XHJcblx0XHRkYXRhT3V0W2ldID0gZGF0YUFbaV0gLSBkYXRhQltpXTtcclxuXHR9XHJcbn07XHJcblxyXG4vKipcclxuICogU3VidHJhY3RzIGEgY29uc3RhbnQgZnJvbSBhbiBhcnJheS5cclxuICpcclxuICogQHBhcmFtIHtBcnJheUJ1ZmZlclZpZXd9IGRhdGFBIC0gdGhlIGlucHV0IG1pbnVlbmQgYXJyYXkuXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZUIgLSB0aGUgc3VidHJhaGVuZCBjb25zdGFudC5cclxuICogQHBhcmFtIHtBcnJheUJ1ZmZlclZpZXd9IGRhdGFPdXQgLSB0aGUgb3V0cHV0IGRpZmZlcmVuY2UgYXJyYXkuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBzdGF0aWNcclxuICogQG1ldGhvZCBzdWJDb25zdFxyXG4gKi9cclxuZXhwb3J0cy5zdWJDb25zdCA9IGZ1bmN0aW9uKGRhdGFBLCB2YWx1ZUIsIGRhdGFPdXQpIHtcclxuXHR2YXIgbiA9IGRhdGFPdXQubGVuZ3RoO1xyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKSB7XHJcblx0XHRkYXRhT3V0W2ldID0gZGF0YUFbaV0gLSB2YWx1ZUI7XHJcblx0fVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFN1YnRyYWN0cyBhbiBhcnJheSBmcm9tIGEgY29uc3RhbnQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJWaWV3fSBkYXRhQSAtIHRoZSBpbnB1dCBzdWJ0cmFoZW5kIGFycmF5LlxyXG4gKiBAcGFyYW0ge051bWJlcn0gdmFsdWVCIC0gdGhlIG1pbnVlbmQgY29uc3RhbnQuXHJcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJWaWV3fSBkYXRhT3V0IC0gdGhlIG91dHB1dCBkaWZmZXJlbmNlIGFycmF5LlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAc3RhdGljXHJcbiAqIEBtZXRob2Qgc3ViUmV2Q29uc3RcclxuICovXHJcbmV4cG9ydHMuc3ViUmV2Q29uc3QgPSBmdW5jdGlvbihkYXRhQSwgdmFsdWVCLCBkYXRhT3V0KSB7XHJcblx0dmFyIG4gPSBkYXRhT3V0Lmxlbmd0aDtcclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSkge1xyXG5cdFx0ZGF0YU91dFtpXSA9IHZhbHVlQiAtIGRhdGFBW2ldO1xyXG5cdH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBNdWx0aXBsaWVzIHR3byBhcnJheXMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJWaWV3fSBkYXRhQSAtIHRoZSBpbnB1dCBtdWx0aXBsaWNhbmQgYXJyYXkuXHJcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJWaWV3fSBkYXRhQiAtIHRoZSBpbnB1dCBtdWx0aXBsaWVyIGFycmF5LlxyXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyVmlld30gZGF0YU91dCAtIHRoZSBvdXRwdXQgcHJvZHVjdCBhcnJheS5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQHN0YXRpY1xyXG4gKiBAbWV0aG9kIG11bFxyXG4gKi9cclxuZXhwb3J0cy5tdWwgPSBmdW5jdGlvbihkYXRhQSwgZGF0YUIsIGRhdGFPdXQpIHtcclxuXHR2YXIgbiA9IGRhdGFPdXQubGVuZ3RoO1xyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKSB7XHJcblx0XHRkYXRhT3V0W2ldID0gZGF0YUFbaV0gKiBkYXRhQltpXTtcclxuXHR9XHJcbn07XHJcblxyXG4vKipcclxuICogTXVsdGlwbGllcyBhbiBhcnJheSBieSBhIGNvbnN0YW50LlxyXG4gKlxyXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyVmlld30gZGF0YUEgLSB0aGUgaW5wdXQgbXVsdGlwbGljYW5kIGFycmF5LlxyXG4gKiBAcGFyYW0ge051bWJlcn0gdmFsdWVCIC0gdGhlIG11bHRpcGxpZXIgY29uc3RhbnQuXHJcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJWaWV3fSBkYXRhT3V0IC0gdGhlIG91dHB1dCBwcm9kdWN0IGFycmF5LlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAc3RhdGljXHJcbiAqIEBtZXRob2QgbXVsQ29uc3RcclxuICovXHJcbmV4cG9ydHMubXVsQ29uc3QgPSBmdW5jdGlvbihkYXRhQSwgdmFsdWVCLCBkYXRhT3V0KSB7XHJcblx0dmFyIG4gPSBkYXRhT3V0Lmxlbmd0aDtcclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSkge1xyXG5cdFx0ZGF0YU91dFtpXSA9IGRhdGFBW2ldICogdmFsdWVCO1xyXG5cdH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBEaXZpZGVzIHR3byBhcnJheXMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJWaWV3fSBkYXRhQSAtIHRoZSBpbnB1dCBkaXZpZGVuZCBhcnJheS5cclxuICogQHBhcmFtIHtBcnJheUJ1ZmZlclZpZXd9IGRhdGFCIC0gdGhlIGlucHV0IGRpdmlzb3IgYXJyYXkuXHJcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJWaWV3fSBkYXRhT3V0IC0gdGhlIG91dHB1dCBxdW90aWVudCBhcnJheS5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQHN0YXRpY1xyXG4gKiBAbWV0aG9kIGRpdlxyXG4gKi9cclxuZXhwb3J0cy5kaXYgPSBmdW5jdGlvbihkYXRhQSwgZGF0YUIsIGRhdGFPdXQpIHtcclxuXHR2YXIgbiA9IGRhdGFPdXQubGVuZ3RoO1xyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKSB7XHJcblx0XHRkYXRhT3V0W2ldID0gZGF0YUFbaV0gLyBkYXRhQltpXTtcclxuXHR9XHJcbn07XHJcblxyXG4vKipcclxuICogRGl2aWRlcyBhbiBhcnJheSBieSBhIGNvbnN0YW50LlxyXG4gKlxyXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyVmlld30gZGF0YUEgLSB0aGUgaW5wdXQgZGl2aWRlbmQgYXJyYXkuXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZUIgLSB0aGUgZGl2aXNvciBjb25zdGFudC5cclxuICogQHBhcmFtIHtBcnJheUJ1ZmZlclZpZXd9IGRhdGFPdXQgLSB0aGUgb3V0cHV0IHF1b3RpZW50IGFycmF5LlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAc3RhdGljXHJcbiAqIEBtZXRob2QgZGl2Q29uc3RcclxuICovXHJcbmV4cG9ydHMuZGl2Q29uc3QgPSBmdW5jdGlvbihkYXRhQSwgdmFsdWVCLCBkYXRhT3V0KSB7XHJcblx0dmFyIG4gPSBkYXRhT3V0Lmxlbmd0aDtcclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSkge1xyXG5cdFx0ZGF0YU91dFtpXSA9IGRhdGFBW2ldIC8gdmFsdWVCO1xyXG5cdH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBEaXZpZGVzIGEgY29uc3RhbnQgYnkgYW4gYXJyYXkuXHJcbiAqXHJcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJWaWV3fSBkYXRhQSAtIHRoZSBpbnB1dCBkaXZpc29yIGFycmF5LlxyXG4gKiBAcGFyYW0ge051bWJlcn0gdmFsdWVCIC0gdGhlIGRpdmlkZW5kIGNvbnN0YW50LlxyXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyVmlld30gZGF0YU91dCAtIHRoZSBvdXRwdXQgcXVvdGllbnQgYXJyYXkuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBzdGF0aWNcclxuICogQG1ldGhvZCBkaXZSZXZDb25zdFxyXG4gKi9cclxuZXhwb3J0cy5kaXZSZXZDb25zdCA9IGZ1bmN0aW9uKGRhdGFBLCB2YWx1ZUIsIGRhdGFPdXQpIHtcclxuXHR2YXIgbiA9IGRhdGFPdXQubGVuZ3RoO1xyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKSB7XHJcblx0XHRkYXRhT3V0W2ldID0gdmFsdWVCIC8gZGF0YUFbaV07XHJcblx0fVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIE5lZ2F0ZXMgYW4gYXJyYXkuXHJcbiAqXHJcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJWaWV3fSBkYXRhQSAtIHRoZSBpbnB1dCBhcnJheS5cclxuICogQHBhcmFtIHtBcnJheUJ1ZmZlclZpZXd9IGRhdGFPdXQgLSB0aGUgb3V0cHV0IGFycmF5LlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAc3RhdGljXHJcbiAqIEBtZXRob2QgbmVnXHJcbiAqL1xyXG5leHBvcnRzLm5lZyA9IGZ1bmN0aW9uKGRhdGFBLCBkYXRhT3V0KSB7XHJcblx0dmFyIG4gPSBkYXRhT3V0Lmxlbmd0aDtcclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSkge1xyXG5cdFx0ZGF0YU91dFtpXSA9IC1kYXRhQVtpXTtcclxuXHR9XHJcbn07XHJcblxyXG4vKipcclxuICogQ29tcHV0ZXMgYWJzb2x1dGUgdmFsdWUgb2YgYXJyYXkgZWxlbWVudHMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJWaWV3fSBkYXRhQSAtIHRoZSBpbnB1dCBhcnJheS5cclxuICogQHBhcmFtIHtBcnJheUJ1ZmZlclZpZXd9IGRhdGFPdXQgLSB0aGUgb3V0cHV0IGFycmF5LlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAc3RhdGljXHJcbiAqIEBtZXRob2QgYWJzXHJcbiAqL1xyXG5leHBvcnRzLmFicyA9IGZ1bmN0aW9uKGRhdGFBLCBkYXRhT3V0KSB7XHJcblx0dmFyIG4gPSBkYXRhT3V0Lmxlbmd0aDtcclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSkge1xyXG5cdFx0ZGF0YU91dFtpXSA9IE1hdGguYWJzKGRhdGFBW2ldKTtcclxuXHR9XHJcbn07XHJcblxyXG4vKipcclxuICogRXhwb25lbnRpYXRlcyBhcnJheSBlbGVtZW50cy5cclxuICpcclxuICogQHBhcmFtIHtBcnJheUJ1ZmZlclZpZXd9IGRhdGFBIC0gdGhlIGlucHV0IGFycmF5LlxyXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyVmlld30gZGF0YU91dCAtIHRoZSBvdXRwdXQgYXJyYXkuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBzdGF0aWNcclxuICogQG1ldGhvZCBleHBcclxuICovXHJcbmV4cG9ydHMuZXhwID0gZnVuY3Rpb24oZGF0YUEsIGRhdGFPdXQpIHtcclxuXHR2YXIgbiA9IGRhdGFPdXQubGVuZ3RoO1xyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKSB7XHJcblx0XHRkYXRhT3V0W2ldID0gTWF0aC5leHAoZGF0YUFbaV0pO1xyXG5cdH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb21wdXRlcyBsb2dhcml0aG0gb2YgYXJyYXkgZWxlbWVudHMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJWaWV3fSBkYXRhQSAtIHRoZSBpbnB1dCBhcnJheS5cclxuICogQHBhcmFtIHtBcnJheUJ1ZmZlclZpZXd9IGRhdGFPdXQgLSB0aGUgb3V0cHV0IGFycmF5LlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAc3RhdGljXHJcbiAqIEBtZXRob2QgbG9nXHJcbiAqL1xyXG5leHBvcnRzLmxvZyA9IGZ1bmN0aW9uKGRhdGFBLCBkYXRhT3V0KSB7XHJcblx0dmFyIG4gPSBkYXRhT3V0Lmxlbmd0aDtcclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSkge1xyXG5cdFx0ZGF0YU91dFtpXSA9IE1hdGgubG9nKGRhdGFBW2ldKTtcclxuXHR9XHJcbn07XHJcblxyXG4vKipcclxuICogQ29tcHV0ZXMgc3F1YXJlIHJvb3Qgb2YgYXJyYXkgZWxlbWVudHMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJWaWV3fSBkYXRhQSAtIHRoZSBpbnB1dCBhcnJheS5cclxuICogQHBhcmFtIHtBcnJheUJ1ZmZlclZpZXd9IGRhdGFPdXQgLSB0aGUgb3V0cHV0IGFycmF5LlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAc3RhdGljXHJcbiAqIEBtZXRob2Qgc3FydFxyXG4gKi9cclxuZXhwb3J0cy5zcXJ0ID0gZnVuY3Rpb24oZGF0YUEsIGRhdGFPdXQpIHtcclxuXHR2YXIgbiA9IGRhdGFPdXQubGVuZ3RoO1xyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKSB7XHJcblx0XHRkYXRhT3V0W2ldID0gTWF0aC5zcXJ0KGRhdGFBW2ldKTtcclxuXHR9XHJcbn07XHJcblxyXG4vKipcclxuICogU3F1YXJlcyBhcnJheSBlbGVtZW50cy5cclxuICpcclxuICogQHBhcmFtIHtBcnJheUJ1ZmZlclZpZXd9IGRhdGFBIC0gdGhlIGlucHV0IGFycmF5LlxyXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyVmlld30gZGF0YU91dCAtIHRoZSBvdXRwdXQgYXJyYXkuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBzdGF0aWNcclxuICogQG1ldGhvZCBzcXVhcmVcclxuICovXHJcbmV4cG9ydHMuc3F1YXJlID0gZnVuY3Rpb24oZGF0YUEsIGRhdGFPdXQpIHtcclxuXHR2YXIgbiA9IGRhdGFPdXQubGVuZ3RoO1xyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKSB7XHJcblx0XHR2YXIgYSA9IGRhdGFBW2ldO1xyXG5cdFx0ZGF0YU91dFtpXSA9IGEgKiBhO1xyXG5cdH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb21wdXRlcyB0aGUgbWluaW11bSB2YWx1ZSBvZiBlbGVtZW50cyBpbiBhbiBhcnJheS5cclxuICpcclxuICogQHBhcmFtIHtBcnJheUJ1ZmZlclZpZXd9IGRhdGFBIC0gdGhlIGlucHV0IGFycmF5IHRvIGNvbXB1dGUgbWluaW11bSBvbi5cclxuICogQHBhcmFtIHtBcnJheUJ1ZmZlclZpZXd9IGRhdGFPdXQgLSB0aGUgb3V0cHV0IGFycmF5IHRvIHN0b3JlIHRoZSBtaW5pbXVtIGF0LlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAc3RhdGljXHJcbiAqIEBtZXRob2QgbWluXHJcbiAqL1xyXG5leHBvcnRzLm1pbiA9IGZ1bmN0aW9uKGRhdGFBLCBkYXRhT3V0KSB7XHJcblx0LyogQ29tcHV0YXRpb24gb2YgYWxsLWFycmF5IG1pbiAqL1xyXG5cdHZhciBsZW5ndGhBID0gZGF0YUEubGVuZ3RoO1xyXG5cdHZhciByZXN1bHQgPSBkYXRhQVswXTtcclxuXHRmb3IgKHZhciBpID0gMTsgaSA8IGxlbmd0aEE7ICsraSkge1xyXG5cdFx0cmVzdWx0ID0gTWF0aC5taW4ocmVzdWx0LCBkYXRhQVtpXSk7XHJcblx0fVxyXG5cdGRhdGFPdXRbMF0gPSByZXN1bHQ7XHJcbn07XHJcblxyXG4vKipcclxuICogQ29tcHV0ZXMgdGhlIG1heGltdW0gdmFsdWUgb2YgZWxlbWVudHMgaW4gYW4gYXJyYXkuXHJcbiAqXHJcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJWaWV3fSBkYXRhQSAtIHRoZSBpbnB1dCBhcnJheSB0byBjb21wdXRlIG1heGltdW0gb24uXHJcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJWaWV3fSBkYXRhT3V0IC0gdGhlIG91dHB1dCBhcnJheSB0byBzdG9yZSB0aGUgbWF4aW11bSBhdC5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQHN0YXRpY1xyXG4gKiBAbWV0aG9kIG1heFxyXG4gKi9cclxuZXhwb3J0cy5tYXggPSBmdW5jdGlvbihkYXRhQSwgZGF0YU91dCkge1xyXG5cdC8qIENvbXB1dGF0aW9uIG9mIGFsbC1hcnJheSBtaW4gKi9cclxuXHR2YXIgbGVuZ3RoQSA9IGRhdGFBLmxlbmd0aDtcclxuXHR2YXIgcmVzdWx0ID0gZGF0YUFbMF07XHJcblx0Zm9yICh2YXIgaSA9IDE7IGkgPCBsZW5ndGhBOyArK2kpIHtcclxuXHRcdHJlc3VsdCA9IE1hdGgubWF4KHJlc3VsdCwgZGF0YUFbaV0pO1xyXG5cdH1cclxuXHRkYXRhT3V0WzBdID0gcmVzdWx0O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvbXB1dGVzIHRoZSBzdW0gb2YgZWxlbWVudHMgaW4gYW4gYXJyYXkuXHJcbiAqXHJcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJWaWV3fSBkYXRhQSAtIHRoZSBpbnB1dCBhcnJheSB3aXRoIGVsZW1lbnRzIHRvIHN1bSB1cC5cclxuICogQHBhcmFtIHtBcnJheUJ1ZmZlclZpZXd9IGRhdGFPdXQgLSB0aGUgb3V0cHV0IGFycmF5IHRvIHN0b3JlIHRoZSBzdW0gYXQuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBzdGF0aWNcclxuICogQG1ldGhvZCBtaW5cclxuICovXHJcbmV4cG9ydHMuc3VtID0gZnVuY3Rpb24oZGF0YUEsIGRhdGFPdXQpIHtcclxuXHR2YXIgbGVuZ3RoQSA9IGRhdGFBLmxlbmd0aDtcclxuXHR2YXIgcmVzdWx0ID0gMC4wO1xyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoQTsgKytpKSB7XHJcblx0XHRyZXN1bHQgKz0gZGF0YUFbaV07XHJcblx0fVxyXG5cdGRhdGFPdXRbMF0gPSByZXN1bHQ7XHJcbn07XHJcblxyXG4vKipcclxuICogQ29tcHV0ZXMgdGhlIG1pbmltdW0gdmFsdWUgb2YgZWxlbWVudHMgYWxvbmcgYW4gYXhpcy5cclxuICpcclxuICogQHBhcmFtIHtBcnJheUJ1ZmZlclZpZXd9IGRhdGFBIC0gdGhlIGlucHV0IGFycmF5IHRvIGNvbXB1dGUgbWluaW1hIG9uLlxyXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyVmlld30gZGF0YU91dCAtIHRoZSBvdXRwdXQgYXJyYXkgdG8gc3RvcmUgdGhlIG1pbmltYSBhdC5cclxuICogQHBhcmFtIHtOdW1iZXJ9IG91dGVyU3RyaWRlIC0gdGhlIHByb2R1Y3Qgb2YgaW5wdXQgYXJyYXkgZGltZW5zaW9ucyBwcmVjZWVkaW5nIHRoZSByZWR1Y3Rpb24gZGltZW5zaW9uLlxyXG4gKiBAcGFyYW0ge051bWJlcn0gaW5uZXJTdHJpZGUgLSB0aGUgcHJvZHVjdCBvZiBpbnB1dCBhcnJheSBkaW1lbnNpb25zIGZvbGxvd2luZyB0aGUgcmVkdWN0aW9uIGRpbWVuc2lvbi5cclxuICogQHBhcmFtIHtOdW1iZXJ9IHJlZHVjdGlvbkRpbSAtIHRoZSBsZW5ndGggb2YgaW5wdXQgYXJyYXkgYWxvbmcgdGhlIHJlZHVjdGlvbiBkaW1lbnNpb24uXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBzdGF0aWNcclxuICogQG1ldGhvZCBheGlzTWluXHJcbiAqL1xyXG5leHBvcnRzLmF4aXNNaW4gPSBmdW5jdGlvbihkYXRhQSwgZGF0YU91dCwgb3V0ZXJTdHJpZGUsIGlubmVyU3RyaWRlLCByZWR1Y3Rpb25EaW0pIHtcclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IG91dGVyU3RyaWRlOyArK2kpIHtcclxuXHRcdGZvciAodmFyIGsgPSAwOyBrIDwgaW5uZXJTdHJpZGU7ICsraykge1xyXG5cdFx0XHR2YXIgb2Zmc2V0ID0gaSAqIHJlZHVjdGlvbkRpbSAqIGlubmVyU3RyaWRlICsgaztcclxuXHRcdFx0dmFyIGN1cnJlbnRNaW4gPSBkYXRhQVtvZmZzZXRdO1xyXG5cdFx0XHRmb3IgKHZhciBqID0gMTsgaiA8IHJlZHVjdGlvbkRpbTsgKytqKSB7XHJcblx0XHRcdFx0b2Zmc2V0ICs9IGlubmVyU3RyaWRlO1xyXG5cdFx0XHRcdGN1cnJlbnRNaW4gPSBNYXRoLm1pbihjdXJyZW50TWluLCBkYXRhQVtvZmZzZXRdKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRkYXRhT3V0W2kgKiBpbm5lclN0cmlkZSArIGtdID0gY3VycmVudE1pbjtcclxuXHRcdH1cclxuXHR9XHJcbn07XHJcblxyXG4vKipcclxuICogQ29tcHV0ZXMgdGhlIG1heGltdW0gdmFsdWUgb2YgZWxlbWVudHMgYWxvbmcgYW4gYXhpcy5cclxuICpcclxuICogQHBhcmFtIHtBcnJheUJ1ZmZlclZpZXd9IGRhdGFBIC0gdGhlIGlucHV0IGFycmF5IHRvIGNvbXB1dGUgbWF4aW1hIG9uLlxyXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyVmlld30gZGF0YU91dCAtIHRoZSBvdXRwdXQgYXJyYXkgdG8gc3RvcmUgdGhlIG1heGltYSBhdC5cclxuICogQHBhcmFtIHtOdW1iZXJ9IG91dGVyU3RyaWRlIC0gdGhlIHByb2R1Y3Qgb2YgaW5wdXQgYXJyYXkgZGltZW5zaW9ucyBwcmVjZWVkaW5nIHRoZSByZWR1Y3Rpb24gZGltZW5zaW9uLlxyXG4gKiBAcGFyYW0ge051bWJlcn0gaW5uZXJTdHJpZGUgLSB0aGUgcHJvZHVjdCBvZiBpbnB1dCBhcnJheSBkaW1lbnNpb25zIGZvbGxvd2luZyB0aGUgcmVkdWN0aW9uIGRpbWVuc2lvbi5cclxuICogQHBhcmFtIHtOdW1iZXJ9IHJlZHVjdGlvbkRpbSAtIHRoZSBsZW5ndGggb2YgaW5wdXQgYXJyYXkgYWxvbmcgdGhlIHJlZHVjdGlvbiBkaW1lbnNpb24uXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBzdGF0aWNcclxuICogQG1ldGhvZCBheGlzTWF4XHJcbiAqL1xyXG5leHBvcnRzLmF4aXNNYXggPSBmdW5jdGlvbihkYXRhQSwgZGF0YU91dCwgb3V0ZXJTdHJpZGUsIGlubmVyU3RyaWRlLCByZWR1Y3Rpb25EaW0pIHtcclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IG91dGVyU3RyaWRlOyArK2kpIHtcclxuXHRcdGZvciAodmFyIGsgPSAwOyBrIDwgaW5uZXJTdHJpZGU7ICsraykge1xyXG5cdFx0XHR2YXIgb2Zmc2V0ID0gaSAqIHJlZHVjdGlvbkRpbSAqIGlubmVyU3RyaWRlICsgaztcclxuXHRcdFx0dmFyIGN1cnJlbnRNYXggPSBkYXRhQVtvZmZzZXRdO1xyXG5cdFx0XHRmb3IgKHZhciBqID0gMTsgaiA8IHJlZHVjdGlvbkRpbTsgKytqKSB7XHJcblx0XHRcdFx0b2Zmc2V0ICs9IGlubmVyU3RyaWRlO1xyXG5cdFx0XHRcdGN1cnJlbnRNYXggPSBNYXRoLm1heChjdXJyZW50TWF4LCBkYXRhQVtvZmZzZXRdKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRkYXRhT3V0W2kgKiBpbm5lclN0cmlkZSArIGtdID0gY3VycmVudE1heDtcclxuXHRcdH1cclxuXHR9XHJcbn07XHJcblxyXG4vKipcclxuICogQ29tcHV0ZXMgdGhlIHN1bSBvZiBlbGVtZW50cyBhbG9uZyBhbiBheGlzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyVmlld30gZGF0YUEgLSB0aGUgaW5wdXQgYXJyYXkgdG8gc3VtIHVwLlxyXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyVmlld30gZGF0YU91dCAtIHRoZSBvdXRwdXQgYXJyYXkgdG8gc3RvcmUgdGhlIHN1bXMgYXQuXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBvdXRlclN0cmlkZSAtIHRoZSBwcm9kdWN0IG9mIGlucHV0IGFycmF5IGRpbWVuc2lvbnMgcHJlY2VlZGluZyB0aGUgcmVkdWN0aW9uIGRpbWVuc2lvbi5cclxuICogQHBhcmFtIHtOdW1iZXJ9IGlubmVyU3RyaWRlIC0gdGhlIHByb2R1Y3Qgb2YgaW5wdXQgYXJyYXkgZGltZW5zaW9ucyBmb2xsb3dpbmcgdGhlIHJlZHVjdGlvbiBkaW1lbnNpb24uXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSByZWR1Y3Rpb25EaW0gLSB0aGUgbGVuZ3RoIG9mIGlucHV0IGFycmF5IGFsb25nIHRoZSByZWR1Y3Rpb24gZGltZW5zaW9uLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAc3RhdGljXHJcbiAqIEBtZXRob2QgYXhpc1N1bVxyXG4gKi9cclxuZXhwb3J0cy5heGlzU3VtID0gZnVuY3Rpb24oZGF0YUEsIGRhdGFPdXQsIG91dGVyU3RyaWRlLCBpbm5lclN0cmlkZSwgcmVkdWN0aW9uRGltKSB7XHJcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBvdXRlclN0cmlkZTsgKytpKSB7XHJcblx0XHRmb3IgKHZhciBrID0gMDsgayA8IGlubmVyU3RyaWRlOyArK2spIHtcclxuXHRcdFx0dmFyIG9mZnNldCA9IGkgKiByZWR1Y3Rpb25EaW0gKiBpbm5lclN0cmlkZSArIGs7XHJcblx0XHRcdHZhciBjdXJyZW50U3VtID0gZGF0YUFbb2Zmc2V0XTtcclxuXHRcdFx0Zm9yICh2YXIgaiA9IDE7IGogPCByZWR1Y3Rpb25EaW07ICsraikge1xyXG5cdFx0XHRcdG9mZnNldCArPSBpbm5lclN0cmlkZTtcclxuXHRcdFx0XHRjdXJyZW50U3VtICs9IGRhdGFBW29mZnNldF07XHJcblx0XHRcdH1cclxuXHRcdFx0ZGF0YU91dFtpICogaW5uZXJTdHJpZGUgKyBrXSA9IGN1cnJlbnRTdW07XHJcblx0XHR9XHJcblx0fVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvbXB1dGVzIHRoZSBkb3QgcHJvZHVjdCBvZiB0d28gTi1kaW1lbnNpb25hbCBhcnJheXMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJWaWV3fSBkYXRhQSAtIGFuIGlucHV0IG11bHRpcGxpY2FuZCBhcnJheS5cclxuICogQHBhcmFtIHtBcnJheUJ1ZmZlclZpZXd9IGRhdGFCIC0gYW4gaW5wdXQgbXVsdGlwbGllciBhcnJheS5cclxuICogQHBhcmFtIHtBcnJheUJ1ZmZlclZpZXd9IGRhdGFPdXQgLSB0aGUgb3V0cHV0IHByb2R1Y3QgYXJyYXkuXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBzdHJpZGVBIC0gdGhlIHByb2R1Y3Qgb2YgdGhlIHRoZSBtdWx0aXBsaWNhbmQgZGltZW5zaW9ucyBwcmVjZWVkaW5nIHRoZSByZWR1Y3Rpb24gZGltZW5zaW9uLlxyXG4gKiBAcGFyYW0ge051bWJlcn0gb3V0ZXJTdHJpZGVCIC0gdGhlIHByb2R1Y3Qgb2YgdGhlIG11bHRpcGxpZXIgZGltZW5zaW9ucyBwcmVjZWVkaW5nIHRoZSByZWR1Y3Rpb24gZGltZW5zaW9uLlxyXG4gKiBAcGFyYW0ge051bWJlcn0gaW5uZXJTdHJpZGVCIC0gdGhlIHByb2R1Y3Qgb2YgdGhlIG11bHRpcGxpZXIgZGltZW5zaW9ucyBmb2xsb3dpbmcgdGhlIHJlZHVjdGlvbiBkaW1lbnNpb24uXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSByZWR1Y3Rpb25EaW0gLSB0aGUgbGVuZ3RoIG9mIGlucHV0cyBhcnJheXMgYWxvbmcgdGhlIHJlZHVjdGlvbiBkaW1lbnNpb24uXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBzdGF0aWNcclxuICogQG1ldGhvZCBkb3RcclxuICovXHJcbmV4cG9ydHMuZG90ID0gZnVuY3Rpb24oZGF0YUEsIGRhdGFCLCBkYXRhT3V0LCBzdHJpZGVBLCBvdXRlclN0cmlkZUIsIGlubmVyU3RyaWRlQiwgcmVkdWN0aW9uRGltKSB7XHJcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzdHJpZGVBOyArK2kpIHtcclxuXHRcdGZvciAodmFyIGogPSAwOyBqIDwgcmVkdWN0aW9uRGltOyArK2opIHtcclxuXHRcdFx0Zm9yICh2YXIgayA9IDA7IGsgPCBvdXRlclN0cmlkZUI7ICsraykge1xyXG5cdFx0XHRcdGZvciAodmFyIGwgPSAwOyBsIDwgaW5uZXJTdHJpZGVCOyArK2wpIHtcclxuXHRcdFx0XHRcdGRhdGFPdXRbKGkqb3V0ZXJTdHJpZGVCICsgaykgKiBpbm5lclN0cmlkZUIgKyBsXSArPSBkYXRhQVtpKnJlZHVjdGlvbkRpbStqXSAqIGRhdGFCWyhrKnJlZHVjdGlvbkRpbStqKSppbm5lclN0cmlkZUIrbF07XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlcGxpY2F0ZXMgYXJyYXkgZWxlbWVudHMgYWxvbmcgYW4gYXhpcy5cclxuICpcclxuICogQHBhcmFtIHtBcnJheUJ1ZmZlclZpZXd9IGRhdGFBIC0gdGhlIGlucHV0IGFycmF5LlxyXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyVmlld30gZGF0YU91dCAtIHRoZSBvdXRwdXQgYXJyYXkgZm9yIHJlcGVhdGVkIGVsZW1lbnRzLlxyXG4gKiBAcGFyYW0ge051bWJlcn0gb3V0ZXJTdHJpZGUgLSB0aGUgcHJvZHVjdCBvZiBpbnB1dCBhcnJheSBkaW1lbnNpb25zIHByZWNlZWRpbmcgdGhlIGV4cGFuc2lvbiBkaW1lbnNpb24uXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBpbm5lclN0cmlkZSAtIHRoZSBwcm9kdWN0IG9mIGlucHV0IGFycmF5IGRpbWVuc2lvbnMgZm9sbG93aW5nIHRoZSBleHBhbnNpb24gZGltZW5zaW9uLlxyXG4gKiBAcGFyYW0ge051bWJlcn0gZXhwYW5zaW9uRGltIC0gdGhlIGxlbmd0aCBvZiBpbnB1dCBhcnJheSBhbG9uZyB0aGUgZXhwYW5zaW9uIGRpbWVuc2lvbi5cclxuICogQHBhcmFtIHtOdW1iZXJ9IHJlcGVhdHMgLSB0aGUgbnVtYmVyIG9mIHRpbWVzIGVhY2ggZWxlbWVudCB3aWxsIGJlIHJlcGxpY2F0ZWQuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBzdGF0aWNcclxuICogQG1ldGhvZCByZXBlYXRcclxuICovXHJcbmV4cG9ydHMucmVwZWF0ID0gZnVuY3Rpb24oZGF0YUEsIGRhdGFPdXQsIG91dGVyU3RyaWRlLCBpbm5lclN0cmlkZSwgZXhwYW5zaW9uRGltLCByZXBlYXRzKSB7XHJcblx0aWYgKGlubmVyU3RyaWRlIDwgcmVwZWF0cykge1xyXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBvdXRlclN0cmlkZTsgKytpKSB7XHJcblx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgZXhwYW5zaW9uRGltOyArK2opIHtcclxuXHRcdFx0XHRmb3IgKHZhciBrID0gMDsgayA8IGlubmVyU3RyaWRlOyArK2spIHtcclxuXHRcdFx0XHRcdHZhciB2YWx1ZUEgPSBkYXRhQVsoaSAqIGV4cGFuc2lvbkRpbSArIGopICogaW5uZXJTdHJpZGUgKyBrXTtcclxuXHRcdFx0XHRcdGZvciAodmFyIGMgPSAwOyBjIDwgcmVwZWF0czsgKytjKSB7XHJcblx0XHRcdFx0XHRcdGRhdGFPdXRbKChpICogZXhwYW5zaW9uRGltICsgaikgKiByZXBlYXRzICsgYykgKiBpbm5lclN0cmlkZSArIGtdID0gdmFsdWVBO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0gZWxzZSB7XHJcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG91dGVyU3RyaWRlOyArK2kpIHtcclxuXHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBleHBhbnNpb25EaW07ICsraikge1xyXG5cdFx0XHRcdHZhciByb3dBID0gZGF0YUEuc3ViYXJyYXkoKGkgKiBleHBhbnNpb25EaW0gKyBqKSAqIGlubmVyU3RyaWRlLCAoaSAqIGV4cGFuc2lvbkRpbSArIGogKyAxKSAqIGlubmVyU3RyaWRlKTtcclxuXHRcdFx0XHRmb3IgKHZhciBjID0gMDsgYyA8IHJlcGVhdHM7ICsrYykge1xyXG5cdFx0XHRcdFx0ZGF0YU91dC5zZXQocm93QSwgKChpICogZXhwYW5zaW9uRGltICsgaikgKiByZXBlYXRzICsgYykgKiBpbm5lclN0cmlkZSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG59O1xyXG4iLCJcbnZhciBwcm90b2J1ZmpzID0gcmVxdWlyZShcInByb3RvYnVmanNcIik7XG5wcm90b2J1ZmpzLmNvbnZlcnRGaWVsZHNUb0NhbWVsQ2FzZSA9IHRydWU7XG52YXIgcmVxdWVzdHNQcm90byA9IFwicGFja2FnZSBmdXJpb3VzO1xcclxcblxcclxcbm9wdGlvbiBvcHRpbWl6ZV9mb3IgPSBMSVRFX1JVTlRJTUU7XFxyXFxuXFxyXFxuZW51bSBEYXRhVHlwZSB7XFxyXFxuXFx0RkxPQVQ2NCA9IDA7XFxyXFxuXFx0RkxPQVQzMiA9IDE7XFxyXFxufVxcclxcblxcclxcbm1lc3NhZ2UgUmVxdWVzdCB7XFxyXFxuXFx0ZW51bSBUeXBlIHtcXHJcXG5cXHRcXHRFTVBUWV9BUlJBWSAgICAgICAgICAgICAgPSAgMDtcXHJcXG5cXHRcXHREQVRBX0FSUkFZICAgICAgICAgICAgICAgPSAgMTtcXHJcXG5cXHRcXHRDT05TVF9BUlJBWSAgICAgICAgICAgICAgPSAgMjtcXHJcXG5cXHRcXHRMSU5TUEFDRSAgICAgICAgICAgICAgICAgPSAgMztcXHJcXG5cXHRcXHRSRVNIQVBFICAgICAgICAgICAgICAgICAgPSAgNDtcXHJcXG5cXHRcXHRSRVBFQVQgICAgICAgICAgICAgICAgICAgPSAgNTtcXHJcXG5cXHRcXHRERUFMTE9DQVRFICAgICAgICAgICAgICAgPSAgNjtcXHJcXG5cXHRcXHRGRVRDSCAgICAgICAgICAgICAgICAgICAgPSAgNztcXHJcXG5cXHRcXHRCQVJSSUVSICAgICAgICAgICAgICAgICAgPSAgODtcXHJcXG5cXHRcXHRJTkZPICAgICAgICAgICAgICAgICAgICAgPSAgOTtcXHJcXG5cXHRcXHRCSU5BUllfT1BFUkFUSU9OICAgICAgICAgPSAxMDtcXHJcXG5cXHRcXHRCSU5BUllfQ09OU1RfT1BFUkFUSU9OICAgPSAxMTtcXHJcXG5cXHRcXHRVTkFSWV9PUEVSQVRJT04gICAgICAgICAgPSAxMjtcXHJcXG5cXHRcXHRSRURVQ1RJT05fT1BFUkFUSU9OICAgICAgPSAxMztcXHJcXG5cXHRcXHRBWElTX1JFRFVDVElPTl9PUEVSQVRJT04gPSAxNDtcXHJcXG5cXHRcXHRET1RfT1BFUkFUSU9OICAgICAgICAgICAgPSAxNTtcXHJcXG5cXHR9XFxyXFxuXFx0cmVxdWlyZWQgZml4ZWQzMiAgICAgICAgICAgICAgICAgICAgIGlkICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9ICAxO1xcclxcblxcdHJlcXVpcmVkIFR5cGUgICAgICAgICAgICAgICAgICAgICAgICB0eXBlICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAgMjtcXHJcXG5cXHJcXG5cXHRvcHRpb25hbCBFbXB0eUFycmF5UmVxdWVzdCAgICAgICAgICAgZW1wdHlfYXJyYXlfcmVxdWVzdCAgICAgICAgICAgID0gIDM7XFxyXFxuXFx0b3B0aW9uYWwgRGF0YUFycmF5UmVxdWVzdCAgICAgICAgICAgIGRhdGFfYXJyYXlfcmVxdWVzdCAgICAgICAgICAgICA9ICA0O1xcclxcblxcdG9wdGlvbmFsIENvbnN0QXJyYXlSZXF1ZXN0ICAgICAgICAgICBjb25zdF9hcnJheV9yZXF1ZXN0ICAgICAgICAgICAgPSAgNTtcXHJcXG5cXHRvcHRpb25hbCBMaW5zcGFjZVJlcXVlc3QgICAgICAgICAgICAgbGluc3BhY2VfcmVxdWVzdCAgICAgICAgICAgICAgID0gIDY7XFxyXFxuXFx0b3B0aW9uYWwgUmVzaGFwZVJlcXVlc3QgICAgICAgICAgICAgIHJlc2hhcGVfcmVxdWVzdCAgICAgICAgICAgICAgICA9ICA3O1xcclxcblxcdG9wdGlvbmFsIFJlcGVhdFJlcXVlc3QgICAgICAgICAgICAgICByZXBlYXRfcmVxdWVzdCAgICAgICAgICAgICAgICAgPSAgODtcXHJcXG5cXHRvcHRpb25hbCBEZWFsbG9jYXRlUmVxdWVzdCAgICAgICAgICAgZGVhbGxvY2F0ZV9yZXF1ZXN0ICAgICAgICAgICAgID0gIDk7XFxyXFxuXFx0b3B0aW9uYWwgRmV0Y2hSZXF1ZXN0ICAgICAgICAgICAgICAgIGZldGNoX3JlcXVlc3QgICAgICAgICAgICAgICAgICA9IDEwO1xcclxcblxcdG9wdGlvbmFsIEJpbmFyeU9wZXJhdGlvblJlcXVlc3QgICAgICBiaW5hcnlfb3BlcmF0aW9uX3JlcXVlc3QgICAgICAgPSAxMTtcXHJcXG5cXHRvcHRpb25hbCBCaW5hcnlDb25zdE9wZXJhdGlvblJlcXVlc3QgYmluYXJ5X2NvbnN0X29wZXJhdGlvbl9yZXF1ZXN0ID0gMTI7XFxyXFxuXFx0b3B0aW9uYWwgVW5hcnlPcGVyYXRpb25SZXF1ZXN0ICAgICAgIHVuYXJ5X29wZXJhdGlvbl9yZXF1ZXN0ICAgICAgICA9IDEzO1xcclxcblxcdG9wdGlvbmFsIFJlZHVjdGlvblJlcXVlc3QgICAgICAgICAgICByZWR1Y3Rpb25fcmVxdWVzdCAgICAgICAgICAgICAgPSAxNDtcXHJcXG5cXHRvcHRpb25hbCBBeGlzUmVkdWN0aW9uUmVxdWVzdCAgICAgICAgYXhpc19yZWR1Y3Rpb25fcmVxdWVzdCAgICAgICAgID0gMTU7XFxyXFxuXFx0b3B0aW9uYWwgRG90T3BlcmF0aW9uUmVxdWVzdCAgICAgICAgIGRvdF9vcGVyYXRpb25fcmVxdWVzdCAgICAgICAgICA9IDE2O1xcclxcbn1cXHJcXG5cXHJcXG5tZXNzYWdlIEVtcHR5QXJyYXlSZXF1ZXN0IHtcXHJcXG5cXHRyZXF1aXJlZCBmaXhlZDMyICBpZF9vdXQgICAgICA9IDE7XFxyXFxuXFx0cmVwZWF0ZWQgdWludDMyICAgc2hhcGUgICAgICAgPSAyIFtwYWNrZWQ9dHJ1ZV07XFxyXFxuXFx0cmVxdWlyZWQgRGF0YVR5cGUgZGF0YV90eXBlICAgPSAzO1xcclxcbn1cXHJcXG5cXHJcXG5tZXNzYWdlIERhdGFBcnJheVJlcXVlc3Qge1xcclxcblxcdHJlcXVpcmVkIGZpeGVkMzIgIGlkX291dCAgICAgID0gMTtcXHJcXG5cXHRyZXBlYXRlZCB1aW50MzIgICBzaGFwZSAgICAgICA9IDIgW3BhY2tlZD10cnVlXTtcXHJcXG5cXHRyZXF1aXJlZCBEYXRhVHlwZSBkYXRhX3R5cGUgICA9IDM7XFxyXFxuXFx0cmVxdWlyZWQgYnl0ZXMgICAgZGF0YV9idWZmZXIgPSA0O1xcclxcbn1cXHJcXG5cXHJcXG5tZXNzYWdlIENvbnN0QXJyYXlSZXF1ZXN0IHtcXHJcXG5cXHRyZXF1aXJlZCBmaXhlZDMyICBpZF9vdXQgICAgICA9IDE7XFxyXFxuXFx0cmVwZWF0ZWQgdWludDMyICAgc2hhcGUgICAgICAgPSAyIFtwYWNrZWQ9dHJ1ZV07XFxyXFxuXFx0cmVxdWlyZWQgRGF0YVR5cGUgZGF0YV90eXBlICAgPSAzO1xcclxcblxcdHJlcXVpcmVkIGRvdWJsZSAgIGZpbGxfdmFsdWUgID0gNDtcXHJcXG59XFxyXFxuXFxyXFxubWVzc2FnZSBMaW5zcGFjZVJlcXVlc3Qge1xcclxcblxcdHJlcXVpcmVkIHNmaXhlZDMyICBpZF9vdXQgICAgID0gMTtcXHJcXG5cXHRyZXF1aXJlZCBkb3VibGUgICAgc3RhcnQgICAgICA9IDI7XFxyXFxuXFx0cmVxdWlyZWQgZG91YmxlICAgIHN0b3AgICAgICAgPSAzO1xcclxcblxcdHJlcXVpcmVkIHVpbnQzMiAgICBzYW1wbGVzICAgID0gNDtcXHJcXG5cXHRyZXF1aXJlZCBib29sICAgICAgY2xvc2VkICAgICA9IDU7XFxyXFxuXFx0cmVxdWlyZWQgRGF0YVR5cGUgIGRhdGFfdHlwZSAgPSA2O1xcclxcbn1cXHJcXG5cXHJcXG5tZXNzYWdlIFJlc2hhcGVSZXF1ZXN0IHtcXHJcXG5cXHRyZXF1aXJlZCBzZml4ZWQzMiAgaWRfYSAgICAgID0gMTtcXHJcXG5cXHRyZXF1aXJlZCBmaXhlZDMyICAgaWRfb3V0ICAgID0gMjtcXHJcXG5cXHRyZXBlYXRlZCB1aW50MzIgICAgc2hhcGVfb3V0ID0gMyBbcGFja2VkPXRydWVdO1xcclxcbn1cXHJcXG5cXHJcXG5tZXNzYWdlIFJlcGVhdFJlcXVlc3Qge1xcclxcblxcdHJlcXVpcmVkIHNmaXhlZDMyIGlkX2EgICAgPSAxO1xcclxcblxcdHJlcXVpcmVkIGZpeGVkMzIgIGlkX291dCAgPSAyO1xcclxcblxcdHJlcXVpcmVkIHVpbnQzMiAgIGF4aXMgICAgPSAzO1xcclxcblxcdHJlcXVpcmVkIHVpbnQzMiAgIHJlcGVhdHMgPSA0O1xcclxcbn1cXHJcXG5cXHJcXG5tZXNzYWdlIERlYWxsb2NhdGVSZXF1ZXN0IHtcXHJcXG5cXHRyZXF1aXJlZCBmaXhlZDMyIGlkX2EgPSAxO1xcclxcbn1cXHJcXG5cXHJcXG5tZXNzYWdlIEZldGNoUmVxdWVzdCB7XFxyXFxuXFx0cmVxdWlyZWQgc2ZpeGVkMzIgaWRfYSA9IDE7XFxyXFxufVxcclxcblxcclxcbm1lc3NhZ2UgQmluYXJ5T3BlcmF0aW9uUmVxdWVzdCB7XFxyXFxuXFx0ZW51bSBUeXBlIHtcXHJcXG5cXHRcXHRBREQgPSAwO1xcclxcblxcdFxcdFNVQiA9IDE7XFxyXFxuXFx0XFx0TVVMID0gMjtcXHJcXG5cXHRcXHRESVYgPSAzO1xcclxcblxcdH1cXHJcXG5cXHRyZXF1aXJlZCBUeXBlICAgICB0eXBlICAgPSAxO1xcclxcblxcdHJlcXVpcmVkIHNmaXhlZDMyIGlkX2EgICA9IDI7XFxyXFxuXFx0cmVxdWlyZWQgc2ZpeGVkMzIgaWRfYiAgID0gMztcXHJcXG5cXHRyZXF1aXJlZCBmaXhlZDMyICBpZF9vdXQgPSA0O1xcclxcbn1cXHJcXG5cXHJcXG5tZXNzYWdlIEJpbmFyeUNvbnN0T3BlcmF0aW9uUmVxdWVzdCB7XFxyXFxuXFx0ZW51bSBUeXBlIHtcXHJcXG5cXHRcXHRBRERDICA9IDA7XFxyXFxuXFx0XFx0U1VCQyAgPSAxO1xcclxcblxcdFxcdFNVQlJDID0gMjtcXHJcXG5cXHRcXHRNVUxDICA9IDM7XFxyXFxuXFx0XFx0RElWQyAgPSA0O1xcclxcblxcdFxcdERJVlJDID0gNTtcXHJcXG5cXHR9XFxyXFxuXFx0cmVxdWlyZWQgVHlwZSAgICAgdHlwZSAgICA9IDE7XFxyXFxuXFx0cmVxdWlyZWQgc2ZpeGVkMzIgaWRfYSAgICA9IDI7XFxyXFxuXFx0cmVxdWlyZWQgZG91YmxlICAgdmFsdWVfYiA9IDM7XFxyXFxuXFx0cmVxdWlyZWQgZml4ZWQzMiAgaWRfb3V0ICA9IDQ7XFxyXFxufVxcclxcblxcclxcbm1lc3NhZ2UgVW5hcnlPcGVyYXRpb25SZXF1ZXN0IHtcXHJcXG5cXHRlbnVtIFR5cGUge1xcclxcblxcdFxcdE5FRyAgICA9IDA7XFxyXFxuXFx0XFx0QUJTICAgID0gMTtcXHJcXG5cXHRcXHRFWFAgICAgPSAyO1xcclxcblxcdFxcdExPRyAgICA9IDM7XFxyXFxuXFx0XFx0U1FSVCAgID0gNDtcXHJcXG5cXHRcXHRTUVVBUkUgPSA1O1xcclxcblxcdH1cXHJcXG5cXHRyZXF1aXJlZCBUeXBlICAgICB0eXBlICAgPSAxO1xcclxcblxcdHJlcXVpcmVkIHNmaXhlZDMyIGlkX2EgICA9IDI7XFxyXFxuXFx0cmVxdWlyZWQgZml4ZWQzMiAgaWRfb3V0ID0gMztcXHJcXG59XFxyXFxuXFxyXFxubWVzc2FnZSBSZWR1Y3Rpb25SZXF1ZXN0IHtcXHJcXG5cXHRlbnVtIFR5cGUge1xcclxcblxcdFxcdFNVTSA9IDA7XFxyXFxuXFx0XFx0TUlOID0gMTtcXHJcXG5cXHRcXHRNQVggPSAyO1xcclxcblxcdH1cXHJcXG5cXHRyZXF1aXJlZCBUeXBlICAgICB0eXBlICAgPSAxO1xcclxcblxcdHJlcXVpcmVkIHNmaXhlZDMyIGlkX2EgICA9IDI7XFxyXFxuXFx0cmVxdWlyZWQgZml4ZWQzMiAgaWRfb3V0ID0gMztcXHJcXG59XFxyXFxuXFxyXFxubWVzc2FnZSBBeGlzUmVkdWN0aW9uUmVxdWVzdCB7XFxyXFxuXFx0ZW51bSBUeXBlIHtcXHJcXG5cXHRcXHRTVU0gPSAwO1xcclxcblxcdFxcdE1JTiA9IDE7XFxyXFxuXFx0XFx0TUFYID0gMjtcXHJcXG5cXHR9XFxyXFxuXFx0cmVxdWlyZWQgVHlwZSAgICAgdHlwZSAgID0gMTtcXHJcXG5cXHRyZXF1aXJlZCBzZml4ZWQzMiBpZF9hICAgPSAyO1xcclxcblxcdHJlcXVpcmVkIHVpbnQzMiAgIGF4aXMgICA9IDM7XFxyXFxuXFx0cmVxdWlyZWQgZml4ZWQzMiAgaWRfb3V0ID0gNDtcXHJcXG59XFxyXFxuXFxyXFxubWVzc2FnZSBEb3RPcGVyYXRpb25SZXF1ZXN0IHtcXHJcXG5cXHRyZXF1aXJlZCBzZml4ZWQzMiBpZF9hICAgPSAxO1xcclxcblxcdHJlcXVpcmVkIHNmaXhlZDMyIGlkX2IgICA9IDI7XFxyXFxuXFx0cmVxdWlyZWQgZml4ZWQzMiAgaWRfb3V0ID0gMztcXHJcXG59XFxyXFxuXCI7XG5tb2R1bGUuZXhwb3J0cyA9IHByb3RvYnVmanMubG9hZFByb3RvKHJlcXVlc3RzUHJvdG8pLmJ1aWxkKFwiZnVyaW91c1wiKTtcbiIsIlxudmFyIHByb3RvYnVmanMgPSByZXF1aXJlKFwicHJvdG9idWZqc1wiKTtcbnByb3RvYnVmanMuY29udmVydEZpZWxkc1RvQ2FtZWxDYXNlID0gdHJ1ZTtcbnZhciByZXNwb25zZXNQcm90byA9IFwicGFja2FnZSBmdXJpb3VzO1xcclxcblxcclxcbm9wdGlvbiBvcHRpbWl6ZV9mb3IgPSBMSVRFX1JVTlRJTUU7XFxyXFxuXFxyXFxubWVzc2FnZSBSZXNwb25zZSB7XFxyXFxuXFx0ZW51bSBUeXBlIHtcXHJcXG5cXHRcXHRGRVRDSCAgID0gMDtcXHJcXG5cXHRcXHRFUlJPUiAgID0gMTtcXHJcXG5cXHRcXHRJTklUICAgID0gMjtcXHJcXG5cXHRcXHRCQVJSSUVSID0gMztcXHJcXG5cXHRcXHRJTkZPICAgID0gNDtcXHJcXG5cXHR9XFxyXFxuXFx0cmVxdWlyZWQgZml4ZWQzMiAgICAgICAgIGlkICAgICAgICAgICAgICAgPSAxO1xcclxcblxcdHJlcXVpcmVkIFR5cGUgICAgICAgICAgICB0eXBlICAgICAgICAgICAgID0gMjtcXHJcXG5cXHJcXG5cXHRvcHRpb25hbCBGZXRjaFJlc3BvbnNlICAgZmV0Y2hfcmVzcG9uc2UgICA9IDM7XFxyXFxuXFx0b3B0aW9uYWwgRXJyb3JSZXNwb25zZSAgIGVycm9yX3Jlc3BvbnNlICAgPSA0O1xcclxcblxcdG9wdGlvbmFsIEluaXRSZXNwb25zZSAgICBpbml0X3Jlc3BvbnNlICAgID0gNTtcXHJcXG5cXHRvcHRpb25hbCBJbmZvUmVzcG9uc2UgICAgaW5mb19yZXNwb25zZSAgICA9IDc7XFxyXFxufVxcclxcblxcclxcbm1lc3NhZ2UgRmV0Y2hSZXNwb25zZSB7XFxyXFxuXFx0cmVxdWlyZWQgYnl0ZXMgZGF0YV9idWZmZXIgPSAxO1xcclxcbn1cXHJcXG5cXHJcXG5tZXNzYWdlIEVycm9yUmVzcG9uc2Uge1xcclxcblxcdGVudW0gVHlwZSB7XFxyXFxuXFx0XFx0UlVOVElNRSAgPSAwO1xcclxcblxcdFxcdEFSR1VNRU5UID0gMTtcXHJcXG5cXHRcXHRQQVJTRSAgICA9IDI7XFxyXFxuXFx0fVxcclxcblxcdHJlcXVpcmVkIFR5cGUgICB0eXBlICAgICAgICA9IDE7XFxyXFxuXFx0b3B0aW9uYWwgc3RyaW5nIGRlc2NyaXB0aW9uID0gMjtcXHJcXG59XFxyXFxuXFxyXFxubWVzc2FnZSBJbml0UmVzcG9uc2Uge1xcclxcblxcdG9wdGlvbmFsIHVpbnQzMiBjb25jdXJyZW5jeSA9IDE7XFxyXFxufVxcclxcblxcclxcbm1lc3NhZ2UgSW5mb1Jlc3BvbnNlIHtcXHJcXG59XFxyXFxuXCI7XG5tb2R1bGUuZXhwb3J0cyA9IHByb3RvYnVmanMubG9hZFByb3RvKHJlc3BvbnNlc1Byb3RvKS5idWlsZChcImZ1cmlvdXNcIik7XG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbi8qKlxyXG4gKiBQcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBjbGFzcyB1dGlsXHJcbiAqL1xyXG5cclxudmFyIGlzTnVtYmVyID0gZnVuY3Rpb24obikge1xyXG5cdHJldHVybiBuID09PSArbjtcclxufTtcclxuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xyXG5cclxudmFyIGlzUmVhbCA9IGZ1bmN0aW9uKG4pIHtcclxuXHRyZXR1cm4gKG4gPT09ICtuKSAmJiAoaXNGaW5pdGUobikpO1xyXG59O1xyXG5leHBvcnRzLmlzUmVhbCA9IGlzUmVhbDtcclxuXHJcbnZhciBpc0ludCA9IGZ1bmN0aW9uKG4pIHtcclxuXHRyZXR1cm4gbiA9PT0gKG58MCk7XHJcbn07XHJcbmV4cG9ydHMuaXNJbnQgPSBpc0ludDtcclxuXHJcbmV4cG9ydHMuaXNQb3NpdGl2ZUludCA9IGZ1bmN0aW9uKG4pIHtcclxuXHRyZXR1cm4gKG4gPT09ICtuKSAmJiAobiA9PT0gKG58MCkpICYmIChuID4gMCk7XHJcbn07XHJcblxyXG5leHBvcnRzLmlzTm9uTmVnYXRpdmVJbnQgPSBmdW5jdGlvbihuKSB7XHJcblx0cmV0dXJuIChuID09PSArbikgJiYgKG4gPT09IChufDApKSAmJiAobiA+PSAwKTtcclxufTtcclxuXHJcbnZhciBpc0FycmF5ID0gZnVuY3Rpb24obGlzdCkge1xyXG5cdHJldHVybiBsaXN0IGluc3RhbmNlb2YgQXJyYXk7XHJcbn07XHJcbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XHJcblxyXG5leHBvcnRzLmlzSW50QXJyYXkgPSBmdW5jdGlvbihsaXN0KSB7XHJcblx0aWYgKGV4cG9ydHMuaXNBcnJheShsaXN0KSkge1xyXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdGlmICghZXhwb3J0cy5pc0ludChsaXN0W2ldKSkge1xyXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fSBlbHNlIHtcclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHR9XHJcbn07XHJcblxyXG5leHBvcnRzLmlzUG9zaXRpdmVJbnRBcnJheSA9IGZ1bmN0aW9uKGxpc3QpIHtcclxuXHRpZiAoZXhwb3J0cy5pc0FycmF5KGxpc3QpKSB7XHJcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0aWYgKCFleHBvcnRzLmlzUG9zaXRpdmVJbnQobGlzdFtpXSkpIHtcclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiB0cnVlO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fVxyXG59O1xyXG5cclxuZXhwb3J0cy5hc0ludEFycmF5ID0gZnVuY3Rpb24gKGxpc3QpIHtcclxuXHRpZiAoZXhwb3J0cy5pc0ludChsaXN0KSkge1xyXG5cdFx0cmV0dXJuIFtsaXN0XTtcclxuXHR9IGVsc2UgaWYgKGV4cG9ydHMuaXNJbnRBcnJheShsaXN0KSkge1xyXG5cdFx0cmV0dXJuIGxpc3Q7XHJcblx0fSBlbHNlIHtcclxuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IobGlzdCArIFwiIGNhbiBub3QgYmUgY29udmVydGVkIHRvIGludGVnZXIgYXJyYXlcIik7XHJcblx0fVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvbXBhcmVzIGZvciBlcXVhbGl0eSB0d28gYXJyYXlzIG9mIHByaW1pdGl2ZSB0eXBlcy5cclxuICpcclxuICogQHBhcmFtIHtOdW1iZXJbXX0gYXJyYXlBIC0gdGhlIGZpcnN0IGFycmF5IHRvIGNvbXBhcmUuXHJcbiAqIEBwYXJhbSB7TnVtYmVyW119IGFycmF5QiAtIHRoZSBzZWNvbmQgYXJyYXkgdG8gY29tcGFyZS5cclxuICpcclxuICogQGV4YW1wbGVcclxuICogICAgIGlmICghdXRpbC5hcnJheUVxdWFscyhhLnNoYXBlLCBiLnNoYXBlKSkge1xyXG4gKlx0ICAgICAgIHRocm93IG5ldyBFcnJvcihcImEgYW5kIGIgaGF2ZSBpbmNvbXBhdGlibGUgc2hhcGVzXCIpO1xyXG4gKiAgICAgfVxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAc3RhdGljXHJcbiAqIEBtZXRob2QgYXJyYXlFcXVhbHNcclxuICovXHJcbmV4cG9ydHMuYXJyYXlFcXVhbHMgPSBmdW5jdGlvbihhcnJheUEsIGFycmF5Qikge1xyXG5cdGlmIChhcnJheUEgPT09IGFycmF5Qikge1xyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fVxyXG5cdGlmIChhcnJheUEubGVuZ3RoICE9PSBhcnJheUIubGVuZ3RoKSB7XHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fVxyXG5cdHZhciBuID0gYXJyYXlBLmxlbmd0aDtcclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSkge1xyXG5cdFx0aWYgKGFycmF5QVtpXSAhPT0gYXJyYXlCW2ldKSB7XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHR9XHJcblx0cmV0dXJuIHRydWU7XHJcbn07XHJcblxyXG5leHBvcnRzLnJvdW5kVXAgPSBmdW5jdGlvbiAobnVtYmVyLCBtdWx0aXBsZSkge1xyXG5cdHJldHVybiBNYXRoLmNlaWwobnVtYmVyIC8gbXVsdGlwbGUpICogbXVsdGlwbGU7XHJcbn07XHJcblxyXG4vKipcclxuICogVmFsaWRhdGUgdGhlIHNoYXBlIGFyZ3VtZW50LlxyXG4gKiBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlIGFyZ3VtZW50IHJlcHJlc2VudHMgYSB2YWxpZCBzaGFwZS5cclxuICogUmV0dXJucyB0aGUgc2hhcGUgYXMgYW4gaW50ZWdlciBhcnJheS5cclxuICpcclxuICogQHBhcmFtIHsoTnVtYmVyfE51bWJlcltdKX0gc2hhcGUgLSB0aGUgc2hhcGUgYXJndW1lbnQgdG8gdmFsaWRhdGUuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqICAgICBzaGFwZSA9IHV0aWwuY2hlY2tTaGFwZShzaGFwZSk7XHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBzdGF0aWNcclxuICogQG1ldGhvZCBjaGVja1NoYXBlXHJcbiAqL1xyXG52YXIgY2hlY2tTaGFwZSA9IGZ1bmN0aW9uKHNoYXBlKSB7XHJcblx0aWYgKGlzTnVtYmVyKHNoYXBlKSkge1xyXG5cdFx0cmV0dXJuIGNoZWNrU2hhcGUoW3NoYXBlXSk7XHJcblx0fSBlbHNlIGlmIChpc0FycmF5KHNoYXBlKSkge1xyXG5cdFx0dmFyIG4gPSBzaGFwZS5sZW5ndGg7XHJcblx0XHR2YXIgb3V0U2hhcGUgPSBuZXcgQXJyYXkobik7XHJcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xyXG5cdFx0XHRpZiAoIWlzTnVtYmVyKHNoYXBlW2ldKSkge1xyXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIlNoYXBlIGhhcyBub24tbnVtZXJpYyBkaW1lbnNpb25zXCIpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmICghaXNJbnQoc2hhcGVbaV0pKSB7XHJcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiU2hhcGUgbXVzdCBoYXZlIGludGVnZXIgZGltZW5zaW9uc1wiKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAoc2hhcGVbaV0gPCAxKSB7XHJcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiRGVnZW5lcmF0ZSBzaGFwZVwiKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRvdXRTaGFwZVtpXSA9IHNoYXBlW2ldfDA7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gb3V0U2hhcGU7XHJcblx0fSBlbHNlIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcihcIlNoYXBlIG11c3QgYmUgYW4gaW50ZWdlciBvciBpbnRlZ2VyIGFycmF5XCIpO1xyXG5cdH1cclxufTtcclxuZXhwb3J0cy5jaGVja1NoYXBlID0gY2hlY2tTaGFwZTtcclxuXHJcbi8qKlxyXG4gKiBDaGVja3MgdGhhdCB0aGUgdHdvIHNoYXBlcyBhcmUgc2ltaWxhci5cclxuICogVGhyb3dzIGFuIGVycm9yIGlmIHRoZSB0d28gc2hhcGVzIGFyZSBkaWZmZXJlbnQuXHJcbiAqIElmIHRoZSBkYXRhIHR5cGVzIGFyZSBjb21wYXRpYmxlLCB0aGUgZnVuY3Rpb24gZG9lcyBub3RoaW5nLlxyXG4gKlxyXG4gKiBAcGFyYW0ge051bWJlcltdfSBzaGFwZUEgLSBvbmUgdmFsaWQgc2hhcGUgdG8gY29tcGFyZS5cclxuICogQHBhcmFtIHtOdW1iZXJbXX0gc2hhcGVCIC0gYW5vdGhlciB2YWxpZCBzaGFwZSB0byBjb21wYXJlLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiAgICAgdXRpbC5jaGVja1NoYXBlc0NvbXBhdGliaWxpdHkoYS5zaGFwZSwgYi5zaGFwZSk7XHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBzdGF0aWNcclxuICogQG1ldGhvZCBjaGVja1NoYXBlc0NvbXBhdGliaWxpdHlcclxuICovXHJcbmV4cG9ydHMuY2hlY2tTaGFwZXNDb21wYXRpYmlsaXR5ID0gZnVuY3Rpb24oc2hhcGVBLCBzaGFwZUIpIHtcclxuXHRpZiAoc2hhcGVBLmxlbmd0aCAhPSBzaGFwZUIubGVuZ3RoKSB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc2hhcGVzIGhhdmUgZGlmZmVyZW50IGRpbWVuc2lvbnNcIik7XHJcblx0fVxyXG5cdHZhciBuID0gc2hhcGVBLmxlbmd0aDtcclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xyXG5cdFx0aWYgKHNoYXBlQVtpXSAhPSBzaGFwZUJbaV0pIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiVGhlIHNoYXBlcyBhcmUgZGlmZmVyZW50XCIpO1xyXG5cdFx0fVxyXG5cdH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb21wdXRlcyBhcnJheSBsZW5ndGggZnJvbSBpdHMgc2hhcGUuXHJcbiAqXHJcbiAqIEBwYXJhbSB7TnVtYmVyW119IHNoYXBlIC0gYW4gYXJyYXkgc2hhcGUuICBUaGUgc2hhcGUgbXVzdCBiZSB2YWxpZCB3LnIudC4gKipjaGVja1NoYXBlKiogZnVuY3Rpb24uXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqICAgICB2YXIgbGVuZ3RoID0gdXRpbC5jb21wdXRlTGVuZ3RoKHNoYXBlKTtcclxuICpcclxuICogQHByaXZhdGVcclxuICogQHN0YXRpY1xyXG4gKiBAbWV0aG9kIGNvbXB1dGVMZW5ndGhcclxuICovXHJcbmV4cG9ydHMuY29tcHV0ZUxlbmd0aCA9IGZ1bmN0aW9uKHNoYXBlKSB7XHJcblx0dmFyIGxlbmd0aCA9IDE7XHJcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzaGFwZS5sZW5ndGg7ICsraSkge1xyXG5cdFx0bGVuZ3RoICo9IHNoYXBlW2ldO1xyXG5cdH1cclxuXHRyZXR1cm4gbGVuZ3RoO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENoZWNrcyB0aGUgdGhlIGFyZ3VtZW50IHJlcHJlc2VudHMgYSBkYXRhIHR5cGUuXHJcbiAqIFRocm93cyBhbiBlcnJvciBpZiB0aGUgYXJndW1lbnQgaXMgbm90IG9mIERhdGFUeXBlIHR5cGUuXHJcbiAqIElmIHRoZSBhcmd1bWVudCBpcyBhIERhdGFUeXBlIG9iamVjdCwgdGhlIGZ1bmN0aW9uIGRvZXMgbm90aGluZy5cclxuICpcclxuICogQHBhcmFtIHtEYXRhVHlwZX0gZGF0YVR5cGUgLSB0aGUgZXhwZWN0ZWRseSBkYXRhIHR5cGUgb2JqZWN0IHRvIHZhbGlkYXRlLlxyXG4gKiBAcmV0dXJuIHtEYXRhVHlwZX0gLSBhIGRhdGEgdHlwZSBvYmplY3QgZXF1aXZhbGVudCB0byB0aGUgYXJndW1lbnQuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqICAgICBkYXRhVHlwZSA9IHV0aWwuY2hlY2tEYXRhVHlwZShkYXRhVHlwZSk7XHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBzdGF0aWNcclxuICogQG1ldGhvZCBjaGVja0RhdGFUeXBlXHJcbiAqL1xyXG5leHBvcnRzLmNoZWNrRGF0YVR5cGUgPSBmdW5jdGlvbihkYXRhVHlwZSkge1xyXG5cdHZhciBEYXRhVHlwZSA9IHJlcXVpcmUoXCIuL0RhdGFUeXBlXCIpO1xyXG5cdGlmICghKGRhdGFUeXBlIGluc3RhbmNlb2YgRGF0YVR5cGUpKSB7XHJcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKFwiZGF0YVR5cGUgaXMgbm90IGFuIGluc3RhbmNlIG9mIERhdGFUeXBlXCIpO1xyXG5cdH1cclxuXHRyZXR1cm4gZGF0YVR5cGU7XHJcbn07XHJcblxyXG4vKipcclxuICogQ2hlY2tzIHRoYXQgdGhlIHR3byBkYXRhIHR5cGVzIGFyZSBjb21wYXRpYmxlLlxyXG4gKiBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlIGRhdGEgdHlwZXMgZG8gbm90IG1hdGNoLlxyXG4gKiBJZiB0aGUgZGF0YSB0eXBlcyBhcmUgY29tcGF0aWJsZSwgdGhlIGZ1bmN0aW9uIGRvZXMgbm90aGluZy5cclxuICpcclxuICogQHBhcmFtIHtEYXRhVHlwZX0gZGF0YVR5cGVBIC0gdGhlIGZpcnN0IGRhdGEgdHlwZS5cclxuICogQHBhcmFtIHtEYXRhVHlwZX0gZGF0YVR5cGVCIC0gdGhlIHNlY29uZCBkYXRhIHR5cGUuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqICAgICB1dGlsLmNoZWNrRGF0YVR5cGVzQ29tcGF0aWJpbGl0eShhLmRhdGFUeXBlLCBiLmRhdGFUeXBlKTtcclxuICpcclxuICogQHByaXZhdGVcclxuICogQHN0YXRpY1xyXG4gKiBAbWV0aG9kIGNoZWNrRGF0YVR5cGVzQ29tcGF0aWJpbGl0eVxyXG4gKi9cclxuZXhwb3J0cy5jaGVja0RhdGFUeXBlc0NvbXBhdGliaWxpdHkgPSBmdW5jdGlvbihkYXRhVHlwZUEsIGRhdGFUeXBlQikge1xyXG5cdGlmICghZGF0YVR5cGVBLmVxdWFscyhkYXRhVHlwZUIpKSB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZGF0YSB0eXBlcyBhcmUgbm90IGNvbXBhdGlibGVcIik7XHJcblx0fVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFZhbGlkYXRlcyBhbiBOREFycmF5IHBhcmFtZXRlci5cclxuICogVGhyb3dzIGFuIGVycm9yIGlmIHRoZSBleHBlY3RlZCBOREFycmF5IGFyZ3VtZW50IGhhcyBvdGhlciB0eXBlIG9yIGlmIGl0IGhhcyBiZWVuIGludmFsaWRhdGVkLlxyXG4gKiBJZiB0aGUgYXJndW1lbnQgaXMgYSB2YWxpZCBOREFycmF5LCB0aGUgZnVuY3Rpb24gZG9lcyBub3RoaW5nLlxyXG4gKlxyXG4gKiBAcGFyYW0ge05EQXJyYXl9IGFycmF5IC0gdGhlIGV4cGVjdGVkbHkgTkRBcnJheSBhcmd1bWVudCB0byBiZSB2YWxpZGF0ZWQuXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YW5hbWUgLSB0aGUgbmFtZSBvZiB0aGUgTkRBcnJheSBhcmd1bWVudCB0byBiZSB1c2VkIGluIGVycm9yIG1lc3NhZ2VzLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiAgICAgdXRpbC5jaGVja05EQXJyYXkob3V0LCBcIm91dFwiKTtcclxuICpcclxuICogQHByaXZhdGVcclxuICogQHN0YXRpY1xyXG4gKiBAbWV0aG9kIGNoZWNrTkRBcnJheVxyXG4gKi9cclxuZXhwb3J0cy5jaGVja05EQXJyYXkgPSBmdW5jdGlvbihhcnJheSwgdmFybmFtZSkge1xyXG5cdHZhciBOREFycmF5ID0gcmVxdWlyZShcIi4vTkRBcnJheVwiKTtcclxuXHRpZiAoIShhcnJheSBpbnN0YW5jZW9mIE5EQXJyYXkpKSB7XHJcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKHZhcm5hbWUgKyBcIiBpcyBub3QgYW4gTkRBcnJheVwiKTtcclxuXHR9XHJcblx0aWYgKCFhcnJheS5pc1ZhbGlkKCkpIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcih2YXJuYW1lICsgXCIgaXMgYW4gaW52YWxpZGF0ZWQgYXJyYXlcIik7XHJcblx0fVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIENoZWNrcyB0aGF0IHRoZSB0d28gYXJyYXlzIGFyZSBkaWZmZXJlbnQuXHJcbiAqIFRocm93cyBhbiBlcnJvciBpZiB0aGV5IHJlZmVyIHRvIHRoZSBzYW1lIG9iamVjdC5cclxuICogSWYgdGhlIGFycmF5cyBhcmUgZGlmZmVyZW50LCB0aGUgZnVuY3Rpb24gZG9lcyBub3RoaW5nLlxyXG4gKlxyXG4gKiBAcGFyYW0ge05EQXJyYXl9IGEgLSB0aGUgZmlyc3QgYXJyYXkgdG8gY2hlY2suIE11c3QgYmUgYW4gTkRBcnJheSBvYmplY3QuXHJcbiAqIEBwYXJhbSB7TkRBcnJheX0gYiAtIHRoZSBzZWNvbmQgYXJyYXkgdG8gY2hlY2suIE11c3QgYmUgYW4gTkRBcnJheSBvYmplY3QuXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YXJuYW1lQSAtIG5hbWUgb2YgdGhlIGZpcnN0IGFycmF5IHZhcmlhYmxlLiBUaGlzIG5hbWUgbWF5IGJlIHVzZWQgaW4gYW4gZXJyb3IgbWVzc2FnZS5cclxuICogQHBhcmFtIHtTdHJpbmd9IHZhcm5hbWVCIC0gbmFtZSBvZiB0aGUgc2Vjb25kIGFycmF5IHZhcmlhYmxlLiBUaGlzIG5hbWUgbWF5IGJlIHVzZWQgaW4gYW4gZXJyb3IgbWVzc2FnZS5cclxuICpcclxuICogQGV4YW1wbGVcclxuICogICAgIHV0aWwuY2hlY2tEaWZmZXJlbnROREFycmF5cyhhLCBvdXQsIFwiYVwiLCBcIm91dFwiKTtcclxuICpcclxuICogQHByaXZhdGVcclxuICogQHN0YXRpY1xyXG4gKiBAbWV0aG9kIGNoZWNrRGlmZmVyZW50TkRBcnJheXNcclxuICovXHJcbmV4cG9ydHMuY2hlY2tEaWZmZXJlbnROREFycmF5cyA9IGZ1bmN0aW9uKGEsIGIsIHZhcm5hbWVBLCB2YXJuYW1lQikge1xyXG5cdGlmIChhID09PSBiKSB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJUaGUgYXJyYXlzIFwiICsgdmFybmFtZUEgKyBcIiBhbmQgXCIgKyB2YXJuYW1lQiArIFwiIG11c3QgYmUgZGlmZmVyZW50XCIpO1xyXG5cdH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBWYWxpZGF0ZXMgKipyZXBlYXRzKiogcGFyYW1ldGVyIGZvciByZXBlYXRpdGlvbi90aWxpbmcgb2YgYXJyYXkgYWxvbmcgYW4gYXhpcy5cclxuICogVGhyb3dzIGFuIGVycm9yIGlmICoqcmVwZWF0cyoqIGlzIG5vdCBhbiBpbnRlZ2VyIG9yIGlmICoqcmVwZWF0cyoqIGlzIHNtYWxsZXIgdGhhbiAyLlxyXG4gKiBJZiAqKnJlcGVhdHMqKiBpcyB2YWxpZCwgdGhlIGZ1bmN0aW9uIGRvZXMgbm90aGluZy5cclxuICpcclxuICogQHBhcmFtIHtOdW1iZXJ9IHJlcGVhdHMgLSB0aGUgcmVwZWF0cyBhcmd1bWVudCB0byBiZSB2ZXJpZmllZC5cclxuICogQHJldHVybiB7TnVtYmVyfSAtICoqcmVwZWF0cyoqIGNhc3RlZCB0byBpbnRlZ2VyLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiAgICAgcmVwZWF0cyA9IHV0aWwuY2hlY2tSZXBlYXRzKHJlcGVhdHMpO1xyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAc3RhdGljXHJcbiAqIEBtZXRob2QgY2hlY2tSZXBlYXRzXHJcbiAqL1xyXG5leHBvcnRzLmNoZWNrUmVwZWF0cyA9IGZ1bmN0aW9uKHJlcGVhdHMpIHtcclxuXHRpZiAoIWlzSW50KHJlcGVhdHMpKSB7XHJcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKFwiUmVwZWF0cyBpcyBub3QgYW4gaW50ZWdlclwiKTtcclxuXHR9XHJcblx0aWYgKHJlcGVhdHMgPD0gMSkge1xyXG5cdFx0dGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJSZXBlYXRzIHNob3VsZCBiZSBncmVhdGVyIHRoYW4gMVwiKTtcclxuXHR9XHJcblx0cmV0dXJuIHJlcGVhdHN8MDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBWYWxpZGF0ZXMgYXhpcyBwYXJhbWV0ZXIgZm9yIHJlZHVjdGlvbnMgYWxvbmcgYW4gYXhpcy5cclxuICogVGhyb3dzIGFuIGVycm9yIGlmIGF4aXMgaXMgbm90IGFuIGludGVnZXIsIGlmIGF4aXMgaXMgbmVnYXRpdmUsIG9yIGF4aXMgZXhjZWVkcyB0aGUgbnVtYmVyIG9mIGRpbWVuc2lvbnMuXHJcbiAqIElmIGF4aXMgaXMgdmFsaWQsIHRoZSBmdW5jdGlvbiBkb2VzIG5vdGhpbmcuXHJcbiAqXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBheGlzIC0gdGhlIGF4aXMgYXJndW1lbnQgdG8gYmUgdmVyaWZpZWQuXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBudW1EaW1lbnNpb25zIC0gdGhlIG51bWJlciBvZiBkaW1lbnNpb25zIGluIHRoZSBhcnJheSBiZWluZyByZWR1Y2VkLlxyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IC0gYXhpcyBjYXN0ZWQgdG8gaW50ZWdlci5cclxuICpcclxuICogQGV4YW1wbGVcclxuICogICAgIGF4aXMgPSB1dGlsLmNoZWNrQXhpcyhheGlzLCBuZGFycmF5LnNoYXBlLmxlbmd0aCk7XHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBzdGF0aWNcclxuICogQG1ldGhvZFxyXG4gKi9cclxuZXhwb3J0cy5jaGVja0F4aXMgPSBmdW5jdGlvbihheGlzLCBudW1EaW1lbnNpb25zKSB7XHJcblx0aWYgKCFpc0ludChheGlzKSkge1xyXG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihcIkF4aXMgaXMgbm90IGFuIGludGVnZXJcIik7XHJcblx0fVxyXG5cdGlmIChheGlzIDwgMCkge1xyXG5cdFx0dGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJBeGlzIGlzIG5lZ2F0aXZlXCIpO1xyXG5cdH1cclxuXHQvKiBFLmcuIDMtZGltZW5zaW9uYWwgYXJyYXkgaGFzIGF4ZXMgMCwgMSwgMiAoYnV0IG5vdCAzISkgKi9cclxuXHRpZiAoYXhpcyA+PSBudW1EaW1lbnNpb25zKSB7XHJcblx0XHR0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkF4aXMgb3V0IG9mIHJhbmdlXCIpO1xyXG5cdH1cclxuXHRyZXR1cm4gYXhpc3wwO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFZhbGlkYXRlcyB0aGUgc2hhcGUgb2Ygb3V0cHV0IGFycmF5IGZvciByZWR1Y3Rpb25zIGFsb25nIGFuIGF4aXMuXHJcbiAqIFRocm93cyBhbiBlcnJvciBpZiB0aGUgc2hhcGUgb2YgdGhlIG91dHB1dCBhcnJheSBkb2VzIG1hdGNoIHRoZSBzaGFwZSBvZiBpbnB1dCBhcnJheSBhZnRlciByZWR1Y3Rpb24gYWxvbmcgdGhlIGF4aXMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7TnVtYmVyW119IGluU2hhcGUgLSB0aGUgc2hhcGUgb2YgdGhlIGlucHV0IGFycmF5LlxyXG4gKiBAcGFyYW0ge051bWJlcltdfSBvdXRTaGFwZSAtIHRoZSBzaGFwZSBvZiB0aGUgb3V0cHV0IGFycmF5IHRvIGJlIHZhbGlkYXRlZC5cclxuICogQHBhcmFtIHtOdW1iZXJ9IGF4aXMgLSB0aGUgYXhpcyBmb3IgcmVkdWN0aW9uIG9mIGlucHV0IGFycmF5LiBNdXN0IGJlIHZhbGlkIHcuci50LiBpblNoYXBlLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiAgICAgdXRpbC5jaGVja0F4aXNSZWR1Y3Rpb25PdXRTaGFwZShpbkFycmF5LnNoYXBlLCBvdXRBcnJheS5zaGFwZSwgYXhpcyk7XHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBzdGF0aWNcclxuICogQG1ldGhvZFxyXG4gKi9cclxuZXhwb3J0cy5jaGVja0F4aXNSZWR1Y3Rpb25PdXRTaGFwZSA9IGZ1bmN0aW9uKGluU2hhcGUsIG91dFNoYXBlLCBheGlzKSB7XHJcblx0aWYgKGluU2hhcGUubGVuZ3RoICE9PSBvdXRTaGFwZS5sZW5ndGggKyAxKSB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJPdXRwdXQgYXJyYXkgaGFzIGludmFsaWQgbnVtYmVyIG9mIGRpbWVuc2lvbnMgZm9yIHRoaXMgb3BlcmF0aW9uXCIpO1xyXG5cdH1cclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGF4aXM7ICsraSkge1xyXG5cdFx0aWYgKGluU2hhcGVbaV0gIT09IG91dFNoYXBlW2ldKSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcihcIk91dHB1dCBhcnJheSBoYXMgaW52YWxpZCBzaGFwZSBmb3IgdGhpcyBvcGVyYXRpb25cIik7XHJcblx0XHR9XHJcblx0fVxyXG5cdGZvciAodmFyIGkgPSBheGlzICsgMTsgaSA8IGluU2hhcGUubGVuZ3RoOyArK2kpIHtcclxuXHRcdGlmIChpblNoYXBlW2ldICE9PSBvdXRTaGFwZVtpLTFdKSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcihcIk91dHB1dCBhcnJheSBoYXMgaW52YWxpZCBzaGFwZSBmb3IgdGhpcyBvcGVyYXRpb25cIik7XHJcblx0XHR9XHJcblx0fVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvbXB1dGVzIHRoZSBzaGFwZSBvZiBhbiBhcnJheSBhZnRlciByZWR1Y3Rpb24gYWxvbmcgYW4gYXhpcy5cclxuICpcclxuICogQHBhcmFtIHtOdW1iZXJbXX0gaW5TaGFwZSAtIHRoZSBzaGFwZSBvZiB0aGUgaW5wdXQgYXJyYXkuXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBheGlzIC0gdGhlIGF4aXMgZm9yIHJlZHVjdGlvbiBvZiBpbnB1dCBhcnJheS4gTXVzdCBiZSB2YWxpZCB3LnIudC4gaW5TaGFwZS5cclxuICogQHJldHVybiB7TnVtYmVyW119IC0gdGhlIHNoYXBlIG9mIHRoZSBvdXRwdXQgYXJyYXkuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqICAgICB2YXIgb3V0U2hhcGUgPSB1dGlsLmdldEF4aXNSZWR1Y3Rpb25PdXRTaGFwZShpbkFycmF5LnNoYXBlLCBheGlzKTtcclxuICogICAgIHZhciBvdXRBcnJheSA9IG5ldyBOREFycmF5KG91dFNoYXBlLCBpbkFycmF5LmRhdGFUeXBlLCBjb250ZXh0KTtcclxuICpcclxuICogQHByaXZhdGVcclxuICogQHN0YXRpY1xyXG4gKiBAbWV0aG9kXHJcbiAqL1xyXG5leHBvcnRzLmNvbXB1dGVBeGlzUmVkdWN0aW9uT3V0U2hhcGUgPSBmdW5jdGlvbihpblNoYXBlLCBheGlzKSB7XHJcblx0dmFyIG91dFNoYXBlID0gW107XHJcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBpblNoYXBlLmxlbmd0aDsgKytpKSB7XHJcblx0XHRpZiAoaSAhPT0gYXhpcykge1xyXG5cdFx0XHRvdXRTaGFwZS5wdXNoKGluU2hhcGVbaV0pO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRyZXR1cm4gb3V0U2hhcGU7XHJcbn07XHJcblxyXG4vKipcclxuICogQ29tcHV0ZXMgdGhlIHByb2R1Y3Qgb2YgYXJyYXkgZGltZW5zaW9ucyBiZWZvcmUgdGhlIGF4aXMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7TnVtYmVyW119IHNoYXBlIC0gdGhlIHNoYXBlIG9mIHRoZSBhcnJheS5cclxuICogQHBhcmFtIHtOdW1iZXJ9IGF4aXMgLSB0aGUgYXhpcyB1c2VkIGluIGFuIG9wZXJhdGlvbi4gTXVzdCBiZSB2YWxpZCB3LnIudC4gc2hhcGUuXHJcbiAqIEByZXR1cm4ge051bWJlcn0gLSB0aGUgcHJvZHVjdCBvZiBhcnJheSBkaW1lbnNpb25zIGJlZm9yZSBheGlzLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiAgICAgLy8gNS1kaW1lbnNpb25hbCBhcnJheVxyXG4gKiAgICAgdmFyIG5kYXJyYXkgPSBjb250ZXh0LmVtcHR5KFsyLCAzLCA0LCA1LCA2XSk7XHJcbiAqICAgICAvLyBSZXR1cm5zIDYgPSAyKjNcclxuICogICAgIHZhciBvdXRlclN0cmlkZSA9IGNvbXB1dGVPdXRlclN0cmlkZShuZGFycmF5LCAyKTtcclxuICpcclxuICogQHByaXZhdGVcclxuICogQHN0YXRpY1xyXG4gKiBAbWV0aG9kXHJcbiAqL1xyXG5leHBvcnRzLmNvbXB1dGVPdXRlclN0cmlkZSA9IGZ1bmN0aW9uKHNoYXBlLCBheGlzKSB7XHJcblx0dmFyIG91dGVyU3RyaWRlID0gMTtcclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGF4aXM7ICsraSkge1xyXG5cdFx0b3V0ZXJTdHJpZGUgKj0gc2hhcGVbaV07XHJcblx0fVxyXG5cdHJldHVybiBvdXRlclN0cmlkZTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb21wdXRlcyB0aGUgcHJvZHVjdCBvZiBhcnJheSBkaW1lbnNpb25zIGFmdGVyIHRoZSBheGlzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge051bWJlcltdfSBzaGFwZSAtIHRoZSBzaGFwZSBvZiB0aGUgYXJyYXkuXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBheGlzIC0gdGhlIGF4aXMgdXNlZCBpbiBhbiBvcGVyYXRpb24uIE11c3QgYmUgdmFsaWQgdy5yLnQuIHNoYXBlLlxyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IC0gdGhlIHByb2R1Y3Qgb2YgYXJyYXkgZGltZW5zaW9ucyBhZnRlciBheGlzLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiAgICAgLy8gNS1kaW1lbnNpb25hbCBhcnJheVxyXG4gKiAgICAgdmFyIG5kYXJyYXkgPSBjb250ZXh0LmVtcHR5KFsyLCAzLCA0LCA1LCA2XSk7XHJcbiAqICAgICAvLyBSZXR1cm5zIDYgPSAyKjNcclxuICogICAgIHZhciBpbm5lclN0cmlkZSA9IGNvbXB1dGVJbm5lclN0cmlkZShuZGFycmF5LCAyKTtcclxuICpcclxuICogQHByaXZhdGVcclxuICogQHN0YXRpY1xyXG4gKiBAbWV0aG9kXHJcbiAqL1xyXG5leHBvcnRzLmNvbXB1dGVJbm5lclN0cmlkZSA9IGZ1bmN0aW9uKHNoYXBlLCBheGlzKSB7XHJcblx0dmFyIGlubmVyU3RyaWRlID0gMTtcclxuXHRmb3IgKHZhciBpID0gYXhpcyArIDE7IGkgPCBzaGFwZS5sZW5ndGg7ICsraSkge1xyXG5cdFx0aW5uZXJTdHJpZGUgKj0gc2hhcGVbaV07XHJcblx0fVxyXG5cdHJldHVybiBpbm5lclN0cmlkZTtcclxufTtcclxuXHJcbnZhciBkaXNjb3ZlckFycmF5U2hhcGVSZWN1cnNpdmUgPSBmdW5jdGlvbihkYXRhLCBzaGFwZSwgbGV2ZWwpIHtcclxuXHRpZiAoaXNBcnJheShkYXRhKSkge1xyXG5cdFx0aWYgKHNoYXBlLmxlbmd0aCA8PSBsZXZlbCkge1xyXG5cdFx0XHQvKiBEaXNjb3ZlcmVkIGEgbmV3IGxldmVsIG9mIHN1Yi1hcnJheXMuIFJlY29yZCBpdHMgZGltZW5zaW9uLiAqL1xyXG5cdFx0XHRzaGFwZS5wdXNoKGRhdGEubGVuZ3RoKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdC8qIE9ubHkgY2hlY2sgZGltZW5zaW9uICovXHJcblx0XHRcdGlmIChzaGFwZVtsZXZlbF0gIT0gZGF0YS5sZW5ndGgpIHtcclxuXHRcdFx0XHR0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlN1Yi1hcnJheSBcIiArIGRhdGEgKyBcIiBkb2VzIG5vdCBtYXRjaCB0aGUgZXhwZWN0ZWQgZGltZW5zaW9uIG9mIFwiICsgc2hhcGVbbGV2ZWxdKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdGRpc2NvdmVyQXJyYXlTaGFwZVJlY3Vyc2l2ZShkYXRhW2ldLCBzaGFwZSwgbGV2ZWwgKyAxKTtcclxuXHRcdH1cclxuXHR9IGVsc2Uge1xyXG5cdFx0aWYgKGxldmVsICE9IHNoYXBlLmxlbmd0aCkge1xyXG5cdFx0XHR0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlN1Yi1hcnJheSBbXCIgKyBkYXRhICsgXCJdIGRvZXMgbm90IG1hdGNoIHRoZSBleHBlY3RlZCBkaW1lbnNpb24gb2YgXCIgKyBzaGFwZVtsZXZlbF0pO1xyXG5cdFx0fVxyXG5cdFx0aWYgKCFpc051bWJlcihkYXRhKSkge1xyXG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKFwiTm9uLW51bWVyaWMgZWxlbWVudDogXCIgKyBkYXRhKTtcclxuXHRcdH1cclxuXHR9XHJcbn07XHJcbmV4cG9ydHMuZGlzY292ZXJBcnJheVNoYXBlUmVjdXJzaXZlID0gZGlzY292ZXJBcnJheVNoYXBlUmVjdXJzaXZlO1xyXG5cclxudmFyIGNvcHlBcnJheURhdGFSZWN1cnNpdmUgPSBmdW5jdGlvbihkYXRhQnVmZmVyLCBkYXRhQXJyYXksIHNoYXBlLCBsZXZlbCwgb2Zmc2V0KSB7XHJcblx0dmFyIG4gPSBzaGFwZVtsZXZlbF07XHJcblx0aWYgKGxldmVsID09PSBzaGFwZS5sZW5ndGggLSAxKSB7XHJcblx0XHRkYXRhQnVmZmVyLnNldChkYXRhQXJyYXksIG9mZnNldCAqIG4pO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xyXG5cdFx0XHRjb3B5QXJyYXlEYXRhUmVjdXJzaXZlKGRhdGFCdWZmZXIsIGRhdGFBcnJheVtpXSwgc2hhcGUsIGxldmVsICsgMSwgb2Zmc2V0ICogbiAgKyBpKTtcclxuXHRcdH1cclxuXHR9XHJcbn07XHJcbmV4cG9ydHMuY29weUFycmF5RGF0YVJlY3Vyc2l2ZSA9IGNvcHlBcnJheURhdGFSZWN1cnNpdmU7XHJcblxyXG52YXIgY3JlYXRlQXJyYXlSZWN1cnNpdmUgPSBmdW5jdGlvbihkYXRhQnVmZmVyLCBkYXRhQXJyYXksIHNoYXBlLCBsZXZlbCwgb2Zmc2V0KSB7XHJcblx0dmFyIG4gPSBzaGFwZVtsZXZlbF07XHJcblx0aWYgKGxldmVsID09PSBzaGFwZS5sZW5ndGggLSAxKSB7XHJcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xyXG5cdFx0XHRkYXRhQXJyYXlbaV0gPSBkYXRhQnVmZmVyW29mZnNldCAqIG4gKyBpXTtcclxuXHRcdH1cclxuXHR9IGVsc2Uge1xyXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcclxuXHRcdFx0ZGF0YUFycmF5W2ldID0gbmV3IEFycmF5KHNoYXBlW2xldmVsICsgMV0pO1xyXG5cdFx0XHRjcmVhdGVBcnJheVJlY3Vyc2l2ZShkYXRhQnVmZmVyLCBkYXRhQXJyYXlbaV0sIHNoYXBlLCBsZXZlbCArIDEsIG9mZnNldCAqIG4gICsgaSk7XHJcblx0XHR9XHJcblx0fVxyXG59O1xyXG5leHBvcnRzLmNyZWF0ZUFycmF5UmVjdXJzaXZlID0gY3JlYXRlQXJyYXlSZWN1cnNpdmU7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxudmFyIE5EQXJyYXkgPSByZXF1aXJlKFwiLi4vTkRBcnJheVwiKTtcclxudmFyIERhdGFUeXBlID0gcmVxdWlyZShcIi4uL0RhdGFUeXBlXCIpO1xyXG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xyXG5cclxuXHJcbi8qIEJ1Z2d5IGluIENocm9taXVtLVdlYkNMICovXHJcbnZhciB1c2VCdWZmZXJDcmVhdGlvbldpdGhJbml0ID0gZmFsc2U7XHJcblxyXG52YXIgaXNOb2RlV2ViQ0wgPSBmYWxzZTtcclxudmFyIGNsID0gdm9pZCAwO1xyXG52YXIgYXZhaWxhYmxlRGV2aWNlcyA9IG51bGw7XHJcbnZhciBhdmFpbGFibGVEZXZpY2VzRGVzY3JpcHRpb25zID0gbnVsbDtcclxudmFyIGRlZmF1bHREZXZpY2VJbmRleCA9IC0xO1xyXG5cclxuLyoqXHJcbiAqIElmIHRoZSBnbG9iYWwgY2wgdmFyaWFibGUgaXMgdW5kZWZpbmVkLCB0aGlzIG1ldGhvZCB3b3VsZCBpbml0aWFsaXplIGl0IHdpdGggYSBXZWJDTCBpbnN0YW5jZS5cclxuICogV29ya3MgZm9yIGJvdGggYnJvd3NlciBhbmQgTm9kZS5qc1xyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAc3RhdGljXHJcbiAqIEBtZXRob2QgaW5pdFdlYkNMXHJcbiAqIEByZXR1cm4ge1dlYkNMfSAtIGFuIGluc3RhbmNlIG9mIFdlYkNMIG9iamVjdCBmcm9tIFdlYkNMIHNwZWNpZmljYXRpb24uIElmIFdlYkNMIGlzIG5vdCBzdXBwb3J0ZWQsIHJldHVybiBudWxsLlxyXG4gKi9cclxudmFyIGluaXRXZWJDTCA9IGZ1bmN0aW9uKCkge1xyXG5cdGlmICh0eXBlb2YgY2wgPT09IFwidW5kZWZpbmVkXCIpIHtcclxuXHRcdGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSB7XHJcblx0XHRcdGNsID0gKHR5cGVvZiB3aW5kb3cud2ViY2wgIT09IFwidW5kZWZpbmVkXCIpID8gd2luZG93LndlYmNsIDogbnVsbDtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRyeSB7XHJcblx0XHRcdFx0Y2wgPSByZXF1aXJlKFwibm9kZS13ZWJjbFwiKTtcclxuXHRcdFx0XHRpc05vZGVXZWJDTCA9IHRydWU7XHJcblx0XHRcdH0gY2F0Y2ggKGUpIHtcclxuXHRcdFx0XHRjbCA9IG51bGw7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblx0cmV0dXJuIGNsO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgYW4gZW1wdHkgV2ViQ0xFdmVudC5cclxuICogV29ya3MgZm9yIGJvdGggYnJvd3NlciBhbmQgTm9kZS5qc1xyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAc3RhdGljXHJcbiAqIEBtZXRob2QgY3JlYXRlRXZlbnRcclxuICogQHJldHVybiB7V2ViQ0xFdmVudH0gLSBhbiBlbXB0eSBpbnN0YW5jZSBvZiBXZWJDTEV2ZW50LlxyXG4gKi9cclxudmFyIGNyZWF0ZUV2ZW50ID0gZnVuY3Rpb24oKSB7XHJcblx0aWYgKGlzTm9kZVdlYkNMKSB7XHJcblx0XHRyZXR1cm4gbmV3IGNsLldlYkNMRXZlbnQoKTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0cmV0dXJuIG5ldyBXZWJDTEV2ZW50KCk7XHJcblx0fVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRyaWVzIHRvIHJlbGVhc2UgYSBXZWJDTCByZXNvdXJjZSBhbmQgaWdub3JlcyBhbnkgZXJyb3JzIGluIHRoZSBwcm9jZXNzLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAbWV0aG9kIHRyeVJsZWFzZVxyXG4gKiBAcGFyYW0ge09iamVjdH0gd2ViY2xPYmplY3QgLSBhIFdlYkNMIG9iamVjdC5cclxuICogQHJldHVybiB7Qm9vbGVhbn0gLSB0cnVlIGlmIHRoZSBvYmplY3Qgd2FzIHN1Y2Nlc3NmdWxseSByZWxlYXNlZCBhbmQgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gKi9cclxudmFyIHRyeVJlbGVhc2UgPSBmdW5jdGlvbih3ZWJjbFJlc291cmNlKSB7XHJcblx0aWYgKHdlYmNsUmVzb3VyY2UgIT09IG51bGwpIHtcclxuXHRcdHRyeSB7XHJcblx0XHRcdHdlYmNsUmVzb3VyY2UucmVsZWFzZSgpO1xyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdH0gY2F0Y2ggKGUpIHtcclxuXHRcdFx0LyogU2lsZW50bHkgaWdub3JlICovXHJcblx0XHR9XHJcblx0fVxyXG5cdHJldHVybiBmYWxzZTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgYSBXZWJDTCBkZXZpY2Ugc3VwcG9ydHMgS0hSX2ZwNjQgZXh0ZW5zaW9uLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAbWV0aG9kIGlzRlA2NENhcGFibGVcclxuICogQHBhcmFtIHtXZWJDTERldmljZX0gZGV2aWNlIC0gdGhlIGRldmljZSB0byBjaGVjayBmb3IgS0hSX2ZwNjQgc3VwcG9ydC5cclxuICogQHJldHVybiB7Qm9vbGVhbn0gLSB0cnVlIGlmIHRoZSBkZXZpY2Ugc3VwcG9ydHMgS0hSX2ZwNjQgYW5kIGZhbHNlIG90aGVyd2lzZS5cclxuICovXHJcbnZhciBpc0ZQNjRDYXBhYmxlID0gZnVuY3Rpb24oZGV2aWNlKSB7XHJcblx0dmFyIGV4dGVuc2lvbnMgPSBkZXZpY2UuZ2V0U3VwcG9ydGVkRXh0ZW5zaW9ucygpO1xyXG5cdGlmIChleHRlbnNpb25zLmluZGV4T2YoXCJLSFJfZnA2NFwiKSA9PT0gLTEpIHtcclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHR9XHJcblx0LypcclxuXHQgKiBEdWUgdG8gYSBidWcgV2ViS2l0LVdlYkNMIG1heSByZXBvcnQgS0hSX2ZwNjQgZXZlbiBpZiBpdCBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoZSB1bmRlcmx5aW5nIE9wZW5DTCBkZXZpY2UuXHJcblx0ICogU2VlIGJ1ZyBodHRwczovL2dpdGh1Yi5jb20vU1JBLVNpbGljb25WYWxsZXkvd2Via2l0LXdlYmNsL2lzc3Vlcy81MzZcclxuXHQgKi9cclxuXHR2YXIgdGVzdFNvdXJjZSA9IFwia2VybmVsIHZvaWQgZm9vKGdsb2JhbCBkb3VibGUqIGJhcikgeyB9XCI7XHJcblx0dmFyIGNvbnRleHQgPSBudWxsLCBwcm9ncmFtID0gbnVsbDtcclxuXHR0cnkge1xyXG5cdFx0Y29udGV4dCA9IGNsLmNyZWF0ZUNvbnRleHQoZGV2aWNlKTtcclxuXHRcdHByb2dyYW0gPSBjb250ZXh0LmNyZWF0ZVByb2dyYW0odGVzdFNvdXJjZSk7XHJcblx0XHRwcm9ncmFtLmJ1aWxkKCk7XHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9IGNhdGNoIChlKSB7XHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fSBmaW5hbGx5IHtcclxuXHRcdHRyeVJlbGVhc2UocHJvZ3JhbSk7XHJcblx0XHR0cnlSZWxlYXNlKGNvbnRleHQpO1xyXG5cdH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBJbml0aWFsaXNlcyBhbmQgcmV0dXJucyBhIGxpc3Qgb2YgV2ViQ0wgZGV2aWNlcyBzdWl0YWJsZSBmb3IgY29tcHV0YXRpb24uXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBzdGF0aWNcclxuICogQG1ldGhvZCBnZXRBdmFpbGFibGVEZXZpY2VzXHJcbiAqIEByZXR1cm4ge1dlYkNMRGV2aWNlW119IC0gYSBsaXN0IG9mIEdQVSBhbmQgQ1BVIFdlYkNMIGRldmljZXMgdGhhdCBzdXBwb3J0IEtIUl9GUDY0IChtYXkgYmUgZW1wdHkpLlxyXG4gKi9cclxudmFyIGdldEF2YWlsYWJsZURldmljZXMgPSBmdW5jdGlvbigpIHtcclxuXHRpZiAoYXZhaWxhYmxlRGV2aWNlcyA9PT0gbnVsbCkge1xyXG5cdFx0YXZhaWxhYmxlRGV2aWNlcyA9IFtdO1xyXG5cdFx0dmFyIHdlYmNsID0gaW5pdFdlYkNMKCk7XHJcblx0XHRpZiAod2ViY2wgIT09IG51bGwpIHtcclxuXHRcdFx0dmFyIHBsYXRmb3JtcyA9IGNsLmdldFBsYXRmb3JtcygpO1xyXG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHBsYXRmb3Jtcy5sZW5ndGg7ICsraSkge1xyXG5cdFx0XHRcdHZhciBwbGF0Zm9ybSA9IHBsYXRmb3Jtc1tpXTtcclxuXHRcdFx0XHR2YXIgZGV2aWNlcyA9IHBsYXRmb3JtLmdldERldmljZXMoY2wuREVWSUNFX1RZUEVfQUxMKTtcclxuXHRcdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGRldmljZXMubGVuZ3RoOyArK2opIHtcclxuXHRcdFx0XHRcdHZhciBkZXZpY2UgPSBkZXZpY2VzW2pdO1xyXG5cdFx0XHRcdFx0aWYgKGlzRlA2NENhcGFibGUoZGV2aWNlKSkge1xyXG5cdFx0XHRcdFx0XHRhdmFpbGFibGVEZXZpY2VzLnB1c2goZGV2aWNlKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdGdlbmVyYXRlQXZhaWxhYmxlRGV2aWNlc0Rlc2NyaXB0aW9ucygpO1xyXG5cdH1cclxuXHRyZXR1cm4gYXZhaWxhYmxlRGV2aWNlcztcclxufTtcclxuXHJcbnZhciBnZW5lcmF0ZUF2YWlsYWJsZURldmljZXNEZXNjcmlwdGlvbnMgPSBmdW5jdGlvbigpIHtcclxuXHRhdmFpbGFibGVEZXZpY2VzRGVzY3JpcHRpb25zID0gW107XHJcblx0LyogSWYgZGV2aWNlcyBuYW1lcyBhcmUgYXZhaWxhYmxlLCB1c2UgdGhlbSAqL1xyXG5cdHZhciBoYXZlTmFtZXMgPSB0cnVlO1xyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgYXZhaWxhYmxlRGV2aWNlcy5sZW5ndGg7ICsraSkge1xyXG5cdFx0dmFyIGRldmljZSA9IGF2YWlsYWJsZURldmljZXNbaV07XHJcblx0XHR2YXIgbmFtZSA9IGRldmljZS5nZXRJbmZvKGNsLkRFVklDRV9OQU1FKTtcclxuXHRcdGlmICgobmFtZSA9PT0gbnVsbCkgfHwgKG5hbWUgPT09IFwiXCIpKSB7XHJcblx0XHRcdGhhdmVOYW1lcyA9IGZhbHNlO1xyXG5cdFx0XHRicmVhaztcclxuXHRcdH1cclxuXHRcdGF2YWlsYWJsZURldmljZXNEZXNjcmlwdGlvbnNbaV0gPSBuYW1lO1xyXG5cdH1cclxuXHRpZiAoIWhhdmVOYW1lcykge1xyXG5cdFx0LyogQXQgbGVhc3Qgc29tZSBuYW1lcyBhcmUgbm90IGF2YWlsYWJsZTogdHJ5IHRvIGFzc2lnbiBuYW1lcyBiYXNlZCBvbiBjbGFzc2lmaWNhdGlvbiAoZS5nLiBcIkNQVVwiLCBcImRHUFVcIiwgXCJpR1BVXCIpICovXHJcblx0XHR2YXIgY3B1Q291bnQgPSAwLCBpZ3B1Q291bnQgPSAwLCBkZ3B1Q291bnQgPSAwO1xyXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhdmFpbGFibGVEZXZpY2VzLmxlbmd0aDsgKytpKSB7XHJcblx0XHRcdHZhciBkZXZpY2UgPSBhdmFpbGFibGVEZXZpY2VzW2ldO1xyXG5cdFx0XHR2YXIgY2xhc3NpZmljYXRpb24gPSBjbGFzc2lmeURldmljZShkZXZpY2UpO1xyXG5cdFx0XHRpZiAoY2xhc3NpZmljYXRpb24gPT09IFwiY3B1XCIpIHtcclxuXHRcdFx0XHQrK2NwdUNvdW50O1xyXG5cdFx0XHRcdGF2YWlsYWJsZURldmljZXNEZXNjcmlwdGlvbnNbaV0gPSBcIkNQVVwiO1xyXG5cdFx0XHR9IGVsc2UgaWYgKGNsYXNzaWZpY2F0aW9uID09PSBcImlncHVcIikge1xyXG5cdFx0XHRcdCsraWdwdUNvdW50O1xyXG5cdFx0XHRcdGF2YWlsYWJsZURldmljZXNEZXNjcmlwdGlvbnNbaV0gPSBcImlHUFVcIjtcclxuXHRcdFx0fSBlbHNlIGlmIChjbGFzc2lmaWNhdGlvbiA9PT0gXCJkZ3B1XCIpIHtcclxuXHRcdFx0XHQrK2RncHVDb3VudDtcclxuXHRcdFx0XHRhdmFpbGFibGVEZXZpY2VzRGVzY3JpcHRpb25zW2ldID0gXCJkR1BVXCI7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiSW1wb3NzaWJsZSBkZXZpY2UgY2xhc3NpZmljYXRpb246IFwiICsgY2xhc3NpZmljYXRpb24pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRpZiAoKGNwdUNvdW50ID4gMSkgfHwgKGlncHVDb3VudCA+IDEpIHx8IChkZ3B1Q291bnQgPiAxKSkge1xyXG5cdFx0XHQvKiBXZSBoYXZlIG11bHRpcGxlIGRldmljZXMgb2YgdGhlIHNhbWUgdHlwZS4gTmVlZCB0byB1c2UgbW9yZSBjb21wbGljYXRlZCBuYW1pbmcgc2NoZW1lICovXHJcblx0XHRcdHZhciBjcHVJbmRleCA9IDAsIGlncHVJbmRleCA9IDAsIGRncHVJbmRleCA9IDA7XHJcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYXZhaWxhYmxlRGV2aWNlcy5sZW5ndGg7ICsraSkge1xyXG5cdFx0XHRcdHZhciBkZXZpY2UgPSBhdmFpbGFibGVEZXZpY2VzW2ldO1xyXG5cdFx0XHRcdHZhciBjbGFzc2lmaWNhdGlvbiA9IGNsYXNzaWZ5RGV2aWNlKGRldmljZSk7XHJcblx0XHRcdFx0aWYgKGNsYXNzaWZpY2F0aW9uID09PSBcImNwdVwiKSB7XHJcblx0XHRcdFx0XHRpZiAoY3B1Q291bnQgPiAxKSB7XHJcblx0XHRcdFx0XHRcdCsrY3B1SW5kZXg7XHJcblx0XHRcdFx0XHRcdGF2YWlsYWJsZURldmljZXNEZXNjcmlwdGlvbnNbaV0gPSBcIkNQVSAjXCIgKyBjcHVJbmRleDtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9IGVsc2UgaWYgKGNsYXNzaWZpY2F0aW9uID09PSBcImlncHVcIikge1xyXG5cdFx0XHRcdFx0aWYgKGlncHVDb3VudCA+IDEpIHtcclxuXHRcdFx0XHRcdFx0KytpZ3B1SW5kZXg7XHJcblx0XHRcdFx0XHRcdGF2YWlsYWJsZURldmljZXNEZXNjcmlwdGlvbnNbaV0gPSBcImlHUFUgI1wiICsgaWdwdUluZGV4O1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0gZWxzZSBpZiAoY2xhc3NpZmljYXRpb24gPT09IFwiZGdwdVwiKSB7XHJcblx0XHRcdFx0XHRpZiAoZGdwdUNvdW50ID4gMSkge1xyXG5cdFx0XHRcdFx0XHQrK2RncHVDb3VudDtcclxuXHRcdFx0XHRcdFx0YXZhaWxhYmxlRGV2aWNlc0Rlc2NyaXB0aW9uc1tpXSA9IFwiZEdQVSAjXCIgKyBkZ3B1SW5kZXg7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIkltcG9zc2libGUgZGV2aWNlIGNsYXNzaWZpY2F0aW9uOiBcIiArIGNsYXNzaWZpY2F0aW9uKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcbn07XHJcblxyXG4vKipcclxuICogQ2xhc3NpZmllcyBXZWJDTCBkZXZpY2UgdG8gb25lIG9mIGZvdXIgY2F0ZWdvcmllczpcclxuICogLSBcImNwdVwiIGZvciBDUFUgZGV2aWNlcy5cclxuICogLSBcImlncHVcIiBmb3IgR1BVcyBpbnRlZ3JhdGVkIHdpdGggQ1BVIHBhY2thZ2Ugb3IgY2hpcHNldC5cclxuICogLSBcImRncHVcIiBmb3IgZGlzY3JldGUgR1BVcy5cclxuICogLSBcInVua25vd25cIiBmb3Igb3RoZXIgdHlwZXMgb2YgZGV2aWNlcyAoZS5nLiBGUEdBcylcclxuICpcclxuICogQHByaXZhdGVcclxuICogQG1ldGhvZCBjbGFzc2lmeURldmljZVxyXG4gKiBAcGFyYW0ge1dlYkNMRGV2aWNlfSBkZXZpY2UgLSB0aGUgV2ViQ0wgZGV2aWNlIHRvIGNsYXNzaWZ5LlxyXG4gKiBAcmV0dXJuIHtTdHJpbmd9IC0gb25lIG9mIHRoZSBzdHJpbmdzIGRlc2NyaWJlZCBhYm92ZS5cclxuICovXHJcbnZhciBjbGFzc2lmeURldmljZSA9IGZ1bmN0aW9uKGRldmljZSkge1xyXG5cdHRyeSB7XHJcblx0XHR2YXIgZGV2aWNlVHlwZSA9IGRldmljZS5nZXRJbmZvKGNsLkRFVklDRV9UWVBFKTtcclxuXHRcdGlmIChkZXZpY2VUeXBlID09PSBjbC5ERVZJQ0VfVFlQRV9DUFUpIHtcclxuXHRcdFx0cmV0dXJuIFwiY3B1XCI7XHJcblx0XHR9IGVsc2UgaWYgKGRldmljZVR5cGUgPT09IGNsLkRFVklDRV9UWVBFX0dQVSkge1xyXG5cdFx0XHR2YXIgaXNIb3N0VW5pZmllZE1lbW9yeSA9IGRldmljZS5nZXRJbmZvKGNsLkRFVklDRV9IT1NUX1VOSUZJRURfTUVNT1JZKTtcclxuXHRcdFx0cmV0dXJuIChpc0hvc3RVbmlmaWVkTWVtb3J5ID8gXCJpZ3B1XCIgOiBcImRncHVcIik7XHJcblx0XHR9XHJcblx0fSBjYXRjaCAoZSkge1xyXG5cdH1cclxuXHRyZXR1cm4gXCJ1bmtub3duXCI7XHJcbn07XHJcblxyXG4vKipcclxuICogU2VsZWN0cyB0aGUgb3B0aW1hbCBXZWJDTCBkZXZpY2UgYW1vbmcgdGhlIGF2YWlsYWJsZSBkZXZpY2VzLlxyXG4gKiBUaGUgcHJpb3JpdHkgb2YgZGV2aWNlczogXCJkZ3B1XCIgPiBcImlncHVcIiA+IFwiY3B1XCJcclxuICpcclxuICogQHByaXZhdGVcclxuICogQG1ldGhvZCBnZXREZWZhdWx0RGV2aWNlSW5kZXhcclxuICogQHJldHVybiB7V2ViQ0xEZXZpY2V9IC0gdGhlIHNlbGVjdGVkIGRldmljZSBmcm9tIHRoZSBsaXN0LlxyXG4gKi9cclxudmFyIGdldERlZmF1bHREZXZpY2VJbmRleCA9IGZ1bmN0aW9uKCkge1xyXG5cdGlmIChkZWZhdWx0RGV2aWNlSW5kZXggPT09IC0xKSB7XHJcblx0XHR2YXIgYXZhaWxhYmxlRGV2aWNlcyA9IGdldEF2YWlsYWJsZURldmljZXMoKTtcclxuXHRcdGlmIChhdmFpbGFibGVEZXZpY2VzLmxlbmd0aCA9PT0gMCkge1xyXG5cdFx0XHRkZWZhdWx0RGV2aWNlSW5kZXggPSAtMjtcclxuXHRcdFx0cmV0dXJuIGRlZmF1bHREZXZpY2VJbmRleDtcclxuXHRcdH1cclxuXHRcdHZhciBkZXZpY2VDbGFzc2lmaWNhdGlvbnMgPSBbXTtcclxuXHRcdC8qIFNlYXJjaCBmb3IgXCJkZ3B1XCIgKi9cclxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYXZhaWxhYmxlRGV2aWNlcy5sZW5ndGg7ICsraSkge1xyXG5cdFx0XHR2YXIgZGV2aWNlID0gYXZhaWxhYmxlRGV2aWNlc1tpXTtcclxuXHRcdFx0dmFyIGRldmljZUNsYXNzID0gY2xhc3NpZnlEZXZpY2UoZGV2aWNlKTtcclxuXHRcdFx0aWYgKGRldmljZUNsYXNzID09PSBcImRncHVcIikge1xyXG5cdFx0XHRcdGRlZmF1bHREZXZpY2VJbmRleCA9IGk7XHJcblx0XHRcdFx0cmV0dXJuIGk7XHJcblx0XHRcdH1cclxuXHRcdFx0ZGV2aWNlQ2xhc3NpZmljYXRpb25zLnB1c2goZGV2aWNlQ2xhc3MpO1xyXG5cdFx0fVxyXG5cdFx0LyogU2VhcmNoIGZvciBcImlncHVcIiAqL1xyXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhdmFpbGFibGVEZXZpY2VzLmxlbmd0aDsgKytpKSB7XHJcblx0XHRcdGlmIChkZXZpY2VDbGFzc2lmaWNhdGlvbnNbaV0gPT09IFwiaWdwdVwiKSB7XHJcblx0XHRcdFx0ZGVmYXVsdERldmljZUluZGV4ID0gaTtcclxuXHRcdFx0XHRyZXR1cm4gaTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0LyogU2VhcmNoIGZvciBcImNwdVwiICovXHJcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGF2YWlsYWJsZURldmljZXMubGVuZ3RoOyArK2kpIHtcclxuXHRcdFx0aWYgKGRldmljZUNsYXNzaWZpY2F0aW9uc1tpXSA9PT0gXCJjcHVcIikge1xyXG5cdFx0XHRcdGRlZmF1bHREZXZpY2VJbmRleCA9IGk7XHJcblx0XHRcdFx0cmV0dXJuIGk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblx0cmV0dXJuIGRlZmF1bHREZXZpY2VJbmRleDtcclxufTtcclxuXHJcbnZhciBjcmVhdGVLZXJuZWxzID0gZnVuY3Rpb24ocHJvZ3JhbSkge1xyXG5cdHZhciBrZXJuZWxzID0ge1xyXG5cdFx0c2V0OiB7XHJcblx0XHRcdGYzMjogcHJvZ3JhbS5jcmVhdGVLZXJuZWwoXCJzZXRfZjMyXCIpLFxyXG5cdFx0XHRmNjQ6IHByb2dyYW0uY3JlYXRlS2VybmVsKFwic2V0X2Y2NFwiKVxyXG5cdFx0fSxcclxuXHRcdGxpbnNwYWNlOiB7XHJcblx0XHRcdGYzMjogcHJvZ3JhbS5jcmVhdGVLZXJuZWwoXCJsaW5zcGFjZV9mMzJcIiksXHJcblx0XHRcdGY2NDogcHJvZ3JhbS5jcmVhdGVLZXJuZWwoXCJsaW5zcGFjZV9mNjRcIilcclxuXHRcdH0sXHJcblx0XHRyZXBlYXQ6IHtcclxuXHRcdFx0ZjMyOiBwcm9ncmFtLmNyZWF0ZUtlcm5lbChcInJlcGVhdF9mMzJcIiksXHJcblx0XHRcdGY2NDogcHJvZ3JhbS5jcmVhdGVLZXJuZWwoXCJyZXBlYXRfZjY0XCIpXHJcblx0XHR9LFxyXG5cdFx0YWRkOiB7XHJcblx0XHRcdGYzMjogcHJvZ3JhbS5jcmVhdGVLZXJuZWwoXCJhZGRfZjMyXCIpLFxyXG5cdFx0XHRmNjQ6IHByb2dyYW0uY3JlYXRlS2VybmVsKFwiYWRkX2Y2NFwiKVxyXG5cdFx0fSxcclxuXHRcdHN1Yjoge1xyXG5cdFx0XHRmMzI6IHByb2dyYW0uY3JlYXRlS2VybmVsKFwic3ViX2YzMlwiKSxcclxuXHRcdFx0ZjY0OiBwcm9ncmFtLmNyZWF0ZUtlcm5lbChcInN1Yl9mNjRcIilcclxuXHRcdH0sXHJcblx0XHRtdWw6IHtcclxuXHRcdFx0ZjMyOiBwcm9ncmFtLmNyZWF0ZUtlcm5lbChcIm11bF9mMzJcIiksXHJcblx0XHRcdGY2NDogcHJvZ3JhbS5jcmVhdGVLZXJuZWwoXCJtdWxfZjY0XCIpXHJcblx0XHR9LFxyXG5cdFx0ZGl2OiB7XHJcblx0XHRcdGYzMjogcHJvZ3JhbS5jcmVhdGVLZXJuZWwoXCJkaXZfZjMyXCIpLFxyXG5cdFx0XHRmNjQ6IHByb2dyYW0uY3JlYXRlS2VybmVsKFwiZGl2X2Y2NFwiKVxyXG5cdFx0fSxcclxuXHRcdGFkZGM6IHtcclxuXHRcdFx0ZjMyOiBwcm9ncmFtLmNyZWF0ZUtlcm5lbChcImFkZGNfZjMyXCIpLFxyXG5cdFx0XHRmNjQ6IHByb2dyYW0uY3JlYXRlS2VybmVsKFwiYWRkY19mNjRcIilcclxuXHRcdH0sXHJcblx0XHRzdWJjOiB7XHJcblx0XHRcdGYzMjogcHJvZ3JhbS5jcmVhdGVLZXJuZWwoXCJzdWJjX2YzMlwiKSxcclxuXHRcdFx0ZjY0OiBwcm9ncmFtLmNyZWF0ZUtlcm5lbChcInN1YmNfZjY0XCIpXHJcblx0XHR9LFxyXG5cdFx0c3VicmM6IHtcclxuXHRcdFx0ZjMyOiBwcm9ncmFtLmNyZWF0ZUtlcm5lbChcInN1YnJjX2YzMlwiKSxcclxuXHRcdFx0ZjY0OiBwcm9ncmFtLmNyZWF0ZUtlcm5lbChcInN1YnJjX2Y2NFwiKVxyXG5cdFx0fSxcclxuXHRcdG11bGM6IHtcclxuXHRcdFx0ZjMyOiBwcm9ncmFtLmNyZWF0ZUtlcm5lbChcIm11bGNfZjMyXCIpLFxyXG5cdFx0XHRmNjQ6IHByb2dyYW0uY3JlYXRlS2VybmVsKFwibXVsY19mNjRcIilcclxuXHRcdH0sXHJcblx0XHRkaXZjOiB7XHJcblx0XHRcdGYzMjogcHJvZ3JhbS5jcmVhdGVLZXJuZWwoXCJkaXZjX2YzMlwiKSxcclxuXHRcdFx0ZjY0OiBwcm9ncmFtLmNyZWF0ZUtlcm5lbChcImRpdmNfZjY0XCIpXHJcblx0XHR9LFxyXG5cdFx0ZGl2cmM6IHtcclxuXHRcdFx0ZjMyOiBwcm9ncmFtLmNyZWF0ZUtlcm5lbChcImRpdnJjX2YzMlwiKSxcclxuXHRcdFx0ZjY0OiBwcm9ncmFtLmNyZWF0ZUtlcm5lbChcImRpdnJjX2Y2NFwiKVxyXG5cdFx0fSxcclxuXHRcdG5lZzoge1xyXG5cdFx0XHRmMzI6IHByb2dyYW0uY3JlYXRlS2VybmVsKFwibmVnX2YzMlwiKSxcclxuXHRcdFx0ZjY0OiBwcm9ncmFtLmNyZWF0ZUtlcm5lbChcIm5lZ19mNjRcIilcclxuXHRcdH0sXHJcblx0XHRhYnM6IHtcclxuXHRcdFx0ZjMyOiBwcm9ncmFtLmNyZWF0ZUtlcm5lbChcImFic19mMzJcIiksXHJcblx0XHRcdGY2NDogcHJvZ3JhbS5jcmVhdGVLZXJuZWwoXCJhYnNfZjY0XCIpXHJcblx0XHR9LFxyXG5cdFx0ZXhwOiB7XHJcblx0XHRcdGYzMjogcHJvZ3JhbS5jcmVhdGVLZXJuZWwoXCJleHBfZjMyXCIpLFxyXG5cdFx0XHRmNjQ6IHByb2dyYW0uY3JlYXRlS2VybmVsKFwiZXhwX2Y2NFwiKVxyXG5cdFx0fSxcclxuXHRcdGxvZzoge1xyXG5cdFx0XHRmMzI6IHByb2dyYW0uY3JlYXRlS2VybmVsKFwibG9nX2YzMlwiKSxcclxuXHRcdFx0ZjY0OiBwcm9ncmFtLmNyZWF0ZUtlcm5lbChcImxvZ19mNjRcIilcclxuXHRcdH0sXHJcblx0XHRzcXJ0OiB7XHJcblx0XHRcdGYzMjogcHJvZ3JhbS5jcmVhdGVLZXJuZWwoXCJzcXJ0X2YzMlwiKSxcclxuXHRcdFx0ZjY0OiBwcm9ncmFtLmNyZWF0ZUtlcm5lbChcInNxcnRfZjY0XCIpXHJcblx0XHR9LFxyXG5cdFx0c3F1YXJlOiB7XHJcblx0XHRcdGYzMjogcHJvZ3JhbS5jcmVhdGVLZXJuZWwoXCJzcXVhcmVfZjMyXCIpLFxyXG5cdFx0XHRmNjQ6IHByb2dyYW0uY3JlYXRlS2VybmVsKFwic3F1YXJlX2Y2NFwiKVxyXG5cdFx0fSxcclxuXHRcdHN1bToge1xyXG5cdFx0XHRmMzI6IHByb2dyYW0uY3JlYXRlS2VybmVsKFwic3VtX2YzMl9ncHVcIiksXHJcblx0XHRcdGY2NDogcHJvZ3JhbS5jcmVhdGVLZXJuZWwoXCJzdW1fZjY0X2dwdVwiKVxyXG5cdFx0fSxcclxuXHRcdG1pbjoge1xyXG5cdFx0XHRmMzI6IHByb2dyYW0uY3JlYXRlS2VybmVsKFwibWluX2YzMl9ncHVcIiksXHJcblx0XHRcdGY2NDogcHJvZ3JhbS5jcmVhdGVLZXJuZWwoXCJtaW5fZjY0X2dwdVwiKVxyXG5cdFx0fSxcclxuXHRcdG1heDoge1xyXG5cdFx0XHRmMzI6IHByb2dyYW0uY3JlYXRlS2VybmVsKFwibWF4X2YzMl9ncHVcIiksXHJcblx0XHRcdGY2NDogcHJvZ3JhbS5jcmVhdGVLZXJuZWwoXCJtYXhfZjY0X2dwdVwiKVxyXG5cdFx0fSxcclxuXHRcdGFzdW06IHtcclxuXHRcdFx0ZjMyOiBwcm9ncmFtLmNyZWF0ZUtlcm5lbChcImFzdW1fZjMyXCIpLFxyXG5cdFx0XHRmNjQ6IHByb2dyYW0uY3JlYXRlS2VybmVsKFwiYXN1bV9mNjRcIilcclxuXHRcdH0sXHJcblx0XHRhbWluOiB7XHJcblx0XHRcdGYzMjogcHJvZ3JhbS5jcmVhdGVLZXJuZWwoXCJhbWluX2YzMlwiKSxcclxuXHRcdFx0ZjY0OiBwcm9ncmFtLmNyZWF0ZUtlcm5lbChcImFtaW5fZjY0XCIpXHJcblx0XHR9LFxyXG5cdFx0YW1heDoge1xyXG5cdFx0XHRmMzI6IHByb2dyYW0uY3JlYXRlS2VybmVsKFwiYW1heF9mMzJcIiksXHJcblx0XHRcdGY2NDogcHJvZ3JhbS5jcmVhdGVLZXJuZWwoXCJhbWF4X2Y2NFwiKVxyXG5cdFx0fSxcclxuXHRcdGRvdDoge1xyXG5cdFx0XHRmMzI6IHByb2dyYW0uY3JlYXRlS2VybmVsKFwiZG90X2YzMlwiKSxcclxuXHRcdFx0ZjY0OiBwcm9ncmFtLmNyZWF0ZUtlcm5lbChcImRvdF9mNjRcIilcclxuXHRcdH1cclxuXHR9O1xyXG5cdHJldHVybiBrZXJuZWxzO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gV2ViQ0xDb250ZXh0KG9wdGlvbnMsIGNhbGxiYWNrKSB7XHJcblx0aW5pdFdlYkNMKCk7XHJcblx0dmFyIGJpbmFyeUtlcm5lbHNTb3VyY2UgPSBcImtlcm5lbCB2b2lkIGFkZF9mMzIoXFxyXFxuXFx0dWludCBsZW5ndGgsXFxyXFxuXFx0Z2xvYmFsIGZsb2F0KiBhLFxcclxcblxcdGdsb2JhbCBmbG9hdCogYixcXHJcXG5cXHRnbG9iYWwgZmxvYXQqIG91dClcXHJcXG57XFxyXFxuXFx0Y29uc3QgdWludCBpZCA9IGdldF9nbG9iYWxfaWQoMCk7XFxyXFxuXFx0aWYgKGlkIDwgbGVuZ3RoKSB7XFxyXFxuXFx0XFx0b3V0W2lkXSA9IGFbaWRdICsgYltpZF07XFxyXFxuXFx0fVxcclxcbn1cXHJcXG5rZXJuZWwgdm9pZCBhZGRfZjY0KFxcclxcblxcdHVpbnQgbGVuZ3RoLFxcclxcblxcdGdsb2JhbCBkb3VibGUqIGEsXFxyXFxuXFx0Z2xvYmFsIGRvdWJsZSogYixcXHJcXG5cXHRnbG9iYWwgZG91YmxlKiBvdXQpXFxyXFxue1xcclxcblxcdGNvbnN0IHVpbnQgaWQgPSBnZXRfZ2xvYmFsX2lkKDApO1xcclxcblxcdGlmIChpZCA8IGxlbmd0aCkge1xcclxcblxcdFxcdG91dFtpZF0gPSBhW2lkXSArIGJbaWRdO1xcclxcblxcdH1cXHJcXG59XFxyXFxua2VybmVsIHZvaWQgc3ViX2YzMihcXHJcXG5cXHR1aW50IGxlbmd0aCxcXHJcXG5cXHRnbG9iYWwgZmxvYXQqIGEsXFxyXFxuXFx0Z2xvYmFsIGZsb2F0KiBiLFxcclxcblxcdGdsb2JhbCBmbG9hdCogb3V0KVxcclxcbntcXHJcXG5cXHRjb25zdCB1aW50IGlkID0gZ2V0X2dsb2JhbF9pZCgwKTtcXHJcXG5cXHRpZiAoaWQgPCBsZW5ndGgpIHtcXHJcXG5cXHRcXHRvdXRbaWRdID0gYVtpZF0gLSBiW2lkXTtcXHJcXG5cXHR9XFxyXFxufVxcclxcbmtlcm5lbCB2b2lkIHN1Yl9mNjQoXFxyXFxuXFx0dWludCBsZW5ndGgsXFxyXFxuXFx0Z2xvYmFsIGRvdWJsZSogYSxcXHJcXG5cXHRnbG9iYWwgZG91YmxlKiBiLFxcclxcblxcdGdsb2JhbCBkb3VibGUqIG91dClcXHJcXG57XFxyXFxuXFx0Y29uc3QgdWludCBpZCA9IGdldF9nbG9iYWxfaWQoMCk7XFxyXFxuXFx0aWYgKGlkIDwgbGVuZ3RoKSB7XFxyXFxuXFx0XFx0b3V0W2lkXSA9IGFbaWRdIC0gYltpZF07XFxyXFxuXFx0fVxcclxcbn1cXHJcXG5rZXJuZWwgdm9pZCBtdWxfZjMyKFxcclxcblxcdHVpbnQgbGVuZ3RoLFxcclxcblxcdGdsb2JhbCBmbG9hdCogYSxcXHJcXG5cXHRnbG9iYWwgZmxvYXQqIGIsXFxyXFxuXFx0Z2xvYmFsIGZsb2F0KiBvdXQpXFxyXFxue1xcclxcblxcdGNvbnN0IHVpbnQgaWQgPSBnZXRfZ2xvYmFsX2lkKDApO1xcclxcblxcdGlmIChpZCA8IGxlbmd0aCkge1xcclxcblxcdFxcdG91dFtpZF0gPSBhW2lkXSAqIGJbaWRdO1xcclxcblxcdH1cXHJcXG59XFxyXFxua2VybmVsIHZvaWQgbXVsX2Y2NChcXHJcXG5cXHR1aW50IGxlbmd0aCxcXHJcXG5cXHRnbG9iYWwgZG91YmxlKiBhLFxcclxcblxcdGdsb2JhbCBkb3VibGUqIGIsXFxyXFxuXFx0Z2xvYmFsIGRvdWJsZSogb3V0KVxcclxcbntcXHJcXG5cXHRjb25zdCB1aW50IGlkID0gZ2V0X2dsb2JhbF9pZCgwKTtcXHJcXG5cXHRpZiAoaWQgPCBsZW5ndGgpIHtcXHJcXG5cXHRcXHRvdXRbaWRdID0gYVtpZF0gKiBiW2lkXTtcXHJcXG5cXHR9XFxyXFxufVxcclxcbmtlcm5lbCB2b2lkIGRpdl9mMzIoXFxyXFxuXFx0dWludCBsZW5ndGgsXFxyXFxuXFx0Z2xvYmFsIGZsb2F0KiBhLFxcclxcblxcdGdsb2JhbCBmbG9hdCogYixcXHJcXG5cXHRnbG9iYWwgZmxvYXQqIG91dClcXHJcXG57XFxyXFxuXFx0Y29uc3QgdWludCBpZCA9IGdldF9nbG9iYWxfaWQoMCk7XFxyXFxuXFx0aWYgKGlkIDwgbGVuZ3RoKSB7XFxyXFxuXFx0XFx0b3V0W2lkXSA9IGFbaWRdIC8gYltpZF07XFxyXFxuXFx0fVxcclxcbn1cXHJcXG5rZXJuZWwgdm9pZCBkaXZfZjY0KFxcclxcblxcdHVpbnQgbGVuZ3RoLFxcclxcblxcdGdsb2JhbCBkb3VibGUqIGEsXFxyXFxuXFx0Z2xvYmFsIGRvdWJsZSogYixcXHJcXG5cXHRnbG9iYWwgZG91YmxlKiBvdXQpXFxyXFxue1xcclxcblxcdGNvbnN0IHVpbnQgaWQgPSBnZXRfZ2xvYmFsX2lkKDApO1xcclxcblxcdGlmIChpZCA8IGxlbmd0aCkge1xcclxcblxcdFxcdG91dFtpZF0gPSBhW2lkXSAvIGJbaWRdO1xcclxcblxcdH1cXHJcXG59XFxyXFxua2VybmVsIHZvaWQgYWRkY19mMzIoXFxyXFxuXFx0dWludCBsZW5ndGgsXFxyXFxuXFx0Z2xvYmFsIGZsb2F0KiBhLFxcclxcblxcdGZsb2F0IGIsXFxyXFxuXFx0Z2xvYmFsIGZsb2F0KiBvdXQpXFxyXFxue1xcclxcblxcdGNvbnN0IHVpbnQgaWQgPSBnZXRfZ2xvYmFsX2lkKDApO1xcclxcblxcdGlmIChpZCA8IGxlbmd0aCkge1xcclxcblxcdFxcdG91dFtpZF0gPSBhW2lkXSArIGI7XFxyXFxuXFx0fVxcclxcbn1cXHJcXG5rZXJuZWwgdm9pZCBhZGRjX2Y2NChcXHJcXG5cXHR1aW50IGxlbmd0aCxcXHJcXG5cXHRnbG9iYWwgZG91YmxlKiBhLFxcclxcblxcdGRvdWJsZSBiLFxcclxcblxcdGdsb2JhbCBkb3VibGUqIG91dClcXHJcXG57XFxyXFxuXFx0Y29uc3QgdWludCBpZCA9IGdldF9nbG9iYWxfaWQoMCk7XFxyXFxuXFx0aWYgKGlkIDwgbGVuZ3RoKSB7XFxyXFxuXFx0XFx0b3V0W2lkXSA9IGFbaWRdICsgYjtcXHJcXG5cXHR9XFxyXFxufVxcclxcbmtlcm5lbCB2b2lkIHN1YmNfZjMyKFxcclxcblxcdHVpbnQgbGVuZ3RoLFxcclxcblxcdGdsb2JhbCBmbG9hdCogYSxcXHJcXG5cXHRmbG9hdCBiLFxcclxcblxcdGdsb2JhbCBmbG9hdCogb3V0KVxcclxcbntcXHJcXG5cXHRjb25zdCB1aW50IGlkID0gZ2V0X2dsb2JhbF9pZCgwKTtcXHJcXG5cXHRpZiAoaWQgPCBsZW5ndGgpIHtcXHJcXG5cXHRcXHRvdXRbaWRdID0gYVtpZF0gLSBiO1xcclxcblxcdH1cXHJcXG59XFxyXFxua2VybmVsIHZvaWQgc3ViY19mNjQoXFxyXFxuXFx0dWludCBsZW5ndGgsXFxyXFxuXFx0Z2xvYmFsIGRvdWJsZSogYSxcXHJcXG5cXHRkb3VibGUgYixcXHJcXG5cXHRnbG9iYWwgZG91YmxlKiBvdXQpXFxyXFxue1xcclxcblxcdGNvbnN0IHVpbnQgaWQgPSBnZXRfZ2xvYmFsX2lkKDApO1xcclxcblxcdGlmIChpZCA8IGxlbmd0aCkge1xcclxcblxcdFxcdG91dFtpZF0gPSBhW2lkXSAtIGI7XFxyXFxuXFx0fVxcclxcbn1cXHJcXG5rZXJuZWwgdm9pZCBzdWJyY19mMzIoXFxyXFxuXFx0dWludCBsZW5ndGgsXFxyXFxuXFx0Z2xvYmFsIGZsb2F0KiBhLFxcclxcblxcdGZsb2F0IGIsXFxyXFxuXFx0Z2xvYmFsIGZsb2F0KiBvdXQpXFxyXFxue1xcclxcblxcdGNvbnN0IHVpbnQgaWQgPSBnZXRfZ2xvYmFsX2lkKDApO1xcclxcblxcdGlmIChpZCA8IGxlbmd0aCkge1xcclxcblxcdFxcdG91dFtpZF0gPSBiIC8gYVtpZF07XFxyXFxuXFx0fVxcclxcbn1cXHJcXG5rZXJuZWwgdm9pZCBzdWJyY19mNjQoXFxyXFxuXFx0dWludCBsZW5ndGgsXFxyXFxuXFx0Z2xvYmFsIGRvdWJsZSogYSxcXHJcXG5cXHRkb3VibGUgYixcXHJcXG5cXHRnbG9iYWwgZG91YmxlKiBvdXQpXFxyXFxue1xcclxcblxcdGNvbnN0IHVpbnQgaWQgPSBnZXRfZ2xvYmFsX2lkKDApO1xcclxcblxcdGlmIChpZCA8IGxlbmd0aCkge1xcclxcblxcdFxcdG91dFtpZF0gPSBiIC8gYVtpZF07XFxyXFxuXFx0fVxcclxcbn1cXHJcXG5rZXJuZWwgdm9pZCBtdWxjX2YzMihcXHJcXG5cXHR1aW50IGxlbmd0aCxcXHJcXG5cXHRnbG9iYWwgZmxvYXQqIGEsXFxyXFxuXFx0ZmxvYXQgYixcXHJcXG5cXHRnbG9iYWwgZmxvYXQqIG91dClcXHJcXG57XFxyXFxuXFx0Y29uc3QgdWludCBpZCA9IGdldF9nbG9iYWxfaWQoMCk7XFxyXFxuXFx0aWYgKGlkIDwgbGVuZ3RoKSB7XFxyXFxuXFx0XFx0b3V0W2lkXSA9IGFbaWRdICogYjtcXHJcXG5cXHR9XFxyXFxufVxcclxcbmtlcm5lbCB2b2lkIG11bGNfZjY0KFxcclxcblxcdHVpbnQgbGVuZ3RoLFxcclxcblxcdGdsb2JhbCBkb3VibGUqIGEsXFxyXFxuXFx0ZG91YmxlIGIsXFxyXFxuXFx0Z2xvYmFsIGRvdWJsZSogb3V0KVxcclxcbntcXHJcXG5cXHRjb25zdCB1aW50IGlkID0gZ2V0X2dsb2JhbF9pZCgwKTtcXHJcXG5cXHRpZiAoaWQgPCBsZW5ndGgpIHtcXHJcXG5cXHRcXHRvdXRbaWRdID0gYVtpZF0gKiBiO1xcclxcblxcdH1cXHJcXG59XFxyXFxua2VybmVsIHZvaWQgZGl2Y19mMzIoXFxyXFxuXFx0dWludCBsZW5ndGgsXFxyXFxuXFx0Z2xvYmFsIGZsb2F0KiBhLFxcclxcblxcdGZsb2F0IGIsXFxyXFxuXFx0Z2xvYmFsIGZsb2F0KiBvdXQpXFxyXFxue1xcclxcblxcdGNvbnN0IHVpbnQgaWQgPSBnZXRfZ2xvYmFsX2lkKDApO1xcclxcblxcdGlmIChpZCA8IGxlbmd0aCkge1xcclxcblxcdFxcdG91dFtpZF0gPSBhW2lkXSAvIGI7XFxyXFxuXFx0fVxcclxcbn1cXHJcXG5rZXJuZWwgdm9pZCBkaXZjX2Y2NChcXHJcXG5cXHR1aW50IGxlbmd0aCxcXHJcXG5cXHRnbG9iYWwgZG91YmxlKiBhLFxcclxcblxcdGRvdWJsZSBiLFxcclxcblxcdGdsb2JhbCBkb3VibGUqIG91dClcXHJcXG57XFxyXFxuXFx0Y29uc3QgdWludCBpZCA9IGdldF9nbG9iYWxfaWQoMCk7XFxyXFxuXFx0aWYgKGlkIDwgbGVuZ3RoKSB7XFxyXFxuXFx0XFx0b3V0W2lkXSA9IGFbaWRdIC8gYjtcXHJcXG5cXHR9XFxyXFxufVxcclxcbmtlcm5lbCB2b2lkIGRpdnJjX2YzMihcXHJcXG5cXHR1aW50IGxlbmd0aCxcXHJcXG5cXHRnbG9iYWwgZmxvYXQqIGEsXFxyXFxuXFx0ZmxvYXQgYixcXHJcXG5cXHRnbG9iYWwgZmxvYXQqIG91dClcXHJcXG57XFxyXFxuXFx0Y29uc3QgdWludCBpZCA9IGdldF9nbG9iYWxfaWQoMCk7XFxyXFxuXFx0aWYgKGlkIDwgbGVuZ3RoKSB7XFxyXFxuXFx0XFx0b3V0W2lkXSA9IGIgLyBhW2lkXTtcXHJcXG5cXHR9XFxyXFxufVxcclxcbmtlcm5lbCB2b2lkIGRpdnJjX2Y2NChcXHJcXG5cXHR1aW50IGxlbmd0aCxcXHJcXG5cXHRnbG9iYWwgZG91YmxlKiBhLFxcclxcblxcdGRvdWJsZSBiLFxcclxcblxcdGdsb2JhbCBkb3VibGUqIG91dClcXHJcXG57XFxyXFxuXFx0Y29uc3QgdWludCBpZCA9IGdldF9nbG9iYWxfaWQoMCk7XFxyXFxuXFx0aWYgKGlkIDwgbGVuZ3RoKSB7XFxyXFxuXFx0XFx0b3V0W2lkXSA9IGIgLyBhW2lkXTtcXHJcXG5cXHR9XFxyXFxufVxcclxcblwiO1xyXG5cdHZhciB1bmFyeUtlcm5lbHNTb3VyY2UgPSBcImtlcm5lbCB2b2lkIG5lZ19mMzIoXFxyXFxuXFx0dWludCBsZW5ndGgsXFxyXFxuXFx0Z2xvYmFsIGZsb2F0KiBhLFxcclxcblxcdGdsb2JhbCBmbG9hdCogb3V0KVxcclxcbntcXHJcXG5cXHRjb25zdCB1aW50IGlkID0gZ2V0X2dsb2JhbF9pZCgwKTtcXHJcXG5cXHRpZiAoaWQgPCBsZW5ndGgpIHtcXHJcXG5cXHRcXHRvdXRbaWRdID0gLWFbaWRdO1xcclxcblxcdH1cXHJcXG59XFxyXFxua2VybmVsIHZvaWQgbmVnX2Y2NChcXHJcXG5cXHR1aW50IGxlbmd0aCxcXHJcXG5cXHRnbG9iYWwgZG91YmxlKiBhLFxcclxcblxcdGdsb2JhbCBkb3VibGUqIG91dClcXHJcXG57XFxyXFxuXFx0Y29uc3QgdWludCBpZCA9IGdldF9nbG9iYWxfaWQoMCk7XFxyXFxuXFx0aWYgKGlkIDwgbGVuZ3RoKSB7XFxyXFxuXFx0XFx0b3V0W2lkXSA9IC1hW2lkXTtcXHJcXG5cXHR9XFxyXFxufVxcclxcbmtlcm5lbCB2b2lkIGFic19mMzIoXFxyXFxuXFx0dWludCBsZW5ndGgsXFxyXFxuXFx0Z2xvYmFsIGZsb2F0KiBhLFxcclxcblxcdGdsb2JhbCBmbG9hdCogb3V0KVxcclxcbntcXHJcXG5cXHRjb25zdCB1aW50IGlkID0gZ2V0X2dsb2JhbF9pZCgwKTtcXHJcXG5cXHRpZiAoaWQgPCBsZW5ndGgpIHtcXHJcXG5cXHRcXHRvdXRbaWRdID0gZmFicyhhW2lkXSk7XFxyXFxuXFx0fVxcclxcbn1cXHJcXG5rZXJuZWwgdm9pZCBhYnNfZjY0KFxcclxcblxcdHVpbnQgbGVuZ3RoLFxcclxcblxcdGdsb2JhbCBkb3VibGUqIGEsXFxyXFxuXFx0Z2xvYmFsIGRvdWJsZSogb3V0KVxcclxcbntcXHJcXG5cXHRjb25zdCB1aW50IGlkID0gZ2V0X2dsb2JhbF9pZCgwKTtcXHJcXG5cXHRpZiAoaWQgPCBsZW5ndGgpIHtcXHJcXG5cXHRcXHRvdXRbaWRdID0gZmFicyhhW2lkXSk7XFxyXFxuXFx0fVxcclxcbn1cXHJcXG5rZXJuZWwgdm9pZCBleHBfZjMyKFxcclxcblxcdHVpbnQgbGVuZ3RoLFxcclxcblxcdGdsb2JhbCBmbG9hdCogYSxcXHJcXG5cXHRnbG9iYWwgZmxvYXQqIG91dClcXHJcXG57XFxyXFxuXFx0Y29uc3QgdWludCBpZCA9IGdldF9nbG9iYWxfaWQoMCk7XFxyXFxuXFx0aWYgKGlkIDwgbGVuZ3RoKSB7XFxyXFxuXFx0XFx0b3V0W2lkXSA9IGV4cChhW2lkXSk7XFxyXFxuXFx0fVxcclxcbn1cXHJcXG5rZXJuZWwgdm9pZCBleHBfZjY0KFxcclxcblxcdHVpbnQgbGVuZ3RoLFxcclxcblxcdGdsb2JhbCBkb3VibGUqIGEsXFxyXFxuXFx0Z2xvYmFsIGRvdWJsZSogb3V0KVxcclxcbntcXHJcXG5cXHRjb25zdCB1aW50IGlkID0gZ2V0X2dsb2JhbF9pZCgwKTtcXHJcXG5cXHRpZiAoaWQgPCBsZW5ndGgpIHtcXHJcXG5cXHRcXHRvdXRbaWRdID0gZXhwKGFbaWRdKTtcXHJcXG5cXHR9XFxyXFxufVxcclxcbmtlcm5lbCB2b2lkIGxvZ19mMzIoXFxyXFxuXFx0dWludCBsZW5ndGgsXFxyXFxuXFx0Z2xvYmFsIGZsb2F0KiBhLFxcclxcblxcdGdsb2JhbCBmbG9hdCogb3V0KVxcclxcbntcXHJcXG5cXHRjb25zdCB1aW50IGlkID0gZ2V0X2dsb2JhbF9pZCgwKTtcXHJcXG5cXHRpZiAoaWQgPCBsZW5ndGgpIHtcXHJcXG5cXHRcXHRvdXRbaWRdID0gbG9nKGFbaWRdKTtcXHJcXG5cXHR9XFxyXFxufVxcclxcbmtlcm5lbCB2b2lkIGxvZ19mNjQoXFxyXFxuXFx0dWludCBsZW5ndGgsXFxyXFxuXFx0Z2xvYmFsIGRvdWJsZSogYSxcXHJcXG5cXHRnbG9iYWwgZG91YmxlKiBvdXQpXFxyXFxue1xcclxcblxcdGNvbnN0IHVpbnQgaWQgPSBnZXRfZ2xvYmFsX2lkKDApO1xcclxcblxcdGlmIChpZCA8IGxlbmd0aCkge1xcclxcblxcdFxcdG91dFtpZF0gPSBsb2coYVtpZF0pO1xcclxcblxcdH1cXHJcXG59XFxyXFxua2VybmVsIHZvaWQgc3FydF9mMzIoXFxyXFxuXFx0dWludCBsZW5ndGgsXFxyXFxuXFx0Z2xvYmFsIGZsb2F0KiBhLFxcclxcblxcdGdsb2JhbCBmbG9hdCogb3V0KVxcclxcbntcXHJcXG5cXHRjb25zdCB1aW50IGlkID0gZ2V0X2dsb2JhbF9pZCgwKTtcXHJcXG5cXHRpZiAoaWQgPCBsZW5ndGgpIHtcXHJcXG5cXHRcXHRvdXRbaWRdID0gc3FydChhW2lkXSk7XFxyXFxuXFx0fVxcclxcbn1cXHJcXG5rZXJuZWwgdm9pZCBzcXJ0X2Y2NChcXHJcXG5cXHR1aW50IGxlbmd0aCxcXHJcXG5cXHRnbG9iYWwgZG91YmxlKiBhLFxcclxcblxcdGdsb2JhbCBkb3VibGUqIG91dClcXHJcXG57XFxyXFxuXFx0Y29uc3QgdWludCBpZCA9IGdldF9nbG9iYWxfaWQoMCk7XFxyXFxuXFx0aWYgKGlkIDwgbGVuZ3RoKSB7XFxyXFxuXFx0XFx0b3V0W2lkXSA9IHNxcnQoYVtpZF0pO1xcclxcblxcdH1cXHJcXG59XFxyXFxua2VybmVsIHZvaWQgc3F1YXJlX2YzMihcXHJcXG5cXHR1aW50IGxlbmd0aCxcXHJcXG5cXHRnbG9iYWwgZmxvYXQqIGEsXFxyXFxuXFx0Z2xvYmFsIGZsb2F0KiBvdXQpXFxyXFxue1xcclxcblxcdGNvbnN0IHVpbnQgaWQgPSBnZXRfZ2xvYmFsX2lkKDApO1xcclxcblxcdGlmIChpZCA8IGxlbmd0aCkge1xcclxcblxcdFxcdGNvbnN0IGZsb2F0IGFWYWwgPSBhW2lkXTsgXFxyXFxuXFx0XFx0b3V0W2lkXSA9IGFWYWwgKiBhVmFsO1xcclxcblxcdH1cXHJcXG59XFxyXFxua2VybmVsIHZvaWQgc3F1YXJlX2Y2NChcXHJcXG5cXHR1aW50IGxlbmd0aCxcXHJcXG5cXHRnbG9iYWwgZG91YmxlKiBhLFxcclxcblxcdGdsb2JhbCBkb3VibGUqIG91dClcXHJcXG57XFxyXFxuXFx0Y29uc3QgdWludCBpZCA9IGdldF9nbG9iYWxfaWQoMCk7XFxyXFxuXFx0aWYgKGlkIDwgbGVuZ3RoKSB7XFxyXFxuXFx0XFx0Y29uc3QgZG91YmxlIGFWYWwgPSBhW2lkXTtcXHJcXG5cXHRcXHRvdXRbaWRdID0gYVZhbCAqIGFWYWw7XFxyXFxuXFx0fVxcclxcbn1cXHJcXG5cIjtcclxuXHR2YXIgcmVkdWN0aW9uS2VybmVsc1NvdXJjZSA9IFwia2VybmVsIHZvaWQgc3VtX2YzMl9ncHUoXFxyXFxuXFx0dWludCBsZW5ndGgsXFxyXFxuXFx0Z2xvYmFsIGZsb2F0KiBhLFxcclxcblxcdGxvY2FsIGZsb2F0KiBzY3JhdGNoLFxcclxcblxcdGdsb2JhbCBmbG9hdCogb3V0KVxcclxcbntcXHJcXG5cXHRjb25zdCB1aW50IGdsb2JhbFNpemUgPSBnZXRfZ2xvYmFsX3NpemUoMCk7XFxyXFxuXFx0dWludCBnbG9iYWxJbmRleCA9IGdldF9nbG9iYWxfaWQoMCk7XFxyXFxuXFx0ZmxvYXQgYWNjdW11bGF0b3IgPSAwLjBmO1xcclxcblxcdHdoaWxlIChnbG9iYWxJbmRleCA8IGxlbmd0aCkge1xcclxcblxcdFxcdGFjY3VtdWxhdG9yICs9IGFbZ2xvYmFsSW5kZXhdO1xcclxcblxcdFxcdGdsb2JhbEluZGV4ICs9IGdsb2JhbFNpemU7XFxyXFxuXFx0fVxcclxcblxcclxcblxcdHVpbnQgbG9jYWxJbmRleCA9IGdldF9sb2NhbF9pZCgwKTtcXHJcXG5cXHRzY3JhdGNoW2xvY2FsSW5kZXhdID0gYWNjdW11bGF0b3I7XFxyXFxuXFx0YmFycmllcihDTEtfTE9DQUxfTUVNX0ZFTkNFKTtcXHJcXG5cXHRmb3IgKHVpbnQgb2Zmc2V0ID0gZ2V0X2xvY2FsX3NpemUoMCkgLyAyOyBvZmZzZXQgIT0gMDsgb2Zmc2V0ID4+PSAxKSB7XFxyXFxuXFx0XFx0aWYgKGxvY2FsSW5kZXggPCBvZmZzZXQpIHtcXHJcXG5cXHRcXHRcXHRzY3JhdGNoW2xvY2FsSW5kZXhdICs9IHNjcmF0Y2hbbG9jYWxJbmRleCArIG9mZnNldF07XFxyXFxuXFx0XFx0fVxcclxcblxcdFxcdGJhcnJpZXIoQ0xLX0xPQ0FMX01FTV9GRU5DRSk7XFxyXFxuXFx0fVxcclxcblxcdGlmIChsb2NhbEluZGV4ID09IDApIHtcXHJcXG5cXHRcXHRvdXRbZ2V0X2dyb3VwX2lkKDApXSA9IHNjcmF0Y2hbMF07XFxyXFxuXFx0fVxcclxcbn1cXHJcXG5cXHJcXG5rZXJuZWwgdm9pZCBzdW1fZjY0X2dwdShcXHJcXG5cXHR1aW50IGxlbmd0aCxcXHJcXG5cXHRnbG9iYWwgZG91YmxlKiBhLFxcclxcblxcdGxvY2FsIGRvdWJsZSogc2NyYXRjaCxcXHJcXG5cXHRnbG9iYWwgZG91YmxlKiBvdXQpXFxyXFxue1xcclxcblxcdGNvbnN0IHVpbnQgZ2xvYmFsU2l6ZSA9IGdldF9nbG9iYWxfc2l6ZSgwKTtcXHJcXG5cXHR1aW50IGdsb2JhbEluZGV4ID0gZ2V0X2dsb2JhbF9pZCgwKTtcXHJcXG5cXHRkb3VibGUgYWNjdW11bGF0b3IgPSAwLjA7XFxyXFxuXFx0d2hpbGUgKGdsb2JhbEluZGV4IDwgbGVuZ3RoKSB7XFxyXFxuXFx0XFx0YWNjdW11bGF0b3IgKz0gYVtnbG9iYWxJbmRleF07XFxyXFxuXFx0XFx0Z2xvYmFsSW5kZXggKz0gZ2xvYmFsU2l6ZTtcXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0dWludCBsb2NhbEluZGV4ID0gZ2V0X2xvY2FsX2lkKDApO1xcclxcblxcdHNjcmF0Y2hbbG9jYWxJbmRleF0gPSBhY2N1bXVsYXRvcjtcXHJcXG5cXHRiYXJyaWVyKENMS19MT0NBTF9NRU1fRkVOQ0UpO1xcclxcblxcdGZvciAodWludCBvZmZzZXQgPSBnZXRfbG9jYWxfc2l6ZSgwKSAvIDI7IG9mZnNldCAhPSAwOyBvZmZzZXQgPj49IDEpIHtcXHJcXG5cXHRcXHRpZiAobG9jYWxJbmRleCA8IG9mZnNldCkge1xcclxcblxcdFxcdFxcdHNjcmF0Y2hbbG9jYWxJbmRleF0gKz0gc2NyYXRjaFtsb2NhbEluZGV4ICsgb2Zmc2V0XTtcXHJcXG5cXHRcXHR9XFxyXFxuXFx0XFx0YmFycmllcihDTEtfTE9DQUxfTUVNX0ZFTkNFKTtcXHJcXG5cXHR9XFxyXFxuXFx0aWYgKGxvY2FsSW5kZXggPT0gMCkge1xcclxcblxcdFxcdG91dFtnZXRfZ3JvdXBfaWQoMCldID0gc2NyYXRjaFswXTtcXHJcXG5cXHR9XFxyXFxufVxcclxcblxcclxcbmtlcm5lbCB2b2lkIG1pbl9mMzJfZ3B1KFxcclxcblxcdHVpbnQgbGVuZ3RoLFxcclxcblxcdGdsb2JhbCBmbG9hdCogYSxcXHJcXG5cXHRsb2NhbCBmbG9hdCogc2NyYXRjaCxcXHJcXG5cXHRnbG9iYWwgZmxvYXQqIG91dClcXHJcXG57XFxyXFxuXFx0Y29uc3QgdWludCBnbG9iYWxTaXplID0gZ2V0X2dsb2JhbF9zaXplKDApO1xcclxcblxcdHVpbnQgZ2xvYmFsSW5kZXggPSBnZXRfZ2xvYmFsX2lkKDApO1xcclxcblxcdGZsb2F0IGFjY3VtdWxhdG9yID0gSU5GSU5JVFk7XFxyXFxuXFx0d2hpbGUgKGdsb2JhbEluZGV4IDwgbGVuZ3RoKSB7XFxyXFxuXFx0XFx0YWNjdW11bGF0b3IgPSBtaW4oYWNjdW11bGF0b3IsIGFbZ2xvYmFsSW5kZXhdKTtcXHJcXG5cXHRcXHRnbG9iYWxJbmRleCArPSBnbG9iYWxTaXplO1xcclxcblxcdH1cXHJcXG5cXHJcXG5cXHR1aW50IGxvY2FsSW5kZXggPSBnZXRfbG9jYWxfaWQoMCk7XFxyXFxuXFx0c2NyYXRjaFtsb2NhbEluZGV4XSA9IGFjY3VtdWxhdG9yO1xcclxcblxcdGJhcnJpZXIoQ0xLX0xPQ0FMX01FTV9GRU5DRSk7XFxyXFxuXFx0Zm9yICh1aW50IG9mZnNldCA9IGdldF9sb2NhbF9zaXplKDApIC8gMjsgb2Zmc2V0ICE9IDA7IG9mZnNldCA+Pj0gMSkge1xcclxcblxcdFxcdGlmIChsb2NhbEluZGV4IDwgb2Zmc2V0KSB7XFxyXFxuXFx0XFx0XFx0c2NyYXRjaFtsb2NhbEluZGV4XSA9IG1pbihzY3JhdGNoW2xvY2FsSW5kZXhdLCBzY3JhdGNoW2xvY2FsSW5kZXggKyBvZmZzZXRdKTtcXHJcXG5cXHRcXHR9XFxyXFxuXFx0XFx0YmFycmllcihDTEtfTE9DQUxfTUVNX0ZFTkNFKTtcXHJcXG5cXHR9XFxyXFxuXFx0aWYgKGxvY2FsSW5kZXggPT0gMCkge1xcclxcblxcdFxcdG91dFtnZXRfZ3JvdXBfaWQoMCldID0gc2NyYXRjaFswXTtcXHJcXG5cXHR9XFxyXFxufVxcclxcblxcclxcbmtlcm5lbCB2b2lkIG1pbl9mNjRfZ3B1KFxcclxcblxcdHVpbnQgbGVuZ3RoLFxcclxcblxcdGdsb2JhbCBkb3VibGUqIGEsXFxyXFxuXFx0bG9jYWwgZG91YmxlKiBzY3JhdGNoLFxcclxcblxcdGdsb2JhbCBkb3VibGUqIG91dClcXHJcXG57XFxyXFxuXFx0Y29uc3QgdWludCBnbG9iYWxTaXplID0gZ2V0X2dsb2JhbF9zaXplKDApO1xcclxcblxcdHVpbnQgZ2xvYmFsSW5kZXggPSBnZXRfZ2xvYmFsX2lkKDApO1xcclxcblxcdGRvdWJsZSBhY2N1bXVsYXRvciA9IElORklOSVRZO1xcclxcblxcdHdoaWxlIChnbG9iYWxJbmRleCA8IGxlbmd0aCkge1xcclxcblxcdFxcdGFjY3VtdWxhdG9yID0gbWluKGFjY3VtdWxhdG9yLCBhW2dsb2JhbEluZGV4XSk7XFxyXFxuXFx0XFx0Z2xvYmFsSW5kZXggKz0gZ2xvYmFsU2l6ZTtcXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0dWludCBsb2NhbEluZGV4ID0gZ2V0X2xvY2FsX2lkKDApO1xcclxcblxcdHNjcmF0Y2hbbG9jYWxJbmRleF0gPSBhY2N1bXVsYXRvcjtcXHJcXG5cXHRiYXJyaWVyKENMS19MT0NBTF9NRU1fRkVOQ0UpO1xcclxcblxcdGZvciAodWludCBvZmZzZXQgPSBnZXRfbG9jYWxfc2l6ZSgwKSAvIDI7IG9mZnNldCAhPSAwOyBvZmZzZXQgPj49IDEpIHtcXHJcXG5cXHRcXHRpZiAobG9jYWxJbmRleCA8IG9mZnNldCkge1xcclxcblxcdFxcdFxcdHNjcmF0Y2hbbG9jYWxJbmRleF0gPSBtaW4oc2NyYXRjaFtsb2NhbEluZGV4XSwgc2NyYXRjaFtsb2NhbEluZGV4ICsgb2Zmc2V0XSk7XFxyXFxuXFx0XFx0fVxcclxcblxcdFxcdGJhcnJpZXIoQ0xLX0xPQ0FMX01FTV9GRU5DRSk7XFxyXFxuXFx0fVxcclxcblxcdGlmIChsb2NhbEluZGV4ID09IDApIHtcXHJcXG5cXHRcXHRvdXRbZ2V0X2dyb3VwX2lkKDApXSA9IHNjcmF0Y2hbMF07XFxyXFxuXFx0fVxcclxcbn1cXHJcXG5cXHJcXG5rZXJuZWwgdm9pZCBtYXhfZjMyX2dwdShcXHJcXG5cXHR1aW50IGxlbmd0aCxcXHJcXG5cXHRnbG9iYWwgZmxvYXQqIGEsXFxyXFxuXFx0bG9jYWwgZmxvYXQqIHNjcmF0Y2gsXFxyXFxuXFx0Z2xvYmFsIGZsb2F0KiBvdXQpXFxyXFxue1xcclxcblxcdGNvbnN0IHVpbnQgZ2xvYmFsU2l6ZSA9IGdldF9nbG9iYWxfc2l6ZSgwKTtcXHJcXG5cXHR1aW50IGdsb2JhbEluZGV4ID0gZ2V0X2dsb2JhbF9pZCgwKTtcXHJcXG5cXHRmbG9hdCBhY2N1bXVsYXRvciA9IC1JTkZJTklUWTtcXHJcXG5cXHR3aGlsZSAoZ2xvYmFsSW5kZXggPCBsZW5ndGgpIHtcXHJcXG5cXHRcXHRhY2N1bXVsYXRvciA9IG1heChhY2N1bXVsYXRvciwgYVtnbG9iYWxJbmRleF0pO1xcclxcblxcdFxcdGdsb2JhbEluZGV4ICs9IGdsb2JhbFNpemU7XFxyXFxuXFx0fVxcclxcblxcclxcblxcdHVpbnQgbG9jYWxJbmRleCA9IGdldF9sb2NhbF9pZCgwKTtcXHJcXG5cXHRzY3JhdGNoW2xvY2FsSW5kZXhdID0gYWNjdW11bGF0b3I7XFxyXFxuXFx0YmFycmllcihDTEtfTE9DQUxfTUVNX0ZFTkNFKTtcXHJcXG5cXHRmb3IgKHVpbnQgb2Zmc2V0ID0gZ2V0X2xvY2FsX3NpemUoMCkgLyAyOyBvZmZzZXQgIT0gMDsgb2Zmc2V0ID4+PSAxKSB7XFxyXFxuXFx0XFx0aWYgKGxvY2FsSW5kZXggPCBvZmZzZXQpIHtcXHJcXG5cXHRcXHRcXHRzY3JhdGNoW2xvY2FsSW5kZXhdID0gbWF4KHNjcmF0Y2hbbG9jYWxJbmRleF0sIHNjcmF0Y2hbbG9jYWxJbmRleCArIG9mZnNldF0pO1xcclxcblxcdFxcdH1cXHJcXG5cXHRcXHRiYXJyaWVyKENMS19MT0NBTF9NRU1fRkVOQ0UpO1xcclxcblxcdH1cXHJcXG5cXHRpZiAobG9jYWxJbmRleCA9PSAwKSB7XFxyXFxuXFx0XFx0b3V0W2dldF9ncm91cF9pZCgwKV0gPSBzY3JhdGNoWzBdO1xcclxcblxcdH1cXHJcXG59XFxyXFxuXFxyXFxua2VybmVsIHZvaWQgbWF4X2Y2NF9ncHUoXFxyXFxuXFx0dWludCBsZW5ndGgsXFxyXFxuXFx0Z2xvYmFsIGRvdWJsZSogYSxcXHJcXG5cXHRsb2NhbCBkb3VibGUqIHNjcmF0Y2gsXFxyXFxuXFx0Z2xvYmFsIGRvdWJsZSogb3V0KVxcclxcbntcXHJcXG5cXHRjb25zdCB1aW50IGdsb2JhbFNpemUgPSBnZXRfZ2xvYmFsX3NpemUoMCk7XFxyXFxuXFx0dWludCBnbG9iYWxJbmRleCA9IGdldF9nbG9iYWxfaWQoMCk7XFxyXFxuXFx0ZG91YmxlIGFjY3VtdWxhdG9yID0gLUlORklOSVRZO1xcclxcblxcdHdoaWxlIChnbG9iYWxJbmRleCA8IGxlbmd0aCkge1xcclxcblxcdFxcdGFjY3VtdWxhdG9yID0gbWF4KGFjY3VtdWxhdG9yLCBhW2dsb2JhbEluZGV4XSk7XFxyXFxuXFx0XFx0Z2xvYmFsSW5kZXggKz0gZ2xvYmFsU2l6ZTtcXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0dWludCBsb2NhbEluZGV4ID0gZ2V0X2xvY2FsX2lkKDApO1xcclxcblxcdHNjcmF0Y2hbbG9jYWxJbmRleF0gPSBhY2N1bXVsYXRvcjtcXHJcXG5cXHRiYXJyaWVyKENMS19MT0NBTF9NRU1fRkVOQ0UpO1xcclxcblxcdGZvciAodWludCBvZmZzZXQgPSBnZXRfbG9jYWxfc2l6ZSgwKSAvIDI7IG9mZnNldCAhPSAwOyBvZmZzZXQgPj49IDEpIHtcXHJcXG5cXHRcXHRpZiAobG9jYWxJbmRleCA8IG9mZnNldCkge1xcclxcblxcdFxcdFxcdHNjcmF0Y2hbbG9jYWxJbmRleF0gPSBtYXgoc2NyYXRjaFtsb2NhbEluZGV4XSwgc2NyYXRjaFtsb2NhbEluZGV4ICsgb2Zmc2V0XSk7XFxyXFxuXFx0XFx0fVxcclxcblxcdFxcdGJhcnJpZXIoQ0xLX0xPQ0FMX01FTV9GRU5DRSk7XFxyXFxuXFx0fVxcclxcblxcdGlmIChsb2NhbEluZGV4ID09IDApIHtcXHJcXG5cXHRcXHRvdXRbZ2V0X2dyb3VwX2lkKDApXSA9IHNjcmF0Y2hbMF07XFxyXFxuXFx0fVxcclxcbn1cXHJcXG5cIjtcclxuXHR2YXIgYXhpc1JlZHVjdGlvbktlcm5lbHNTb3VyY2UgPSBcImtlcm5lbCB2b2lkIGFzdW1fZjMyKFxcclxcblxcdHVpbnQgcmVkdWN0aW9uRGltLFxcclxcblxcdGdsb2JhbCBmbG9hdCogYSxcXHJcXG5cXHRnbG9iYWwgZmxvYXQqIG91dClcXHJcXG57XFxyXFxuXFx0Y29uc3QgdWludCBpbm5lclN0cmlkZSA9IGdldF9nbG9iYWxfc2l6ZSgxKTtcXHJcXG5cXHRjb25zdCB1aW50IGkgPSBnZXRfZ2xvYmFsX2lkKDApO1xcclxcblxcdGNvbnN0IHVpbnQgayA9IGdldF9nbG9iYWxfaWQoMSk7XFxyXFxuXFx0YSArPSBpICogcmVkdWN0aW9uRGltICogaW5uZXJTdHJpZGUgKyBrO1xcclxcblxcdGZsb2F0IGFjY3VtdWxhdG9yID0gKmE7XFxyXFxuXFx0d2hpbGUgKC0tcmVkdWN0aW9uRGltKSB7XFxyXFxuXFx0XFx0YSArPSBpbm5lclN0cmlkZTtcXHJcXG5cXHRcXHRhY2N1bXVsYXRvciArPSAqYTtcXHJcXG5cXHR9XFxyXFxuXFx0b3V0W2kgKiBpbm5lclN0cmlkZSArIGtdID0gYWNjdW11bGF0b3I7XFxyXFxufVxcclxcblxcclxcbmtlcm5lbCB2b2lkIGFzdW1fZjY0KFxcclxcblxcdHVpbnQgcmVkdWN0aW9uRGltLFxcclxcblxcdGdsb2JhbCBkb3VibGUqIGEsXFxyXFxuXFx0Z2xvYmFsIGRvdWJsZSogb3V0KVxcclxcbntcXHJcXG5cXHRjb25zdCB1aW50IGlubmVyU3RyaWRlID0gZ2V0X2dsb2JhbF9zaXplKDEpO1xcclxcblxcdGNvbnN0IHVpbnQgaSA9IGdldF9nbG9iYWxfaWQoMCk7XFxyXFxuXFx0Y29uc3QgdWludCBrID0gZ2V0X2dsb2JhbF9pZCgxKTtcXHJcXG5cXHRhICs9IGkgKiByZWR1Y3Rpb25EaW0gKiBpbm5lclN0cmlkZSArIGs7XFxyXFxuXFx0ZG91YmxlIGFjY3VtdWxhdG9yID0gKmE7XFxyXFxuXFx0d2hpbGUgKC0tcmVkdWN0aW9uRGltKSB7XFxyXFxuXFx0XFx0YSArPSBpbm5lclN0cmlkZTtcXHJcXG5cXHRcXHRhY2N1bXVsYXRvciArPSAqYTtcXHJcXG5cXHR9XFxyXFxuXFx0b3V0W2kgKiBpbm5lclN0cmlkZSArIGtdID0gYWNjdW11bGF0b3I7XFxyXFxufVxcclxcblxcclxcbmtlcm5lbCB2b2lkIGFtaW5fZjMyKFxcclxcblxcdHVpbnQgcmVkdWN0aW9uRGltLFxcclxcblxcdGdsb2JhbCBmbG9hdCogYSxcXHJcXG5cXHRnbG9iYWwgZmxvYXQqIG91dClcXHJcXG57XFxyXFxuXFx0Y29uc3QgdWludCBpbm5lclN0cmlkZSA9IGdldF9nbG9iYWxfc2l6ZSgxKTtcXHJcXG5cXHRjb25zdCB1aW50IGkgPSBnZXRfZ2xvYmFsX2lkKDApO1xcclxcblxcdGNvbnN0IHVpbnQgayA9IGdldF9nbG9iYWxfaWQoMSk7XFxyXFxuXFx0YSArPSBpICogcmVkdWN0aW9uRGltICogaW5uZXJTdHJpZGUgKyBrO1xcclxcblxcdGZsb2F0IGFjY3VtdWxhdG9yID0gKmE7XFxyXFxuXFx0d2hpbGUgKC0tcmVkdWN0aW9uRGltKSB7XFxyXFxuXFx0XFx0YSArPSBpbm5lclN0cmlkZTtcXHJcXG5cXHRcXHRhY2N1bXVsYXRvciA9IG1pbihhY2N1bXVsYXRvciwgKmEpO1xcclxcblxcdH1cXHJcXG5cXHRvdXRbaSAqIGlubmVyU3RyaWRlICsga10gPSBhY2N1bXVsYXRvcjtcXHJcXG59XFxyXFxuXFxyXFxua2VybmVsIHZvaWQgYW1pbl9mNjQoXFxyXFxuXFx0dWludCByZWR1Y3Rpb25EaW0sXFxyXFxuXFx0Z2xvYmFsIGRvdWJsZSogYSxcXHJcXG5cXHRnbG9iYWwgZG91YmxlKiBvdXQpXFxyXFxue1xcclxcblxcdGNvbnN0IHVpbnQgaW5uZXJTdHJpZGUgPSBnZXRfZ2xvYmFsX3NpemUoMSk7XFxyXFxuXFx0Y29uc3QgdWludCBpID0gZ2V0X2dsb2JhbF9pZCgwKTtcXHJcXG5cXHRjb25zdCB1aW50IGsgPSBnZXRfZ2xvYmFsX2lkKDEpO1xcclxcblxcdGEgKz0gaSAqIHJlZHVjdGlvbkRpbSAqIGlubmVyU3RyaWRlICsgaztcXHJcXG5cXHRkb3VibGUgYWNjdW11bGF0b3IgPSAqYTtcXHJcXG5cXHR3aGlsZSAoLS1yZWR1Y3Rpb25EaW0pIHtcXHJcXG5cXHRcXHRhICs9IGlubmVyU3RyaWRlO1xcclxcblxcdFxcdGFjY3VtdWxhdG9yID0gbWluKGFjY3VtdWxhdG9yLCAqYSk7XFxyXFxuXFx0fVxcclxcblxcdG91dFtpICogaW5uZXJTdHJpZGUgKyBrXSA9IGFjY3VtdWxhdG9yO1xcclxcbn1cXHJcXG5cXHJcXG5rZXJuZWwgdm9pZCBhbWF4X2YzMihcXHJcXG5cXHR1aW50IHJlZHVjdGlvbkRpbSxcXHJcXG5cXHRnbG9iYWwgZmxvYXQqIGEsXFxyXFxuXFx0Z2xvYmFsIGZsb2F0KiBvdXQpXFxyXFxue1xcclxcblxcdGNvbnN0IHVpbnQgaW5uZXJTdHJpZGUgPSBnZXRfZ2xvYmFsX3NpemUoMSk7XFxyXFxuXFx0Y29uc3QgdWludCBpID0gZ2V0X2dsb2JhbF9pZCgwKTtcXHJcXG5cXHRjb25zdCB1aW50IGsgPSBnZXRfZ2xvYmFsX2lkKDEpO1xcclxcblxcdGEgKz0gaSAqIHJlZHVjdGlvbkRpbSAqIGlubmVyU3RyaWRlICsgaztcXHJcXG5cXHRmbG9hdCBhY2N1bXVsYXRvciA9ICphO1xcclxcblxcdHdoaWxlICgtLXJlZHVjdGlvbkRpbSkge1xcclxcblxcdFxcdGEgKz0gaW5uZXJTdHJpZGU7XFxyXFxuXFx0XFx0YWNjdW11bGF0b3IgPSBtYXgoYWNjdW11bGF0b3IsICphKTtcXHJcXG5cXHR9XFxyXFxuXFx0b3V0W2kgKiBpbm5lclN0cmlkZSArIGtdID0gYWNjdW11bGF0b3I7XFxyXFxufVxcclxcblxcclxcbmtlcm5lbCB2b2lkIGFtYXhfZjY0KFxcclxcblxcdHVpbnQgcmVkdWN0aW9uRGltLFxcclxcblxcdGdsb2JhbCBkb3VibGUqIGEsXFxyXFxuXFx0Z2xvYmFsIGRvdWJsZSogb3V0KVxcclxcbntcXHJcXG5cXHRjb25zdCB1aW50IGlubmVyU3RyaWRlID0gZ2V0X2dsb2JhbF9zaXplKDEpO1xcclxcblxcdGNvbnN0IHVpbnQgaSA9IGdldF9nbG9iYWxfaWQoMCk7XFxyXFxuXFx0Y29uc3QgdWludCBrID0gZ2V0X2dsb2JhbF9pZCgxKTtcXHJcXG5cXHRhICs9IGkgKiByZWR1Y3Rpb25EaW0gKiBpbm5lclN0cmlkZSArIGs7XFxyXFxuXFx0ZG91YmxlIGFjY3VtdWxhdG9yID0gKmE7XFxyXFxuXFx0d2hpbGUgKC0tcmVkdWN0aW9uRGltKSB7XFxyXFxuXFx0XFx0YSArPSBpbm5lclN0cmlkZTtcXHJcXG5cXHRcXHRhY2N1bXVsYXRvciA9IG1heChhY2N1bXVsYXRvciwgKmEpO1xcclxcblxcdH1cXHJcXG5cXHRvdXRbaSAqIGlubmVyU3RyaWRlICsga10gPSBhY2N1bXVsYXRvcjtcXHJcXG59XFxyXFxuXCI7XHJcblx0dmFyIHByb2R1Y3RLZXJuZWxzU291cmNlID0gXCJrZXJuZWwgdm9pZCBkb3RfZjMyKFxcclxcblxcdHVpbnQgcmVkdWN0aW9uRGltLFxcclxcblxcdGdsb2JhbCBmbG9hdCogYSxcXHJcXG5cXHRnbG9iYWwgZmxvYXQqIGIsXFxyXFxuXFx0Z2xvYmFsIGZsb2F0KiBvdXQpXFxyXFxue1xcclxcblxcdGNvbnN0IHVpbnQgaSA9IGdldF9nbG9iYWxfaWQoMCk7XFxyXFxuXFx0Y29uc3QgdWludCBrID0gZ2V0X2dsb2JhbF9pZCgxKTtcXHJcXG5cXHRjb25zdCB1aW50IGwgPSBnZXRfZ2xvYmFsX2lkKDIpO1xcclxcblxcdGNvbnN0IHVpbnQgb3V0ZXJTdHJpZGVCID0gZ2V0X2dsb2JhbF9zaXplKDEpO1xcclxcblxcdGNvbnN0IHVpbnQgaW5uZXJTdHJpZGVCID0gZ2V0X2dsb2JhbF9zaXplKDIpO1xcclxcblxcclxcblxcdGZsb2F0IGFjY3VtdWxhdG9yID0gMC4wZjtcXHJcXG5cXHRmb3IgKHVpbnQgaiA9IDA7IGogPCByZWR1Y3Rpb25EaW07ICsraikge1xcclxcblxcdFxcdGFjY3VtdWxhdG9yICs9IGFbaSpyZWR1Y3Rpb25EaW0ral0gKiBiWyhrKnJlZHVjdGlvbkRpbStqKSppbm5lclN0cmlkZUIrbF07XFxyXFxuXFx0fVxcclxcblxcdG91dFsoaSpvdXRlclN0cmlkZUIgKyBrKSAqIGlubmVyU3RyaWRlQiArIGxdID0gYWNjdW11bGF0b3I7XFxyXFxufVxcclxcblxcclxcbmtlcm5lbCB2b2lkIGRvdF9mNjQoXFxyXFxuXFx0dWludCByZWR1Y3Rpb25EaW0sXFxyXFxuXFx0Z2xvYmFsIGRvdWJsZSogYSxcXHJcXG5cXHRnbG9iYWwgZG91YmxlKiBiLFxcclxcblxcdGdsb2JhbCBkb3VibGUqIG91dClcXHJcXG57XFxyXFxuXFx0Y29uc3QgdWludCBpID0gZ2V0X2dsb2JhbF9pZCgwKTtcXHJcXG5cXHRjb25zdCB1aW50IGsgPSBnZXRfZ2xvYmFsX2lkKDEpO1xcclxcblxcdGNvbnN0IHVpbnQgbCA9IGdldF9nbG9iYWxfaWQoMik7XFxyXFxuXFx0Y29uc3QgdWludCBvdXRlclN0cmlkZUIgPSBnZXRfZ2xvYmFsX3NpemUoMSk7XFxyXFxuXFx0Y29uc3QgdWludCBpbm5lclN0cmlkZUIgPSBnZXRfZ2xvYmFsX3NpemUoMik7XFxyXFxuXFxyXFxuXFx0ZG91YmxlIGFjY3VtdWxhdG9yID0gMC4wO1xcclxcblxcdGZvciAodWludCBqID0gMDsgaiA8IHJlZHVjdGlvbkRpbTsgKytqKSB7XFxyXFxuXFx0XFx0YWNjdW11bGF0b3IgKz0gYVtpKnJlZHVjdGlvbkRpbStqXSAqIGJbKGsqcmVkdWN0aW9uRGltK2opKmlubmVyU3RyaWRlQitsXTtcXHJcXG5cXHR9XFxyXFxuXFx0b3V0WyhpKm91dGVyU3RyaWRlQiArIGspICogaW5uZXJTdHJpZGVCICsgbF0gPSBhY2N1bXVsYXRvcjtcXHJcXG59XFxyXFxuXCI7XHJcblx0dmFyIHV0aWxLZXJuZWxzU291cmNlID0gXCJrZXJuZWwgdm9pZCBzZXRfZjMyKFxcclxcblxcdHVpbnQgbGVuZ3RoLFxcclxcblxcdGdsb2JhbCBmbG9hdCogb3V0LFxcclxcblxcdGZsb2F0IHZhbHVlKVxcclxcbntcXHJcXG5cXHRjb25zdCB1aW50IGlkID0gZ2V0X2dsb2JhbF9pZCgwKTtcXHJcXG5cXHRpZiAoaWQgPCBsZW5ndGgpIHtcXHJcXG5cXHRcXHRvdXRbaWRdID0gdmFsdWU7XFxyXFxuXFx0fVxcclxcbn1cXHJcXG5rZXJuZWwgdm9pZCBzZXRfZjY0KFxcclxcblxcdHVpbnQgbGVuZ3RoLFxcclxcblxcdGdsb2JhbCBkb3VibGUqIG91dCxcXHJcXG5cXHRkb3VibGUgdmFsdWUpXFxyXFxue1xcclxcblxcdGNvbnN0IHVpbnQgaWQgPSBnZXRfZ2xvYmFsX2lkKDApO1xcclxcblxcdGlmIChpZCA8IGxlbmd0aCkge1xcclxcblxcdFxcdG91dFtpZF0gPSB2YWx1ZTtcXHJcXG5cXHR9XFxyXFxufVxcclxcblxcclxcbmtlcm5lbCB2b2lkIGxpbnNwYWNlX2YzMihcXHJcXG5cXHR1aW50IGxlbmd0aCxcXHJcXG5cXHRnbG9iYWwgZmxvYXQqIG91dCxcXHJcXG5cXHRmbG9hdCBzdGFydCxcXHJcXG5cXHRmbG9hdCBzdGVwKVxcclxcbntcXHJcXG5cXHRjb25zdCB1aW50IGlkID0gZ2V0X2dsb2JhbF9pZCgwKTtcXHJcXG5cXHRpZiAoaWQgPCBsZW5ndGgpIHtcXHJcXG5cXHRcXHRvdXRbaWRdID0gc3RhcnQgKyBzdGVwICogKChmbG9hdCkgaWQpO1xcclxcblxcdH1cXHJcXG59XFxyXFxua2VybmVsIHZvaWQgbGluc3BhY2VfZjY0KFxcclxcblxcdHVpbnQgbGVuZ3RoLFxcclxcblxcdGdsb2JhbCBkb3VibGUqIG91dCxcXHJcXG5cXHRkb3VibGUgc3RhcnQsXFxyXFxuXFx0ZG91YmxlIHN0ZXApXFxyXFxue1xcclxcblxcdGNvbnN0IHVpbnQgaWQgPSBnZXRfZ2xvYmFsX2lkKDApO1xcclxcblxcdGlmIChpZCA8IGxlbmd0aCkge1xcclxcblxcdFxcdG91dFtpZF0gPSBzdGFydCArIHN0ZXAgKiAoKGRvdWJsZSkgaWQpO1xcclxcblxcdH1cXHJcXG59XFxyXFxuXFxyXFxua2VybmVsIHZvaWQgcmVwZWF0X2YzMihcXHJcXG5cXHR1aW50IGV4cGFuc2lvbkRpbSxcXHJcXG5cXHR1aW50IGlubmVyU3RyaWRlLFxcclxcblxcdHVpbnQgcmVwZWF0cyxcXHJcXG5cXHRnbG9iYWwgZmxvYXQgKnJlc3RyaWN0IGEsXFxyXFxuXFx0Z2xvYmFsIGZsb2F0ICpyZXN0cmljdCBvdXQpXFxyXFxue1xcclxcblxcdGNvbnN0IHVpbnQgaSA9IGdldF9nbG9iYWxfaWQoMCk7XFxyXFxuXFx0Y29uc3QgdWludCBqID0gZ2V0X2dsb2JhbF9pZCgxKTtcXHJcXG5cXHRjb25zdCB1aW50IGsgPSBnZXRfZ2xvYmFsX2lkKDIpO1xcclxcblxcdGNvbnN0IGZsb2F0IHZhbHVlID0gYVsoaSAqIGV4cGFuc2lvbkRpbSArIGopICogaW5uZXJTdHJpZGUgKyBrXTtcXHJcXG5cXHR1aW50IG9mZnNldE91dCA9IChpICogZXhwYW5zaW9uRGltICsgaikgKiByZXBlYXRzICogaW5uZXJTdHJpZGUgKyBrO1xcclxcblxcdGZvciAodWludCBjID0gMDsgYyA8IHJlcGVhdHM7ICsrYykge1xcclxcblxcdFxcdG91dFtvZmZzZXRPdXRdID0gdmFsdWU7XFxyXFxuXFx0XFx0b2Zmc2V0T3V0ICs9IGlubmVyU3RyaWRlO1xcclxcblxcdH1cXHJcXG59XFxyXFxua2VybmVsIHZvaWQgcmVwZWF0X2Y2NChcXHJcXG5cXHR1aW50IGV4cGFuc2lvbkRpbSxcXHJcXG5cXHR1aW50IGlubmVyU3RyaWRlLFxcclxcblxcdHVpbnQgcmVwZWF0cyxcXHJcXG5cXHRnbG9iYWwgZG91YmxlICpyZXN0cmljdCBhLFxcclxcblxcdGdsb2JhbCBkb3VibGUgKnJlc3RyaWN0IG91dClcXHJcXG57XFxyXFxuXFx0Y29uc3QgdWludCBpID0gZ2V0X2dsb2JhbF9pZCgwKTtcXHJcXG5cXHRjb25zdCB1aW50IGogPSBnZXRfZ2xvYmFsX2lkKDEpO1xcclxcblxcdGNvbnN0IHVpbnQgayA9IGdldF9nbG9iYWxfaWQoMik7XFxyXFxuXFx0Y29uc3QgZG91YmxlIHZhbHVlID0gYVsoaSAqIGV4cGFuc2lvbkRpbSArIGopICogaW5uZXJTdHJpZGUgKyBrXTtcXHJcXG5cXHR1aW50IG9mZnNldE91dCA9IChpICogZXhwYW5zaW9uRGltICsgaikgKiByZXBlYXRzICogaW5uZXJTdHJpZGUgKyBrO1xcclxcblxcdGZvciAodWludCBjID0gMDsgYyA8IHJlcGVhdHM7ICsrYykge1xcclxcblxcdFxcdG91dFtvZmZzZXRPdXRdID0gdmFsdWU7XFxyXFxuXFx0XFx0b2Zmc2V0T3V0ICs9IGlubmVyU3RyaWRlO1xcclxcblxcdH1cXHJcXG59XFxyXFxuXCI7XHJcblx0dmFyIHNvdXJjZSA9IGJpbmFyeUtlcm5lbHNTb3VyY2UgKyB1bmFyeUtlcm5lbHNTb3VyY2UgKyBcclxuXHRcdHJlZHVjdGlvbktlcm5lbHNTb3VyY2UgKyBheGlzUmVkdWN0aW9uS2VybmVsc1NvdXJjZSArIFxyXG5cdFx0cHJvZHVjdEtlcm5lbHNTb3VyY2UgKyB1dGlsS2VybmVsc1NvdXJjZTtcclxuXHJcblx0dmFyIGFzeW5jQ2FsbGJhY2tzID0gb3B0aW9ucy5hc3luY0NhbGxiYWNrcztcclxuXHRpZiAodHlwZW9mIGFzeW5jQ2FsbGJhY2tzID09PSBcInVuZGVmaW5lZFwiKSB7XHJcblx0XHQvKiBDdXJyZW50bHkgb25seSBOb2RlLVdlYkNMIHN1cHBvcnRzIGFzeW5jaHJvbm91cyBjYWxsYmFja3MgKi9cclxuXHRcdHRoaXMuYXN5bmNDYWxsYmFja3MgPSBpc05vZGVXZWJDTDtcclxuXHR9IGVsc2Uge1xyXG5cdFx0dGhpcy5hc3luY0NhbGxiYWNrcyA9ICEhYXN5bmNDYWxsYmFja3M7XHJcblx0fVxyXG5cdHZhciBkZXZpY2VOYW1lID0gb3B0aW9ucy5kZXZpY2U7XHJcblx0aWYgKGRldmljZU5hbWUpIHtcclxuXHRcdHZhciBkZXZpY2VJbmRleCA9IGF2YWlsYWJsZURldmljZXNEZXNjcmlwdGlvbnMuaW5kZXhPZihkZXZpY2VOYW1lKTtcclxuXHRcdGlmIChkZXZpY2VJbmRleCA9PT0gLTEpIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBXZWJDTCBkZXZpY2UgbmFtZTogXCIgKyBkZXZpY2VOYW1lKTtcclxuXHRcdH1cclxuXHRcdHRoaXMuZGV2aWNlID0gYXZhaWxhYmxlRGV2aWNlc1tkZXZpY2VJbmRleF07XHJcblx0fSBlbHNlIHtcclxuXHRcdHZhciBkZXZpY2VJbmRleCA9IGdldERlZmF1bHREZXZpY2VJbmRleCgpO1xyXG5cdFx0aWYgKGRldmljZUluZGV4IDwgMCkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJObyBzdWl0YWJsZSBXZWJDTCBkZXZpY2UgZm91bmRcIik7XHJcblx0XHR9XHJcblx0XHR0aGlzLmRldmljZSA9IGF2YWlsYWJsZURldmljZXNbZGV2aWNlSW5kZXhdO1xyXG5cdH1cclxuXHR0aGlzLmRldmljZS5lbmFibGVFeHRlbnNpb24oXCJLSFJfZnA2NFwiKTtcclxuXHR0aGlzLmRldmljZUluZm8gPSB7XHJcblx0XHRkZXZpY2VDbGFzczogY2xhc3NpZnlEZXZpY2UodGhpcy5kZXZpY2UpLFxyXG5cdFx0bG9jYWxNZW1vcnlTaXplOiB0aGlzLmRldmljZS5nZXRJbmZvKGNsLkRFVklDRV9MT0NBTF9NRU1fU0laRSksXHJcblx0XHRtYXhDb21wdXRlVW5pdHM6IHRoaXMuZGV2aWNlLmdldEluZm8oY2wuREVWSUNFX01BWF9DT01QVVRFX1VOSVRTKSxcclxuXHRcdG1heFdvcmtHcm91cFNpemU6IHRoaXMuZGV2aWNlLmdldEluZm8oY2wuREVWSUNFX01BWF9XT1JLX0dST1VQX1NJWkUpLFxyXG5cdFx0bWF4V29ya0l0ZW1TaXplczogdGhpcy5kZXZpY2UuZ2V0SW5mbyhjbC5ERVZJQ0VfTUFYX1dPUktfSVRFTV9TSVpFUylcclxuXHR9O1xyXG5cdHRoaXMuY29udGV4dCA9IGNsLmNyZWF0ZUNvbnRleHQodGhpcy5kZXZpY2UpO1xyXG5cdHRoaXMucXVldWUgPSB0aGlzLmNvbnRleHQuY3JlYXRlQ29tbWFuZFF1ZXVlKHRoaXMuZGV2aWNlKTtcclxuXHR0aGlzLnByb2dyYW0gPSB0aGlzLmNvbnRleHQuY3JlYXRlUHJvZ3JhbShzb3VyY2UpO1xyXG5cdHRyeSB7XHJcblx0XHQvKiBDaHJvbWl1bS1XZWJDTCByZXF1aXJlcyBhIGxpc3Qgb2YgZGV2aWNlcyAqL1xyXG5cdFx0dGhpcy5wcm9ncmFtLmJ1aWxkKFt0aGlzLmRldmljZV0pO1xyXG5cdH0gY2F0Y2ggKGUpIHtcclxuXHRcdGlmIChlLm5hbWUgPT09IFwiSU5WQUxJRF9ERVZJQ0VcIikge1xyXG5cdFx0XHQvKiBOb2tpYS1XZWJDTCBvbmx5IHdvcmtzIHdpdGggbm8gYXJndW1lbnRzIHRvIFdlYkNMUHJvZ3JhbS5idWlsZCAqL1xyXG5cdFx0XHR0aGlzLnByb2dyYW0uYnVpbGQoKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRocm93IGU7XHJcblx0XHR9XHJcblx0fVxyXG5cdHRoaXMua2VybmVscyA9IGNyZWF0ZUtlcm5lbHModGhpcy5wcm9ncmFtKTtcclxuXHQvKiBDb250ZXh0IGlzIHJlYWR5IGZvciBjb21wdXRhdGlvbnMgKi9cclxuXHRjYWxsYmFjayh0aGlzKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIG5hbWVzIG9mIGRldmljZXMgdGhhdCBjYW4gYmUgdXNlZCBmb3IgY29tcHV0YXRpb24uXHJcbiAqIEFueSBvZiB0aGVzZSBuYW1lcyBjYW4gYmUgcGFzc2VkIGFzIGEgXCJkZXZpY2VcIiBvcHRpb24gd2hlbiBjcmVhdGluZyBhIFdlYkNMIGNvbnRleHQuXHJcbiAqXHJcbiAqIEBzdGF0aWNcclxuICogQG1ldGhvZCBnZXRBdmFpbGFibGVEZXZpY2VzXHJcbiAqIEByZXR1cm4ge1N0cmluZ1tdfSAtIGEgcG9zc2libHkgZW1wdHkgbGlzdCBvZiBhdmFpbGFibGUgZGV2aWNlIG5hbWVzLlxyXG4gKi9cclxuV2ViQ0xDb250ZXh0LmdldEF2YWlsYWJsZURldmljZXMgPSBmdW5jdGlvbigpIHtcclxuXHRpZiAoV2ViQ0xDb250ZXh0LmlzVXNhYmxlKCkpIHtcclxuXHRcdHJldHVybiBhdmFpbGFibGVEZXZpY2VzRGVzY3JpcHRpb25zO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRyZXR1cm4gW107XHJcblx0fVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIG5hbWUgb2YgdGhlIGRlZmF1bHQgZGV2aWNlIHVzZWQgZm9yIGNvbXB1dGF0aW9uLlxyXG4gKlxyXG4gKiBAc3RhdGljXHJcbiAqIEBtZXRob2QgZ2V0RGVmYXVsdERldmljZVxyXG4gKiBAcmV0dXJuIHtTdHJpbmd9IC0gdGhlIG5hbWUgb2YgdGhlIGRlZmF1bHQgV2ViQ0wgZGV2aWNlIG9yIG51bGwgaWYgbm8gc3VpdGFibGUgZGV2aWNlIGF2YWlsYWJsZS5cclxuICovXHJcbldlYkNMQ29udGV4dC5nZXREZWZhdWx0RGV2aWNlID0gZnVuY3Rpb24oKSB7XHJcblx0dmFyIGRldmljZUluZGV4ID0gZ2V0RGVmYXVsdERldmljZUluZGV4KCk7XHJcblx0aWYgKGRldmljZUluZGV4IDwgMCkge1xyXG5cdFx0cmV0dXJuIG51bGw7XHJcblx0fSBlbHNlIHtcclxuXHRcdHJldHVybiBhdmFpbGFibGVEZXZpY2VzRGVzY3JpcHRpb25zW2RldmljZUluZGV4XTtcclxuXHR9XHJcbn07XHJcblxyXG4vKipcclxuICogQ2hlY2tzIGlmIFdlYkNMIGlzIHN1cHBvcnRlZCBieSB0aGUgZW52aXJvbm1lbnQuXHJcbiAqXHJcbiAqIEBzdGF0aWNcclxuICogQG1ldGhvZCBpc1N1cHBvcnRlZFxyXG4gKiBAcmV0dXJuIHtCb29sZWFufSAtIHRydWUgaWYgV2ViQ0wgaXMgc3VwcG9ydGVkIG9uIHRoaXMgc3lzdGVtIGFuZCBmYWxzZSBvdGhlcndpc2UuXHJcbiAqL1xyXG5XZWJDTENvbnRleHQuaXNTdXBwb3J0ZWQgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gaW5pdFdlYkNMKCkgIT09IG51bGw7XHJcbn07XHJcblxyXG4vKipcclxuICogQ2hlY2tzIGlmIFdlYkNMIGNhbiBiZSB1c2VkIGZvciBjb21wdXRhdGlvbi5cclxuICogV2ViQ0wgaXMgdXNhYmxlIGZvciBjb21wdXRhdGlvbnMgaWYgaXQgaXMgc3VwcG9ydGVkIGJ5IEpTIGVuZ2luZSAob3IgTm9kZS5qcykgYW5kIHRoZXJlIGlzIGF0IGxlYXN0IG9uZSBDUFUgb3IgR1BVIGRldmljZSB3aXRoIEtIUl9mcDY0IGV4dGVuc2lvbi5cclxuICpcclxuICogQHN0YXRpY1xyXG4gKiBAbWV0aG9kIGlzVXNhYmxlXHJcbiAqIEByZXR1cm4ge0Jvb2xlYW59IC0gdHJ1ZSBpZiBXZWJDTCBpcyB1c2FibGUgb24gdGhpcyBzeXN0ZW0gYW5kIGZhbHNlIG90aGVyd2lzZS5cclxuICovXHJcbldlYkNMQ29udGV4dC5pc1VzYWJsZSA9IGZ1bmN0aW9uKCkge1xyXG5cdHZhciB3ZWJjbCA9IGluaXRXZWJDTCgpO1xyXG5cdGlmICh3ZWJjbCA9PT0gbnVsbCkge1xyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH1cclxuXHR2YXIgYXZhaWxhYmxlRGV2aWNlcyA9IGdldEF2YWlsYWJsZURldmljZXMoKTtcclxuXHRyZXR1cm4gYXZhaWxhYmxlRGV2aWNlcy5sZW5ndGggIT09IDA7XHJcbn07XHJcblxyXG5XZWJDTENvbnRleHQucHJvdG90eXBlLmVtcHR5ID0gZnVuY3Rpb24oc2hhcGUsIGRhdGFUeXBlKSB7XHJcblx0c2hhcGUgPSB1dGlsLmNoZWNrU2hhcGUoc2hhcGUpO1xyXG5cdGlmICh0eXBlb2YgZGF0YVR5cGUgPT09IFwidW5kZWZpbmVkXCIpIHtcclxuXHRcdGRhdGFUeXBlID0gbmV3IERhdGFUeXBlKFwiZjY0XCIpO1xyXG5cdH0gZWxzZSBpZiAoIShkYXRhVHlwZSBpbnN0YW5jZW9mIERhdGFUeXBlKSkge1xyXG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihkYXRhVHlwZSArIFwiIGlzIG5vdCBhbiBpbnN0YW5jZSBvZiBEYXRhVHlwZVwiKTtcclxuXHR9XHJcblx0dmFyIGFycmF5ID0gbmV3IE5EQXJyYXkoc2hhcGUsIGRhdGFUeXBlLCB0aGlzKTtcclxuXHRhcnJheS5fYnVmZmVyID0gdGhpcy5jb250ZXh0LmNyZWF0ZUJ1ZmZlcihjbC5NRU1fUkVBRF9XUklURSwgYXJyYXkubGVuZ3RoICogZGF0YVR5cGUuc2l6ZSk7XHJcblx0cmV0dXJuIGFycmF5O1xyXG59O1xyXG5cclxuV2ViQ0xDb250ZXh0LnByb3RvdHlwZS56ZXJvcyA9IGZ1bmN0aW9uKHNoYXBlLCBkYXRhVHlwZSkge1xyXG5cdHNoYXBlID0gdXRpbC5jaGVja1NoYXBlKHNoYXBlKTtcclxuXHRpZiAodHlwZW9mIGRhdGFUeXBlID09PSBcInVuZGVmaW5lZFwiKSB7XHJcblx0XHRkYXRhVHlwZSA9IG5ldyBEYXRhVHlwZShcImY2NFwiKTtcclxuXHR9IGVsc2UgaWYgKCEoZGF0YVR5cGUgaW5zdGFuY2VvZiBEYXRhVHlwZSkpIHtcclxuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoZGF0YVR5cGUgKyBcIiBpcyBub3QgYW4gaW5zdGFuY2Ugb2YgRGF0YVR5cGVcIik7XHJcblx0fVxyXG5cdHZhciBhcnJheSA9IG5ldyBOREFycmF5KHNoYXBlLCBkYXRhVHlwZSwgdGhpcyk7XHJcblx0YXJyYXkuX2J1ZmZlciA9IHRoaXMuY29udGV4dC5jcmVhdGVCdWZmZXIoY2wuTUVNX1JFQURfV1JJVEUsIGFycmF5Lmxlbmd0aCAqIGRhdGFUeXBlLnNpemUpO1xyXG5cdHZhciBrZXJuZWwgPSB0aGlzLmtlcm5lbHMuc2V0W2RhdGFUeXBlLnR5cGVdO1xyXG5cdGtlcm5lbC5zZXRBcmcoMCwgbmV3IFVpbnQzMkFycmF5KFthcnJheS5sZW5ndGhdKSk7XHJcblx0a2VybmVsLnNldEFyZygxLCBhcnJheS5fYnVmZmVyKTtcclxuXHRrZXJuZWwuc2V0QXJnKDIsIG5ldyBkYXRhVHlwZS5hcnJheVR5cGUoWzAuMF0pKTtcclxuXHR0aGlzLnF1ZXVlLmVucXVldWVORFJhbmdlS2VybmVsKGtlcm5lbCwgMSwgbnVsbCwgW2FycmF5Lmxlbmd0aF0pO1xyXG5cdHJldHVybiBhcnJheTtcclxufTtcclxuXHJcbldlYkNMQ29udGV4dC5wcm90b3R5cGUub25lcyA9IGZ1bmN0aW9uKHNoYXBlLCBkYXRhVHlwZSkge1xyXG5cdHNoYXBlID0gdXRpbC5jaGVja1NoYXBlKHNoYXBlKTtcclxuXHRpZiAodHlwZW9mIGRhdGFUeXBlID09PSBcInVuZGVmaW5lZFwiKSB7XHJcblx0XHRkYXRhVHlwZSA9IG5ldyBEYXRhVHlwZShcImY2NFwiKTtcclxuXHR9IGVsc2UgaWYgKCEoZGF0YVR5cGUgaW5zdGFuY2VvZiBEYXRhVHlwZSkpIHtcclxuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoZGF0YVR5cGUgKyBcIiBpcyBub3QgYW4gaW5zdGFuY2Ugb2YgRGF0YVR5cGVcIik7XHJcblx0fVxyXG5cdHZhciBhcnJheSA9IG5ldyBOREFycmF5KHNoYXBlLCBkYXRhVHlwZSwgdGhpcyk7XHJcblx0YXJyYXkuX2J1ZmZlciA9IHRoaXMuY29udGV4dC5jcmVhdGVCdWZmZXIoY2wuTUVNX1JFQURfV1JJVEUsIGFycmF5Lmxlbmd0aCAqIGRhdGFUeXBlLnNpemUpO1xyXG5cdHZhciBrZXJuZWwgPSB0aGlzLmtlcm5lbHMuc2V0W2RhdGFUeXBlLnR5cGVdO1xyXG5cdGtlcm5lbC5zZXRBcmcoMCwgbmV3IFVpbnQzMkFycmF5KFthcnJheS5sZW5ndGhdKSk7XHJcblx0a2VybmVsLnNldEFyZygxLCBhcnJheS5fYnVmZmVyKTtcclxuXHRrZXJuZWwuc2V0QXJnKDIsIG5ldyBkYXRhVHlwZS5hcnJheVR5cGUoWzEuMF0pKTtcclxuXHR0aGlzLnF1ZXVlLmVucXVldWVORFJhbmdlS2VybmVsKGtlcm5lbCwgMSwgbnVsbCwgW2FycmF5Lmxlbmd0aF0pO1xyXG5cdHJldHVybiBhcnJheTtcclxufTtcclxuXHJcbldlYkNMQ29udGV4dC5wcm90b3R5cGUuYXJyYXkgPSBmdW5jdGlvbihkYXRhLCBkYXRhVHlwZSkge1xyXG5cdGlmICh0eXBlb2YgZGF0YVR5cGUgPT09IFwidW5kZWZpbmVkXCIpIHtcclxuXHRcdGRhdGFUeXBlID0gbmV3IERhdGFUeXBlKFwiZjY0XCIpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRkYXRhVHlwZSA9IHV0aWwuY2hlY2tEYXRhVHlwZShkYXRhVHlwZSk7XHJcblx0fVxyXG5cdHZhciBzaGFwZSA9IFtdO1xyXG5cdHV0aWwuZGlzY292ZXJBcnJheVNoYXBlUmVjdXJzaXZlKGRhdGEsIHNoYXBlLCAwKTtcclxuXHR2YXIgYXJyYXkgPSBuZXcgTkRBcnJheShzaGFwZSwgZGF0YVR5cGUsIHRoaXMpO1xyXG5cdHZhciBidWZmZXIgPSBuZXcgZGF0YVR5cGUuYXJyYXlUeXBlKGFycmF5Lmxlbmd0aCk7XHJcblx0dXRpbC5jb3B5QXJyYXlEYXRhUmVjdXJzaXZlKGJ1ZmZlciwgZGF0YSwgc2hhcGUsIDAsIDApO1xyXG5cdGlmICh1c2VCdWZmZXJDcmVhdGlvbldpdGhJbml0KSB7XHJcblx0XHRhcnJheS5fYnVmZmVyID0gdGhpcy5jb250ZXh0LmNyZWF0ZUJ1ZmZlcihjbC5NRU1fUkVBRF9XUklURSwgYnVmZmVyLmJ5dGVMZW5ndGgsIGJ1ZmZlcik7XHJcblx0fSBlbHNlIHtcclxuXHRcdGFycmF5Ll9idWZmZXIgPSB0aGlzLmNvbnRleHQuY3JlYXRlQnVmZmVyKGNsLk1FTV9SRUFEX1dSSVRFLCBidWZmZXIuYnl0ZUxlbmd0aCk7XHJcblx0XHR0aGlzLnF1ZXVlLmVucXVldWVXcml0ZUJ1ZmZlcihhcnJheS5fYnVmZmVyLCBmYWxzZSwgMCwgYnVmZmVyLmJ5dGVMZW5ndGgsIGJ1ZmZlcik7XHJcblx0fVxyXG5cdHJldHVybiBhcnJheTtcclxufTtcclxuXHJcbldlYkNMQ29udGV4dC5wcm90b3R5cGUubGluc3BhY2UgPSBmdW5jdGlvbihzdGFydCwgc3RvcCwgc2FtcGxlcywgY2xvc2VkKSB7XHJcblx0aWYgKCF1dGlsLmlzUmVhbChzdGFydCkpIHtcclxuXHRcdHRocm93IG5ldyBUeXBlRXJyb3Ioc3RhcnQgKyBcIiBpcyBub3QgYSByZWFsIG51bWJlclwiKTtcclxuXHR9XHJcblx0aWYgKCF1dGlsLmlzUmVhbChzdG9wKSkge1xyXG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihzdG9wICsgXCIgaXMgbm90IGEgcmVhbCBudW1iZXJcIik7XHJcblx0fVxyXG5cdGlmICh0eXBlb2Ygc2FtcGxlcyA9PT0gXCJ1bmRlZmluZWRcIikge1xyXG5cdFx0LyogRGVmYXVsdCB2YWx1ZSBpbiBOdW1QeSAqL1xyXG5cdFx0c2FtcGxlcyA9IDUwO1xyXG5cdH0gZWxzZSBpZiAoIXV0aWwuaXNJbnQoc2FtcGxlcykpIHtcclxuXHRcdHRocm93IG5ldyBUeXBlRXJyb3Ioc2FtcGxlcyArIFwiIGlzIG5vdCBhbiBpbnRlZ2VyXCIpO1xyXG5cdH0gZWxzZSBpZiAoc2FtcGxlcyA8PSAwKSB7XHJcblx0XHR0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlRoZSBudW1iZXIgb2Ygc2FtcGxlcyBtdXN0IGJlIHBvc2l0aXZlXCIpO1xyXG5cdH1cclxuXHRpZiAodHlwZW9mIGNsb3NlZCA9PT0gXCJ1bmRlZmluZWRcIikge1xyXG5cdFx0Y2xvc2VkID0gdHJ1ZTtcclxuXHR9XHJcblx0aWYgKGNsb3NlZCAmJiAoc2FtcGxlcyA9PT0gMSkpIHtcclxuXHRcdHRocm93IG5ldyBSYW5nZUVycm9yKFwiVGhlIG51bWJlciBvZiBzYW1wbGVzIG11c3QgYmUgYSBsZWFzdCAyIChmb3Igc3RhcnQgYW5kIGVuZCBwb2ludHMpXCIpO1xyXG5cdH1cclxuXHJcblx0dmFyIGRhdGFUeXBlID0gbmV3IERhdGFUeXBlKFwiZjY0XCIpO1xyXG5cdHZhciBhcnJheSA9IG5ldyBOREFycmF5KHNhbXBsZXMsIGRhdGFUeXBlLCB0aGlzKTtcclxuXHRhcnJheS5fYnVmZmVyID0gdGhpcy5jb250ZXh0LmNyZWF0ZUJ1ZmZlcihjbC5NRU1fUkVBRF9XUklURSwgc2FtcGxlcyAqIGRhdGFUeXBlLnNpemUpO1xyXG5cclxuXHR2YXIgcmFuZ2UgPSBzdG9wIC0gc3RhcnQ7XHJcblx0dmFyIG4gPSAoY2xvc2VkKSA/IHNhbXBsZXMgLSAxIDogc2FtcGxlcztcclxuXHR2YXIgc3RlcCA9IHJhbmdlIC8gbjtcclxuXHJcblx0dmFyIGtlcm5lbCA9IHRoaXMua2VybmVscy5saW5zcGFjZVtkYXRhVHlwZS50eXBlXTtcclxuXHRrZXJuZWwuc2V0QXJnKDAsIG5ldyBVaW50MzJBcnJheShbYXJyYXkubGVuZ3RoXSkpO1xyXG5cdGtlcm5lbC5zZXRBcmcoMSwgYXJyYXkuX2J1ZmZlcik7XHJcblx0a2VybmVsLnNldEFyZygyLCBuZXcgZGF0YVR5cGUuYXJyYXlUeXBlKFtzdGFydF0pKTtcclxuXHRrZXJuZWwuc2V0QXJnKDMsIG5ldyBkYXRhVHlwZS5hcnJheVR5cGUoW3N0ZXBdKSk7XHJcblx0dGhpcy5xdWV1ZS5lbnF1ZXVlTkRSYW5nZUtlcm5lbChrZXJuZWwsIDEsIG51bGwsIFthcnJheS5sZW5ndGhdKTtcclxuXHJcblx0cmV0dXJuIGFycmF5O1xyXG59O1xyXG5cclxuV2ViQ0xDb250ZXh0LnByb3RvdHlwZS5faW52YWxpZGF0ZSA9IGZ1bmN0aW9uKGFycmF5KSB7XHJcblx0aWYgKGFycmF5Ll9idWZmZXIgIT09IG51bGwpIHtcclxuXHRcdC8qIFdvcmstYXJvdW5kIGZvciBDaHJvbWl1bS1XZWJDTCB0aGF0IGN1cnJlbnRseSBsYWNrcyBXZWJDTE1lbU9iamVjdC5yZWxlYXNlIG1ldGhvZCAqL1xyXG5cdFx0aWYgKHR5cGVvZiBhcnJheS5fYnVmZmVyLnJlbGVhc2UgIT09IFwidW5kZWZpbmVkXCIpIHtcclxuXHRcdFx0YXJyYXkuX2J1ZmZlci5yZWxlYXNlKCk7XHJcblx0XHR9XHJcblx0XHRhcnJheS5fYnVmZmVyID0gbnVsbDtcclxuXHR9XHJcbn07XHJcblxyXG5XZWJDTENvbnRleHQucHJvdG90eXBlLmZldGNoID0gZnVuY3Rpb24oKSB7XHJcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcihcIkNhbGxiYWNrIGFyZ3VtZW50IG1pc3NpbmdcIik7XHJcblx0fVxyXG5cdHZhciBjYWxsYmFjayA9IGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoIC0gMV07XHJcblx0LyogVmFsaWRhdGUgYXJndW1lbnRzICovXHJcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcihcIkF0IGxlYXN0IG9uZSBOREFycmF5IGFyZ3VtZW50IGV4cGVjdGVkXCIpO1xyXG5cdH1cclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGggLSAxOyBpKyspIHtcclxuXHRcdGlmICghKGFyZ3VtZW50c1tpXSBpbnN0YW5jZW9mIE5EQXJyYXkpKSB7XHJcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoXCJBcmd1bWVudCBcIiArIGkgKyBcIiBpcyBub3QgYW4gTkRBcnJheVwiKTtcclxuXHRcdH1cclxuXHR9XHJcblx0dmFyIGNhbGxiYWNrV2FpdEFyZ3VtZW50cyA9IGFyZ3VtZW50cy5sZW5ndGggLSAxO1xyXG5cdHZhciBjYWxsYmFja0FyZ3VtZW50cyA9IG5ldyBBcnJheShjYWxsYmFja1dhaXRBcmd1bWVudHMpO1xyXG5cdGlmICh0aGlzLmFzeW5jQ2FsbGJhY2tzKSB7XHJcblx0XHR2YXIgYXN5bmNFdmVudHMgPSBbXTtcclxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgY2FsbGJhY2tXYWl0QXJndW1lbnRzOyBpKyspIHtcclxuXHRcdFx0dmFyIGFycmF5ID0gYXJndW1lbnRzW2ldO1xyXG5cdFx0XHQoZnVuY3Rpb24ocXVldWUsIGksIHNoYXBlLCBBcnJheVR5cGUpIHtcclxuXHRcdFx0XHR2YXIgYnVmZmVyID0gbmV3IEFycmF5VHlwZShhcnJheS5sZW5ndGgpO1xyXG5cdFx0XHRcdHZhciByZWFkRmluaXNoRXZlbnQgPSBjcmVhdGVFdmVudCgpO1xyXG5cdFx0XHRcdGFzeW5jRXZlbnRzLnB1c2gocmVhZEZpbmlzaEV2ZW50KTtcclxuXHRcdFx0XHRxdWV1ZS5lbnF1ZXVlUmVhZEJ1ZmZlcihhcnJheS5fYnVmZmVyLCBmYWxzZSwgMCwgYnVmZmVyLmJ5dGVMZW5ndGgsIGJ1ZmZlciwgbnVsbCwgcmVhZEZpbmlzaEV2ZW50KTtcclxuXHRcdFx0XHRyZWFkRmluaXNoRXZlbnQuc2V0Q2FsbGJhY2soY2wuQ09NUExFVEUsIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0cmVhZEZpbmlzaEV2ZW50LnJlbGVhc2UoKTtcclxuXHRcdFx0XHRcdGNhbGxiYWNrQXJndW1lbnRzW2ldID0gYnVmZmVyO1xyXG5cdFx0XHRcdFx0aWYgKC0tY2FsbGJhY2tXYWl0QXJndW1lbnRzID09PSAwKSB7XHJcblx0XHRcdFx0XHRcdGNhbGxiYWNrLmFwcGx5KG51bGwsIGNhbGxiYWNrQXJndW1lbnRzKTtcclxuXHRcdFx0XHRcdFx0LyogT3BlbkNMIHN0YW5kYXJkOiBjb21tYW5kcyBlbnF1ZXVlZCBpbiBhIGNhbGxiYWNrIHdvbid0IHN0YXJ0IHVudGlsIGNsRmx1c2ggKi9cclxuXHRcdFx0XHRcdFx0cXVldWUuZmx1c2goKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fSkodGhpcy5xdWV1ZSwgaSwgYXJyYXkuc2hhcGUsIGFycmF5LmRhdGFUeXBlLmFycmF5VHlwZSk7XHJcblx0XHRcdC8qIFRoaXMgbGluZSBtb3N0bHkgc2VyaWFsaXplcyBleGVjdXRpb24uIFVuZm9ydHVuYXRlbHksIHdpdGhvdXQgaXQgbm90aGluZyB3b3JrcyAqL1xyXG5cdFx0XHRjbC53YWl0Rm9yRXZlbnRzKGFzeW5jRXZlbnRzKTtcclxuXHRcdH1cclxuXHR9IGVsc2Uge1xyXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjYWxsYmFja1dhaXRBcmd1bWVudHM7IGkrKykge1xyXG5cdFx0XHR2YXIgYXJyYXkgPSBhcmd1bWVudHNbaV07XHJcblx0XHRcdHZhciBidWZmZXIgPSBuZXcgYXJyYXkuZGF0YVR5cGUuYXJyYXlUeXBlKGFycmF5Lmxlbmd0aCk7XHJcblx0XHRcdHRoaXMucXVldWUuZW5xdWV1ZVJlYWRCdWZmZXIoYXJyYXkuX2J1ZmZlciwgdHJ1ZSwgMCwgYnVmZmVyLmJ5dGVMZW5ndGgsIGJ1ZmZlcik7XHJcblx0XHRcdGNhbGxiYWNrQXJndW1lbnRzW2ldID0gYnVmZmVyO1xyXG5cdFx0fVxyXG5cdFx0Y2FsbGJhY2suYXBwbHkobnVsbCwgY2FsbGJhY2tBcmd1bWVudHMpO1xyXG5cdH1cclxufTtcclxuXHJcbldlYkNMQ29udGV4dC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oKSB7XHJcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcihcIkNhbGxiYWNrIGFyZ3VtZW50IG1pc3NpbmdcIik7XHJcblx0fVxyXG5cdHZhciBjYWxsYmFjayA9IGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoIC0gMV07XHJcblx0LyogVmFsaWRhdGUgYXJndW1lbnRzICovXHJcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcihcIkF0IGxlYXN0IG9uZSBOREFycmF5IGFyZ3VtZW50IGV4cGVjdGVkXCIpO1xyXG5cdH1cclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGggLSAxOyBpKyspIHtcclxuXHRcdGlmICghKGFyZ3VtZW50c1tpXSBpbnN0YW5jZW9mIE5EQXJyYXkpKSB7XHJcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoXCJBcmd1bWVudCBcIiArIGkgKyBcIiBpcyBub3QgYW4gTkRBcnJheVwiKTtcclxuXHRcdH1cclxuXHR9XHJcblx0dmFyIGNhbGxiYWNrV2FpdEFyZ3VtZW50cyA9IGFyZ3VtZW50cy5sZW5ndGggLSAxO1xyXG5cdHZhciBjYWxsYmFja0FyZ3VtZW50cyA9IG5ldyBBcnJheShjYWxsYmFja1dhaXRBcmd1bWVudHMpO1xyXG5cdGlmICh0aGlzLmFzeW5jQ2FsbGJhY2tzKSB7XHJcblx0XHR2YXIgYXN5bmNFdmVudHMgPSBbXTtcclxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgY2FsbGJhY2tXYWl0QXJndW1lbnRzOyBpKyspIHtcclxuXHRcdFx0dmFyIGFycmF5ID0gYXJndW1lbnRzW2ldO1xyXG5cdFx0XHQoZnVuY3Rpb24ocXVldWUsIGksIHNoYXBlLCBBcnJheVR5cGUpIHtcclxuXHRcdFx0XHR2YXIgYnVmZmVyID0gbmV3IEFycmF5VHlwZShhcnJheS5sZW5ndGgpO1xyXG5cdFx0XHRcdHZhciByZWFkRmluaXNoRXZlbnQgPSBjcmVhdGVFdmVudCgpO1xyXG5cdFx0XHRcdGFzeW5jRXZlbnRzLnB1c2gocmVhZEZpbmlzaEV2ZW50KTtcclxuXHRcdFx0XHRxdWV1ZS5lbnF1ZXVlUmVhZEJ1ZmZlcihhcnJheS5fYnVmZmVyLCBmYWxzZSwgMCwgYnVmZmVyLmJ5dGVMZW5ndGgsIGJ1ZmZlciwgbnVsbCwgcmVhZEZpbmlzaEV2ZW50KTtcclxuXHRcdFx0XHRpZiAoc2hhcGUubGVuZ3RoID09PSAwKSB7XHJcblx0XHRcdFx0XHRyZWFkRmluaXNoRXZlbnQuc2V0Q2FsbGJhY2soY2wuQ09NUExFVEUsIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0XHRyZWFkRmluaXNoRXZlbnQucmVsZWFzZSgpO1xyXG5cdFx0XHRcdFx0XHRjYWxsYmFja0FyZ3VtZW50c1tpXSA9IGJ1ZmZlclswXTtcclxuXHRcdFx0XHRcdFx0aWYgKC0tY2FsbGJhY2tXYWl0QXJndW1lbnRzID09PSAwKSB7XHJcblx0XHRcdFx0XHRcdFx0Y2FsbGJhY2suYXBwbHkobnVsbCwgY2FsbGJhY2tBcmd1bWVudHMpO1xyXG5cdFx0XHRcdFx0XHRcdC8qIE9wZW5DTCBzdGFuZGFyZDogY29tbWFuZHMgZW5xdWV1ZWQgaW4gYSBjYWxsYmFjayB3b24ndCBzdGFydCB1bnRpbCBjbEZsdXNoICovXHJcblx0XHRcdFx0XHRcdFx0cXVldWUuZmx1c2goKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHJlYWRGaW5pc2hFdmVudC5zZXRDYWxsYmFjayhjbC5DT01QTEVURSwgZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHRcdHJlYWRGaW5pc2hFdmVudC5yZWxlYXNlKCk7XHJcblx0XHRcdFx0XHRcdHZhciBqc2FycmF5ID0gbmV3IEFycmF5KHNoYXBlWzBdKTtcclxuXHRcdFx0XHRcdFx0dXRpbC5jcmVhdGVBcnJheVJlY3Vyc2l2ZShuZXcgQXJyYXlUeXBlKGJ1ZmZlciksIGpzYXJyYXksIHNoYXBlLCAwLCAwKTtcclxuXHRcdFx0XHRcdFx0Y2FsbGJhY2tBcmd1bWVudHNbaV0gPSBqc2FycmF5O1xyXG5cdFx0XHRcdFx0XHRpZiAoLS1jYWxsYmFja1dhaXRBcmd1bWVudHMgPT09IDApIHtcclxuXHRcdFx0XHRcdFx0XHRjYWxsYmFjay5hcHBseShudWxsLCBjYWxsYmFja0FyZ3VtZW50cyk7XHJcblx0XHRcdFx0XHRcdFx0LyogT3BlbkNMIHN0YW5kYXJkOiBjb21tYW5kcyBlbnF1ZXVlZCBpbiBhIGNhbGxiYWNrIHdvbid0IHN0YXJ0IHVudGlsIGNsRmx1c2ggKi9cclxuXHRcdFx0XHRcdFx0XHRxdWV1ZS5mbHVzaCgpO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pKHRoaXMucXVldWUsIGksIGFycmF5LnNoYXBlLCBhcnJheS5kYXRhVHlwZS5hcnJheVR5cGUpO1xyXG5cdFx0XHQvKiBUaGlzIGxpbmUgbW9zdGx5IHNlcmlhbGl6ZXMgZXhlY3V0aW9uLiBVbmZvcnR1bmF0ZWx5LCB3aXRob3V0IGl0IG5vdGhpbmcgd29ya3MgKi9cclxuXHRcdFx0Y2wud2FpdEZvckV2ZW50cyhhc3luY0V2ZW50cyk7XHJcblx0XHR9XHJcblx0fSBlbHNlIHtcclxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgY2FsbGJhY2tXYWl0QXJndW1lbnRzOyBpKyspIHtcclxuXHRcdFx0dmFyIGFycmF5ID0gYXJndW1lbnRzW2ldO1xyXG5cdFx0XHR2YXIgYnVmZmVyID0gbmV3IGFycmF5LmRhdGFUeXBlLmFycmF5VHlwZShhcnJheS5sZW5ndGgpO1xyXG5cdFx0XHR0aGlzLnF1ZXVlLmVucXVldWVSZWFkQnVmZmVyKGFycmF5Ll9idWZmZXIsIHRydWUsIDAsIGJ1ZmZlci5ieXRlTGVuZ3RoLCBidWZmZXIpO1xyXG5cdFx0XHRpZiAoYXJyYXkuc2hhcGUubGVuZ3RoID09PSAwKSB7XHJcblx0XHRcdFx0Y2FsbGJhY2tBcmd1bWVudHNbaV0gPSBidWZmZXJbMF07XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dmFyIGpzYXJyYXkgPSBuZXcgQXJyYXkoYXJyYXkuc2hhcGVbMF0pO1xyXG5cdFx0XHRcdHV0aWwuY3JlYXRlQXJyYXlSZWN1cnNpdmUobmV3IGFycmF5LmRhdGFUeXBlLmFycmF5VHlwZShidWZmZXIpLCBqc2FycmF5LCBhcnJheS5zaGFwZSwgMCwgMCk7XHJcblx0XHRcdFx0Y2FsbGJhY2tBcmd1bWVudHNbaV0gPSBqc2FycmF5O1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRjYWxsYmFjay5hcHBseShudWxsLCBjYWxsYmFja0FyZ3VtZW50cyk7XHJcblx0fVxyXG59O1xyXG5cclxuV2ViQ0xDb250ZXh0LnByb3RvdHlwZS5iYXJyaWVyID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcclxuXHR2YXIgYmFycmllckV2ZW50ID0gY3JlYXRlRXZlbnQoKTtcclxuXHR0aGlzLnF1ZXVlLmVucXVldWVNYXJrZXIoYmFycmllckV2ZW50KTtcclxuXHRpZiAodGhpcy5hc3luY0NhbGxiYWNrcykge1xyXG5cdFx0dmFyIHF1ZXVlID0gdGhpcy5xdWV1ZTtcclxuXHRcdGJhcnJpZXJFdmVudC5zZXRDYWxsYmFjayhjbC5DT01QTEVURSwgZnVuY3Rpb24oKSB7XHJcblx0XHRcdGJhcnJpZXJFdmVudC5yZWxlYXNlKCk7XHJcblx0XHRcdGNhbGxiYWNrKCk7XHJcblx0XHRcdC8qIE9wZW5DTCBzdGFuZGFyZDogY29tbWFuZHMgZW5xdWV1ZWQgaW4gYSBjYWxsYmFjayB3b24ndCBzdGFydCB1bnRpbCBjbEZsdXNoICovXHJcblx0XHRcdHF1ZXVlLmZsdXNoKCk7XHJcblx0XHR9KTtcclxuXHRcdGNsLndhaXRGb3JFdmVudHMoW2JhcnJpZXJFdmVudF0pO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRjbC53YWl0Rm9yRXZlbnRzKFtiYXJyaWVyRXZlbnRdKTtcclxuXHRcdGNhbGxiYWNrKCk7XHJcblx0fVxyXG59O1xyXG5cclxuV2ViQ0xDb250ZXh0LnByb3RvdHlwZS5yZXNoYXBlID0gZnVuY3Rpb24oYSwgc2hhcGUpIHtcclxuXHRzaGFwZSA9IHV0aWwuY2hlY2tTaGFwZShzaGFwZSk7XHJcblx0aWYgKHV0aWwuY29tcHV0ZUxlbmd0aChzaGFwZSkgIT09IGEubGVuZ3RoKSB7XHJcblx0XHR0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlRoZSBzaGFwZSBpcyBub3QgY29tcGF0aWJsZSB3aXRoIHRoZSBhcnJheVwiKTtcclxuXHR9XHJcblx0dmFyIG91dCA9IG5ldyBOREFycmF5KHNoYXBlLCBhLmRhdGFUeXBlLCB0aGlzKTtcclxuXHRpZiAoYS5fZGVjUmVmKCkpIHtcclxuXHRcdG91dC5fYnVmZmVyID0gdGhpcy5jb250ZXh0LmNyZWF0ZUJ1ZmZlcih3ZWJjbC5NRU1fUkVBRF9XUklURSwgb3V0Lmxlbmd0aCAqIG91dC5kYXRhVHlwZS5zaXplKTtcclxuXHRcdHRoaXMucXVldWUuZW5xdWV1ZUNvcHlCdWZmZXIoYS5fYnVmZmVyLCBvdXQuX2J1ZmZlciwgMCwgMCwgb3V0Lmxlbmd0aCAqIG91dC5kYXRhVHlwZS5zaXplKTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0b3V0Ll9idWZmZXIgPSBhLl9idWZmZXI7XHJcblx0XHRhLl9idWZmZXIgPSBudWxsO1xyXG5cdH1cclxuXHRyZXR1cm4gb3V0O1xyXG59O1xyXG5cclxuV2ViQ0xDb250ZXh0LnByb3RvdHlwZS5yZXBlYXQgPSBmdW5jdGlvbihhLCByZXBlYXRzLCBheGlzLCBvdXQpIHtcclxuXHR1dGlsLmNoZWNrTkRBcnJheShhLCBcImFcIik7XHJcblx0cmVwZWF0cyA9IHV0aWwuY2hlY2tSZXBlYXRzKHJlcGVhdHMpO1xyXG5cdGF4aXMgPSB1dGlsLmNoZWNrQXhpcyhheGlzLCBhLnNoYXBlLmxlbmd0aCk7XHJcblx0dmFyIHNoYXBlQSA9IGEuc2hhcGU7XHJcblx0dmFyIHNoYXBlT3V0ID0gc2hhcGVBLnNsaWNlKDApO1xyXG5cdHNoYXBlT3V0W2F4aXNdICo9IHJlcGVhdHM7XHJcblx0YS5fZGVjUmVmKCk7XHJcblx0dHJ5IHtcclxuXHRcdGlmICh0eXBlb2Ygb3V0ID09PSBcInVuZGVmaW5lZFwiKSB7XHJcblx0XHRcdG91dCA9IG5ldyBOREFycmF5KHNoYXBlT3V0LCBhLmRhdGFUeXBlLCB0aGlzKTtcclxuXHRcdFx0b3V0Ll9idWZmZXIgPSB0aGlzLmNvbnRleHQuY3JlYXRlQnVmZmVyKGNsLk1FTV9SRUFEX1dSSVRFLCBvdXQubGVuZ3RoICogb3V0LmRhdGFUeXBlLnNpemUpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dXRpbC5jaGVja05EQXJyYXkob3V0LCBcIm91dFwiKTtcclxuXHRcdFx0dXRpbC5jaGVja1NoYXBlc0NvbXBhdGliaWxpdHkob3V0LnNoYXBlLCBzaGFwZU91dCk7XHJcblx0XHRcdHV0aWwuY2hlY2tEYXRhVHlwZXNDb21wYXRpYmlsaXR5KGEuZGF0YVR5cGUsIG91dC5kYXRhVHlwZSk7XHJcblx0XHRcdG91dC5faW5jUmVmKCk7XHJcblx0XHR9XHJcblx0XHR2YXIgb3V0ZXJTdHJpZGUgPSB1dGlsLmNvbXB1dGVPdXRlclN0cmlkZShzaGFwZUEsIGF4aXMpO1xyXG5cdFx0dmFyIGV4cGFuc2lvbkRpbSA9IHNoYXBlQVtheGlzXTtcclxuXHRcdHZhciBpbm5lclN0cmlkZSA9IHV0aWwuY29tcHV0ZUlubmVyU3RyaWRlKHNoYXBlQSwgYXhpcyk7XHJcblx0XHR2YXIga2VybmVsID0gdGhpcy5rZXJuZWxzLnJlcGVhdFthLmRhdGFUeXBlLnR5cGVdO1xyXG5cdFx0a2VybmVsLnNldEFyZygwLCBuZXcgVWludDMyQXJyYXkoW2V4cGFuc2lvbkRpbV0pKTtcclxuXHRcdGtlcm5lbC5zZXRBcmcoMSwgbmV3IFVpbnQzMkFycmF5KFtpbm5lclN0cmlkZV0pKTtcclxuXHRcdGtlcm5lbC5zZXRBcmcoMiwgbmV3IFVpbnQzMkFycmF5KFtyZXBlYXRzXSkpO1xyXG5cdFx0a2VybmVsLnNldEFyZygzLCBhLl9idWZmZXIpO1xyXG5cdFx0a2VybmVsLnNldEFyZyg0LCBvdXQuX2J1ZmZlcik7XHJcblx0XHR0aGlzLnF1ZXVlLmVucXVldWVORFJhbmdlS2VybmVsKGtlcm5lbCwgMywgbnVsbCwgW291dGVyU3RyaWRlLCBleHBhbnNpb25EaW0sIGlubmVyU3RyaWRlXSk7XHJcblx0fSBjYXRjaCAoZSkge1xyXG5cdFx0YS5faW5jUmVmKCk7XHJcblx0XHR0aHJvdyBlO1xyXG5cdH1cclxuXHRhLl90cnlJbnZhbGlkYXRlKCk7XHJcblx0cmV0dXJuIG91dDtcclxufTtcclxuXHJcbnZhciBiaW5hcnlBcml0aE9wID0gZnVuY3Rpb24oYSwgYiwgb3V0LCBmdXJpb3VzQ29udGV4dCwgYmluYXJ5T3BLZXJuZWxzLCBiaW5hcnlDb25zdE9wS2VybmVscywgYmluYXJ5UmV2Q29uc3RLZXJuZWxzKSB7XHJcblx0dmFyIHNoYXBlT3V0ID0gbnVsbCwgZGF0YVR5cGVPdXQgPSBudWxsO1xyXG5cdHZhciBidWZmZXJBID0gbnVsbCwgYnVmZmVyQiA9IG51bGw7XHJcblx0aWYgKGEgaW5zdGFuY2VvZiBOREFycmF5KSB7XHJcblx0XHRidWZmZXJBID0gYS5fYnVmZmVyO1xyXG5cdFx0c2hhcGVPdXQgPSBhLnNoYXBlO1xyXG5cdFx0ZGF0YVR5cGVPdXQgPSBhLmRhdGFUeXBlO1xyXG5cdFx0aWYgKGIgaW5zdGFuY2VvZiBOREFycmF5KSB7XHJcblx0XHRcdGJ1ZmZlckIgPSBiLl9idWZmZXI7XHJcblx0XHRcdHV0aWwuY2hlY2tTaGFwZXNDb21wYXRpYmlsaXR5KGEuc2hhcGUsIGIuc2hhcGUpO1xyXG5cdFx0XHR1dGlsLmNoZWNrRGF0YVR5cGVzQ29tcGF0aWJpbGl0eShhLmRhdGFUeXBlLCBiLmRhdGFUeXBlKTtcclxuXHRcdH0gZWxzZSBpZiAoIXV0aWwuaXNOdW1iZXIoYikpIHtcclxuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihcIlVuc3VwcG9ydGVkIHR5cGUgb2YgYlwiKTtcclxuXHRcdH1cclxuXHR9IGVsc2UgaWYgKHV0aWwuaXNOdW1iZXIoYSkpIHtcclxuXHRcdHV0aWwuY2hlY2tOREFycmF5KGIsIFwiYlwiKTtcclxuXHRcdGJ1ZmZlckIgPSBiLl9idWZmZXI7XHJcblx0XHRzaGFwZU91dCA9IGIuc2hhcGU7XHJcblx0XHRkYXRhVHlwZU91dCA9IGIuZGF0YVR5cGU7XHJcblx0fSBlbHNlIHtcclxuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoXCJVbnN1cHBvcnRlZCB0eXBlIG9mIGFcIik7XHJcblx0fVxyXG5cdGlmIChhIGluc3RhbmNlb2YgTkRBcnJheSkge1xyXG5cdFx0YS5fZGVjUmVmKCk7XHJcblx0fVxyXG5cdGlmIChiIGluc3RhbmNlb2YgTkRBcnJheSkge1xyXG5cdFx0Yi5fZGVjUmVmKCk7XHJcblx0fVxyXG5cdHRyeSB7XHJcblx0XHRpZiAodHlwZW9mIG91dCA9PT0gXCJ1bmRlZmluZWRcIikge1xyXG5cdFx0XHRvdXQgPSBuZXcgTkRBcnJheShzaGFwZU91dCwgZGF0YVR5cGVPdXQsIGZ1cmlvdXNDb250ZXh0KTtcclxuXHRcdFx0aWYgKChhIGluc3RhbmNlb2YgTkRBcnJheSkgJiYgIWEuX2hhc1JlZnMoKSkge1xyXG5cdFx0XHRcdG91dC5fYnVmZmVyID0gYS5fYnVmZmVyO1xyXG5cdFx0XHRcdGEuX2J1ZmZlciA9IG51bGw7XHJcblx0XHRcdH0gZWxzZSBpZiAoKGIgaW5zdGFuY2VvZiBOREFycmF5KSAmJiAhYi5faGFzUmVmcygpKSB7XHJcblx0XHRcdFx0b3V0Ll9idWZmZXIgPSBiLl9idWZmZXI7XHJcblx0XHRcdFx0Yi5fYnVmZmVyID0gbnVsbDtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRvdXQuX2J1ZmZlciA9IGZ1cmlvdXNDb250ZXh0LmNvbnRleHQuY3JlYXRlQnVmZmVyKGNsLk1FTV9SRUFEX1dSSVRFLCBvdXQubGVuZ3RoICogb3V0LmRhdGFUeXBlLnNpemUpO1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR1dGlsLmNoZWNrTkRBcnJheShvdXQsIFwib3V0XCIpO1xyXG5cdFx0XHR1dGlsLmNoZWNrU2hhcGVzQ29tcGF0aWJpbGl0eShzaGFwZU91dCwgb3V0LnNoYXBlKTtcclxuXHRcdFx0dXRpbC5jaGVja0RhdGFUeXBlc0NvbXBhdGliaWxpdHkoZGF0YVR5cGVPdXQsIG91dC5kYXRhVHlwZSk7XHJcblx0XHRcdG91dC5faW5jUmVmKCk7XHJcblx0XHR9XHJcblx0XHRpZiAoYSBpbnN0YW5jZW9mIE5EQXJyYXkpIHtcclxuXHRcdFx0aWYgKGIgaW5zdGFuY2VvZiBOREFycmF5KSB7XHJcblx0XHRcdFx0dmFyIGtlcm5lbCA9IGJpbmFyeU9wS2VybmVsc1tkYXRhVHlwZU91dC50eXBlXTtcclxuXHRcdFx0XHRrZXJuZWwuc2V0QXJnKDAsIG5ldyBVaW50MzJBcnJheShbb3V0Lmxlbmd0aF0pKTtcclxuXHRcdFx0XHRrZXJuZWwuc2V0QXJnKDEsIGJ1ZmZlckEpO1xyXG5cdFx0XHRcdGtlcm5lbC5zZXRBcmcoMiwgYnVmZmVyQik7XHJcblx0XHRcdFx0a2VybmVsLnNldEFyZygzLCBvdXQuX2J1ZmZlcik7XHJcblx0XHRcdFx0ZnVyaW91c0NvbnRleHQucXVldWUuZW5xdWV1ZU5EUmFuZ2VLZXJuZWwoa2VybmVsLCAxLCBudWxsLCBbb3V0Lmxlbmd0aF0pO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHZhciBrZXJuZWwgPSBiaW5hcnlDb25zdE9wS2VybmVsc1tkYXRhVHlwZU91dC50eXBlXTtcclxuXHRcdFx0XHRrZXJuZWwuc2V0QXJnKDAsIG5ldyBVaW50MzJBcnJheShbb3V0Lmxlbmd0aF0pKTtcclxuXHRcdFx0XHRrZXJuZWwuc2V0QXJnKDEsIGJ1ZmZlckEpO1xyXG5cdFx0XHRcdGtlcm5lbC5zZXRBcmcoMiwgbmV3IGRhdGFUeXBlT3V0LmFycmF5VHlwZShbYl0pKTtcclxuXHRcdFx0XHRrZXJuZWwuc2V0QXJnKDMsIG91dC5fYnVmZmVyKTtcclxuXHRcdFx0XHRmdXJpb3VzQ29udGV4dC5xdWV1ZS5lbnF1ZXVlTkRSYW5nZUtlcm5lbChrZXJuZWwsIDEsIG51bGwsIFtvdXQubGVuZ3RoXSk7XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHZhciBrZXJuZWwgPSBiaW5hcnlSZXZDb25zdEtlcm5lbHNbZGF0YVR5cGVPdXQudHlwZV07XHJcblx0XHRcdGtlcm5lbC5zZXRBcmcoMCwgbmV3IFVpbnQzMkFycmF5KFtvdXQubGVuZ3RoXSkpO1xyXG5cdFx0XHRrZXJuZWwuc2V0QXJnKDEsIGJ1ZmZlckIpO1xyXG5cdFx0XHRrZXJuZWwuc2V0QXJnKDIsIG5ldyBkYXRhVHlwZU91dC5hcnJheVR5cGUoW2FdKSk7XHJcblx0XHRcdGtlcm5lbC5zZXRBcmcoMywgb3V0Ll9idWZmZXIpO1xyXG5cdFx0XHRmdXJpb3VzQ29udGV4dC5xdWV1ZS5lbnF1ZXVlTkRSYW5nZUtlcm5lbChrZXJuZWwsIDEsIG51bGwsIFtvdXQubGVuZ3RoXSk7XHJcblx0XHR9XHJcblx0fSBjYXRjaCAoZSkge1xyXG5cdFx0LyogUmVzdG9yZSB0aGUgcHJldmlvdXMgc3RhdGUgKi9cclxuXHRcdGlmIChhIGluc3RhbmNlb2YgTkRBcnJheSkge1xyXG5cdFx0XHRhLl9pbmNSZWYoKTtcclxuXHRcdH1cclxuXHRcdGlmIChiIGluc3RhbmNlb2YgTkRBcnJheSkge1xyXG5cdFx0XHRiLl9pbmNSZWYoKTtcclxuXHRcdH1cclxuXHRcdHRocm93IGU7XHJcblx0fVxyXG5cdGlmIChhIGluc3RhbmNlb2YgTkRBcnJheSkge1xyXG5cdFx0YS5fdHJ5SW52YWxpZGF0ZSgpO1xyXG5cdH1cclxuXHRpZiAoYiBpbnN0YW5jZW9mIE5EQXJyYXkpIHtcclxuXHRcdGIuX3RyeUludmFsaWRhdGUoKTtcclxuXHR9XHJcblx0cmV0dXJuIG91dDtcclxufTtcclxuXHJcbnZhciB1bmFyeUFyaXRoT3AgPSBmdW5jdGlvbihhLCBvdXQsIGZ1cmlvdXNDb250ZXh0LCB1bmFyeU9wS2VybmVscykge1xyXG5cdHV0aWwuY2hlY2tOREFycmF5KGEsIFwiYVwiKTtcclxuXHRhLl9kZWNSZWYoKTtcclxuXHR2YXIgYnVmZmVyQSA9IGEuX2J1ZmZlcjtcclxuXHR0cnkge1xyXG5cdFx0aWYgKHR5cGVvZiBvdXQgPT09IFwidW5kZWZpbmVkXCIpIHtcclxuXHRcdFx0b3V0ID0gbmV3IE5EQXJyYXkoYS5zaGFwZSwgYS5kYXRhVHlwZSwgZnVyaW91c0NvbnRleHQpO1xyXG5cdFx0XHRpZiAoKGEgaW5zdGFuY2VvZiBOREFycmF5KSAmJiAhYS5faGFzUmVmcygpKSB7XHJcblx0XHRcdFx0b3V0Ll9idWZmZXIgPSBhLl9idWZmZXI7XHJcblx0XHRcdFx0YS5fYnVmZmVyID0gbnVsbDtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRvdXQuX2J1ZmZlciA9IGZ1cmlvdXNDb250ZXh0LmNvbnRleHQuY3JlYXRlQnVmZmVyKGNsLk1FTV9SRUFEX1dSSVRFLCBvdXQubGVuZ3RoICogb3V0LmRhdGFUeXBlLnNpemUpO1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR1dGlsLmNoZWNrTkRBcnJheShvdXQsIFwib3V0XCIpO1xyXG5cdFx0XHR1dGlsLmNoZWNrU2hhcGVzQ29tcGF0aWJpbGl0eShhLnNoYXBlLCBvdXQuc2hhcGUpO1xyXG5cdFx0XHR1dGlsLmNoZWNrRGF0YVR5cGVzQ29tcGF0aWJpbGl0eShhLmRhdGFUeXBlLCBvdXQuZGF0YVR5cGUpO1xyXG5cdFx0XHRvdXQuX2luY1JlZigpO1xyXG5cdFx0fVxyXG5cdFx0dmFyIGtlcm5lbCA9IHVuYXJ5T3BLZXJuZWxzW2EuZGF0YVR5cGUudHlwZV07XHJcblx0XHRrZXJuZWwuc2V0QXJnKDAsIG5ldyBVaW50MzJBcnJheShbb3V0Lmxlbmd0aF0pKTtcclxuXHRcdGtlcm5lbC5zZXRBcmcoMSwgYnVmZmVyQSk7XHJcblx0XHRrZXJuZWwuc2V0QXJnKDIsIG91dC5fYnVmZmVyKTtcclxuXHRcdGZ1cmlvdXNDb250ZXh0LnF1ZXVlLmVucXVldWVORFJhbmdlS2VybmVsKGtlcm5lbCwgMSwgbnVsbCwgW291dC5sZW5ndGhdKTtcclxuXHR9IGNhdGNoIChlKSB7XHJcblx0XHQvKiBSZXN0b3JlIHRoZSBwcmV2aW91cyBzdGF0ZSAqL1xyXG5cdFx0YS5faW5jUmVmKCk7XHJcblx0XHR0aHJvdyBlO1xyXG5cdH1cclxuXHRhLl90cnlJbnZhbGlkYXRlKCk7XHJcblx0cmV0dXJuIG91dDtcclxufTtcclxuXHJcbnZhciBheGlzUmVkdWNlT3AgPSBmdW5jdGlvbihhLCBheGlzLCBvdXQsIGZ1cmlvdXNDb250ZXh0LCByZWR1Y2VLZXJuZWxzLCBheGlzUmVkdWNlS2VybmVscykge1xyXG5cdHV0aWwuY2hlY2tOREFycmF5KGEsIFwiYVwiKTtcclxuXHRpZiAodHlwZW9mIGF4aXMgPT09IFwidW5kZWZpbmVkXCIpIHtcclxuXHRcdGlmICh0eXBlb2Ygb3V0ID09PSBcInVuZGVmaW5lZFwiKSB7XHJcblx0XHRcdG91dCA9IG5ldyBOREFycmF5KFtdLCBhLmRhdGFUeXBlLCBmdXJpb3VzQ29udGV4dCk7XHJcblx0XHRcdG91dC5fYnVmZmVyID0gZnVyaW91c0NvbnRleHQuY29udGV4dC5jcmVhdGVCdWZmZXIoY2wuTUVNX1JFQURfV1JJVEUsIGEuZGF0YVR5cGUuc2l6ZSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR1dGlsLmNoZWNrTkRBcnJheShvdXQsIFwib3V0XCIpO1xyXG5cdFx0XHR1dGlsLmNoZWNrU2hhcGVzQ29tcGF0aWJpbGl0eShbXSwgb3V0LnNoYXBlKTtcclxuXHRcdFx0dXRpbC5jaGVja0RhdGFUeXBlc0NvbXBhdGliaWxpdHkoYS5kYXRhVHlwZSwgb3V0LmRhdGFUeXBlKTtcclxuXHRcdFx0b3V0Ll9pbmNSZWYoKTtcclxuXHRcdH1cclxuXHRcdHZhciBsZW5ndGhBID0gYS5sZW5ndGg7XHJcblx0XHR2YXIgbWF4V29ya0l0ZW1zUGVyQ1UgPSBNYXRoLm1pbihcclxuXHRcdFx0TWF0aC5taW4oZnVyaW91c0NvbnRleHQuZGV2aWNlSW5mby5tYXhXb3JrR3JvdXBTaXplLFxyXG5cdFx0XHRcdGZ1cmlvdXNDb250ZXh0LmRldmljZUluZm8ubWF4V29ya0l0ZW1TaXplc1swXSksIFxyXG5cdFx0XHRmdXJpb3VzQ29udGV4dC5kZXZpY2VJbmZvLmxvY2FsTWVtb3J5U2l6ZSAvIGEuZGF0YVR5cGUuc2l6ZSk7XHJcblx0XHQvKiBUaGUgbWluaW1hbCBhbW1vdW50IG9mIHBhcmFsbGVsaXNtIHRoYXQganVzdGlmaWVzIHN3aXRjaGluZyB0byB0d28tcGFzcyByZWR1Y3Rpb24gKi9cclxuXHRcdHZhciBwYXJhbGxlbGlzYXRpb25UaHJlc2hvbGQgPSAxNjtcclxuXHRcdHZhciBrZXJuZWwgPSByZWR1Y2VLZXJuZWxzW2EuZGF0YVR5cGUudHlwZV07XHJcblx0XHRpZiAobGVuZ3RoQSA8IG1heFdvcmtJdGVtc1BlckNVICogcGFyYWxsZWxpc2F0aW9uVGhyZXNob2xkKSB7XHJcblx0XHRcdC8qIE9uZSByZWR1Y3Rpb24gaXMgZW5vdWdoICovXHJcblx0XHRcdGtlcm5lbC5zZXRBcmcoMCwgbmV3IFVpbnQzMkFycmF5KFtsZW5ndGhBXSkpO1xyXG5cdFx0XHRrZXJuZWwuc2V0QXJnKDEsIGEuX2J1ZmZlcik7XHJcblx0XHRcdGtlcm5lbC5zZXRBcmcoMiwgbmV3IFVpbnQzMkFycmF5KFttYXhXb3JrSXRlbXNQZXJDVSAqIGEuZGF0YVR5cGUuc2l6ZV0pKTtcclxuXHRcdFx0a2VybmVsLnNldEFyZygzLCBvdXQuX2J1ZmZlcik7XHJcblx0XHRcdC8qIEltcG9ydGFudDogdXNlIG9ubHkgb25lIHdvcmsgZ3JvdXAgKi9cclxuXHRcdFx0ZnVyaW91c0NvbnRleHQucXVldWUuZW5xdWV1ZU5EUmFuZ2VLZXJuZWwoa2VybmVsLCAxLCBudWxsLCBbbWF4V29ya0l0ZW1zUGVyQ1VdLCBbbWF4V29ya0l0ZW1zUGVyQ1VdKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdC8qIFR3by1zdGVwIHJlZHVjdGlvbiAqL1xyXG5cdFx0XHR2YXIgbWF4Q29tcHV0ZVVuaXRzID0gZnVyaW91c0NvbnRleHQuZGV2aWNlSW5mby5tYXhDb21wdXRlVW5pdHM7XHJcblx0XHRcdHZhciB3b3JrR3JvdXBTaXplTXVsdGlwbGUgPSBrZXJuZWwuZ2V0V29ya0dyb3VwSW5mbyhmdXJpb3VzQ29udGV4dC5kZXZpY2UsIGNsLktFUk5FTF9QUkVGRVJSRURfV09SS19HUk9VUF9TSVpFX01VTFRJUExFKTtcclxuXHRcdFx0dmFyIHRlbXBCdWZmZXIgPSBmdXJpb3VzQ29udGV4dC5jb250ZXh0LmNyZWF0ZUJ1ZmZlcihjbC5NRU1fUkVBRF9XUklURSwgbWF4Q29tcHV0ZVVuaXRzICogYS5kYXRhVHlwZS5zaXplKTtcclxuXHJcblx0XHRcdGtlcm5lbC5zZXRBcmcoMCwgbmV3IFVpbnQzMkFycmF5KFtsZW5ndGhBXSkpO1xyXG5cdFx0XHRrZXJuZWwuc2V0QXJnKDEsIGEuX2J1ZmZlcik7XHJcblx0XHRcdGtlcm5lbC5zZXRBcmcoMiwgbmV3IFVpbnQzMkFycmF5KFttYXhXb3JrSXRlbXNQZXJDVSAqIGEuZGF0YVR5cGUuc2l6ZV0pKTtcclxuXHRcdFx0a2VybmVsLnNldEFyZygzLCB0ZW1wQnVmZmVyKTtcclxuXHRcdFx0ZnVyaW91c0NvbnRleHQucXVldWUuZW5xdWV1ZU5EUmFuZ2VLZXJuZWwoa2VybmVsLCAxLCBudWxsLFxyXG5cdFx0XHRcdFttYXhXb3JrSXRlbXNQZXJDVSAqIG1heENvbXB1dGVVbml0c10sXHJcblx0XHRcdFx0W21heFdvcmtJdGVtc1BlckNVXSk7XHJcblxyXG5cdFx0XHR2YXIgd29ya0dyb3VwU2l6ZSA9IE1hdGgubWluKG1heFdvcmtJdGVtc1BlckNVLFxyXG5cdFx0XHRcdHV0aWwucm91bmRVcChtYXhDb21wdXRlVW5pdHMsIHdvcmtHcm91cFNpemVNdWx0aXBsZSkpO1xyXG5cdFx0XHRrZXJuZWwuc2V0QXJnKDAsIG5ldyBVaW50MzJBcnJheShbbWF4Q29tcHV0ZVVuaXRzXSkpO1xyXG5cdFx0XHRrZXJuZWwuc2V0QXJnKDEsIHRlbXBCdWZmZXIpO1xyXG5cdFx0XHRrZXJuZWwuc2V0QXJnKDIsIG5ldyBVaW50MzJBcnJheShbd29ya0dyb3VwU2l6ZSAqIGEuZGF0YVR5cGUuc2l6ZV0pKTtcclxuXHRcdFx0a2VybmVsLnNldEFyZygzLCBvdXQuX2J1ZmZlcik7XHJcblx0XHRcdC8qIEltcG9ydGFudDogdXNlIG9ubHkgb25lIHdvcmsgZ3JvdXAgKi9cclxuXHRcdFx0ZnVyaW91c0NvbnRleHQucXVldWUuZW5xdWV1ZU5EUmFuZ2VLZXJuZWwoa2VybmVsLCAxLCBudWxsLFxyXG5cdFx0XHRcdFt3b3JrR3JvdXBTaXplXSxcclxuXHRcdFx0XHRbd29ya0dyb3VwU2l6ZV0pO1xyXG5cclxuXHRcdFx0dGVtcEJ1ZmZlci5yZWxlYXNlKCk7XHJcblx0XHR9XHJcblx0XHRhLl90cnlSZWxlYXNlKCk7XHJcblx0XHRyZXR1cm4gb3V0O1xyXG5cdH0gZWxzZSB7XHJcblx0XHRheGlzID0gdXRpbC5jaGVja0F4aXMoYXhpcywgYS5zaGFwZS5sZW5ndGgpO1xyXG5cdFx0dmFyIHNoYXBlT3V0ID0gdXRpbC5jb21wdXRlQXhpc1JlZHVjdGlvbk91dFNoYXBlKGEuc2hhcGUsIGF4aXMpO1xyXG5cdFx0aWYgKHR5cGVvZiBvdXQgPT09IFwidW5kZWZpbmVkXCIpIHtcclxuXHRcdFx0b3V0ID0gbmV3IE5EQXJyYXkoc2hhcGVPdXQsIGEuZGF0YVR5cGUsIGZ1cmlvdXNDb250ZXh0KTtcclxuXHRcdFx0b3V0Ll9idWZmZXIgPSBmdXJpb3VzQ29udGV4dC5jb250ZXh0LmNyZWF0ZUJ1ZmZlcihjbC5NRU1fUkVBRF9XUklURSwgYS5kYXRhVHlwZS5zaXplICogb3V0Lmxlbmd0aCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR1dGlsLmNoZWNrTkRBcnJheShvdXQsIFwib3V0XCIpO1xyXG5cdFx0XHR1dGlsLmNoZWNrU2hhcGVzQ29tcGF0aWJpbGl0eShbXSwgb3V0LnNoYXBlKTtcclxuXHRcdFx0dXRpbC5jaGVja0RhdGFUeXBlc0NvbXBhdGliaWxpdHkoYS5kYXRhVHlwZSwgb3V0LmRhdGFUeXBlKTtcclxuXHRcdFx0b3V0Ll9pbmNSZWYoKTtcclxuXHRcdH1cclxuXHRcdHZhciBvdXRlclN0cmlkZSA9IHV0aWwuY29tcHV0ZU91dGVyU3RyaWRlKGEuc2hhcGUsIGF4aXMpO1xyXG5cdFx0dmFyIHJlZHVjdGlvbkRpbSA9IGEuc2hhcGVbYXhpc107XHJcblx0XHR2YXIgaW5uZXJTdHJpZGUgPSB1dGlsLmNvbXB1dGVJbm5lclN0cmlkZShhLnNoYXBlLCBheGlzKTtcclxuXHRcdHZhciBrZXJuZWwgPSBheGlzUmVkdWNlS2VybmVsc1thLmRhdGFUeXBlLnR5cGVdO1xyXG5cdFx0a2VybmVsLnNldEFyZygwLCBuZXcgVWludDMyQXJyYXkoW3JlZHVjdGlvbkRpbV0pKTtcclxuXHRcdGtlcm5lbC5zZXRBcmcoMSwgYS5fYnVmZmVyKTtcclxuXHRcdGtlcm5lbC5zZXRBcmcoMiwgb3V0Ll9idWZmZXIpO1xyXG5cdFx0ZnVyaW91c0NvbnRleHQucXVldWUuZW5xdWV1ZU5EUmFuZ2VLZXJuZWwoa2VybmVsLCAyLCBudWxsLFxyXG5cdFx0XHRbb3V0ZXJTdHJpZGUsIGlubmVyU3RyaWRlXSk7XHJcblx0XHRhLl90cnlSZWxlYXNlKCk7XHJcblx0XHRyZXR1cm4gb3V0O1xyXG5cdH1cclxufTtcclxuXHJcblxyXG5XZWJDTENvbnRleHQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKGEsIGIsIG91dCkge1xyXG5cdHJldHVybiBiaW5hcnlBcml0aE9wKGEsIGIsIG91dCwgdGhpcywgdGhpcy5rZXJuZWxzLmFkZCwgdGhpcy5rZXJuZWxzLmFkZGMsIHRoaXMua2VybmVscy5hZGRjKTtcclxufTtcclxuXHJcbldlYkNMQ29udGV4dC5wcm90b3R5cGUuc3ViID0gZnVuY3Rpb24oYSwgYiwgb3V0KSB7XHJcblx0cmV0dXJuIGJpbmFyeUFyaXRoT3AoYSwgYiwgb3V0LCB0aGlzLCB0aGlzLmtlcm5lbHMuc3ViLCB0aGlzLmtlcm5lbHMuc3ViYywgdGhpcy5rZXJuZWxzLnN1YnJjKTtcclxufTtcclxuXHJcbldlYkNMQ29udGV4dC5wcm90b3R5cGUubXVsID0gZnVuY3Rpb24oYSwgYiwgb3V0KSB7XHJcblx0cmV0dXJuIGJpbmFyeUFyaXRoT3AoYSwgYiwgb3V0LCB0aGlzLCB0aGlzLmtlcm5lbHMubXVsLCB0aGlzLmtlcm5lbHMubXVsYywgdGhpcy5rZXJuZWxzLm11bGMpO1xyXG59O1xyXG5cclxuV2ViQ0xDb250ZXh0LnByb3RvdHlwZS5kaXYgPSBmdW5jdGlvbihhLCBiLCBvdXQpIHtcclxuXHRyZXR1cm4gYmluYXJ5QXJpdGhPcChhLCBiLCBvdXQsIHRoaXMsIHRoaXMua2VybmVscy5kaXYsIHRoaXMua2VybmVscy5kaXZjLCB0aGlzLmtlcm5lbHMuZGl2cmMpO1xyXG59O1xyXG5cclxuV2ViQ0xDb250ZXh0LnByb3RvdHlwZS5uZWcgPSBmdW5jdGlvbihhLCBvdXQpIHtcclxuXHRyZXR1cm4gdW5hcnlBcml0aE9wKGEsIG91dCwgdGhpcywgdGhpcy5rZXJuZWxzLm5lZyk7XHJcbn07XHJcblxyXG5XZWJDTENvbnRleHQucHJvdG90eXBlLmFicyA9IGZ1bmN0aW9uKGEsIG91dCkge1xyXG5cdHJldHVybiB1bmFyeUFyaXRoT3AoYSwgb3V0LCB0aGlzLCB0aGlzLmtlcm5lbHMuYWJzKTtcclxufTtcclxuXHJcbldlYkNMQ29udGV4dC5wcm90b3R5cGUuZXhwID0gZnVuY3Rpb24oYSwgb3V0KSB7XHJcblx0cmV0dXJuIHVuYXJ5QXJpdGhPcChhLCBvdXQsIHRoaXMsIHRoaXMua2VybmVscy5leHApO1xyXG59O1xyXG5cclxuV2ViQ0xDb250ZXh0LnByb3RvdHlwZS5sb2cgPSBmdW5jdGlvbihhLCBvdXQpIHtcclxuXHRyZXR1cm4gdW5hcnlBcml0aE9wKGEsIG91dCwgdGhpcywgdGhpcy5rZXJuZWxzLmxvZyk7XHJcbn07XHJcblxyXG5XZWJDTENvbnRleHQucHJvdG90eXBlLnNxcnQgPSBmdW5jdGlvbihhLCBvdXQpIHtcclxuXHRyZXR1cm4gdW5hcnlBcml0aE9wKGEsIG91dCwgdGhpcywgdGhpcy5rZXJuZWxzLnNxcnQpO1xyXG59O1xyXG5cclxuV2ViQ0xDb250ZXh0LnByb3RvdHlwZS5zcXVhcmUgPSBmdW5jdGlvbihhLCBvdXQpIHtcclxuXHRyZXR1cm4gdW5hcnlBcml0aE9wKGEsIG91dCwgdGhpcywgdGhpcy5rZXJuZWxzLnNxdWFyZSk7XHJcbn07XHJcblxyXG5XZWJDTENvbnRleHQucHJvdG90eXBlLm1pbiA9IGZ1bmN0aW9uKGEsIGF4aXMsIG91dCkge1xyXG5cdHJldHVybiBheGlzUmVkdWNlT3AoYSwgYXhpcywgb3V0LCB0aGlzLCB0aGlzLmtlcm5lbHMubWluLCB0aGlzLmtlcm5lbHMuYW1pbik7XHJcbn07XHJcblxyXG5XZWJDTENvbnRleHQucHJvdG90eXBlLm1heCA9IGZ1bmN0aW9uKGEsIGF4aXMsIG91dCkge1xyXG5cdHJldHVybiBheGlzUmVkdWNlT3AoYSwgYXhpcywgb3V0LCB0aGlzLCB0aGlzLmtlcm5lbHMubWF4LCB0aGlzLmtlcm5lbHMuYW1heCk7XHJcbn07XHJcblxyXG5XZWJDTENvbnRleHQucHJvdG90eXBlLnN1bSA9IGZ1bmN0aW9uKGEsIGF4aXMsIG91dCkge1xyXG5cdHJldHVybiBheGlzUmVkdWNlT3AoYSwgYXhpcywgb3V0LCB0aGlzLCB0aGlzLmtlcm5lbHMuc3VtLCB0aGlzLmtlcm5lbHMuYXN1bSk7XHJcbn07XHJcblxyXG5XZWJDTENvbnRleHQucHJvdG90eXBlLmRvdCA9IGZ1bmN0aW9uKGEsIGIsIG91dCkge1xyXG5cdHV0aWwuY2hlY2tOREFycmF5KGEsIFwiYVwiKTtcclxuXHR1dGlsLmNoZWNrTkRBcnJheShiLCBcImJcIik7XHJcblx0dXRpbC5jaGVja0RhdGFUeXBlc0NvbXBhdGliaWxpdHkoYS5kYXRhVHlwZSwgYi5kYXRhVHlwZSk7XHJcblxyXG5cdC8qIFRoZSBheGlzIG9mIGIgdXNlZCBpbiByZWR1Y3Rpb246IGF4aXMgMCBmb3IgMUQgYXJyYXksIHNlY29uZC10by1sYXN0IGF4aXMgZm9yIE5EIGFycmF5ICovXHJcblx0dmFyIGFBeGlzID0gTWF0aC5tYXgoYS5zaGFwZS5sZW5ndGggLSAxLCAwKTtcclxuXHR2YXIgYkF4aXMgPSBNYXRoLm1heChiLnNoYXBlLmxlbmd0aCAtIDIsIDApO1xyXG5cdHZhciByZWR1Y3Rpb25EaW0gPSBhLnNoYXBlW2FBeGlzXTtcclxuXHRpZiAocmVkdWN0aW9uRGltICE9PSBiLnNoYXBlW2JBeGlzXSkge1xyXG5cdFx0dGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJBcnJheXMgaGF2ZSBpbmNvbXBhdGlibGUgcmVkdWN0aW9uIGRpbWVuc2lvbnNcIik7XHJcblx0fVxyXG5cdHZhciBzaGFwZU91dCA9IFtdLCBzdHJpZGVBID0gMSwgb3V0ZXJTdHJpZGVCID0gMSwgaW5uZXJTdHJpZGVCID0gMTtcclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGFBeGlzOyBpKyspIHtcclxuXHRcdHNoYXBlT3V0LnB1c2goYS5zaGFwZVtpXSk7XHJcblx0XHRzdHJpZGVBICo9IGEuc2hhcGVbaV07XHJcblx0fVxyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgYi5zaGFwZS5sZW5ndGg7IGkrKykge1xyXG5cdFx0dmFyIGRpbSA9IGIuc2hhcGVbaV07XHJcblx0XHRpZiAoaSA8IGJBeGlzKSB7XHJcblx0XHRcdG91dGVyU3RyaWRlQiAqPSBkaW07XHJcblx0XHRcdHNoYXBlT3V0LnB1c2goZGltKTtcclxuXHRcdH0gZWxzZSBpZiAoaSA+IGJBeGlzKSB7XHJcblx0XHRcdGlubmVyU3RyaWRlQiAqPSBkaW07XHJcblx0XHRcdHNoYXBlT3V0LnB1c2goZGltKTtcclxuXHRcdH1cclxuXHR9XHJcblx0aWYgKHR5cGVvZiBvdXQgPT09IFwidW5kZWZpbmVkXCIpIHtcclxuXHRcdG91dCA9IHRoaXMuZW1wdHkoc2hhcGVPdXQsIGEuZGF0YVR5cGUpO1xyXG5cdH0gZWxzZSBpZiAob3V0IGluc3RhbmNlb2YgTkRBcnJheSkge1xyXG5cdFx0dXRpbC5jaGVja05EQXJyYXkob3V0LCBcIm91dFwiKTtcclxuXHRcdHV0aWwuY2hlY2tTaGFwZXNDb21wYXRpYmlsaXR5KG91dC5zaGFwZSwgc2hhcGVPdXQpO1xyXG5cdFx0dXRpbC5jaGVja0RhdGFUeXBlc0NvbXBhdGliaWxpdHkob3V0LmRhdGFUeXBlLCBhLmRhdGFUeXBlKTtcclxuXHRcdHV0aWwuY2hlY2tEaWZmZXJlbnROREFycmF5cyhhLCBvdXQsIFwiYVwiLCBcIm91dFwiKTtcclxuXHRcdHV0aWwuY2hlY2tEaWZmZXJlbnROREFycmF5cyhiLCBvdXQsIFwiYlwiLCBcIm91dFwiKTtcclxuXHRcdG91dC5faW5jUmVmKCk7XHJcblx0fVxyXG5cdHZhciBrZXJuZWwgPSB0aGlzLmtlcm5lbHMuZG90W291dC5kYXRhVHlwZS50eXBlXTtcclxuXHRrZXJuZWwuc2V0QXJnKDAsIG5ldyBVaW50MzJBcnJheShbcmVkdWN0aW9uRGltXSkpO1xyXG5cdGtlcm5lbC5zZXRBcmcoMSwgYS5fYnVmZmVyKTtcclxuXHRrZXJuZWwuc2V0QXJnKDIsIGIuX2J1ZmZlcik7XHJcblx0a2VybmVsLnNldEFyZygzLCBvdXQuX2J1ZmZlcik7XHJcblx0dGhpcy5xdWV1ZS5lbnF1ZXVlTkRSYW5nZUtlcm5lbChrZXJuZWwsIDMsIG51bGwsXHJcblx0XHRbc3RyaWRlQSwgb3V0ZXJTdHJpZGVCLCBpbm5lclN0cmlkZUJdKTtcclxuXHRhLl90cnlSZWxlYXNlKCk7XHJcblx0Yi5fdHJ5UmVsZWFzZSgpO1xyXG5cdHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFdlYkNMQ29udGV4dDtcclxuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9jaGFpJyk7XG4iLCIvKiFcbiAqIGNoYWlcbiAqIENvcHlyaWdodChjKSAyMDExLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG52YXIgdXNlZCA9IFtdXG4gICwgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8qIVxuICogQ2hhaSB2ZXJzaW9uXG4gKi9cblxuZXhwb3J0cy52ZXJzaW9uID0gJzEuOS4xJztcblxuLyohXG4gKiBBc3NlcnRpb24gRXJyb3JcbiAqL1xuXG5leHBvcnRzLkFzc2VydGlvbkVycm9yID0gcmVxdWlyZSgnYXNzZXJ0aW9uLWVycm9yJyk7XG5cbi8qIVxuICogVXRpbHMgZm9yIHBsdWdpbnMgKG5vdCBleHBvcnRlZClcbiAqL1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vY2hhaS91dGlscycpO1xuXG4vKipcbiAqICMgLnVzZShmdW5jdGlvbilcbiAqXG4gKiBQcm92aWRlcyBhIHdheSB0byBleHRlbmQgdGhlIGludGVybmFscyBvZiBDaGFpXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn1cbiAqIEByZXR1cm5zIHt0aGlzfSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy51c2UgPSBmdW5jdGlvbiAoZm4pIHtcbiAgaWYgKCF+dXNlZC5pbmRleE9mKGZuKSkge1xuICAgIGZuKHRoaXMsIHV0aWwpO1xuICAgIHVzZWQucHVzaChmbik7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qIVxuICogQ29uZmlndXJhdGlvblxuICovXG5cbnZhciBjb25maWcgPSByZXF1aXJlKCcuL2NoYWkvY29uZmlnJyk7XG5leHBvcnRzLmNvbmZpZyA9IGNvbmZpZztcblxuLyohXG4gKiBQcmltYXJ5IGBBc3NlcnRpb25gIHByb3RvdHlwZVxuICovXG5cbnZhciBhc3NlcnRpb24gPSByZXF1aXJlKCcuL2NoYWkvYXNzZXJ0aW9uJyk7XG5leHBvcnRzLnVzZShhc3NlcnRpb24pO1xuXG4vKiFcbiAqIENvcmUgQXNzZXJ0aW9uc1xuICovXG5cbnZhciBjb3JlID0gcmVxdWlyZSgnLi9jaGFpL2NvcmUvYXNzZXJ0aW9ucycpO1xuZXhwb3J0cy51c2UoY29yZSk7XG5cbi8qIVxuICogRXhwZWN0IGludGVyZmFjZVxuICovXG5cbnZhciBleHBlY3QgPSByZXF1aXJlKCcuL2NoYWkvaW50ZXJmYWNlL2V4cGVjdCcpO1xuZXhwb3J0cy51c2UoZXhwZWN0KTtcblxuLyohXG4gKiBTaG91bGQgaW50ZXJmYWNlXG4gKi9cblxudmFyIHNob3VsZCA9IHJlcXVpcmUoJy4vY2hhaS9pbnRlcmZhY2Uvc2hvdWxkJyk7XG5leHBvcnRzLnVzZShzaG91bGQpO1xuXG4vKiFcbiAqIEFzc2VydCBpbnRlcmZhY2VcbiAqL1xuXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnLi9jaGFpL2ludGVyZmFjZS9hc3NlcnQnKTtcbmV4cG9ydHMudXNlKGFzc2VydCk7XG4iLCIvKiFcbiAqIGNoYWlcbiAqIGh0dHA6Ly9jaGFpanMuY29tXG4gKiBDb3B5cmlnaHQoYykgMjAxMS0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxudmFyIGNvbmZpZyA9IHJlcXVpcmUoJy4vY29uZmlnJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKF9jaGFpLCB1dGlsKSB7XG4gIC8qIVxuICAgKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICAgKi9cblxuICB2YXIgQXNzZXJ0aW9uRXJyb3IgPSBfY2hhaS5Bc3NlcnRpb25FcnJvclxuICAgICwgZmxhZyA9IHV0aWwuZmxhZztcblxuICAvKiFcbiAgICogTW9kdWxlIGV4cG9ydC5cbiAgICovXG5cbiAgX2NoYWkuQXNzZXJ0aW9uID0gQXNzZXJ0aW9uO1xuXG4gIC8qIVxuICAgKiBBc3NlcnRpb24gQ29uc3RydWN0b3JcbiAgICpcbiAgICogQ3JlYXRlcyBvYmplY3QgZm9yIGNoYWluaW5nLlxuICAgKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG5cbiAgZnVuY3Rpb24gQXNzZXJ0aW9uIChvYmosIG1zZywgc3RhY2spIHtcbiAgICBmbGFnKHRoaXMsICdzc2ZpJywgc3RhY2sgfHwgYXJndW1lbnRzLmNhbGxlZSk7XG4gICAgZmxhZyh0aGlzLCAnb2JqZWN0Jywgb2JqKTtcbiAgICBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgfVxuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBc3NlcnRpb24sICdpbmNsdWRlU3RhY2snLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnNvbGUud2FybignQXNzZXJ0aW9uLmluY2x1ZGVTdGFjayBpcyBkZXByZWNhdGVkLCB1c2UgY2hhaS5jb25maWcuaW5jbHVkZVN0YWNrIGluc3RlYWQuJyk7XG4gICAgICByZXR1cm4gY29uZmlnLmluY2x1ZGVTdGFjaztcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIGNvbnNvbGUud2FybignQXNzZXJ0aW9uLmluY2x1ZGVTdGFjayBpcyBkZXByZWNhdGVkLCB1c2UgY2hhaS5jb25maWcuaW5jbHVkZVN0YWNrIGluc3RlYWQuJyk7XG4gICAgICBjb25maWcuaW5jbHVkZVN0YWNrID0gdmFsdWU7XG4gICAgfVxuICB9KTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQXNzZXJ0aW9uLCAnc2hvd0RpZmYnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnNvbGUud2FybignQXNzZXJ0aW9uLnNob3dEaWZmIGlzIGRlcHJlY2F0ZWQsIHVzZSBjaGFpLmNvbmZpZy5zaG93RGlmZiBpbnN0ZWFkLicpO1xuICAgICAgcmV0dXJuIGNvbmZpZy5zaG93RGlmZjtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIGNvbnNvbGUud2FybignQXNzZXJ0aW9uLnNob3dEaWZmIGlzIGRlcHJlY2F0ZWQsIHVzZSBjaGFpLmNvbmZpZy5zaG93RGlmZiBpbnN0ZWFkLicpO1xuICAgICAgY29uZmlnLnNob3dEaWZmID0gdmFsdWU7XG4gICAgfVxuICB9KTtcblxuICBBc3NlcnRpb24uYWRkUHJvcGVydHkgPSBmdW5jdGlvbiAobmFtZSwgZm4pIHtcbiAgICB1dGlsLmFkZFByb3BlcnR5KHRoaXMucHJvdG90eXBlLCBuYW1lLCBmbik7XG4gIH07XG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCA9IGZ1bmN0aW9uIChuYW1lLCBmbikge1xuICAgIHV0aWwuYWRkTWV0aG9kKHRoaXMucHJvdG90eXBlLCBuYW1lLCBmbik7XG4gIH07XG5cbiAgQXNzZXJ0aW9uLmFkZENoYWluYWJsZU1ldGhvZCA9IGZ1bmN0aW9uIChuYW1lLCBmbiwgY2hhaW5pbmdCZWhhdmlvcikge1xuICAgIHV0aWwuYWRkQ2hhaW5hYmxlTWV0aG9kKHRoaXMucHJvdG90eXBlLCBuYW1lLCBmbiwgY2hhaW5pbmdCZWhhdmlvcik7XG4gIH07XG5cbiAgQXNzZXJ0aW9uLm92ZXJ3cml0ZVByb3BlcnR5ID0gZnVuY3Rpb24gKG5hbWUsIGZuKSB7XG4gICAgdXRpbC5vdmVyd3JpdGVQcm9wZXJ0eSh0aGlzLnByb3RvdHlwZSwgbmFtZSwgZm4pO1xuICB9O1xuXG4gIEFzc2VydGlvbi5vdmVyd3JpdGVNZXRob2QgPSBmdW5jdGlvbiAobmFtZSwgZm4pIHtcbiAgICB1dGlsLm92ZXJ3cml0ZU1ldGhvZCh0aGlzLnByb3RvdHlwZSwgbmFtZSwgZm4pO1xuICB9O1xuXG4gIEFzc2VydGlvbi5vdmVyd3JpdGVDaGFpbmFibGVNZXRob2QgPSBmdW5jdGlvbiAobmFtZSwgZm4sIGNoYWluaW5nQmVoYXZpb3IpIHtcbiAgICB1dGlsLm92ZXJ3cml0ZUNoYWluYWJsZU1ldGhvZCh0aGlzLnByb3RvdHlwZSwgbmFtZSwgZm4sIGNoYWluaW5nQmVoYXZpb3IpO1xuICB9O1xuXG4gIC8qIVxuICAgKiAjIyMgLmFzc2VydChleHByZXNzaW9uLCBtZXNzYWdlLCBuZWdhdGVNZXNzYWdlLCBleHBlY3RlZCwgYWN0dWFsKVxuICAgKlxuICAgKiBFeGVjdXRlcyBhbiBleHByZXNzaW9uIGFuZCBjaGVjayBleHBlY3RhdGlvbnMuIFRocm93cyBBc3NlcnRpb25FcnJvciBmb3IgcmVwb3J0aW5nIGlmIHRlc3QgZG9lc24ndCBwYXNzLlxuICAgKlxuICAgKiBAbmFtZSBhc3NlcnRcbiAgICogQHBhcmFtIHtQaGlsb3NvcGhpY2FsfSBleHByZXNzaW9uIHRvIGJlIHRlc3RlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSB0byBkaXNwbGF5IGlmIGZhaWxzXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuZWdhdGVkTWVzc2FnZSB0byBkaXNwbGF5IGlmIG5lZ2F0ZWQgZXhwcmVzc2lvbiBmYWlsc1xuICAgKiBAcGFyYW0ge01peGVkfSBleHBlY3RlZCB2YWx1ZSAocmVtZW1iZXIgdG8gY2hlY2sgZm9yIG5lZ2F0aW9uKVxuICAgKiBAcGFyYW0ge01peGVkfSBhY3R1YWwgKG9wdGlvbmFsKSB3aWxsIGRlZmF1bHQgdG8gYHRoaXMub2JqYFxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG5cbiAgQXNzZXJ0aW9uLnByb3RvdHlwZS5hc3NlcnQgPSBmdW5jdGlvbiAoZXhwciwgbXNnLCBuZWdhdGVNc2csIGV4cGVjdGVkLCBfYWN0dWFsLCBzaG93RGlmZikge1xuICAgIHZhciBvayA9IHV0aWwudGVzdCh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmICh0cnVlICE9PSBzaG93RGlmZikgc2hvd0RpZmYgPSBmYWxzZTtcbiAgICBpZiAodHJ1ZSAhPT0gY29uZmlnLnNob3dEaWZmKSBzaG93RGlmZiA9IGZhbHNlO1xuXG4gICAgaWYgKCFvaykge1xuICAgICAgdmFyIG1zZyA9IHV0aWwuZ2V0TWVzc2FnZSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICAgICwgYWN0dWFsID0gdXRpbC5nZXRBY3R1YWwodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHRocm93IG5ldyBBc3NlcnRpb25FcnJvcihtc2csIHtcbiAgICAgICAgICBhY3R1YWw6IGFjdHVhbFxuICAgICAgICAsIGV4cGVjdGVkOiBleHBlY3RlZFxuICAgICAgICAsIHNob3dEaWZmOiBzaG93RGlmZlxuICAgICAgfSwgKGNvbmZpZy5pbmNsdWRlU3RhY2spID8gdGhpcy5hc3NlcnQgOiBmbGFnKHRoaXMsICdzc2ZpJykpO1xuICAgIH1cbiAgfTtcblxuICAvKiFcbiAgICogIyMjIC5fb2JqXG4gICAqXG4gICAqIFF1aWNrIHJlZmVyZW5jZSB0byBzdG9yZWQgYGFjdHVhbGAgdmFsdWUgZm9yIHBsdWdpbiBkZXZlbG9wZXJzLlxuICAgKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFzc2VydGlvbi5wcm90b3R5cGUsICdfb2JqJyxcbiAgICB7IGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZmxhZyh0aGlzLCAnb2JqZWN0Jyk7XG4gICAgICB9XG4gICAgLCBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgZmxhZyh0aGlzLCAnb2JqZWN0JywgdmFsKTtcbiAgICAgIH1cbiAgfSk7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgLyoqXG4gICAqICMjIyBjb25maWcuaW5jbHVkZVN0YWNrXG4gICAqXG4gICAqIFVzZXIgY29uZmlndXJhYmxlIHByb3BlcnR5LCBpbmZsdWVuY2VzIHdoZXRoZXIgc3RhY2sgdHJhY2VcbiAgICogaXMgaW5jbHVkZWQgaW4gQXNzZXJ0aW9uIGVycm9yIG1lc3NhZ2UuIERlZmF1bHQgb2YgZmFsc2VcbiAgICogc3VwcHJlc3NlcyBzdGFjayB0cmFjZSBpbiB0aGUgZXJyb3IgbWVzc2FnZS5cbiAgICpcbiAgICogICAgIGNoYWkuY29uZmlnLmluY2x1ZGVTdGFjayA9IHRydWU7ICAvLyBlbmFibGUgc3RhY2sgb24gZXJyb3JcbiAgICpcbiAgICogQHBhcmFtIHtCb29sZWFufVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICAgaW5jbHVkZVN0YWNrOiBmYWxzZSxcblxuICAvKipcbiAgICogIyMjIGNvbmZpZy5zaG93RGlmZlxuICAgKlxuICAgKiBVc2VyIGNvbmZpZ3VyYWJsZSBwcm9wZXJ0eSwgaW5mbHVlbmNlcyB3aGV0aGVyIG9yIG5vdFxuICAgKiB0aGUgYHNob3dEaWZmYCBmbGFnIHNob3VsZCBiZSBpbmNsdWRlZCBpbiB0aGUgdGhyb3duXG4gICAqIEFzc2VydGlvbkVycm9ycy4gYGZhbHNlYCB3aWxsIGFsd2F5cyBiZSBgZmFsc2VgOyBgdHJ1ZWBcbiAgICogd2lsbCBiZSB0cnVlIHdoZW4gdGhlIGFzc2VydGlvbiBoYXMgcmVxdWVzdGVkIGEgZGlmZlxuICAgKiBiZSBzaG93bi5cbiAgICpcbiAgICogQHBhcmFtIHtCb29sZWFufVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBzaG93RGlmZjogdHJ1ZSxcblxuICAvKipcbiAgICogIyMjIGNvbmZpZy50cnVuY2F0ZVRocmVzaG9sZFxuICAgKlxuICAgKiBVc2VyIGNvbmZpZ3VyYWJsZSBwcm9wZXJ0eSwgc2V0cyBsZW5ndGggdGhyZXNob2xkIGZvciBhY3R1YWwgYW5kXG4gICAqIGV4cGVjdGVkIHZhbHVlcyBpbiBhc3NlcnRpb24gZXJyb3JzLiBJZiB0aGlzIHRocmVzaG9sZCBpcyBleGNlZWRlZCxcbiAgICogdGhlIHZhbHVlIGlzIHRydW5jYXRlZC5cbiAgICpcbiAgICogU2V0IGl0IHRvIHplcm8gaWYgeW91IHdhbnQgdG8gZGlzYWJsZSB0cnVuY2F0aW5nIGFsdG9nZXRoZXIuXG4gICAqXG4gICAqICAgICBjaGFpLmNvbmZpZy50cnVuY2F0ZVRocmVzaG9sZCA9IDA7ICAvLyBkaXNhYmxlIHRydW5jYXRpbmdcbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIHRydW5jYXRlVGhyZXNob2xkOiA0MFxuXG59O1xuIiwiLyohXG4gKiBjaGFpXG4gKiBodHRwOi8vY2hhaWpzLmNvbVxuICogQ29weXJpZ2h0KGMpIDIwMTEtMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNoYWksIF8pIHtcbiAgdmFyIEFzc2VydGlvbiA9IGNoYWkuQXNzZXJ0aW9uXG4gICAgLCB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdcbiAgICAsIGZsYWcgPSBfLmZsYWc7XG5cbiAgLyoqXG4gICAqICMjIyBMYW5ndWFnZSBDaGFpbnNcbiAgICpcbiAgICogVGhlIGZvbGxvd2luZyBhcmUgcHJvdmlkZWQgYXMgY2hhaW5hYmxlIGdldHRlcnMgdG9cbiAgICogaW1wcm92ZSB0aGUgcmVhZGFiaWxpdHkgb2YgeW91ciBhc3NlcnRpb25zLiBUaGV5XG4gICAqIGRvIG5vdCBwcm92aWRlIHRlc3RpbmcgY2FwYWJpbGl0aWVzIHVubGVzcyB0aGV5XG4gICAqIGhhdmUgYmVlbiBvdmVyd3JpdHRlbiBieSBhIHBsdWdpbi5cbiAgICpcbiAgICogKipDaGFpbnMqKlxuICAgKlxuICAgKiAtIHRvXG4gICAqIC0gYmVcbiAgICogLSBiZWVuXG4gICAqIC0gaXNcbiAgICogLSB0aGF0XG4gICAqIC0gYW5kXG4gICAqIC0gaGFzXG4gICAqIC0gaGF2ZVxuICAgKiAtIHdpdGhcbiAgICogLSBhdFxuICAgKiAtIG9mXG4gICAqIC0gc2FtZVxuICAgKlxuICAgKiBAbmFtZSBsYW5ndWFnZSBjaGFpbnNcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgWyAndG8nLCAnYmUnLCAnYmVlbidcbiAgLCAnaXMnLCAnYW5kJywgJ2hhcycsICdoYXZlJ1xuICAsICd3aXRoJywgJ3RoYXQnLCAnYXQnXG4gICwgJ29mJywgJ3NhbWUnIF0uZm9yRWFjaChmdW5jdGlvbiAoY2hhaW4pIHtcbiAgICBBc3NlcnRpb24uYWRkUHJvcGVydHkoY2hhaW4sIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0pO1xuICB9KTtcblxuICAvKipcbiAgICogIyMjIC5ub3RcbiAgICpcbiAgICogTmVnYXRlcyBhbnkgb2YgYXNzZXJ0aW9ucyBmb2xsb3dpbmcgaW4gdGhlIGNoYWluLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KGZvbykudG8ubm90LmVxdWFsKCdiYXInKTtcbiAgICogICAgIGV4cGVjdChnb29kRm4pLnRvLm5vdC50aHJvdyhFcnJvcik7XG4gICAqICAgICBleHBlY3QoeyBmb286ICdiYXonIH0pLnRvLmhhdmUucHJvcGVydHkoJ2ZvbycpXG4gICAqICAgICAgIC5hbmQubm90LmVxdWFsKCdiYXInKTtcbiAgICpcbiAgICogQG5hbWUgbm90XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEFzc2VydGlvbi5hZGRQcm9wZXJ0eSgnbm90JywgZnVuY3Rpb24gKCkge1xuICAgIGZsYWcodGhpcywgJ25lZ2F0ZScsIHRydWUpO1xuICB9KTtcblxuICAvKipcbiAgICogIyMjIC5kZWVwXG4gICAqXG4gICAqIFNldHMgdGhlIGBkZWVwYCBmbGFnLCBsYXRlciB1c2VkIGJ5IHRoZSBgZXF1YWxgIGFuZFxuICAgKiBgcHJvcGVydHlgIGFzc2VydGlvbnMuXG4gICAqXG4gICAqICAgICBleHBlY3QoZm9vKS50by5kZWVwLmVxdWFsKHsgYmFyOiAnYmF6JyB9KTtcbiAgICogICAgIGV4cGVjdCh7IGZvbzogeyBiYXI6IHsgYmF6OiAncXV1eCcgfSB9IH0pXG4gICAqICAgICAgIC50by5oYXZlLmRlZXAucHJvcGVydHkoJ2Zvby5iYXIuYmF6JywgJ3F1dXgnKTtcbiAgICpcbiAgICogQG5hbWUgZGVlcFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkUHJvcGVydHkoJ2RlZXAnLCBmdW5jdGlvbiAoKSB7XG4gICAgZmxhZyh0aGlzLCAnZGVlcCcsIHRydWUpO1xuICB9KTtcblxuICAvKipcbiAgICogIyMjIC5hKHR5cGUpXG4gICAqXG4gICAqIFRoZSBgYWAgYW5kIGBhbmAgYXNzZXJ0aW9ucyBhcmUgYWxpYXNlcyB0aGF0IGNhbiBiZVxuICAgKiB1c2VkIGVpdGhlciBhcyBsYW5ndWFnZSBjaGFpbnMgb3IgdG8gYXNzZXJ0IGEgdmFsdWUnc1xuICAgKiB0eXBlLlxuICAgKlxuICAgKiAgICAgLy8gdHlwZW9mXG4gICAqICAgICBleHBlY3QoJ3Rlc3QnKS50by5iZS5hKCdzdHJpbmcnKTtcbiAgICogICAgIGV4cGVjdCh7IGZvbzogJ2JhcicgfSkudG8uYmUuYW4oJ29iamVjdCcpO1xuICAgKiAgICAgZXhwZWN0KG51bGwpLnRvLmJlLmEoJ251bGwnKTtcbiAgICogICAgIGV4cGVjdCh1bmRlZmluZWQpLnRvLmJlLmFuKCd1bmRlZmluZWQnKTtcbiAgICpcbiAgICogICAgIC8vIGxhbmd1YWdlIGNoYWluXG4gICAqICAgICBleHBlY3QoZm9vKS50by5iZS5hbi5pbnN0YW5jZW9mKEZvbyk7XG4gICAqXG4gICAqIEBuYW1lIGFcbiAgICogQGFsaWFzIGFuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gYW4gKHR5cGUsIG1zZykge1xuICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuICAgIHR5cGUgPSB0eXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgICAsIGFydGljbGUgPSB+WyAnYScsICdlJywgJ2knLCAnbycsICd1JyBdLmluZGV4T2YodHlwZS5jaGFyQXQoMCkpID8gJ2FuICcgOiAnYSAnO1xuXG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIHR5cGUgPT09IF8udHlwZShvYmopXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlICcgKyBhcnRpY2xlICsgdHlwZVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSBub3QgdG8gYmUgJyArIGFydGljbGUgKyB0eXBlXG4gICAgKTtcbiAgfVxuXG4gIEFzc2VydGlvbi5hZGRDaGFpbmFibGVNZXRob2QoJ2FuJywgYW4pO1xuICBBc3NlcnRpb24uYWRkQ2hhaW5hYmxlTWV0aG9kKCdhJywgYW4pO1xuXG4gIC8qKlxuICAgKiAjIyMgLmluY2x1ZGUodmFsdWUpXG4gICAqXG4gICAqIFRoZSBgaW5jbHVkZWAgYW5kIGBjb250YWluYCBhc3NlcnRpb25zIGNhbiBiZSB1c2VkIGFzIGVpdGhlciBwcm9wZXJ0eVxuICAgKiBiYXNlZCBsYW5ndWFnZSBjaGFpbnMgb3IgYXMgbWV0aG9kcyB0byBhc3NlcnQgdGhlIGluY2x1c2lvbiBvZiBhbiBvYmplY3RcbiAgICogaW4gYW4gYXJyYXkgb3IgYSBzdWJzdHJpbmcgaW4gYSBzdHJpbmcuIFdoZW4gdXNlZCBhcyBsYW5ndWFnZSBjaGFpbnMsXG4gICAqIHRoZXkgdG9nZ2xlIHRoZSBgY29udGFpbmAgZmxhZyBmb3IgdGhlIGBrZXlzYCBhc3NlcnRpb24uXG4gICAqXG4gICAqICAgICBleHBlY3QoWzEsMiwzXSkudG8uaW5jbHVkZSgyKTtcbiAgICogICAgIGV4cGVjdCgnZm9vYmFyJykudG8uY29udGFpbignZm9vJyk7XG4gICAqICAgICBleHBlY3QoeyBmb286ICdiYXInLCBoZWxsbzogJ3VuaXZlcnNlJyB9KS50by5pbmNsdWRlLmtleXMoJ2ZvbycpO1xuICAgKlxuICAgKiBAbmFtZSBpbmNsdWRlXG4gICAqIEBhbGlhcyBjb250YWluXG4gICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ3xOdW1iZXJ9IG9ialxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGluY2x1ZGVDaGFpbmluZ0JlaGF2aW9yICgpIHtcbiAgICBmbGFnKHRoaXMsICdjb250YWlucycsIHRydWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5jbHVkZSAodmFsLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0Jyk7XG4gICAgdmFyIGV4cGVjdGVkID0gZmFsc2U7XG4gICAgaWYgKF8udHlwZShvYmopID09PSAnYXJyYXknICYmIF8udHlwZSh2YWwpID09PSAnb2JqZWN0Jykge1xuICAgICAgZm9yICh2YXIgaSBpbiBvYmopIHtcbiAgICAgICAgaWYgKF8uZXFsKG9ialtpXSwgdmFsKSkge1xuICAgICAgICAgIGV4cGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoXy50eXBlKHZhbCkgPT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAoIWZsYWcodGhpcywgJ25lZ2F0ZScpKSB7XG4gICAgICAgIGZvciAodmFyIGsgaW4gdmFsKSBuZXcgQXNzZXJ0aW9uKG9iaikucHJvcGVydHkoaywgdmFsW2tdKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHN1YnNldCA9IHt9XG4gICAgICBmb3IgKHZhciBrIGluIHZhbCkgc3Vic2V0W2tdID0gb2JqW2tdXG4gICAgICBleHBlY3RlZCA9IF8uZXFsKHN1YnNldCwgdmFsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhwZWN0ZWQgPSBvYmogJiYgfm9iai5pbmRleE9mKHZhbClcbiAgICB9XG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIGV4cGVjdGVkXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGluY2x1ZGUgJyArIF8uaW5zcGVjdCh2YWwpXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBpbmNsdWRlICcgKyBfLmluc3BlY3QodmFsKSk7XG4gIH1cblxuICBBc3NlcnRpb24uYWRkQ2hhaW5hYmxlTWV0aG9kKCdpbmNsdWRlJywgaW5jbHVkZSwgaW5jbHVkZUNoYWluaW5nQmVoYXZpb3IpO1xuICBBc3NlcnRpb24uYWRkQ2hhaW5hYmxlTWV0aG9kKCdjb250YWluJywgaW5jbHVkZSwgaW5jbHVkZUNoYWluaW5nQmVoYXZpb3IpO1xuXG4gIC8qKlxuICAgKiAjIyMgLm9rXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIHRydXRoeS5cbiAgICpcbiAgICogICAgIGV4cGVjdCgnZXZlcnRoaW5nJykudG8uYmUub2s7XG4gICAqICAgICBleHBlY3QoMSkudG8uYmUub2s7XG4gICAqICAgICBleHBlY3QoZmFsc2UpLnRvLm5vdC5iZS5vaztcbiAgICogICAgIGV4cGVjdCh1bmRlZmluZWQpLnRvLm5vdC5iZS5vaztcbiAgICogICAgIGV4cGVjdChudWxsKS50by5ub3QuYmUub2s7XG4gICAqXG4gICAqIEBuYW1lIG9rXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEFzc2VydGlvbi5hZGRQcm9wZXJ0eSgnb2snLCBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIHRydXRoeSdcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgZmFsc3knKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqICMjIyAudHJ1ZVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyBgdHJ1ZWAuXG4gICAqXG4gICAqICAgICBleHBlY3QodHJ1ZSkudG8uYmUudHJ1ZTtcbiAgICogICAgIGV4cGVjdCgxKS50by5ub3QuYmUudHJ1ZTtcbiAgICpcbiAgICogQG5hbWUgdHJ1ZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkUHJvcGVydHkoJ3RydWUnLCBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIHRydWUgPT09IGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIHRydWUnXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIGZhbHNlJ1xuICAgICAgLCB0aGlzLm5lZ2F0ZSA/IGZhbHNlIDogdHJ1ZVxuICAgICk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiAjIyMgLmZhbHNlXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIGBmYWxzZWAuXG4gICAqXG4gICAqICAgICBleHBlY3QoZmFsc2UpLnRvLmJlLmZhbHNlO1xuICAgKiAgICAgZXhwZWN0KDApLnRvLm5vdC5iZS5mYWxzZTtcbiAgICpcbiAgICogQG5hbWUgZmFsc2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQXNzZXJ0aW9uLmFkZFByb3BlcnR5KCdmYWxzZScsIGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgZmFsc2UgPT09IGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIGZhbHNlJ1xuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSB0cnVlJ1xuICAgICAgLCB0aGlzLm5lZ2F0ZSA/IHRydWUgOiBmYWxzZVxuICAgICk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiAjIyMgLm51bGxcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaXMgYG51bGxgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KG51bGwpLnRvLmJlLm51bGw7XG4gICAqICAgICBleHBlY3QodW5kZWZpbmVkKS5ub3QudG8uYmUubnVsbDtcbiAgICpcbiAgICogQG5hbWUgbnVsbFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkUHJvcGVydHkoJ251bGwnLCBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIG51bGwgPT09IGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIG51bGwnXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IG5vdCB0byBiZSBudWxsJ1xuICAgICk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiAjIyMgLnVuZGVmaW5lZFxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyBgdW5kZWZpbmVkYC5cbiAgICpcbiAgICogICAgIGV4cGVjdCh1bmRlZmluZWQpLnRvLmJlLnVuZGVmaW5lZDtcbiAgICogICAgIGV4cGVjdChudWxsKS50by5ub3QuYmUudW5kZWZpbmVkO1xuICAgKlxuICAgKiBAbmFtZSB1bmRlZmluZWRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQXNzZXJ0aW9uLmFkZFByb3BlcnR5KCd1bmRlZmluZWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIHVuZGVmaW5lZCA9PT0gZmxhZyh0aGlzLCAnb2JqZWN0JylcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgdW5kZWZpbmVkJ1xuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSBub3QgdG8gYmUgdW5kZWZpbmVkJ1xuICAgICk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiAjIyMgLmV4aXN0XG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIG5laXRoZXIgYG51bGxgIG5vciBgdW5kZWZpbmVkYC5cbiAgICpcbiAgICogICAgIHZhciBmb28gPSAnaGknXG4gICAqICAgICAgICwgYmFyID0gbnVsbFxuICAgKiAgICAgICAsIGJhejtcbiAgICpcbiAgICogICAgIGV4cGVjdChmb28pLnRvLmV4aXN0O1xuICAgKiAgICAgZXhwZWN0KGJhcikudG8ubm90LmV4aXN0O1xuICAgKiAgICAgZXhwZWN0KGJheikudG8ubm90LmV4aXN0O1xuICAgKlxuICAgKiBAbmFtZSBleGlzdFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkUHJvcGVydHkoJ2V4aXN0JywgZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICBudWxsICE9IGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGV4aXN0J1xuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgZXhpc3QnXG4gICAgKTtcbiAgfSk7XG5cblxuICAvKipcbiAgICogIyMjIC5lbXB0eVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCdzIGxlbmd0aCBpcyBgMGAuIEZvciBhcnJheXMsIGl0IGNoZWNrc1xuICAgKiB0aGUgYGxlbmd0aGAgcHJvcGVydHkuIEZvciBvYmplY3RzLCBpdCBnZXRzIHRoZSBjb3VudCBvZlxuICAgKiBlbnVtZXJhYmxlIGtleXMuXG4gICAqXG4gICAqICAgICBleHBlY3QoW10pLnRvLmJlLmVtcHR5O1xuICAgKiAgICAgZXhwZWN0KCcnKS50by5iZS5lbXB0eTtcbiAgICogICAgIGV4cGVjdCh7fSkudG8uYmUuZW1wdHk7XG4gICAqXG4gICAqIEBuYW1lIGVtcHR5XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEFzc2VydGlvbi5hZGRQcm9wZXJ0eSgnZW1wdHknLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgICAsIGV4cGVjdGVkID0gb2JqO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSB8fCAnc3RyaW5nJyA9PT0gdHlwZW9mIG9iamVjdCkge1xuICAgICAgZXhwZWN0ZWQgPSBvYmoubGVuZ3RoO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGV4cGVjdGVkID0gT2JqZWN0LmtleXMob2JqKS5sZW5ndGg7XG4gICAgfVxuXG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICFleHBlY3RlZFxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSBlbXB0eSdcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gbm90IHRvIGJlIGVtcHR5J1xuICAgICk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiAjIyMgLmFyZ3VtZW50c1xuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyBhbiBhcmd1bWVudHMgb2JqZWN0LlxuICAgKlxuICAgKiAgICAgZnVuY3Rpb24gdGVzdCAoKSB7XG4gICAqICAgICAgIGV4cGVjdChhcmd1bWVudHMpLnRvLmJlLmFyZ3VtZW50cztcbiAgICogICAgIH1cbiAgICpcbiAgICogQG5hbWUgYXJndW1lbnRzXG4gICAqIEBhbGlhcyBBcmd1bWVudHNcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gY2hlY2tBcmd1bWVudHMgKCkge1xuICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKVxuICAgICAgLCB0eXBlID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaik7XG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICdbb2JqZWN0IEFyZ3VtZW50c10nID09PSB0eXBlXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIGFyZ3VtZW50cyBidXQgZ290ICcgKyB0eXBlXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBiZSBhcmd1bWVudHMnXG4gICAgKTtcbiAgfVxuXG4gIEFzc2VydGlvbi5hZGRQcm9wZXJ0eSgnYXJndW1lbnRzJywgY2hlY2tBcmd1bWVudHMpO1xuICBBc3NlcnRpb24uYWRkUHJvcGVydHkoJ0FyZ3VtZW50cycsIGNoZWNrQXJndW1lbnRzKTtcblxuICAvKipcbiAgICogIyMjIC5lcXVhbCh2YWx1ZSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaXMgc3RyaWN0bHkgZXF1YWwgKGA9PT1gKSB0byBgdmFsdWVgLlxuICAgKiBBbHRlcm5hdGVseSwgaWYgdGhlIGBkZWVwYCBmbGFnIGlzIHNldCwgYXNzZXJ0cyB0aGF0XG4gICAqIHRoZSB0YXJnZXQgaXMgZGVlcGx5IGVxdWFsIHRvIGB2YWx1ZWAuXG4gICAqXG4gICAqICAgICBleHBlY3QoJ2hlbGxvJykudG8uZXF1YWwoJ2hlbGxvJyk7XG4gICAqICAgICBleHBlY3QoNDIpLnRvLmVxdWFsKDQyKTtcbiAgICogICAgIGV4cGVjdCgxKS50by5ub3QuZXF1YWwodHJ1ZSk7XG4gICAqICAgICBleHBlY3QoeyBmb286ICdiYXInIH0pLnRvLm5vdC5lcXVhbCh7IGZvbzogJ2JhcicgfSk7XG4gICAqICAgICBleHBlY3QoeyBmb286ICdiYXInIH0pLnRvLmRlZXAuZXF1YWwoeyBmb286ICdiYXInIH0pO1xuICAgKlxuICAgKiBAbmFtZSBlcXVhbFxuICAgKiBAYWxpYXMgZXF1YWxzXG4gICAqIEBhbGlhcyBlcVxuICAgKiBAYWxpYXMgZGVlcC5lcXVhbFxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGFzc2VydEVxdWFsICh2YWwsIG1zZykge1xuICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKTtcbiAgICBpZiAoZmxhZyh0aGlzLCAnZGVlcCcpKSB7XG4gICAgICByZXR1cm4gdGhpcy5lcWwodmFsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICAgdmFsID09PSBvYmpcbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBlcXVhbCAje2V4cH0nXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGVxdWFsICN7ZXhwfSdcbiAgICAgICAgLCB2YWxcbiAgICAgICAgLCB0aGlzLl9vYmpcbiAgICAgICAgLCB0cnVlXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2VxdWFsJywgYXNzZXJ0RXF1YWwpO1xuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdlcXVhbHMnLCBhc3NlcnRFcXVhbCk7XG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2VxJywgYXNzZXJ0RXF1YWwpO1xuXG4gIC8qKlxuICAgKiAjIyMgLmVxbCh2YWx1ZSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaXMgZGVlcGx5IGVxdWFsIHRvIGB2YWx1ZWAuXG4gICAqXG4gICAqICAgICBleHBlY3QoeyBmb286ICdiYXInIH0pLnRvLmVxbCh7IGZvbzogJ2JhcicgfSk7XG4gICAqICAgICBleHBlY3QoWyAxLCAyLCAzIF0pLnRvLmVxbChbIDEsIDIsIDMgXSk7XG4gICAqXG4gICAqIEBuYW1lIGVxbFxuICAgKiBAYWxpYXMgZXFsc1xuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGFzc2VydEVxbChvYmosIG1zZykge1xuICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICBfLmVxbChvYmosIGZsYWcodGhpcywgJ29iamVjdCcpKVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBkZWVwbHkgZXF1YWwgI3tleHB9J1xuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgZGVlcGx5IGVxdWFsICN7ZXhwfSdcbiAgICAgICwgb2JqXG4gICAgICAsIHRoaXMuX29ialxuICAgICAgLCB0cnVlXG4gICAgKTtcbiAgfVxuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2VxbCcsIGFzc2VydEVxbCk7XG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2VxbHMnLCBhc3NlcnRFcWwpO1xuXG4gIC8qKlxuICAgKiAjIyMgLmFib3ZlKHZhbHVlKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyBncmVhdGVyIHRoYW4gYHZhbHVlYC5cbiAgICpcbiAgICogICAgIGV4cGVjdCgxMCkudG8uYmUuYWJvdmUoNSk7XG4gICAqXG4gICAqIENhbiBhbHNvIGJlIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCBgbGVuZ3RoYCB0b1xuICAgKiBhc3NlcnQgYSBtaW5pbXVtIGxlbmd0aC4gVGhlIGJlbmVmaXQgYmVpbmcgYVxuICAgKiBtb3JlIGluZm9ybWF0aXZlIGVycm9yIG1lc3NhZ2UgdGhhbiBpZiB0aGUgbGVuZ3RoXG4gICAqIHdhcyBzdXBwbGllZCBkaXJlY3RseS5cbiAgICpcbiAgICogICAgIGV4cGVjdCgnZm9vJykudG8uaGF2ZS5sZW5ndGguYWJvdmUoMik7XG4gICAqICAgICBleHBlY3QoWyAxLCAyLCAzIF0pLnRvLmhhdmUubGVuZ3RoLmFib3ZlKDIpO1xuICAgKlxuICAgKiBAbmFtZSBhYm92ZVxuICAgKiBAYWxpYXMgZ3RcbiAgICogQGFsaWFzIGdyZWF0ZXJUaGFuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGFzc2VydEFib3ZlIChuLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0Jyk7XG4gICAgaWYgKGZsYWcodGhpcywgJ2RvTGVuZ3RoJykpIHtcbiAgICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2cpLnRvLmhhdmUucHJvcGVydHkoJ2xlbmd0aCcpO1xuICAgICAgdmFyIGxlbiA9IG9iai5sZW5ndGg7XG4gICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgICBsZW4gPiBuXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gaGF2ZSBhIGxlbmd0aCBhYm92ZSAje2V4cH0gYnV0IGdvdCAje2FjdH0nXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGhhdmUgYSBsZW5ndGggYWJvdmUgI3tleHB9J1xuICAgICAgICAsIG5cbiAgICAgICAgLCBsZW5cbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgIG9iaiA+IG5cbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSBhYm92ZSAnICsgblxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIGF0IG1vc3QgJyArIG5cbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnYWJvdmUnLCBhc3NlcnRBYm92ZSk7XG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2d0JywgYXNzZXJ0QWJvdmUpO1xuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdncmVhdGVyVGhhbicsIGFzc2VydEFib3ZlKTtcblxuICAvKipcbiAgICogIyMjIC5sZWFzdCh2YWx1ZSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIGB2YWx1ZWAuXG4gICAqXG4gICAqICAgICBleHBlY3QoMTApLnRvLmJlLmF0LmxlYXN0KDEwKTtcbiAgICpcbiAgICogQ2FuIGFsc28gYmUgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIGBsZW5ndGhgIHRvXG4gICAqIGFzc2VydCBhIG1pbmltdW0gbGVuZ3RoLiBUaGUgYmVuZWZpdCBiZWluZyBhXG4gICAqIG1vcmUgaW5mb3JtYXRpdmUgZXJyb3IgbWVzc2FnZSB0aGFuIGlmIHRoZSBsZW5ndGhcbiAgICogd2FzIHN1cHBsaWVkIGRpcmVjdGx5LlxuICAgKlxuICAgKiAgICAgZXhwZWN0KCdmb28nKS50by5oYXZlLmxlbmd0aC5vZi5hdC5sZWFzdCgyKTtcbiAgICogICAgIGV4cGVjdChbIDEsIDIsIDMgXSkudG8uaGF2ZS5sZW5ndGgub2YuYXQubGVhc3QoMyk7XG4gICAqXG4gICAqIEBuYW1lIGxlYXN0XG4gICAqIEBhbGlhcyBndGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gYXNzZXJ0TGVhc3QgKG4sIG1zZykge1xuICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKTtcbiAgICBpZiAoZmxhZyh0aGlzLCAnZG9MZW5ndGgnKSkge1xuICAgICAgbmV3IEFzc2VydGlvbihvYmosIG1zZykudG8uaGF2ZS5wcm9wZXJ0eSgnbGVuZ3RoJyk7XG4gICAgICB2YXIgbGVuID0gb2JqLmxlbmd0aDtcbiAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgIGxlbiA+PSBuXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gaGF2ZSBhIGxlbmd0aCBhdCBsZWFzdCAje2V4cH0gYnV0IGdvdCAje2FjdH0nXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gaGF2ZSBhIGxlbmd0aCBiZWxvdyAje2V4cH0nXG4gICAgICAgICwgblxuICAgICAgICAsIGxlblxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICAgb2JqID49IG5cbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSBhdCBsZWFzdCAnICsgblxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIGJlbG93ICcgKyBuXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2xlYXN0JywgYXNzZXJ0TGVhc3QpO1xuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdndGUnLCBhc3NlcnRMZWFzdCk7XG5cbiAgLyoqXG4gICAqICMjIyAuYmVsb3codmFsdWUpXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIGxlc3MgdGhhbiBgdmFsdWVgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KDUpLnRvLmJlLmJlbG93KDEwKTtcbiAgICpcbiAgICogQ2FuIGFsc28gYmUgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIGBsZW5ndGhgIHRvXG4gICAqIGFzc2VydCBhIG1heGltdW0gbGVuZ3RoLiBUaGUgYmVuZWZpdCBiZWluZyBhXG4gICAqIG1vcmUgaW5mb3JtYXRpdmUgZXJyb3IgbWVzc2FnZSB0aGFuIGlmIHRoZSBsZW5ndGhcbiAgICogd2FzIHN1cHBsaWVkIGRpcmVjdGx5LlxuICAgKlxuICAgKiAgICAgZXhwZWN0KCdmb28nKS50by5oYXZlLmxlbmd0aC5iZWxvdyg0KTtcbiAgICogICAgIGV4cGVjdChbIDEsIDIsIDMgXSkudG8uaGF2ZS5sZW5ndGguYmVsb3coNCk7XG4gICAqXG4gICAqIEBuYW1lIGJlbG93XG4gICAqIEBhbGlhcyBsdFxuICAgKiBAYWxpYXMgbGVzc1RoYW5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gYXNzZXJ0QmVsb3cgKG4sIG1zZykge1xuICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKTtcbiAgICBpZiAoZmxhZyh0aGlzLCAnZG9MZW5ndGgnKSkge1xuICAgICAgbmV3IEFzc2VydGlvbihvYmosIG1zZykudG8uaGF2ZS5wcm9wZXJ0eSgnbGVuZ3RoJyk7XG4gICAgICB2YXIgbGVuID0gb2JqLmxlbmd0aDtcbiAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgIGxlbiA8IG5cbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBoYXZlIGEgbGVuZ3RoIGJlbG93ICN7ZXhwfSBidXQgZ290ICN7YWN0fSdcbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgaGF2ZSBhIGxlbmd0aCBiZWxvdyAje2V4cH0nXG4gICAgICAgICwgblxuICAgICAgICAsIGxlblxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICAgb2JqIDwgblxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIGJlbG93ICcgKyBuXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgYXQgbGVhc3QgJyArIG5cbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnYmVsb3cnLCBhc3NlcnRCZWxvdyk7XG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2x0JywgYXNzZXJ0QmVsb3cpO1xuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdsZXNzVGhhbicsIGFzc2VydEJlbG93KTtcblxuICAvKipcbiAgICogIyMjIC5tb3N0KHZhbHVlKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYHZhbHVlYC5cbiAgICpcbiAgICogICAgIGV4cGVjdCg1KS50by5iZS5hdC5tb3N0KDUpO1xuICAgKlxuICAgKiBDYW4gYWxzbyBiZSB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggYGxlbmd0aGAgdG9cbiAgICogYXNzZXJ0IGEgbWF4aW11bSBsZW5ndGguIFRoZSBiZW5lZml0IGJlaW5nIGFcbiAgICogbW9yZSBpbmZvcm1hdGl2ZSBlcnJvciBtZXNzYWdlIHRoYW4gaWYgdGhlIGxlbmd0aFxuICAgKiB3YXMgc3VwcGxpZWQgZGlyZWN0bHkuXG4gICAqXG4gICAqICAgICBleHBlY3QoJ2ZvbycpLnRvLmhhdmUubGVuZ3RoLm9mLmF0Lm1vc3QoNCk7XG4gICAqICAgICBleHBlY3QoWyAxLCAyLCAzIF0pLnRvLmhhdmUubGVuZ3RoLm9mLmF0Lm1vc3QoMyk7XG4gICAqXG4gICAqIEBuYW1lIG1vc3RcbiAgICogQGFsaWFzIGx0ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBmdW5jdGlvbiBhc3NlcnRNb3N0IChuLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0Jyk7XG4gICAgaWYgKGZsYWcodGhpcywgJ2RvTGVuZ3RoJykpIHtcbiAgICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2cpLnRvLmhhdmUucHJvcGVydHkoJ2xlbmd0aCcpO1xuICAgICAgdmFyIGxlbiA9IG9iai5sZW5ndGg7XG4gICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgICBsZW4gPD0gblxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGhhdmUgYSBsZW5ndGggYXQgbW9zdCAje2V4cH0gYnV0IGdvdCAje2FjdH0nXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gaGF2ZSBhIGxlbmd0aCBhYm92ZSAje2V4cH0nXG4gICAgICAgICwgblxuICAgICAgICAsIGxlblxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICAgb2JqIDw9IG5cbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSBhdCBtb3N0ICcgKyBuXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgYWJvdmUgJyArIG5cbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnbW9zdCcsIGFzc2VydE1vc3QpO1xuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdsdGUnLCBhc3NlcnRNb3N0KTtcblxuICAvKipcbiAgICogIyMjIC53aXRoaW4oc3RhcnQsIGZpbmlzaClcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaXMgd2l0aGluIGEgcmFuZ2UuXG4gICAqXG4gICAqICAgICBleHBlY3QoNykudG8uYmUud2l0aGluKDUsMTApO1xuICAgKlxuICAgKiBDYW4gYWxzbyBiZSB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggYGxlbmd0aGAgdG9cbiAgICogYXNzZXJ0IGEgbGVuZ3RoIHJhbmdlLiBUaGUgYmVuZWZpdCBiZWluZyBhXG4gICAqIG1vcmUgaW5mb3JtYXRpdmUgZXJyb3IgbWVzc2FnZSB0aGFuIGlmIHRoZSBsZW5ndGhcbiAgICogd2FzIHN1cHBsaWVkIGRpcmVjdGx5LlxuICAgKlxuICAgKiAgICAgZXhwZWN0KCdmb28nKS50by5oYXZlLmxlbmd0aC53aXRoaW4oMiw0KTtcbiAgICogICAgIGV4cGVjdChbIDEsIDIsIDMgXSkudG8uaGF2ZS5sZW5ndGgud2l0aGluKDIsNCk7XG4gICAqXG4gICAqIEBuYW1lIHdpdGhpblxuICAgKiBAcGFyYW0ge051bWJlcn0gc3RhcnQgbG93ZXJib3VuZCBpbmNsdXNpdmVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGZpbmlzaCB1cHBlcmJvdW5kIGluY2x1c2l2ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ3dpdGhpbicsIGZ1bmN0aW9uIChzdGFydCwgZmluaXNoLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0JylcbiAgICAgICwgcmFuZ2UgPSBzdGFydCArICcuLicgKyBmaW5pc2g7XG4gICAgaWYgKGZsYWcodGhpcywgJ2RvTGVuZ3RoJykpIHtcbiAgICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2cpLnRvLmhhdmUucHJvcGVydHkoJ2xlbmd0aCcpO1xuICAgICAgdmFyIGxlbiA9IG9iai5sZW5ndGg7XG4gICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgICBsZW4gPj0gc3RhcnQgJiYgbGVuIDw9IGZpbmlzaFxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGhhdmUgYSBsZW5ndGggd2l0aGluICcgKyByYW5nZVxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBoYXZlIGEgbGVuZ3RoIHdpdGhpbiAnICsgcmFuZ2VcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgIG9iaiA+PSBzdGFydCAmJiBvYmogPD0gZmluaXNoXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgd2l0aGluICcgKyByYW5nZVxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBiZSB3aXRoaW4gJyArIHJhbmdlXG4gICAgICApO1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqICMjIyAuaW5zdGFuY2VvZihjb25zdHJ1Y3RvcilcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaXMgYW4gaW5zdGFuY2Ugb2YgYGNvbnN0cnVjdG9yYC5cbiAgICpcbiAgICogICAgIHZhciBUZWEgPSBmdW5jdGlvbiAobmFtZSkgeyB0aGlzLm5hbWUgPSBuYW1lOyB9XG4gICAqICAgICAgICwgQ2hhaSA9IG5ldyBUZWEoJ2NoYWknKTtcbiAgICpcbiAgICogICAgIGV4cGVjdChDaGFpKS50by5iZS5hbi5pbnN0YW5jZW9mKFRlYSk7XG4gICAqICAgICBleHBlY3QoWyAxLCAyLCAzIF0pLnRvLmJlLmluc3RhbmNlb2YoQXJyYXkpO1xuICAgKlxuICAgKiBAbmFtZSBpbnN0YW5jZW9mXG4gICAqIEBwYXJhbSB7Q29uc3RydWN0b3J9IGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQGFsaWFzIGluc3RhbmNlT2ZcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gYXNzZXJ0SW5zdGFuY2VPZiAoY29uc3RydWN0b3IsIG1zZykge1xuICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuICAgIHZhciBuYW1lID0gXy5nZXROYW1lKGNvbnN0cnVjdG9yKTtcbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgZmxhZyh0aGlzLCAnb2JqZWN0JykgaW5zdGFuY2VvZiBjb25zdHJ1Y3RvclxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSBhbiBpbnN0YW5jZSBvZiAnICsgbmFtZVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgYmUgYW4gaW5zdGFuY2Ugb2YgJyArIG5hbWVcbiAgICApO1xuICB9O1xuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2luc3RhbmNlb2YnLCBhc3NlcnRJbnN0YW5jZU9mKTtcbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnaW5zdGFuY2VPZicsIGFzc2VydEluc3RhbmNlT2YpO1xuXG4gIC8qKlxuICAgKiAjIyMgLnByb3BlcnR5KG5hbWUsIFt2YWx1ZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGhhcyBhIHByb3BlcnR5IGBuYW1lYCwgb3B0aW9uYWxseSBhc3NlcnRpbmcgdGhhdFxuICAgKiB0aGUgdmFsdWUgb2YgdGhhdCBwcm9wZXJ0eSBpcyBzdHJpY3RseSBlcXVhbCB0byAgYHZhbHVlYC5cbiAgICogSWYgdGhlIGBkZWVwYCBmbGFnIGlzIHNldCwgeW91IGNhbiB1c2UgZG90LSBhbmQgYnJhY2tldC1ub3RhdGlvbiBmb3IgZGVlcFxuICAgKiByZWZlcmVuY2VzIGludG8gb2JqZWN0cyBhbmQgYXJyYXlzLlxuICAgKlxuICAgKiAgICAgLy8gc2ltcGxlIHJlZmVyZW5jaW5nXG4gICAqICAgICB2YXIgb2JqID0geyBmb286ICdiYXInIH07XG4gICAqICAgICBleHBlY3Qob2JqKS50by5oYXZlLnByb3BlcnR5KCdmb28nKTtcbiAgICogICAgIGV4cGVjdChvYmopLnRvLmhhdmUucHJvcGVydHkoJ2ZvbycsICdiYXInKTtcbiAgICpcbiAgICogICAgIC8vIGRlZXAgcmVmZXJlbmNpbmdcbiAgICogICAgIHZhciBkZWVwT2JqID0ge1xuICAgKiAgICAgICAgIGdyZWVuOiB7IHRlYTogJ21hdGNoYScgfVxuICAgKiAgICAgICAsIHRlYXM6IFsgJ2NoYWknLCAnbWF0Y2hhJywgeyB0ZWE6ICdrb25hY2hhJyB9IF1cbiAgICogICAgIH07XG5cbiAgICogICAgIGV4cGVjdChkZWVwT2JqKS50by5oYXZlLmRlZXAucHJvcGVydHkoJ2dyZWVuLnRlYScsICdtYXRjaGEnKTtcbiAgICogICAgIGV4cGVjdChkZWVwT2JqKS50by5oYXZlLmRlZXAucHJvcGVydHkoJ3RlYXNbMV0nLCAnbWF0Y2hhJyk7XG4gICAqICAgICBleHBlY3QoZGVlcE9iaikudG8uaGF2ZS5kZWVwLnByb3BlcnR5KCd0ZWFzWzJdLnRlYScsICdrb25hY2hhJyk7XG4gICAqXG4gICAqIFlvdSBjYW4gYWxzbyB1c2UgYW4gYXJyYXkgYXMgdGhlIHN0YXJ0aW5nIHBvaW50IG9mIGEgYGRlZXAucHJvcGVydHlgXG4gICAqIGFzc2VydGlvbiwgb3IgdHJhdmVyc2UgbmVzdGVkIGFycmF5cy5cbiAgICpcbiAgICogICAgIHZhciBhcnIgPSBbXG4gICAqICAgICAgICAgWyAnY2hhaScsICdtYXRjaGEnLCAna29uYWNoYScgXVxuICAgKiAgICAgICAsIFsgeyB0ZWE6ICdjaGFpJyB9XG4gICAqICAgICAgICAgLCB7IHRlYTogJ21hdGNoYScgfVxuICAgKiAgICAgICAgICwgeyB0ZWE6ICdrb25hY2hhJyB9IF1cbiAgICogICAgIF07XG4gICAqXG4gICAqICAgICBleHBlY3QoYXJyKS50by5oYXZlLmRlZXAucHJvcGVydHkoJ1swXVsxXScsICdtYXRjaGEnKTtcbiAgICogICAgIGV4cGVjdChhcnIpLnRvLmhhdmUuZGVlcC5wcm9wZXJ0eSgnWzFdWzJdLnRlYScsICdrb25hY2hhJyk7XG4gICAqXG4gICAqIEZ1cnRoZXJtb3JlLCBgcHJvcGVydHlgIGNoYW5nZXMgdGhlIHN1YmplY3Qgb2YgdGhlIGFzc2VydGlvblxuICAgKiB0byBiZSB0aGUgdmFsdWUgb2YgdGhhdCBwcm9wZXJ0eSBmcm9tIHRoZSBvcmlnaW5hbCBvYmplY3QuIFRoaXNcbiAgICogcGVybWl0cyBmb3IgZnVydGhlciBjaGFpbmFibGUgYXNzZXJ0aW9ucyBvbiB0aGF0IHByb3BlcnR5LlxuICAgKlxuICAgKiAgICAgZXhwZWN0KG9iaikudG8uaGF2ZS5wcm9wZXJ0eSgnZm9vJylcbiAgICogICAgICAgLnRoYXQuaXMuYSgnc3RyaW5nJyk7XG4gICAqICAgICBleHBlY3QoZGVlcE9iaikudG8uaGF2ZS5wcm9wZXJ0eSgnZ3JlZW4nKVxuICAgKiAgICAgICAudGhhdC5pcy5hbignb2JqZWN0JylcbiAgICogICAgICAgLnRoYXQuZGVlcC5lcXVhbHMoeyB0ZWE6ICdtYXRjaGEnIH0pO1xuICAgKiAgICAgZXhwZWN0KGRlZXBPYmopLnRvLmhhdmUucHJvcGVydHkoJ3RlYXMnKVxuICAgKiAgICAgICAudGhhdC5pcy5hbignYXJyYXknKVxuICAgKiAgICAgICAud2l0aC5kZWVwLnByb3BlcnR5KCdbMl0nKVxuICAgKiAgICAgICAgIC50aGF0LmRlZXAuZXF1YWxzKHsgdGVhOiAna29uYWNoYScgfSk7XG4gICAqXG4gICAqIEBuYW1lIHByb3BlcnR5XG4gICAqIEBhbGlhcyBkZWVwLnByb3BlcnR5XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlIChvcHRpb25hbClcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAcmV0dXJucyB2YWx1ZSBvZiBwcm9wZXJ0eSBmb3IgY2hhaW5pbmdcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgncHJvcGVydHknLCBmdW5jdGlvbiAobmFtZSwgdmFsLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcblxuICAgIHZhciBkZXNjcmlwdG9yID0gZmxhZyh0aGlzLCAnZGVlcCcpID8gJ2RlZXAgcHJvcGVydHkgJyA6ICdwcm9wZXJ0eSAnXG4gICAgICAsIG5lZ2F0ZSA9IGZsYWcodGhpcywgJ25lZ2F0ZScpXG4gICAgICAsIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgICAsIHZhbHVlID0gZmxhZyh0aGlzLCAnZGVlcCcpXG4gICAgICAgID8gXy5nZXRQYXRoVmFsdWUobmFtZSwgb2JqKVxuICAgICAgICA6IG9ialtuYW1lXTtcblxuICAgIGlmIChuZWdhdGUgJiYgdW5kZWZpbmVkICE9PSB2YWwpIHtcbiAgICAgIGlmICh1bmRlZmluZWQgPT09IHZhbHVlKSB7XG4gICAgICAgIG1zZyA9IChtc2cgIT0gbnVsbCkgPyBtc2cgKyAnOiAnIDogJyc7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cgKyBfLmluc3BlY3Qob2JqKSArICcgaGFzIG5vICcgKyBkZXNjcmlwdG9yICsgXy5pbnNwZWN0KG5hbWUpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICAgdW5kZWZpbmVkICE9PSB2YWx1ZVxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGhhdmUgYSAnICsgZGVzY3JpcHRvciArIF8uaW5zcGVjdChuYW1lKVxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBoYXZlICcgKyBkZXNjcmlwdG9yICsgXy5pbnNwZWN0KG5hbWUpKTtcbiAgICB9XG5cbiAgICBpZiAodW5kZWZpbmVkICE9PSB2YWwpIHtcbiAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgIHZhbCA9PT0gdmFsdWVcbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBoYXZlIGEgJyArIGRlc2NyaXB0b3IgKyBfLmluc3BlY3QobmFtZSkgKyAnIG9mICN7ZXhwfSwgYnV0IGdvdCAje2FjdH0nXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGhhdmUgYSAnICsgZGVzY3JpcHRvciArIF8uaW5zcGVjdChuYW1lKSArICcgb2YgI3thY3R9J1xuICAgICAgICAsIHZhbFxuICAgICAgICAsIHZhbHVlXG4gICAgICApO1xuICAgIH1cblxuICAgIGZsYWcodGhpcywgJ29iamVjdCcsIHZhbHVlKTtcbiAgfSk7XG5cblxuICAvKipcbiAgICogIyMjIC5vd25Qcm9wZXJ0eShuYW1lKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBoYXMgYW4gb3duIHByb3BlcnR5IGBuYW1lYC5cbiAgICpcbiAgICogICAgIGV4cGVjdCgndGVzdCcpLnRvLmhhdmUub3duUHJvcGVydHkoJ2xlbmd0aCcpO1xuICAgKlxuICAgKiBAbmFtZSBvd25Qcm9wZXJ0eVxuICAgKiBAYWxpYXMgaGF2ZU93blByb3BlcnR5XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gYXNzZXJ0T3duUHJvcGVydHkgKG5hbWUsIG1zZykge1xuICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKTtcbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgb2JqLmhhc093blByb3BlcnR5KG5hbWUpXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGhhdmUgb3duIHByb3BlcnR5ICcgKyBfLmluc3BlY3QobmFtZSlcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGhhdmUgb3duIHByb3BlcnR5ICcgKyBfLmluc3BlY3QobmFtZSlcbiAgICApO1xuICB9XG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnb3duUHJvcGVydHknLCBhc3NlcnRPd25Qcm9wZXJ0eSk7XG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2hhdmVPd25Qcm9wZXJ0eScsIGFzc2VydE93blByb3BlcnR5KTtcblxuICAvKipcbiAgICogIyMjIC5sZW5ndGgodmFsdWUpXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0J3MgYGxlbmd0aGAgcHJvcGVydHkgaGFzXG4gICAqIHRoZSBleHBlY3RlZCB2YWx1ZS5cbiAgICpcbiAgICogICAgIGV4cGVjdChbIDEsIDIsIDNdKS50by5oYXZlLmxlbmd0aCgzKTtcbiAgICogICAgIGV4cGVjdCgnZm9vYmFyJykudG8uaGF2ZS5sZW5ndGgoNik7XG4gICAqXG4gICAqIENhbiBhbHNvIGJlIHVzZWQgYXMgYSBjaGFpbiBwcmVjdXJzb3IgdG8gYSB2YWx1ZVxuICAgKiBjb21wYXJpc29uIGZvciB0aGUgbGVuZ3RoIHByb3BlcnR5LlxuICAgKlxuICAgKiAgICAgZXhwZWN0KCdmb28nKS50by5oYXZlLmxlbmd0aC5hYm92ZSgyKTtcbiAgICogICAgIGV4cGVjdChbIDEsIDIsIDMgXSkudG8uaGF2ZS5sZW5ndGguYWJvdmUoMik7XG4gICAqICAgICBleHBlY3QoJ2ZvbycpLnRvLmhhdmUubGVuZ3RoLmJlbG93KDQpO1xuICAgKiAgICAgZXhwZWN0KFsgMSwgMiwgMyBdKS50by5oYXZlLmxlbmd0aC5iZWxvdyg0KTtcbiAgICogICAgIGV4cGVjdCgnZm9vJykudG8uaGF2ZS5sZW5ndGgud2l0aGluKDIsNCk7XG4gICAqICAgICBleHBlY3QoWyAxLCAyLCAzIF0pLnRvLmhhdmUubGVuZ3RoLndpdGhpbigyLDQpO1xuICAgKlxuICAgKiBAbmFtZSBsZW5ndGhcbiAgICogQGFsaWFzIGxlbmd0aE9mXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBsZW5ndGhcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBmdW5jdGlvbiBhc3NlcnRMZW5ndGhDaGFpbiAoKSB7XG4gICAgZmxhZyh0aGlzLCAnZG9MZW5ndGgnLCB0cnVlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFzc2VydExlbmd0aCAobiwgbXNnKSB7XG4gICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpO1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2cpLnRvLmhhdmUucHJvcGVydHkoJ2xlbmd0aCcpO1xuICAgIHZhciBsZW4gPSBvYmoubGVuZ3RoO1xuXG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIGxlbiA9PSBuXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGhhdmUgYSBsZW5ndGggb2YgI3tleHB9IGJ1dCBnb3QgI3thY3R9J1xuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgaGF2ZSBhIGxlbmd0aCBvZiAje2FjdH0nXG4gICAgICAsIG5cbiAgICAgICwgbGVuXG4gICAgKTtcbiAgfVxuXG4gIEFzc2VydGlvbi5hZGRDaGFpbmFibGVNZXRob2QoJ2xlbmd0aCcsIGFzc2VydExlbmd0aCwgYXNzZXJ0TGVuZ3RoQ2hhaW4pO1xuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdsZW5ndGhPZicsIGFzc2VydExlbmd0aCwgYXNzZXJ0TGVuZ3RoQ2hhaW4pO1xuXG4gIC8qKlxuICAgKiAjIyMgLm1hdGNoKHJlZ2V4cClcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgbWF0Y2hlcyBhIHJlZ3VsYXIgZXhwcmVzc2lvbi5cbiAgICpcbiAgICogICAgIGV4cGVjdCgnZm9vYmFyJykudG8ubWF0Y2goL15mb28vKTtcbiAgICpcbiAgICogQG5hbWUgbWF0Y2hcbiAgICogQHBhcmFtIHtSZWdFeHB9IFJlZ3VsYXJFeHByZXNzaW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnbWF0Y2gnLCBmdW5jdGlvbiAocmUsIG1zZykge1xuICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKTtcbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgcmUuZXhlYyhvYmopXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG1hdGNoICcgKyByZVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSBub3QgdG8gbWF0Y2ggJyArIHJlXG4gICAgKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqICMjIyAuc3RyaW5nKHN0cmluZylcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSBzdHJpbmcgdGFyZ2V0IGNvbnRhaW5zIGFub3RoZXIgc3RyaW5nLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KCdmb29iYXInKS50by5oYXZlLnN0cmluZygnYmFyJyk7XG4gICAqXG4gICAqIEBuYW1lIHN0cmluZ1xuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnc3RyaW5nJywgZnVuY3Rpb24gKHN0ciwgbXNnKSB7XG4gICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpO1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2cpLmlzLmEoJ3N0cmluZycpO1xuXG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIH5vYmouaW5kZXhPZihzdHIpXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGNvbnRhaW4gJyArIF8uaW5zcGVjdChzdHIpXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBjb250YWluICcgKyBfLmluc3BlY3Qoc3RyKVxuICAgICk7XG4gIH0pO1xuXG5cbiAgLyoqXG4gICAqICMjIyAua2V5cyhrZXkxLCBba2V5Ml0sIFsuLi5dKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBoYXMgZXhhY3RseSB0aGUgZ2l2ZW4ga2V5cywgb3JcbiAgICogYXNzZXJ0cyB0aGUgaW5jbHVzaW9uIG9mIHNvbWUga2V5cyB3aGVuIHVzaW5nIHRoZVxuICAgKiBgaW5jbHVkZWAgb3IgYGNvbnRhaW5gIG1vZGlmaWVycy5cbiAgICpcbiAgICogICAgIGV4cGVjdCh7IGZvbzogMSwgYmFyOiAyIH0pLnRvLmhhdmUua2V5cyhbJ2ZvbycsICdiYXInXSk7XG4gICAqICAgICBleHBlY3QoeyBmb286IDEsIGJhcjogMiwgYmF6OiAzIH0pLnRvLmNvbnRhaW4ua2V5cygnZm9vJywgJ2JhcicpO1xuICAgKlxuICAgKiBAbmFtZSBrZXlzXG4gICAqIEBhbGlhcyBrZXlcbiAgICogQHBhcmFtIHtTdHJpbmcuLi58QXJyYXl9IGtleXNcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gYXNzZXJ0S2V5cyAoa2V5cykge1xuICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKVxuICAgICAgLCBzdHJcbiAgICAgICwgb2sgPSB0cnVlO1xuXG4gICAga2V5cyA9IGtleXMgaW5zdGFuY2VvZiBBcnJheVxuICAgICAgPyBrZXlzXG4gICAgICA6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cbiAgICBpZiAoIWtleXMubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoJ2tleXMgcmVxdWlyZWQnKTtcblxuICAgIHZhciBhY3R1YWwgPSBPYmplY3Qua2V5cyhvYmopXG4gICAgICAsIGxlbiA9IGtleXMubGVuZ3RoO1xuXG4gICAgLy8gSW5jbHVzaW9uXG4gICAgb2sgPSBrZXlzLmV2ZXJ5KGZ1bmN0aW9uKGtleSl7XG4gICAgICByZXR1cm4gfmFjdHVhbC5pbmRleE9mKGtleSk7XG4gICAgfSk7XG5cbiAgICAvLyBTdHJpY3RcbiAgICBpZiAoIWZsYWcodGhpcywgJ25lZ2F0ZScpICYmICFmbGFnKHRoaXMsICdjb250YWlucycpKSB7XG4gICAgICBvayA9IG9rICYmIGtleXMubGVuZ3RoID09IGFjdHVhbC5sZW5ndGg7XG4gICAgfVxuXG4gICAgLy8gS2V5IHN0cmluZ1xuICAgIGlmIChsZW4gPiAxKSB7XG4gICAgICBrZXlzID0ga2V5cy5tYXAoZnVuY3Rpb24oa2V5KXtcbiAgICAgICAgcmV0dXJuIF8uaW5zcGVjdChrZXkpO1xuICAgICAgfSk7XG4gICAgICB2YXIgbGFzdCA9IGtleXMucG9wKCk7XG4gICAgICBzdHIgPSBrZXlzLmpvaW4oJywgJykgKyAnLCBhbmQgJyArIGxhc3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IF8uaW5zcGVjdChrZXlzWzBdKTtcbiAgICB9XG5cbiAgICAvLyBGb3JtXG4gICAgc3RyID0gKGxlbiA+IDEgPyAna2V5cyAnIDogJ2tleSAnKSArIHN0cjtcblxuICAgIC8vIEhhdmUgLyBpbmNsdWRlXG4gICAgc3RyID0gKGZsYWcodGhpcywgJ2NvbnRhaW5zJykgPyAnY29udGFpbiAnIDogJ2hhdmUgJykgKyBzdHI7XG5cbiAgICAvLyBBc3NlcnRpb25cbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgb2tcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gJyArIHN0clxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgJyArIHN0clxuICAgICk7XG4gIH1cblxuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdrZXlzJywgYXNzZXJ0S2V5cyk7XG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2tleScsIGFzc2VydEtleXMpO1xuXG4gIC8qKlxuICAgKiAjIyMgLnRocm93KGNvbnN0cnVjdG9yKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIGZ1bmN0aW9uIHRhcmdldCB3aWxsIHRocm93IGEgc3BlY2lmaWMgZXJyb3IsIG9yIHNwZWNpZmljIHR5cGUgb2YgZXJyb3JcbiAgICogKGFzIGRldGVybWluZWQgdXNpbmcgYGluc3RhbmNlb2ZgKSwgb3B0aW9uYWxseSB3aXRoIGEgUmVnRXhwIG9yIHN0cmluZyBpbmNsdXNpb24gdGVzdFxuICAgKiBmb3IgdGhlIGVycm9yJ3MgbWVzc2FnZS5cbiAgICpcbiAgICogICAgIHZhciBlcnIgPSBuZXcgUmVmZXJlbmNlRXJyb3IoJ1RoaXMgaXMgYSBiYWQgZnVuY3Rpb24uJyk7XG4gICAqICAgICB2YXIgZm4gPSBmdW5jdGlvbiAoKSB7IHRocm93IGVycjsgfVxuICAgKiAgICAgZXhwZWN0KGZuKS50by50aHJvdyhSZWZlcmVuY2VFcnJvcik7XG4gICAqICAgICBleHBlY3QoZm4pLnRvLnRocm93KEVycm9yKTtcbiAgICogICAgIGV4cGVjdChmbikudG8udGhyb3coL2JhZCBmdW5jdGlvbi8pO1xuICAgKiAgICAgZXhwZWN0KGZuKS50by5ub3QudGhyb3coJ2dvb2QgZnVuY3Rpb24nKTtcbiAgICogICAgIGV4cGVjdChmbikudG8udGhyb3coUmVmZXJlbmNlRXJyb3IsIC9iYWQgZnVuY3Rpb24vKTtcbiAgICogICAgIGV4cGVjdChmbikudG8udGhyb3coZXJyKTtcbiAgICogICAgIGV4cGVjdChmbikudG8ubm90LnRocm93KG5ldyBSYW5nZUVycm9yKCdPdXQgb2YgcmFuZ2UuJykpO1xuICAgKlxuICAgKiBQbGVhc2Ugbm90ZSB0aGF0IHdoZW4gYSB0aHJvdyBleHBlY3RhdGlvbiBpcyBuZWdhdGVkLCBpdCB3aWxsIGNoZWNrIGVhY2hcbiAgICogcGFyYW1ldGVyIGluZGVwZW5kZW50bHksIHN0YXJ0aW5nIHdpdGggZXJyb3IgY29uc3RydWN0b3IgdHlwZS4gVGhlIGFwcHJvcHJpYXRlIHdheVxuICAgKiB0byBjaGVjayBmb3IgdGhlIGV4aXN0ZW5jZSBvZiBhIHR5cGUgb2YgZXJyb3IgYnV0IGZvciBhIG1lc3NhZ2UgdGhhdCBkb2VzIG5vdCBtYXRjaFxuICAgKiBpcyB0byB1c2UgYGFuZGAuXG4gICAqXG4gICAqICAgICBleHBlY3QoZm4pLnRvLnRocm93KFJlZmVyZW5jZUVycm9yKVxuICAgKiAgICAgICAgLmFuZC5ub3QudGhyb3coL2dvb2QgZnVuY3Rpb24vKTtcbiAgICpcbiAgICogQG5hbWUgdGhyb3dcbiAgICogQGFsaWFzIHRocm93c1xuICAgKiBAYWxpYXMgVGhyb3dcbiAgICogQHBhcmFtIHtFcnJvckNvbnN0cnVjdG9yfSBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge1N0cmluZ3xSZWdFeHB9IGV4cGVjdGVkIGVycm9yIG1lc3NhZ2VcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0Vycm9yI0Vycm9yX3R5cGVzXG4gICAqIEByZXR1cm5zIGVycm9yIGZvciBjaGFpbmluZyAobnVsbCBpZiBubyBlcnJvcilcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gYXNzZXJ0VGhyb3dzIChjb25zdHJ1Y3RvciwgZXJyTXNnLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0Jyk7XG4gICAgbmV3IEFzc2VydGlvbihvYmosIG1zZykuaXMuYSgnZnVuY3Rpb24nKTtcblxuICAgIHZhciB0aHJvd24gPSBmYWxzZVxuICAgICAgLCBkZXNpcmVkRXJyb3IgPSBudWxsXG4gICAgICAsIG5hbWUgPSBudWxsXG4gICAgICAsIHRocm93bkVycm9yID0gbnVsbDtcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICBlcnJNc2cgPSBudWxsO1xuICAgICAgY29uc3RydWN0b3IgPSBudWxsO1xuICAgIH0gZWxzZSBpZiAoY29uc3RydWN0b3IgJiYgKGNvbnN0cnVjdG9yIGluc3RhbmNlb2YgUmVnRXhwIHx8ICdzdHJpbmcnID09PSB0eXBlb2YgY29uc3RydWN0b3IpKSB7XG4gICAgICBlcnJNc2cgPSBjb25zdHJ1Y3RvcjtcbiAgICAgIGNvbnN0cnVjdG9yID0gbnVsbDtcbiAgICB9IGVsc2UgaWYgKGNvbnN0cnVjdG9yICYmIGNvbnN0cnVjdG9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIGRlc2lyZWRFcnJvciA9IGNvbnN0cnVjdG9yO1xuICAgICAgY29uc3RydWN0b3IgPSBudWxsO1xuICAgICAgZXJyTXNnID0gbnVsbDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBjb25zdHJ1Y3RvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgbmFtZSA9IGNvbnN0cnVjdG9yLnByb3RvdHlwZS5uYW1lIHx8IGNvbnN0cnVjdG9yLm5hbWU7XG4gICAgICBpZiAobmFtZSA9PT0gJ0Vycm9yJyAmJiBjb25zdHJ1Y3RvciAhPT0gRXJyb3IpIHtcbiAgICAgICAgbmFtZSA9IChuZXcgY29uc3RydWN0b3IoKSkubmFtZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3RydWN0b3IgPSBudWxsO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBvYmooKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIC8vIGZpcnN0LCBjaGVjayBkZXNpcmVkIGVycm9yXG4gICAgICBpZiAoZGVzaXJlZEVycm9yKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgICAgZXJyID09PSBkZXNpcmVkRXJyb3JcbiAgICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIHRocm93ICN7ZXhwfSBidXQgI3thY3R9IHdhcyB0aHJvd24nXG4gICAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgdGhyb3cgI3tleHB9J1xuICAgICAgICAgICwgKGRlc2lyZWRFcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZGVzaXJlZEVycm9yLnRvU3RyaW5nKCkgOiBkZXNpcmVkRXJyb3IpXG4gICAgICAgICAgLCAoZXJyIGluc3RhbmNlb2YgRXJyb3IgPyBlcnIudG9TdHJpbmcoKSA6IGVycilcbiAgICAgICAgKTtcblxuICAgICAgICBmbGFnKHRoaXMsICdvYmplY3QnLCBlcnIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgLy8gbmV4dCwgY2hlY2sgY29uc3RydWN0b3JcbiAgICAgIGlmIChjb25zdHJ1Y3Rvcikge1xuICAgICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgICAgIGVyciBpbnN0YW5jZW9mIGNvbnN0cnVjdG9yXG4gICAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byB0aHJvdyAje2V4cH0gYnV0ICN7YWN0fSB3YXMgdGhyb3duJ1xuICAgICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IHRocm93ICN7ZXhwfSBidXQgI3thY3R9IHdhcyB0aHJvd24nXG4gICAgICAgICAgLCBuYW1lXG4gICAgICAgICAgLCAoZXJyIGluc3RhbmNlb2YgRXJyb3IgPyBlcnIudG9TdHJpbmcoKSA6IGVycilcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAoIWVyck1zZykge1xuICAgICAgICAgIGZsYWcodGhpcywgJ29iamVjdCcsIGVycik7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gbmV4dCwgY2hlY2sgbWVzc2FnZVxuICAgICAgdmFyIG1lc3NhZ2UgPSAnb2JqZWN0JyA9PT0gXy50eXBlKGVycikgJiYgXCJtZXNzYWdlXCIgaW4gZXJyXG4gICAgICAgID8gZXJyLm1lc3NhZ2VcbiAgICAgICAgOiAnJyArIGVycjtcblxuICAgICAgaWYgKChtZXNzYWdlICE9IG51bGwpICYmIGVyck1zZyAmJiBlcnJNc2cgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICAgICBlcnJNc2cuZXhlYyhtZXNzYWdlKVxuICAgICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gdGhyb3cgZXJyb3IgbWF0Y2hpbmcgI3tleHB9IGJ1dCBnb3QgI3thY3R9J1xuICAgICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gdGhyb3cgZXJyb3Igbm90IG1hdGNoaW5nICN7ZXhwfSdcbiAgICAgICAgICAsIGVyck1zZ1xuICAgICAgICAgICwgbWVzc2FnZVxuICAgICAgICApO1xuXG4gICAgICAgIGZsYWcodGhpcywgJ29iamVjdCcsIGVycik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSBlbHNlIGlmICgobWVzc2FnZSAhPSBudWxsKSAmJiBlcnJNc2cgJiYgJ3N0cmluZycgPT09IHR5cGVvZiBlcnJNc2cpIHtcbiAgICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICAgICB+bWVzc2FnZS5pbmRleE9mKGVyck1zZylcbiAgICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIHRocm93IGVycm9yIGluY2x1ZGluZyAje2V4cH0gYnV0IGdvdCAje2FjdH0nXG4gICAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byB0aHJvdyBlcnJvciBub3QgaW5jbHVkaW5nICN7YWN0fSdcbiAgICAgICAgICAsIGVyck1zZ1xuICAgICAgICAgICwgbWVzc2FnZVxuICAgICAgICApO1xuXG4gICAgICAgIGZsYWcodGhpcywgJ29iamVjdCcsIGVycik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3duID0gdHJ1ZTtcbiAgICAgICAgdGhyb3duRXJyb3IgPSBlcnI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGFjdHVhbGx5R290ID0gJydcbiAgICAgICwgZXhwZWN0ZWRUaHJvd24gPSBuYW1lICE9PSBudWxsXG4gICAgICAgID8gbmFtZVxuICAgICAgICA6IGRlc2lyZWRFcnJvclxuICAgICAgICAgID8gJyN7ZXhwfScgLy9fLmluc3BlY3QoZGVzaXJlZEVycm9yKVxuICAgICAgICAgIDogJ2FuIGVycm9yJztcblxuICAgIGlmICh0aHJvd24pIHtcbiAgICAgIGFjdHVhbGx5R290ID0gJyBidXQgI3thY3R9IHdhcyB0aHJvd24nXG4gICAgfVxuXG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIHRocm93biA9PT0gdHJ1ZVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byB0aHJvdyAnICsgZXhwZWN0ZWRUaHJvd24gKyBhY3R1YWxseUdvdFxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgdGhyb3cgJyArIGV4cGVjdGVkVGhyb3duICsgYWN0dWFsbHlHb3RcbiAgICAgICwgKGRlc2lyZWRFcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZGVzaXJlZEVycm9yLnRvU3RyaW5nKCkgOiBkZXNpcmVkRXJyb3IpXG4gICAgICAsICh0aHJvd25FcnJvciBpbnN0YW5jZW9mIEVycm9yID8gdGhyb3duRXJyb3IudG9TdHJpbmcoKSA6IHRocm93bkVycm9yKVxuICAgICk7XG5cbiAgICBmbGFnKHRoaXMsICdvYmplY3QnLCB0aHJvd25FcnJvcik7XG4gIH07XG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgndGhyb3cnLCBhc3NlcnRUaHJvd3MpO1xuICBBc3NlcnRpb24uYWRkTWV0aG9kKCd0aHJvd3MnLCBhc3NlcnRUaHJvd3MpO1xuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdUaHJvdycsIGFzc2VydFRocm93cyk7XG5cbiAgLyoqXG4gICAqICMjIyAucmVzcG9uZFRvKG1ldGhvZClcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSBvYmplY3Qgb3IgY2xhc3MgdGFyZ2V0IHdpbGwgcmVzcG9uZCB0byBhIG1ldGhvZC5cbiAgICpcbiAgICogICAgIEtsYXNzLnByb3RvdHlwZS5iYXIgPSBmdW5jdGlvbigpe307XG4gICAqICAgICBleHBlY3QoS2xhc3MpLnRvLnJlc3BvbmRUbygnYmFyJyk7XG4gICAqICAgICBleHBlY3Qob2JqKS50by5yZXNwb25kVG8oJ2JhcicpO1xuICAgKlxuICAgKiBUbyBjaGVjayBpZiBhIGNvbnN0cnVjdG9yIHdpbGwgcmVzcG9uZCB0byBhIHN0YXRpYyBmdW5jdGlvbixcbiAgICogc2V0IHRoZSBgaXRzZWxmYCBmbGFnLlxuICAgKlxuICAgKiAgICAgS2xhc3MuYmF6ID0gZnVuY3Rpb24oKXt9O1xuICAgKiAgICAgZXhwZWN0KEtsYXNzKS5pdHNlbGYudG8ucmVzcG9uZFRvKCdiYXonKTtcbiAgICpcbiAgICogQG5hbWUgcmVzcG9uZFRvXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2RcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdyZXNwb25kVG8nLCBmdW5jdGlvbiAobWV0aG9kLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0JylcbiAgICAgICwgaXRzZWxmID0gZmxhZyh0aGlzLCAnaXRzZWxmJylcbiAgICAgICwgY29udGV4dCA9ICgnZnVuY3Rpb24nID09PSBfLnR5cGUob2JqKSAmJiAhaXRzZWxmKVxuICAgICAgICA/IG9iai5wcm90b3R5cGVbbWV0aG9kXVxuICAgICAgICA6IG9ialttZXRob2RdO1xuXG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICdmdW5jdGlvbicgPT09IHR5cGVvZiBjb250ZXh0XG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIHJlc3BvbmQgdG8gJyArIF8uaW5zcGVjdChtZXRob2QpXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCByZXNwb25kIHRvICcgKyBfLmluc3BlY3QobWV0aG9kKVxuICAgICk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiAjIyMgLml0c2VsZlxuICAgKlxuICAgKiBTZXRzIHRoZSBgaXRzZWxmYCBmbGFnLCBsYXRlciB1c2VkIGJ5IHRoZSBgcmVzcG9uZFRvYCBhc3NlcnRpb24uXG4gICAqXG4gICAqICAgICBmdW5jdGlvbiBGb28oKSB7fVxuICAgKiAgICAgRm9vLmJhciA9IGZ1bmN0aW9uKCkge31cbiAgICogICAgIEZvby5wcm90b3R5cGUuYmF6ID0gZnVuY3Rpb24oKSB7fVxuICAgKlxuICAgKiAgICAgZXhwZWN0KEZvbykuaXRzZWxmLnRvLnJlc3BvbmRUbygnYmFyJyk7XG4gICAqICAgICBleHBlY3QoRm9vKS5pdHNlbGYubm90LnRvLnJlc3BvbmRUbygnYmF6Jyk7XG4gICAqXG4gICAqIEBuYW1lIGl0c2VsZlxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkUHJvcGVydHkoJ2l0c2VsZicsIGZ1bmN0aW9uICgpIHtcbiAgICBmbGFnKHRoaXMsICdpdHNlbGYnLCB0cnVlKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqICMjIyAuc2F0aXNmeShtZXRob2QpXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IHBhc3NlcyBhIGdpdmVuIHRydXRoIHRlc3QuXG4gICAqXG4gICAqICAgICBleHBlY3QoMSkudG8uc2F0aXNmeShmdW5jdGlvbihudW0pIHsgcmV0dXJuIG51bSA+IDA7IH0pO1xuICAgKlxuICAgKiBAbmFtZSBzYXRpc2Z5XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG1hdGNoZXJcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdzYXRpc2Z5JywgZnVuY3Rpb24gKG1hdGNoZXIsIG1zZykge1xuICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKTtcbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgbWF0Y2hlcihvYmopXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIHNhdGlzZnkgJyArIF8ub2JqRGlzcGxheShtYXRjaGVyKVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3Qgc2F0aXNmeScgKyBfLm9iakRpc3BsYXkobWF0Y2hlcilcbiAgICAgICwgdGhpcy5uZWdhdGUgPyBmYWxzZSA6IHRydWVcbiAgICAgICwgbWF0Y2hlcihvYmopXG4gICAgKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqICMjIyAuY2xvc2VUbyhleHBlY3RlZCwgZGVsdGEpXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIGVxdWFsIGBleHBlY3RlZGAsIHRvIHdpdGhpbiBhICsvLSBgZGVsdGFgIHJhbmdlLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KDEuNSkudG8uYmUuY2xvc2VUbygxLCAwLjUpO1xuICAgKlxuICAgKiBAbmFtZSBjbG9zZVRvXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBleHBlY3RlZFxuICAgKiBAcGFyYW0ge051bWJlcn0gZGVsdGFcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdjbG9zZVRvJywgZnVuY3Rpb24gKGV4cGVjdGVkLCBkZWx0YSwgbXNnKSB7XG4gICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpO1xuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICBNYXRoLmFicyhvYmogLSBleHBlY3RlZCkgPD0gZGVsdGFcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgY2xvc2UgdG8gJyArIGV4cGVjdGVkICsgJyArLy0gJyArIGRlbHRhXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IG5vdCB0byBiZSBjbG9zZSB0byAnICsgZXhwZWN0ZWQgKyAnICsvLSAnICsgZGVsdGFcbiAgICApO1xuICB9KTtcblxuICBmdW5jdGlvbiBpc1N1YnNldE9mKHN1YnNldCwgc3VwZXJzZXQsIGNtcCkge1xuICAgIHJldHVybiBzdWJzZXQuZXZlcnkoZnVuY3Rpb24oZWxlbSkge1xuICAgICAgaWYgKCFjbXApIHJldHVybiBzdXBlcnNldC5pbmRleE9mKGVsZW0pICE9PSAtMTtcblxuICAgICAgcmV0dXJuIHN1cGVyc2V0LnNvbWUoZnVuY3Rpb24oZWxlbTIpIHtcbiAgICAgICAgcmV0dXJuIGNtcChlbGVtLCBlbGVtMik7XG4gICAgICB9KTtcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqICMjIyAubWVtYmVycyhzZXQpXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIGEgc3VwZXJzZXQgb2YgYHNldGAsXG4gICAqIG9yIHRoYXQgdGhlIHRhcmdldCBhbmQgYHNldGAgaGF2ZSB0aGUgc2FtZSBzdHJpY3RseS1lcXVhbCAoPT09KSBtZW1iZXJzLlxuICAgKiBBbHRlcm5hdGVseSwgaWYgdGhlIGBkZWVwYCBmbGFnIGlzIHNldCwgc2V0IG1lbWJlcnMgYXJlIGNvbXBhcmVkIGZvciBkZWVwXG4gICAqIGVxdWFsaXR5LlxuICAgKlxuICAgKiAgICAgZXhwZWN0KFsxLCAyLCAzXSkudG8uaW5jbHVkZS5tZW1iZXJzKFszLCAyXSk7XG4gICAqICAgICBleHBlY3QoWzEsIDIsIDNdKS50by5ub3QuaW5jbHVkZS5tZW1iZXJzKFszLCAyLCA4XSk7XG4gICAqXG4gICAqICAgICBleHBlY3QoWzQsIDJdKS50by5oYXZlLm1lbWJlcnMoWzIsIDRdKTtcbiAgICogICAgIGV4cGVjdChbNSwgMl0pLnRvLm5vdC5oYXZlLm1lbWJlcnMoWzUsIDIsIDFdKTtcbiAgICpcbiAgICogICAgIGV4cGVjdChbeyBpZDogMSB9XSkudG8uZGVlcC5pbmNsdWRlLm1lbWJlcnMoW3sgaWQ6IDEgfV0pO1xuICAgKlxuICAgKiBAbmFtZSBtZW1iZXJzXG4gICAqIEBwYXJhbSB7QXJyYXl9IHNldFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ21lbWJlcnMnLCBmdW5jdGlvbiAoc3Vic2V0LCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0Jyk7XG5cbiAgICBuZXcgQXNzZXJ0aW9uKG9iaikudG8uYmUuYW4oJ2FycmF5Jyk7XG4gICAgbmV3IEFzc2VydGlvbihzdWJzZXQpLnRvLmJlLmFuKCdhcnJheScpO1xuXG4gICAgdmFyIGNtcCA9IGZsYWcodGhpcywgJ2RlZXAnKSA/IF8uZXFsIDogdW5kZWZpbmVkO1xuXG4gICAgaWYgKGZsYWcodGhpcywgJ2NvbnRhaW5zJykpIHtcbiAgICAgIHJldHVybiB0aGlzLmFzc2VydChcbiAgICAgICAgICBpc1N1YnNldE9mKHN1YnNldCwgb2JqLCBjbXApXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgYSBzdXBlcnNldCBvZiAje2FjdH0nXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGJlIGEgc3VwZXJzZXQgb2YgI3thY3R9J1xuICAgICAgICAsIG9ialxuICAgICAgICAsIHN1YnNldFxuICAgICAgKTtcbiAgICB9XG5cbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgaXNTdWJzZXRPZihvYmosIHN1YnNldCwgY21wKSAmJiBpc1N1YnNldE9mKHN1YnNldCwgb2JqLCBjbXApXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gaGF2ZSB0aGUgc2FtZSBtZW1iZXJzIGFzICN7YWN0fSdcbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgaGF2ZSB0aGUgc2FtZSBtZW1iZXJzIGFzICN7YWN0fSdcbiAgICAgICAgLCBvYmpcbiAgICAgICAgLCBzdWJzZXRcbiAgICApO1xuICB9KTtcbn07XG4iLCIvKiFcbiAqIGNoYWlcbiAqIENvcHlyaWdodChjKSAyMDExLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNoYWksIHV0aWwpIHtcblxuICAvKiFcbiAgICogQ2hhaSBkZXBlbmRlbmNpZXMuXG4gICAqL1xuXG4gIHZhciBBc3NlcnRpb24gPSBjaGFpLkFzc2VydGlvblxuICAgICwgZmxhZyA9IHV0aWwuZmxhZztcblxuICAvKiFcbiAgICogTW9kdWxlIGV4cG9ydC5cbiAgICovXG5cbiAgLyoqXG4gICAqICMjIyBhc3NlcnQoZXhwcmVzc2lvbiwgbWVzc2FnZSlcbiAgICpcbiAgICogV3JpdGUgeW91ciBvd24gdGVzdCBleHByZXNzaW9ucy5cbiAgICpcbiAgICogICAgIGFzc2VydCgnZm9vJyAhPT0gJ2JhcicsICdmb28gaXMgbm90IGJhcicpO1xuICAgKiAgICAgYXNzZXJ0KEFycmF5LmlzQXJyYXkoW10pLCAnZW1wdHkgYXJyYXlzIGFyZSBhcnJheXMnKTtcbiAgICpcbiAgICogQHBhcmFtIHtNaXhlZH0gZXhwcmVzc2lvbiB0byB0ZXN0IGZvciB0cnV0aGluZXNzXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIHRvIGRpc3BsYXkgb24gZXJyb3JcbiAgICogQG5hbWUgYXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIHZhciBhc3NlcnQgPSBjaGFpLmFzc2VydCA9IGZ1bmN0aW9uIChleHByZXNzLCBlcnJtc2cpIHtcbiAgICB2YXIgdGVzdCA9IG5ldyBBc3NlcnRpb24obnVsbCwgbnVsbCwgY2hhaS5hc3NlcnQpO1xuICAgIHRlc3QuYXNzZXJ0KFxuICAgICAgICBleHByZXNzXG4gICAgICAsIGVycm1zZ1xuICAgICAgLCAnWyBuZWdhdGlvbiBtZXNzYWdlIHVuYXZhaWxhYmxlIF0nXG4gICAgKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5mYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIFttZXNzYWdlXSwgW29wZXJhdG9yXSlcbiAgICpcbiAgICogVGhyb3cgYSBmYWlsdXJlLiBOb2RlLmpzIGBhc3NlcnRgIG1vZHVsZS1jb21wYXRpYmxlLlxuICAgKlxuICAgKiBAbmFtZSBmYWlsXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGFjdHVhbFxuICAgKiBAcGFyYW0ge01peGVkfSBleHBlY3RlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gb3BlcmF0b3JcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmZhaWwgPSBmdW5jdGlvbiAoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgb3BlcmF0b3IpIHtcbiAgICBtZXNzYWdlID0gbWVzc2FnZSB8fCAnYXNzZXJ0LmZhaWwoKSc7XG4gICAgdGhyb3cgbmV3IGNoYWkuQXNzZXJ0aW9uRXJyb3IobWVzc2FnZSwge1xuICAgICAgICBhY3R1YWw6IGFjdHVhbFxuICAgICAgLCBleHBlY3RlZDogZXhwZWN0ZWRcbiAgICAgICwgb3BlcmF0b3I6IG9wZXJhdG9yXG4gICAgfSwgYXNzZXJ0LmZhaWwpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLm9rKG9iamVjdCwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYG9iamVjdGAgaXMgdHJ1dGh5LlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lm9rKCdldmVyeXRoaW5nJywgJ2V2ZXJ5dGhpbmcgaXMgb2snKTtcbiAgICogICAgIGFzc2VydC5vayhmYWxzZSwgJ3RoaXMgd2lsbCBmYWlsJyk7XG4gICAqXG4gICAqIEBuYW1lIG9rXG4gICAqIEBwYXJhbSB7TWl4ZWR9IG9iamVjdCB0byB0ZXN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5vayA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2cpLmlzLm9rO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLm5vdE9rKG9iamVjdCwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYG9iamVjdGAgaXMgZmFsc3kuXG4gICAqXG4gICAqICAgICBhc3NlcnQubm90T2soJ2V2ZXJ5dGhpbmcnLCAndGhpcyB3aWxsIGZhaWwnKTtcbiAgICogICAgIGFzc2VydC5ub3RPayhmYWxzZSwgJ3RoaXMgd2lsbCBwYXNzJyk7XG4gICAqXG4gICAqIEBuYW1lIG5vdE9rXG4gICAqIEBwYXJhbSB7TWl4ZWR9IG9iamVjdCB0byB0ZXN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5ub3RPayA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2cpLmlzLm5vdC5vaztcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5lcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgbm9uLXN0cmljdCBlcXVhbGl0eSAoYD09YCkgb2YgYGFjdHVhbGAgYW5kIGBleHBlY3RlZGAuXG4gICAqXG4gICAqICAgICBhc3NlcnQuZXF1YWwoMywgJzMnLCAnPT0gY29lcmNlcyB2YWx1ZXMgdG8gc3RyaW5ncycpO1xuICAgKlxuICAgKiBAbmFtZSBlcXVhbFxuICAgKiBAcGFyYW0ge01peGVkfSBhY3R1YWxcbiAgICogQHBhcmFtIHtNaXhlZH0gZXhwZWN0ZWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmVxdWFsID0gZnVuY3Rpb24gKGFjdCwgZXhwLCBtc2cpIHtcbiAgICB2YXIgdGVzdCA9IG5ldyBBc3NlcnRpb24oYWN0LCBtc2csIGFzc2VydC5lcXVhbCk7XG5cbiAgICB0ZXN0LmFzc2VydChcbiAgICAgICAgZXhwID09IGZsYWcodGVzdCwgJ29iamVjdCcpXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGVxdWFsICN7ZXhwfSdcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGVxdWFsICN7YWN0fSdcbiAgICAgICwgZXhwXG4gICAgICAsIGFjdFxuICAgICk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAubm90RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIG5vbi1zdHJpY3QgaW5lcXVhbGl0eSAoYCE9YCkgb2YgYGFjdHVhbGAgYW5kIGBleHBlY3RlZGAuXG4gICAqXG4gICAqICAgICBhc3NlcnQubm90RXF1YWwoMywgNCwgJ3RoZXNlIG51bWJlcnMgYXJlIG5vdCBlcXVhbCcpO1xuICAgKlxuICAgKiBAbmFtZSBub3RFcXVhbFxuICAgKiBAcGFyYW0ge01peGVkfSBhY3R1YWxcbiAgICogQHBhcmFtIHtNaXhlZH0gZXhwZWN0ZWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm5vdEVxdWFsID0gZnVuY3Rpb24gKGFjdCwgZXhwLCBtc2cpIHtcbiAgICB2YXIgdGVzdCA9IG5ldyBBc3NlcnRpb24oYWN0LCBtc2csIGFzc2VydC5ub3RFcXVhbCk7XG5cbiAgICB0ZXN0LmFzc2VydChcbiAgICAgICAgZXhwICE9IGZsYWcodGVzdCwgJ29iamVjdCcpXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBlcXVhbCAje2V4cH0nXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGVxdWFsICN7YWN0fSdcbiAgICAgICwgZXhwXG4gICAgICAsIGFjdFxuICAgICk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuc3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHN0cmljdCBlcXVhbGl0eSAoYD09PWApIG9mIGBhY3R1YWxgIGFuZCBgZXhwZWN0ZWRgLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LnN0cmljdEVxdWFsKHRydWUsIHRydWUsICd0aGVzZSBib29sZWFucyBhcmUgc3RyaWN0bHkgZXF1YWwnKTtcbiAgICpcbiAgICogQG5hbWUgc3RyaWN0RXF1YWxcbiAgICogQHBhcmFtIHtNaXhlZH0gYWN0dWFsXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGV4cGVjdGVkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5zdHJpY3RFcXVhbCA9IGZ1bmN0aW9uIChhY3QsIGV4cCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihhY3QsIG1zZykudG8uZXF1YWwoZXhwKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5ub3RTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgc3RyaWN0IGluZXF1YWxpdHkgKGAhPT1gKSBvZiBgYWN0dWFsYCBhbmQgYGV4cGVjdGVkYC5cbiAgICpcbiAgICogICAgIGFzc2VydC5ub3RTdHJpY3RFcXVhbCgzLCAnMycsICdubyBjb2VyY2lvbiBmb3Igc3RyaWN0IGVxdWFsaXR5Jyk7XG4gICAqXG4gICAqIEBuYW1lIG5vdFN0cmljdEVxdWFsXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGFjdHVhbFxuICAgKiBAcGFyYW0ge01peGVkfSBleHBlY3RlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQubm90U3RyaWN0RXF1YWwgPSBmdW5jdGlvbiAoYWN0LCBleHAsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oYWN0LCBtc2cpLnRvLm5vdC5lcXVhbChleHApO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmRlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgYWN0dWFsYCBpcyBkZWVwbHkgZXF1YWwgdG8gYGV4cGVjdGVkYC5cbiAgICpcbiAgICogICAgIGFzc2VydC5kZWVwRXF1YWwoeyB0ZWE6ICdncmVlbicgfSwgeyB0ZWE6ICdncmVlbicgfSk7XG4gICAqXG4gICAqIEBuYW1lIGRlZXBFcXVhbFxuICAgKiBAcGFyYW0ge01peGVkfSBhY3R1YWxcbiAgICogQHBhcmFtIHtNaXhlZH0gZXhwZWN0ZWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmRlZXBFcXVhbCA9IGZ1bmN0aW9uIChhY3QsIGV4cCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihhY3QsIG1zZykudG8uZXFsKGV4cCk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAubm90RGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0IHRoYXQgYGFjdHVhbGAgaXMgbm90IGRlZXBseSBlcXVhbCB0byBgZXhwZWN0ZWRgLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lm5vdERlZXBFcXVhbCh7IHRlYTogJ2dyZWVuJyB9LCB7IHRlYTogJ2phc21pbmUnIH0pO1xuICAgKlxuICAgKiBAbmFtZSBub3REZWVwRXF1YWxcbiAgICogQHBhcmFtIHtNaXhlZH0gYWN0dWFsXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGV4cGVjdGVkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5ub3REZWVwRXF1YWwgPSBmdW5jdGlvbiAoYWN0LCBleHAsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oYWN0LCBtc2cpLnRvLm5vdC5lcWwoZXhwKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc1RydWUodmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAgaXMgdHJ1ZS5cbiAgICpcbiAgICogICAgIHZhciB0ZWFTZXJ2ZWQgPSB0cnVlO1xuICAgKiAgICAgYXNzZXJ0LmlzVHJ1ZSh0ZWFTZXJ2ZWQsICd0aGUgdGVhIGhhcyBiZWVuIHNlcnZlZCcpO1xuICAgKlxuICAgKiBAbmFtZSBpc1RydWVcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzVHJ1ZSA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2cpLmlzWyd0cnVlJ107XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNGYWxzZSh2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBpcyBmYWxzZS5cbiAgICpcbiAgICogICAgIHZhciB0ZWFTZXJ2ZWQgPSBmYWxzZTtcbiAgICogICAgIGFzc2VydC5pc0ZhbHNlKHRlYVNlcnZlZCwgJ25vIHRlYSB5ZXQ/IGhtbS4uLicpO1xuICAgKlxuICAgKiBAbmFtZSBpc0ZhbHNlXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc0ZhbHNlID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZykuaXNbJ2ZhbHNlJ107XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNOdWxsKHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgIGlzIG51bGwuXG4gICAqXG4gICAqICAgICBhc3NlcnQuaXNOdWxsKGVyciwgJ3RoZXJlIHdhcyBubyBlcnJvcicpO1xuICAgKlxuICAgKiBAbmFtZSBpc051bGxcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzTnVsbCA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2cpLnRvLmVxdWFsKG51bGwpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzTm90TnVsbCh2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBpcyBub3QgbnVsbC5cbiAgICpcbiAgICogICAgIHZhciB0ZWEgPSAndGFzdHkgY2hhaSc7XG4gICAqICAgICBhc3NlcnQuaXNOb3ROdWxsKHRlYSwgJ2dyZWF0LCB0aW1lIGZvciB0ZWEhJyk7XG4gICAqXG4gICAqIEBuYW1lIGlzTm90TnVsbFxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNOb3ROdWxsID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZykudG8ubm90LmVxdWFsKG51bGwpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzVW5kZWZpbmVkKHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgIGlzIGB1bmRlZmluZWRgLlxuICAgKlxuICAgKiAgICAgdmFyIHRlYTtcbiAgICogICAgIGFzc2VydC5pc1VuZGVmaW5lZCh0ZWEsICdubyB0ZWEgZGVmaW5lZCcpO1xuICAgKlxuICAgKiBAbmFtZSBpc1VuZGVmaW5lZFxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNVbmRlZmluZWQgPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnKS50by5lcXVhbCh1bmRlZmluZWQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzRGVmaW5lZCh2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBpcyBub3QgYHVuZGVmaW5lZGAuXG4gICAqXG4gICAqICAgICB2YXIgdGVhID0gJ2N1cCBvZiBjaGFpJztcbiAgICogICAgIGFzc2VydC5pc0RlZmluZWQodGVhLCAndGVhIGhhcyBiZWVuIGRlZmluZWQnKTtcbiAgICpcbiAgICogQG5hbWUgaXNEZWZpbmVkXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc0RlZmluZWQgPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnKS50by5ub3QuZXF1YWwodW5kZWZpbmVkKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc0Z1bmN0aW9uKHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgIGlzIGEgZnVuY3Rpb24uXG4gICAqXG4gICAqICAgICBmdW5jdGlvbiBzZXJ2ZVRlYSgpIHsgcmV0dXJuICdjdXAgb2YgdGVhJzsgfTtcbiAgICogICAgIGFzc2VydC5pc0Z1bmN0aW9uKHNlcnZlVGVhLCAnZ3JlYXQsIHdlIGNhbiBoYXZlIHRlYSBub3cnKTtcbiAgICpcbiAgICogQG5hbWUgaXNGdW5jdGlvblxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNGdW5jdGlvbiA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2cpLnRvLmJlLmEoJ2Z1bmN0aW9uJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNOb3RGdW5jdGlvbih2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBpcyBfbm90XyBhIGZ1bmN0aW9uLlxuICAgKlxuICAgKiAgICAgdmFyIHNlcnZlVGVhID0gWyAnaGVhdCcsICdwb3VyJywgJ3NpcCcgXTtcbiAgICogICAgIGFzc2VydC5pc05vdEZ1bmN0aW9uKHNlcnZlVGVhLCAnZ3JlYXQsIHdlIGhhdmUgbGlzdGVkIHRoZSBzdGVwcycpO1xuICAgKlxuICAgKiBAbmFtZSBpc05vdEZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc05vdEZ1bmN0aW9uID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZykudG8ubm90LmJlLmEoJ2Z1bmN0aW9uJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNPYmplY3QodmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAgaXMgYW4gb2JqZWN0IChhcyByZXZlYWxlZCBieVxuICAgKiBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2ApLlxuICAgKlxuICAgKiAgICAgdmFyIHNlbGVjdGlvbiA9IHsgbmFtZTogJ0NoYWknLCBzZXJ2ZTogJ3dpdGggc3BpY2VzJyB9O1xuICAgKiAgICAgYXNzZXJ0LmlzT2JqZWN0KHNlbGVjdGlvbiwgJ3RlYSBzZWxlY3Rpb24gaXMgYW4gb2JqZWN0Jyk7XG4gICAqXG4gICAqIEBuYW1lIGlzT2JqZWN0XG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc09iamVjdCA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2cpLnRvLmJlLmEoJ29iamVjdCcpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzTm90T2JqZWN0KHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgIGlzIF9ub3RfIGFuIG9iamVjdC5cbiAgICpcbiAgICogICAgIHZhciBzZWxlY3Rpb24gPSAnY2hhaSdcbiAgICogICAgIGFzc2VydC5pc05vdE9iamVjdChzZWxlY3Rpb24sICd0ZWEgc2VsZWN0aW9uIGlzIG5vdCBhbiBvYmplY3QnKTtcbiAgICogICAgIGFzc2VydC5pc05vdE9iamVjdChudWxsLCAnbnVsbCBpcyBub3QgYW4gb2JqZWN0Jyk7XG4gICAqXG4gICAqIEBuYW1lIGlzTm90T2JqZWN0XG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc05vdE9iamVjdCA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2cpLnRvLm5vdC5iZS5hKCdvYmplY3QnKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc0FycmF5KHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgIGlzIGFuIGFycmF5LlxuICAgKlxuICAgKiAgICAgdmFyIG1lbnUgPSBbICdncmVlbicsICdjaGFpJywgJ29vbG9uZycgXTtcbiAgICogICAgIGFzc2VydC5pc0FycmF5KG1lbnUsICd3aGF0IGtpbmQgb2YgdGVhIGRvIHdlIHdhbnQ/Jyk7XG4gICAqXG4gICAqIEBuYW1lIGlzQXJyYXlcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzQXJyYXkgPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnKS50by5iZS5hbignYXJyYXknKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc05vdEFycmF5KHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgIGlzIF9ub3RfIGFuIGFycmF5LlxuICAgKlxuICAgKiAgICAgdmFyIG1lbnUgPSAnZ3JlZW58Y2hhaXxvb2xvbmcnO1xuICAgKiAgICAgYXNzZXJ0LmlzTm90QXJyYXkobWVudSwgJ3doYXQga2luZCBvZiB0ZWEgZG8gd2Ugd2FudD8nKTtcbiAgICpcbiAgICogQG5hbWUgaXNOb3RBcnJheVxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNOb3RBcnJheSA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2cpLnRvLm5vdC5iZS5hbignYXJyYXknKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc1N0cmluZyh2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBpcyBhIHN0cmluZy5cbiAgICpcbiAgICogICAgIHZhciB0ZWFPcmRlciA9ICdjaGFpJztcbiAgICogICAgIGFzc2VydC5pc1N0cmluZyh0ZWFPcmRlciwgJ29yZGVyIHBsYWNlZCcpO1xuICAgKlxuICAgKiBAbmFtZSBpc1N0cmluZ1xuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNTdHJpbmcgPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnKS50by5iZS5hKCdzdHJpbmcnKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc05vdFN0cmluZyh2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBpcyBfbm90XyBhIHN0cmluZy5cbiAgICpcbiAgICogICAgIHZhciB0ZWFPcmRlciA9IDQ7XG4gICAqICAgICBhc3NlcnQuaXNOb3RTdHJpbmcodGVhT3JkZXIsICdvcmRlciBwbGFjZWQnKTtcbiAgICpcbiAgICogQG5hbWUgaXNOb3RTdHJpbmdcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzTm90U3RyaW5nID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZykudG8ubm90LmJlLmEoJ3N0cmluZycpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzTnVtYmVyKHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgIGlzIGEgbnVtYmVyLlxuICAgKlxuICAgKiAgICAgdmFyIGN1cHMgPSAyO1xuICAgKiAgICAgYXNzZXJ0LmlzTnVtYmVyKGN1cHMsICdob3cgbWFueSBjdXBzJyk7XG4gICAqXG4gICAqIEBuYW1lIGlzTnVtYmVyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNOdW1iZXIgPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnKS50by5iZS5hKCdudW1iZXInKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc05vdE51bWJlcih2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBpcyBfbm90XyBhIG51bWJlci5cbiAgICpcbiAgICogICAgIHZhciBjdXBzID0gJzIgY3VwcyBwbGVhc2UnO1xuICAgKiAgICAgYXNzZXJ0LmlzTm90TnVtYmVyKGN1cHMsICdob3cgbWFueSBjdXBzJyk7XG4gICAqXG4gICAqIEBuYW1lIGlzTm90TnVtYmVyXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc05vdE51bWJlciA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2cpLnRvLm5vdC5iZS5hKCdudW1iZXInKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc0Jvb2xlYW4odmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAgaXMgYSBib29sZWFuLlxuICAgKlxuICAgKiAgICAgdmFyIHRlYVJlYWR5ID0gdHJ1ZVxuICAgKiAgICAgICAsIHRlYVNlcnZlZCA9IGZhbHNlO1xuICAgKlxuICAgKiAgICAgYXNzZXJ0LmlzQm9vbGVhbih0ZWFSZWFkeSwgJ2lzIHRoZSB0ZWEgcmVhZHknKTtcbiAgICogICAgIGFzc2VydC5pc0Jvb2xlYW4odGVhU2VydmVkLCAnaGFzIHRlYSBiZWVuIHNlcnZlZCcpO1xuICAgKlxuICAgKiBAbmFtZSBpc0Jvb2xlYW5cbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzQm9vbGVhbiA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2cpLnRvLmJlLmEoJ2Jvb2xlYW4nKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc05vdEJvb2xlYW4odmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAgaXMgX25vdF8gYSBib29sZWFuLlxuICAgKlxuICAgKiAgICAgdmFyIHRlYVJlYWR5ID0gJ3llcCdcbiAgICogICAgICAgLCB0ZWFTZXJ2ZWQgPSAnbm9wZSc7XG4gICAqXG4gICAqICAgICBhc3NlcnQuaXNOb3RCb29sZWFuKHRlYVJlYWR5LCAnaXMgdGhlIHRlYSByZWFkeScpO1xuICAgKiAgICAgYXNzZXJ0LmlzTm90Qm9vbGVhbih0ZWFTZXJ2ZWQsICdoYXMgdGVhIGJlZW4gc2VydmVkJyk7XG4gICAqXG4gICAqIEBuYW1lIGlzTm90Qm9vbGVhblxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNOb3RCb29sZWFuID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZykudG8ubm90LmJlLmEoJ2Jvb2xlYW4nKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC50eXBlT2YodmFsdWUsIG5hbWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAncyB0eXBlIGlzIGBuYW1lYCwgYXMgZGV0ZXJtaW5lZCBieVxuICAgKiBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AuXG4gICAqXG4gICAqICAgICBhc3NlcnQudHlwZU9mKHsgdGVhOiAnY2hhaScgfSwgJ29iamVjdCcsICd3ZSBoYXZlIGFuIG9iamVjdCcpO1xuICAgKiAgICAgYXNzZXJ0LnR5cGVPZihbJ2NoYWknLCAnamFzbWluZSddLCAnYXJyYXknLCAnd2UgaGF2ZSBhbiBhcnJheScpO1xuICAgKiAgICAgYXNzZXJ0LnR5cGVPZigndGVhJywgJ3N0cmluZycsICd3ZSBoYXZlIGEgc3RyaW5nJyk7XG4gICAqICAgICBhc3NlcnQudHlwZU9mKC90ZWEvLCAncmVnZXhwJywgJ3dlIGhhdmUgYSByZWd1bGFyIGV4cHJlc3Npb24nKTtcbiAgICogICAgIGFzc2VydC50eXBlT2YobnVsbCwgJ251bGwnLCAnd2UgaGF2ZSBhIG51bGwnKTtcbiAgICogICAgIGFzc2VydC50eXBlT2YodW5kZWZpbmVkLCAndW5kZWZpbmVkJywgJ3dlIGhhdmUgYW4gdW5kZWZpbmVkJyk7XG4gICAqXG4gICAqIEBuYW1lIHR5cGVPZlxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQudHlwZU9mID0gZnVuY3Rpb24gKHZhbCwgdHlwZSwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZykudG8uYmUuYSh0eXBlKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5ub3RUeXBlT2YodmFsdWUsIG5hbWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAncyB0eXBlIGlzIF9ub3RfIGBuYW1lYCwgYXMgZGV0ZXJtaW5lZCBieVxuICAgKiBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AuXG4gICAqXG4gICAqICAgICBhc3NlcnQubm90VHlwZU9mKCd0ZWEnLCAnbnVtYmVyJywgJ3N0cmluZ3MgYXJlIG5vdCBudW1iZXJzJyk7XG4gICAqXG4gICAqIEBuYW1lIG5vdFR5cGVPZlxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZW9mIG5hbWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm5vdFR5cGVPZiA9IGZ1bmN0aW9uICh2YWwsIHR5cGUsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2cpLnRvLm5vdC5iZS5hKHR5cGUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmluc3RhbmNlT2Yob2JqZWN0LCBjb25zdHJ1Y3RvciwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBpcyBhbiBpbnN0YW5jZSBvZiBgY29uc3RydWN0b3JgLlxuICAgKlxuICAgKiAgICAgdmFyIFRlYSA9IGZ1bmN0aW9uIChuYW1lKSB7IHRoaXMubmFtZSA9IG5hbWU7IH1cbiAgICogICAgICAgLCBjaGFpID0gbmV3IFRlYSgnY2hhaScpO1xuICAgKlxuICAgKiAgICAgYXNzZXJ0Lmluc3RhbmNlT2YoY2hhaSwgVGVhLCAnY2hhaSBpcyBhbiBpbnN0YW5jZSBvZiB0ZWEnKTtcbiAgICpcbiAgICogQG5hbWUgaW5zdGFuY2VPZlxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7Q29uc3RydWN0b3J9IGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pbnN0YW5jZU9mID0gZnVuY3Rpb24gKHZhbCwgdHlwZSwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZykudG8uYmUuaW5zdGFuY2VPZih0eXBlKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5ub3RJbnN0YW5jZU9mKG9iamVjdCwgY29uc3RydWN0b3IsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyBgdmFsdWVgIGlzIG5vdCBhbiBpbnN0YW5jZSBvZiBgY29uc3RydWN0b3JgLlxuICAgKlxuICAgKiAgICAgdmFyIFRlYSA9IGZ1bmN0aW9uIChuYW1lKSB7IHRoaXMubmFtZSA9IG5hbWU7IH1cbiAgICogICAgICAgLCBjaGFpID0gbmV3IFN0cmluZygnY2hhaScpO1xuICAgKlxuICAgKiAgICAgYXNzZXJ0Lm5vdEluc3RhbmNlT2YoY2hhaSwgVGVhLCAnY2hhaSBpcyBub3QgYW4gaW5zdGFuY2Ugb2YgdGVhJyk7XG4gICAqXG4gICAqIEBuYW1lIG5vdEluc3RhbmNlT2ZcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgKiBAcGFyYW0ge0NvbnN0cnVjdG9yfSBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQubm90SW5zdGFuY2VPZiA9IGZ1bmN0aW9uICh2YWwsIHR5cGUsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2cpLnRvLm5vdC5iZS5pbnN0YW5jZU9mKHR5cGUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmluY2x1ZGUoaGF5c3RhY2ssIG5lZWRsZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYGhheXN0YWNrYCBpbmNsdWRlcyBgbmVlZGxlYC4gV29ya3NcbiAgICogZm9yIHN0cmluZ3MgYW5kIGFycmF5cy5cbiAgICpcbiAgICogICAgIGFzc2VydC5pbmNsdWRlKCdmb29iYXInLCAnYmFyJywgJ2Zvb2JhciBjb250YWlucyBzdHJpbmcgXCJiYXJcIicpO1xuICAgKiAgICAgYXNzZXJ0LmluY2x1ZGUoWyAxLCAyLCAzIF0sIDMsICdhcnJheSBjb250YWlucyB2YWx1ZScpO1xuICAgKlxuICAgKiBAbmFtZSBpbmNsdWRlXG4gICAqIEBwYXJhbSB7QXJyYXl8U3RyaW5nfSBoYXlzdGFja1xuICAgKiBAcGFyYW0ge01peGVkfSBuZWVkbGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmluY2x1ZGUgPSBmdW5jdGlvbiAoZXhwLCBpbmMsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oZXhwLCBtc2csIGFzc2VydC5pbmNsdWRlKS5pbmNsdWRlKGluYyk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAubm90SW5jbHVkZShoYXlzdGFjaywgbmVlZGxlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgaGF5c3RhY2tgIGRvZXMgbm90IGluY2x1ZGUgYG5lZWRsZWAuIFdvcmtzXG4gICAqIGZvciBzdHJpbmdzIGFuZCBhcnJheXMuXG4gICAqaVxuICAgKiAgICAgYXNzZXJ0Lm5vdEluY2x1ZGUoJ2Zvb2JhcicsICdiYXonLCAnc3RyaW5nIG5vdCBpbmNsdWRlIHN1YnN0cmluZycpO1xuICAgKiAgICAgYXNzZXJ0Lm5vdEluY2x1ZGUoWyAxLCAyLCAzIF0sIDQsICdhcnJheSBub3QgaW5jbHVkZSBjb250YWluIHZhbHVlJyk7XG4gICAqXG4gICAqIEBuYW1lIG5vdEluY2x1ZGVcbiAgICogQHBhcmFtIHtBcnJheXxTdHJpbmd9IGhheXN0YWNrXG4gICAqIEBwYXJhbSB7TWl4ZWR9IG5lZWRsZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQubm90SW5jbHVkZSA9IGZ1bmN0aW9uIChleHAsIGluYywgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihleHAsIG1zZywgYXNzZXJ0Lm5vdEluY2x1ZGUpLm5vdC5pbmNsdWRlKGluYyk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAubWF0Y2godmFsdWUsIHJlZ2V4cCwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBtYXRjaGVzIHRoZSByZWd1bGFyIGV4cHJlc3Npb24gYHJlZ2V4cGAuXG4gICAqXG4gICAqICAgICBhc3NlcnQubWF0Y2goJ2Zvb2JhcicsIC9eZm9vLywgJ3JlZ2V4cCBtYXRjaGVzJyk7XG4gICAqXG4gICAqIEBuYW1lIG1hdGNoXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7UmVnRXhwfSByZWdleHBcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm1hdGNoID0gZnVuY3Rpb24gKGV4cCwgcmUsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oZXhwLCBtc2cpLnRvLm1hdGNoKHJlKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5ub3RNYXRjaCh2YWx1ZSwgcmVnZXhwLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgIGRvZXMgbm90IG1hdGNoIHRoZSByZWd1bGFyIGV4cHJlc3Npb24gYHJlZ2V4cGAuXG4gICAqXG4gICAqICAgICBhc3NlcnQubm90TWF0Y2goJ2Zvb2JhcicsIC9eZm9vLywgJ3JlZ2V4cCBkb2VzIG5vdCBtYXRjaCcpO1xuICAgKlxuICAgKiBAbmFtZSBub3RNYXRjaFxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1JlZ0V4cH0gcmVnZXhwXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5ub3RNYXRjaCA9IGZ1bmN0aW9uIChleHAsIHJlLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKGV4cCwgbXNnKS50by5ub3QubWF0Y2gocmUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLnByb3BlcnR5KG9iamVjdCwgcHJvcGVydHksIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGhhcyBhIHByb3BlcnR5IG5hbWVkIGJ5IGBwcm9wZXJ0eWAuXG4gICAqXG4gICAqICAgICBhc3NlcnQucHJvcGVydHkoeyB0ZWE6IHsgZ3JlZW46ICdtYXRjaGEnIH19LCAndGVhJyk7XG4gICAqXG4gICAqIEBuYW1lIHByb3BlcnR5XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5wcm9wZXJ0eSA9IGZ1bmN0aW9uIChvYmosIHByb3AsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2cpLnRvLmhhdmUucHJvcGVydHkocHJvcCk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAubm90UHJvcGVydHkob2JqZWN0LCBwcm9wZXJ0eSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYG9iamVjdGAgZG9lcyBfbm90XyBoYXZlIGEgcHJvcGVydHkgbmFtZWQgYnkgYHByb3BlcnR5YC5cbiAgICpcbiAgICogICAgIGFzc2VydC5ub3RQcm9wZXJ0eSh7IHRlYTogeyBncmVlbjogJ21hdGNoYScgfX0sICdjb2ZmZWUnKTtcbiAgICpcbiAgICogQG5hbWUgbm90UHJvcGVydHlcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHlcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm5vdFByb3BlcnR5ID0gZnVuY3Rpb24gKG9iaiwgcHJvcCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihvYmosIG1zZykudG8ubm90LmhhdmUucHJvcGVydHkocHJvcCk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuZGVlcFByb3BlcnR5KG9iamVjdCwgcHJvcGVydHksIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGhhcyBhIHByb3BlcnR5IG5hbWVkIGJ5IGBwcm9wZXJ0eWAsIHdoaWNoIGNhbiBiZSBhXG4gICAqIHN0cmluZyB1c2luZyBkb3QtIGFuZCBicmFja2V0LW5vdGF0aW9uIGZvciBkZWVwIHJlZmVyZW5jZS5cbiAgICpcbiAgICogICAgIGFzc2VydC5kZWVwUHJvcGVydHkoeyB0ZWE6IHsgZ3JlZW46ICdtYXRjaGEnIH19LCAndGVhLmdyZWVuJyk7XG4gICAqXG4gICAqIEBuYW1lIGRlZXBQcm9wZXJ0eVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuZGVlcFByb3BlcnR5ID0gZnVuY3Rpb24gKG9iaiwgcHJvcCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihvYmosIG1zZykudG8uaGF2ZS5kZWVwLnByb3BlcnR5KHByb3ApO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLm5vdERlZXBQcm9wZXJ0eShvYmplY3QsIHByb3BlcnR5LCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBkb2VzIF9ub3RfIGhhdmUgYSBwcm9wZXJ0eSBuYW1lZCBieSBgcHJvcGVydHlgLCB3aGljaFxuICAgKiBjYW4gYmUgYSBzdHJpbmcgdXNpbmcgZG90LSBhbmQgYnJhY2tldC1ub3RhdGlvbiBmb3IgZGVlcCByZWZlcmVuY2UuXG4gICAqXG4gICAqICAgICBhc3NlcnQubm90RGVlcFByb3BlcnR5KHsgdGVhOiB7IGdyZWVuOiAnbWF0Y2hhJyB9fSwgJ3RlYS5vb2xvbmcnKTtcbiAgICpcbiAgICogQG5hbWUgbm90RGVlcFByb3BlcnR5XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5ub3REZWVwUHJvcGVydHkgPSBmdW5jdGlvbiAob2JqLCBwcm9wLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnKS50by5ub3QuaGF2ZS5kZWVwLnByb3BlcnR5KHByb3ApO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLnByb3BlcnR5VmFsKG9iamVjdCwgcHJvcGVydHksIHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBoYXMgYSBwcm9wZXJ0eSBuYW1lZCBieSBgcHJvcGVydHlgIHdpdGggdmFsdWUgZ2l2ZW5cbiAgICogYnkgYHZhbHVlYC5cbiAgICpcbiAgICogICAgIGFzc2VydC5wcm9wZXJ0eVZhbCh7IHRlYTogJ2lzIGdvb2QnIH0sICd0ZWEnLCAnaXMgZ29vZCcpO1xuICAgKlxuICAgKiBAbmFtZSBwcm9wZXJ0eVZhbFxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eVxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQucHJvcGVydHlWYWwgPSBmdW5jdGlvbiAob2JqLCBwcm9wLCB2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2cpLnRvLmhhdmUucHJvcGVydHkocHJvcCwgdmFsKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5wcm9wZXJ0eU5vdFZhbChvYmplY3QsIHByb3BlcnR5LCB2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYG9iamVjdGAgaGFzIGEgcHJvcGVydHkgbmFtZWQgYnkgYHByb3BlcnR5YCwgYnV0IHdpdGggYSB2YWx1ZVxuICAgKiBkaWZmZXJlbnQgZnJvbSB0aGF0IGdpdmVuIGJ5IGB2YWx1ZWAuXG4gICAqXG4gICAqICAgICBhc3NlcnQucHJvcGVydHlOb3RWYWwoeyB0ZWE6ICdpcyBnb29kJyB9LCAndGVhJywgJ2lzIGJhZCcpO1xuICAgKlxuICAgKiBAbmFtZSBwcm9wZXJ0eU5vdFZhbFxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eVxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQucHJvcGVydHlOb3RWYWwgPSBmdW5jdGlvbiAob2JqLCBwcm9wLCB2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2cpLnRvLm5vdC5oYXZlLnByb3BlcnR5KHByb3AsIHZhbCk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuZGVlcFByb3BlcnR5VmFsKG9iamVjdCwgcHJvcGVydHksIHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBoYXMgYSBwcm9wZXJ0eSBuYW1lZCBieSBgcHJvcGVydHlgIHdpdGggdmFsdWUgZ2l2ZW5cbiAgICogYnkgYHZhbHVlYC4gYHByb3BlcnR5YCBjYW4gdXNlIGRvdC0gYW5kIGJyYWNrZXQtbm90YXRpb24gZm9yIGRlZXBcbiAgICogcmVmZXJlbmNlLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LmRlZXBQcm9wZXJ0eVZhbCh7IHRlYTogeyBncmVlbjogJ21hdGNoYScgfX0sICd0ZWEuZ3JlZW4nLCAnbWF0Y2hhJyk7XG4gICAqXG4gICAqIEBuYW1lIGRlZXBQcm9wZXJ0eVZhbFxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eVxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuZGVlcFByb3BlcnR5VmFsID0gZnVuY3Rpb24gKG9iaiwgcHJvcCwgdmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnKS50by5oYXZlLmRlZXAucHJvcGVydHkocHJvcCwgdmFsKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5kZWVwUHJvcGVydHlOb3RWYWwob2JqZWN0LCBwcm9wZXJ0eSwgdmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGhhcyBhIHByb3BlcnR5IG5hbWVkIGJ5IGBwcm9wZXJ0eWAsIGJ1dCB3aXRoIGEgdmFsdWVcbiAgICogZGlmZmVyZW50IGZyb20gdGhhdCBnaXZlbiBieSBgdmFsdWVgLiBgcHJvcGVydHlgIGNhbiB1c2UgZG90LSBhbmRcbiAgICogYnJhY2tldC1ub3RhdGlvbiBmb3IgZGVlcCByZWZlcmVuY2UuXG4gICAqXG4gICAqICAgICBhc3NlcnQuZGVlcFByb3BlcnR5Tm90VmFsKHsgdGVhOiB7IGdyZWVuOiAnbWF0Y2hhJyB9fSwgJ3RlYS5ncmVlbicsICdrb25hY2hhJyk7XG4gICAqXG4gICAqIEBuYW1lIGRlZXBQcm9wZXJ0eU5vdFZhbFxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eVxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuZGVlcFByb3BlcnR5Tm90VmFsID0gZnVuY3Rpb24gKG9iaiwgcHJvcCwgdmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnKS50by5ub3QuaGF2ZS5kZWVwLnByb3BlcnR5KHByb3AsIHZhbCk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAubGVuZ3RoT2Yob2JqZWN0LCBsZW5ndGgsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGhhcyBhIGBsZW5ndGhgIHByb3BlcnR5IHdpdGggdGhlIGV4cGVjdGVkIHZhbHVlLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lmxlbmd0aE9mKFsxLDIsM10sIDMsICdhcnJheSBoYXMgbGVuZ3RoIG9mIDMnKTtcbiAgICogICAgIGFzc2VydC5sZW5ndGhPZignZm9vYmFyJywgNSwgJ3N0cmluZyBoYXMgbGVuZ3RoIG9mIDYnKTtcbiAgICpcbiAgICogQG5hbWUgbGVuZ3RoT2ZcbiAgICogQHBhcmFtIHtNaXhlZH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBsZW5ndGhcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lmxlbmd0aE9mID0gZnVuY3Rpb24gKGV4cCwgbGVuLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKGV4cCwgbXNnKS50by5oYXZlLmxlbmd0aChsZW4pO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLnRocm93cyhmdW5jdGlvbiwgW2NvbnN0cnVjdG9yL3N0cmluZy9yZWdleHBdLCBbc3RyaW5nL3JlZ2V4cF0sIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBmdW5jdGlvbmAgd2lsbCB0aHJvdyBhbiBlcnJvciB0aGF0IGlzIGFuIGluc3RhbmNlIG9mXG4gICAqIGBjb25zdHJ1Y3RvcmAsIG9yIGFsdGVybmF0ZWx5IHRoYXQgaXQgd2lsbCB0aHJvdyBhbiBlcnJvciB3aXRoIG1lc3NhZ2VcbiAgICogbWF0Y2hpbmcgYHJlZ2V4cGAuXG4gICAqXG4gICAqICAgICBhc3NlcnQudGhyb3coZm4sICdmdW5jdGlvbiB0aHJvd3MgYSByZWZlcmVuY2UgZXJyb3InKTtcbiAgICogICAgIGFzc2VydC50aHJvdyhmbiwgL2Z1bmN0aW9uIHRocm93cyBhIHJlZmVyZW5jZSBlcnJvci8pO1xuICAgKiAgICAgYXNzZXJ0LnRocm93KGZuLCBSZWZlcmVuY2VFcnJvcik7XG4gICAqICAgICBhc3NlcnQudGhyb3coZm4sIFJlZmVyZW5jZUVycm9yLCAnZnVuY3Rpb24gdGhyb3dzIGEgcmVmZXJlbmNlIGVycm9yJyk7XG4gICAqICAgICBhc3NlcnQudGhyb3coZm4sIFJlZmVyZW5jZUVycm9yLCAvZnVuY3Rpb24gdGhyb3dzIGEgcmVmZXJlbmNlIGVycm9yLyk7XG4gICAqXG4gICAqIEBuYW1lIHRocm93c1xuICAgKiBAYWxpYXMgdGhyb3dcbiAgICogQGFsaWFzIFRocm93XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7RXJyb3JDb25zdHJ1Y3Rvcn0gY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtSZWdFeHB9IHJlZ2V4cFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0Vycm9yI0Vycm9yX3R5cGVzXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5UaHJvdyA9IGZ1bmN0aW9uIChmbiwgZXJydCwgZXJycywgbXNnKSB7XG4gICAgaWYgKCdzdHJpbmcnID09PSB0eXBlb2YgZXJydCB8fCBlcnJ0IGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICBlcnJzID0gZXJydDtcbiAgICAgIGVycnQgPSBudWxsO1xuICAgIH1cblxuICAgIHZhciBhc3NlcnRFcnIgPSBuZXcgQXNzZXJ0aW9uKGZuLCBtc2cpLnRvLlRocm93KGVycnQsIGVycnMpO1xuICAgIHJldHVybiBmbGFnKGFzc2VydEVyciwgJ29iamVjdCcpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmRvZXNOb3RUaHJvdyhmdW5jdGlvbiwgW2NvbnN0cnVjdG9yL3JlZ2V4cF0sIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBmdW5jdGlvbmAgd2lsbCBfbm90XyB0aHJvdyBhbiBlcnJvciB0aGF0IGlzIGFuIGluc3RhbmNlIG9mXG4gICAqIGBjb25zdHJ1Y3RvcmAsIG9yIGFsdGVybmF0ZWx5IHRoYXQgaXQgd2lsbCBub3QgdGhyb3cgYW4gZXJyb3Igd2l0aCBtZXNzYWdlXG4gICAqIG1hdGNoaW5nIGByZWdleHBgLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LmRvZXNOb3RUaHJvdyhmbiwgRXJyb3IsICdmdW5jdGlvbiBkb2VzIG5vdCB0aHJvdycpO1xuICAgKlxuICAgKiBAbmFtZSBkb2VzTm90VGhyb3dcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuY3Rpb25cbiAgICogQHBhcmFtIHtFcnJvckNvbnN0cnVjdG9yfSBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge1JlZ0V4cH0gcmVnZXhwXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRXJyb3IjRXJyb3JfdHlwZXNcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmRvZXNOb3RUaHJvdyA9IGZ1bmN0aW9uIChmbiwgdHlwZSwgbXNnKSB7XG4gICAgaWYgKCdzdHJpbmcnID09PSB0eXBlb2YgdHlwZSkge1xuICAgICAgbXNnID0gdHlwZTtcbiAgICAgIHR5cGUgPSBudWxsO1xuICAgIH1cblxuICAgIG5ldyBBc3NlcnRpb24oZm4sIG1zZykudG8ubm90LlRocm93KHR5cGUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLm9wZXJhdG9yKHZhbDEsIG9wZXJhdG9yLCB2YWwyLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIENvbXBhcmVzIHR3byB2YWx1ZXMgdXNpbmcgYG9wZXJhdG9yYC5cbiAgICpcbiAgICogICAgIGFzc2VydC5vcGVyYXRvcigxLCAnPCcsIDIsICdldmVyeXRoaW5nIGlzIG9rJyk7XG4gICAqICAgICBhc3NlcnQub3BlcmF0b3IoMSwgJz4nLCAyLCAndGhpcyB3aWxsIGZhaWwnKTtcbiAgICpcbiAgICogQG5hbWUgb3BlcmF0b3JcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsMVxuICAgKiBAcGFyYW0ge1N0cmluZ30gb3BlcmF0b3JcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsMlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQub3BlcmF0b3IgPSBmdW5jdGlvbiAodmFsLCBvcGVyYXRvciwgdmFsMiwgbXNnKSB7XG4gICAgaWYgKCF+Wyc9PScsICc9PT0nLCAnPicsICc+PScsICc8JywgJzw9JywgJyE9JywgJyE9PSddLmluZGV4T2Yob3BlcmF0b3IpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgb3BlcmF0b3IgXCInICsgb3BlcmF0b3IgKyAnXCInKTtcbiAgICB9XG4gICAgdmFyIHRlc3QgPSBuZXcgQXNzZXJ0aW9uKGV2YWwodmFsICsgb3BlcmF0b3IgKyB2YWwyKSwgbXNnKTtcbiAgICB0ZXN0LmFzc2VydChcbiAgICAgICAgdHJ1ZSA9PT0gZmxhZyh0ZXN0LCAnb2JqZWN0JylcbiAgICAgICwgJ2V4cGVjdGVkICcgKyB1dGlsLmluc3BlY3QodmFsKSArICcgdG8gYmUgJyArIG9wZXJhdG9yICsgJyAnICsgdXRpbC5pbnNwZWN0KHZhbDIpXG4gICAgICAsICdleHBlY3RlZCAnICsgdXRpbC5pbnNwZWN0KHZhbCkgKyAnIHRvIG5vdCBiZSAnICsgb3BlcmF0b3IgKyAnICcgKyB1dGlsLmluc3BlY3QodmFsMikgKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5jbG9zZVRvKGFjdHVhbCwgZXhwZWN0ZWQsIGRlbHRhLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIGVxdWFsIGBleHBlY3RlZGAsIHRvIHdpdGhpbiBhICsvLSBgZGVsdGFgIHJhbmdlLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LmNsb3NlVG8oMS41LCAxLCAwLjUsICdudW1iZXJzIGFyZSBjbG9zZScpO1xuICAgKlxuICAgKiBAbmFtZSBjbG9zZVRvXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBhY3R1YWxcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGV4cGVjdGVkXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkZWx0YVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuY2xvc2VUbyA9IGZ1bmN0aW9uIChhY3QsIGV4cCwgZGVsdGEsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oYWN0LCBtc2cpLnRvLmJlLmNsb3NlVG8oZXhwLCBkZWx0YSk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuc2FtZU1lbWJlcnMoc2V0MSwgc2V0MiwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHNldDFgIGFuZCBgc2V0MmAgaGF2ZSB0aGUgc2FtZSBtZW1iZXJzLlxuICAgKiBPcmRlciBpcyBub3QgdGFrZW4gaW50byBhY2NvdW50LlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LnNhbWVNZW1iZXJzKFsgMSwgMiwgMyBdLCBbIDIsIDEsIDMgXSwgJ3NhbWUgbWVtYmVycycpO1xuICAgKlxuICAgKiBAbmFtZSBzYW1lTWVtYmVyc1xuICAgKiBAcGFyYW0ge0FycmF5fSBzdXBlcnNldFxuICAgKiBAcGFyYW0ge0FycmF5fSBzdWJzZXRcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LnNhbWVNZW1iZXJzID0gZnVuY3Rpb24gKHNldDEsIHNldDIsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oc2V0MSwgbXNnKS50by5oYXZlLnNhbWUubWVtYmVycyhzZXQyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiAjIyMgLmluY2x1ZGVNZW1iZXJzKHN1cGVyc2V0LCBzdWJzZXQsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBzdWJzZXRgIGlzIGluY2x1ZGVkIGluIGBzdXBlcnNldGAuXG4gICAqIE9yZGVyIGlzIG5vdCB0YWtlbiBpbnRvIGFjY291bnQuXG4gICAqXG4gICAqICAgICBhc3NlcnQuaW5jbHVkZU1lbWJlcnMoWyAxLCAyLCAzIF0sIFsgMiwgMSBdLCAnaW5jbHVkZSBtZW1iZXJzJyk7XG4gICAqXG4gICAqIEBuYW1lIGluY2x1ZGVNZW1iZXJzXG4gICAqIEBwYXJhbSB7QXJyYXl9IHN1cGVyc2V0XG4gICAqIEBwYXJhbSB7QXJyYXl9IHN1YnNldFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaW5jbHVkZU1lbWJlcnMgPSBmdW5jdGlvbiAoc3VwZXJzZXQsIHN1YnNldCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihzdXBlcnNldCwgbXNnKS50by5pbmNsdWRlLm1lbWJlcnMoc3Vic2V0KTtcbiAgfVxuXG4gIC8qIVxuICAgKiBVbmRvY3VtZW50ZWQgLyB1bnRlc3RlZFxuICAgKi9cblxuICBhc3NlcnQuaWZFcnJvciA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2cpLnRvLm5vdC5iZS5vaztcbiAgfTtcblxuICAvKiFcbiAgICogQWxpYXNlcy5cbiAgICovXG5cbiAgKGZ1bmN0aW9uIGFsaWFzKG5hbWUsIGFzKXtcbiAgICBhc3NlcnRbYXNdID0gYXNzZXJ0W25hbWVdO1xuICAgIHJldHVybiBhbGlhcztcbiAgfSlcbiAgKCdUaHJvdycsICd0aHJvdycpXG4gICgnVGhyb3cnLCAndGhyb3dzJyk7XG59O1xuIiwiLyohXG4gKiBjaGFpXG4gKiBDb3B5cmlnaHQoYykgMjAxMS0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY2hhaSwgdXRpbCkge1xuICBjaGFpLmV4cGVjdCA9IGZ1bmN0aW9uICh2YWwsIG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gbmV3IGNoYWkuQXNzZXJ0aW9uKHZhbCwgbWVzc2FnZSk7XG4gIH07XG59O1xuXG4iLCIvKiFcbiAqIGNoYWlcbiAqIENvcHlyaWdodChjKSAyMDExLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjaGFpLCB1dGlsKSB7XG4gIHZhciBBc3NlcnRpb24gPSBjaGFpLkFzc2VydGlvbjtcblxuICBmdW5jdGlvbiBsb2FkU2hvdWxkICgpIHtcbiAgICAvLyBleHBsaWNpdGx5IGRlZmluZSB0aGlzIG1ldGhvZCBhcyBmdW5jdGlvbiBhcyB0byBoYXZlIGl0J3MgbmFtZSB0byBpbmNsdWRlIGFzIGBzc2ZpYFxuICAgIGZ1bmN0aW9uIHNob3VsZEdldHRlcigpIHtcbiAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgU3RyaW5nIHx8IHRoaXMgaW5zdGFuY2VvZiBOdW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBc3NlcnRpb24odGhpcy5jb25zdHJ1Y3Rvcih0aGlzKSwgbnVsbCwgc2hvdWxkR2V0dGVyKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcyBpbnN0YW5jZW9mIEJvb2xlYW4pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBc3NlcnRpb24odGhpcyA9PSB0cnVlLCBudWxsLCBzaG91bGRHZXR0ZXIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBBc3NlcnRpb24odGhpcywgbnVsbCwgc2hvdWxkR2V0dGVyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2hvdWxkU2V0dGVyKHZhbHVlKSB7XG4gICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2NoYWlqcy9jaGFpL2lzc3Vlcy84NjogdGhpcyBtYWtlc1xuICAgICAgLy8gYHdoYXRldmVyLnNob3VsZCA9IHNvbWVWYWx1ZWAgYWN0dWFsbHkgc2V0IGBzb21lVmFsdWVgLCB3aGljaCBpc1xuICAgICAgLy8gZXNwZWNpYWxseSB1c2VmdWwgZm9yIGBnbG9iYWwuc2hvdWxkID0gcmVxdWlyZSgnY2hhaScpLnNob3VsZCgpYC5cbiAgICAgIC8vXG4gICAgICAvLyBOb3RlIHRoYXQgd2UgaGF2ZSB0byB1c2UgW1tEZWZpbmVQcm9wZXJ0eV1dIGluc3RlYWQgb2YgW1tQdXRdXVxuICAgICAgLy8gc2luY2Ugb3RoZXJ3aXNlIHdlIHdvdWxkIHRyaWdnZXIgdGhpcyB2ZXJ5IHNldHRlciFcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnc2hvdWxkJywge1xuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBtb2RpZnkgT2JqZWN0LnByb3RvdHlwZSB0byBoYXZlIGBzaG91bGRgXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE9iamVjdC5wcm90b3R5cGUsICdzaG91bGQnLCB7XG4gICAgICBzZXQ6IHNob3VsZFNldHRlclxuICAgICAgLCBnZXQ6IHNob3VsZEdldHRlclxuICAgICAgLCBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcblxuICAgIHZhciBzaG91bGQgPSB7fTtcblxuICAgIHNob3VsZC5lcXVhbCA9IGZ1bmN0aW9uICh2YWwxLCB2YWwyLCBtc2cpIHtcbiAgICAgIG5ldyBBc3NlcnRpb24odmFsMSwgbXNnKS50by5lcXVhbCh2YWwyKTtcbiAgICB9O1xuXG4gICAgc2hvdWxkLlRocm93ID0gZnVuY3Rpb24gKGZuLCBlcnJ0LCBlcnJzLCBtc2cpIHtcbiAgICAgIG5ldyBBc3NlcnRpb24oZm4sIG1zZykudG8uVGhyb3coZXJydCwgZXJycyk7XG4gICAgfTtcblxuICAgIHNob3VsZC5leGlzdCA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZykudG8uZXhpc3Q7XG4gICAgfVxuXG4gICAgLy8gbmVnYXRpb25cbiAgICBzaG91bGQubm90ID0ge31cblxuICAgIHNob3VsZC5ub3QuZXF1YWwgPSBmdW5jdGlvbiAodmFsMSwgdmFsMiwgbXNnKSB7XG4gICAgICBuZXcgQXNzZXJ0aW9uKHZhbDEsIG1zZykudG8ubm90LmVxdWFsKHZhbDIpO1xuICAgIH07XG5cbiAgICBzaG91bGQubm90LlRocm93ID0gZnVuY3Rpb24gKGZuLCBlcnJ0LCBlcnJzLCBtc2cpIHtcbiAgICAgIG5ldyBBc3NlcnRpb24oZm4sIG1zZykudG8ubm90LlRocm93KGVycnQsIGVycnMpO1xuICAgIH07XG5cbiAgICBzaG91bGQubm90LmV4aXN0ID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnKS50by5ub3QuZXhpc3Q7XG4gICAgfVxuXG4gICAgc2hvdWxkWyd0aHJvdyddID0gc2hvdWxkWydUaHJvdyddO1xuICAgIHNob3VsZC5ub3RbJ3Rocm93J10gPSBzaG91bGQubm90WydUaHJvdyddO1xuXG4gICAgcmV0dXJuIHNob3VsZDtcbiAgfTtcblxuICBjaGFpLnNob3VsZCA9IGxvYWRTaG91bGQ7XG4gIGNoYWkuU2hvdWxkID0gbG9hZFNob3VsZDtcbn07XG4iLCIvKiFcbiAqIENoYWkgLSBhZGRDaGFpbmluZ01ldGhvZCB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyohXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzXG4gKi9cblxudmFyIHRyYW5zZmVyRmxhZ3MgPSByZXF1aXJlKCcuL3RyYW5zZmVyRmxhZ3MnKTtcbnZhciBmbGFnID0gcmVxdWlyZSgnLi9mbGFnJyk7XG52YXIgY29uZmlnID0gcmVxdWlyZSgnLi4vY29uZmlnJyk7XG5cbi8qIVxuICogTW9kdWxlIHZhcmlhYmxlc1xuICovXG5cbi8vIENoZWNrIHdoZXRoZXIgYF9fcHJvdG9fX2AgaXMgc3VwcG9ydGVkXG52YXIgaGFzUHJvdG9TdXBwb3J0ID0gJ19fcHJvdG9fXycgaW4gT2JqZWN0O1xuXG4vLyBXaXRob3V0IGBfX3Byb3RvX19gIHN1cHBvcnQsIHRoaXMgbW9kdWxlIHdpbGwgbmVlZCB0byBhZGQgcHJvcGVydGllcyB0byBhIGZ1bmN0aW9uLlxuLy8gSG93ZXZlciwgc29tZSBGdW5jdGlvbi5wcm90b3R5cGUgbWV0aG9kcyBjYW5ub3QgYmUgb3ZlcndyaXR0ZW4sXG4vLyBhbmQgdGhlcmUgc2VlbXMgbm8gZWFzeSBjcm9zcy1wbGF0Zm9ybSB3YXkgdG8gZGV0ZWN0IHRoZW0gKEBzZWUgY2hhaWpzL2NoYWkvaXNzdWVzLzY5KS5cbnZhciBleGNsdWRlTmFtZXMgPSAvXig/Omxlbmd0aHxuYW1lfGFyZ3VtZW50c3xjYWxsZXIpJC87XG5cbi8vIENhY2hlIGBGdW5jdGlvbmAgcHJvcGVydGllc1xudmFyIGNhbGwgID0gRnVuY3Rpb24ucHJvdG90eXBlLmNhbGwsXG4gICAgYXBwbHkgPSBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHk7XG5cbi8qKlxuICogIyMjIGFkZENoYWluYWJsZU1ldGhvZCAoY3R4LCBuYW1lLCBtZXRob2QsIGNoYWluaW5nQmVoYXZpb3IpXG4gKlxuICogQWRkcyBhIG1ldGhvZCB0byBhbiBvYmplY3QsIHN1Y2ggdGhhdCB0aGUgbWV0aG9kIGNhbiBhbHNvIGJlIGNoYWluZWQuXG4gKlxuICogICAgIHV0aWxzLmFkZENoYWluYWJsZU1ldGhvZChjaGFpLkFzc2VydGlvbi5wcm90b3R5cGUsICdmb28nLCBmdW5jdGlvbiAoc3RyKSB7XG4gKiAgICAgICB2YXIgb2JqID0gdXRpbHMuZmxhZyh0aGlzLCAnb2JqZWN0Jyk7XG4gKiAgICAgICBuZXcgY2hhaS5Bc3NlcnRpb24ob2JqKS50by5iZS5lcXVhbChzdHIpO1xuICogICAgIH0pO1xuICpcbiAqIENhbiBhbHNvIGJlIGFjY2Vzc2VkIGRpcmVjdGx5IGZyb20gYGNoYWkuQXNzZXJ0aW9uYC5cbiAqXG4gKiAgICAgY2hhaS5Bc3NlcnRpb24uYWRkQ2hhaW5hYmxlTWV0aG9kKCdmb28nLCBmbiwgY2hhaW5pbmdCZWhhdmlvcik7XG4gKlxuICogVGhlIHJlc3VsdCBjYW4gdGhlbiBiZSB1c2VkIGFzIGJvdGggYSBtZXRob2QgYXNzZXJ0aW9uLCBleGVjdXRpbmcgYm90aCBgbWV0aG9kYCBhbmRcbiAqIGBjaGFpbmluZ0JlaGF2aW9yYCwgb3IgYXMgYSBsYW5ndWFnZSBjaGFpbiwgd2hpY2ggb25seSBleGVjdXRlcyBgY2hhaW5pbmdCZWhhdmlvcmAuXG4gKlxuICogICAgIGV4cGVjdChmb29TdHIpLnRvLmJlLmZvbygnYmFyJyk7XG4gKiAgICAgZXhwZWN0KGZvb1N0cikudG8uYmUuZm9vLmVxdWFsKCdmb28nKTtcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY3R4IG9iamVjdCB0byB3aGljaCB0aGUgbWV0aG9kIGlzIGFkZGVkXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBvZiBtZXRob2QgdG8gYWRkXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBtZXRob2QgZnVuY3Rpb24gdG8gYmUgdXNlZCBmb3IgYG5hbWVgLCB3aGVuIGNhbGxlZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2hhaW5pbmdCZWhhdmlvciBmdW5jdGlvbiB0byBiZSBjYWxsZWQgZXZlcnkgdGltZSB0aGUgcHJvcGVydHkgaXMgYWNjZXNzZWRcbiAqIEBuYW1lIGFkZENoYWluYWJsZU1ldGhvZFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjdHgsIG5hbWUsIG1ldGhvZCwgY2hhaW5pbmdCZWhhdmlvcikge1xuICBpZiAodHlwZW9mIGNoYWluaW5nQmVoYXZpb3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICBjaGFpbmluZ0JlaGF2aW9yID0gZnVuY3Rpb24gKCkgeyB9O1xuICB9XG5cbiAgdmFyIGNoYWluYWJsZUJlaGF2aW9yID0ge1xuICAgICAgbWV0aG9kOiBtZXRob2RcbiAgICAsIGNoYWluaW5nQmVoYXZpb3I6IGNoYWluaW5nQmVoYXZpb3JcbiAgfTtcblxuICAvLyBzYXZlIHRoZSBtZXRob2RzIHNvIHdlIGNhbiBvdmVyd3JpdGUgdGhlbSBsYXRlciwgaWYgd2UgbmVlZCB0by5cbiAgaWYgKCFjdHguX19tZXRob2RzKSB7XG4gICAgY3R4Ll9fbWV0aG9kcyA9IHt9O1xuICB9XG4gIGN0eC5fX21ldGhvZHNbbmFtZV0gPSBjaGFpbmFibGVCZWhhdmlvcjtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3R4LCBuYW1lLFxuICAgIHsgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNoYWluYWJsZUJlaGF2aW9yLmNoYWluaW5nQmVoYXZpb3IuY2FsbCh0aGlzKTtcblxuICAgICAgICB2YXIgYXNzZXJ0ID0gZnVuY3Rpb24gYXNzZXJ0KCkge1xuICAgICAgICAgIHZhciBvbGRfc3NmaSA9IGZsYWcodGhpcywgJ3NzZmknKTtcbiAgICAgICAgICBpZiAob2xkX3NzZmkgJiYgY29uZmlnLmluY2x1ZGVTdGFjayA9PT0gZmFsc2UpXG4gICAgICAgICAgICBmbGFnKHRoaXMsICdzc2ZpJywgYXNzZXJ0KTtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gY2hhaW5hYmxlQmVoYXZpb3IubWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gdGhpcyA6IHJlc3VsdDtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBVc2UgYF9fcHJvdG9fX2AgaWYgYXZhaWxhYmxlXG4gICAgICAgIGlmIChoYXNQcm90b1N1cHBvcnQpIHtcbiAgICAgICAgICAvLyBJbmhlcml0IGFsbCBwcm9wZXJ0aWVzIGZyb20gdGhlIG9iamVjdCBieSByZXBsYWNpbmcgdGhlIGBGdW5jdGlvbmAgcHJvdG90eXBlXG4gICAgICAgICAgdmFyIHByb3RvdHlwZSA9IGFzc2VydC5fX3Byb3RvX18gPSBPYmplY3QuY3JlYXRlKHRoaXMpO1xuICAgICAgICAgIC8vIFJlc3RvcmUgdGhlIGBjYWxsYCBhbmQgYGFwcGx5YCBtZXRob2RzIGZyb20gYEZ1bmN0aW9uYFxuICAgICAgICAgIHByb3RvdHlwZS5jYWxsID0gY2FsbDtcbiAgICAgICAgICBwcm90b3R5cGUuYXBwbHkgPSBhcHBseTtcbiAgICAgICAgfVxuICAgICAgICAvLyBPdGhlcndpc2UsIHJlZGVmaW5lIGFsbCBwcm9wZXJ0aWVzIChzbG93ISlcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdmFyIGFzc2VydGVyTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhjdHgpO1xuICAgICAgICAgIGFzc2VydGVyTmFtZXMuZm9yRWFjaChmdW5jdGlvbiAoYXNzZXJ0ZXJOYW1lKSB7XG4gICAgICAgICAgICBpZiAoIWV4Y2x1ZGVOYW1lcy50ZXN0KGFzc2VydGVyTmFtZSkpIHtcbiAgICAgICAgICAgICAgdmFyIHBkID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjdHgsIGFzc2VydGVyTmFtZSk7XG4gICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhc3NlcnQsIGFzc2VydGVyTmFtZSwgcGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJhbnNmZXJGbGFncyh0aGlzLCBhc3NlcnQpO1xuICAgICAgICByZXR1cm4gYXNzZXJ0O1xuICAgICAgfVxuICAgICwgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufTtcbiIsIi8qIVxuICogQ2hhaSAtIGFkZE1ldGhvZCB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxudmFyIGNvbmZpZyA9IHJlcXVpcmUoJy4uL2NvbmZpZycpO1xuXG4vKipcbiAqICMjIyAuYWRkTWV0aG9kIChjdHgsIG5hbWUsIG1ldGhvZClcbiAqXG4gKiBBZGRzIGEgbWV0aG9kIHRvIHRoZSBwcm90b3R5cGUgb2YgYW4gb2JqZWN0LlxuICpcbiAqICAgICB1dGlscy5hZGRNZXRob2QoY2hhaS5Bc3NlcnRpb24ucHJvdG90eXBlLCAnZm9vJywgZnVuY3Rpb24gKHN0cikge1xuICogICAgICAgdmFyIG9iaiA9IHV0aWxzLmZsYWcodGhpcywgJ29iamVjdCcpO1xuICogICAgICAgbmV3IGNoYWkuQXNzZXJ0aW9uKG9iaikudG8uYmUuZXF1YWwoc3RyKTtcbiAqICAgICB9KTtcbiAqXG4gKiBDYW4gYWxzbyBiZSBhY2Nlc3NlZCBkaXJlY3RseSBmcm9tIGBjaGFpLkFzc2VydGlvbmAuXG4gKlxuICogICAgIGNoYWkuQXNzZXJ0aW9uLmFkZE1ldGhvZCgnZm9vJywgZm4pO1xuICpcbiAqIFRoZW4gY2FuIGJlIHVzZWQgYXMgYW55IG90aGVyIGFzc2VydGlvbi5cbiAqXG4gKiAgICAgZXhwZWN0KGZvb1N0cikudG8uYmUuZm9vKCdiYXInKTtcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY3R4IG9iamVjdCB0byB3aGljaCB0aGUgbWV0aG9kIGlzIGFkZGVkXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBvZiBtZXRob2QgdG8gYWRkXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBtZXRob2QgZnVuY3Rpb24gdG8gYmUgdXNlZCBmb3IgbmFtZVxuICogQG5hbWUgYWRkTWV0aG9kXG4gKiBAYXBpIHB1YmxpY1xuICovXG52YXIgZmxhZyA9IHJlcXVpcmUoJy4vZmxhZycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjdHgsIG5hbWUsIG1ldGhvZCkge1xuICBjdHhbbmFtZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9sZF9zc2ZpID0gZmxhZyh0aGlzLCAnc3NmaScpO1xuICAgIGlmIChvbGRfc3NmaSAmJiBjb25maWcuaW5jbHVkZVN0YWNrID09PSBmYWxzZSlcbiAgICAgIGZsYWcodGhpcywgJ3NzZmknLCBjdHhbbmFtZV0pO1xuICAgIHZhciByZXN1bHQgPSBtZXRob2QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICByZXR1cm4gcmVzdWx0ID09PSB1bmRlZmluZWQgPyB0aGlzIDogcmVzdWx0O1xuICB9O1xufTtcbiIsIi8qIVxuICogQ2hhaSAtIGFkZFByb3BlcnR5IHV0aWxpdHlcbiAqIENvcHlyaWdodChjKSAyMDEyLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4vKipcbiAqICMjIyBhZGRQcm9wZXJ0eSAoY3R4LCBuYW1lLCBnZXR0ZXIpXG4gKlxuICogQWRkcyBhIHByb3BlcnR5IHRvIHRoZSBwcm90b3R5cGUgb2YgYW4gb2JqZWN0LlxuICpcbiAqICAgICB1dGlscy5hZGRQcm9wZXJ0eShjaGFpLkFzc2VydGlvbi5wcm90b3R5cGUsICdmb28nLCBmdW5jdGlvbiAoKSB7XG4gKiAgICAgICB2YXIgb2JqID0gdXRpbHMuZmxhZyh0aGlzLCAnb2JqZWN0Jyk7XG4gKiAgICAgICBuZXcgY2hhaS5Bc3NlcnRpb24ob2JqKS50by5iZS5pbnN0YW5jZW9mKEZvbyk7XG4gKiAgICAgfSk7XG4gKlxuICogQ2FuIGFsc28gYmUgYWNjZXNzZWQgZGlyZWN0bHkgZnJvbSBgY2hhaS5Bc3NlcnRpb25gLlxuICpcbiAqICAgICBjaGFpLkFzc2VydGlvbi5hZGRQcm9wZXJ0eSgnZm9vJywgZm4pO1xuICpcbiAqIFRoZW4gY2FuIGJlIHVzZWQgYXMgYW55IG90aGVyIGFzc2VydGlvbi5cbiAqXG4gKiAgICAgZXhwZWN0KG15Rm9vKS50by5iZS5mb287XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGN0eCBvYmplY3QgdG8gd2hpY2ggdGhlIHByb3BlcnR5IGlzIGFkZGVkXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBvZiBwcm9wZXJ0eSB0byBhZGRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGdldHRlciBmdW5jdGlvbiB0byBiZSB1c2VkIGZvciBuYW1lXG4gKiBAbmFtZSBhZGRQcm9wZXJ0eVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjdHgsIG5hbWUsIGdldHRlcikge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3R4LCBuYW1lLFxuICAgIHsgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBnZXR0ZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gdGhpcyA6IHJlc3VsdDtcbiAgICAgIH1cbiAgICAsIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn07XG4iLCIvKiFcbiAqIENoYWkgLSBmbGFnIHV0aWxpdHlcbiAqIENvcHlyaWdodChjKSAyMDEyLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4vKipcbiAqICMjIyBmbGFnKG9iamVjdCAsa2V5LCBbdmFsdWVdKVxuICpcbiAqIEdldCBvciBzZXQgYSBmbGFnIHZhbHVlIG9uIGFuIG9iamVjdC4gSWYgYVxuICogdmFsdWUgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSBzZXQsIGVsc2UgaXQgd2lsbFxuICogcmV0dXJuIHRoZSBjdXJyZW50bHkgc2V0IHZhbHVlIG9yIGB1bmRlZmluZWRgIGlmXG4gKiB0aGUgdmFsdWUgaXMgbm90IHNldC5cbiAqXG4gKiAgICAgdXRpbHMuZmxhZyh0aGlzLCAnZm9vJywgJ2JhcicpOyAvLyBzZXR0ZXJcbiAqICAgICB1dGlscy5mbGFnKHRoaXMsICdmb28nKTsgLy8gZ2V0dGVyLCByZXR1cm5zIGBiYXJgXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCAoY29uc3RydWN0ZWQgQXNzZXJ0aW9uXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKiBAcGFyYW0ge01peGVkfSB2YWx1ZSAob3B0aW9uYWwpXG4gKiBAbmFtZSBmbGFnXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmosIGtleSwgdmFsdWUpIHtcbiAgdmFyIGZsYWdzID0gb2JqLl9fZmxhZ3MgfHwgKG9iai5fX2ZsYWdzID0gT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgZmxhZ3Nba2V5XSA9IHZhbHVlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmbGFnc1trZXldO1xuICB9XG59O1xuIiwiLyohXG4gKiBDaGFpIC0gZ2V0QWN0dWFsIHV0aWxpdHlcbiAqIENvcHlyaWdodChjKSAyMDEyLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4vKipcbiAqICMgZ2V0QWN0dWFsKG9iamVjdCwgW2FjdHVhbF0pXG4gKlxuICogUmV0dXJucyB0aGUgYGFjdHVhbGAgdmFsdWUgZm9yIGFuIEFzc2VydGlvblxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgKGNvbnN0cnVjdGVkIEFzc2VydGlvbilcbiAqIEBwYXJhbSB7QXJndW1lbnRzfSBjaGFpLkFzc2VydGlvbi5wcm90b3R5cGUuYXNzZXJ0IGFyZ3VtZW50c1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iaiwgYXJncykge1xuICByZXR1cm4gYXJncy5sZW5ndGggPiA0ID8gYXJnc1s0XSA6IG9iai5fb2JqO1xufTtcbiIsIi8qIVxuICogQ2hhaSAtIGdldEVudW1lcmFibGVQcm9wZXJ0aWVzIHV0aWxpdHlcbiAqIENvcHlyaWdodChjKSAyMDEyLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4vKipcbiAqICMjIyAuZ2V0RW51bWVyYWJsZVByb3BlcnRpZXMob2JqZWN0KVxuICpcbiAqIFRoaXMgYWxsb3dzIHRoZSByZXRyaWV2YWwgb2YgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBhbiBvYmplY3QsXG4gKiBpbmhlcml0ZWQgb3Igbm90LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqIEBuYW1lIGdldEVudW1lcmFibGVQcm9wZXJ0aWVzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0RW51bWVyYWJsZVByb3BlcnRpZXMob2JqZWN0KSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yICh2YXIgbmFtZSBpbiBvYmplY3QpIHtcbiAgICByZXN1bHQucHVzaChuYW1lKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcbiIsIi8qIVxuICogQ2hhaSAtIG1lc3NhZ2UgY29tcG9zaXRpb24gdXRpbGl0eVxuICogQ29weXJpZ2h0KGMpIDIwMTItMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qIVxuICogTW9kdWxlIGRlcGVuZGFuY2llc1xuICovXG5cbnZhciBmbGFnID0gcmVxdWlyZSgnLi9mbGFnJylcbiAgLCBnZXRBY3R1YWwgPSByZXF1aXJlKCcuL2dldEFjdHVhbCcpXG4gICwgaW5zcGVjdCA9IHJlcXVpcmUoJy4vaW5zcGVjdCcpXG4gICwgb2JqRGlzcGxheSA9IHJlcXVpcmUoJy4vb2JqRGlzcGxheScpO1xuXG4vKipcbiAqICMjIyAuZ2V0TWVzc2FnZShvYmplY3QsIG1lc3NhZ2UsIG5lZ2F0ZU1lc3NhZ2UpXG4gKlxuICogQ29uc3RydWN0IHRoZSBlcnJvciBtZXNzYWdlIGJhc2VkIG9uIGZsYWdzXG4gKiBhbmQgdGVtcGxhdGUgdGFncy4gVGVtcGxhdGUgdGFncyB3aWxsIHJldHVyblxuICogYSBzdHJpbmdpZmllZCBpbnNwZWN0aW9uIG9mIHRoZSBvYmplY3QgcmVmZXJlbmNlZC5cbiAqXG4gKiBNZXNzYWdlIHRlbXBsYXRlIHRhZ3M6XG4gKiAtIGAje3RoaXN9YCBjdXJyZW50IGFzc2VydGVkIG9iamVjdFxuICogLSBgI3thY3R9YCBhY3R1YWwgdmFsdWVcbiAqIC0gYCN7ZXhwfWAgZXhwZWN0ZWQgdmFsdWVcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IChjb25zdHJ1Y3RlZCBBc3NlcnRpb24pXG4gKiBAcGFyYW0ge0FyZ3VtZW50c30gY2hhaS5Bc3NlcnRpb24ucHJvdG90eXBlLmFzc2VydCBhcmd1bWVudHNcbiAqIEBuYW1lIGdldE1lc3NhZ2VcbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqLCBhcmdzKSB7XG4gIHZhciBuZWdhdGUgPSBmbGFnKG9iaiwgJ25lZ2F0ZScpXG4gICAgLCB2YWwgPSBmbGFnKG9iaiwgJ29iamVjdCcpXG4gICAgLCBleHBlY3RlZCA9IGFyZ3NbM11cbiAgICAsIGFjdHVhbCA9IGdldEFjdHVhbChvYmosIGFyZ3MpXG4gICAgLCBtc2cgPSBuZWdhdGUgPyBhcmdzWzJdIDogYXJnc1sxXVxuICAgICwgZmxhZ01zZyA9IGZsYWcob2JqLCAnbWVzc2FnZScpO1xuXG4gIG1zZyA9IG1zZyB8fCAnJztcbiAgbXNnID0gbXNnXG4gICAgLnJlcGxhY2UoLyN7dGhpc30vZywgb2JqRGlzcGxheSh2YWwpKVxuICAgIC5yZXBsYWNlKC8je2FjdH0vZywgb2JqRGlzcGxheShhY3R1YWwpKVxuICAgIC5yZXBsYWNlKC8je2V4cH0vZywgb2JqRGlzcGxheShleHBlY3RlZCkpO1xuXG4gIHJldHVybiBmbGFnTXNnID8gZmxhZ01zZyArICc6ICcgKyBtc2cgOiBtc2c7XG59O1xuIiwiLyohXG4gKiBDaGFpIC0gZ2V0TmFtZSB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyoqXG4gKiAjIGdldE5hbWUoZnVuYylcbiAqXG4gKiBHZXRzIHRoZSBuYW1lIG9mIGEgZnVuY3Rpb24sIGluIGEgY3Jvc3MtYnJvd3NlciB3YXkuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gYSBmdW5jdGlvbiAodXN1YWxseSBhIGNvbnN0cnVjdG9yKVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGZ1bmMpIHtcbiAgaWYgKGZ1bmMubmFtZSkgcmV0dXJuIGZ1bmMubmFtZTtcblxuICB2YXIgbWF0Y2ggPSAvXlxccz9mdW5jdGlvbiAoW14oXSopXFwoLy5leGVjKGZ1bmMpO1xuICByZXR1cm4gbWF0Y2ggJiYgbWF0Y2hbMV0gPyBtYXRjaFsxXSA6IFwiXCI7XG59O1xuIiwiLyohXG4gKiBDaGFpIC0gZ2V0UGF0aFZhbHVlIHV0aWxpdHlcbiAqIENvcHlyaWdodChjKSAyMDEyLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9sb2dpY2FscGFyYWRveC9maWx0clxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyoqXG4gKiAjIyMgLmdldFBhdGhWYWx1ZShwYXRoLCBvYmplY3QpXG4gKlxuICogVGhpcyBhbGxvd3MgdGhlIHJldHJpZXZhbCBvZiB2YWx1ZXMgaW4gYW5cbiAqIG9iamVjdCBnaXZlbiBhIHN0cmluZyBwYXRoLlxuICpcbiAqICAgICB2YXIgb2JqID0ge1xuICogICAgICAgICBwcm9wMToge1xuICogICAgICAgICAgICAgYXJyOiBbJ2EnLCAnYicsICdjJ11cbiAqICAgICAgICAgICAsIHN0cjogJ0hlbGxvJ1xuICogICAgICAgICB9XG4gKiAgICAgICAsIHByb3AyOiB7XG4gKiAgICAgICAgICAgICBhcnI6IFsgeyBuZXN0ZWQ6ICdVbml2ZXJzZScgfSBdXG4gKiAgICAgICAgICAgLCBzdHI6ICdIZWxsbyBhZ2FpbiEnXG4gKiAgICAgICAgIH1cbiAqICAgICB9XG4gKlxuICogVGhlIGZvbGxvd2luZyB3b3VsZCBiZSB0aGUgcmVzdWx0cy5cbiAqXG4gKiAgICAgZ2V0UGF0aFZhbHVlKCdwcm9wMS5zdHInLCBvYmopOyAvLyBIZWxsb1xuICogICAgIGdldFBhdGhWYWx1ZSgncHJvcDEuYXR0WzJdJywgb2JqKTsgLy8gYlxuICogICAgIGdldFBhdGhWYWx1ZSgncHJvcDIuYXJyWzBdLm5lc3RlZCcsIG9iaik7IC8vIFVuaXZlcnNlXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm5zIHtPYmplY3R9IHZhbHVlIG9yIGB1bmRlZmluZWRgXG4gKiBAbmFtZSBnZXRQYXRoVmFsdWVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxudmFyIGdldFBhdGhWYWx1ZSA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHBhdGgsIG9iaikge1xuICB2YXIgcGFyc2VkID0gcGFyc2VQYXRoKHBhdGgpO1xuICByZXR1cm4gX2dldFBhdGhWYWx1ZShwYXJzZWQsIG9iaik7XG59O1xuXG4vKiFcbiAqICMjIHBhcnNlUGF0aChwYXRoKVxuICpcbiAqIEhlbHBlciBmdW5jdGlvbiB1c2VkIHRvIHBhcnNlIHN0cmluZyBvYmplY3RcbiAqIHBhdGhzLiBVc2UgaW4gY29uanVuY3Rpb24gd2l0aCBgX2dldFBhdGhWYWx1ZWAuXG4gKlxuICogICAgICB2YXIgcGFyc2VkID0gcGFyc2VQYXRoKCdteW9iamVjdC5wcm9wZXJ0eS5zdWJwcm9wJyk7XG4gKlxuICogIyMjIFBhdGhzOlxuICpcbiAqICogQ2FuIGJlIGFzIG5lYXIgaW5maW5pdGVseSBkZWVwIGFuZCBuZXN0ZWRcbiAqICogQXJyYXlzIGFyZSBhbHNvIHZhbGlkIHVzaW5nIHRoZSBmb3JtYWwgYG15b2JqZWN0LmRvY3VtZW50WzNdLnByb3BlcnR5YC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICogQHJldHVybnMge09iamVjdH0gcGFyc2VkXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZVBhdGggKHBhdGgpIHtcbiAgdmFyIHN0ciA9IHBhdGgucmVwbGFjZSgvXFxbL2csICcuWycpXG4gICAgLCBwYXJ0cyA9IHN0ci5tYXRjaCgvKFxcXFxcXC58W14uXSs/KSsvZyk7XG4gIHJldHVybiBwYXJ0cy5tYXAoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdmFyIHJlID0gL1xcWyhcXGQrKVxcXSQvXG4gICAgICAsIG1BcnIgPSByZS5leGVjKHZhbHVlKVxuICAgIGlmIChtQXJyKSByZXR1cm4geyBpOiBwYXJzZUZsb2F0KG1BcnJbMV0pIH07XG4gICAgZWxzZSByZXR1cm4geyBwOiB2YWx1ZSB9O1xuICB9KTtcbn07XG5cbi8qIVxuICogIyMgX2dldFBhdGhWYWx1ZShwYXJzZWQsIG9iailcbiAqXG4gKiBIZWxwZXIgY29tcGFuaW9uIGZ1bmN0aW9uIGZvciBgLnBhcnNlUGF0aGAgdGhhdCByZXR1cm5zXG4gKiB0aGUgdmFsdWUgbG9jYXRlZCBhdCB0aGUgcGFyc2VkIGFkZHJlc3MuXG4gKlxuICogICAgICB2YXIgdmFsdWUgPSBnZXRQYXRoVmFsdWUocGFyc2VkLCBvYmopO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXJzZWQgZGVmaW5pdGlvbiBmcm9tIGBwYXJzZVBhdGhgLlxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCB0byBzZWFyY2ggYWdhaW5zdFxuICogQHJldHVybnMge09iamVjdHxVbmRlZmluZWR9IHZhbHVlXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBfZ2V0UGF0aFZhbHVlIChwYXJzZWQsIG9iaikge1xuICB2YXIgdG1wID0gb2JqXG4gICAgLCByZXM7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gcGFyc2VkLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHZhciBwYXJ0ID0gcGFyc2VkW2ldO1xuICAgIGlmICh0bXApIHtcbiAgICAgIGlmICgndW5kZWZpbmVkJyAhPT0gdHlwZW9mIHBhcnQucClcbiAgICAgICAgdG1wID0gdG1wW3BhcnQucF07XG4gICAgICBlbHNlIGlmICgndW5kZWZpbmVkJyAhPT0gdHlwZW9mIHBhcnQuaSlcbiAgICAgICAgdG1wID0gdG1wW3BhcnQuaV07XG4gICAgICBpZiAoaSA9PSAobCAtIDEpKSByZXMgPSB0bXA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcztcbn07XG4iLCIvKiFcbiAqIENoYWkgLSBnZXRQcm9wZXJ0aWVzIHV0aWxpdHlcbiAqIENvcHlyaWdodChjKSAyMDEyLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4vKipcbiAqICMjIyAuZ2V0UHJvcGVydGllcyhvYmplY3QpXG4gKlxuICogVGhpcyBhbGxvd3MgdGhlIHJldHJpZXZhbCBvZiBwcm9wZXJ0eSBuYW1lcyBvZiBhbiBvYmplY3QsIGVudW1lcmFibGUgb3Igbm90LFxuICogaW5oZXJpdGVkIG9yIG5vdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKiBAbmFtZSBnZXRQcm9wZXJ0aWVzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0UHJvcGVydGllcyhvYmplY3QpIHtcbiAgdmFyIHJlc3VsdCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHN1YmplY3QpO1xuXG4gIGZ1bmN0aW9uIGFkZFByb3BlcnR5KHByb3BlcnR5KSB7XG4gICAgaWYgKHJlc3VsdC5pbmRleE9mKHByb3BlcnR5KSA9PT0gLTEpIHtcbiAgICAgIHJlc3VsdC5wdXNoKHByb3BlcnR5KTtcbiAgICB9XG4gIH1cblxuICB2YXIgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yoc3ViamVjdCk7XG4gIHdoaWxlIChwcm90byAhPT0gbnVsbCkge1xuICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHByb3RvKS5mb3JFYWNoKGFkZFByb3BlcnR5KTtcbiAgICBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihwcm90byk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcbiIsIi8qIVxuICogY2hhaVxuICogQ29weXJpZ2h0KGMpIDIwMTEgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4vKiFcbiAqIE1haW4gZXhwb3J0c1xuICovXG5cbnZhciBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLyohXG4gKiB0ZXN0IHV0aWxpdHlcbiAqL1xuXG5leHBvcnRzLnRlc3QgPSByZXF1aXJlKCcuL3Rlc3QnKTtcblxuLyohXG4gKiB0eXBlIHV0aWxpdHlcbiAqL1xuXG5leHBvcnRzLnR5cGUgPSByZXF1aXJlKCcuL3R5cGUnKTtcblxuLyohXG4gKiBtZXNzYWdlIHV0aWxpdHlcbiAqL1xuXG5leHBvcnRzLmdldE1lc3NhZ2UgPSByZXF1aXJlKCcuL2dldE1lc3NhZ2UnKTtcblxuLyohXG4gKiBhY3R1YWwgdXRpbGl0eVxuICovXG5cbmV4cG9ydHMuZ2V0QWN0dWFsID0gcmVxdWlyZSgnLi9nZXRBY3R1YWwnKTtcblxuLyohXG4gKiBJbnNwZWN0IHV0aWxcbiAqL1xuXG5leHBvcnRzLmluc3BlY3QgPSByZXF1aXJlKCcuL2luc3BlY3QnKTtcblxuLyohXG4gKiBPYmplY3QgRGlzcGxheSB1dGlsXG4gKi9cblxuZXhwb3J0cy5vYmpEaXNwbGF5ID0gcmVxdWlyZSgnLi9vYmpEaXNwbGF5Jyk7XG5cbi8qIVxuICogRmxhZyB1dGlsaXR5XG4gKi9cblxuZXhwb3J0cy5mbGFnID0gcmVxdWlyZSgnLi9mbGFnJyk7XG5cbi8qIVxuICogRmxhZyB0cmFuc2ZlcnJpbmcgdXRpbGl0eVxuICovXG5cbmV4cG9ydHMudHJhbnNmZXJGbGFncyA9IHJlcXVpcmUoJy4vdHJhbnNmZXJGbGFncycpO1xuXG4vKiFcbiAqIERlZXAgZXF1YWwgdXRpbGl0eVxuICovXG5cbmV4cG9ydHMuZXFsID0gcmVxdWlyZSgnZGVlcC1lcWwnKTtcblxuLyohXG4gKiBEZWVwIHBhdGggdmFsdWVcbiAqL1xuXG5leHBvcnRzLmdldFBhdGhWYWx1ZSA9IHJlcXVpcmUoJy4vZ2V0UGF0aFZhbHVlJyk7XG5cbi8qIVxuICogRnVuY3Rpb24gbmFtZVxuICovXG5cbmV4cG9ydHMuZ2V0TmFtZSA9IHJlcXVpcmUoJy4vZ2V0TmFtZScpO1xuXG4vKiFcbiAqIGFkZCBQcm9wZXJ0eVxuICovXG5cbmV4cG9ydHMuYWRkUHJvcGVydHkgPSByZXF1aXJlKCcuL2FkZFByb3BlcnR5Jyk7XG5cbi8qIVxuICogYWRkIE1ldGhvZFxuICovXG5cbmV4cG9ydHMuYWRkTWV0aG9kID0gcmVxdWlyZSgnLi9hZGRNZXRob2QnKTtcblxuLyohXG4gKiBvdmVyd3JpdGUgUHJvcGVydHlcbiAqL1xuXG5leHBvcnRzLm92ZXJ3cml0ZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9vdmVyd3JpdGVQcm9wZXJ0eScpO1xuXG4vKiFcbiAqIG92ZXJ3cml0ZSBNZXRob2RcbiAqL1xuXG5leHBvcnRzLm92ZXJ3cml0ZU1ldGhvZCA9IHJlcXVpcmUoJy4vb3ZlcndyaXRlTWV0aG9kJyk7XG5cbi8qIVxuICogQWRkIGEgY2hhaW5hYmxlIG1ldGhvZFxuICovXG5cbmV4cG9ydHMuYWRkQ2hhaW5hYmxlTWV0aG9kID0gcmVxdWlyZSgnLi9hZGRDaGFpbmFibGVNZXRob2QnKTtcblxuLyohXG4gKiBPdmVyd3JpdGUgY2hhaW5hYmxlIG1ldGhvZFxuICovXG5cbmV4cG9ydHMub3ZlcndyaXRlQ2hhaW5hYmxlTWV0aG9kID0gcmVxdWlyZSgnLi9vdmVyd3JpdGVDaGFpbmFibGVNZXRob2QnKTtcblxuIiwiLy8gVGhpcyBpcyAoYWxtb3N0KSBkaXJlY3RseSBmcm9tIE5vZGUuanMgdXRpbHNcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qb3llbnQvbm9kZS9ibG9iL2Y4YzMzNWQwY2FmNDdmMTZkMzE0MTNmODlhYTI4ZWRhMzg3OGUzYWEvbGliL3V0aWwuanNcblxudmFyIGdldE5hbWUgPSByZXF1aXJlKCcuL2dldE5hbWUnKTtcbnZhciBnZXRQcm9wZXJ0aWVzID0gcmVxdWlyZSgnLi9nZXRQcm9wZXJ0aWVzJyk7XG52YXIgZ2V0RW51bWVyYWJsZVByb3BlcnRpZXMgPSByZXF1aXJlKCcuL2dldEVudW1lcmFibGVQcm9wZXJ0aWVzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gaW5zcGVjdDtcblxuLyoqXG4gKiBFY2hvcyB0aGUgdmFsdWUgb2YgYSB2YWx1ZS4gVHJ5cyB0byBwcmludCB0aGUgdmFsdWUgb3V0XG4gKiBpbiB0aGUgYmVzdCB3YXkgcG9zc2libGUgZ2l2ZW4gdGhlIGRpZmZlcmVudCB0eXBlcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gcHJpbnQgb3V0LlxuICogQHBhcmFtIHtCb29sZWFufSBzaG93SGlkZGVuIEZsYWcgdGhhdCBzaG93cyBoaWRkZW4gKG5vdCBlbnVtZXJhYmxlKVxuICogICAgcHJvcGVydGllcyBvZiBvYmplY3RzLlxuICogQHBhcmFtIHtOdW1iZXJ9IGRlcHRoIERlcHRoIGluIHdoaWNoIHRvIGRlc2NlbmQgaW4gb2JqZWN0LiBEZWZhdWx0IGlzIDIuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGNvbG9ycyBGbGFnIHRvIHR1cm4gb24gQU5TSSBlc2NhcGUgY29kZXMgdG8gY29sb3IgdGhlXG4gKiAgICBvdXRwdXQuIERlZmF1bHQgaXMgZmFsc2UgKG5vIGNvbG9yaW5nKS5cbiAqL1xuZnVuY3Rpb24gaW5zcGVjdChvYmosIHNob3dIaWRkZW4sIGRlcHRoLCBjb2xvcnMpIHtcbiAgdmFyIGN0eCA9IHtcbiAgICBzaG93SGlkZGVuOiBzaG93SGlkZGVuLFxuICAgIHNlZW46IFtdLFxuICAgIHN0eWxpemU6IGZ1bmN0aW9uIChzdHIpIHsgcmV0dXJuIHN0cjsgfVxuICB9O1xuICByZXR1cm4gZm9ybWF0VmFsdWUoY3R4LCBvYmosICh0eXBlb2YgZGVwdGggPT09ICd1bmRlZmluZWQnID8gMiA6IGRlcHRoKSk7XG59XG5cbi8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tLzEwNDQxMjgvXG52YXIgZ2V0T3V0ZXJIVE1MID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICBpZiAoJ291dGVySFRNTCcgaW4gZWxlbWVudCkgcmV0dXJuIGVsZW1lbnQub3V0ZXJIVE1MO1xuICB2YXIgbnMgPSBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIjtcbiAgdmFyIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhucywgJ18nKTtcbiAgdmFyIGVsZW1Qcm90byA9ICh3aW5kb3cuSFRNTEVsZW1lbnQgfHwgd2luZG93LkVsZW1lbnQpLnByb3RvdHlwZTtcbiAgdmFyIHhtbFNlcmlhbGl6ZXIgPSBuZXcgWE1MU2VyaWFsaXplcigpO1xuICB2YXIgaHRtbDtcbiAgaWYgKGRvY3VtZW50LnhtbFZlcnNpb24pIHtcbiAgICByZXR1cm4geG1sU2VyaWFsaXplci5zZXJpYWxpemVUb1N0cmluZyhlbGVtZW50KTtcbiAgfSBlbHNlIHtcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoZWxlbWVudC5jbG9uZU5vZGUoZmFsc2UpKTtcbiAgICBodG1sID0gY29udGFpbmVyLmlubmVySFRNTC5yZXBsYWNlKCc+PCcsICc+JyArIGVsZW1lbnQuaW5uZXJIVE1MICsgJzwnKTtcbiAgICBjb250YWluZXIuaW5uZXJIVE1MID0gJyc7XG4gICAgcmV0dXJuIGh0bWw7XG4gIH1cbn07XG5cbi8vIFJldHVybnMgdHJ1ZSBpZiBvYmplY3QgaXMgYSBET00gZWxlbWVudC5cbnZhciBpc0RPTUVsZW1lbnQgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gIGlmICh0eXBlb2YgSFRNTEVsZW1lbnQgPT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG9iamVjdCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBvYmplY3QgJiZcbiAgICAgIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmXG4gICAgICBvYmplY3Qubm9kZVR5cGUgPT09IDEgJiZcbiAgICAgIHR5cGVvZiBvYmplY3Qubm9kZU5hbWUgPT09ICdzdHJpbmcnO1xuICB9XG59O1xuXG5mdW5jdGlvbiBmb3JtYXRWYWx1ZShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMpIHtcbiAgLy8gUHJvdmlkZSBhIGhvb2sgZm9yIHVzZXItc3BlY2lmaWVkIGluc3BlY3QgZnVuY3Rpb25zLlxuICAvLyBDaGVjayB0aGF0IHZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIGFuIGluc3BlY3QgZnVuY3Rpb24gb24gaXRcbiAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZS5pbnNwZWN0ID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAvLyBGaWx0ZXIgb3V0IHRoZSB1dGlsIG1vZHVsZSwgaXQncyBpbnNwZWN0IGZ1bmN0aW9uIGlzIHNwZWNpYWxcbiAgICAgIHZhbHVlLmluc3BlY3QgIT09IGV4cG9ydHMuaW5zcGVjdCAmJlxuICAgICAgLy8gQWxzbyBmaWx0ZXIgb3V0IGFueSBwcm90b3R5cGUgb2JqZWN0cyB1c2luZyB0aGUgY2lyY3VsYXIgY2hlY2suXG4gICAgICAhKHZhbHVlLmNvbnN0cnVjdG9yICYmIHZhbHVlLmNvbnN0cnVjdG9yLnByb3RvdHlwZSA9PT0gdmFsdWUpKSB7XG4gICAgdmFyIHJldCA9IHZhbHVlLmluc3BlY3QocmVjdXJzZVRpbWVzKTtcbiAgICBpZiAodHlwZW9mIHJldCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHJldCA9IGZvcm1hdFZhbHVlKGN0eCwgcmV0LCByZWN1cnNlVGltZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLy8gUHJpbWl0aXZlIHR5cGVzIGNhbm5vdCBoYXZlIHByb3BlcnRpZXNcbiAgdmFyIHByaW1pdGl2ZSA9IGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKTtcbiAgaWYgKHByaW1pdGl2ZSkge1xuICAgIHJldHVybiBwcmltaXRpdmU7XG4gIH1cblxuICAvLyBJZiBpdCdzIERPTSBlbGVtLCBnZXQgb3V0ZXIgSFRNTC5cbiAgaWYgKGlzRE9NRWxlbWVudCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZ2V0T3V0ZXJIVE1MKHZhbHVlKTtcbiAgfVxuXG4gIC8vIExvb2sgdXAgdGhlIGtleXMgb2YgdGhlIG9iamVjdC5cbiAgdmFyIHZpc2libGVLZXlzID0gZ2V0RW51bWVyYWJsZVByb3BlcnRpZXModmFsdWUpO1xuICB2YXIga2V5cyA9IGN0eC5zaG93SGlkZGVuID8gZ2V0UHJvcGVydGllcyh2YWx1ZSkgOiB2aXNpYmxlS2V5cztcblxuICAvLyBTb21lIHR5cGUgb2Ygb2JqZWN0IHdpdGhvdXQgcHJvcGVydGllcyBjYW4gYmUgc2hvcnRjdXR0ZWQuXG4gIC8vIEluIElFLCBlcnJvcnMgaGF2ZSBhIHNpbmdsZSBgc3RhY2tgIHByb3BlcnR5LCBvciBpZiB0aGV5IGFyZSB2YW5pbGxhIGBFcnJvcmAsXG4gIC8vIGEgYHN0YWNrYCBwbHVzIGBkZXNjcmlwdGlvbmAgcHJvcGVydHk7IGlnbm9yZSB0aG9zZSBmb3IgY29uc2lzdGVuY3kuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCB8fCAoaXNFcnJvcih2YWx1ZSkgJiYgKFxuICAgICAgKGtleXMubGVuZ3RoID09PSAxICYmIGtleXNbMF0gPT09ICdzdGFjaycpIHx8XG4gICAgICAoa2V5cy5sZW5ndGggPT09IDIgJiYga2V5c1swXSA9PT0gJ2Rlc2NyaXB0aW9uJyAmJiBrZXlzWzFdID09PSAnc3RhY2snKVxuICAgICApKSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciBuYW1lID0gZ2V0TmFtZSh2YWx1ZSk7XG4gICAgICB2YXIgbmFtZVN1ZmZpeCA9IG5hbWUgPyAnOiAnICsgbmFtZSA6ICcnO1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbRnVuY3Rpb24nICsgbmFtZVN1ZmZpeCArICddJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9XG4gICAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShEYXRlLnByb3RvdHlwZS50b1VUQ1N0cmluZy5jYWxsKHZhbHVlKSwgJ2RhdGUnKTtcbiAgICB9XG4gICAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBiYXNlID0gJycsIGFycmF5ID0gZmFsc2UsIGJyYWNlcyA9IFsneycsICd9J107XG5cbiAgLy8gTWFrZSBBcnJheSBzYXkgdGhhdCB0aGV5IGFyZSBBcnJheVxuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBhcnJheSA9IHRydWU7XG4gICAgYnJhY2VzID0gWydbJywgJ10nXTtcbiAgfVxuXG4gIC8vIE1ha2UgZnVuY3Rpb25zIHNheSB0aGF0IHRoZXkgYXJlIGZ1bmN0aW9uc1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIG5hbWUgPSBnZXROYW1lKHZhbHVlKTtcbiAgICB2YXIgbmFtZVN1ZmZpeCA9IG5hbWUgPyAnOiAnICsgbmFtZSA6ICcnO1xuICAgIGJhc2UgPSAnIFtGdW5jdGlvbicgKyBuYW1lU3VmZml4ICsgJ10nO1xuICB9XG5cbiAgLy8gTWFrZSBSZWdFeHBzIHNheSB0aGF0IHRoZXkgYXJlIFJlZ0V4cHNcbiAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBkYXRlcyB3aXRoIHByb3BlcnRpZXMgZmlyc3Qgc2F5IHRoZSBkYXRlXG4gIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIERhdGUucHJvdG90eXBlLnRvVVRDU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBlcnJvciB3aXRoIG1lc3NhZ2UgZmlyc3Qgc2F5IHRoZSBlcnJvclxuICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwICYmICghYXJyYXkgfHwgdmFsdWUubGVuZ3RoID09IDApKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyBicmFjZXNbMV07XG4gIH1cblxuICBpZiAocmVjdXJzZVRpbWVzIDwgMCkge1xuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW09iamVjdF0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuXG4gIGN0eC5zZWVuLnB1c2godmFsdWUpO1xuXG4gIHZhciBvdXRwdXQ7XG4gIGlmIChhcnJheSkge1xuICAgIG91dHB1dCA9IGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpO1xuICB9IGVsc2Uge1xuICAgIG91dHB1dCA9IGtleXMubWFwKGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpO1xuICAgIH0pO1xuICB9XG5cbiAgY3R4LnNlZW4ucG9wKCk7XG5cbiAgcmV0dXJuIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKTtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSkge1xuICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ3VuZGVmaW5lZCcsICd1bmRlZmluZWQnKTtcblxuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICB2YXIgc2ltcGxlID0gJ1xcJycgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkucmVwbGFjZSgvXlwifFwiJC9nLCAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpICsgJ1xcJyc7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoc2ltcGxlLCAnc3RyaW5nJyk7XG5cbiAgICBjYXNlICdudW1iZXInOlxuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdudW1iZXInKTtcblxuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdib29sZWFuJyk7XG4gIH1cbiAgLy8gRm9yIHNvbWUgcmVhc29uIHR5cGVvZiBudWxsIGlzIFwib2JqZWN0XCIsIHNvIHNwZWNpYWwgY2FzZSBoZXJlLlxuICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ251bGwnLCAnbnVsbCcpO1xuICB9XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0RXJyb3IodmFsdWUpIHtcbiAgcmV0dXJuICdbJyArIEVycm9yLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSArICddJztcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKSB7XG4gIHZhciBvdXRwdXQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBTdHJpbmcoaSkpKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIFN0cmluZyhpKSwgdHJ1ZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXQucHVzaCgnJyk7XG4gICAgfVxuICB9XG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAoIWtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAga2V5LCB0cnVlKSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KSB7XG4gIHZhciBuYW1lLCBzdHI7XG4gIGlmICh2YWx1ZS5fX2xvb2t1cEdldHRlcl9fKSB7XG4gICAgaWYgKHZhbHVlLl9fbG9va3VwR2V0dGVyX18oa2V5KSkge1xuICAgICAgaWYgKHZhbHVlLl9fbG9va3VwU2V0dGVyX18oa2V5KSkge1xuICAgICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlci9TZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh2YWx1ZS5fX2xvb2t1cFNldHRlcl9fKGtleSkpIHtcbiAgICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tTZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHZpc2libGVLZXlzLmluZGV4T2Yoa2V5KSA8IDApIHtcbiAgICBuYW1lID0gJ1snICsga2V5ICsgJ10nO1xuICB9XG4gIGlmICghc3RyKSB7XG4gICAgaWYgKGN0eC5zZWVuLmluZGV4T2YodmFsdWVba2V5XSkgPCAwKSB7XG4gICAgICBpZiAocmVjdXJzZVRpbWVzID09PSBudWxsKSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgdmFsdWVba2V5XSwgbnVsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIHZhbHVlW2tleV0sIHJlY3Vyc2VUaW1lcyAtIDEpO1xuICAgICAgfVxuICAgICAgaWYgKHN0ci5pbmRleE9mKCdcXG4nKSA+IC0xKSB7XG4gICAgICAgIGlmIChhcnJheSkge1xuICAgICAgICAgIHN0ciA9IHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKS5zdWJzdHIoMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyID0gJ1xcbicgKyBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbQ2lyY3VsYXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cbiAgaWYgKHR5cGVvZiBuYW1lID09PSAndW5kZWZpbmVkJykge1xuICAgIGlmIChhcnJheSAmJiBrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICBuYW1lID0gSlNPTi5zdHJpbmdpZnkoJycgKyBrZXkpO1xuICAgIGlmIChuYW1lLm1hdGNoKC9eXCIoW2EtekEtWl9dW2EtekEtWl8wLTldKilcIiQvKSkge1xuICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyKDEsIG5hbWUubGVuZ3RoIC0gMik7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ25hbWUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJylcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyheXCJ8XCIkKS9nLCBcIidcIik7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ3N0cmluZycpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuYW1lICsgJzogJyArIHN0cjtcbn1cblxuXG5mdW5jdGlvbiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcykge1xuICB2YXIgbnVtTGluZXNFc3QgPSAwO1xuICB2YXIgbGVuZ3RoID0gb3V0cHV0LnJlZHVjZShmdW5jdGlvbihwcmV2LCBjdXIpIHtcbiAgICBudW1MaW5lc0VzdCsrO1xuICAgIGlmIChjdXIuaW5kZXhPZignXFxuJykgPj0gMCkgbnVtTGluZXNFc3QrKztcbiAgICByZXR1cm4gcHJldiArIGN1ci5sZW5ndGggKyAxO1xuICB9LCAwKTtcblxuICBpZiAobGVuZ3RoID4gNjApIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICtcbiAgICAgICAgICAgKGJhc2UgPT09ICcnID8gJycgOiBiYXNlICsgJ1xcbiAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIG91dHB1dC5qb2luKCcsXFxuICAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIGJyYWNlc1sxXTtcbiAgfVxuXG4gIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgJyAnICsgb3V0cHV0LmpvaW4oJywgJykgKyAnICcgKyBicmFjZXNbMV07XG59XG5cbmZ1bmN0aW9uIGlzQXJyYXkoYXIpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXIpIHx8XG4gICAgICAgICAodHlwZW9mIGFyID09PSAnb2JqZWN0JyAmJiBvYmplY3RUb1N0cmluZyhhcikgPT09ICdbb2JqZWN0IEFycmF5XScpO1xufVxuXG5mdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICByZXR1cm4gdHlwZW9mIHJlID09PSAnb2JqZWN0JyAmJiBvYmplY3RUb1N0cmluZyhyZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuXG5mdW5jdGlvbiBpc0RhdGUoZCkge1xuICByZXR1cm4gdHlwZW9mIGQgPT09ICdvYmplY3QnICYmIG9iamVjdFRvU3RyaW5nKGQpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5cbmZ1bmN0aW9uIGlzRXJyb3IoZSkge1xuICByZXR1cm4gdHlwZW9mIGUgPT09ICdvYmplY3QnICYmIG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nO1xufVxuXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG59XG4iLCIvKiFcbiAqIENoYWkgLSBmbGFnIHV0aWxpdHlcbiAqIENvcHlyaWdodChjKSAyMDEyLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4vKiFcbiAqIE1vZHVsZSBkZXBlbmRhbmNpZXNcbiAqL1xuXG52YXIgaW5zcGVjdCA9IHJlcXVpcmUoJy4vaW5zcGVjdCcpO1xudmFyIGNvbmZpZyA9IHJlcXVpcmUoJy4uL2NvbmZpZycpO1xuXG4vKipcbiAqICMjIyAub2JqRGlzcGxheSAob2JqZWN0KVxuICpcbiAqIERldGVybWluZXMgaWYgYW4gb2JqZWN0IG9yIGFuIGFycmF5IG1hdGNoZXNcbiAqIGNyaXRlcmlhIHRvIGJlIGluc3BlY3RlZCBpbi1saW5lIGZvciBlcnJvclxuICogbWVzc2FnZXMgb3Igc2hvdWxkIGJlIHRydW5jYXRlZC5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSBqYXZhc2NyaXB0IG9iamVjdCB0byBpbnNwZWN0XG4gKiBAbmFtZSBvYmpEaXNwbGF5XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iaikge1xuICB2YXIgc3RyID0gaW5zcGVjdChvYmopXG4gICAgLCB0eXBlID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaik7XG5cbiAgaWYgKGNvbmZpZy50cnVuY2F0ZVRocmVzaG9sZCAmJiBzdHIubGVuZ3RoID49IGNvbmZpZy50cnVuY2F0ZVRocmVzaG9sZCkge1xuICAgIGlmICh0eXBlID09PSAnW29iamVjdCBGdW5jdGlvbl0nKSB7XG4gICAgICByZXR1cm4gIW9iai5uYW1lIHx8IG9iai5uYW1lID09PSAnJ1xuICAgICAgICA/ICdbRnVuY3Rpb25dJ1xuICAgICAgICA6ICdbRnVuY3Rpb246ICcgKyBvYmoubmFtZSArICddJztcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgIHJldHVybiAnWyBBcnJheSgnICsgb2JqLmxlbmd0aCArICcpIF0nO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKVxuICAgICAgICAsIGtzdHIgPSBrZXlzLmxlbmd0aCA+IDJcbiAgICAgICAgICA/IGtleXMuc3BsaWNlKDAsIDIpLmpvaW4oJywgJykgKyAnLCAuLi4nXG4gICAgICAgICAgOiBrZXlzLmpvaW4oJywgJyk7XG4gICAgICByZXR1cm4gJ3sgT2JqZWN0ICgnICsga3N0ciArICcpIH0nO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG59O1xuIiwiLyohXG4gKiBDaGFpIC0gb3ZlcndyaXRlQ2hhaW5hYmxlTWV0aG9kIHV0aWxpdHlcbiAqIENvcHlyaWdodChjKSAyMDEyLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4vKipcbiAqICMjIyBvdmVyd3JpdGVDaGFpbmFibGVNZXRob2QgKGN0eCwgbmFtZSwgZm4pXG4gKlxuICogT3ZlcndpdGVzIGFuIGFscmVhZHkgZXhpc3RpbmcgY2hhaW5hYmxlIG1ldGhvZFxuICogYW5kIHByb3ZpZGVzIGFjY2VzcyB0byB0aGUgcHJldmlvdXMgZnVuY3Rpb24gb3JcbiAqIHByb3BlcnR5LiAgTXVzdCByZXR1cm4gZnVuY3Rpb25zIHRvIGJlIHVzZWQgZm9yXG4gKiBuYW1lLlxuICpcbiAqICAgICB1dGlscy5vdmVyd3JpdGVDaGFpbmFibGVNZXRob2QoY2hhaS5Bc3NlcnRpb24ucHJvdG90eXBlLCAnbGVuZ3RoJyxcbiAqICAgICAgIGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAqICAgICAgIH1cbiAqICAgICAsIGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAqICAgICAgIH1cbiAqICAgICApO1xuICpcbiAqIENhbiBhbHNvIGJlIGFjY2Vzc2VkIGRpcmVjdGx5IGZyb20gYGNoYWkuQXNzZXJ0aW9uYC5cbiAqXG4gKiAgICAgY2hhaS5Bc3NlcnRpb24ub3ZlcndyaXRlQ2hhaW5hYmxlTWV0aG9kKCdmb28nLCBmbiwgZm4pO1xuICpcbiAqIFRoZW4gY2FuIGJlIHVzZWQgYXMgYW55IG90aGVyIGFzc2VydGlvbi5cbiAqXG4gKiAgICAgZXhwZWN0KG15Rm9vKS50by5oYXZlLmxlbmd0aCgzKTtcbiAqICAgICBleHBlY3QobXlGb28pLnRvLmhhdmUubGVuZ3RoLmFib3ZlKDMpO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjdHggb2JqZWN0IHdob3NlIG1ldGhvZCAvIHByb3BlcnR5IGlzIHRvIGJlIG92ZXJ3cml0dGVuXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBvZiBtZXRob2QgLyBwcm9wZXJ0eSB0byBvdmVyd3JpdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG1ldGhvZCBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBmdW5jdGlvbiB0byBiZSB1c2VkIGZvciBuYW1lXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjaGFpbmluZ0JlaGF2aW9yIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIGZ1bmN0aW9uIHRvIGJlIHVzZWQgZm9yIHByb3BlcnR5XG4gKiBAbmFtZSBvdmVyd3JpdGVDaGFpbmFibGVNZXRob2RcbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY3R4LCBuYW1lLCBtZXRob2QsIGNoYWluaW5nQmVoYXZpb3IpIHtcbiAgdmFyIGNoYWluYWJsZUJlaGF2aW9yID0gY3R4Ll9fbWV0aG9kc1tuYW1lXTtcblxuICB2YXIgX2NoYWluaW5nQmVoYXZpb3IgPSBjaGFpbmFibGVCZWhhdmlvci5jaGFpbmluZ0JlaGF2aW9yO1xuICBjaGFpbmFibGVCZWhhdmlvci5jaGFpbmluZ0JlaGF2aW9yID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXN1bHQgPSBjaGFpbmluZ0JlaGF2aW9yKF9jaGFpbmluZ0JlaGF2aW9yKS5jYWxsKHRoaXMpO1xuICAgIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IHRoaXMgOiByZXN1bHQ7XG4gIH07XG5cbiAgdmFyIF9tZXRob2QgPSBjaGFpbmFibGVCZWhhdmlvci5tZXRob2Q7XG4gIGNoYWluYWJsZUJlaGF2aW9yLm1ldGhvZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVzdWx0ID0gbWV0aG9kKF9tZXRob2QpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgcmV0dXJuIHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gdGhpcyA6IHJlc3VsdDtcbiAgfTtcbn07XG4iLCIvKiFcbiAqIENoYWkgLSBvdmVyd3JpdGVNZXRob2QgdXRpbGl0eVxuICogQ29weXJpZ2h0KGMpIDIwMTItMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qKlxuICogIyMjIG92ZXJ3cml0ZU1ldGhvZCAoY3R4LCBuYW1lLCBmbilcbiAqXG4gKiBPdmVyd2l0ZXMgYW4gYWxyZWFkeSBleGlzdGluZyBtZXRob2QgYW5kIHByb3ZpZGVzXG4gKiBhY2Nlc3MgdG8gcHJldmlvdXMgZnVuY3Rpb24uIE11c3QgcmV0dXJuIGZ1bmN0aW9uXG4gKiB0byBiZSB1c2VkIGZvciBuYW1lLlxuICpcbiAqICAgICB1dGlscy5vdmVyd3JpdGVNZXRob2QoY2hhaS5Bc3NlcnRpb24ucHJvdG90eXBlLCAnZXF1YWwnLCBmdW5jdGlvbiAoX3N1cGVyKSB7XG4gKiAgICAgICByZXR1cm4gZnVuY3Rpb24gKHN0cikge1xuICogICAgICAgICB2YXIgb2JqID0gdXRpbHMuZmxhZyh0aGlzLCAnb2JqZWN0Jyk7XG4gKiAgICAgICAgIGlmIChvYmogaW5zdGFuY2VvZiBGb28pIHtcbiAqICAgICAgICAgICBuZXcgY2hhaS5Bc3NlcnRpb24ob2JqLnZhbHVlKS50by5lcXVhbChzdHIpO1xuICogICAgICAgICB9IGVsc2Uge1xuICogICAgICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICogICAgICAgICB9XG4gKiAgICAgICB9XG4gKiAgICAgfSk7XG4gKlxuICogQ2FuIGFsc28gYmUgYWNjZXNzZWQgZGlyZWN0bHkgZnJvbSBgY2hhaS5Bc3NlcnRpb25gLlxuICpcbiAqICAgICBjaGFpLkFzc2VydGlvbi5vdmVyd3JpdGVNZXRob2QoJ2ZvbycsIGZuKTtcbiAqXG4gKiBUaGVuIGNhbiBiZSB1c2VkIGFzIGFueSBvdGhlciBhc3NlcnRpb24uXG4gKlxuICogICAgIGV4cGVjdChteUZvbykudG8uZXF1YWwoJ2JhcicpO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjdHggb2JqZWN0IHdob3NlIG1ldGhvZCBpcyB0byBiZSBvdmVyd3JpdHRlblxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgb2YgbWV0aG9kIHRvIG92ZXJ3cml0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gbWV0aG9kIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIGZ1bmN0aW9uIHRvIGJlIHVzZWQgZm9yIG5hbWVcbiAqIEBuYW1lIG92ZXJ3cml0ZU1ldGhvZFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjdHgsIG5hbWUsIG1ldGhvZCkge1xuICB2YXIgX21ldGhvZCA9IGN0eFtuYW1lXVxuICAgICwgX3N1cGVyID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcblxuICBpZiAoX21ldGhvZCAmJiAnZnVuY3Rpb24nID09PSB0eXBlb2YgX21ldGhvZClcbiAgICBfc3VwZXIgPSBfbWV0aG9kO1xuXG4gIGN0eFtuYW1lXSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVzdWx0ID0gbWV0aG9kKF9zdXBlcikuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICByZXR1cm4gcmVzdWx0ID09PSB1bmRlZmluZWQgPyB0aGlzIDogcmVzdWx0O1xuICB9XG59O1xuIiwiLyohXG4gKiBDaGFpIC0gb3ZlcndyaXRlUHJvcGVydHkgdXRpbGl0eVxuICogQ29weXJpZ2h0KGMpIDIwMTItMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qKlxuICogIyMjIG92ZXJ3cml0ZVByb3BlcnR5IChjdHgsIG5hbWUsIGZuKVxuICpcbiAqIE92ZXJ3aXRlcyBhbiBhbHJlYWR5IGV4aXN0aW5nIHByb3BlcnR5IGdldHRlciBhbmQgcHJvdmlkZXNcbiAqIGFjY2VzcyB0byBwcmV2aW91cyB2YWx1ZS4gTXVzdCByZXR1cm4gZnVuY3Rpb24gdG8gdXNlIGFzIGdldHRlci5cbiAqXG4gKiAgICAgdXRpbHMub3ZlcndyaXRlUHJvcGVydHkoY2hhaS5Bc3NlcnRpb24ucHJvdG90eXBlLCAnb2snLCBmdW5jdGlvbiAoX3N1cGVyKSB7XG4gKiAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICogICAgICAgICB2YXIgb2JqID0gdXRpbHMuZmxhZyh0aGlzLCAnb2JqZWN0Jyk7XG4gKiAgICAgICAgIGlmIChvYmogaW5zdGFuY2VvZiBGb28pIHtcbiAqICAgICAgICAgICBuZXcgY2hhaS5Bc3NlcnRpb24ob2JqLm5hbWUpLnRvLmVxdWFsKCdiYXInKTtcbiAqICAgICAgICAgfSBlbHNlIHtcbiAqICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAqICAgICAgICAgfVxuICogICAgICAgfVxuICogICAgIH0pO1xuICpcbiAqXG4gKiBDYW4gYWxzbyBiZSBhY2Nlc3NlZCBkaXJlY3RseSBmcm9tIGBjaGFpLkFzc2VydGlvbmAuXG4gKlxuICogICAgIGNoYWkuQXNzZXJ0aW9uLm92ZXJ3cml0ZVByb3BlcnR5KCdmb28nLCBmbik7XG4gKlxuICogVGhlbiBjYW4gYmUgdXNlZCBhcyBhbnkgb3RoZXIgYXNzZXJ0aW9uLlxuICpcbiAqICAgICBleHBlY3QobXlGb28pLnRvLmJlLm9rO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjdHggb2JqZWN0IHdob3NlIHByb3BlcnR5IGlzIHRvIGJlIG92ZXJ3cml0dGVuXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBvZiBwcm9wZXJ0eSB0byBvdmVyd3JpdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGdldHRlciBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBnZXR0ZXIgZnVuY3Rpb24gdG8gYmUgdXNlZCBmb3IgbmFtZVxuICogQG5hbWUgb3ZlcndyaXRlUHJvcGVydHlcbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY3R4LCBuYW1lLCBnZXR0ZXIpIHtcbiAgdmFyIF9nZXQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGN0eCwgbmFtZSlcbiAgICAsIF9zdXBlciA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gIGlmIChfZ2V0ICYmICdmdW5jdGlvbicgPT09IHR5cGVvZiBfZ2V0LmdldClcbiAgICBfc3VwZXIgPSBfZ2V0LmdldFxuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdHgsIG5hbWUsXG4gICAgeyBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGdldHRlcihfc3VwZXIpLmNhbGwodGhpcyk7XG4gICAgICAgIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IHRoaXMgOiByZXN1bHQ7XG4gICAgICB9XG4gICAgLCBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59O1xuIiwiLyohXG4gKiBDaGFpIC0gdGVzdCB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyohXG4gKiBNb2R1bGUgZGVwZW5kYW5jaWVzXG4gKi9cblxudmFyIGZsYWcgPSByZXF1aXJlKCcuL2ZsYWcnKTtcblxuLyoqXG4gKiAjIHRlc3Qob2JqZWN0LCBleHByZXNzaW9uKVxuICpcbiAqIFRlc3QgYW5kIG9iamVjdCBmb3IgZXhwcmVzc2lvbi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IChjb25zdHJ1Y3RlZCBBc3NlcnRpb24pXG4gKiBAcGFyYW0ge0FyZ3VtZW50c30gY2hhaS5Bc3NlcnRpb24ucHJvdG90eXBlLmFzc2VydCBhcmd1bWVudHNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmosIGFyZ3MpIHtcbiAgdmFyIG5lZ2F0ZSA9IGZsYWcob2JqLCAnbmVnYXRlJylcbiAgICAsIGV4cHIgPSBhcmdzWzBdO1xuICByZXR1cm4gbmVnYXRlID8gIWV4cHIgOiBleHByO1xufTtcbiIsIi8qIVxuICogQ2hhaSAtIHRyYW5zZmVyRmxhZ3MgdXRpbGl0eVxuICogQ29weXJpZ2h0KGMpIDIwMTItMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qKlxuICogIyMjIHRyYW5zZmVyRmxhZ3MoYXNzZXJ0aW9uLCBvYmplY3QsIGluY2x1ZGVBbGwgPSB0cnVlKVxuICpcbiAqIFRyYW5zZmVyIGFsbCB0aGUgZmxhZ3MgZm9yIGBhc3NlcnRpb25gIHRvIGBvYmplY3RgLiBJZlxuICogYGluY2x1ZGVBbGxgIGlzIHNldCB0byBgZmFsc2VgLCB0aGVuIHRoZSBiYXNlIENoYWlcbiAqIGFzc2VydGlvbiBmbGFncyAobmFtZWx5IGBvYmplY3RgLCBgc3NmaWAsIGFuZCBgbWVzc2FnZWApXG4gKiB3aWxsIG5vdCBiZSB0cmFuc2ZlcnJlZC5cbiAqXG4gKlxuICogICAgIHZhciBuZXdBc3NlcnRpb24gPSBuZXcgQXNzZXJ0aW9uKCk7XG4gKiAgICAgdXRpbHMudHJhbnNmZXJGbGFncyhhc3NlcnRpb24sIG5ld0Fzc2VydGlvbik7XG4gKlxuICogICAgIHZhciBhbm90aGVyQXNzZXJpdG9uID0gbmV3IEFzc2VydGlvbihteU9iaik7XG4gKiAgICAgdXRpbHMudHJhbnNmZXJGbGFncyhhc3NlcnRpb24sIGFub3RoZXJBc3NlcnRpb24sIGZhbHNlKTtcbiAqXG4gKiBAcGFyYW0ge0Fzc2VydGlvbn0gYXNzZXJ0aW9uIHRoZSBhc3NlcnRpb24gdG8gdHJhbnNmZXIgdGhlIGZsYWdzIGZyb21cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgdGhlIG9iamVjdCB0byB0cmFuc2ZlciB0aGUgZmxhZ3MgdG9vOyB1c3VhbGx5IGEgbmV3IGFzc2VydGlvblxuICogQHBhcmFtIHtCb29sZWFufSBpbmNsdWRlQWxsXG4gKiBAbmFtZSBnZXRBbGxGbGFnc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXNzZXJ0aW9uLCBvYmplY3QsIGluY2x1ZGVBbGwpIHtcbiAgdmFyIGZsYWdzID0gYXNzZXJ0aW9uLl9fZmxhZ3MgfHwgKGFzc2VydGlvbi5fX2ZsYWdzID0gT2JqZWN0LmNyZWF0ZShudWxsKSk7XG5cbiAgaWYgKCFvYmplY3QuX19mbGFncykge1xuICAgIG9iamVjdC5fX2ZsYWdzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfVxuXG4gIGluY2x1ZGVBbGwgPSBhcmd1bWVudHMubGVuZ3RoID09PSAzID8gaW5jbHVkZUFsbCA6IHRydWU7XG5cbiAgZm9yICh2YXIgZmxhZyBpbiBmbGFncykge1xuICAgIGlmIChpbmNsdWRlQWxsIHx8XG4gICAgICAgIChmbGFnICE9PSAnb2JqZWN0JyAmJiBmbGFnICE9PSAnc3NmaScgJiYgZmxhZyAhPSAnbWVzc2FnZScpKSB7XG4gICAgICBvYmplY3QuX19mbGFnc1tmbGFnXSA9IGZsYWdzW2ZsYWddO1xuICAgIH1cbiAgfVxufTtcbiIsIi8qIVxuICogQ2hhaSAtIHR5cGUgdXRpbGl0eVxuICogQ29weXJpZ2h0KGMpIDIwMTItMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qIVxuICogRGV0ZWN0YWJsZSBqYXZhc2NyaXB0IG5hdGl2ZXNcbiAqL1xuXG52YXIgbmF0aXZlcyA9IHtcbiAgICAnW29iamVjdCBBcmd1bWVudHNdJzogJ2FyZ3VtZW50cydcbiAgLCAnW29iamVjdCBBcnJheV0nOiAnYXJyYXknXG4gICwgJ1tvYmplY3QgRGF0ZV0nOiAnZGF0ZSdcbiAgLCAnW29iamVjdCBGdW5jdGlvbl0nOiAnZnVuY3Rpb24nXG4gICwgJ1tvYmplY3QgTnVtYmVyXSc6ICdudW1iZXInXG4gICwgJ1tvYmplY3QgUmVnRXhwXSc6ICdyZWdleHAnXG4gICwgJ1tvYmplY3QgU3RyaW5nXSc6ICdzdHJpbmcnXG59O1xuXG4vKipcbiAqICMjIyB0eXBlKG9iamVjdClcbiAqXG4gKiBCZXR0ZXIgaW1wbGVtZW50YXRpb24gb2YgYHR5cGVvZmAgZGV0ZWN0aW9uIHRoYXQgY2FuXG4gKiBiZSB1c2VkIGNyb3NzLWJyb3dzZXIuIEhhbmRsZXMgdGhlIGluY29uc2lzdGVuY2llcyBvZlxuICogQXJyYXksIGBudWxsYCwgYW5kIGB1bmRlZmluZWRgIGRldGVjdGlvbi5cbiAqXG4gKiAgICAgdXRpbHMudHlwZSh7fSkgLy8gJ29iamVjdCdcbiAqICAgICB1dGlscy50eXBlKG51bGwpIC8vIGBudWxsJ1xuICogICAgIHV0aWxzLnR5cGUodW5kZWZpbmVkKSAvLyBgdW5kZWZpbmVkYFxuICogICAgIHV0aWxzLnR5cGUoW10pIC8vIGBhcnJheWBcbiAqXG4gKiBAcGFyYW0ge01peGVkfSBvYmplY3QgdG8gZGV0ZWN0IHR5cGUgb2ZcbiAqIEBuYW1lIHR5cGVcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iaikge1xuICB2YXIgc3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaik7XG4gIGlmIChuYXRpdmVzW3N0cl0pIHJldHVybiBuYXRpdmVzW3N0cl07XG4gIGlmIChvYmogPT09IG51bGwpIHJldHVybiAnbnVsbCc7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgcmV0dXJuICd1bmRlZmluZWQnO1xuICBpZiAob2JqID09PSBPYmplY3Qob2JqKSkgcmV0dXJuICdvYmplY3QnO1xuICByZXR1cm4gdHlwZW9mIG9iajtcbn07XG4iLCIvKiFcbiAqIGFzc2VydGlvbi1lcnJvclxuICogQ29weXJpZ2h0KGMpIDIwMTMgSmFrZSBMdWVyIDxqYWtlQHF1YWxpYW5jeS5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4vKiFcbiAqIFJldHVybiBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBjb3B5IHByb3BlcnRpZXMgZnJvbVxuICogb25lIG9iamVjdCB0byBhbm90aGVyIGV4Y2x1ZGluZyBhbnkgb3JpZ2luYWxseVxuICogbGlzdGVkLiBSZXR1cm5lZCBmdW5jdGlvbiB3aWxsIGNyZWF0ZSBhIG5ldyBge31gLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBleGNsdWRlZCBwcm9wZXJ0aWVzIC4uLlxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cblxuZnVuY3Rpb24gZXhjbHVkZSAoKSB7XG4gIHZhciBleGNsdWRlcyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblxuICBmdW5jdGlvbiBleGNsdWRlUHJvcHMgKHJlcywgb2JqKSB7XG4gICAgT2JqZWN0LmtleXMob2JqKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIGlmICghfmV4Y2x1ZGVzLmluZGV4T2Yoa2V5KSkgcmVzW2tleV0gPSBvYmpba2V5XTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiBleHRlbmRFeGNsdWRlICgpIHtcbiAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKVxuICAgICAgLCBpID0gMFxuICAgICAgLCByZXMgPSB7fTtcblxuICAgIGZvciAoOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgZXhjbHVkZVByb3BzKHJlcywgYXJnc1tpXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcztcbiAgfTtcbn07XG5cbi8qIVxuICogUHJpbWFyeSBFeHBvcnRzXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBBc3NlcnRpb25FcnJvcjtcblxuLyoqXG4gKiAjIyMgQXNzZXJ0aW9uRXJyb3JcbiAqXG4gKiBBbiBleHRlbnNpb24gb2YgdGhlIEphdmFTY3JpcHQgYEVycm9yYCBjb25zdHJ1Y3RvciBmb3JcbiAqIGFzc2VydGlvbiBhbmQgdmFsaWRhdGlvbiBzY2VuYXJpb3MuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wZXJ0aWVzIHRvIGluY2x1ZGUgKG9wdGlvbmFsKVxuICogQHBhcmFtIHtjYWxsZWV9IHN0YXJ0IHN0YWNrIGZ1bmN0aW9uIChvcHRpb25hbClcbiAqL1xuXG5mdW5jdGlvbiBBc3NlcnRpb25FcnJvciAobWVzc2FnZSwgX3Byb3BzLCBzc2YpIHtcbiAgdmFyIGV4dGVuZCA9IGV4Y2x1ZGUoJ25hbWUnLCAnbWVzc2FnZScsICdzdGFjaycsICdjb25zdHJ1Y3RvcicsICd0b0pTT04nKVxuICAgICwgcHJvcHMgPSBleHRlbmQoX3Byb3BzIHx8IHt9KTtcblxuICAvLyBkZWZhdWx0IHZhbHVlc1xuICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8ICdVbnNwZWNpZmllZCBBc3NlcnRpb25FcnJvcic7XG4gIHRoaXMuc2hvd0RpZmYgPSBmYWxzZTtcblxuICAvLyBjb3B5IGZyb20gcHJvcGVydGllc1xuICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICB0aGlzW2tleV0gPSBwcm9wc1trZXldO1xuICB9XG5cbiAgLy8gY2FwdHVyZSBzdGFjayB0cmFjZVxuICBzc2YgPSBzc2YgfHwgYXJndW1lbnRzLmNhbGxlZTtcbiAgaWYgKHNzZiAmJiBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHNzZik7XG4gIH1cbn1cblxuLyohXG4gKiBJbmhlcml0IGZyb20gRXJyb3IucHJvdG90eXBlXG4gKi9cblxuQXNzZXJ0aW9uRXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xuXG4vKiFcbiAqIFN0YXRpY2FsbHkgc2V0IG5hbWVcbiAqL1xuXG5Bc3NlcnRpb25FcnJvci5wcm90b3R5cGUubmFtZSA9ICdBc3NlcnRpb25FcnJvcic7XG5cbi8qIVxuICogRW5zdXJlIGNvcnJlY3QgY29uc3RydWN0b3JcbiAqL1xuXG5Bc3NlcnRpb25FcnJvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBBc3NlcnRpb25FcnJvcjtcblxuLyoqXG4gKiBBbGxvdyBlcnJvcnMgdG8gYmUgY29udmVydGVkIHRvIEpTT04gZm9yIHN0YXRpYyB0cmFuc2Zlci5cbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGluY2x1ZGUgc3RhY2sgKGRlZmF1bHQ6IGB0cnVlYClcbiAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0IHRoYXQgY2FuIGJlIGBKU09OLnN0cmluZ2lmeWBcbiAqL1xuXG5Bc3NlcnRpb25FcnJvci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKHN0YWNrKSB7XG4gIHZhciBleHRlbmQgPSBleGNsdWRlKCdjb25zdHJ1Y3RvcicsICd0b0pTT04nLCAnc3RhY2snKVxuICAgICwgcHJvcHMgPSBleHRlbmQoeyBuYW1lOiB0aGlzLm5hbWUgfSwgdGhpcyk7XG5cbiAgLy8gaW5jbHVkZSBzdGFjayBpZiBleGlzdHMgYW5kIG5vdCB0dXJuZWQgb2ZmXG4gIGlmIChmYWxzZSAhPT0gc3RhY2sgJiYgdGhpcy5zdGFjaykge1xuICAgIHByb3BzLnN0YWNrID0gdGhpcy5zdGFjaztcbiAgfVxuXG4gIHJldHVybiBwcm9wcztcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL2VxbCcpO1xuIiwiLyohXG4gKiBkZWVwLWVxbFxuICogQ29weXJpZ2h0KGMpIDIwMTMgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4vKiFcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXNcbiAqL1xuXG52YXIgdHlwZSA9IHJlcXVpcmUoJ3R5cGUtZGV0ZWN0Jyk7XG5cbi8qIVxuICogQnVmZmVyLmlzQnVmZmVyIGJyb3dzZXIgc2hpbVxuICovXG5cbnZhciBCdWZmZXI7XG50cnkgeyBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7IH1cbmNhdGNoKGV4KSB7XG4gIEJ1ZmZlciA9IHt9O1xuICBCdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGZhbHNlOyB9XG59XG5cbi8qIVxuICogUHJpbWFyeSBFeHBvcnRcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlZXBFcXVhbDtcblxuLyoqXG4gKiBBc3NlcnQgc3VwZXItc3RyaWN0IChlZ2FsKSBlcXVhbGl0eSBiZXR3ZWVuXG4gKiB0d28gb2JqZWN0cyBvZiBhbnkgdHlwZS5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSBhXG4gKiBAcGFyYW0ge01peGVkfSBiXG4gKiBAcGFyYW0ge0FycmF5fSBtZW1vaXNlZCAob3B0aW9uYWwpXG4gKiBAcmV0dXJuIHtCb29sZWFufSBlcXVhbCBtYXRjaFxuICovXG5cbmZ1bmN0aW9uIGRlZXBFcXVhbChhLCBiLCBtKSB7XG4gIGlmIChzYW1lVmFsdWUoYSwgYikpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmICgnZGF0ZScgPT09IHR5cGUoYSkpIHtcbiAgICByZXR1cm4gZGF0ZUVxdWFsKGEsIGIpO1xuICB9IGVsc2UgaWYgKCdyZWdleHAnID09PSB0eXBlKGEpKSB7XG4gICAgcmV0dXJuIHJlZ2V4cEVxdWFsKGEsIGIpO1xuICB9IGVsc2UgaWYgKEJ1ZmZlci5pc0J1ZmZlcihhKSkge1xuICAgIHJldHVybiBidWZmZXJFcXVhbChhLCBiKTtcbiAgfSBlbHNlIGlmICgnYXJndW1lbnRzJyA9PT0gdHlwZShhKSkge1xuICAgIHJldHVybiBhcmd1bWVudHNFcXVhbChhLCBiLCBtKTtcbiAgfSBlbHNlIGlmICghdHlwZUVxdWFsKGEsIGIpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2UgaWYgKCgnb2JqZWN0JyAhPT0gdHlwZShhKSAmJiAnb2JqZWN0JyAhPT0gdHlwZShiKSlcbiAgJiYgKCdhcnJheScgIT09IHR5cGUoYSkgJiYgJ2FycmF5JyAhPT0gdHlwZShiKSkpIHtcbiAgICByZXR1cm4gc2FtZVZhbHVlKGEsIGIpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBvYmplY3RFcXVhbChhLCBiLCBtKTtcbiAgfVxufVxuXG4vKiFcbiAqIFN0cmljdCAoZWdhbCkgZXF1YWxpdHkgdGVzdC4gRW5zdXJlcyB0aGF0IE5hTiBhbHdheXNcbiAqIGVxdWFscyBOYU4gYW5kIGAtMGAgZG9lcyBub3QgZXF1YWwgYCswYC5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSBhXG4gKiBAcGFyYW0ge01peGVkfSBiXG4gKiBAcmV0dXJuIHtCb29sZWFufSBlcXVhbCBtYXRjaFxuICovXG5cbmZ1bmN0aW9uIHNhbWVWYWx1ZShhLCBiKSB7XG4gIGlmIChhID09PSBiKSByZXR1cm4gYSAhPT0gMCB8fCAxIC8gYSA9PT0gMSAvIGI7XG4gIHJldHVybiBhICE9PSBhICYmIGIgIT09IGI7XG59XG5cbi8qIVxuICogQ29tcGFyZSB0aGUgdHlwZXMgb2YgdHdvIGdpdmVuIG9iamVjdHMgYW5kXG4gKiByZXR1cm4gaWYgdGhleSBhcmUgZXF1YWwuIE5vdGUgdGhhdCBhbiBBcnJheVxuICogaGFzIGEgdHlwZSBvZiBgYXJyYXlgIChub3QgYG9iamVjdGApIGFuZCBhcmd1bWVudHNcbiAqIGhhdmUgYSB0eXBlIG9mIGBhcmd1bWVudHNgIChub3QgYGFycmF5YC9gb2JqZWN0YCkuXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gYVxuICogQHBhcmFtIHtNaXhlZH0gYlxuICogQHJldHVybiB7Qm9vbGVhbn0gcmVzdWx0XG4gKi9cblxuZnVuY3Rpb24gdHlwZUVxdWFsKGEsIGIpIHtcbiAgcmV0dXJuIHR5cGUoYSkgPT09IHR5cGUoYik7XG59XG5cbi8qIVxuICogQ29tcGFyZSB0d28gRGF0ZSBvYmplY3RzIGJ5IGFzc2VydGluZyB0aGF0XG4gKiB0aGUgdGltZSB2YWx1ZXMgYXJlIGVxdWFsIHVzaW5nIGBzYXZlVmFsdWVgLlxuICpcbiAqIEBwYXJhbSB7RGF0ZX0gYVxuICogQHBhcmFtIHtEYXRlfSBiXG4gKiBAcmV0dXJuIHtCb29sZWFufSByZXN1bHRcbiAqL1xuXG5mdW5jdGlvbiBkYXRlRXF1YWwoYSwgYikge1xuICBpZiAoJ2RhdGUnICE9PSB0eXBlKGIpKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBzYW1lVmFsdWUoYS5nZXRUaW1lKCksIGIuZ2V0VGltZSgpKTtcbn1cblxuLyohXG4gKiBDb21wYXJlIHR3byByZWd1bGFyIGV4cHJlc3Npb25zIGJ5IGNvbnZlcnRpbmcgdGhlbVxuICogdG8gc3RyaW5nIGFuZCBjaGVja2luZyBmb3IgYHNhbWVWYWx1ZWAuXG4gKlxuICogQHBhcmFtIHtSZWdFeHB9IGFcbiAqIEBwYXJhbSB7UmVnRXhwfSBiXG4gKiBAcmV0dXJuIHtCb29sZWFufSByZXN1bHRcbiAqL1xuXG5mdW5jdGlvbiByZWdleHBFcXVhbChhLCBiKSB7XG4gIGlmICgncmVnZXhwJyAhPT0gdHlwZShiKSkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gc2FtZVZhbHVlKGEudG9TdHJpbmcoKSwgYi50b1N0cmluZygpKTtcbn1cblxuLyohXG4gKiBBc3NlcnQgZGVlcCBlcXVhbGl0eSBvZiB0d28gYGFyZ3VtZW50c2Agb2JqZWN0cy5cbiAqIFVuZm9ydHVuYXRlbHksIHRoZXNlIG11c3QgYmUgc2xpY2VkIHRvIGFycmF5c1xuICogcHJpb3IgdG8gdGVzdCB0byBlbnN1cmUgbm8gYmFkIGJlaGF2aW9yLlxuICpcbiAqIEBwYXJhbSB7QXJndW1lbnRzfSBhXG4gKiBAcGFyYW0ge0FyZ3VtZW50c30gYlxuICogQHBhcmFtIHtBcnJheX0gbWVtb2l6ZSAob3B0aW9uYWwpXG4gKiBAcmV0dXJuIHtCb29sZWFufSByZXN1bHRcbiAqL1xuXG5mdW5jdGlvbiBhcmd1bWVudHNFcXVhbChhLCBiLCBtKSB7XG4gIGlmICgnYXJndW1lbnRzJyAhPT0gdHlwZShiKSkgcmV0dXJuIGZhbHNlO1xuICBhID0gW10uc2xpY2UuY2FsbChhKTtcbiAgYiA9IFtdLnNsaWNlLmNhbGwoYik7XG4gIHJldHVybiBkZWVwRXF1YWwoYSwgYiwgbSk7XG59XG5cbi8qIVxuICogR2V0IGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBhIGdpdmVuIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYVxuICogQHJldHVybiB7QXJyYXl9IHByb3BlcnR5IG5hbWVzXG4gKi9cblxuZnVuY3Rpb24gZW51bWVyYWJsZShhKSB7XG4gIHZhciByZXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIGEpIHJlcy5wdXNoKGtleSk7XG4gIHJldHVybiByZXM7XG59XG5cbi8qIVxuICogU2ltcGxlIGVxdWFsaXR5IGZvciBmbGF0IGl0ZXJhYmxlIG9iamVjdHNcbiAqIHN1Y2ggYXMgQXJyYXlzIG9yIE5vZGUuanMgYnVmZmVycy5cbiAqXG4gKiBAcGFyYW0ge0l0ZXJhYmxlfSBhXG4gKiBAcGFyYW0ge0l0ZXJhYmxlfSBiXG4gKiBAcmV0dXJuIHtCb29sZWFufSByZXN1bHRcbiAqL1xuXG5mdW5jdGlvbiBpdGVyYWJsZUVxdWFsKGEsIGIpIHtcbiAgaWYgKGEubGVuZ3RoICE9PSAgYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcblxuICB2YXIgaSA9IDA7XG4gIHZhciBtYXRjaCA9IHRydWU7XG5cbiAgZm9yICg7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIG1hdGNoID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWF0Y2g7XG59XG5cbi8qIVxuICogRXh0ZW5zaW9uIHRvIGBpdGVyYWJsZUVxdWFsYCBzcGVjaWZpY2FsbHlcbiAqIGZvciBOb2RlLmpzIEJ1ZmZlcnMuXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGFcbiAqIEBwYXJhbSB7TWl4ZWR9IGJcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHJlc3VsdFxuICovXG5cbmZ1bmN0aW9uIGJ1ZmZlckVxdWFsKGEsIGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIGl0ZXJhYmxlRXF1YWwoYSwgYik7XG59XG5cbi8qIVxuICogQmxvY2sgZm9yIGBvYmplY3RFcXVhbGAgZW5zdXJpbmcgbm9uLWV4aXN0aW5nXG4gKiB2YWx1ZXMgZG9uJ3QgZ2V0IGluLlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IG9iamVjdFxuICogQHJldHVybiB7Qm9vbGVhbn0gcmVzdWx0XG4gKi9cblxuZnVuY3Rpb24gaXNWYWx1ZShhKSB7XG4gIHJldHVybiBhICE9PSBudWxsICYmIGEgIT09IHVuZGVmaW5lZDtcbn1cblxuLyohXG4gKiBSZWN1cnNpdmVseSBjaGVjayB0aGUgZXF1YWxpdHkgb2YgdHdvIG9iamVjdHMuXG4gKiBPbmNlIGJhc2ljIHNhbWVuZXNzIGhhcyBiZWVuIGVzdGFibGlzaGVkIGl0IHdpbGxcbiAqIGRlZmVyIHRvIGBkZWVwRXF1YWxgIGZvciBlYWNoIGVudW1lcmFibGUga2V5XG4gKiBpbiB0aGUgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IGFcbiAqIEBwYXJhbSB7TWl4ZWR9IGJcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHJlc3VsdFxuICovXG5cbmZ1bmN0aW9uIG9iamVjdEVxdWFsKGEsIGIsIG0pIHtcbiAgaWYgKCFpc1ZhbHVlKGEpIHx8ICFpc1ZhbHVlKGIpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGEucHJvdG90eXBlICE9PSBiLnByb3RvdHlwZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBpO1xuICBpZiAobSkge1xuICAgIGZvciAoaSA9IDA7IGkgPCBtLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoKG1baV1bMF0gPT09IGEgJiYgbVtpXVsxXSA9PT0gYilcbiAgICAgIHx8ICAobVtpXVswXSA9PT0gYiAmJiBtW2ldWzFdID09PSBhKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbSA9IFtdO1xuICB9XG5cbiAgdHJ5IHtcbiAgICB2YXIga2EgPSBlbnVtZXJhYmxlKGEpO1xuICAgIHZhciBrYiA9IGVudW1lcmFibGUoYik7XG4gIH0gY2F0Y2ggKGV4KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAga2Euc29ydCgpO1xuICBrYi5zb3J0KCk7XG5cbiAgaWYgKCFpdGVyYWJsZUVxdWFsKGthLCBrYikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBtLnB1c2goWyBhLCBiIF0pO1xuXG4gIHZhciBrZXk7XG4gIGZvciAoaSA9IGthLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAga2V5ID0ga2FbaV07XG4gICAgaWYgKCFkZWVwRXF1YWwoYVtrZXldLCBiW2tleV0sIG0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL3R5cGUnKTtcbiIsIi8qIVxuICogdHlwZS1kZXRlY3RcbiAqIENvcHlyaWdodChjKSAyMDEzIGpha2UgbHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyohXG4gKiBQcmltYXJ5IEV4cG9ydHNcbiAqL1xuXG52YXIgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZ2V0VHlwZTtcblxuLyohXG4gKiBEZXRlY3RhYmxlIGphdmFzY3JpcHQgbmF0aXZlc1xuICovXG5cbnZhciBuYXRpdmVzID0ge1xuICAgICdbb2JqZWN0IEFycmF5XSc6ICdhcnJheSdcbiAgLCAnW29iamVjdCBSZWdFeHBdJzogJ3JlZ2V4cCdcbiAgLCAnW29iamVjdCBGdW5jdGlvbl0nOiAnZnVuY3Rpb24nXG4gICwgJ1tvYmplY3QgQXJndW1lbnRzXSc6ICdhcmd1bWVudHMnXG4gICwgJ1tvYmplY3QgRGF0ZV0nOiAnZGF0ZSdcbn07XG5cbi8qKlxuICogIyMjIHR5cGVPZiAob2JqKVxuICpcbiAqIFVzZSBzZXZlcmFsIGRpZmZlcmVudCB0ZWNobmlxdWVzIHRvIGRldGVybWluZVxuICogdGhlIHR5cGUgb2Ygb2JqZWN0IGJlaW5nIHRlc3RlZC5cbiAqXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gb2JqZWN0XG4gKiBAcmV0dXJuIHtTdHJpbmd9IG9iamVjdCB0eXBlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGdldFR5cGUgKG9iaikge1xuICB2YXIgc3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaik7XG4gIGlmIChuYXRpdmVzW3N0cl0pIHJldHVybiBuYXRpdmVzW3N0cl07XG4gIGlmIChvYmogPT09IG51bGwpIHJldHVybiAnbnVsbCc7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgcmV0dXJuICd1bmRlZmluZWQnO1xuICBpZiAob2JqID09PSBPYmplY3Qob2JqKSkgcmV0dXJuICdvYmplY3QnO1xuICByZXR1cm4gdHlwZW9mIG9iajtcbn1cblxuZXhwb3J0cy5MaWJyYXJ5ID0gTGlicmFyeTtcblxuLyoqXG4gKiAjIyMgTGlicmFyeVxuICpcbiAqIENyZWF0ZSBhIHJlcG9zaXRvcnkgZm9yIGN1c3RvbSB0eXBlIGRldGVjdGlvbi5cbiAqXG4gKiBgYGBqc1xuICogdmFyIGxpYiA9IG5ldyB0eXBlLkxpYnJhcnk7XG4gKiBgYGBcbiAqXG4gKi9cblxuZnVuY3Rpb24gTGlicmFyeSAoKSB7XG4gIHRoaXMudGVzdHMgPSB7fTtcbn1cblxuLyoqXG4gKiAjIyMjIC5vZiAob2JqKVxuICpcbiAqIEV4cG9zZSByZXBsYWNlbWVudCBgdHlwZW9mYCBkZXRlY3Rpb24gdG8gdGhlIGxpYnJhcnkuXG4gKlxuICogYGBganNcbiAqIGlmICgnc3RyaW5nJyA9PT0gbGliLm9mKCdoZWxsbyB3b3JsZCcpKSB7XG4gKiAgIC8vIC4uLlxuICogfVxuICogYGBgXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gb2JqZWN0IHRvIHRlc3RcbiAqIEByZXR1cm4ge1N0cmluZ30gdHlwZVxuICovXG5cbkxpYnJhcnkucHJvdG90eXBlLm9mID0gZ2V0VHlwZTtcblxuLyoqXG4gKiAjIyMjIC5kZWZpbmUgKHR5cGUsIHRlc3QpXG4gKlxuICogQWRkIGEgdGVzdCB0byBmb3IgdGhlIGAudGVzdCgpYCBhc3NlcnRpb24uXG4gKlxuICogQ2FuIGJlIGRlZmluZWQgYXMgYSByZWd1bGFyIGV4cHJlc3Npb246XG4gKlxuICogYGBganNcbiAqIGxpYi5kZWZpbmUoJ2ludCcsIC9eWzAtOV0rJC8pO1xuICogYGBgXG4gKlxuICogLi4uIG9yIGFzIGEgZnVuY3Rpb246XG4gKlxuICogYGBganNcbiAqIGxpYi5kZWZpbmUoJ2JsbicsIGZ1bmN0aW9uIChvYmopIHtcbiAqICAgaWYgKCdib29sZWFuJyA9PT0gbGliLm9mKG9iaikpIHJldHVybiB0cnVlO1xuICogICB2YXIgYmxucyA9IFsgJ3llcycsICdubycsICd0cnVlJywgJ2ZhbHNlJywgMSwgMCBdO1xuICogICBpZiAoJ3N0cmluZycgPT09IGxpYi5vZihvYmopKSBvYmogPSBvYmoudG9Mb3dlckNhc2UoKTtcbiAqICAgcmV0dXJuICEhIH5ibG5zLmluZGV4T2Yob2JqKTtcbiAqIH0pO1xuICogYGBgXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqIEBwYXJhbSB7UmVnRXhwfEZ1bmN0aW9ufSB0ZXN0XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkxpYnJhcnkucHJvdG90eXBlLmRlZmluZSA9IGZ1bmN0aW9uICh0eXBlLCB0ZXN0KSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSByZXR1cm4gdGhpcy50ZXN0c1t0eXBlXTtcbiAgdGhpcy50ZXN0c1t0eXBlXSA9IHRlc3Q7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiAjIyMjIC50ZXN0IChvYmosIHRlc3QpXG4gKlxuICogQXNzZXJ0IHRoYXQgYW4gb2JqZWN0IGlzIG9mIHR5cGUuIFdpbGwgZmlyc3RcbiAqIGNoZWNrIG5hdGl2ZXMsIGFuZCBpZiB0aGF0IGRvZXMgbm90IHBhc3MgaXQgd2lsbFxuICogdXNlIHRoZSB1c2VyIGRlZmluZWQgY3VzdG9tIHRlc3RzLlxuICpcbiAqIGBgYGpzXG4gKiBhc3NlcnQobGliLnRlc3QoJzEnLCAnaW50JykpO1xuICogYXNzZXJ0KGxpYi50ZXN0KCd5ZXMnLCAnYmxuJykpO1xuICogYGBgXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gb2JqZWN0XG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICogQHJldHVybiB7Qm9vbGVhbn0gcmVzdWx0XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkxpYnJhcnkucHJvdG90eXBlLnRlc3QgPSBmdW5jdGlvbiAob2JqLCB0eXBlKSB7XG4gIGlmICh0eXBlID09PSBnZXRUeXBlKG9iaikpIHJldHVybiB0cnVlO1xuICB2YXIgdGVzdCA9IHRoaXMudGVzdHNbdHlwZV07XG5cbiAgaWYgKHRlc3QgJiYgJ3JlZ2V4cCcgPT09IGdldFR5cGUodGVzdCkpIHtcbiAgICByZXR1cm4gdGVzdC50ZXN0KG9iaik7XG4gIH0gZWxzZSBpZiAodGVzdCAmJiAnZnVuY3Rpb24nID09PSBnZXRUeXBlKHRlc3QpKSB7XG4gICAgcmV0dXJuIHRlc3Qob2JqKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoJ1R5cGUgdGVzdCBcIicgKyB0eXBlICsgJ1wiIG5vdCBkZWZpbmVkIG9yIGludmFsaWQuJyk7XG4gIH1cbn07XG4iLG51bGwsIi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cblxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG52YXIgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5TbG93QnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTBcbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTJcblxuLyoqXG4gKiBJZiBgVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBVc2UgT2JqZWN0IGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBOb3RlOlxuICpcbiAqIC0gSW1wbGVtZW50YXRpb24gbXVzdCBzdXBwb3J0IGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWAgaW5zdGFuY2VzLlxuICogICBGaXJlZm94IDQtMjkgbGFja2VkIHN1cHBvcnQsIGZpeGVkIGluIEZpcmVmb3ggMzArLlxuICogICBTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOC5cbiAqXG4gKiAgLSBDaHJvbWUgOS0xMCBpcyBtaXNzaW5nIHRoZSBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uLlxuICpcbiAqICAtIElFMTAgaGFzIGEgYnJva2VuIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhcnJheXMgb2ZcbiAqICAgIGluY29ycmVjdCBsZW5ndGggaW4gc29tZSBzaXR1YXRpb25zLlxuICpcbiAqIFdlIGRldGVjdCB0aGVzZSBidWdneSBicm93c2VycyBhbmQgc2V0IGBUWVBFRF9BUlJBWV9TVVBQT1JUYCB0byBgZmFsc2VgIHNvIHRoZXkgd2lsbFxuICogZ2V0IHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24sIHdoaWNoIGlzIHNsb3dlciBidXQgd2lsbCB3b3JrIGNvcnJlY3RseS5cbiAqL1xudmFyIFRZUEVEX0FSUkFZX1NVUFBPUlQgPSAoZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIHZhciBidWYgPSBuZXcgQXJyYXlCdWZmZXIoMClcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoYnVmKVxuICAgIGFyci5mb28gPSBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9XG4gICAgcmV0dXJuIDQyID09PSBhcnIuZm9vKCkgJiYgLy8gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWRcbiAgICAgICAgdHlwZW9mIGFyci5zdWJhcnJheSA9PT0gJ2Z1bmN0aW9uJyAmJiAvLyBjaHJvbWUgOS0xMCBsYWNrIGBzdWJhcnJheWBcbiAgICAgICAgbmV3IFVpbnQ4QXJyYXkoMSkuc3ViYXJyYXkoMSwgMSkuYnl0ZUxlbmd0aCA9PT0gMCAvLyBpZTEwIGhhcyBicm9rZW4gYHN1YmFycmF5YFxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn0pKClcblxuLyoqXG4gKiBDbGFzczogQnVmZmVyXG4gKiA9PT09PT09PT09PT09XG4gKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBhcmUgYXVnbWVudGVkXG4gKiB3aXRoIGZ1bmN0aW9uIHByb3BlcnRpZXMgZm9yIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBBUEkgZnVuY3Rpb25zLiBXZSB1c2VcbiAqIGBVaW50OEFycmF5YCBzbyB0aGF0IHNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0IHJldHVybnNcbiAqIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIEJ5IGF1Z21lbnRpbmcgdGhlIGluc3RhbmNlcywgd2UgY2FuIGF2b2lkIG1vZGlmeWluZyB0aGUgYFVpbnQ4QXJyYXlgXG4gKiBwcm90b3R5cGUuXG4gKi9cbmZ1bmN0aW9uIEJ1ZmZlciAoc3ViamVjdCwgZW5jb2RpbmcsIG5vWmVybykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQnVmZmVyKSlcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihzdWJqZWN0LCBlbmNvZGluZywgbm9aZXJvKVxuXG4gIHZhciB0eXBlID0gdHlwZW9mIHN1YmplY3RcblxuICAvLyBGaW5kIHRoZSBsZW5ndGhcbiAgdmFyIGxlbmd0aFxuICBpZiAodHlwZSA9PT0gJ251bWJlcicpXG4gICAgbGVuZ3RoID0gc3ViamVjdCA+IDAgPyBzdWJqZWN0ID4+PiAwIDogMFxuICBlbHNlIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgIGlmIChlbmNvZGluZyA9PT0gJ2Jhc2U2NCcpXG4gICAgICBzdWJqZWN0ID0gYmFzZTY0Y2xlYW4oc3ViamVjdClcbiAgICBsZW5ndGggPSBCdWZmZXIuYnl0ZUxlbmd0aChzdWJqZWN0LCBlbmNvZGluZylcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnb2JqZWN0JyAmJiBzdWJqZWN0ICE9PSBudWxsKSB7IC8vIGFzc3VtZSBvYmplY3QgaXMgYXJyYXktbGlrZVxuICAgIGlmIChzdWJqZWN0LnR5cGUgPT09ICdCdWZmZXInICYmIGlzQXJyYXkoc3ViamVjdC5kYXRhKSlcbiAgICAgIHN1YmplY3QgPSBzdWJqZWN0LmRhdGFcbiAgICBsZW5ndGggPSArc3ViamVjdC5sZW5ndGggPiAwID8gTWF0aC5mbG9vcigrc3ViamVjdC5sZW5ndGgpIDogMFxuICB9IGVsc2VcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG5lZWRzIHRvIGJlIGEgbnVtYmVyLCBhcnJheSBvciBzdHJpbmcuJylcblxuICB2YXIgYnVmXG4gIGlmIChUWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUHJlZmVycmVkOiBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIGJ1ZiA9IEJ1ZmZlci5fYXVnbWVudChuZXcgVWludDhBcnJheShsZW5ndGgpKVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gVEhJUyBpbnN0YW5jZSBvZiBCdWZmZXIgKGNyZWF0ZWQgYnkgYG5ld2ApXG4gICAgYnVmID0gdGhpc1xuICAgIGJ1Zi5sZW5ndGggPSBsZW5ndGhcbiAgICBidWYuX2lzQnVmZmVyID0gdHJ1ZVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKFRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgdHlwZW9mIHN1YmplY3QuYnl0ZUxlbmd0aCA9PT0gJ251bWJlcicpIHtcbiAgICAvLyBTcGVlZCBvcHRpbWl6YXRpb24gLS0gdXNlIHNldCBpZiB3ZSdyZSBjb3B5aW5nIGZyb20gYSB0eXBlZCBhcnJheVxuICAgIGJ1Zi5fc2V0KHN1YmplY3QpXG4gIH0gZWxzZSBpZiAoaXNBcnJheWlzaChzdWJqZWN0KSkge1xuICAgIC8vIFRyZWF0IGFycmF5LWlzaCBvYmplY3RzIGFzIGEgYnl0ZSBhcnJheVxuICAgIGlmIChCdWZmZXIuaXNCdWZmZXIoc3ViamVjdCkpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKylcbiAgICAgICAgYnVmW2ldID0gc3ViamVjdC5yZWFkVUludDgoaSlcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKVxuICAgICAgICBidWZbaV0gPSAoKHN1YmplY3RbaV0gJSAyNTYpICsgMjU2KSAlIDI1NlxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgIGJ1Zi53cml0ZShzdWJqZWN0LCAwLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJyAmJiAhVFlQRURfQVJSQVlfU1VQUE9SVCAmJiAhbm9aZXJvKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBidWZbaV0gPSAwXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ1ZlxufVxuXG4vLyBTVEFUSUMgTUVUSE9EU1xuLy8gPT09PT09PT09PT09PT1cblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3Jhdyc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIChiKSB7XG4gIHJldHVybiAhIShiICE9IG51bGwgJiYgYi5faXNCdWZmZXIpXG59XG5cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gZnVuY3Rpb24gKHN0ciwgZW5jb2RpbmcpIHtcbiAgdmFyIHJldFxuICBzdHIgPSBzdHIudG9TdHJpbmcoKVxuICBzd2l0Y2ggKGVuY29kaW5nIHx8ICd1dGY4Jykge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgICByZXQgPSBzdHIubGVuZ3RoIC8gMlxuICAgICAgYnJlYWtcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgICByZXQgPSB1dGY4VG9CeXRlcyhzdHIpLmxlbmd0aFxuICAgICAgYnJlYWtcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdyYXcnOlxuICAgICAgcmV0ID0gc3RyLmxlbmd0aFxuICAgICAgYnJlYWtcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgcmV0ID0gYmFzZTY0VG9CeXRlcyhzdHIpLmxlbmd0aFxuICAgICAgYnJlYWtcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0ID0gc3RyLmxlbmd0aCAqIDJcbiAgICAgIGJyZWFrXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZycpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gKGxpc3QsIHRvdGFsTGVuZ3RoKSB7XG4gIGFzc2VydChpc0FycmF5KGxpc3QpLCAnVXNhZ2U6IEJ1ZmZlci5jb25jYXQobGlzdFssIGxlbmd0aF0pJylcblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcigwKVxuICB9IGVsc2UgaWYgKGxpc3QubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIGxpc3RbMF1cbiAgfVxuXG4gIHZhciBpXG4gIGlmICh0b3RhbExlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdG90YWxMZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRvdGFsTGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZiA9IG5ldyBCdWZmZXIodG90YWxMZW5ndGgpXG4gIHZhciBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBsaXN0W2ldXG4gICAgaXRlbS5jb3B5KGJ1ZiwgcG9zKVxuICAgIHBvcyArPSBpdGVtLmxlbmd0aFxuICB9XG4gIHJldHVybiBidWZcbn1cblxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiAoYSwgYikge1xuICBhc3NlcnQoQnVmZmVyLmlzQnVmZmVyKGEpICYmIEJ1ZmZlci5pc0J1ZmZlcihiKSwgJ0FyZ3VtZW50cyBtdXN0IGJlIEJ1ZmZlcnMnKVxuICB2YXIgeCA9IGEubGVuZ3RoXG4gIHZhciB5ID0gYi5sZW5ndGhcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuICYmIGFbaV0gPT09IGJbaV07IGkrKykge31cbiAgaWYgKGkgIT09IGxlbikge1xuICAgIHggPSBhW2ldXG4gICAgeSA9IGJbaV1cbiAgfVxuICBpZiAoeCA8IHkpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICBpZiAoeSA8IHgpIHtcbiAgICByZXR1cm4gMVxuICB9XG4gIHJldHVybiAwXG59XG5cbi8vIEJVRkZFUiBJTlNUQU5DRSBNRVRIT0RTXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PVxuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIC8vIG11c3QgYmUgYW4gZXZlbiBudW1iZXIgb2YgZGlnaXRzXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGFzc2VydChzdHJMZW4gJSAyID09PSAwLCAnSW52YWxpZCBoZXggc3RyaW5nJylcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDJcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGJ5dGUgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXG4gICAgYXNzZXJ0KCFpc05hTihieXRlKSwgJ0ludmFsaWQgaGV4IHN0cmluZycpXG4gICAgYnVmW29mZnNldCArIGldID0gYnl0ZVxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHZhciBjaGFyc1dyaXR0ZW4gPSBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG4gIHJldHVybiBjaGFyc1dyaXR0ZW5cbn1cblxuZnVuY3Rpb24gYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHZhciBjaGFyc1dyaXR0ZW4gPSBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxuICByZXR1cm4gY2hhcnNXcml0dGVuXG59XG5cbmZ1bmN0aW9uIGJpbmFyeVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGFzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHZhciBjaGFyc1dyaXR0ZW4gPSBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbiAgcmV0dXJuIGNoYXJzV3JpdHRlblxufVxuXG5mdW5jdGlvbiB1dGYxNmxlV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgY2hhcnNXcml0dGVuID0gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxuICByZXR1cm4gY2hhcnNXcml0dGVuXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gU3VwcG9ydCBib3RoIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZylcbiAgLy8gYW5kIHRoZSBsZWdhY3kgKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIGlmICghaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGhcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgfSBlbHNlIHsgIC8vIGxlZ2FjeVxuICAgIHZhciBzd2FwID0gZW5jb2RpbmdcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIG9mZnNldCA9IGxlbmd0aFxuICAgIGxlbmd0aCA9IHN3YXBcbiAgfVxuXG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cbiAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcgfHwgJ3V0ZjgnKS50b0xvd2VyQ2FzZSgpXG5cbiAgdmFyIHJldFxuICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICAgIHJldCA9IGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIHJldCA9IHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgICByZXQgPSBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICByZXQgPSBiaW5hcnlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgcmV0ID0gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldCA9IHV0ZjE2bGVXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nJylcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG5cbiAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcgfHwgJ3V0ZjgnKS50b0xvd2VyQ2FzZSgpXG4gIHN0YXJ0ID0gTnVtYmVyKHN0YXJ0KSB8fCAwXG4gIGVuZCA9IChlbmQgPT09IHVuZGVmaW5lZCkgPyBzZWxmLmxlbmd0aCA6IE51bWJlcihlbmQpXG5cbiAgLy8gRmFzdHBhdGggZW1wdHkgc3RyaW5nc1xuICBpZiAoZW5kID09PSBzdGFydClcbiAgICByZXR1cm4gJydcblxuICB2YXIgcmV0XG4gIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgICAgcmV0ID0gaGV4U2xpY2Uoc2VsZiwgc3RhcnQsIGVuZClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgICAgcmV0ID0gdXRmOFNsaWNlKHNlbGYsIHN0YXJ0LCBlbmQpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIHJldCA9IGFzY2lpU2xpY2Uoc2VsZiwgc3RhcnQsIGVuZClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgIHJldCA9IGJpbmFyeVNsaWNlKHNlbGYsIHN0YXJ0LCBlbmQpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICByZXQgPSBiYXNlNjRTbGljZShzZWxmLCBzdGFydCwgZW5kKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0ID0gdXRmMTZsZVNsaWNlKHNlbGYsIHN0YXJ0LCBlbmQpXG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2RpbmcnKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiAoYikge1xuICBhc3NlcnQoQnVmZmVyLmlzQnVmZmVyKGIpLCAnQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiAoYikge1xuICBhc3NlcnQoQnVmZmVyLmlzQnVmZmVyKGIpLCAnQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAodGFyZ2V0LCB0YXJnZXRfc3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHNvdXJjZSA9IHRoaXNcblxuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAoIXRhcmdldF9zdGFydCkgdGFyZ2V0X3N0YXJ0ID0gMFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHNvdXJjZS5sZW5ndGggPT09IDApIHJldHVyblxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgYXNzZXJ0KGVuZCA+PSBzdGFydCwgJ3NvdXJjZUVuZCA8IHNvdXJjZVN0YXJ0JylcbiAgYXNzZXJ0KHRhcmdldF9zdGFydCA+PSAwICYmIHRhcmdldF9zdGFydCA8IHRhcmdldC5sZW5ndGgsXG4gICAgICAndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGFzc2VydChzdGFydCA+PSAwICYmIHN0YXJ0IDwgc291cmNlLmxlbmd0aCwgJ3NvdXJjZVN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBhc3NlcnQoZW5kID49IDAgJiYgZW5kIDw9IHNvdXJjZS5sZW5ndGgsICdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKVxuICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0X3N0YXJ0IDwgZW5kIC0gc3RhcnQpXG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldF9zdGFydCArIHN0YXJ0XG5cbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XG5cbiAgaWYgKGxlbiA8IDEwMCB8fCAhVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0X3N0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0YXJnZXQuX3NldCh0aGlzLnN1YmFycmF5KHN0YXJ0LCBzdGFydCArIGxlbiksIHRhcmdldF9zdGFydClcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJlcyA9ICcnXG4gIHZhciB0bXAgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICBpZiAoYnVmW2ldIDw9IDB4N0YpIHtcbiAgICAgIHJlcyArPSBkZWNvZGVVdGY4Q2hhcih0bXApICsgU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gICAgICB0bXAgPSAnJ1xuICAgIH0gZWxzZSB7XG4gICAgICB0bXAgKz0gJyUnICsgYnVmW2ldLnRvU3RyaW5nKDE2KVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXMgKyBkZWNvZGVVdGY4Q2hhcih0bXApXG59XG5cbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gYmluYXJ5U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICByZXR1cm4gYXNjaWlTbGljZShidWYsIHN0YXJ0LCBlbmQpXG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cblxuICB2YXIgb3V0ID0gJydcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICBvdXQgKz0gdG9IZXgoYnVmW2ldKVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHZhciByZXMgPSAnJ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyBieXRlc1tpICsgMV0gKiAyNTYpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gfn5zdGFydFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kXG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlbjtcbiAgICBpZiAoc3RhcnQgPCAwKVxuICAgICAgc3RhcnQgPSAwXG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuXG4gICAgaWYgKGVuZCA8IDApXG4gICAgICBlbmQgPSAwXG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpXG4gICAgZW5kID0gc3RhcnRcblxuICBpZiAoVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHJldHVybiBCdWZmZXIuX2F1Z21lbnQodGhpcy5zdWJhcnJheShzdGFydCwgZW5kKSlcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2xpY2VMZW4gPSBlbmQgLSBzdGFydFxuICAgIHZhciBuZXdCdWYgPSBuZXcgQnVmZmVyKHNsaWNlTGVuLCB1bmRlZmluZWQsIHRydWUpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbGljZUxlbjsgaSsrKSB7XG4gICAgICBuZXdCdWZbaV0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gICAgcmV0dXJuIG5ld0J1ZlxuICB9XG59XG5cbi8vIGBnZXRgIHdpbGwgYmUgcmVtb3ZlZCBpbiBOb2RlIDAuMTMrXG5CdWZmZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgY29uc29sZS5sb2coJy5nZXQoKSBpcyBkZXByZWNhdGVkLiBBY2Nlc3MgdXNpbmcgYXJyYXkgaW5kZXhlcyBpbnN0ZWFkLicpXG4gIHJldHVybiB0aGlzLnJlYWRVSW50OChvZmZzZXQpXG59XG5cbi8vIGBzZXRgIHdpbGwgYmUgcmVtb3ZlZCBpbiBOb2RlIDAuMTMrXG5CdWZmZXIucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh2LCBvZmZzZXQpIHtcbiAgY29uc29sZS5sb2coJy5zZXQoKSBpcyBkZXByZWNhdGVkLiBBY2Nlc3MgdXNpbmcgYXJyYXkgaW5kZXhlcyBpbnN0ZWFkLicpXG4gIHJldHVybiB0aGlzLndyaXRlVUludDgodiwgb2Zmc2V0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgPCB0aGlzLmxlbmd0aCwgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgfVxuXG4gIGlmIChvZmZzZXQgPj0gdGhpcy5sZW5ndGgpXG4gICAgcmV0dXJuXG5cbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5mdW5jdGlvbiByZWFkVUludDE2IChidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDEgPCBidWYubGVuZ3RoLCAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgdmFyIHZhbFxuICBpZiAobGl0dGxlRW5kaWFuKSB7XG4gICAgdmFsID0gYnVmW29mZnNldF1cbiAgICBpZiAob2Zmc2V0ICsgMSA8IGxlbilcbiAgICAgIHZhbCB8PSBidWZbb2Zmc2V0ICsgMV0gPDwgOFxuICB9IGVsc2Uge1xuICAgIHZhbCA9IGJ1ZltvZmZzZXRdIDw8IDhcbiAgICBpZiAob2Zmc2V0ICsgMSA8IGxlbilcbiAgICAgIHZhbCB8PSBidWZbb2Zmc2V0ICsgMV1cbiAgfVxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRVSW50MTYodGhpcywgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZFVJbnQxNih0aGlzLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gcmVhZFVJbnQzMiAoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyAzIDwgYnVmLmxlbmd0aCwgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIHZhciB2YWxcbiAgaWYgKGxpdHRsZUVuZGlhbikge1xuICAgIGlmIChvZmZzZXQgKyAyIDwgbGVuKVxuICAgICAgdmFsID0gYnVmW29mZnNldCArIDJdIDw8IDE2XG4gICAgaWYgKG9mZnNldCArIDEgPCBsZW4pXG4gICAgICB2YWwgfD0gYnVmW29mZnNldCArIDFdIDw8IDhcbiAgICB2YWwgfD0gYnVmW29mZnNldF1cbiAgICBpZiAob2Zmc2V0ICsgMyA8IGxlbilcbiAgICAgIHZhbCA9IHZhbCArIChidWZbb2Zmc2V0ICsgM10gPDwgMjQgPj4+IDApXG4gIH0gZWxzZSB7XG4gICAgaWYgKG9mZnNldCArIDEgPCBsZW4pXG4gICAgICB2YWwgPSBidWZbb2Zmc2V0ICsgMV0gPDwgMTZcbiAgICBpZiAob2Zmc2V0ICsgMiA8IGxlbilcbiAgICAgIHZhbCB8PSBidWZbb2Zmc2V0ICsgMl0gPDwgOFxuICAgIGlmIChvZmZzZXQgKyAzIDwgbGVuKVxuICAgICAgdmFsIHw9IGJ1ZltvZmZzZXQgKyAzXVxuICAgIHZhbCA9IHZhbCArIChidWZbb2Zmc2V0XSA8PCAyNCA+Pj4gMClcbiAgfVxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRVSW50MzIodGhpcywgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZFVJbnQzMih0aGlzLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgPCB0aGlzLmxlbmd0aCwgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgfVxuXG4gIGlmIChvZmZzZXQgPj0gdGhpcy5sZW5ndGgpXG4gICAgcmV0dXJuXG5cbiAgdmFyIG5lZyA9IHRoaXNbb2Zmc2V0XSAmIDB4ODBcbiAgaWYgKG5lZylcbiAgICByZXR1cm4gKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xXG4gIGVsc2VcbiAgICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbmZ1bmN0aW9uIHJlYWRJbnQxNiAoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyAxIDwgYnVmLmxlbmd0aCwgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIHZhciB2YWwgPSByZWFkVUludDE2KGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIHRydWUpXG4gIHZhciBuZWcgPSB2YWwgJiAweDgwMDBcbiAgaWYgKG5lZylcbiAgICByZXR1cm4gKDB4ZmZmZiAtIHZhbCArIDEpICogLTFcbiAgZWxzZVxuICAgIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkSW50MTYodGhpcywgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkSW50MTYodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHJlYWRJbnQzMiAoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyAzIDwgYnVmLmxlbmd0aCwgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIHZhciB2YWwgPSByZWFkVUludDMyKGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIHRydWUpXG4gIHZhciBuZWcgPSB2YWwgJiAweDgwMDAwMDAwXG4gIGlmIChuZWcpXG4gICAgcmV0dXJuICgweGZmZmZmZmZmIC0gdmFsICsgMSkgKiAtMVxuICBlbHNlXG4gICAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRJbnQzMih0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRJbnQzMih0aGlzLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gcmVhZEZsb2F0IChidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgKyAzIDwgYnVmLmxlbmd0aCwgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgfVxuXG4gIHJldHVybiBpZWVlNzU0LnJlYWQoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZEZsb2F0KHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZEZsb2F0KHRoaXMsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiByZWFkRG91YmxlIChidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgKyA3IDwgYnVmLmxlbmd0aCwgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgfVxuXG4gIHJldHVybiBpZWVlNzU0LnJlYWQoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWREb3VibGUodGhpcywgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZERvdWJsZSh0aGlzLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCwgJ21pc3NpbmcgdmFsdWUnKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCA8IHRoaXMubGVuZ3RoLCAndHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgICB2ZXJpZnVpbnQodmFsdWUsIDB4ZmYpXG4gIH1cblxuICBpZiAob2Zmc2V0ID49IHRoaXMubGVuZ3RoKSByZXR1cm5cblxuICB0aGlzW29mZnNldF0gPSB2YWx1ZVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5mdW5jdGlvbiB3cml0ZVVJbnQxNiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCwgJ21pc3NpbmcgdmFsdWUnKVxuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyAxIDwgYnVmLmxlbmd0aCwgJ3RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gICAgdmVyaWZ1aW50KHZhbHVlLCAweGZmZmYpXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGxlbiAtIG9mZnNldCwgMik7IGkgPCBqOyBpKyspIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPVxuICAgICAgICAodmFsdWUgJiAoMHhmZiA8PCAoOCAqIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpKSkpID4+PlxuICAgICAgICAgICAgKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkgKiA4XG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlVUludDMyIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLCAnbWlzc2luZyB2YWx1ZScpXG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDMgPCBidWYubGVuZ3RoLCAndHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgICB2ZXJpZnVpbnQodmFsdWUsIDB4ZmZmZmZmZmYpXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGxlbiAtIG9mZnNldCwgNCk7IGkgPCBqOyBpKyspIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPVxuICAgICAgICAodmFsdWUgPj4+IChsaXR0bGVFbmRpYW4gPyBpIDogMyAtIGkpICogOCkgJiAweGZmXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCwgJ21pc3NpbmcgdmFsdWUnKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCA8IHRoaXMubGVuZ3RoLCAnVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgICB2ZXJpZnNpbnQodmFsdWUsIDB4N2YsIC0weDgwKVxuICB9XG5cbiAgaWYgKG9mZnNldCA+PSB0aGlzLmxlbmd0aClcbiAgICByZXR1cm5cblxuICBpZiAodmFsdWUgPj0gMClcbiAgICB0aGlzLndyaXRlVUludDgodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpXG4gIGVsc2VcbiAgICB0aGlzLndyaXRlVUludDgoMHhmZiArIHZhbHVlICsgMSwgb2Zmc2V0LCBub0Fzc2VydClcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuZnVuY3Rpb24gd3JpdGVJbnQxNiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCwgJ21pc3NpbmcgdmFsdWUnKVxuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyAxIDwgYnVmLmxlbmd0aCwgJ1RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gICAgdmVyaWZzaW50KHZhbHVlLCAweDdmZmYsIC0weDgwMDApXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICBpZiAodmFsdWUgPj0gMClcbiAgICB3cml0ZVVJbnQxNihidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpXG4gIGVsc2VcbiAgICB3cml0ZVVJbnQxNihidWYsIDB4ZmZmZiArIHZhbHVlICsgMSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZUludDMyIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLCAnbWlzc2luZyB2YWx1ZScpXG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDMgPCBidWYubGVuZ3RoLCAnVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgICB2ZXJpZnNpbnQodmFsdWUsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgaWYgKHZhbHVlID49IDApXG4gICAgd3JpdGVVSW50MzIoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KVxuICBlbHNlXG4gICAgd3JpdGVVSW50MzIoYnVmLCAweGZmZmZmZmZmICsgdmFsdWUgKyAxLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsICdtaXNzaW5nIHZhbHVlJylcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMyA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICAgIHZlcmlmSUVFRTc1NCh2YWx1ZSwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsICdtaXNzaW5nIHZhbHVlJylcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgNyA8IGJ1Zi5sZW5ndGgsXG4gICAgICAgICdUcnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICAgIHZlcmlmSUVFRTc1NCh2YWx1ZSwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gZmlsbCh2YWx1ZSwgc3RhcnQ9MCwgZW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiAodmFsdWUsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCF2YWx1ZSkgdmFsdWUgPSAwXG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCkgZW5kID0gdGhpcy5sZW5ndGhcblxuICBhc3NlcnQoZW5kID49IHN0YXJ0LCAnZW5kIDwgc3RhcnQnKVxuXG4gIC8vIEZpbGwgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuXG4gIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuXG5cbiAgYXNzZXJ0KHN0YXJ0ID49IDAgJiYgc3RhcnQgPCB0aGlzLmxlbmd0aCwgJ3N0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBhc3NlcnQoZW5kID49IDAgJiYgZW5kIDw9IHRoaXMubGVuZ3RoLCAnZW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIHZhciBpXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgdGhpc1tpXSA9IHZhbHVlXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBieXRlcyA9IHV0ZjhUb0J5dGVzKHZhbHVlLnRvU3RyaW5nKCkpXG4gICAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aFxuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgIHRoaXNbaV0gPSBieXRlc1tpICUgbGVuXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG91dCA9IFtdXG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgb3V0W2ldID0gdG9IZXgodGhpc1tpXSlcbiAgICBpZiAoaSA9PT0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUykge1xuICAgICAgb3V0W2kgKyAxXSA9ICcuLi4nXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuICByZXR1cm4gJzxCdWZmZXIgJyArIG91dC5qb2luKCcgJykgKyAnPidcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGBBcnJheUJ1ZmZlcmAgd2l0aCB0aGUgKmNvcGllZCogbWVtb3J5IG9mIHRoZSBidWZmZXIgaW5zdGFuY2UuXG4gKiBBZGRlZCBpbiBOb2RlIDAuMTIuIE9ubHkgYXZhaWxhYmxlIGluIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBBcnJheUJ1ZmZlci5cbiAqL1xuQnVmZmVyLnByb3RvdHlwZS50b0FycmF5QnVmZmVyID0gZnVuY3Rpb24gKCkge1xuICBpZiAodHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKFRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAgIHJldHVybiAobmV3IEJ1ZmZlcih0aGlzKSkuYnVmZmVyXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBidWYgPSBuZXcgVWludDhBcnJheSh0aGlzLmxlbmd0aClcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBidWYubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgYnVmW2ldID0gdGhpc1tpXVxuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1Zi5idWZmZXJcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdCdWZmZXIudG9BcnJheUJ1ZmZlciBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3NlcicpXG4gIH1cbn1cblxuLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG52YXIgQlAgPSBCdWZmZXIucHJvdG90eXBlXG5cbi8qKlxuICogQXVnbWVudCBhIFVpbnQ4QXJyYXkgKmluc3RhbmNlKiAobm90IHRoZSBVaW50OEFycmF5IGNsYXNzISkgd2l0aCBCdWZmZXIgbWV0aG9kc1xuICovXG5CdWZmZXIuX2F1Z21lbnQgPSBmdW5jdGlvbiAoYXJyKSB7XG4gIGFyci5faXNCdWZmZXIgPSB0cnVlXG5cbiAgLy8gc2F2ZSByZWZlcmVuY2UgdG8gb3JpZ2luYWwgVWludDhBcnJheSBnZXQvc2V0IG1ldGhvZHMgYmVmb3JlIG92ZXJ3cml0aW5nXG4gIGFyci5fZ2V0ID0gYXJyLmdldFxuICBhcnIuX3NldCA9IGFyci5zZXRcblxuICAvLyBkZXByZWNhdGVkLCB3aWxsIGJlIHJlbW92ZWQgaW4gbm9kZSAwLjEzK1xuICBhcnIuZ2V0ID0gQlAuZ2V0XG4gIGFyci5zZXQgPSBCUC5zZXRcblxuICBhcnIud3JpdGUgPSBCUC53cml0ZVxuICBhcnIudG9TdHJpbmcgPSBCUC50b1N0cmluZ1xuICBhcnIudG9Mb2NhbGVTdHJpbmcgPSBCUC50b1N0cmluZ1xuICBhcnIudG9KU09OID0gQlAudG9KU09OXG4gIGFyci5lcXVhbHMgPSBCUC5lcXVhbHNcbiAgYXJyLmNvbXBhcmUgPSBCUC5jb21wYXJlXG4gIGFyci5jb3B5ID0gQlAuY29weVxuICBhcnIuc2xpY2UgPSBCUC5zbGljZVxuICBhcnIucmVhZFVJbnQ4ID0gQlAucmVhZFVJbnQ4XG4gIGFyci5yZWFkVUludDE2TEUgPSBCUC5yZWFkVUludDE2TEVcbiAgYXJyLnJlYWRVSW50MTZCRSA9IEJQLnJlYWRVSW50MTZCRVxuICBhcnIucmVhZFVJbnQzMkxFID0gQlAucmVhZFVJbnQzMkxFXG4gIGFyci5yZWFkVUludDMyQkUgPSBCUC5yZWFkVUludDMyQkVcbiAgYXJyLnJlYWRJbnQ4ID0gQlAucmVhZEludDhcbiAgYXJyLnJlYWRJbnQxNkxFID0gQlAucmVhZEludDE2TEVcbiAgYXJyLnJlYWRJbnQxNkJFID0gQlAucmVhZEludDE2QkVcbiAgYXJyLnJlYWRJbnQzMkxFID0gQlAucmVhZEludDMyTEVcbiAgYXJyLnJlYWRJbnQzMkJFID0gQlAucmVhZEludDMyQkVcbiAgYXJyLnJlYWRGbG9hdExFID0gQlAucmVhZEZsb2F0TEVcbiAgYXJyLnJlYWRGbG9hdEJFID0gQlAucmVhZEZsb2F0QkVcbiAgYXJyLnJlYWREb3VibGVMRSA9IEJQLnJlYWREb3VibGVMRVxuICBhcnIucmVhZERvdWJsZUJFID0gQlAucmVhZERvdWJsZUJFXG4gIGFyci53cml0ZVVJbnQ4ID0gQlAud3JpdGVVSW50OFxuICBhcnIud3JpdGVVSW50MTZMRSA9IEJQLndyaXRlVUludDE2TEVcbiAgYXJyLndyaXRlVUludDE2QkUgPSBCUC53cml0ZVVJbnQxNkJFXG4gIGFyci53cml0ZVVJbnQzMkxFID0gQlAud3JpdGVVSW50MzJMRVxuICBhcnIud3JpdGVVSW50MzJCRSA9IEJQLndyaXRlVUludDMyQkVcbiAgYXJyLndyaXRlSW50OCA9IEJQLndyaXRlSW50OFxuICBhcnIud3JpdGVJbnQxNkxFID0gQlAud3JpdGVJbnQxNkxFXG4gIGFyci53cml0ZUludDE2QkUgPSBCUC53cml0ZUludDE2QkVcbiAgYXJyLndyaXRlSW50MzJMRSA9IEJQLndyaXRlSW50MzJMRVxuICBhcnIud3JpdGVJbnQzMkJFID0gQlAud3JpdGVJbnQzMkJFXG4gIGFyci53cml0ZUZsb2F0TEUgPSBCUC53cml0ZUZsb2F0TEVcbiAgYXJyLndyaXRlRmxvYXRCRSA9IEJQLndyaXRlRmxvYXRCRVxuICBhcnIud3JpdGVEb3VibGVMRSA9IEJQLndyaXRlRG91YmxlTEVcbiAgYXJyLndyaXRlRG91YmxlQkUgPSBCUC53cml0ZURvdWJsZUJFXG4gIGFyci5maWxsID0gQlAuZmlsbFxuICBhcnIuaW5zcGVjdCA9IEJQLmluc3BlY3RcbiAgYXJyLnRvQXJyYXlCdWZmZXIgPSBCUC50b0FycmF5QnVmZmVyXG5cbiAgcmV0dXJuIGFyclxufVxuXG52YXIgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rXFwvMC05QS16XS9nXG5cbmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHN0ciA9IHN0cmluZ3RyaW0oc3RyKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJylcbiAgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgIHN0ciA9IHN0ciArICc9J1xuICB9XG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gc3RyaW5ndHJpbSAoc3RyKSB7XG4gIGlmIChzdHIudHJpbSkgcmV0dXJuIHN0ci50cmltKClcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJylcbn1cblxuZnVuY3Rpb24gaXNBcnJheSAoc3ViamVjdCkge1xuICByZXR1cm4gKEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHN1YmplY3QpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHN1YmplY3QpID09PSAnW29iamVjdCBBcnJheV0nXG4gIH0pKHN1YmplY3QpXG59XG5cbmZ1bmN0aW9uIGlzQXJyYXlpc2ggKHN1YmplY3QpIHtcbiAgcmV0dXJuIGlzQXJyYXkoc3ViamVjdCkgfHwgQnVmZmVyLmlzQnVmZmVyKHN1YmplY3QpIHx8XG4gICAgICBzdWJqZWN0ICYmIHR5cGVvZiBzdWJqZWN0ID09PSAnb2JqZWN0JyAmJlxuICAgICAgdHlwZW9mIHN1YmplY3QubGVuZ3RoID09PSAnbnVtYmVyJ1xufVxuXG5mdW5jdGlvbiB0b0hleCAobikge1xuICBpZiAobiA8IDE2KSByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNilcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGIgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGlmIChiIDw9IDB4N0YpIHtcbiAgICAgIGJ5dGVBcnJheS5wdXNoKGIpXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBzdGFydCA9IGlcbiAgICAgIGlmIChiID49IDB4RDgwMCAmJiBiIDw9IDB4REZGRikgaSsrXG4gICAgICB2YXIgaCA9IGVuY29kZVVSSUNvbXBvbmVudChzdHIuc2xpY2Uoc3RhcnQsIGkrMSkpLnN1YnN0cigxKS5zcGxpdCgnJScpXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGgubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgYnl0ZUFycmF5LnB1c2gocGFyc2VJbnQoaFtqXSwgMTYpKVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGMsIGhpLCBsb1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShzdHIpXG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKVxuICAgICAgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiBkZWNvZGVVdGY4Q2hhciAoc3RyKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChzdHIpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RkZGRCkgLy8gVVRGIDggaW52YWxpZCBjaGFyXG4gIH1cbn1cblxuLypcbiAqIFdlIGhhdmUgdG8gbWFrZSBzdXJlIHRoYXQgdGhlIHZhbHVlIGlzIGEgdmFsaWQgaW50ZWdlci4gVGhpcyBtZWFucyB0aGF0IGl0XG4gKiBpcyBub24tbmVnYXRpdmUuIEl0IGhhcyBubyBmcmFjdGlvbmFsIGNvbXBvbmVudCBhbmQgdGhhdCBpdCBkb2VzIG5vdFxuICogZXhjZWVkIHRoZSBtYXhpbXVtIGFsbG93ZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHZlcmlmdWludCAodmFsdWUsIG1heCkge1xuICBhc3NlcnQodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJywgJ2Nhbm5vdCB3cml0ZSBhIG5vbi1udW1iZXIgYXMgYSBudW1iZXInKVxuICBhc3NlcnQodmFsdWUgPj0gMCwgJ3NwZWNpZmllZCBhIG5lZ2F0aXZlIHZhbHVlIGZvciB3cml0aW5nIGFuIHVuc2lnbmVkIHZhbHVlJylcbiAgYXNzZXJ0KHZhbHVlIDw9IG1heCwgJ3ZhbHVlIGlzIGxhcmdlciB0aGFuIG1heGltdW0gdmFsdWUgZm9yIHR5cGUnKVxuICBhc3NlcnQoTWF0aC5mbG9vcih2YWx1ZSkgPT09IHZhbHVlLCAndmFsdWUgaGFzIGEgZnJhY3Rpb25hbCBjb21wb25lbnQnKVxufVxuXG5mdW5jdGlvbiB2ZXJpZnNpbnQgKHZhbHVlLCBtYXgsIG1pbikge1xuICBhc3NlcnQodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJywgJ2Nhbm5vdCB3cml0ZSBhIG5vbi1udW1iZXIgYXMgYSBudW1iZXInKVxuICBhc3NlcnQodmFsdWUgPD0gbWF4LCAndmFsdWUgbGFyZ2VyIHRoYW4gbWF4aW11bSBhbGxvd2VkIHZhbHVlJylcbiAgYXNzZXJ0KHZhbHVlID49IG1pbiwgJ3ZhbHVlIHNtYWxsZXIgdGhhbiBtaW5pbXVtIGFsbG93ZWQgdmFsdWUnKVxuICBhc3NlcnQoTWF0aC5mbG9vcih2YWx1ZSkgPT09IHZhbHVlLCAndmFsdWUgaGFzIGEgZnJhY3Rpb25hbCBjb21wb25lbnQnKVxufVxuXG5mdW5jdGlvbiB2ZXJpZklFRUU3NTQgKHZhbHVlLCBtYXgsIG1pbikge1xuICBhc3NlcnQodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJywgJ2Nhbm5vdCB3cml0ZSBhIG5vbi1udW1iZXIgYXMgYSBudW1iZXInKVxuICBhc3NlcnQodmFsdWUgPD0gbWF4LCAndmFsdWUgbGFyZ2VyIHRoYW4gbWF4aW11bSBhbGxvd2VkIHZhbHVlJylcbiAgYXNzZXJ0KHZhbHVlID49IG1pbiwgJ3ZhbHVlIHNtYWxsZXIgdGhhbiBtaW5pbXVtIGFsbG93ZWQgdmFsdWUnKVxufVxuXG5mdW5jdGlvbiBhc3NlcnQgKHRlc3QsIG1lc3NhZ2UpIHtcbiAgaWYgKCF0ZXN0KSB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSB8fCAnRmFpbGVkIGFzc2VydGlvbicpXG59XG4iLCJ2YXIgbG9va3VwID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nO1xuXG47KGZ1bmN0aW9uIChleHBvcnRzKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuICB2YXIgQXJyID0gKHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJylcbiAgICA/IFVpbnQ4QXJyYXlcbiAgICA6IEFycmF5XG5cblx0dmFyIFBMVVMgICA9ICcrJy5jaGFyQ29kZUF0KDApXG5cdHZhciBTTEFTSCAgPSAnLycuY2hhckNvZGVBdCgwKVxuXHR2YXIgTlVNQkVSID0gJzAnLmNoYXJDb2RlQXQoMClcblx0dmFyIExPV0VSICA9ICdhJy5jaGFyQ29kZUF0KDApXG5cdHZhciBVUFBFUiAgPSAnQScuY2hhckNvZGVBdCgwKVxuXG5cdGZ1bmN0aW9uIGRlY29kZSAoZWx0KSB7XG5cdFx0dmFyIGNvZGUgPSBlbHQuY2hhckNvZGVBdCgwKVxuXHRcdGlmIChjb2RlID09PSBQTFVTKVxuXHRcdFx0cmV0dXJuIDYyIC8vICcrJ1xuXHRcdGlmIChjb2RlID09PSBTTEFTSClcblx0XHRcdHJldHVybiA2MyAvLyAnLydcblx0XHRpZiAoY29kZSA8IE5VTUJFUilcblx0XHRcdHJldHVybiAtMSAvL25vIG1hdGNoXG5cdFx0aWYgKGNvZGUgPCBOVU1CRVIgKyAxMClcblx0XHRcdHJldHVybiBjb2RlIC0gTlVNQkVSICsgMjYgKyAyNlxuXHRcdGlmIChjb2RlIDwgVVBQRVIgKyAyNilcblx0XHRcdHJldHVybiBjb2RlIC0gVVBQRVJcblx0XHRpZiAoY29kZSA8IExPV0VSICsgMjYpXG5cdFx0XHRyZXR1cm4gY29kZSAtIExPV0VSICsgMjZcblx0fVxuXG5cdGZ1bmN0aW9uIGI2NFRvQnl0ZUFycmF5IChiNjQpIHtcblx0XHR2YXIgaSwgaiwgbCwgdG1wLCBwbGFjZUhvbGRlcnMsIGFyclxuXG5cdFx0aWYgKGI2NC5sZW5ndGggJSA0ID4gMCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0Jylcblx0XHR9XG5cblx0XHQvLyB0aGUgbnVtYmVyIG9mIGVxdWFsIHNpZ25zIChwbGFjZSBob2xkZXJzKVxuXHRcdC8vIGlmIHRoZXJlIGFyZSB0d28gcGxhY2Vob2xkZXJzLCB0aGFuIHRoZSB0d28gY2hhcmFjdGVycyBiZWZvcmUgaXRcblx0XHQvLyByZXByZXNlbnQgb25lIGJ5dGVcblx0XHQvLyBpZiB0aGVyZSBpcyBvbmx5IG9uZSwgdGhlbiB0aGUgdGhyZWUgY2hhcmFjdGVycyBiZWZvcmUgaXQgcmVwcmVzZW50IDIgYnl0ZXNcblx0XHQvLyB0aGlzIGlzIGp1c3QgYSBjaGVhcCBoYWNrIHRvIG5vdCBkbyBpbmRleE9mIHR3aWNlXG5cdFx0dmFyIGxlbiA9IGI2NC5sZW5ndGhcblx0XHRwbGFjZUhvbGRlcnMgPSAnPScgPT09IGI2NC5jaGFyQXQobGVuIC0gMikgPyAyIDogJz0nID09PSBiNjQuY2hhckF0KGxlbiAtIDEpID8gMSA6IDBcblxuXHRcdC8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuXHRcdGFyciA9IG5ldyBBcnIoYjY0Lmxlbmd0aCAqIDMgLyA0IC0gcGxhY2VIb2xkZXJzKVxuXG5cdFx0Ly8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuXHRcdGwgPSBwbGFjZUhvbGRlcnMgPiAwID8gYjY0Lmxlbmd0aCAtIDQgOiBiNjQubGVuZ3RoXG5cblx0XHR2YXIgTCA9IDBcblxuXHRcdGZ1bmN0aW9uIHB1c2ggKHYpIHtcblx0XHRcdGFycltMKytdID0gdlxuXHRcdH1cblxuXHRcdGZvciAoaSA9IDAsIGogPSAwOyBpIDwgbDsgaSArPSA0LCBqICs9IDMpIHtcblx0XHRcdHRtcCA9IChkZWNvZGUoYjY0LmNoYXJBdChpKSkgPDwgMTgpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAxKSkgPDwgMTIpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAyKSkgPDwgNikgfCBkZWNvZGUoYjY0LmNoYXJBdChpICsgMykpXG5cdFx0XHRwdXNoKCh0bXAgJiAweEZGMDAwMCkgPj4gMTYpXG5cdFx0XHRwdXNoKCh0bXAgJiAweEZGMDApID4+IDgpXG5cdFx0XHRwdXNoKHRtcCAmIDB4RkYpXG5cdFx0fVxuXG5cdFx0aWYgKHBsYWNlSG9sZGVycyA9PT0gMikge1xuXHRcdFx0dG1wID0gKGRlY29kZShiNjQuY2hhckF0KGkpKSA8PCAyKSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMSkpID4+IDQpXG5cdFx0XHRwdXNoKHRtcCAmIDB4RkYpXG5cdFx0fSBlbHNlIGlmIChwbGFjZUhvbGRlcnMgPT09IDEpIHtcblx0XHRcdHRtcCA9IChkZWNvZGUoYjY0LmNoYXJBdChpKSkgPDwgMTApIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAxKSkgPDwgNCkgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDIpKSA+PiAyKVxuXHRcdFx0cHVzaCgodG1wID4+IDgpICYgMHhGRilcblx0XHRcdHB1c2godG1wICYgMHhGRilcblx0XHR9XG5cblx0XHRyZXR1cm4gYXJyXG5cdH1cblxuXHRmdW5jdGlvbiB1aW50OFRvQmFzZTY0ICh1aW50OCkge1xuXHRcdHZhciBpLFxuXHRcdFx0ZXh0cmFCeXRlcyA9IHVpbnQ4Lmxlbmd0aCAlIDMsIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG5cdFx0XHRvdXRwdXQgPSBcIlwiLFxuXHRcdFx0dGVtcCwgbGVuZ3RoXG5cblx0XHRmdW5jdGlvbiBlbmNvZGUgKG51bSkge1xuXHRcdFx0cmV0dXJuIGxvb2t1cC5jaGFyQXQobnVtKVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG5cdFx0XHRyZXR1cm4gZW5jb2RlKG51bSA+PiAxOCAmIDB4M0YpICsgZW5jb2RlKG51bSA+PiAxMiAmIDB4M0YpICsgZW5jb2RlKG51bSA+PiA2ICYgMHgzRikgKyBlbmNvZGUobnVtICYgMHgzRilcblx0XHR9XG5cblx0XHQvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG5cdFx0Zm9yIChpID0gMCwgbGVuZ3RoID0gdWludDgubGVuZ3RoIC0gZXh0cmFCeXRlczsgaSA8IGxlbmd0aDsgaSArPSAzKSB7XG5cdFx0XHR0ZW1wID0gKHVpbnQ4W2ldIDw8IDE2KSArICh1aW50OFtpICsgMV0gPDwgOCkgKyAodWludDhbaSArIDJdKVxuXHRcdFx0b3V0cHV0ICs9IHRyaXBsZXRUb0Jhc2U2NCh0ZW1wKVxuXHRcdH1cblxuXHRcdC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcblx0XHRzd2l0Y2ggKGV4dHJhQnl0ZXMpIHtcblx0XHRcdGNhc2UgMTpcblx0XHRcdFx0dGVtcCA9IHVpbnQ4W3VpbnQ4Lmxlbmd0aCAtIDFdXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUodGVtcCA+PiAyKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKCh0ZW1wIDw8IDQpICYgMHgzRilcblx0XHRcdFx0b3V0cHV0ICs9ICc9PSdcblx0XHRcdFx0YnJlYWtcblx0XHRcdGNhc2UgMjpcblx0XHRcdFx0dGVtcCA9ICh1aW50OFt1aW50OC5sZW5ndGggLSAyXSA8PCA4KSArICh1aW50OFt1aW50OC5sZW5ndGggLSAxXSlcblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSh0ZW1wID4+IDEwKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKCh0ZW1wID4+IDQpICYgMHgzRilcblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSgodGVtcCA8PCAyKSAmIDB4M0YpXG5cdFx0XHRcdG91dHB1dCArPSAnPSdcblx0XHRcdFx0YnJlYWtcblx0XHR9XG5cblx0XHRyZXR1cm4gb3V0cHV0XG5cdH1cblxuXHRleHBvcnRzLnRvQnl0ZUFycmF5ID0gYjY0VG9CeXRlQXJyYXlcblx0ZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gdWludDhUb0Jhc2U2NFxufSh0eXBlb2YgZXhwb3J0cyA9PT0gJ3VuZGVmaW5lZCcgPyAodGhpcy5iYXNlNjRqcyA9IHt9KSA6IGV4cG9ydHMpKVxuIiwiZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24oYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSxcbiAgICAgIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDEsXG4gICAgICBlTWF4ID0gKDEgPDwgZUxlbikgLSAxLFxuICAgICAgZUJpYXMgPSBlTWF4ID4+IDEsXG4gICAgICBuQml0cyA9IC03LFxuICAgICAgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwLFxuICAgICAgZCA9IGlzTEUgPyAtMSA6IDEsXG4gICAgICBzID0gYnVmZmVyW29mZnNldCArIGldO1xuXG4gIGkgKz0gZDtcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKTtcbiAgcyA+Pj0gKC1uQml0cyk7XG4gIG5CaXRzICs9IGVMZW47XG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSBlICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpO1xuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpO1xuICBlID4+PSAoLW5CaXRzKTtcbiAgbkJpdHMgKz0gbUxlbjtcbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IG0gKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCk7XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzO1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSk7XG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKTtcbiAgICBlID0gZSAtIGVCaWFzO1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pO1xufTtcblxuZXhwb3J0cy53cml0ZSA9IGZ1bmN0aW9uKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjLFxuICAgICAgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMSxcbiAgICAgIGVNYXggPSAoMSA8PCBlTGVuKSAtIDEsXG4gICAgICBlQmlhcyA9IGVNYXggPj4gMSxcbiAgICAgIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKSxcbiAgICAgIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKSxcbiAgICAgIGQgPSBpc0xFID8gMSA6IC0xLFxuICAgICAgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMDtcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKTtcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMDtcbiAgICBlID0gZU1heDtcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMik7XG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tO1xuICAgICAgYyAqPSAyO1xuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gYztcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrKztcbiAgICAgIGMgLz0gMjtcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwO1xuICAgICAgZSA9IGVNYXg7XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICh2YWx1ZSAqIGMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pO1xuICAgICAgZSA9IGUgKyBlQmlhcztcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pO1xuICAgICAgZSA9IDA7XG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCk7XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbTtcbiAgZUxlbiArPSBtTGVuO1xuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpO1xuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyODtcbn07XG4iLCIoZnVuY3Rpb24gKHByb2Nlc3Mpe1xuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIHJlc29sdmVzIC4gYW5kIC4uIGVsZW1lbnRzIGluIGEgcGF0aCBhcnJheSB3aXRoIGRpcmVjdG9yeSBuYW1lcyB0aGVyZVxuLy8gbXVzdCBiZSBubyBzbGFzaGVzLCBlbXB0eSBlbGVtZW50cywgb3IgZGV2aWNlIG5hbWVzIChjOlxcKSBpbiB0aGUgYXJyYXlcbi8vIChzbyBhbHNvIG5vIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHNsYXNoZXMgLSBpdCBkb2VzIG5vdCBkaXN0aW5ndWlzaFxuLy8gcmVsYXRpdmUgYW5kIGFic29sdXRlIHBhdGhzKVxuZnVuY3Rpb24gbm9ybWFsaXplQXJyYXkocGFydHMsIGFsbG93QWJvdmVSb290KSB7XG4gIC8vIGlmIHRoZSBwYXRoIHRyaWVzIHRvIGdvIGFib3ZlIHRoZSByb290LCBgdXBgIGVuZHMgdXAgPiAwXG4gIHZhciB1cCA9IDA7XG4gIGZvciAodmFyIGkgPSBwYXJ0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHZhciBsYXN0ID0gcGFydHNbaV07XG4gICAgaWYgKGxhc3QgPT09ICcuJykge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgIH0gZWxzZSBpZiAobGFzdCA9PT0gJy4uJykge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgICB1cC0tO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBwYXRoIGlzIGFsbG93ZWQgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIHJlc3RvcmUgbGVhZGluZyAuLnNcbiAgaWYgKGFsbG93QWJvdmVSb290KSB7XG4gICAgZm9yICg7IHVwLS07IHVwKSB7XG4gICAgICBwYXJ0cy51bnNoaWZ0KCcuLicpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYXJ0cztcbn1cblxuLy8gU3BsaXQgYSBmaWxlbmFtZSBpbnRvIFtyb290LCBkaXIsIGJhc2VuYW1lLCBleHRdLCB1bml4IHZlcnNpb25cbi8vICdyb290JyBpcyBqdXN0IGEgc2xhc2gsIG9yIG5vdGhpbmcuXG52YXIgc3BsaXRQYXRoUmUgPVxuICAgIC9eKFxcLz98KShbXFxzXFxTXSo/KSgoPzpcXC57MSwyfXxbXlxcL10rP3wpKFxcLlteLlxcL10qfCkpKD86W1xcL10qKSQvO1xudmFyIHNwbGl0UGF0aCA9IGZ1bmN0aW9uKGZpbGVuYW1lKSB7XG4gIHJldHVybiBzcGxpdFBhdGhSZS5leGVjKGZpbGVuYW1lKS5zbGljZSgxKTtcbn07XG5cbi8vIHBhdGgucmVzb2x2ZShbZnJvbSAuLi5dLCB0bylcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMucmVzb2x2ZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcmVzb2x2ZWRQYXRoID0gJycsXG4gICAgICByZXNvbHZlZEFic29sdXRlID0gZmFsc2U7XG5cbiAgZm9yICh2YXIgaSA9IGFyZ3VtZW50cy5sZW5ndGggLSAxOyBpID49IC0xICYmICFyZXNvbHZlZEFic29sdXRlOyBpLS0pIHtcbiAgICB2YXIgcGF0aCA9IChpID49IDApID8gYXJndW1lbnRzW2ldIDogcHJvY2Vzcy5jd2QoKTtcblxuICAgIC8vIFNraXAgZW1wdHkgYW5kIGludmFsaWQgZW50cmllc1xuICAgIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyB0byBwYXRoLnJlc29sdmUgbXVzdCBiZSBzdHJpbmdzJyk7XG4gICAgfSBlbHNlIGlmICghcGF0aCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgcmVzb2x2ZWRQYXRoID0gcGF0aCArICcvJyArIHJlc29sdmVkUGF0aDtcbiAgICByZXNvbHZlZEFic29sdXRlID0gcGF0aC5jaGFyQXQoMCkgPT09ICcvJztcbiAgfVxuXG4gIC8vIEF0IHRoaXMgcG9pbnQgdGhlIHBhdGggc2hvdWxkIGJlIHJlc29sdmVkIHRvIGEgZnVsbCBhYnNvbHV0ZSBwYXRoLCBidXRcbiAgLy8gaGFuZGxlIHJlbGF0aXZlIHBhdGhzIHRvIGJlIHNhZmUgKG1pZ2h0IGhhcHBlbiB3aGVuIHByb2Nlc3MuY3dkKCkgZmFpbHMpXG5cbiAgLy8gTm9ybWFsaXplIHRoZSBwYXRoXG4gIHJlc29sdmVkUGF0aCA9IG5vcm1hbGl6ZUFycmF5KGZpbHRlcihyZXNvbHZlZFBhdGguc3BsaXQoJy8nKSwgZnVuY3Rpb24ocCkge1xuICAgIHJldHVybiAhIXA7XG4gIH0pLCAhcmVzb2x2ZWRBYnNvbHV0ZSkuam9pbignLycpO1xuXG4gIHJldHVybiAoKHJlc29sdmVkQWJzb2x1dGUgPyAnLycgOiAnJykgKyByZXNvbHZlZFBhdGgpIHx8ICcuJztcbn07XG5cbi8vIHBhdGgubm9ybWFsaXplKHBhdGgpXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgdmFyIGlzQWJzb2x1dGUgPSBleHBvcnRzLmlzQWJzb2x1dGUocGF0aCksXG4gICAgICB0cmFpbGluZ1NsYXNoID0gc3Vic3RyKHBhdGgsIC0xKSA9PT0gJy8nO1xuXG4gIC8vIE5vcm1hbGl6ZSB0aGUgcGF0aFxuICBwYXRoID0gbm9ybWFsaXplQXJyYXkoZmlsdGVyKHBhdGguc3BsaXQoJy8nKSwgZnVuY3Rpb24ocCkge1xuICAgIHJldHVybiAhIXA7XG4gIH0pLCAhaXNBYnNvbHV0ZSkuam9pbignLycpO1xuXG4gIGlmICghcGF0aCAmJiAhaXNBYnNvbHV0ZSkge1xuICAgIHBhdGggPSAnLic7XG4gIH1cbiAgaWYgKHBhdGggJiYgdHJhaWxpbmdTbGFzaCkge1xuICAgIHBhdGggKz0gJy8nO1xuICB9XG5cbiAgcmV0dXJuIChpc0Fic29sdXRlID8gJy8nIDogJycpICsgcGF0aDtcbn07XG5cbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMuaXNBYnNvbHV0ZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGguY2hhckF0KDApID09PSAnLyc7XG59O1xuXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLmpvaW4gPSBmdW5jdGlvbigpIHtcbiAgdmFyIHBhdGhzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcbiAgcmV0dXJuIGV4cG9ydHMubm9ybWFsaXplKGZpbHRlcihwYXRocywgZnVuY3Rpb24ocCwgaW5kZXgpIHtcbiAgICBpZiAodHlwZW9mIHAgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgdG8gcGF0aC5qb2luIG11c3QgYmUgc3RyaW5ncycpO1xuICAgIH1cbiAgICByZXR1cm4gcDtcbiAgfSkuam9pbignLycpKTtcbn07XG5cblxuLy8gcGF0aC5yZWxhdGl2ZShmcm9tLCB0bylcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMucmVsYXRpdmUgPSBmdW5jdGlvbihmcm9tLCB0bykge1xuICBmcm9tID0gZXhwb3J0cy5yZXNvbHZlKGZyb20pLnN1YnN0cigxKTtcbiAgdG8gPSBleHBvcnRzLnJlc29sdmUodG8pLnN1YnN0cigxKTtcblxuICBmdW5jdGlvbiB0cmltKGFycikge1xuICAgIHZhciBzdGFydCA9IDA7XG4gICAgZm9yICg7IHN0YXJ0IDwgYXJyLmxlbmd0aDsgc3RhcnQrKykge1xuICAgICAgaWYgKGFycltzdGFydF0gIT09ICcnKSBicmVhaztcbiAgICB9XG5cbiAgICB2YXIgZW5kID0gYXJyLmxlbmd0aCAtIDE7XG4gICAgZm9yICg7IGVuZCA+PSAwOyBlbmQtLSkge1xuICAgICAgaWYgKGFycltlbmRdICE9PSAnJykgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKHN0YXJ0ID4gZW5kKSByZXR1cm4gW107XG4gICAgcmV0dXJuIGFyci5zbGljZShzdGFydCwgZW5kIC0gc3RhcnQgKyAxKTtcbiAgfVxuXG4gIHZhciBmcm9tUGFydHMgPSB0cmltKGZyb20uc3BsaXQoJy8nKSk7XG4gIHZhciB0b1BhcnRzID0gdHJpbSh0by5zcGxpdCgnLycpKTtcblxuICB2YXIgbGVuZ3RoID0gTWF0aC5taW4oZnJvbVBhcnRzLmxlbmd0aCwgdG9QYXJ0cy5sZW5ndGgpO1xuICB2YXIgc2FtZVBhcnRzTGVuZ3RoID0gbGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGZyb21QYXJ0c1tpXSAhPT0gdG9QYXJ0c1tpXSkge1xuICAgICAgc2FtZVBhcnRzTGVuZ3RoID0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHZhciBvdXRwdXRQYXJ0cyA9IFtdO1xuICBmb3IgKHZhciBpID0gc2FtZVBhcnRzTGVuZ3RoOyBpIDwgZnJvbVBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgb3V0cHV0UGFydHMucHVzaCgnLi4nKTtcbiAgfVxuXG4gIG91dHB1dFBhcnRzID0gb3V0cHV0UGFydHMuY29uY2F0KHRvUGFydHMuc2xpY2Uoc2FtZVBhcnRzTGVuZ3RoKSk7XG5cbiAgcmV0dXJuIG91dHB1dFBhcnRzLmpvaW4oJy8nKTtcbn07XG5cbmV4cG9ydHMuc2VwID0gJy8nO1xuZXhwb3J0cy5kZWxpbWl0ZXIgPSAnOic7XG5cbmV4cG9ydHMuZGlybmFtZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgdmFyIHJlc3VsdCA9IHNwbGl0UGF0aChwYXRoKSxcbiAgICAgIHJvb3QgPSByZXN1bHRbMF0sXG4gICAgICBkaXIgPSByZXN1bHRbMV07XG5cbiAgaWYgKCFyb290ICYmICFkaXIpIHtcbiAgICAvLyBObyBkaXJuYW1lIHdoYXRzb2V2ZXJcbiAgICByZXR1cm4gJy4nO1xuICB9XG5cbiAgaWYgKGRpcikge1xuICAgIC8vIEl0IGhhcyBhIGRpcm5hbWUsIHN0cmlwIHRyYWlsaW5nIHNsYXNoXG4gICAgZGlyID0gZGlyLnN1YnN0cigwLCBkaXIubGVuZ3RoIC0gMSk7XG4gIH1cblxuICByZXR1cm4gcm9vdCArIGRpcjtcbn07XG5cblxuZXhwb3J0cy5iYXNlbmFtZSA9IGZ1bmN0aW9uKHBhdGgsIGV4dCkge1xuICB2YXIgZiA9IHNwbGl0UGF0aChwYXRoKVsyXTtcbiAgLy8gVE9ETzogbWFrZSB0aGlzIGNvbXBhcmlzb24gY2FzZS1pbnNlbnNpdGl2ZSBvbiB3aW5kb3dzP1xuICBpZiAoZXh0ICYmIGYuc3Vic3RyKC0xICogZXh0Lmxlbmd0aCkgPT09IGV4dCkge1xuICAgIGYgPSBmLnN1YnN0cigwLCBmLmxlbmd0aCAtIGV4dC5sZW5ndGgpO1xuICB9XG4gIHJldHVybiBmO1xufTtcblxuXG5leHBvcnRzLmV4dG5hbWUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHJldHVybiBzcGxpdFBhdGgocGF0aClbM107XG59O1xuXG5mdW5jdGlvbiBmaWx0ZXIgKHhzLCBmKSB7XG4gICAgaWYgKHhzLmZpbHRlcikgcmV0dXJuIHhzLmZpbHRlcihmKTtcbiAgICB2YXIgcmVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoZih4c1tpXSwgaSwgeHMpKSByZXMucHVzaCh4c1tpXSk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5cbi8vIFN0cmluZy5wcm90b3R5cGUuc3Vic3RyIC0gbmVnYXRpdmUgaW5kZXggZG9uJ3Qgd29yayBpbiBJRThcbnZhciBzdWJzdHIgPSAnYWInLnN1YnN0cigtMSkgPT09ICdiJ1xuICAgID8gZnVuY3Rpb24gKHN0ciwgc3RhcnQsIGxlbikgeyByZXR1cm4gc3RyLnN1YnN0cihzdGFydCwgbGVuKSB9XG4gICAgOiBmdW5jdGlvbiAoc3RyLCBzdGFydCwgbGVuKSB7XG4gICAgICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gc3RyLmxlbmd0aCArIHN0YXJ0O1xuICAgICAgICByZXR1cm4gc3RyLnN1YnN0cihzdGFydCwgbGVuKTtcbiAgICB9XG47XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiK05zY05tXCIpKSIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxuXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbnByb2Nlc3MubmV4dFRpY2sgPSAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBjYW5TZXRJbW1lZGlhdGUgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgICYmIHdpbmRvdy5zZXRJbW1lZGlhdGU7XG4gICAgdmFyIGNhblBvc3QgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgICYmIHdpbmRvdy5wb3N0TWVzc2FnZSAmJiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lclxuICAgIDtcblxuICAgIGlmIChjYW5TZXRJbW1lZGlhdGUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChmKSB7IHJldHVybiB3aW5kb3cuc2V0SW1tZWRpYXRlKGYpIH07XG4gICAgfVxuXG4gICAgaWYgKGNhblBvc3QpIHtcbiAgICAgICAgdmFyIHF1ZXVlID0gW107XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICB2YXIgc291cmNlID0gZXYuc291cmNlO1xuICAgICAgICAgICAgaWYgKChzb3VyY2UgPT09IHdpbmRvdyB8fCBzb3VyY2UgPT09IG51bGwpICYmIGV2LmRhdGEgPT09ICdwcm9jZXNzLXRpY2snKSB7XG4gICAgICAgICAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgaWYgKHF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZuID0gcXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgZm4oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRydWUpO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBuZXh0VGljayhmbikge1xuICAgICAgICAgICAgcXVldWUucHVzaChmbik7XG4gICAgICAgICAgICB3aW5kb3cucG9zdE1lc3NhZ2UoJ3Byb2Nlc3MtdGljaycsICcqJyk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHRUaWNrKGZuKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZm4sIDApO1xuICAgIH07XG59KSgpO1xuXG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn1cblxuLy8gVE9ETyhzaHR5bG1hbilcbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuIiwiLypcclxuIENvcHlyaWdodCAyMDEzIERhbmllbCBXaXJ0eiA8ZGNvZGVAZGNvZGUuaW8+XHJcblxyXG4gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG5cclxuIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG5cclxuIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBsaWNlbnNlIFByb3RvQnVmLmpzIChjKSAyMDEzIERhbmllbCBXaXJ0eiA8ZGNvZGVAZGNvZGUuaW8+XHJcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjBcclxuICogc2VlOiBodHRwczovL2dpdGh1Yi5jb20vZGNvZGVJTy9Qcm90b0J1Zi5qcyBmb3IgZGV0YWlsc1xyXG4gKi9cclxuKGZ1bmN0aW9uKGdsb2JhbCkge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4gICAgZnVuY3Rpb24gaW5pdChCeXRlQnVmZmVyKSB7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBQcm90b0J1ZiBuYW1lc3BhY2UuXHJcbiAgICAgICAgICogQGV4cG9ydHMgUHJvdG9CdWZcclxuICAgICAgICAgKiBAbmFtZXNwYWNlXHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBQcm90b0J1ZiA9IHt9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBQcm90b0J1Zi5qcyB2ZXJzaW9uLlxyXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICAgICAgICogQGNvbnN0XHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFByb3RvQnVmLlZFUlNJT04gPSBcIjMuMi4xXCI7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFdpcmUgdHlwZXMuXHJcbiAgICAgICAgICogQHR5cGUge09iamVjdC48c3RyaW5nLG51bWJlcj59XHJcbiAgICAgICAgICogQGNvbnN0XHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFByb3RvQnVmLldJUkVfVFlQRVMgPSB7fTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVmFyaW50IHdpcmUgdHlwZS5cclxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBQcm90b0J1Zi5XSVJFX1RZUEVTLlZBUklOVCA9IDA7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEZpeGVkIDY0IGJpdHMgd2lyZSB0eXBlLlxyXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgICAgICogQGNvbnN0XHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFByb3RvQnVmLldJUkVfVFlQRVMuQklUUzY0ID0gMTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTGVuZ3RoIGRlbGltaXRlZCB3aXJlIHR5cGUuXHJcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAgICAgKiBAY29uc3RcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUHJvdG9CdWYuV0lSRV9UWVBFUy5MREVMSU0gPSAyO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTdGFydCBncm91cCB3aXJlIHR5cGUuXHJcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAgICAgKiBAY29uc3RcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUHJvdG9CdWYuV0lSRV9UWVBFUy5TVEFSVEdST1VQID0gMztcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRW5kIGdyb3VwIHdpcmUgdHlwZS5cclxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICAgICAqIEBjb25zdFxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBQcm90b0J1Zi5XSVJFX1RZUEVTLkVOREdST1VQID0gNDtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRml4ZWQgMzIgYml0cyB3aXJlIHR5cGUuXHJcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAgICAgKiBAY29uc3RcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUHJvdG9CdWYuV0lSRV9UWVBFUy5CSVRTMzIgPSA1O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBQYWNrYWJsZSB3aXJlIHR5cGVzLlxyXG4gICAgICAgICAqIEB0eXBlIHshQXJyYXkuPG51bWJlcj59XHJcbiAgICAgICAgICogQGNvbnN0XHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFByb3RvQnVmLlBBQ0tBQkxFX1dJUkVfVFlQRVMgPSBbXHJcbiAgICAgICAgICAgIFByb3RvQnVmLldJUkVfVFlQRVMuVkFSSU5ULFxyXG4gICAgICAgICAgICBQcm90b0J1Zi5XSVJFX1RZUEVTLkJJVFM2NCxcclxuICAgICAgICAgICAgUHJvdG9CdWYuV0lSRV9UWVBFUy5CSVRTMzJcclxuICAgICAgICBdO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUeXBlcy5cclxuICAgICAgICAgKiBAZGljdFxyXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZyx7bmFtZTogc3RyaW5nLCB3aXJlVHlwZTogbnVtYmVyfT59XHJcbiAgICAgICAgICogQGNvbnN0XHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFByb3RvQnVmLlRZUEVTID0ge1xyXG4gICAgICAgICAgICAvLyBBY2NvcmRpbmcgdG8gdGhlIHByb3RvYnVmIHNwZWMuXHJcbiAgICAgICAgICAgIFwiaW50MzJcIjoge1xyXG4gICAgICAgICAgICAgICAgbmFtZTogXCJpbnQzMlwiLFxyXG4gICAgICAgICAgICAgICAgd2lyZVR5cGU6IFByb3RvQnVmLldJUkVfVFlQRVMuVkFSSU5UXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIFwidWludDMyXCI6IHtcclxuICAgICAgICAgICAgICAgIG5hbWU6IFwidWludDMyXCIsXHJcbiAgICAgICAgICAgICAgICB3aXJlVHlwZTogUHJvdG9CdWYuV0lSRV9UWVBFUy5WQVJJTlRcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgXCJzaW50MzJcIjoge1xyXG4gICAgICAgICAgICAgICAgbmFtZTogXCJzaW50MzJcIixcclxuICAgICAgICAgICAgICAgIHdpcmVUeXBlOiBQcm90b0J1Zi5XSVJFX1RZUEVTLlZBUklOVFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBcImludDY0XCI6IHtcclxuICAgICAgICAgICAgICAgIG5hbWU6IFwiaW50NjRcIixcclxuICAgICAgICAgICAgICAgIHdpcmVUeXBlOiBQcm90b0J1Zi5XSVJFX1RZUEVTLlZBUklOVFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBcInVpbnQ2NFwiOiB7XHJcbiAgICAgICAgICAgICAgICBuYW1lOiBcInVpbnQ2NFwiLFxyXG4gICAgICAgICAgICAgICAgd2lyZVR5cGU6IFByb3RvQnVmLldJUkVfVFlQRVMuVkFSSU5UXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIFwic2ludDY0XCI6IHtcclxuICAgICAgICAgICAgICAgIG5hbWU6IFwic2ludDY0XCIsXHJcbiAgICAgICAgICAgICAgICB3aXJlVHlwZTogUHJvdG9CdWYuV0lSRV9UWVBFUy5WQVJJTlRcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgXCJib29sXCI6IHtcclxuICAgICAgICAgICAgICAgIG5hbWU6IFwiYm9vbFwiLFxyXG4gICAgICAgICAgICAgICAgd2lyZVR5cGU6IFByb3RvQnVmLldJUkVfVFlQRVMuVkFSSU5UXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIFwiZG91YmxlXCI6IHtcclxuICAgICAgICAgICAgICAgIG5hbWU6IFwiZG91YmxlXCIsXHJcbiAgICAgICAgICAgICAgICB3aXJlVHlwZTogUHJvdG9CdWYuV0lSRV9UWVBFUy5CSVRTNjRcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgXCJzdHJpbmdcIjoge1xyXG4gICAgICAgICAgICAgICAgbmFtZTogXCJzdHJpbmdcIixcclxuICAgICAgICAgICAgICAgIHdpcmVUeXBlOiBQcm90b0J1Zi5XSVJFX1RZUEVTLkxERUxJTVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBcImJ5dGVzXCI6IHtcclxuICAgICAgICAgICAgICAgIG5hbWU6IFwiYnl0ZXNcIixcclxuICAgICAgICAgICAgICAgIHdpcmVUeXBlOiBQcm90b0J1Zi5XSVJFX1RZUEVTLkxERUxJTVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBcImZpeGVkMzJcIjoge1xyXG4gICAgICAgICAgICAgICAgbmFtZTogXCJmaXhlZDMyXCIsXHJcbiAgICAgICAgICAgICAgICB3aXJlVHlwZTogUHJvdG9CdWYuV0lSRV9UWVBFUy5CSVRTMzJcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgXCJzZml4ZWQzMlwiOiB7XHJcbiAgICAgICAgICAgICAgICBuYW1lOiBcInNmaXhlZDMyXCIsXHJcbiAgICAgICAgICAgICAgICB3aXJlVHlwZTogUHJvdG9CdWYuV0lSRV9UWVBFUy5CSVRTMzJcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgXCJmaXhlZDY0XCI6IHtcclxuICAgICAgICAgICAgICAgIG5hbWU6IFwiZml4ZWQ2NFwiLFxyXG4gICAgICAgICAgICAgICAgd2lyZVR5cGU6IFByb3RvQnVmLldJUkVfVFlQRVMuQklUUzY0XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIFwic2ZpeGVkNjRcIjoge1xyXG4gICAgICAgICAgICAgICAgbmFtZTogXCJzZml4ZWQ2NFwiLFxyXG4gICAgICAgICAgICAgICAgd2lyZVR5cGU6IFByb3RvQnVmLldJUkVfVFlQRVMuQklUUzY0XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIFwiZmxvYXRcIjoge1xyXG4gICAgICAgICAgICAgICAgbmFtZTogXCJmbG9hdFwiLFxyXG4gICAgICAgICAgICAgICAgd2lyZVR5cGU6IFByb3RvQnVmLldJUkVfVFlQRVMuQklUUzMyXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIFwiZW51bVwiOiB7XHJcbiAgICAgICAgICAgICAgICBuYW1lOiBcImVudW1cIixcclxuICAgICAgICAgICAgICAgIHdpcmVUeXBlOiBQcm90b0J1Zi5XSVJFX1RZUEVTLlZBUklOVFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBcIm1lc3NhZ2VcIjoge1xyXG4gICAgICAgICAgICAgICAgbmFtZTogXCJtZXNzYWdlXCIsXHJcbiAgICAgICAgICAgICAgICB3aXJlVHlwZTogUHJvdG9CdWYuV0lSRV9UWVBFUy5MREVMSU1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgXCJncm91cFwiOiB7XHJcbiAgICAgICAgICAgICAgICBuYW1lOiBcImdyb3VwXCIsXHJcbiAgICAgICAgICAgICAgICB3aXJlVHlwZTogUHJvdG9CdWYuV0lSRV9UWVBFUy5TVEFSVEdST1VQXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBNaW5pbXVtIGZpZWxkIGlkLlxyXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgICAgICogQGNvbnN0XHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFByb3RvQnVmLklEX01JTiA9IDE7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIE1heGltdW0gZmllbGQgaWQuXHJcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAgICAgKiBAY29uc3RcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUHJvdG9CdWYuSURfTUFYID0gMHgxRkZGRkZGRjtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHR5cGUgeyFmdW5jdGlvbihuZXc6IEJ5dGVCdWZmZXIsIC4uLlsqXSl9XHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFByb3RvQnVmLkJ5dGVCdWZmZXIgPSBCeXRlQnVmZmVyO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAdHlwZSB7P2Z1bmN0aW9uKG5ldzogTG9uZywgLi4uWypdKX1cclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUHJvdG9CdWYuTG9uZyA9IEJ5dGVCdWZmZXIuTG9uZyB8fCBudWxsO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJZiBzZXQgdG8gYHRydWVgLCBmaWVsZCBuYW1lcyB3aWxsIGJlIGNvbnZlcnRlZCBmcm9tIHVuZGVyc2NvcmUgbm90YXRpb24gdG8gY2FtZWwgY2FzZS4gRGVmYXVsdHMgdG8gYGZhbHNlYC5cclxuICAgICAgICAgKiAgTXVzdCBiZSBzZXQgcHJpb3IgdG8gcGFyc2luZy5cclxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUHJvdG9CdWYuY29udmVydEZpZWxkc1RvQ2FtZWxDYXNlID0gZmFsc2U7XHJcblxyXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAYWxpYXMgUHJvdG9CdWYuVXRpbFxuICAgICAgICAgKiBAZXhwb3NlXG4gICAgICAgICAqL1xuICAgICAgICBQcm90b0J1Zi5VdGlsID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICAgIC8vIE9iamVjdC5jcmVhdGUgcG9seWZpbGxcbiAgICAgICAgICAgIC8vIHJlZjogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZGUvZG9jcy9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvY3JlYXRlXG4gICAgICAgICAgICBpZiAoIU9iamVjdC5jcmVhdGUpXG4gICAgICAgICAgICAgICAgLyoqIEBleHBvc2UgKi9cbiAgICAgICAgICAgICAgICBPYmplY3QuY3JlYXRlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ09iamVjdC5jcmVhdGUgcG9seWZpbGwgb25seSBhY2NlcHRzIHRoZSBmaXJzdCBwYXJhbWV0ZXIuJyk7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIEYoKSB7fVxuICAgICAgICAgICAgICAgICAgICBGLnByb3RvdHlwZSA9IG87XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRigpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUHJvdG9CdWYgdXRpbGl0aWVzLlxuICAgICAgICAgICAgICogQGV4cG9ydHMgUHJvdG9CdWYuVXRpbFxuICAgICAgICAgICAgICogQG5hbWVzcGFjZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2YXIgVXRpbCA9IHt9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEZsYWcgaWYgcnVubmluZyBpbiBub2RlIChmcyBpcyBhdmFpbGFibGUpIG9yIG5vdC5cbiAgICAgICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgICAgICogQGNvbnN0XG4gICAgICAgICAgICAgKiBAZXhwb3NlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFV0aWwuSVNfTk9ERSA9IGZhbHNlO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAvLyBUaGVyZSBpcyBubyByZWxpYWJsZSB3YXkgdG8gZGV0ZWN0IG5vZGUuanMgYXMgYW4gZW52aXJvbm1lbnQsIHNvIG91clxuICAgICAgICAgICAgICAgIC8vIGJlc3QgYmV0IGlzIHRvIGZlYXR1cmUtZGV0ZWN0IHdoYXQgd2UgYWN0dWFsbHkgbmVlZC5cbiAgICAgICAgICAgICAgICBVdGlsLklTX05PREUgPVxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgcmVxdWlyZShcImZzXCIpLnJlYWRGaWxlU3luYyA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgcmVxdWlyZShcInBhdGhcIikucmVzb2x2ZSA9PT0gJ2Z1bmN0aW9uJztcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ29uc3RydWN0cyBhIFhNTEh0dHBSZXF1ZXN0IG9iamVjdC5cbiAgICAgICAgICAgICAqIEByZXR1cm4ge1hNTEh0dHBSZXF1ZXN0fVxuICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIFhNTEh0dHBSZXF1ZXN0IGlzIG5vdCBzdXBwb3J0ZWRcbiAgICAgICAgICAgICAqIEBleHBvc2VcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgVXRpbC5YSFIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAvLyBObyBkZXBlbmRlbmNpZXMgcGxlYXNlLCByZWY6IGh0dHA6Ly93d3cucXVpcmtzbW9kZS5vcmcvanMveG1saHR0cC5odG1sXG4gICAgICAgICAgICAgICAgdmFyIFhNTEh0dHBGYWN0b3JpZXMgPSBbXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtyZXR1cm4gbmV3IFhNTEh0dHBSZXF1ZXN0KCl9LFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7cmV0dXJuIG5ldyBBY3RpdmVYT2JqZWN0KFwiTXN4bWwyLlhNTEhUVFBcIil9LFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7cmV0dXJuIG5ldyBBY3RpdmVYT2JqZWN0KFwiTXN4bWwzLlhNTEhUVFBcIil9LFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7cmV0dXJuIG5ldyBBY3RpdmVYT2JqZWN0KFwiTWljcm9zb2Z0LlhNTEhUVFBcIil9XG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAvKiogQHR5cGUgez9YTUxIdHRwUmVxdWVzdH0gKi9cbiAgICAgICAgICAgICAgICB2YXIgeGhyID0gbnVsbDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpPTA7aTxYTUxIdHRwRmFjdG9yaWVzLmxlbmd0aDtpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHsgeGhyID0gWE1MSHR0cEZhY3Rvcmllc1tpXSgpOyB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXhocilcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJYTUxIdHRwUmVxdWVzdCBpcyBub3Qgc3VwcG9ydGVkXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiB4aHI7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEZldGNoZXMgYSByZXNvdXJjZS5cbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFJlc291cmNlIHBhdGhcbiAgICAgICAgICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oP3N0cmluZyk9fSBjYWxsYmFjayBDYWxsYmFjayByZWNlaXZpbmcgdGhlIHJlc291cmNlJ3MgY29udGVudHMuIElmIG9taXR0ZWQgdGhlIHJlc291cmNlIHdpbGxcbiAgICAgICAgICAgICAqICAgYmUgZmV0Y2hlZCBzeW5jaHJvbm91c2x5LiBJZiB0aGUgcmVxdWVzdCBmYWlsZWQsIGNvbnRlbnRzIHdpbGwgYmUgbnVsbC5cbiAgICAgICAgICAgICAqIEByZXR1cm4gez9zdHJpbmd8dW5kZWZpbmVkfSBSZXNvdXJjZSBjb250ZW50cyBpZiBjYWxsYmFjayBpcyBvbWl0dGVkIChudWxsIGlmIHRoZSByZXF1ZXN0IGZhaWxlZCksIGVsc2UgdW5kZWZpbmVkLlxuICAgICAgICAgICAgICogQGV4cG9zZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBVdGlsLmZldGNoID0gZnVuY3Rpb24ocGF0aCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2sgJiYgdHlwZW9mIGNhbGxiYWNrICE9ICdmdW5jdGlvbicpXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoVXRpbC5JU19OT0RFKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZShcImZzXCIpLnJlYWRGaWxlKHBhdGgsIGZ1bmN0aW9uKGVyciwgZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soXCJcIitkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcXVpcmUoXCJmc1wiKS5yZWFkRmlsZVN5bmMocGF0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHhociA9IFV0aWwuWEhSKCk7XG4gICAgICAgICAgICAgICAgICAgIHhoci5vcGVuKCdHRVQnLCBwYXRoLCBjYWxsYmFjayA/IHRydWUgOiBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdVc2VyLUFnZW50JywgJ1hNTEhUVFAvMS4wJyk7XG4gICAgICAgICAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdBY2NlcHQnLCAndGV4dC9wbGFpbicpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHhoci5vdmVycmlkZU1pbWVUeXBlID09PSAnZnVuY3Rpb24nKSB4aHIub3ZlcnJpZGVNaW1lVHlwZSgndGV4dC9wbGFpbicpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgIT0gNCkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgvKiByZW1vdGUgKi8geGhyLnN0YXR1cyA9PSAyMDAgfHwgLyogbG9jYWwgKi8gKHhoci5zdGF0dXMgPT0gMCAmJiB0eXBlb2YgeGhyLnJlc3BvbnNlVGV4dCA9PT0gJ3N0cmluZycpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayh4aHIucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSA9PSA0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHhoci5zZW5kKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgeGhyLnNlbmQobnVsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoLyogcmVtb3RlICovIHhoci5zdGF0dXMgPT0gMjAwIHx8IC8qIGxvY2FsICovICh4aHIuc3RhdHVzID09IDAgJiYgdHlwZW9mIHhoci5yZXNwb25zZVRleHQgPT09ICdzdHJpbmcnKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geGhyLnJlc3BvbnNlVGV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUZXN0cyBpZiBhbiBvYmplY3QgaXMgYW4gYXJyYXkuXG4gICAgICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICAgICAqIEBwYXJhbSB7Kn0gb2JqIE9iamVjdCB0byB0ZXN0XG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiBpdCBpcyBhbiBhcnJheSwgZWxzZSBmYWxzZVxuICAgICAgICAgICAgICogQGV4cG9zZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBVdGlsLmlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gXCJbb2JqZWN0IEFycmF5XVwiO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmV0dXJuIFV0aWw7XG4gICAgICAgIH0pKCk7XG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBMYW5ndWFnZSBleHByZXNzaW9ucy5cclxuICAgICAgICAgKiBAZXhwb3J0cyBQcm90b0J1Zi5MYW5nXHJcbiAgICAgICAgICogQHR5cGUge09iamVjdC48c3RyaW5nLHN0cmluZ3xSZWdFeHA+fVxyXG4gICAgICAgICAqIEBuYW1lc3BhY2VcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUHJvdG9CdWYuTGFuZyA9IHtcclxuICAgICAgICAgICAgT1BFTjogXCJ7XCIsXHJcbiAgICAgICAgICAgIENMT1NFOiBcIn1cIixcclxuICAgICAgICAgICAgT1BUT1BFTjogXCJbXCIsXHJcbiAgICAgICAgICAgIE9QVENMT1NFOiBcIl1cIixcclxuICAgICAgICAgICAgT1BURU5EOiBcIixcIixcclxuICAgICAgICAgICAgRVFVQUw6IFwiPVwiLFxyXG4gICAgICAgICAgICBFTkQ6IFwiO1wiLFxyXG4gICAgICAgICAgICBTVFJJTkdPUEVOOiAnXCInLFxyXG4gICAgICAgICAgICBTVFJJTkdDTE9TRTogJ1wiJyxcclxuICAgICAgICAgICAgU1RSSU5HT1BFTl9TUTogXCInXCIsXHJcbiAgICAgICAgICAgIFNUUklOR0NMT1NFX1NROiBcIidcIixcclxuICAgICAgICAgICAgQ09QVE9QRU46ICcoJyxcclxuICAgICAgICAgICAgQ09QVENMT1NFOiAnKScsXHJcbiAgICAgICAgICAgIERFTElNOiAvW1xcc1xce1xcfT07XFxbXFxdLCdcIlxcKFxcKV0vZyxcclxuICAgICAgICAgICAgLy8gS0VZV09SRDogL14oPzpwYWNrYWdlfG9wdGlvbnxpbXBvcnR8bWVzc2FnZXxlbnVtfGV4dGVuZHxzZXJ2aWNlfHN5bnRheHxleHRlbnNpb25zfGdyb3VwKSQvLFxyXG4gICAgICAgICAgICBSVUxFOiAvXig/OnJlcXVpcmVkfG9wdGlvbmFsfHJlcGVhdGVkKSQvLFxyXG4gICAgICAgICAgICBUWVBFOiAvXig/OmRvdWJsZXxmbG9hdHxpbnQzMnx1aW50MzJ8c2ludDMyfGludDY0fHVpbnQ2NHxzaW50NjR8Zml4ZWQzMnxzZml4ZWQzMnxmaXhlZDY0fHNmaXhlZDY0fGJvb2x8c3RyaW5nfGJ5dGVzKSQvLFxyXG4gICAgICAgICAgICBOQU1FOiAvXlthLXpBLVpfXVthLXpBLVpfMC05XSokLyxcclxuICAgICAgICAgICAgVFlQRURFRjogL15bYS16QS1aXVthLXpBLVpfMC05XSokLyxcclxuICAgICAgICAgICAgVFlQRVJFRjogL14oPzpcXC4/W2EtekEtWl9dW2EtekEtWl8wLTldKikrJC8sXHJcbiAgICAgICAgICAgIEZRVFlQRVJFRjogL14oPzpcXC5bYS16QS1aXVthLXpBLVpfMC05XSopKyQvLFxyXG4gICAgICAgICAgICBOVU1CRVI6IC9eLT8oPzpbMS05XVswLTldKnwwfDB4WzAtOWEtZkEtRl0rfDBbMC03XSt8KFswLTldKlxcLlswLTldKyhbRWVdWystXT9bMC05XSspPykpJC8sXHJcbiAgICAgICAgICAgIE5VTUJFUl9ERUM6IC9eKD86WzEtOV1bMC05XSp8MCkkLyxcclxuICAgICAgICAgICAgTlVNQkVSX0hFWDogL14weFswLTlhLWZBLUZdKyQvLFxyXG4gICAgICAgICAgICBOVU1CRVJfT0NUOiAvXjBbMC03XSskLyxcclxuICAgICAgICAgICAgTlVNQkVSX0ZMVDogL15bMC05XSpcXC5bMC05XSsoW0VlXVsrLV0/WzAtOV0rKT8kLyxcclxuICAgICAgICAgICAgSUQ6IC9eKD86WzEtOV1bMC05XSp8MHwweFswLTlhLWZBLUZdK3wwWzAtN10rKSQvLFxyXG4gICAgICAgICAgICBORUdJRDogL15cXC0/KD86WzEtOV1bMC05XSp8MHwweFswLTlhLWZBLUZdK3wwWzAtN10rKSQvLFxyXG4gICAgICAgICAgICBXSElURVNQQUNFOiAvXFxzLyxcclxuICAgICAgICAgICAgU1RSSU5HOiAvWydcIl0oW14nXCJcXFxcXSooXFxcXC5bXlwiXFxcXF0qKSopWydcIl0vZyxcclxuICAgICAgICAgICAgQk9PTDogL14oPzp0cnVlfGZhbHNlKSQvaVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBhbGlhcyBQcm90b0J1Zi5Eb3RQcm90b1xyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBQcm90b0J1Zi5Eb3RQcm90byA9IChmdW5jdGlvbihQcm90b0J1ZiwgTGFuZykge1xyXG4gICAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBVdGlsaXRpZXMgdG8gcGFyc2UgLnByb3RvIGZpbGVzLlxyXG4gICAgICAgICAgICAgKiBAZXhwb3J0cyBQcm90b0J1Zi5Eb3RQcm90b1xyXG4gICAgICAgICAgICAgKiBAbmFtZXNwYWNlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB2YXIgRG90UHJvdG8gPSB7fTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IFRva2VuaXplci5cclxuICAgICAgICAgICAgICogQGV4cG9ydHMgUHJvdG9CdWYuRG90UHJvdG8uVG9rZW5pemVyXHJcbiAgICAgICAgICAgICAqIEBjbGFzcyBwcm90byB0b2tlbml6ZXJcclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3RvIFByb3RvIHRvIHRva2VuaXplXHJcbiAgICAgICAgICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdmFyIFRva2VuaXplciA9IGZ1bmN0aW9uKHByb3RvKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBTb3VyY2UgdG8gcGFyc2UuXHJcbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAgICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLnNvdXJjZSA9IFwiXCIrcHJvdG87IC8vIEluIGNhc2UgaXQncyBhIGJ1ZmZlclxyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQ3VycmVudCBpbmRleC5cclxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXggPSAwO1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQ3VycmVudCBsaW5lLlxyXG4gICAgICAgICAgICAgICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5saW5lID0gMTtcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFN0YWNrZWQgdmFsdWVzLlxyXG4gICAgICAgICAgICAgICAgICogQHR5cGUge0FycmF5fVxyXG4gICAgICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YWNrID0gW107XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBXaGV0aGVyIGN1cnJlbnRseSByZWFkaW5nIGEgc3RyaW5nIG9yIG5vdC5cclxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlYWRpbmdTdHJpbmcgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFdoYXRldmVyIGNoYXJhY3RlciBlbmRzIHRoZSBzdHJpbmcuIEVpdGhlciBhIHNpbmdsZSBvciBkb3VibGUgcXVvdGUgY2hhcmFjdGVyLlxyXG4gICAgICAgICAgICAgICAgICogQHR5cGUge3N0cmluZ31cclxuICAgICAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdHJpbmdFbmRzV2l0aCA9IExhbmcuU1RSSU5HQ0xPU0U7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUmVhZHMgYSBzdHJpbmcgYmVnaW5uaW5nIGF0IHRoZSBjdXJyZW50IGluZGV4LlxyXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBzdHJpbmdcclxuICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIGl0J3Mgbm90IGEgdmFsaWQgc3RyaW5nXHJcbiAgICAgICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBUb2tlbml6ZXIucHJvdG90eXBlLl9yZWFkU3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICBMYW5nLlNUUklORy5sYXN0SW5kZXggPSB0aGlzLmluZGV4LTE7IC8vIEluY2x1ZGUgdGhlIG9wZW4gcXVvdGVcclxuICAgICAgICAgICAgICAgIHZhciBtYXRjaDtcclxuICAgICAgICAgICAgICAgIGlmICgobWF0Y2ggPSBMYW5nLlNUUklORy5leGVjKHRoaXMuc291cmNlKSkgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcyA9IG1hdGNoWzFdO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZXggPSBMYW5nLlNUUklORy5sYXN0SW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKHRoaXMuc3RyaW5nRW5kc1dpdGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIHN0cmluZyB2YWx1ZSBhdCBsaW5lIFwiK3RoaXMubGluZStcIiwgaW5kZXggXCIrdGhpcy5pbmRleCk7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR2V0cyB0aGUgbmV4dCB0b2tlbiBhbmQgYWR2YW5jZXMgYnkgb25lLlxyXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/c3RyaW5nfSBUb2tlbiBvciBgbnVsbGAgb24gRU9GXHJcbiAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiBpdCdzIG5vdCBhIHZhbGlkIHByb3RvIGZpbGVcclxuICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgVG9rZW5pemVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGFjay5sZW5ndGggPiAwKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YWNrLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pbmRleCA+PSB0aGlzLnNvdXJjZS5sZW5ndGgpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7IC8vIE5vIG1vcmUgdG9rZW5zXHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZWFkaW5nU3RyaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkaW5nU3RyaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWRTdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciByZXBlYXQsIGxhc3Q7XHJcbiAgICAgICAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVwZWF0ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gU3RyaXAgd2hpdGUgc3BhY2VzXHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKExhbmcuV0hJVEVTUEFDRS50ZXN0KGxhc3QgPSB0aGlzLnNvdXJjZS5jaGFyQXQodGhpcy5pbmRleCkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZXgrKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3QgPT09IFwiXFxuXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxpbmUrKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaW5kZXggPT09IHRoaXMuc291cmNlLmxlbmd0aClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyBTdHJpcCBjb21tZW50c1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNvdXJjZS5jaGFyQXQodGhpcy5pbmRleCkgPT09ICcvJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zb3VyY2UuY2hhckF0KCsrdGhpcy5pbmRleCkgPT09ICcvJykgeyAvLyBTaW5nbGUgbGluZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHRoaXMuc291cmNlLmNoYXJBdCh0aGlzLmluZGV4KSAhPT0gXCJcXG5cIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZXgrKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pbmRleCA9PSB0aGlzLnNvdXJjZS5sZW5ndGgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRleCsrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5saW5lKys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXBlYXQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc291cmNlLmNoYXJBdCh0aGlzLmluZGV4KSA9PT0gJyonKSB7IC8qIEJsb2NrICovXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0ID0gJyc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAobGFzdCsobGFzdD10aGlzLnNvdXJjZS5jaGFyQXQodGhpcy5pbmRleCkpICE9PSAnKi8nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRleCsrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsYXN0ID09PSBcIlxcblwiKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxpbmUrKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pbmRleCA9PT0gdGhpcy5zb3VyY2UubGVuZ3RoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZXgrKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcGVhdCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbnZhbGlkIGNvbW1lbnQgYXQgbGluZSBcIit0aGlzLmxpbmUrXCI6IC9cIit0aGlzLnNvdXJjZS5jaGFyQXQodGhpcy5pbmRleCkrXCIgKCcvJyBvciAnKicgZXhwZWN0ZWQpXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gd2hpbGUgKHJlcGVhdCk7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pbmRleCA9PT0gdGhpcy5zb3VyY2UubGVuZ3RoKSByZXR1cm4gbnVsbDtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBSZWFkIHRoZSBuZXh0IHRva2VuXHJcbiAgICAgICAgICAgICAgICB2YXIgZW5kID0gdGhpcy5pbmRleDtcclxuICAgICAgICAgICAgICAgIExhbmcuREVMSU0ubGFzdEluZGV4ID0gMDtcclxuICAgICAgICAgICAgICAgIHZhciBkZWxpbSA9IExhbmcuREVMSU0udGVzdCh0aGlzLnNvdXJjZS5jaGFyQXQoZW5kKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWRlbGltKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgKytlbmQ7XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUoZW5kIDwgdGhpcy5zb3VyY2UubGVuZ3RoICYmICFMYW5nLkRFTElNLnRlc3QodGhpcy5zb3VyY2UuY2hhckF0KGVuZCkpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQrKztcclxuICAgICAgICAgICAgICAgIH0gZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICsrZW5kO1xyXG4gICAgICAgICAgICAgICAgdmFyIHRva2VuID0gdGhpcy5zb3VyY2Uuc3Vic3RyaW5nKHRoaXMuaW5kZXgsIHRoaXMuaW5kZXggPSBlbmQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRva2VuID09PSBMYW5nLlNUUklOR09QRU4pXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkaW5nU3RyaW5nID0gdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0cmluZ0VuZHNXaXRoID0gTGFuZy5TVFJJTkdDTE9TRTtcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRva2VuID09PSBMYW5nLlNUUklOR09QRU5fU1EpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkaW5nU3RyaW5nID0gdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0cmluZ0VuZHNXaXRoID0gTGFuZy5TVFJJTkdDTE9TRV9TUTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbjtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBQZWVrcyBmb3IgdGhlIG5leHQgdG9rZW4uXHJcbiAgICAgICAgICAgICAqIEByZXR1cm4gez9zdHJpbmd9IFRva2VuIG9yIGBudWxsYCBvbiBFT0ZcclxuICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIGl0J3Mgbm90IGEgdmFsaWQgcHJvdG8gZmlsZVxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBUb2tlbml6ZXIucHJvdG90eXBlLnBlZWsgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0b2tlbiA9IHRoaXMubmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbiA9PT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKHRva2VuKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YWNrWzBdO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBvYmplY3QuXHJcbiAgICAgICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gU3RyaW5nIHJlcHJlc2VudGF0aW9uIGFzIG9mIFwiVG9rZW5pemVyKGluZGV4L2xlbmd0aClcIlxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBUb2tlbml6ZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJUb2tlbml6ZXIoXCIrdGhpcy5pbmRleCtcIi9cIit0aGlzLnNvdXJjZS5sZW5ndGgrXCIgYXQgbGluZSBcIit0aGlzLmxpbmUrXCIpXCI7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQGFsaWFzIFByb3RvQnVmLkRvdFByb3RvLlRva2VuaXplclxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBEb3RQcm90by5Ub2tlbml6ZXIgPSBUb2tlbml6ZXI7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQ29uc3RydWN0cyBhIG5ldyBQYXJzZXIuXHJcbiAgICAgICAgICAgICAqIEBleHBvcnRzIFByb3RvQnVmLkRvdFByb3RvLlBhcnNlclxyXG4gICAgICAgICAgICAgKiBAY2xhc3MgcHJvdG8gcGFyc2VyXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm90byBQcm90b2NvbCBzb3VyY2VcclxuICAgICAgICAgICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB2YXIgUGFyc2VyID0gZnVuY3Rpb24ocHJvdG8pIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFRva2VuaXplci5cclxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtQcm90b0J1Zi5Eb3RQcm90by5Ub2tlbml6ZXJ9XHJcbiAgICAgICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMudG4gPSBuZXcgVG9rZW5pemVyKHByb3RvKTtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBSdW5zIHRoZSBwYXJzZXIuXHJcbiAgICAgICAgICAgICAqIEByZXR1cm4ge3twYWNrYWdlOiBzdHJpbmd8bnVsbCwgbWVzc2FnZXM6IEFycmF5LjxvYmplY3Q+LCBlbnVtczogQXJyYXkuPG9iamVjdD4sIGltcG9ydHM6IEFycmF5LjxzdHJpbmc+LCBvcHRpb25zOiBvYmplY3Q8c3RyaW5nLCo+fX1cclxuICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBzb3VyY2UgY2Fubm90IGJlIHBhcnNlZFxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdG9wTGV2ZWwgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiW1JPT1RdXCIsIC8vIHRlbXBvcmFyeVxyXG4gICAgICAgICAgICAgICAgICAgIFwicGFja2FnZVwiOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgIFwibWVzc2FnZXNcIjogW10sXHJcbiAgICAgICAgICAgICAgICAgICAgXCJlbnVtc1wiOiBbXSxcclxuICAgICAgICAgICAgICAgICAgICBcImltcG9ydHNcIjogW10sXHJcbiAgICAgICAgICAgICAgICAgICAgXCJvcHRpb25zXCI6IHt9LFxyXG4gICAgICAgICAgICAgICAgICAgIFwic2VydmljZXNcIjogW11cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB2YXIgdG9rZW4sIGhlYWRlciA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSh0b2tlbiA9IHRoaXMudG4ubmV4dCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh0b2tlbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdwYWNrYWdlJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaGVhZGVyIHx8IHRvcExldmVsW1wicGFja2FnZVwiXSAhPT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIklsbGVnYWwgcGFja2FnZSBhdCBsaW5lIFwiK3RoaXMudG4ubGluZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3BMZXZlbFtcInBhY2thZ2VcIl0gPSB0aGlzLl9wYXJzZVBhY2thZ2UodG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2ltcG9ydCc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWhlYWRlcilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIklsbGVnYWwgaW1wb3J0IGF0IGxpbmUgXCIrdGhpcy50bi5saW5lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcExldmVsLmltcG9ydHMucHVzaCh0aGlzLl9wYXJzZUltcG9ydCh0b2tlbikpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ21lc3NhZ2UnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFyc2VNZXNzYWdlKHRvcExldmVsLCBudWxsLCB0b2tlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXIgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdlbnVtJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhcnNlRW51bSh0b3BMZXZlbCwgdG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnb3B0aW9uJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaGVhZGVyKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCBvcHRpb24gYXQgbGluZSBcIit0aGlzLnRuLmxpbmUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFyc2VPcHRpb24odG9wTGV2ZWwsIHRva2VuKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdzZXJ2aWNlJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhcnNlU2VydmljZSh0b3BMZXZlbCwgdG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2V4dGVuZCc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYXJzZUV4dGVuZCh0b3BMZXZlbCwgdG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3N5bnRheCc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYXJzZUlnbm9yZWRTdGF0ZW1lbnQodG9wTGV2ZWwsIHRva2VuKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIHRva2VuIGF0IGxpbmUgXCIrdGhpcy50bi5saW5lK1wiOiBcIit0b2tlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZGVsZXRlIHRvcExldmVsW1wibmFtZVwiXTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0b3BMZXZlbDtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBQYXJzZXMgYSBudW1iZXIgdmFsdWUuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWwgTnVtYmVyIHZhbHVlIHRvIHBhcnNlXHJcbiAgICAgICAgICAgICAqIEByZXR1cm4ge251bWJlcn0gTnVtYmVyXHJcbiAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgbnVtYmVyIHZhbHVlIGlzIGludmFsaWRcclxuICAgICAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFBhcnNlci5wcm90b3R5cGUuX3BhcnNlTnVtYmVyID0gZnVuY3Rpb24odmFsKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2lnbiA9IDE7XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsLmNoYXJBdCgwKSA9PSAnLScpXHJcbiAgICAgICAgICAgICAgICAgICAgc2lnbiA9IC0xLFxyXG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IHZhbC5zdWJzdHJpbmcoMSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoTGFuZy5OVU1CRVJfREVDLnRlc3QodmFsKSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2lnbipwYXJzZUludCh2YWwsIDEwKTtcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKExhbmcuTlVNQkVSX0hFWC50ZXN0KHZhbCkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpZ24qcGFyc2VJbnQodmFsLnN1YnN0cmluZygyKSwgMTYpO1xyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoTGFuZy5OVU1CRVJfT0NULnRlc3QodmFsKSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2lnbipwYXJzZUludCh2YWwuc3Vic3RyaW5nKDEpLCA4KTtcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKExhbmcuTlVNQkVSX0ZMVC50ZXN0KHZhbCkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpZ24qcGFyc2VGbG9hdCh2YWwpO1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIG51bWJlciBhdCBsaW5lIFwiK3RoaXMudG4ubGluZStcIjogXCIrKHNpZ24gPCAwID8gJy0nIDogJycpK3ZhbCk7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUGFyc2VzIGFuIElEIHZhbHVlLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsIElEIHZhbHVlIHRvIHBhcnNlXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IG5lZyBXaGV0aGVyIHRoZSBJRCBtYXkgYmUgbmVnYXRpdmUsIGRlZmF1bHRzIHRvIGBmYWxzZWBcclxuICAgICAgICAgICAgICogQHJldHVybnMge251bWJlcn0gSURcclxuICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBJRCB2YWx1ZSBpcyBpbnZhbGlkXHJcbiAgICAgICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBQYXJzZXIucHJvdG90eXBlLl9wYXJzZUlkID0gZnVuY3Rpb24odmFsLCBuZWcpIHtcclxuICAgICAgICAgICAgICAgIHZhciBpZCA9IC0xO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNpZ24gPSAxO1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhbC5jaGFyQXQoMCkgPT0gJy0nKVxyXG4gICAgICAgICAgICAgICAgICAgIHNpZ24gPSAtMSxcclxuICAgICAgICAgICAgICAgICAgICB2YWwgPSB2YWwuc3Vic3RyaW5nKDEpO1xyXG4gICAgICAgICAgICAgICAgaWYgKExhbmcuTlVNQkVSX0RFQy50ZXN0KHZhbCkpXHJcbiAgICAgICAgICAgICAgICAgICAgaWQgPSBwYXJzZUludCh2YWwpO1xyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoTGFuZy5OVU1CRVJfSEVYLnRlc3QodmFsKSlcclxuICAgICAgICAgICAgICAgICAgICBpZCA9IHBhcnNlSW50KHZhbC5zdWJzdHJpbmcoMiksIDE2KTtcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKExhbmcuTlVNQkVSX09DVC50ZXN0KHZhbCkpXHJcbiAgICAgICAgICAgICAgICAgICAgaWQgPSBwYXJzZUludCh2YWwuc3Vic3RyaW5nKDEpLCA4KTtcclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIklsbGVnYWwgSUQgYXQgbGluZSBcIit0aGlzLnRuLmxpbmUrXCI6IFwiKyhzaWduIDwgMCA/ICctJyA6ICcnKSt2YWwpO1xyXG4gICAgICAgICAgICAgICAgaWQgPSAoc2lnbippZCl8MDsgLy8gRm9yY2UgdG8gMzJiaXRcclxuICAgICAgICAgICAgICAgIGlmICghbmVnICYmIGlkIDwgMClcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIklsbGVnYWwgSUQgYXQgbGluZSBcIit0aGlzLnRuLmxpbmUrXCI6IFwiKyhzaWduIDwgMCA/ICctJyA6ICcnKSt2YWwpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGlkO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFBhcnNlcyB0aGUgcGFja2FnZSBkZWZpbml0aW9uLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdG9rZW4gSW5pdGlhbCB0b2tlblxyXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFBhY2thZ2UgbmFtZVxyXG4gICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBhY2thZ2UgZGVmaW5pdGlvbiBjYW5ub3QgYmUgcGFyc2VkXHJcbiAgICAgICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBQYXJzZXIucHJvdG90eXBlLl9wYXJzZVBhY2thZ2UgPSBmdW5jdGlvbih0b2tlbikge1xyXG4gICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRuLm5leHQoKTtcclxuICAgICAgICAgICAgICAgIGlmICghTGFuZy5UWVBFUkVGLnRlc3QodG9rZW4pKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCBwYWNrYWdlIGF0IGxpbmUgXCIrdGhpcy50bi5saW5lK1wiOiBcIit0b2tlbik7XHJcbiAgICAgICAgICAgICAgICB2YXIgcGtnID0gdG9rZW47XHJcbiAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMudG4ubmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRva2VuICE9IExhbmcuRU5EKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCBlbmQgb2YgcGFja2FnZSBhdCBsaW5lIFwiK3RoaXMudG4ubGluZStcIjogXCIrdG9rZW4rXCIgKCdcIitMYW5nLkVORCtcIicgZXhwZWN0ZWQpXCIpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBrZztcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBQYXJzZXMgYW4gaW1wb3J0IGRlZmluaXRpb24uXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlbiBJbml0aWFsIHRva2VuXHJcbiAgICAgICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gSW1wb3J0IGZpbGUgbmFtZVxyXG4gICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGltcG9ydCBkZWZpbml0aW9uIGNhbm5vdCBiZSBwYXJzZWRcclxuICAgICAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFBhcnNlci5wcm90b3R5cGUuX3BhcnNlSW1wb3J0ID0gZnVuY3Rpb24odG9rZW4pIHtcclxuICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy50bi5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4gPT09IFwicHVibGljXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRuLm5leHQoKTtcclxuICAgICAgICAgICAgICAgIGlmICh0b2tlbiAhPT0gTGFuZy5TVFJJTkdPUEVOICYmIHRva2VuICE9PSBMYW5nLlNUUklOR09QRU5fU1EpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIGltcG9ydCBhdCBsaW5lIFwiK3RoaXMudG4ubGluZStcIjogXCIrdG9rZW4rXCIgKCdcIitMYW5nLlNUUklOR09QRU4rXCInIG9yICdcIitMYW5nLlNUUklOR09QRU5fU1ErXCInIGV4cGVjdGVkKVwiKTtcclxuICAgICAgICAgICAgICAgIHZhciBpbXBvcnRlZCA9IHRoaXMudG4ubmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRuLm5leHQoKTtcclxuICAgICAgICAgICAgICAgIGlmICh0b2tlbiAhPT0gdGhpcy50bi5zdHJpbmdFbmRzV2l0aClcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIklsbGVnYWwgaW1wb3J0IGF0IGxpbmUgXCIrdGhpcy50bi5saW5lK1wiOiBcIit0b2tlbitcIiAoJ1wiK3RoaXMudG4uc3RyaW5nRW5kc1dpdGgrXCInIGV4cGVjdGVkKVwiKTtcclxuICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy50bi5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4gIT09IExhbmcuRU5EKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCBpbXBvcnQgYXQgbGluZSBcIit0aGlzLnRuLmxpbmUrXCI6IFwiK3Rva2VuK1wiICgnXCIrTGFuZy5FTkQrXCInIGV4cGVjdGVkKVwiKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpbXBvcnRlZDtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBQYXJzZXMgYSBuYW1lc3BhY2Ugb3B0aW9uLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyZW50IFBhcmVudCBkZWZpbml0aW9uXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlbiBJbml0aWFsIHRva2VuXHJcbiAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgb3B0aW9uIGNhbm5vdCBiZSBwYXJzZWRcclxuICAgICAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFBhcnNlci5wcm90b3R5cGUuX3BhcnNlT3B0aW9uID0gZnVuY3Rpb24ocGFyZW50LCB0b2tlbikge1xyXG4gICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRuLm5leHQoKTtcclxuICAgICAgICAgICAgICAgIHZhciBjdXN0b20gPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGlmICh0b2tlbiA9PSBMYW5nLkNPUFRPUEVOKVxyXG4gICAgICAgICAgICAgICAgICAgIGN1c3RvbSA9IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRuLm5leHQoKTtcclxuICAgICAgICAgICAgICAgIGlmICghTGFuZy5UWVBFUkVGLnRlc3QodG9rZW4pKVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIGNhbiBhbGxvdyBvcHRpb25zIG9mIHRoZSBmb3JtIGdvb2dsZS5wcm90b2J1Zi4qIHNpbmNlIHRoZXkgd2lsbCBqdXN0IGdldCBpZ25vcmVkIGFueXdheXNcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIS9nb29nbGVcXC5wcm90b2J1ZlxcLi8udGVzdCh0b2tlbikpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCBvcHRpb24gaW4gbWVzc2FnZSBcIitwYXJlbnQubmFtZStcIiBhdCBsaW5lIFwiK3RoaXMudG4ubGluZStcIjogXCIrdG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgdmFyIG5hbWUgPSB0b2tlbjtcclxuICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy50bi5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoY3VzdG9tKSB7IC8vIChteV9tZXRob2Rfb3B0aW9uKS5mb28sIChteV9tZXRob2Rfb3B0aW9uKSwgc29tZV9tZXRob2Rfb3B0aW9uLCAoZm9vLm15X29wdGlvbikuYmFyXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuICE9PSBMYW5nLkNPUFRDTE9TRSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIG9wdGlvbiBpbiBtZXNzYWdlIFwiK3BhcmVudC5uYW1lK1wiLCBvcHRpb24gXCIrbmFtZStcIiBhdCBsaW5lIFwiK3RoaXMudG4ubGluZStcIjogXCIrdG9rZW4rXCIgKCdcIitMYW5nLkNPUFRDTE9TRStcIicgZXhwZWN0ZWQpXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPSAnKCcrbmFtZSsnKSc7XHJcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRuLm5leHQoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoTGFuZy5GUVRZUEVSRUYudGVzdCh0b2tlbikpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgKz0gdG9rZW4sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy50bi5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4gIT09IExhbmcuRVFVQUwpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIG9wdGlvbiBvcGVyYXRvciBpbiBtZXNzYWdlIFwiK3BhcmVudC5uYW1lK1wiLCBvcHRpb24gXCIrbmFtZStcIiBhdCBsaW5lIFwiK3RoaXMudG4ubGluZStcIjogXCIrdG9rZW4rXCIgKCdcIitMYW5nLkVRVUFMK1wiJyBleHBlY3RlZClcIik7XHJcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWU7XHJcbiAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMudG4ubmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRva2VuID09PSBMYW5nLlNUUklOR09QRU4gfHwgdG9rZW4gPT09IExhbmcuU1RSSU5HT1BFTl9TUSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy50bi5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRuLm5leHQoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW4gIT09IHRoaXMudG4uc3RyaW5nRW5kc1dpdGgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCBlbmQgb2Ygb3B0aW9uIHZhbHVlIGluIG1lc3NhZ2UgXCIrcGFyZW50Lm5hbWUrXCIsIG9wdGlvbiBcIituYW1lK1wiIGF0IGxpbmUgXCIrdGhpcy50bi5saW5lK1wiOiBcIit0b2tlbitcIiAoJ1wiK3RoaXMudG4uc3RyaW5nRW5kc1dpdGgrXCInIGV4cGVjdGVkKVwiKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKExhbmcuTlVNQkVSLnRlc3QodG9rZW4pKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMuX3BhcnNlTnVtYmVyKHRva2VuLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChMYW5nLkJPT0wudGVzdCh0b2tlbikpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdG9rZW4gPT09ICd0cnVlJztcclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChMYW5nLlRZUEVSRUYudGVzdCh0b2tlbikpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdG9rZW47XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIklsbGVnYWwgb3B0aW9uIHZhbHVlIGluIG1lc3NhZ2UgXCIrcGFyZW50Lm5hbWUrXCIsIG9wdGlvbiBcIituYW1lK1wiIGF0IGxpbmUgXCIrdGhpcy50bi5saW5lK1wiOiBcIit0b2tlbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMudG4ubmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRva2VuICE9PSBMYW5nLkVORClcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIklsbGVnYWwgZW5kIG9mIG9wdGlvbiBpbiBtZXNzYWdlIFwiK3BhcmVudC5uYW1lK1wiLCBvcHRpb24gXCIrbmFtZStcIiBhdCBsaW5lIFwiK3RoaXMudG4ubGluZStcIjogXCIrdG9rZW4rXCIgKCdcIitMYW5nLkVORCtcIicgZXhwZWN0ZWQpXCIpO1xyXG4gICAgICAgICAgICAgICAgcGFyZW50W1wib3B0aW9uc1wiXVtuYW1lXSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFBhcnNlcyBhbiBpZ25vcmVkIHN0YXRlbWVudCBvZiB0aGUgZm9ybSBbJ2tleXdvcmQnLCAuLi4sICc7J10uXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJlbnQgUGFyZW50IGRlZmluaXRpb25cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGtleXdvcmQgSW5pdGlhbCB0b2tlblxyXG4gICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGRpcmVjdGl2ZSBjYW5ub3QgYmUgcGFyc2VkXHJcbiAgICAgICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBQYXJzZXIucHJvdG90eXBlLl9wYXJzZUlnbm9yZWRTdGF0ZW1lbnQgPSBmdW5jdGlvbihwYXJlbnQsIGtleXdvcmQpIHtcclxuICAgICAgICAgICAgICAgIHZhciB0b2tlbjtcclxuICAgICAgICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMudG4ubmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbiA9PT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJVbmV4cGVjdGVkIEVPRiBpbiBcIitwYXJlbnQubmFtZStcIiwgXCIra2V5d29yZCtcIiAoaWdub3JlZCkgYXQgbGluZSBcIit0aGlzLnRuLmxpbmUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbiA9PT0gTGFuZy5FTkQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfSB3aGlsZSAodHJ1ZSk7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUGFyc2VzIGEgc2VydmljZSBkZWZpbml0aW9uLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyZW50IFBhcmVudCBkZWZpbml0aW9uXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlbiBJbml0aWFsIHRva2VuXHJcbiAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgc2VydmljZSBjYW5ub3QgYmUgcGFyc2VkXHJcbiAgICAgICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBQYXJzZXIucHJvdG90eXBlLl9wYXJzZVNlcnZpY2UgPSBmdW5jdGlvbihwYXJlbnQsIHRva2VuKSB7XHJcbiAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMudG4ubmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFMYW5nLk5BTUUudGVzdCh0b2tlbikpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIHNlcnZpY2UgbmFtZSBhdCBsaW5lIFwiK3RoaXMudG4ubGluZStcIjogXCIrdG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgdmFyIG5hbWUgPSB0b2tlbjtcclxuICAgICAgICAgICAgICAgIHZhciBzdmMgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgXCJuYW1lXCI6IG5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJycGNcIjoge30sXHJcbiAgICAgICAgICAgICAgICAgICAgXCJvcHRpb25zXCI6IHt9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRuLm5leHQoKTtcclxuICAgICAgICAgICAgICAgIGlmICh0b2tlbiAhPT0gTGFuZy5PUEVOKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCBPUEVOIGFmdGVyIHNlcnZpY2UgXCIrbmFtZStcIiBhdCBsaW5lIFwiK3RoaXMudG4ubGluZStcIjogXCIrdG9rZW4rXCIgKCdcIitMYW5nLk9QRU4rXCInIGV4cGVjdGVkKVwiKTtcclxuICAgICAgICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMudG4ubmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbiA9PT0gXCJvcHRpb25cIilcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFyc2VPcHRpb24oc3ZjLCB0b2tlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodG9rZW4gPT09ICdycGMnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYXJzZVNlcnZpY2VSUEMoc3ZjLCB0b2tlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodG9rZW4gIT09IExhbmcuQ0xPU0UpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCB0eXBlIGZvciBzZXJ2aWNlIFwiK25hbWUrXCIgYXQgbGluZSBcIit0aGlzLnRuLmxpbmUrXCI6IFwiK3Rva2VuKTtcclxuICAgICAgICAgICAgICAgIH0gd2hpbGUgKHRva2VuICE9PSBMYW5nLkNMT1NFKTtcclxuICAgICAgICAgICAgICAgIHBhcmVudFtcInNlcnZpY2VzXCJdLnB1c2goc3ZjKTtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBQYXJzZXMgYSBSUEMgc2VydmljZSBkZWZpbml0aW9uIG9mIHRoZSBmb3JtIFsncnBjJywgbmFtZSwgKHJlcXVlc3QpLCAncmV0dXJucycsIChyZXNwb25zZSldLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gc3ZjIFBhcmVudCBkZWZpbml0aW9uXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlbiBJbml0aWFsIHRva2VuXHJcbiAgICAgICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBQYXJzZXIucHJvdG90eXBlLl9wYXJzZVNlcnZpY2VSUEMgPSBmdW5jdGlvbihzdmMsIHRva2VuKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IHRva2VuO1xyXG4gICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRuLm5leHQoKTtcclxuICAgICAgICAgICAgICAgIGlmICghTGFuZy5OQU1FLnRlc3QodG9rZW4pKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCBSUEMgbWV0aG9kIG5hbWUgaW4gc2VydmljZSBcIitzdmNbXCJuYW1lXCJdK1wiIGF0IGxpbmUgXCIrdGhpcy50bi5saW5lK1wiOiBcIit0b2tlbik7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IHRva2VuO1xyXG4gICAgICAgICAgICAgICAgdmFyIG1ldGhvZCA9IHtcclxuICAgICAgICAgICAgICAgICAgICBcInJlcXVlc3RcIjogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICBcInJlc3BvbnNlXCI6IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJvcHRpb25zXCI6IHt9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRuLm5leHQoKTtcclxuICAgICAgICAgICAgICAgIGlmICh0b2tlbiAhPT0gTGFuZy5DT1BUT1BFTilcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIklsbGVnYWwgc3RhcnQgb2YgcmVxdWVzdCB0eXBlIGluIFJQQyBzZXJ2aWNlIFwiK3N2Y1tcIm5hbWVcIl0rXCIjXCIrbmFtZStcIiBhdCBsaW5lIFwiK3RoaXMudG4ubGluZStcIjogXCIrdG9rZW4rXCIgKCdcIitMYW5nLkNPUFRPUEVOK1wiJyBleHBlY3RlZClcIik7XHJcbiAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMudG4ubmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFMYW5nLlRZUEVSRUYudGVzdCh0b2tlbikpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIHJlcXVlc3QgdHlwZSBpbiBSUEMgc2VydmljZSBcIitzdmNbXCJuYW1lXCJdK1wiI1wiK25hbWUrXCIgYXQgbGluZSBcIit0aGlzLnRuLmxpbmUrXCI6IFwiK3Rva2VuKTtcclxuICAgICAgICAgICAgICAgIG1ldGhvZFtcInJlcXVlc3RcIl0gPSB0b2tlbjtcclxuICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy50bi5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4gIT0gTGFuZy5DT1BUQ0xPU0UpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIGVuZCBvZiByZXF1ZXN0IHR5cGUgaW4gUlBDIHNlcnZpY2UgXCIrc3ZjW1wibmFtZVwiXStcIiNcIituYW1lK1wiIGF0IGxpbmUgXCIrdGhpcy50bi5saW5lK1wiOiBcIit0b2tlbitcIiAoJ1wiK0xhbmcuQ09QVENMT1NFK1wiJyBleHBlY3RlZClcIik7XHJcbiAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMudG4ubmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRva2VuLnRvTG93ZXJDYXNlKCkgIT09IFwicmV0dXJuc1wiKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCByZXF1ZXN0L3Jlc3BvbnNlIGRlbGltaXRlciBpbiBSUEMgc2VydmljZSBcIitzdmNbXCJuYW1lXCJdK1wiI1wiK25hbWUrXCIgYXQgbGluZSBcIit0aGlzLnRuLmxpbmUrXCI6IFwiK3Rva2VuK1wiICgncmV0dXJucycgZXhwZWN0ZWQpXCIpO1xyXG4gICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRuLm5leHQoKTtcclxuICAgICAgICAgICAgICAgIGlmICh0b2tlbiAhPSBMYW5nLkNPUFRPUEVOKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCBzdGFydCBvZiByZXNwb25zZSB0eXBlIGluIFJQQyBzZXJ2aWNlIFwiK3N2Y1tcIm5hbWVcIl0rXCIjXCIrbmFtZStcIiBhdCBsaW5lIFwiK3RoaXMudG4ubGluZStcIjogXCIrdG9rZW4rXCIgKCdcIitMYW5nLkNPUFRPUEVOK1wiJyBleHBlY3RlZClcIik7XHJcbiAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMudG4ubmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgbWV0aG9kW1wicmVzcG9uc2VcIl0gPSB0b2tlbjtcclxuICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy50bi5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4gIT09IExhbmcuQ09QVENMT1NFKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCBlbmQgb2YgcmVzcG9uc2UgdHlwZSBpbiBSUEMgc2VydmljZSBcIitzdmNbXCJuYW1lXCJdK1wiI1wiK25hbWUrXCIgYXQgbGluZSBcIit0aGlzLnRuLmxpbmUrXCI6IFwiK3Rva2VuK1wiICgnXCIrTGFuZy5DT1BUQ0xPU0UrXCInIGV4cGVjdGVkKVwiKTtcclxuICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy50bi5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4gPT09IExhbmcuT1BFTikge1xyXG4gICAgICAgICAgICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRuLm5leHQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuID09PSAnb3B0aW9uJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhcnNlT3B0aW9uKG1ldGhvZCwgdG9rZW4pOyAvLyA8LSB3aWxsIGZhaWwgZm9yIHRoZSBjdXN0b20tb3B0aW9ucyBleGFtcGxlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRva2VuICE9PSBMYW5nLkNMT1NFKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIHN0YXJ0IG9mIG9wdGlvbiBpbiBSUEMgc2VydmljZSBcIitzdmNbXCJuYW1lXCJdK1wiI1wiK25hbWUrXCIgYXQgbGluZSBcIit0aGlzLnRuLmxpbmUrXCI6IFwiK3Rva2VuK1wiICgnb3B0aW9uJyBleHBlY3RlZClcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAodG9rZW4gIT09IExhbmcuQ0xPU0UpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnRuLnBlZWsoKSA9PT0gTGFuZy5FTkQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudG4ubmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0b2tlbiAhPT0gTGFuZy5FTkQpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIG1ldGhvZCBkZWxpbWl0ZXIgaW4gUlBDIHNlcnZpY2UgXCIrc3ZjW1wibmFtZVwiXStcIiNcIituYW1lK1wiIGF0IGxpbmUgXCIrdGhpcy50bi5saW5lK1wiOiBcIit0b2tlbitcIiAoJ1wiK0xhbmcuRU5EK1wiJyBvciAnXCIrTGFuZy5PUEVOK1wiJyBleHBlY3RlZClcIik7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHN2Y1t0eXBlXSA9PT0gJ3VuZGVmaW5lZCcpXHJcbiAgICAgICAgICAgICAgICAgICAgc3ZjW3R5cGVdID0ge307XHJcbiAgICAgICAgICAgICAgICBzdmNbdHlwZV1bbmFtZV0gPSBtZXRob2Q7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUGFyc2VzIGEgbWVzc2FnZSBkZWZpbml0aW9uLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyZW50IFBhcmVudCBkZWZpbml0aW9uXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBmbGQgRmllbGQgZGVmaW5pdGlvbiBpZiB0aGlzIGlzIGEgZ3JvdXAsIG90aGVyd2lzZSBgbnVsbGBcclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHRva2VuIEZpcnN0IHRva2VuXHJcbiAgICAgICAgICAgICAqIEByZXR1cm4ge09iamVjdH1cclxuICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBtZXNzYWdlIGNhbm5vdCBiZSBwYXJzZWRcclxuICAgICAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFBhcnNlci5wcm90b3R5cGUuX3BhcnNlTWVzc2FnZSA9IGZ1bmN0aW9uKHBhcmVudCwgZmxkLCB0b2tlbikge1xyXG4gICAgICAgICAgICAgICAgLyoqIEBkaWN0ICovXHJcbiAgICAgICAgICAgICAgICB2YXIgbXNnID0ge307IC8vIE5vdGU6IEF0IHNvbWUgcG9pbnQgd2UgbWlnaHQgd2FudCB0byBleGNsdWRlIHRoZSBwYXJzZXIsIHNvIHdlIG5lZWQgYSBkaWN0LlxyXG4gICAgICAgICAgICAgICAgdmFyIGlzR3JvdXAgPSB0b2tlbiA9PT0gXCJncm91cFwiO1xyXG4gICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRuLm5leHQoKTtcclxuICAgICAgICAgICAgICAgIGlmICghTGFuZy5OQU1FLnRlc3QodG9rZW4pKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCBcIisoaXNHcm91cCA/IFwiZ3JvdXBcIiA6IFwibWVzc2FnZVwiKStcIiBuYW1lXCIrKHBhcmVudCA/IFwiIGluIG1lc3NhZ2UgXCIrcGFyZW50W1wibmFtZVwiXSA6IFwiXCIpK1wiIGF0IGxpbmUgXCIrdGhpcy50bi5saW5lK1wiOiBcIit0b2tlbik7XHJcbiAgICAgICAgICAgICAgICBtc2dbXCJuYW1lXCJdID0gdG9rZW47XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNHcm91cCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy50bi5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuICE9PSBMYW5nLkVRVUFMKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIklsbGVnYWwgaWQgYXNzaWdubWVudCBhZnRlciBncm91cCBcIittc2cubmFtZStcIiBhdCBsaW5lIFwiK3RoaXMudG4ubGluZStcIjogXCIrdG9rZW4rXCIgKCdcIitMYW5nLkVRVUFMK1wiJyBleHBlY3RlZClcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRuLm5leHQoKTtcclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmbGRbXCJpZFwiXSA9IHRoaXMuX3BhcnNlSWQodG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIGZpZWxkIGlkIHZhbHVlIGZvciBncm91cCBcIittc2cubmFtZStcIiNcIitmbGQubmFtZStcIiBhdCBsaW5lIFwiK3RoaXMudG4ubGluZStcIjogXCIrdG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBtc2dbXCJpc0dyb3VwXCJdID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG1zZ1tcImZpZWxkc1wiXSA9IFtdOyAvLyBOb3RlOiBVc2luZyBhcnJheXMgdG8gc3VwcG9ydCBhbHNvIGJyb3dzZXIgdGhhdCBjYW5ub3QgcHJlc2VydmUgb3JkZXIgb2Ygb2JqZWN0IGtleXMuXHJcbiAgICAgICAgICAgICAgICBtc2dbXCJlbnVtc1wiXSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgbXNnW1wibWVzc2FnZXNcIl0gPSBbXTtcclxuICAgICAgICAgICAgICAgIG1zZ1tcIm9wdGlvbnNcIl0gPSB7fTtcclxuICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy50bi5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4gPT09IExhbmcuT1BUT1BFTiAmJiBmbGQpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFyc2VGaWVsZE9wdGlvbnMobXNnLCBmbGQsIHRva2VuKSxcclxuICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMudG4ubmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRva2VuICE9PSBMYW5nLk9QRU4pXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIE9QRU4gYWZ0ZXIgXCIrKGlzR3JvdXAgPyBcImdyb3VwXCIgOiBcIm1lc3NhZ2VcIikrXCIgXCIrbXNnLm5hbWUrXCIgYXQgbGluZSBcIit0aGlzLnRuLmxpbmUrXCI6IFwiK3Rva2VuK1wiICgnXCIrTGFuZy5PUEVOK1wiJyBleHBlY3RlZClcIik7XHJcbiAgICAgICAgICAgICAgICAvLyBtc2dbXCJleHRlbnNpb25zXCJdID0gdW5kZWZpbmVkXHJcbiAgICAgICAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRuLm5leHQoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW4gPT09IExhbmcuQ0xPU0UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRuLnBlZWsoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuID09PSBMYW5nLkVORClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudG4ubmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKExhbmcuUlVMRS50ZXN0KHRva2VuKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFyc2VNZXNzYWdlRmllbGQobXNnLCB0b2tlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodG9rZW4gPT09IFwiZW51bVwiKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYXJzZUVudW0obXNnLCB0b2tlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodG9rZW4gPT09IFwibWVzc2FnZVwiKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYXJzZU1lc3NhZ2UobXNnLCBudWxsLCB0b2tlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodG9rZW4gPT09IFwib3B0aW9uXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhcnNlT3B0aW9uKG1zZywgdG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRva2VuID09PSBcImV4dGVuc2lvbnNcIilcclxuICAgICAgICAgICAgICAgICAgICAgICAgbXNnW1wiZXh0ZW5zaW9uc1wiXSA9IHRoaXMuX3BhcnNlRXh0ZW5zaW9ucyhtc2csIHRva2VuKTtcclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0b2tlbiA9PT0gXCJleHRlbmRcIilcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFyc2VFeHRlbmQobXNnLCB0b2tlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIklsbGVnYWwgdG9rZW4gaW4gbWVzc2FnZSBcIittc2cubmFtZStcIiBhdCBsaW5lIFwiK3RoaXMudG4ubGluZStcIjogXCIrdG9rZW4rXCIgKHR5cGUgb3IgJ1wiK0xhbmcuQ0xPU0UrXCInIGV4cGVjdGVkKVwiKTtcclxuICAgICAgICAgICAgICAgIH0gd2hpbGUgKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgcGFyZW50W1wibWVzc2FnZXNcIl0ucHVzaChtc2cpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1zZztcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBQYXJzZXMgYSBtZXNzYWdlIGZpZWxkLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gbXNnIE1lc3NhZ2UgZGVmaW5pdGlvblxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdG9rZW4gSW5pdGlhbCB0b2tlblxyXG4gICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIG1lc3NhZ2UgZmllbGQgY2Fubm90IGJlIHBhcnNlZFxyXG4gICAgICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgUGFyc2VyLnByb3RvdHlwZS5fcGFyc2VNZXNzYWdlRmllbGQgPSBmdW5jdGlvbihtc2csIHRva2VuKSB7XHJcbiAgICAgICAgICAgICAgICAvKiogQGRpY3QgKi9cclxuICAgICAgICAgICAgICAgIHZhciBmbGQgPSB7fSwgZ3JwID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIGZsZFtcInJ1bGVcIl0gPSB0b2tlbjtcclxuICAgICAgICAgICAgICAgIC8qKiBAZGljdCAqL1xyXG4gICAgICAgICAgICAgICAgZmxkW1wib3B0aW9uc1wiXSA9IHt9O1xyXG4gICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRuLm5leHQoKTtcclxuICAgICAgICAgICAgICAgIGlmICh0b2tlbiA9PT0gXCJncm91cFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gXCJBIFtsZWdhY3ldIGdyb3VwIHNpbXBseSBjb21iaW5lcyBhIG5lc3RlZCBtZXNzYWdlIHR5cGUgYW5kIGEgZmllbGQgaW50byBhIHNpbmdsZSBkZWNsYXJhdGlvbi4gSW4geW91clxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvZGUsIHlvdSBjYW4gdHJlYXQgdGhpcyBtZXNzYWdlIGp1c3QgYXMgaWYgaXQgaGFkIGEgUmVzdWx0IHR5cGUgZmllbGQgY2FsbGVkIHJlc3VsdCAodGhlIGxhdHRlciBuYW1lIGlzXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gY29udmVydGVkIHRvIGxvd2VyLWNhc2Ugc28gdGhhdCBpdCBkb2VzIG5vdCBjb25mbGljdCB3aXRoIHRoZSBmb3JtZXIpLlwiXHJcbiAgICAgICAgICAgICAgICAgICAgZ3JwID0gdGhpcy5fcGFyc2VNZXNzYWdlKG1zZywgZmxkLCB0b2tlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEvXltBLVpdLy50ZXN0KGdycFtcIm5hbWVcIl0pKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcignR3JvdXAgbmFtZXMgbXVzdCBzdGFydCB3aXRoIGEgY2FwaXRhbCBsZXR0ZXInKTtcclxuICAgICAgICAgICAgICAgICAgICBmbGRbXCJ0eXBlXCJdID0gZ3JwW1wibmFtZVwiXTtcclxuICAgICAgICAgICAgICAgICAgICBmbGRbXCJuYW1lXCJdID0gZ3JwW1wibmFtZVwiXS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy50bi5wZWVrKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuID09PSBMYW5nLkVORClcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50bi5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghTGFuZy5UWVBFLnRlc3QodG9rZW4pICYmICFMYW5nLlRZUEVSRUYudGVzdCh0b2tlbikpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCBmaWVsZCB0eXBlIGluIG1lc3NhZ2UgXCIrbXNnLm5hbWUrXCIgYXQgbGluZSBcIit0aGlzLnRuLmxpbmUrXCI6IFwiK3Rva2VuKTtcclxuICAgICAgICAgICAgICAgICAgICBmbGRbXCJ0eXBlXCJdID0gdG9rZW47XHJcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRuLm5leHQoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIUxhbmcuTkFNRS50ZXN0KHRva2VuKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIGZpZWxkIG5hbWUgaW4gbWVzc2FnZSBcIittc2cubmFtZStcIiBhdCBsaW5lIFwiK3RoaXMudG4ubGluZStcIjogXCIrdG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIGZsZFtcIm5hbWVcIl0gPSB0b2tlbjtcclxuICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMudG4ubmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbiAhPT0gTGFuZy5FUVVBTClcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIGZpZWxkIGlkIGFzc2lnbm1lbnQgaW4gbWVzc2FnZSBcIittc2cubmFtZStcIiNcIitmbGQubmFtZStcIiBhdCBsaW5lIFwiK3RoaXMudG4ubGluZStcIjogXCIrdG9rZW4rXCIgKCdcIitMYW5nLkVRVUFMK1wiJyBleHBlY3RlZClcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRuLm5leHQoKTtcclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmbGRbXCJpZFwiXSA9IHRoaXMuX3BhcnNlSWQodG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIGZpZWxkIGlkIHZhbHVlIGluIG1lc3NhZ2UgXCIrbXNnLm5hbWUrXCIjXCIrZmxkLm5hbWUrXCIgYXQgbGluZSBcIit0aGlzLnRuLmxpbmUrXCI6IFwiK3Rva2VuKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRuLm5leHQoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW4gPT09IExhbmcuT1BUT1BFTilcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFyc2VGaWVsZE9wdGlvbnMobXNnLCBmbGQsIHRva2VuKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRuLm5leHQoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW4gIT09IExhbmcuRU5EKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIklsbGVnYWwgZmllbGQgZGVsaW1pdGVyIGluIG1lc3NhZ2UgXCIrbXNnLm5hbWUrXCIjXCIrZmxkLm5hbWUrXCIgYXQgbGluZSBcIit0aGlzLnRuLmxpbmUrXCI6IFwiK3Rva2VuK1wiICgnXCIrTGFuZy5FTkQrXCInIGV4cGVjdGVkKVwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG1zZ1tcImZpZWxkc1wiXS5wdXNoKGZsZCk7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUGFyc2VzIGEgc2V0IG9mIGZpZWxkIG9wdGlvbiBkZWZpbml0aW9ucy5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG1zZyBNZXNzYWdlIGRlZmluaXRpb25cclxuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGZsZCBGaWVsZCBkZWZpbml0aW9uXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlbiBJbml0aWFsIHRva2VuXHJcbiAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgbWVzc2FnZSBmaWVsZCBvcHRpb25zIGNhbm5vdCBiZSBwYXJzZWRcclxuICAgICAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFBhcnNlci5wcm90b3R5cGUuX3BhcnNlRmllbGRPcHRpb25zID0gZnVuY3Rpb24obXNnLCBmbGQsIHRva2VuKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZmlyc3QgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy50bi5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuID09PSBMYW5nLk9QVENMT1NFKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0b2tlbiA9PT0gTGFuZy5PUFRFTkQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpcnN0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIHN0YXJ0IG9mIG1lc3NhZ2UgZmllbGQgb3B0aW9ucyBpbiBtZXNzYWdlIFwiK21zZy5uYW1lK1wiI1wiK2ZsZC5uYW1lK1wiIGF0IGxpbmUgXCIrdGhpcy50bi5saW5lK1wiOiBcIit0b2tlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy50bi5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhcnNlRmllbGRPcHRpb24obXNnLCBmbGQsIHRva2VuKTtcclxuICAgICAgICAgICAgICAgICAgICBmaXJzdCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfSB3aGlsZSAodHJ1ZSk7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUGFyc2VzIGEgc2luZ2xlIGZpZWxkIG9wdGlvbi5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG1zZyBNZXNzYWdlIGRlZmluaXRpb25cclxuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGZsZCBGaWVsZCBkZWZpbml0aW9uXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlbiBJbml0aWFsIHRva2VuXHJcbiAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgbWVzYWdlIGZpZWxkIG9wdGlvbiBjYW5ub3QgYmUgcGFyc2VkXHJcbiAgICAgICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBQYXJzZXIucHJvdG90eXBlLl9wYXJzZUZpZWxkT3B0aW9uID0gZnVuY3Rpb24obXNnLCBmbGQsIHRva2VuKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY3VzdG9tID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4gPT09IExhbmcuQ09QVE9QRU4pXHJcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRuLm5leHQoKSxcclxuICAgICAgICAgICAgICAgICAgICBjdXN0b20gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFMYW5nLlRZUEVSRUYudGVzdCh0b2tlbikpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIGZpZWxkIG9wdGlvbiBpbiBtZXNzYWdlIFwiK21zZy5uYW1lK1wiI1wiK2ZsZC5uYW1lK1wiIGF0IGxpbmUgXCIrdGhpcy50bi5saW5lK1wiOiBcIit0b2tlbik7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IHRva2VuO1xyXG4gICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRuLm5leHQoKTtcclxuICAgICAgICAgICAgICAgIGlmIChjdXN0b20pIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW4gIT09IExhbmcuQ09QVENMT1NFKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIklsbGVnYWwgY3VzdG9tIGZpZWxkIG9wdGlvbiBuYW1lIGRlbGltaXRlciBpbiBtZXNzYWdlIFwiK21zZy5uYW1lK1wiI1wiK2ZsZC5uYW1lK1wiIGF0IGxpbmUgXCIrdGhpcy50bi5saW5lK1wiOiBcIit0b2tlbitcIiAoJyknIGV4cGVjdGVkKVwiKTtcclxuICAgICAgICAgICAgICAgICAgICBuYW1lID0gJygnK25hbWUrJyknO1xyXG4gICAgICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy50bi5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKExhbmcuRlFUWVBFUkVGLnRlc3QodG9rZW4pKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lICs9IHRva2VuLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMudG4ubmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHRva2VuICE9PSBMYW5nLkVRVUFMKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCBmaWVsZCBvcHRpb24gb3BlcmF0aW9uIGluIG1lc3NhZ2UgXCIrbXNnLm5hbWUrXCIjXCIrZmxkLm5hbWUrXCIgYXQgbGluZSBcIit0aGlzLnRuLmxpbmUrXCI6IFwiK3Rva2VuK1wiICgnPScgZXhwZWN0ZWQpXCIpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRuLm5leHQoKTtcclxuICAgICAgICAgICAgICAgIGlmICh0b2tlbiA9PT0gTGFuZy5TVFJJTkdPUEVOIHx8IHRva2VuID09PSBMYW5nLlNUUklOR09QRU5fU1EpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMudG4ubmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy50bi5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuICE9IHRoaXMudG4uc3RyaW5nRW5kc1dpdGgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCBlbmQgb2YgZmllbGQgdmFsdWUgaW4gbWVzc2FnZSBcIittc2cubmFtZStcIiNcIitmbGQubmFtZStcIiwgb3B0aW9uIFwiK25hbWUrXCIgYXQgbGluZSBcIit0aGlzLnRuLmxpbmUrXCI6IFwiK3Rva2VuK1wiICgnXCIrdGhpcy50bi5zdHJpbmdFbmRzV2l0aCtcIicgZXhwZWN0ZWQpXCIpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChMYW5nLk5VTUJFUi50ZXN0KHRva2VuLCB0cnVlKSlcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMuX3BhcnNlTnVtYmVyKHRva2VuLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKExhbmcuQk9PTC50ZXN0KHRva2VuKSlcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRva2VuLnRvTG93ZXJDYXNlKCkgPT09ICd0cnVlJztcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKExhbmcuVFlQRVJFRi50ZXN0KHRva2VuKSlcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRva2VuOyAvLyBUT0RPOiBSZXNvbHZlP1xyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCBmaWVsZCBvcHRpb24gdmFsdWUgaW4gbWVzc2FnZSBcIittc2cubmFtZStcIiNcIitmbGQubmFtZStcIiwgb3B0aW9uIFwiK25hbWUrXCIgYXQgbGluZSBcIit0aGlzLnRuLmxpbmUrXCI6IFwiK3Rva2VuKTtcclxuICAgICAgICAgICAgICAgIGZsZFtcIm9wdGlvbnNcIl1bbmFtZV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBQYXJzZXMgYW4gZW51bS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG1zZyBNZXNzYWdlIGRlZmluaXRpb25cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHRva2VuIEluaXRpYWwgdG9rZW5cclxuICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBlbnVtIGNhbm5vdCBiZSBwYXJzZWRcclxuICAgICAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFBhcnNlci5wcm90b3R5cGUuX3BhcnNlRW51bSA9IGZ1bmN0aW9uKG1zZywgdG9rZW4pIHtcclxuICAgICAgICAgICAgICAgIC8qKiBAZGljdCAqL1xyXG4gICAgICAgICAgICAgICAgdmFyIGVubSA9IHt9O1xyXG4gICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRuLm5leHQoKTtcclxuICAgICAgICAgICAgICAgIGlmICghTGFuZy5OQU1FLnRlc3QodG9rZW4pKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCBlbnVtIG5hbWUgaW4gbWVzc2FnZSBcIittc2cubmFtZStcIiBhdCBsaW5lIFwiK3RoaXMudG4ubGluZStcIjogXCIrdG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgZW5tW1wibmFtZVwiXSA9IHRva2VuO1xyXG4gICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRuLm5leHQoKTtcclxuICAgICAgICAgICAgICAgIGlmICh0b2tlbiAhPT0gTGFuZy5PUEVOKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCBPUEVOIGFmdGVyIGVudW0gXCIrZW5tLm5hbWUrXCIgYXQgbGluZSBcIit0aGlzLnRuLmxpbmUrXCI6IFwiK3Rva2VuKTtcclxuICAgICAgICAgICAgICAgIGVubVtcInZhbHVlc1wiXSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgZW5tW1wib3B0aW9uc1wiXSA9IHt9O1xyXG4gICAgICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy50bi5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuID09PSBMYW5nLkNMT1NFKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy50bi5wZWVrKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbiA9PT0gTGFuZy5FTkQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRuLm5leHQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbiA9PSAnb3B0aW9uJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFyc2VPcHRpb24oZW5tLCB0b2tlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghTGFuZy5OQU1FLnRlc3QodG9rZW4pKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIGVudW0gdmFsdWUgbmFtZSBpbiBlbnVtIFwiK2VubS5uYW1lK1wiIGF0IGxpbmUgXCIrdGhpcy50bi5saW5lK1wiOiBcIit0b2tlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhcnNlRW51bVZhbHVlKGVubSwgdG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gd2hpbGUgKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgbXNnW1wiZW51bXNcIl0ucHVzaChlbm0pO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFBhcnNlcyBhbiBlbnVtIHZhbHVlLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZW5tIEVudW0gZGVmaW5pdGlvblxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdG9rZW4gSW5pdGlhbCB0b2tlblxyXG4gICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGVudW0gdmFsdWUgY2Fubm90IGJlIHBhcnNlZFxyXG4gICAgICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgUGFyc2VyLnByb3RvdHlwZS5fcGFyc2VFbnVtVmFsdWUgPSBmdW5jdGlvbihlbm0sIHRva2VuKSB7XHJcbiAgICAgICAgICAgICAgICAvKiogQGRpY3QgKi9cclxuICAgICAgICAgICAgICAgIHZhciB2YWwgPSB7fTtcclxuICAgICAgICAgICAgICAgIHZhbFtcIm5hbWVcIl0gPSB0b2tlbjtcclxuICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy50bi5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4gIT09IExhbmcuRVFVQUwpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIGVudW0gdmFsdWUgb3BlcmF0b3IgaW4gZW51bSBcIitlbm0ubmFtZStcIiBhdCBsaW5lIFwiK3RoaXMudG4ubGluZStcIjogXCIrdG9rZW4rXCIgKCdcIitMYW5nLkVRVUFMK1wiJyBleHBlY3RlZClcIik7XHJcbiAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMudG4ubmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICB2YWxbXCJpZFwiXSA9IHRoaXMuX3BhcnNlSWQodG9rZW4sIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCBlbnVtIHZhbHVlIGlkIGluIGVudW0gXCIrZW5tLm5hbWUrXCIgYXQgbGluZSBcIit0aGlzLnRuLmxpbmUrXCI6IFwiK3Rva2VuKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVubVtcInZhbHVlc1wiXS5wdXNoKHZhbCk7XHJcbiAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMudG4ubmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRva2VuID09PSBMYW5nLk9QVE9QRU4pIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgb3B0ID0geyAnb3B0aW9ucycgOiB7fSB9OyAvLyBUT0RPOiBBY3R1YWxseSBleHBvc2UgdGhlbSBzb21laG93LlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhcnNlRmllbGRPcHRpb25zKGVubSwgb3B0LCB0b2tlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRuLm5leHQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0b2tlbiAhPT0gTGFuZy5FTkQpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIGVudW0gdmFsdWUgZGVsaW1pdGVyIGluIGVudW0gXCIrZW5tLm5hbWUrXCIgYXQgbGluZSBcIit0aGlzLnRuLmxpbmUrXCI6IFwiK3Rva2VuK1wiICgnXCIrTGFuZy5FTkQrXCInIGV4cGVjdGVkKVwiKTtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBQYXJzZXMgYW4gZXh0ZW5zaW9ucyBzdGF0ZW1lbnQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtc2cgTWVzc2FnZSBvYmplY3RcclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHRva2VuIEluaXRpYWwgdG9rZW5cclxuICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBleHRlbnNpb25zIHN0YXRlbWVudCBjYW5ub3QgYmUgcGFyc2VkXHJcbiAgICAgICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBQYXJzZXIucHJvdG90eXBlLl9wYXJzZUV4dGVuc2lvbnMgPSBmdW5jdGlvbihtc2csIHRva2VuKSB7XHJcbiAgICAgICAgICAgICAgICAvKiogQHR5cGUge0FycmF5LjxudW1iZXI+fSAqL1xyXG4gICAgICAgICAgICAgICAgdmFyIHJhbmdlID0gW107XHJcbiAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMudG4ubmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRva2VuID09PSBcIm1pblwiKSAvLyBGSVhNRTogRG9lcyB0aGUgb2ZmaWNpYWwgaW1wbGVtZW50YXRpb24gc3VwcG9ydCB0aGlzP1xyXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlLnB1c2goUHJvdG9CdWYuSURfTUlOKTtcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRva2VuID09PSBcIm1heFwiKVxyXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlLnB1c2goUHJvdG9CdWYuSURfTUFYKTtcclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICByYW5nZS5wdXNoKHRoaXMuX3BhcnNlTnVtYmVyKHRva2VuKSk7XHJcbiAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMudG4ubmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRva2VuICE9PSAndG8nKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCBleHRlbnNpb25zIGRlbGltaXRlciBpbiBtZXNzYWdlIFwiK21zZy5uYW1lK1wiIGF0IGxpbmUgXCIrdGhpcy50bi5saW5lK1wiICgndG8nIGV4cGVjdGVkKVwiKTtcclxuICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy50bi5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4gPT09IFwibWluXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2UucHVzaChQcm90b0J1Zi5JRF9NSU4pO1xyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodG9rZW4gPT09IFwibWF4XCIpXHJcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2UucHVzaChQcm90b0J1Zi5JRF9NQVgpO1xyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlLnB1c2godGhpcy5fcGFyc2VOdW1iZXIodG9rZW4pKTtcclxuICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy50bi5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4gIT09IExhbmcuRU5EKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCBleHRlbnNpb24gZGVsaW1pdGVyIGluIG1lc3NhZ2UgXCIrbXNnLm5hbWUrXCIgYXQgbGluZSBcIit0aGlzLnRuLmxpbmUrXCI6IFwiK3Rva2VuK1wiICgnXCIrTGFuZy5FTkQrXCInIGV4cGVjdGVkKVwiKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiByYW5nZTtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBQYXJzZXMgYW4gZXh0ZW5kIGJsb2NrLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyZW50IFBhcmVudCBvYmplY3RcclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHRva2VuIEluaXRpYWwgdG9rZW5cclxuICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBleHRlbmQgYmxvY2sgY2Fubm90IGJlIHBhcnNlZFxyXG4gICAgICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgUGFyc2VyLnByb3RvdHlwZS5fcGFyc2VFeHRlbmQgPSBmdW5jdGlvbihwYXJlbnQsIHRva2VuKSB7XHJcbiAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMudG4ubmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFMYW5nLlRZUEVSRUYudGVzdCh0b2tlbikpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIGV4dGVuZGVkIG1lc3NhZ2UgbmFtZSBhdCBsaW5lIFwiK3RoaXMudG4ubGluZStcIjogXCIrdG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgLyoqIEBkaWN0ICovXHJcbiAgICAgICAgICAgICAgICB2YXIgZXh0ID0ge307XHJcbiAgICAgICAgICAgICAgICBleHRbXCJyZWZcIl0gPSB0b2tlbjtcclxuICAgICAgICAgICAgICAgIGV4dFtcImZpZWxkc1wiXSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRuLm5leHQoKTtcclxuICAgICAgICAgICAgICAgIGlmICh0b2tlbiAhPT0gTGFuZy5PUEVOKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCBPUEVOIGluIGV4dGVuZCBcIitleHQubmFtZStcIiBhdCBsaW5lIFwiK3RoaXMudG4ubGluZStcIjogXCIrdG9rZW4rXCIgKCdcIitMYW5nLk9QRU4rXCInIGV4cGVjdGVkKVwiKTtcclxuICAgICAgICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMudG4ubmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbiA9PT0gTGFuZy5DTE9TRSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMudG4ucGVlaygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW4gPT0gTGFuZy5FTkQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRuLm5leHQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChMYW5nLlJVTEUudGVzdCh0b2tlbikpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhcnNlTWVzc2FnZUZpZWxkKGV4dCwgdG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIHRva2VuIGluIGV4dGVuZCBcIitleHQubmFtZStcIiBhdCBsaW5lIFwiK3RoaXMudG4ubGluZStcIjogXCIrdG9rZW4rXCIgKHJ1bGUgb3IgJ1wiK0xhbmcuQ0xPU0UrXCInIGV4cGVjdGVkKVwiKTtcclxuICAgICAgICAgICAgICAgIH0gd2hpbGUgKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgcGFyZW50W1wibWVzc2FnZXNcIl0ucHVzaChleHQpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4dDtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgb2JqZWN0LlxyXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBTdHJpbmcgcmVwcmVzZW50YXRpb24gYXMgb2YgXCJQYXJzZXJcIlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgUGFyc2VyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiUGFyc2VyXCI7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQGFsaWFzIFByb3RvQnVmLkRvdFByb3RvLlBhcnNlclxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBEb3RQcm90by5QYXJzZXIgPSBQYXJzZXI7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gRG90UHJvdG87XHJcblxyXG4gICAgICAgIH0pKFByb3RvQnVmLCBQcm90b0J1Zi5MYW5nKTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQGFsaWFzIFByb3RvQnVmLlJlZmxlY3RcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUHJvdG9CdWYuUmVmbGVjdCA9IChmdW5jdGlvbihQcm90b0J1Zikge1xyXG4gICAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBSZWZsZWN0aW9uIHR5cGVzLlxyXG4gICAgICAgICAgICAgKiBAZXhwb3J0cyBQcm90b0J1Zi5SZWZsZWN0XHJcbiAgICAgICAgICAgICAqIEBuYW1lc3BhY2VcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHZhciBSZWZsZWN0ID0ge307XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQ29uc3RydWN0cyBhIFJlZmxlY3QgYmFzZSBjbGFzcy5cclxuICAgICAgICAgICAgICogQGV4cG9ydHMgUHJvdG9CdWYuUmVmbGVjdC5UXHJcbiAgICAgICAgICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICAgICAgICAgKiBAYWJzdHJhY3RcclxuICAgICAgICAgICAgICogQHBhcmFtIHtQcm90b0J1Zi5SZWZsZWN0LlR9IHBhcmVudCBQYXJlbnQgb2JqZWN0XHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE9iamVjdCBuYW1lXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB2YXIgVCA9IGZ1bmN0aW9uKHBhcmVudCwgbmFtZSkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogUGFyZW50IG9iamVjdC5cclxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtQcm90b0J1Zi5SZWZsZWN0LlR8bnVsbH1cclxuICAgICAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBPYmplY3QgbmFtZSBpbiBuYW1lc3BhY2UuXHJcbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAgICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogRnVsbHkgcXVhbGlmaWVkIGNsYXNzIG5hbWVcclxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICAgICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuY2xhc3NOYW1lO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFJldHVybnMgdGhlIGZ1bGx5IHF1YWxpZmllZCBuYW1lIG9mIHRoaXMgb2JqZWN0LlxyXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBGdWxseSBxdWFsaWZpZWQgbmFtZSBhcyBvZiBcIi5QQVRILlRPLlRISVNcIlxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBULnByb3RvdHlwZS5mcW4gPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHZhciBuYW1lID0gdGhpcy5uYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgIHB0ciA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHRyID0gcHRyLnBhcmVudDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocHRyID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPSBwdHIubmFtZStcIi5cIituYW1lO1xyXG4gICAgICAgICAgICAgICAgfSB3aGlsZSAodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmFtZTtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgUmVmbGVjdCBvYmplY3QgKGl0cyBmdWxseSBxdWFsaWZpZWQgbmFtZSkuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IGluY2x1ZGVDbGFzcyBTZXQgdG8gdHJ1ZSB0byBpbmNsdWRlIHRoZSBjbGFzcyBuYW1lLiBEZWZhdWx0cyB0byBmYWxzZS5cclxuICAgICAgICAgICAgICogQHJldHVybiBTdHJpbmcgcmVwcmVzZW50YXRpb25cclxuICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgVC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbihpbmNsdWRlQ2xhc3MpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAoaW5jbHVkZUNsYXNzID8gdGhpcy5jbGFzc05hbWUgKyBcIiBcIiA6IFwiXCIpICsgdGhpcy5mcW4oKTtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBCdWlsZHMgdGhpcyB0eXBlLlxyXG4gICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhpcyB0eXBlIGNhbm5vdCBiZSBidWlsdCBkaXJlY3RseVxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBULnByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IodGhpcy50b1N0cmluZyh0cnVlKStcIiBjYW5ub3QgYmUgYnVpbHQgZGlyZWN0bHlcIik7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQGFsaWFzIFByb3RvQnVmLlJlZmxlY3QuVFxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBSZWZsZWN0LlQgPSBUO1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgTmFtZXNwYWNlLlxyXG4gICAgICAgICAgICAgKiBAZXhwb3J0cyBQcm90b0J1Zi5SZWZsZWN0Lk5hbWVzcGFjZVxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge1Byb3RvQnVmLlJlZmxlY3QuTmFtZXNwYWNlfG51bGx9IHBhcmVudCBOYW1lc3BhY2UgcGFyZW50XHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE5hbWVzcGFjZSBuYW1lXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG9wdGlvbnMgTmFtZXNwYWNlIG9wdGlvbnNcclxuICAgICAgICAgICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgICAgICAgICAqIEBleHRlbmRzIFByb3RvQnVmLlJlZmxlY3QuVFxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdmFyIE5hbWVzcGFjZSA9IGZ1bmN0aW9uKHBhcmVudCwgbmFtZSwgb3B0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgVC5jYWxsKHRoaXMsIHBhcmVudCwgbmFtZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBAb3ZlcnJpZGVcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jbGFzc05hbWUgPSBcIk5hbWVzcGFjZVwiO1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQ2hpbGRyZW4gaW5zaWRlIHRoZSBuYW1lc3BhY2UuXHJcbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPFByb3RvQnVmLlJlZmxlY3QuVD59XHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIE9wdGlvbnMuXHJcbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsICo+fVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLy8gRXh0ZW5kcyBUXHJcbiAgICAgICAgICAgIE5hbWVzcGFjZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFQucHJvdG90eXBlKTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIHRoZSBuYW1lc3BhY2UncyBjaGlsZHJlbi5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtQcm90b0J1Zi5SZWZsZWN0LlQ9fSB0eXBlIEZpbHRlciB0eXBlIChyZXR1cm5zIGluc3RhbmNlcyBvZiB0aGlzIHR5cGUgb25seSkuIERlZmF1bHRzIHRvIG51bGwgKGFsbCBjaGlsZHJlbikuXHJcbiAgICAgICAgICAgICAqIEByZXR1cm4ge0FycmF5LjxQcm90b0J1Zi5SZWZsZWN0LlQ+fVxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBOYW1lc3BhY2UucHJvdG90eXBlLmdldENoaWxkcmVuID0gZnVuY3Rpb24odHlwZSkge1xyXG4gICAgICAgICAgICAgICAgdHlwZSA9IHR5cGUgfHwgbnVsbDtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW4uc2xpY2UoKTtcclxuICAgICAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IFtdO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaT0wLCBrPXRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpPGs7ICsraSlcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jaGlsZHJlbltpXSBpbnN0YW5jZW9mIHR5cGUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGFsc28gbmVlZCB0byBkaXN0aW5ndWlzaCBiZXR3ZWVuIEZpZWxkIGFuZCBFeHRlbnNpb25GaWVsZCB3aGljaCBpcyBhbiBpbnN0YW5jZSBvZiBGaWVsZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSAhPT0gTWVzc2FnZS5GaWVsZCB8fCAhKHRoaXMuY2hpbGRyZW5baV0gaW5zdGFuY2VvZiBNZXNzYWdlLkV4dGVuc2lvbkZpZWxkKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2godGhpcy5jaGlsZHJlbltpXSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGRyZW47XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQWRkcyBhIGNoaWxkIHRvIHRoZSBuYW1lc3BhY2UuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7UHJvdG9CdWYuUmVmbGVjdC5UfSBjaGlsZCBDaGlsZFxyXG4gICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGNoaWxkIGNhbm5vdCBiZSBhZGRlZCAoZHVwbGljYXRlKVxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBOYW1lc3BhY2UucHJvdG90eXBlLmFkZENoaWxkID0gZnVuY3Rpb24oY2hpbGQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBvdGhlcjtcclxuICAgICAgICAgICAgICAgIGlmIChvdGhlciA9IHRoaXMuZ2V0Q2hpbGQoY2hpbGQubmFtZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBUcnkgdG8gcmV2ZXJ0IGNhbWVsY2FzZSB0cmFuc2Zvcm1hdGlvbiBvbiBjb2xsaXNpb25cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3RoZXIgaW5zdGFuY2VvZiBNZXNzYWdlLkZpZWxkICYmIG90aGVyLm5hbWUgIT09IG90aGVyLm9yaWdpbmFsTmFtZSAmJiAhdGhpcy5oYXNDaGlsZChvdGhlci5vcmlnaW5hbE5hbWUpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvdGhlci5uYW1lID0gb3RoZXIub3JpZ2luYWxOYW1lOyAvLyBSZXZlcnQgcHJldmlvdXMgZmlyc3QgKGVmZmVjdGl2ZWx5IGtlZXBzIGJvdGggb3JpZ2luYWxzKVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNoaWxkIGluc3RhbmNlb2YgTWVzc2FnZS5GaWVsZCAmJiBjaGlsZC5uYW1lICE9PSBjaGlsZC5vcmlnaW5hbE5hbWUgJiYgIXRoaXMuaGFzQ2hpbGQoY2hpbGQub3JpZ2luYWxOYW1lKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQubmFtZSA9IGNoaWxkLm9yaWdpbmFsTmFtZTtcclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiRHVwbGljYXRlIG5hbWUgaW4gbmFtZXNwYWNlIFwiK3RoaXMudG9TdHJpbmcodHJ1ZSkrXCI6IFwiK2NoaWxkLm5hbWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUZXN0cyBpZiB0aGlzIG5hbWVzcGFjZSBoYXMgYSBjaGlsZCB3aXRoIHRoZSBzcGVjaWZpZWQgbmFtZS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBuYW1lT3JJZCBDaGlsZCBuYW1lIG9yIGlkXHJcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoZXJlIGlzIG9uZSwgZWxzZSBmYWxzZVxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBOYW1lc3BhY2UucHJvdG90eXBlLmhhc0NoaWxkID0gZnVuY3Rpb24obmFtZU9ySWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbmRleE9mKG5hbWVPcklkKSA+IC0xO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdldHMgYSBjaGlsZCBieSBpdHMgbmFtZS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBuYW1lT3JJZCBDaGlsZCBuYW1lIG9yIGlkXHJcbiAgICAgICAgICAgICAqIEByZXR1cm4gez9Qcm90b0J1Zi5SZWZsZWN0LlR9IFRoZSBjaGlsZCBvciBudWxsIGlmIG5vdCBmb3VuZFxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBOYW1lc3BhY2UucHJvdG90eXBlLmdldENoaWxkID0gZnVuY3Rpb24obmFtZU9ySWQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMuX2luZGV4T2YobmFtZU9ySWQpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4ID4gLTEgPyB0aGlzLmNoaWxkcmVuW2luZGV4XSA6IG51bGw7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUmV0dXJucyBjaGlsZCBpbmRleCBieSBpdHMgbmFtZSBvciBpZC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBuYW1lT3JJZCBDaGlsZCBuYW1lIG9yIGlkXHJcbiAgICAgICAgICAgICAqIEByZXR1cm4ge051bWJlcn0gVGhlIGNoaWxkIGluZGV4XHJcbiAgICAgICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBOYW1lc3BhY2UucHJvdG90eXBlLl9pbmRleE9mID0gZnVuY3Rpb24obmFtZU9ySWQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBrZXkgPSB0eXBlb2YgbmFtZU9ySWQgPT09ICdudW1iZXInID8gJ2lkJyA6ICduYW1lJztcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGk9MDsgaTx0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5jaGlsZHJlbltpXVtrZXldICE9PSAndW5kZWZpbmVkJyAmJiB0aGlzLmNoaWxkcmVuW2ldW2tleV0gPT0gbmFtZU9ySWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFJlc29sdmVzIGEgcmVmbGVjdCBvYmplY3QgaW5zaWRlIG9mIHRoaXMgbmFtZXNwYWNlLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcW4gUXVhbGlmaWVkIG5hbWUgdG8gcmVzb2x2ZVxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBleGNsdWRlRmllbGRzIEV4Y2x1ZGVzIGZpZWxkcywgZGVmYXVsdHMgdG8gYGZhbHNlYFxyXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHtQcm90b0J1Zi5SZWZsZWN0Lk5hbWVzcGFjZXxudWxsfSBUaGUgcmVzb2x2ZWQgdHlwZSBvciBudWxsIGlmIG5vdCBmb3VuZFxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBOYW1lc3BhY2UucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbihxbiwgZXhjbHVkZUZpZWxkcykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBhcnQgPSBxbi5zcGxpdChcIi5cIik7XHJcbiAgICAgICAgICAgICAgICB2YXIgcHRyID0gdGhpcywgaT0wO1xyXG4gICAgICAgICAgICAgICAgaWYgKHBhcnRbaV0gPT0gXCJcIikgeyAvLyBGdWxseSBxdWFsaWZpZWQgbmFtZSwgZS5nLiBcIi5NeS5NZXNzYWdlJ1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChwdHIucGFyZW50ICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHB0ciA9IHB0ci5wYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkO1xyXG4gICAgICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQgPSBwdHIuZ2V0Q2hpbGQocGFydFtpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY2hpbGQgfHwgIShjaGlsZCBpbnN0YW5jZW9mIFJlZmxlY3QuVCkgfHwgKGV4Y2x1ZGVGaWVsZHMgJiYgY2hpbGQgaW5zdGFuY2VvZiBSZWZsZWN0Lk1lc3NhZ2UuRmllbGQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdHIgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcHRyID0gY2hpbGQ7IGkrKztcclxuICAgICAgICAgICAgICAgICAgICB9IHdoaWxlIChpIDwgcGFydC5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwdHIgIT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7IC8vIEZvdW5kXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRWxzZSBzZWFyY2ggdGhlIHBhcmVudFxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnBhcmVudCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQucmVzb2x2ZShxbiwgZXhjbHVkZUZpZWxkcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSB3aGlsZSAocHRyICE9IG51bGwpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHB0cjtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBCdWlsZHMgdGhlIG5hbWVzcGFjZSBhbmQgcmV0dXJucyB0aGUgcnVudGltZSBjb3VudGVycGFydC5cclxuICAgICAgICAgICAgICogQHJldHVybiB7T2JqZWN0LjxzdHJpbmcsRnVuY3Rpb258T2JqZWN0Pn0gUnVudGltZSBuYW1lc3BhY2VcclxuICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgTmFtZXNwYWNlLnByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgLyoqIEBkaWN0ICovXHJcbiAgICAgICAgICAgICAgICB2YXIgbnMgPSB7fTtcclxuICAgICAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuZ2V0Q2hpbGRyZW4oKSwgY2hpbGQ7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpPTAsIGs9Y2hpbGRyZW4ubGVuZ3RoOyBpPGs7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkID0gY2hpbGRyZW5baV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgTmFtZXNwYWNlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuc1tjaGlsZC5uYW1lXSA9IGNoaWxkLmJ1aWxkKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KVxyXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgXCIkb3B0aW9uc1wiLCB7IFwidmFsdWVcIjogdGhpcy5idWlsZE9wdCgpIH0pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5zO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEJ1aWxkcyB0aGUgbmFtZXNwYWNlJ3MgJyRvcHRpb25zJyBwcm9wZXJ0eS5cclxuICAgICAgICAgICAgICogQHJldHVybiB7T2JqZWN0LjxzdHJpbmcsKj59XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBOYW1lc3BhY2UucHJvdG90eXBlLmJ1aWxkT3B0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgb3B0ID0ge307XHJcbiAgICAgICAgICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHRoaXMub3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8a2V5cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSB0aGlzLm9wdGlvbnNba2V5c1tpXV07XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogT3B0aW9ucyBhcmUgbm90IHJlc29sdmVkLCB5ZXQuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgKHZhbCBpbnN0YW5jZW9mIE5hbWVzcGFjZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICBvcHRba2V5XSA9IHZhbC5idWlsZCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3B0W2tleV0gPSB2YWw7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9wdDtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBHZXRzIHRoZSB2YWx1ZSBhc3NpZ25lZCB0byB0aGUgb3B0aW9uIHdpdGggdGhlIHNwZWNpZmllZCBuYW1lLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZz19IG5hbWUgUmV0dXJucyB0aGUgb3B0aW9uIHZhbHVlIGlmIHNwZWNpZmllZCwgb3RoZXJ3aXNlIGFsbCBvcHRpb25zIGFyZSByZXR1cm5lZC5cclxuICAgICAgICAgICAgICogQHJldHVybiB7KnxPYmplY3QuPHN0cmluZywqPn1udWxsfSBPcHRpb24gdmFsdWUgb3IgTlVMTCBpZiB0aGVyZSBpcyBubyBzdWNoIG9wdGlvblxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgTmFtZXNwYWNlLnByb3RvdHlwZS5nZXRPcHRpb24gPSBmdW5jdGlvbihuYW1lKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG5hbWUgPT09ICd1bmRlZmluZWQnKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnM7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIHRoaXMub3B0aW9uc1tuYW1lXSAhPT0gJ3VuZGVmaW5lZCcgPyB0aGlzLm9wdGlvbnNbbmFtZV0gOiBudWxsO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEBhbGlhcyBQcm90b0J1Zi5SZWZsZWN0Lk5hbWVzcGFjZVxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBSZWZsZWN0Lk5hbWVzcGFjZSA9IE5hbWVzcGFjZTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IE1lc3NhZ2UuXHJcbiAgICAgICAgICAgICAqIEBleHBvcnRzIFByb3RvQnVmLlJlZmxlY3QuTWVzc2FnZVxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge1Byb3RvQnVmLlJlZmxlY3QuTmFtZXNwYWNlfSBwYXJlbnQgUGFyZW50IG1lc3NhZ2Ugb3IgbmFtZXNwYWNlXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE1lc3NhZ2UgbmFtZVxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBvcHRpb25zIE1lc3NhZ2Ugb3B0aW9uc1xyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBpc0dyb3VwIGB0cnVlYCBpZiB0aGlzIGlzIGEgbGVnYWN5IGdyb3VwXHJcbiAgICAgICAgICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICAgICAgICAgKiBAZXh0ZW5kcyBQcm90b0J1Zi5SZWZsZWN0Lk5hbWVzcGFjZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdmFyIE1lc3NhZ2UgPSBmdW5jdGlvbihwYXJlbnQsIG5hbWUsIG9wdGlvbnMsIGlzR3JvdXApIHtcclxuICAgICAgICAgICAgICAgIE5hbWVzcGFjZS5jYWxsKHRoaXMsIHBhcmVudCwgbmFtZSwgb3B0aW9ucyk7XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBAb3ZlcnJpZGVcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jbGFzc05hbWUgPSBcIk1lc3NhZ2VcIjtcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEV4dGVuc2lvbnMgcmFuZ2UuXHJcbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7IUFycmF5LjxudW1iZXI+fVxyXG4gICAgICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLmV4dGVuc2lvbnMgPSBbUHJvdG9CdWYuSURfTUlOLCBQcm90b0J1Zi5JRF9NQVhdO1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogUnVudGltZSBtZXNzYWdlIGNsYXNzLlxyXG4gICAgICAgICAgICAgICAgICogQHR5cGUgez9mdW5jdGlvbihuZXc6UHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlKX1cclxuICAgICAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jbGF6eiA9IG51bGw7XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBXaGV0aGVyIHRoaXMgaXMgYSBsZWdhY3kgZ3JvdXAgb3Igbm90LlxyXG4gICAgICAgICAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuaXNHcm91cCA9ICEhaXNHcm91cDtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8vIEV4dGVuZHMgTmFtZXNwYWNlXHJcbiAgICAgICAgICAgIE1lc3NhZ2UucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShOYW1lc3BhY2UucHJvdG90eXBlKTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBCdWlsZHMgdGhlIG1lc3NhZ2UgYW5kIHJldHVybnMgdGhlIHJ1bnRpbWUgY291bnRlcnBhcnQsIHdoaWNoIGlzIGEgZnVsbHkgZnVuY3Rpb25hbCBjbGFzcy5cclxuICAgICAgICAgICAgICogQHNlZSBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2VcclxuICAgICAgICAgICAgICogQHBhcmFtIHtib29sZWFuPX0gcmVidWlsZCBXaGV0aGVyIHRvIHJlYnVpbGQgb3Igbm90LCBkZWZhdWx0cyB0byBmYWxzZVxyXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHtQcm90b0J1Zi5SZWZsZWN0Lk1lc3NhZ2V9IE1lc3NhZ2UgY2xhc3NcclxuICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBtZXNzYWdlIGNhbm5vdCBiZSBidWlsdFxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBNZXNzYWdlLnByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uKHJlYnVpbGQpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNsYXp6ICYmICFyZWJ1aWxkKSByZXR1cm4gdGhpcy5jbGF6ejtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBXZSBuZWVkIHRvIGNyZWF0ZSBhIHByb3RvdHlwZWQgTWVzc2FnZSBjbGFzcyBpbiBhbiBpc29sYXRlZCBzY29wZVxyXG4gICAgICAgICAgICAgICAgdmFyIGNsYXp6ID0gKGZ1bmN0aW9uKFByb3RvQnVmLCBUKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBmaWVsZHMgPSBULmdldENoaWxkcmVuKFByb3RvQnVmLlJlZmxlY3QuTWVzc2FnZS5GaWVsZCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgcnVudGltZSBNZXNzYWdlLlxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBuYW1lIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZVxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBjbGFzcyBCYXJlYm9uZSBvZiBhbGwgcnVudGltZSBtZXNzYWdlcy5cclxuICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fC4uLltzdHJpbmddfSB2YWx1ZXMgUHJlc2V0IHZhbHVlc1xyXG4gICAgICAgICAgICAgICAgICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICAgICAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgbWVzc2FnZSBjYW5ub3QgYmUgY3JlYXRlZFxyXG4gICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBNZXNzYWdlID0gZnVuY3Rpb24odmFsdWVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZS5jYWxsKHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaSwgZmllbGQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDcmVhdGUgZmllbGRzIG9uIHRoZSBvYmplY3QgaXRzZWxmIHRvIGFsbG93IHNldHRpbmcgYW5kIGdldHRpbmcgdGhyb3VnaCBNZXNzYWdlI2ZpZWxkbmFtZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGk9MDsgaTxmaWVsZHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkID0gZmllbGRzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1tmaWVsZC5uYW1lXSA9IChmaWVsZC5yZXBlYXRlZCkgPyBbXSA6IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2V0IHRoZSBkZWZhdWx0IHZhbHVlc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGk9MDsgaTxmaWVsZHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkID0gZmllbGRzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmaWVsZC5vcHRpb25zWydkZWZhdWx0J10gIT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRzZXQoZmllbGQubmFtZSwgZmllbGQub3B0aW9uc1snZGVmYXVsdCddKTsgLy8gU2hvdWxkIG5vdCB0aHJvd1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJbSU5URVJOQUxdIFwiK2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTZXQgZmllbGQgdmFsdWVzIGZyb20gYSB2YWx1ZXMgb2JqZWN0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDEgJiYgdHlwZW9mIHZhbHVlcyA9PSAnb2JqZWN0JyAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogbm90IGFub3RoZXIgTWVzc2FnZSAqLyB0eXBlb2YgdmFsdWVzLmVuY29kZSAhPSAnZnVuY3Rpb24nICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBub3QgYSByZXBlYXRlZCBmaWVsZCAqLyAhUHJvdG9CdWYuVXRpbC5pc0FycmF5KHZhbHVlcykgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIG5vdCBhIEJ5dGVCdWZmZXIgKi8gISh2YWx1ZXMgaW5zdGFuY2VvZiBCeXRlQnVmZmVyKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogbm90IGFuIEFycmF5QnVmZmVyICovICEodmFsdWVzIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBub3QgYSBMb25nICovICEoUHJvdG9CdWYuTG9uZyAmJiB2YWx1ZXMgaW5zdGFuY2VvZiBQcm90b0J1Zi5Mb25nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpPTA7IGk8a2V5cy5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRzZXQoa2V5c1tpXSwgdmFsdWVzW2tleXNbaV1dKTsgLy8gTWF5IHRocm93XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFbHNlIHNldCBmaWVsZCB2YWx1ZXMgZnJvbSBhcmd1bWVudHMsIGluIGNvcnJlY3Qgb3JkZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGk9MDsgaTxhcmd1bWVudHMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGk8ZmllbGRzLmxlbmd0aClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kc2V0KGZpZWxkc1tpXS5uYW1lLCBhcmd1bWVudHNbaV0pOyAvLyBNYXkgdGhyb3dcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBFeHRlbmRzIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZVxyXG4gICAgICAgICAgICAgICAgICAgIE1lc3NhZ2UucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UucHJvdG90eXBlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICogQWRkcyBhIHZhbHVlIHRvIGEgcmVwZWF0ZWQgZmllbGQuXHJcbiAgICAgICAgICAgICAgICAgICAgICogQG5hbWUgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlI2FkZFxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgRmllbGQgbmFtZVxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgdG8gYWRkXHJcbiAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtib29sZWFuPX0gbm9Bc3NlcnQgV2hldGhlciB0byBhc3NlcnQgdGhlIHZhbHVlIG9yIG5vdCAoYXNzZXJ0cyBieSBkZWZhdWx0KVxyXG4gICAgICAgICAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgdmFsdWUgY2Fubm90IGJlIGFkZGVkXHJcbiAgICAgICAgICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgIE1lc3NhZ2UucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKGtleSwgdmFsdWUsIG5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmaWVsZCA9IFQuZ2V0Q2hpbGQoa2V5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFmaWVsZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKHRoaXMrXCIjXCIra2V5K1wiIGlzIHVuZGVmaW5lZFwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoZmllbGQgaW5zdGFuY2VvZiBQcm90b0J1Zi5SZWZsZWN0Lk1lc3NhZ2UuRmllbGQpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IodGhpcytcIiNcIitrZXkrXCIgaXMgbm90IGEgZmllbGQ6IFwiK2ZpZWxkLnRvU3RyaW5nKHRydWUpKTsgLy8gTWF5IHRocm93IGlmIGl0J3MgYW4gZW51bSBvciBlbWJlZGRlZCBtZXNzYWdlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZmllbGQucmVwZWF0ZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcih0aGlzK1wiI1wiK2tleStcIiBpcyBub3QgYSByZXBlYXRlZCBmaWVsZFwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXNbZmllbGQubmFtZV0gPT09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2ZpZWxkLm5hbWVdID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbZmllbGQubmFtZV0ucHVzaChub0Fzc2VydCA/IHZhbHVlIDogZmllbGQudmVyaWZ5VmFsdWUodmFsdWUsIHRydWUpKTtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAgICAgKiBBZGRzIGEgdmFsdWUgdG8gYSByZXBlYXRlZCBmaWVsZC4gVGhpcyBpcyBhbiBhbGlhcyBmb3Ige0BsaW5rIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZSNhZGR9LlxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBuYW1lIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZSMkYWRkXHJcbiAgICAgICAgICAgICAgICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBGaWVsZCBuYW1lXHJcbiAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byBhZGRcclxuICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBub0Fzc2VydCBXaGV0aGVyIHRvIGFzc2VydCB0aGUgdmFsdWUgb3Igbm90IChhc3NlcnRzIGJ5IGRlZmF1bHQpXHJcbiAgICAgICAgICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSB2YWx1ZSBjYW5ub3QgYmUgYWRkZWRcclxuICAgICAgICAgICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgTWVzc2FnZS5wcm90b3R5cGUuJGFkZCA9IE1lc3NhZ2UucHJvdG90eXBlLmFkZDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICogU2V0cyBhIGZpZWxkJ3MgdmFsdWUuXHJcbiAgICAgICAgICAgICAgICAgICAgICogQG5hbWUgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlI3NldFxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgS2V5XHJcbiAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byBzZXRcclxuICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBub0Fzc2VydCBXaGV0aGVyIHRvIGFzc2VydCB0aGUgdmFsdWUgb3Igbm90IChhc3NlcnRzIGJ5IGRlZmF1bHQpXHJcbiAgICAgICAgICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSB2YWx1ZSBjYW5ub3QgYmUgc2V0XHJcbiAgICAgICAgICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgIE1lc3NhZ2UucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKGtleSwgdmFsdWUsIG5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmaWVsZCA9IFQuZ2V0Q2hpbGQoa2V5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFmaWVsZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKHRoaXMrXCIjXCIra2V5K1wiIGlzIG5vdCBhIGZpZWxkOiB1bmRlZmluZWRcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGZpZWxkIGluc3RhbmNlb2YgUHJvdG9CdWYuUmVmbGVjdC5NZXNzYWdlLkZpZWxkKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKHRoaXMrXCIjXCIra2V5K1wiIGlzIG5vdCBhIGZpZWxkOiBcIitmaWVsZC50b1N0cmluZyh0cnVlKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbZmllbGQubmFtZV0gPSBub0Fzc2VydCA/IHZhbHVlIDogZmllbGQudmVyaWZ5VmFsdWUodmFsdWUpOyAvLyBNYXkgdGhyb3dcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAgICAgKiBTZXRzIGEgZmllbGQncyB2YWx1ZS4gVGhpcyBpcyBhbiBhbGlhcyBmb3IgW0BsaW5rIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZSNzZXR9LlxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBuYW1lIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZSMkc2V0XHJcbiAgICAgICAgICAgICAgICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBLZXlcclxuICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIHNldFxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IG5vQXNzZXJ0IFdoZXRoZXIgdG8gYXNzZXJ0IHRoZSB2YWx1ZSBvciBub3QgKGFzc2VydHMgYnkgZGVmYXVsdClcclxuICAgICAgICAgICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHZhbHVlIGNhbm5vdCBiZSBzZXRcclxuICAgICAgICAgICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgTWVzc2FnZS5wcm90b3R5cGUuJHNldCA9IE1lc3NhZ2UucHJvdG90eXBlLnNldDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICogR2V0cyBhIGZpZWxkJ3MgdmFsdWUuXHJcbiAgICAgICAgICAgICAgICAgICAgICogQG5hbWUgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlI2dldFxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgS2V5XHJcbiAgICAgICAgICAgICAgICAgICAgICogQHJldHVybiB7Kn0gVmFsdWVcclxuICAgICAgICAgICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlcmUgaXMgbm8gc3VjaCBmaWVsZFxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICBNZXNzYWdlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihrZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZpZWxkID0gVC5nZXRDaGlsZChrZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWZpZWxkIHx8ICEoZmllbGQgaW5zdGFuY2VvZiBQcm90b0J1Zi5SZWZsZWN0Lk1lc3NhZ2UuRmllbGQpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IodGhpcytcIiNcIitrZXkrXCIgaXMgbm90IGEgZmllbGQ6IHVuZGVmaW5lZFwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoZmllbGQgaW5zdGFuY2VvZiBQcm90b0J1Zi5SZWZsZWN0Lk1lc3NhZ2UuRmllbGQpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IodGhpcytcIiNcIitrZXkrXCIgaXMgbm90IGEgZmllbGQ6IFwiK2ZpZWxkLnRvU3RyaW5nKHRydWUpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbZmllbGQubmFtZV07XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICogR2V0cyBhIGZpZWxkJ3MgdmFsdWUuIFRoaXMgaXMgYW4gYWxpYXMgZm9yIHtAbGluayBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UjJGdldH0uXHJcbiAgICAgICAgICAgICAgICAgICAgICogQG5hbWUgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlIyRnZXRcclxuICAgICAgICAgICAgICAgICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IEtleVxyXG4gICAgICAgICAgICAgICAgICAgICAqIEByZXR1cm4geyp9IFZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZXJlIGlzIG5vIHN1Y2ggZmllbGRcclxuICAgICAgICAgICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgTWVzc2FnZS5wcm90b3R5cGUuJGdldCA9IE1lc3NhZ2UucHJvdG90eXBlLmdldDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gR2V0dGVycyBhbmQgc2V0dGVyc1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8ZmllbGRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmaWVsZCA9IGZpZWxkc1tpXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChmdW5jdGlvbihmaWVsZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2V0L2dldFtTb21lVmFsdWVdXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgTmFtZSA9IGZpZWxkLm9yaWdpbmFsTmFtZS5yZXBsYWNlKC8oX1thLXpBLVpdKS9nLCBmdW5jdGlvbihtYXRjaCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaC50b1VwcGVyQ2FzZSgpLnJlcGxhY2UoJ18nLCcnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTmFtZSA9IE5hbWUuc3Vic3RyaW5nKDAsMSkudG9VcHBlckNhc2UoKStOYW1lLnN1YnN0cmluZygxKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzZXQvZ2V0X1tzb21lX3ZhbHVlXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBmaWVsZC5vcmlnaW5hbE5hbWUucmVwbGFjZSgvKFtBLVpdKS9nLCBmdW5jdGlvbihtYXRjaCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIl9cIittYXRjaDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogU2V0cyBhIHZhbHVlLiBUaGlzIG1ldGhvZCBpcyBwcmVzZW50IGZvciBlYWNoIGZpZWxkLCBidXQgb25seSBpZiB0aGVyZSBpcyBubyBuYW1lIGNvbmZsaWN0IHdpdGhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIGFub3RoZXIgZmllbGQuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbmFtZSBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2Ujc2V0W1NvbWVGaWVsZF1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byBzZXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSB2YWx1ZSBjYW5ub3QgYmUgc2V0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghVC5oYXNDaGlsZChcInNldFwiK05hbWUpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1lc3NhZ2UucHJvdG90eXBlW1wic2V0XCIrTmFtZV0gPSBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRzZXQoZmllbGQubmFtZSwgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBTZXRzIGEgdmFsdWUuIFRoaXMgbWV0aG9kIGlzIHByZXNlbnQgZm9yIGVhY2ggZmllbGQsIGJ1dCBvbmx5IGlmIHRoZXJlIGlzIG5vIG5hbWUgY29uZmxpY3Qgd2l0aFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogYW5vdGhlciBmaWVsZC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBuYW1lIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZSNzZXRfW3NvbWVfZmllbGRdXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgdG8gc2V0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAYWJzdHJhY3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgdmFsdWUgY2Fubm90IGJlIHNldFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIVQuaGFzQ2hpbGQoXCJzZXRfXCIrbmFtZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWVzc2FnZS5wcm90b3R5cGVbXCJzZXRfXCIrbmFtZV0gPSBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRzZXQoZmllbGQubmFtZSwgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBHZXRzIGEgdmFsdWUuIFRoaXMgbWV0aG9kIGlzIHByZXNlbnQgZm9yIGVhY2ggZmllbGQsIGJ1dCBvbmx5IGlmIHRoZXJlIGlzIG5vIG5hbWUgY29uZmxpY3Qgd2l0aFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogYW5vdGhlciBmaWVsZC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBuYW1lIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZSNnZXRbU29tZUZpZWxkXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAYWJzdHJhY3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEByZXR1cm4geyp9IFRoZSB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIVQuaGFzQ2hpbGQoXCJnZXRcIitOYW1lKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNZXNzYWdlLnByb3RvdHlwZVtcImdldFwiK05hbWVdID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRnZXQoZmllbGQubmFtZSk7IC8vIERvZXMgbm90IHRocm93LCBmaWVsZCBleGlzdHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBHZXRzIGEgdmFsdWUuIFRoaXMgbWV0aG9kIGlzIHByZXNlbnQgZm9yIGVhY2ggZmllbGQsIGJ1dCBvbmx5IGlmIHRoZXJlIGlzIG5vIG5hbWUgY29uZmxpY3Qgd2l0aFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogYW5vdGhlciBmaWVsZC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBuYW1lIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZSNnZXRfW3NvbWVfZmllbGRdXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEByZXR1cm4geyp9IFRoZSB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGFic3RyYWN0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghVC5oYXNDaGlsZChcImdldF9cIituYW1lKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNZXNzYWdlLnByb3RvdHlwZVtcImdldF9cIituYW1lXSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kZ2V0KGZpZWxkLm5hbWUpOyAvLyBEb2VzIG5vdCB0aHJvdywgZmllbGQgZXhpc3RzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKGZpZWxkKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEVuLS9kZWNvZGluZ1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAgICAgKiBFbmNvZGVzIHRoZSBtZXNzYWdlLlxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBuYW1lIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZSMkZW5jb2RlXHJcbiAgICAgICAgICAgICAgICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHsoIUJ5dGVCdWZmZXJ8Ym9vbGVhbik9fSBidWZmZXIgQnl0ZUJ1ZmZlciB0byBlbmNvZGUgdG8uIFdpbGwgY3JlYXRlIGEgbmV3IG9uZSBhbmQgZmxpcCBpdCBpZiBvbWl0dGVkLlxyXG4gICAgICAgICAgICAgICAgICAgICAqIEByZXR1cm4geyFCeXRlQnVmZmVyfSBFbmNvZGVkIG1lc3NhZ2UgYXMgYSBCeXRlQnVmZmVyXHJcbiAgICAgICAgICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBtZXNzYWdlIGNhbm5vdCBiZSBlbmNvZGVkIG9yIGlmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZy4gVGhlIGxhdGVyIHN0aWxsXHJcbiAgICAgICAgICAgICAgICAgICAgICogIHJldHVybnMgdGhlIGVuY29kZWQgQnl0ZUJ1ZmZlciBpbiB0aGUgYGVuY29kZWRgIHByb3BlcnR5IG9uIHRoZSBlcnJvci5cclxuICAgICAgICAgICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAgICAgICAgICogQHNlZSBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UjZW5jb2RlNjRcclxuICAgICAgICAgICAgICAgICAgICAgKiBAc2VlIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZSNlbmNvZGVIZXhcclxuICAgICAgICAgICAgICAgICAgICAgKiBAc2VlIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZSNlbmNvZGVBQlxyXG4gICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgIE1lc3NhZ2UucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXNOZXcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFidWZmZXIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIgPSBuZXcgQnl0ZUJ1ZmZlcigpLCBpc05ldyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsZSA9IGJ1ZmZlci5saXR0bGVFbmRpYW47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBULmVuY29kZSh0aGlzLCBidWZmZXIuTEUoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGlzTmV3ID8gYnVmZmVyLmZsaXAoKSA6IGJ1ZmZlcikuTEUobGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIuTEUobGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3coZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAgICAgKiBDYWxjdWxhdGVzIHRoZSBieXRlIGxlbmd0aCBvZiB0aGUgbWVzc2FnZS5cclxuICAgICAgICAgICAgICAgICAgICAgKiBAbmFtZSBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UjY2FsY3VsYXRlXHJcbiAgICAgICAgICAgICAgICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICogQHJldHVybnMge251bWJlcn0gQnl0ZSBsZW5ndGhcclxuICAgICAgICAgICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIG1lc3NhZ2UgY2Fubm90IGJlIGNhbGN1bGF0ZWQgb3IgaWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nLlxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICBNZXNzYWdlLnByb3RvdHlwZS5jYWxjdWxhdGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFQuY2FsY3VsYXRlKHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAqIEVuY29kZXMgdGhlIHZhcmludDMyIGxlbmd0aC1kZWxpbWl0ZWQgbWVzc2FnZS5cclxuICAgICAgICAgICAgICAgICAgICAgKiBAbmFtZSBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UjZW5jb2RlRGVsaW1pdGVkXHJcbiAgICAgICAgICAgICAgICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHsoIUJ5dGVCdWZmZXJ8Ym9vbGVhbik9fSBidWZmZXIgQnl0ZUJ1ZmZlciB0byBlbmNvZGUgdG8uIFdpbGwgY3JlYXRlIGEgbmV3IG9uZSBhbmQgZmxpcCBpdCBpZiBvbWl0dGVkLlxyXG4gICAgICAgICAgICAgICAgICAgICAqIEByZXR1cm4geyFCeXRlQnVmZmVyfSBFbmNvZGVkIG1lc3NhZ2UgYXMgYSBCeXRlQnVmZmVyXHJcbiAgICAgICAgICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBtZXNzYWdlIGNhbm5vdCBiZSBlbmNvZGVkIG9yIGlmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZy4gVGhlIGxhdGVyIHN0aWxsXHJcbiAgICAgICAgICAgICAgICAgICAgICogIHJldHVybnMgdGhlIGVuY29kZWQgQnl0ZUJ1ZmZlciBpbiB0aGUgYGVuY29kZWRgIHByb3BlcnR5IG9uIHRoZSBlcnJvci5cclxuICAgICAgICAgICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgTWVzc2FnZS5wcm90b3R5cGUuZW5jb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24oYnVmZmVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpc05ldyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWJ1ZmZlcilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlciA9IG5ldyBCeXRlQnVmZmVyKCksIGlzTmV3ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVuYyA9IG5ldyBCeXRlQnVmZmVyKCkuTEUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgVC5lbmNvZGUodGhpcywgZW5jKS5mbGlwKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci53cml0ZVZhcmludDMyKGVuYy5yZW1haW5pbmcoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci5hcHBlbmQoZW5jKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzTmV3ID8gYnVmZmVyLmZsaXAoKSA6IGJ1ZmZlcjtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAgICAgKiBEaXJlY3RseSBlbmNvZGVzIHRoZSBtZXNzYWdlIHRvIGFuIEFycmF5QnVmZmVyLlxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBuYW1lIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZSNlbmNvZGVBQlxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAqIEByZXR1cm4ge0FycmF5QnVmZmVyfSBFbmNvZGVkIG1lc3NhZ2UgYXMgQXJyYXlCdWZmZXJcclxuICAgICAgICAgICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIG1lc3NhZ2UgY2Fubm90IGJlIGVuY29kZWQgb3IgaWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nLiBUaGUgbGF0ZXIgc3RpbGxcclxuICAgICAgICAgICAgICAgICAgICAgKiAgcmV0dXJucyB0aGUgZW5jb2RlZCBBcnJheUJ1ZmZlciBpbiB0aGUgYGVuY29kZWRgIHByb3BlcnR5IG9uIHRoZSBlcnJvci5cclxuICAgICAgICAgICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgTWVzc2FnZS5wcm90b3R5cGUuZW5jb2RlQUIgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVuY29kZSgpLnRvQXJyYXlCdWZmZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVbXCJlbmNvZGVkXCJdKSBlW1wiZW5jb2RlZFwiXSA9IGVbXCJlbmNvZGVkXCJdLnRvQXJyYXlCdWZmZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93KGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICogUmV0dXJucyB0aGUgbWVzc2FnZSBhcyBhbiBBcnJheUJ1ZmZlci4gVGhpcyBpcyBhbiBhbGlhcyBmb3Ige0BsaW5rIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZSNlbmNvZGVBQn0uXHJcbiAgICAgICAgICAgICAgICAgICAgICogQG5hbWUgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlI3RvQXJyYXlCdWZmZXJcclxuICAgICAgICAgICAgICAgICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIHtBcnJheUJ1ZmZlcn0gRW5jb2RlZCBtZXNzYWdlIGFzIEFycmF5QnVmZmVyXHJcbiAgICAgICAgICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBtZXNzYWdlIGNhbm5vdCBiZSBlbmNvZGVkIG9yIGlmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZy4gVGhlIGxhdGVyIHN0aWxsXHJcbiAgICAgICAgICAgICAgICAgICAgICogIHJldHVybnMgdGhlIGVuY29kZWQgQXJyYXlCdWZmZXIgaW4gdGhlIGBlbmNvZGVkYCBwcm9wZXJ0eSBvbiB0aGUgZXJyb3IuXHJcbiAgICAgICAgICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgIE1lc3NhZ2UucHJvdG90eXBlLnRvQXJyYXlCdWZmZXIgPSBNZXNzYWdlLnByb3RvdHlwZS5lbmNvZGVBQjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICogRGlyZWN0bHkgZW5jb2RlcyB0aGUgbWVzc2FnZSB0byBhIG5vZGUgQnVmZmVyLlxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBuYW1lIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZSNlbmNvZGVOQlxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAqIEByZXR1cm4geyFCdWZmZXJ9XHJcbiAgICAgICAgICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBtZXNzYWdlIGNhbm5vdCBiZSBlbmNvZGVkLCBub3QgcnVubmluZyB1bmRlciBub2RlLmpzIG9yIGlmIHJlcXVpcmVkIGZpZWxkcyBhcmVcclxuICAgICAgICAgICAgICAgICAgICAgKiAgbWlzc2luZy4gVGhlIGxhdGVyIHN0aWxsIHJldHVybnMgdGhlIGVuY29kZWQgbm9kZSBCdWZmZXIgaW4gdGhlIGBlbmNvZGVkYCBwcm9wZXJ0eSBvbiB0aGUgZXJyb3IuXHJcbiAgICAgICAgICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgIE1lc3NhZ2UucHJvdG90eXBlLmVuY29kZU5CID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGUoKS50b0J1ZmZlcigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZVtcImVuY29kZWRcIl0pIGVbXCJlbmNvZGVkXCJdID0gZVtcImVuY29kZWRcIl0udG9CdWZmZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93KGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICogUmV0dXJucyB0aGUgbWVzc2FnZSBhcyBhIG5vZGUgQnVmZmVyLiBUaGlzIGlzIGFuIGFsaWFzIGZvciB7QGxpbmsgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlI2VuY29kZU5CfS5cclxuICAgICAgICAgICAgICAgICAgICAgKiBAbmFtZSBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UjdG9CdWZmZXJcclxuICAgICAgICAgICAgICAgICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIHshQnVmZmVyfVxyXG4gICAgICAgICAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgbWVzc2FnZSBjYW5ub3QgYmUgZW5jb2RlZCBvciBpZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmcuIFRoZSBsYXRlciBzdGlsbFxyXG4gICAgICAgICAgICAgICAgICAgICAqICByZXR1cm5zIHRoZSBlbmNvZGVkIG5vZGUgQnVmZmVyIGluIHRoZSBgZW5jb2RlZGAgcHJvcGVydHkgb24gdGhlIGVycm9yLlxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICBNZXNzYWdlLnByb3RvdHlwZS50b0J1ZmZlciA9IE1lc3NhZ2UucHJvdG90eXBlLmVuY29kZU5CO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAgICAgKiBEaXJlY3RseSBlbmNvZGVzIHRoZSBtZXNzYWdlIHRvIGEgYmFzZTY0IGVuY29kZWQgc3RyaW5nLlxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBuYW1lIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZSNlbmNvZGU2NFxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gQmFzZTY0IGVuY29kZWQgc3RyaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSB1bmRlcmx5aW5nIGJ1ZmZlciBjYW5ub3QgYmUgZW5jb2RlZCBvciBpZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmcuIFRoZSBsYXRlclxyXG4gICAgICAgICAgICAgICAgICAgICAqICBzdGlsbCByZXR1cm5zIHRoZSBlbmNvZGVkIGJhc2U2NCBzdHJpbmcgaW4gdGhlIGBlbmNvZGVkYCBwcm9wZXJ0eSBvbiB0aGUgZXJyb3IuXHJcbiAgICAgICAgICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgIE1lc3NhZ2UucHJvdG90eXBlLmVuY29kZTY0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGUoKS50b0Jhc2U2NCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZVtcImVuY29kZWRcIl0pIGVbXCJlbmNvZGVkXCJdID0gZVtcImVuY29kZWRcIl0udG9CYXNlNjQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93KGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICogUmV0dXJucyB0aGUgbWVzc2FnZSBhcyBhIGJhc2U2NCBlbmNvZGVkIHN0cmluZy4gVGhpcyBpcyBhbiBhbGlhcyBmb3Ige0BsaW5rIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZSNlbmNvZGU2NH0uXHJcbiAgICAgICAgICAgICAgICAgICAgICogQG5hbWUgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlI3RvQmFzZTY0XHJcbiAgICAgICAgICAgICAgICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBCYXNlNjQgZW5jb2RlZCBzdHJpbmdcclxuICAgICAgICAgICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIG1lc3NhZ2UgY2Fubm90IGJlIGVuY29kZWQgb3IgaWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nLiBUaGUgbGF0ZXIgc3RpbGxcclxuICAgICAgICAgICAgICAgICAgICAgKiAgcmV0dXJucyB0aGUgZW5jb2RlZCBiYXNlNjQgc3RyaW5nIGluIHRoZSBgZW5jb2RlZGAgcHJvcGVydHkgb24gdGhlIGVycm9yLlxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICBNZXNzYWdlLnByb3RvdHlwZS50b0Jhc2U2NCA9IE1lc3NhZ2UucHJvdG90eXBlLmVuY29kZTY0O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAgICAgKiBEaXJlY3RseSBlbmNvZGVzIHRoZSBtZXNzYWdlIHRvIGEgaGV4IGVuY29kZWQgc3RyaW5nLlxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBuYW1lIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZSNlbmNvZGVIZXhcclxuICAgICAgICAgICAgICAgICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IEhleCBlbmNvZGVkIHN0cmluZ1xyXG4gICAgICAgICAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgdW5kZXJseWluZyBidWZmZXIgY2Fubm90IGJlIGVuY29kZWQgb3IgaWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nLiBUaGUgbGF0ZXJcclxuICAgICAgICAgICAgICAgICAgICAgKiAgc3RpbGwgcmV0dXJucyB0aGUgZW5jb2RlZCBoZXggc3RyaW5nIGluIHRoZSBgZW5jb2RlZGAgcHJvcGVydHkgb24gdGhlIGVycm9yLlxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICBNZXNzYWdlLnByb3RvdHlwZS5lbmNvZGVIZXggPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVuY29kZSgpLnRvSGV4KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlW1wiZW5jb2RlZFwiXSkgZVtcImVuY29kZWRcIl0gPSBlW1wiZW5jb2RlZFwiXS50b0hleCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3coZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAgICAgKiBSZXR1cm5zIHRoZSBtZXNzYWdlIGFzIGEgaGV4IGVuY29kZWQgc3RyaW5nLiBUaGlzIGlzIGFuIGFsaWFzIGZvciB7QGxpbmsgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlI2VuY29kZUhleH0uXHJcbiAgICAgICAgICAgICAgICAgICAgICogQG5hbWUgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlI3RvSGV4XHJcbiAgICAgICAgICAgICAgICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBIZXggZW5jb2RlZCBzdHJpbmdcclxuICAgICAgICAgICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIG1lc3NhZ2UgY2Fubm90IGJlIGVuY29kZWQgb3IgaWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nLiBUaGUgbGF0ZXIgc3RpbGxcclxuICAgICAgICAgICAgICAgICAgICAgKiAgcmV0dXJucyB0aGUgZW5jb2RlZCBoZXggc3RyaW5nIGluIHRoZSBgZW5jb2RlZGAgcHJvcGVydHkgb24gdGhlIGVycm9yLlxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICBNZXNzYWdlLnByb3RvdHlwZS50b0hleCA9IE1lc3NhZ2UucHJvdG90eXBlLmVuY29kZUhleDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICogQ2xvbmVzIGEgbWVzc2FnZSBvYmplY3QgdG8gYSByYXcgb2JqZWN0LlxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7Kn0gb2JqIE9iamVjdCB0byBjbG9uZVxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5jbHVkZUJ1ZmZlcnMgV2hldGhlciB0byBpbmNsdWRlIG5hdGl2ZSBidWZmZXIgZGF0YSBvciBub3RcclxuICAgICAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7Kn0gQ2xvbmVkIG9iamVjdFxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBpbm5lclxyXG4gICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGNsb25lUmF3KG9iaiwgaW5jbHVkZUJ1ZmZlcnMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNsb25lID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgaW4gb2JqKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvYmpbaV0gPT09IG51bGwgfHwgdHlwZW9mIG9ialtpXSAhPT0gJ29iamVjdCcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb25lW2ldID0gb2JqW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9ialtpXSBpbnN0YW5jZW9mIEJ5dGVCdWZmZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluY2x1ZGVCdWZmZXJzKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvbmVbaV0gPSBvYmoudG9CdWZmZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgLy8gaXMgYSBub24tbnVsbCBvYmplY3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvbmVbaV0gPSBjbG9uZVJhdyhvYmpbaV0sIGluY2x1ZGVCdWZmZXJzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNsb25lO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICogUmV0dXJucyB0aGUgbWVzc2FnZSdzIHJhdyBwYXlsb2FkLlxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IGluY2x1ZGVCdWZmZXJzIFdoZXRoZXIgdG8gaW5jbHVkZSBuYXRpdmUgYnVmZmVyIGRhdGEgb3Igbm90LCBkZWZhdWx0cyB0byBgZmFsc2VgXHJcbiAgICAgICAgICAgICAgICAgICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBSYXcgcGF5bG9hZFxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICBNZXNzYWdlLnByb3RvdHlwZS50b1JhdyA9IGZ1bmN0aW9uKGluY2x1ZGVCdWZmZXJzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjbG9uZVJhdyh0aGlzLCAhIWluY2x1ZGVCdWZmZXJzKTtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAgICAgKiBEZWNvZGVzIGEgbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgYnVmZmVyIG9yIHN0cmluZy5cclxuICAgICAgICAgICAgICAgICAgICAgKiBAbmFtZSBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UuZGVjb2RlXHJcbiAgICAgICAgICAgICAgICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHshQnl0ZUJ1ZmZlcnwhQXJyYXlCdWZmZXJ8IUJ1ZmZlcnxzdHJpbmd9IGJ1ZmZlciBCdWZmZXIgdG8gZGVjb2RlIGZyb21cclxuICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZz19IGVuYyBFbmNvZGluZyBpZiBidWZmZXIgaXMgYSBzdHJpbmc6IGhleCwgdXRmOCAobm90IHJlY29tbWVuZGVkKSwgZGVmYXVsdHMgdG8gYmFzZTY0XHJcbiAgICAgICAgICAgICAgICAgICAgICogQHJldHVybiB7IVByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZX0gRGVjb2RlZCBtZXNzYWdlXHJcbiAgICAgICAgICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBtZXNzYWdlIGNhbm5vdCBiZSBkZWNvZGVkIG9yIGlmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZy4gVGhlIGxhdGVyIHN0aWxsXHJcbiAgICAgICAgICAgICAgICAgICAgICogIHJldHVybnMgdGhlIGRlY29kZWQgbWVzc2FnZSB3aXRoIG1pc3NpbmcgZmllbGRzIGluIHRoZSBgZGVjb2RlZGAgcHJvcGVydHkgb24gdGhlIGVycm9yLlxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICAgICAgICAgKiBAc2VlIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZS5kZWNvZGU2NFxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBzZWUgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlLmRlY29kZUhleFxyXG4gICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgIE1lc3NhZ2UuZGVjb2RlID0gZnVuY3Rpb24oYnVmZmVyLCBlbmMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBidWZmZXIgPT09ICdzdHJpbmcnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyID0gQnl0ZUJ1ZmZlci53cmFwKGJ1ZmZlciwgZW5jID8gZW5jIDogXCJiYXNlNjRcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlciA9IGJ1ZmZlciBpbnN0YW5jZW9mIEJ5dGVCdWZmZXIgPyBidWZmZXIgOiBCeXRlQnVmZmVyLndyYXAoYnVmZmVyKTsgLy8gTWF5IHRocm93XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsZSA9IGJ1ZmZlci5saXR0bGVFbmRpYW47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbXNnID0gVC5kZWNvZGUoYnVmZmVyLkxFKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLkxFKGxlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtc2c7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci5MRShsZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyhlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAqIERlY29kZXMgYSB2YXJpbnQzMiBsZW5ndGgtZGVsaW1pdGVkIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIGJ1ZmZlciBvciBzdHJpbmcuXHJcbiAgICAgICAgICAgICAgICAgICAgICogQG5hbWUgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlLmRlY29kZURlbGltaXRlZFxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7IUJ5dGVCdWZmZXJ8IUFycmF5QnVmZmVyfCFCdWZmZXJ8c3RyaW5nfSBidWZmZXIgQnVmZmVyIHRvIGRlY29kZSBmcm9tXHJcbiAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmc9fSBlbmMgRW5jb2RpbmcgaWYgYnVmZmVyIGlzIGEgc3RyaW5nOiBoZXgsIHV0ZjggKG5vdCByZWNvbW1lbmRlZCksIGRlZmF1bHRzIHRvIGJhc2U2NFxyXG4gICAgICAgICAgICAgICAgICAgICAqIEByZXR1cm4geyFQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2V9IERlY29kZWQgbWVzc2FnZVxyXG4gICAgICAgICAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgbWVzc2FnZSBjYW5ub3QgYmUgZGVjb2RlZCBvciBpZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmcuIFRoZSBsYXRlciBzdGlsbFxyXG4gICAgICAgICAgICAgICAgICAgICAqICByZXR1cm5zIHRoZSBkZWNvZGVkIG1lc3NhZ2Ugd2l0aCBtaXNzaW5nIGZpZWxkcyBpbiB0aGUgYGRlY29kZWRgIHByb3BlcnR5IG9uIHRoZSBlcnJvci5cclxuICAgICAgICAgICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgTWVzc2FnZS5kZWNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbihidWZmZXIsIGVuYykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGJ1ZmZlciA9PT0gJ3N0cmluZycpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIgPSBCeXRlQnVmZmVyLndyYXAoYnVmZmVyLCBlbmMgPyBlbmMgOiBcImJhc2U2NFwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyID0gYnVmZmVyIGluc3RhbmNlb2YgQnl0ZUJ1ZmZlciA/IGJ1ZmZlciA6IEJ5dGVCdWZmZXIud3JhcChidWZmZXIpOyAvLyBNYXkgdGhyb3dcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxlbiA9IGJ1ZmZlci5yZWFkVmFyaW50MzIoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1zZyA9IFQuZGVjb2RlKGJ1ZmZlci5zbGljZShidWZmZXIub2Zmc2V0LCBidWZmZXIub2Zmc2V0ICsgbGVuKS5MRSgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLm9mZnNldCArPSBsZW47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtc2c7XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICogRGVjb2RlcyB0aGUgbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgYmFzZTY0IGVuY29kZWQgc3RyaW5nLlxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBuYW1lIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZS5kZWNvZGU2NFxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgU3RyaW5nIHRvIGRlY29kZSBmcm9tXHJcbiAgICAgICAgICAgICAgICAgICAgICogQHJldHVybiB7IVByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZX0gRGVjb2RlZCBtZXNzYWdlXHJcbiAgICAgICAgICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBtZXNzYWdlIGNhbm5vdCBiZSBkZWNvZGVkIG9yIGlmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZy4gVGhlIGxhdGVyIHN0aWxsXHJcbiAgICAgICAgICAgICAgICAgICAgICogIHJldHVybnMgdGhlIGRlY29kZWQgbWVzc2FnZSB3aXRoIG1pc3NpbmcgZmllbGRzIGluIHRoZSBgZGVjb2RlZGAgcHJvcGVydHkgb24gdGhlIGVycm9yLlxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICBNZXNzYWdlLmRlY29kZTY0ID0gZnVuY3Rpb24oc3RyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBNZXNzYWdlLmRlY29kZShzdHIsIFwiYmFzZTY0XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAqIERlY29kZXMgdGhlIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIGhleCBlbmNvZGVkIHN0cmluZy5cclxuICAgICAgICAgICAgICAgICAgICAgKiBAbmFtZSBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UuZGVjb2RlSGV4XHJcbiAgICAgICAgICAgICAgICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciBTdHJpbmcgdG8gZGVjb2RlIGZyb21cclxuICAgICAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIHshUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlfSBEZWNvZGVkIG1lc3NhZ2VcclxuICAgICAgICAgICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIG1lc3NhZ2UgY2Fubm90IGJlIGRlY29kZWQgb3IgaWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nLiBUaGUgbGF0ZXIgc3RpbGxcclxuICAgICAgICAgICAgICAgICAgICAgKiAgcmV0dXJucyB0aGUgZGVjb2RlZCBtZXNzYWdlIHdpdGggbWlzc2luZyBmaWVsZHMgaW4gdGhlIGBkZWNvZGVkYCBwcm9wZXJ0eSBvbiB0aGUgZXJyb3IuXHJcbiAgICAgICAgICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgIE1lc3NhZ2UuZGVjb2RlSGV4ID0gZnVuY3Rpb24oc3RyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBNZXNzYWdlLmRlY29kZShzdHIsIFwiaGV4XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFV0aWxpdHlcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIE1lc3NhZ2UuXHJcbiAgICAgICAgICAgICAgICAgICAgICogQG5hbWUgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlI3RvU3RyaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBTdHJpbmcgcmVwcmVzZW50YXRpb24gYXMgb2YgXCIuRnVsbHkuUXVhbGlmaWVkLk1lc3NhZ2VOYW1lXCJcclxuICAgICAgICAgICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgTWVzc2FnZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFQudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBTdGF0aWNcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICogT3B0aW9ucy5cclxuICAgICAgICAgICAgICAgICAgICAgKiBAbmFtZSBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UuJG9wdGlvbnNcclxuICAgICAgICAgICAgICAgICAgICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsKj59XHJcbiAgICAgICAgICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciAkb3B0aW9uczsgLy8gZm9yIGNjXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZXNzYWdlLCAnJG9wdGlvbnMnLCB7IFwidmFsdWVcIjogVC5idWlsZE9wdCgpIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTWVzc2FnZTtcclxuXHJcbiAgICAgICAgICAgICAgICB9KShQcm90b0J1ZiwgdGhpcyk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gU3RhdGljIGVudW1zIGFuZCBwcm90b3R5cGVkIHN1Yi1tZXNzYWdlc1xyXG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5nZXRDaGlsZHJlbigpO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpPGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkcmVuW2ldIGluc3RhbmNlb2YgRW51bSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhenpbY2hpbGRyZW5baV1bJ25hbWUnXV0gPSBjaGlsZHJlbltpXS5idWlsZCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNoaWxkcmVuW2ldIGluc3RhbmNlb2YgTWVzc2FnZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhenpbY2hpbGRyZW5baV1bJ25hbWUnXV0gPSBjaGlsZHJlbltpXS5idWlsZCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNoaWxkcmVuW2ldIGluc3RhbmNlb2YgTWVzc2FnZS5GaWVsZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZ25vcmVcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIHJlZmxlY3QgY2hpbGQgb2YgXCIrdGhpcy50b1N0cmluZyh0cnVlKStcIjogXCIrY2hpbGRyZW5baV0udG9TdHJpbmcodHJ1ZSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xhenogPSBjbGF6ejtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBFbmNvZGVzIGEgcnVudGltZSBtZXNzYWdlJ3MgY29udGVudHMgdG8gdGhlIHNwZWNpZmllZCBidWZmZXIuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7IVByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZX0gbWVzc2FnZSBSdW50aW1lIG1lc3NhZ2UgdG8gZW5jb2RlXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7Qnl0ZUJ1ZmZlcn0gYnVmZmVyIEJ5dGVCdWZmZXIgdG8gd3JpdGUgdG9cclxuICAgICAgICAgICAgICogQHJldHVybiB7Qnl0ZUJ1ZmZlcn0gVGhlIEJ5dGVCdWZmZXIgZm9yIGNoYWluaW5nXHJcbiAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3Npbmcgb3IgdGhlIG1lc3NhZ2UgY2Fubm90IGJlIGVuY29kZWQgZm9yIGFub3RoZXIgcmVhc29uXHJcbiAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIE1lc3NhZ2UucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uKG1lc3NhZ2UsIGJ1ZmZlcikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGZpZWxkcyA9IHRoaXMuZ2V0Q2hpbGRyZW4oTWVzc2FnZS5GaWVsZCksXHJcbiAgICAgICAgICAgICAgICAgICAgZmllbGRNaXNzaW5nID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGk9MCwgdmFsOyBpPGZpZWxkcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IG1lc3NhZ2UuJGdldChmaWVsZHNbaV0ubmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpZWxkc1tpXS5yZXF1aXJlZCAmJiB2YWwgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpZWxkTWlzc2luZyA9PT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkTWlzc2luZyA9IGZpZWxkc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmllbGRzW2ldLmVuY29kZSh2YWwsIGJ1ZmZlcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoZmllbGRNaXNzaW5nICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVyciA9IEVycm9yKFwiTWlzc2luZyBhdCBsZWFzdCBvbmUgcmVxdWlyZWQgZmllbGQgZm9yIFwiK3RoaXMudG9TdHJpbmcodHJ1ZSkrXCI6IFwiK2ZpZWxkTWlzc2luZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgZXJyW1wiZW5jb2RlZFwiXSA9IGJ1ZmZlcjsgLy8gU3RpbGwgZXhwb3NlIHdoYXQgd2UgZ290XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3coZXJyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBidWZmZXI7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQ2FsY3VsYXRlcyBhIHJ1bnRpbWUgbWVzc2FnZSdzIGJ5dGUgbGVuZ3RoLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0geyFQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2V9IG1lc3NhZ2UgUnVudGltZSBtZXNzYWdlIHRvIGVuY29kZVxyXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBCeXRlIGxlbmd0aFxyXG4gICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nIG9yIHRoZSBtZXNzYWdlIGNhbm5vdCBiZSBjYWxjdWxhdGVkIGZvciBhbm90aGVyIHJlYXNvblxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBNZXNzYWdlLnByb3RvdHlwZS5jYWxjdWxhdGUgPSBmdW5jdGlvbihtZXNzYWdlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZmllbGRzID0gdGhpcy5nZXRDaGlsZHJlbihNZXNzYWdlLkZpZWxkKSxcclxuICAgICAgICAgICAgICAgICAgICBuID0gMDtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGk9MCwgdmFsOyBpPGZpZWxkcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IG1lc3NhZ2UuJGdldChmaWVsZHNbaV0ubmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpZWxkc1tpXS5yZXF1aXJlZCAmJiB2YWwgPT09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJNaXNzaW5nIGF0IGxlYXN0IG9uZSByZXF1aXJlZCBmaWVsZCBmb3IgXCIrdGhpcy50b1N0cmluZyh0cnVlKStcIjogXCIrZmllbGRzW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG4gKz0gZmllbGRzW2ldLmNhbGN1bGF0ZSh2YWwpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG47XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogU2tpcHMgYWxsIGRhdGEgdW50aWwgdGhlIGVuZCBvZiB0aGUgc3BlY2lmaWVkIGdyb3VwIGhhcyBiZWVuIHJlYWNoZWQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBleHBlY3RlZElkIEV4cGVjdGVkIEdST1VQRU5EIGlkXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7IUJ5dGVCdWZmZXJ9IGJ1ZiBCeXRlQnVmZmVyXHJcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgYSB2YWx1ZSBhcyBiZWVuIHNraXBwZWQsIGBmYWxzZWAgaWYgdGhlIGVuZCBoYXMgYmVlbiByZWFjaGVkXHJcbiAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiBpdCB3YXNuJ3QgcG9zc2libGUgdG8gZmluZCB0aGUgZW5kIG9mIHRoZSBncm91cCAoYnVmZmVyIG92ZXJydW4gb3IgZW5kIHRhZyBtaXNtYXRjaClcclxuICAgICAgICAgICAgICogQGlubmVyXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBza2lwVGlsbEdyb3VwRW5kKGV4cGVjdGVkSWQsIGJ1Zikge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRhZyA9IGJ1Zi5yZWFkVmFyaW50MzIoKSwgLy8gVGhyb3dzIG9uIE9PQlxyXG4gICAgICAgICAgICAgICAgICAgIHdpcmVUeXBlID0gdGFnICYgMHgwNyxcclxuICAgICAgICAgICAgICAgICAgICBpZCA9IHRhZyA+PiAzO1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoICh3aXJlVHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuV0lSRV9UWVBFUy5WQVJJTlQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvIHRhZyA9IGJ1Zi5yZWFkVWludDgoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCh0YWcgJiAweDgwKSA9PT0gMHg4MCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuV0lSRV9UWVBFUy5CSVRTNjQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1Zi5vZmZzZXQgKz0gODtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5XSVJFX1RZUEVTLkxERUxJTTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFnID0gYnVmLnJlYWRWYXJpbnQzMigpOyAvLyByZWFkcyB0aGUgdmFyaW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1Zi5vZmZzZXQgKz0gdGFnOyAgICAgICAgLy8gc2tpcHMgbiBieXRlc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLldJUkVfVFlQRVMuU1RBUlRHUk9VUDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2tpcFRpbGxHcm91cEVuZChpZCwgYnVmKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5XSVJFX1RZUEVTLkVOREdST1VQOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaWQgPT09IGV4cGVjdGVkSWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCBHUk9VUEVORCBhZnRlciB1bmtub3duIGdyb3VwOiBcIitpZCtcIiAoXCIrZXhwZWN0ZWRJZCtcIiBleHBlY3RlZClcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5XSVJFX1RZUEVTLkJJVFMzMjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmLm9mZnNldCArPSA0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIklsbGVnYWwgd2lyZSB0eXBlIGluIHVua25vd24gZ3JvdXAgXCIrZXhwZWN0ZWRJZCtcIjogXCIrd2lyZVR5cGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBEZWNvZGVzIGFuIGVuY29kZWQgbWVzc2FnZSBhbmQgcmV0dXJucyB0aGUgZGVjb2RlZCBtZXNzYWdlLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0J5dGVCdWZmZXJ9IGJ1ZmZlciBCeXRlQnVmZmVyIHRvIGRlY29kZSBmcm9tXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gbGVuZ3RoIE1lc3NhZ2UgbGVuZ3RoLiBEZWZhdWx0cyB0byBkZWNvZGUgYWxsIHRoZSBhdmFpbGFibGUgZGF0YS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXI9fSBleHBlY3RlZEdyb3VwRW5kSWQgRXhwZWN0ZWQgR1JPVVBFTkQgaWQgaWYgdGhpcyBpcyBhIGxlZ2FjeSBncm91cFxyXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHtQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2V9IERlY29kZWQgbWVzc2FnZVxyXG4gICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIG1lc3NhZ2UgY2Fubm90IGJlIGRlY29kZWRcclxuICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgTWVzc2FnZS5wcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24oYnVmZmVyLCBsZW5ndGgsIGV4cGVjdGVkR3JvdXBFbmRJZCkge1xyXG4gICAgICAgICAgICAgICAgbGVuZ3RoID0gdHlwZW9mIGxlbmd0aCA9PT0gJ251bWJlcicgPyBsZW5ndGggOiAtMTtcclxuICAgICAgICAgICAgICAgIHZhciBzdGFydCA9IGJ1ZmZlci5vZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgbXNnID0gbmV3ICh0aGlzLmNsYXp6KSgpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHRhZywgd2lyZVR5cGUsIGlkO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGJ1ZmZlci5vZmZzZXQgPCBzdGFydCtsZW5ndGggfHwgKGxlbmd0aCA9PSAtMSAmJiBidWZmZXIucmVtYWluaW5nKCkgPiAwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRhZyA9IGJ1ZmZlci5yZWFkVmFyaW50MzIoKTtcclxuICAgICAgICAgICAgICAgICAgICB3aXJlVHlwZSA9IHRhZyAmIDB4MDc7XHJcbiAgICAgICAgICAgICAgICAgICAgaWQgPSB0YWcgPj4gMztcclxuICAgICAgICAgICAgICAgICAgICBpZiAod2lyZVR5cGUgPT09IFByb3RvQnVmLldJUkVfVFlQRVMuRU5ER1JPVVApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlkICE9PSBleHBlY3RlZEdyb3VwRW5kSWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIklsbGVnYWwgZ3JvdXAgZW5kIGluZGljYXRvciBmb3IgXCIrdGhpcy50b1N0cmluZyh0cnVlKStcIjogXCIraWQrXCIgKFwiKyhleHBlY3RlZEdyb3VwRW5kSWQgPyBleHBlY3RlZEdyb3VwRW5kSWQrXCIgZXhwZWN0ZWRcIiA6IFwibm90IGEgZ3JvdXBcIikrXCIpXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZpZWxkID0gdGhpcy5nZXRDaGlsZChpZCk7IC8vIE1lc3NhZ2UuRmllbGQgb25seVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghZmllbGQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gXCJtZXNzYWdlcyBjcmVhdGVkIGJ5IHlvdXIgbmV3IGNvZGUgY2FuIGJlIHBhcnNlZCBieSB5b3VyIG9sZCBjb2RlOiBvbGQgYmluYXJpZXMgc2ltcGx5IGlnbm9yZSB0aGUgbmV3IGZpZWxkIHdoZW4gcGFyc2luZy5cIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHdpcmVUeXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLldJUkVfVFlQRVMuVkFSSU5UOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci5yZWFkVmFyaW50MzIoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuV0lSRV9UWVBFUy5CSVRTMzI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLm9mZnNldCArPSA0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5XSVJFX1RZUEVTLkJJVFM2NDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIub2Zmc2V0ICs9IDg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLldJUkVfVFlQRVMuTERFTElNOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsZW4gPSBidWZmZXIucmVhZFZhcmludDMyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLm9mZnNldCArPSBsZW47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLldJUkVfVFlQRVMuU1RBUlRHUk9VUDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoc2tpcFRpbGxHcm91cEVuZChpZCwgYnVmZmVyKSkge31cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIHdpcmUgdHlwZSBmb3IgdW5rbm93biBmaWVsZCBcIitpZCtcIiBpbiBcIit0aGlzLnRvU3RyaW5nKHRydWUpK1wiI2RlY29kZTogXCIrd2lyZVR5cGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoZmllbGQucmVwZWF0ZWQgJiYgIWZpZWxkLm9wdGlvbnNbXCJwYWNrZWRcIl0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1zZy4kYWRkKGZpZWxkLm5hbWUsIGZpZWxkLmRlY29kZSh3aXJlVHlwZSwgYnVmZmVyKSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtc2cuJHNldChmaWVsZC5uYW1lLCBmaWVsZC5kZWNvZGUod2lyZVR5cGUsIGJ1ZmZlciksIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIGFsbCByZXF1aXJlZCBmaWVsZHMgYXJlIHByZXNlbnRcclxuICAgICAgICAgICAgICAgIHZhciBmaWVsZHMgPSB0aGlzLmdldENoaWxkcmVuKFByb3RvQnVmLlJlZmxlY3QuRmllbGQpO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpPGZpZWxkcy5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZmllbGRzW2ldLnJlcXVpcmVkICYmIG1zZ1tmaWVsZHNbaV0ubmFtZV0gPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVyciA9IEVycm9yKFwiTWlzc2luZyBhdCBsZWFzdCBvbmUgcmVxdWlyZWQgZmllbGQgZm9yIFwiK3RoaXMudG9TdHJpbmcodHJ1ZSkrXCI6IFwiK2ZpZWxkc1tpXS5uYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyW1wiZGVjb2RlZFwiXSA9IG1zZzsgLy8gU3RpbGwgZXhwb3NlIHdoYXQgd2UgZ290XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93KGVycik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1zZztcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBAYWxpYXMgUHJvdG9CdWYuUmVmbGVjdC5NZXNzYWdlXHJcbiAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFJlZmxlY3QuTWVzc2FnZSA9IE1lc3NhZ2U7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQ29uc3RydWN0cyBhIG5ldyBNZXNzYWdlIEZpZWxkLlxyXG4gICAgICAgICAgICAgKiBAZXhwb3J0cyBQcm90b0J1Zi5SZWZsZWN0Lk1lc3NhZ2UuRmllbGRcclxuICAgICAgICAgICAgICogQHBhcmFtIHtQcm90b0J1Zi5SZWZsZWN0Lk1lc3NhZ2V9IG1lc3NhZ2UgTWVzc2FnZSByZWZlcmVuY2VcclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHJ1bGUgUnVsZSwgb25lIG9mIHJlcXVyaWVkLCBvcHRpb25hbCwgcmVwZWF0ZWRcclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgRGF0YSB0eXBlLCBlLmcuIGludDMyXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIEZpZWxkIG5hbWVcclxuICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGlkIFVuaXF1ZSBmaWVsZCBpZFxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLio+PX0gb3B0aW9ucyBPcHRpb25zXHJcbiAgICAgICAgICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICAgICAgICAgKiBAZXh0ZW5kcyBQcm90b0J1Zi5SZWZsZWN0LlRcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHZhciBGaWVsZCA9IGZ1bmN0aW9uKG1lc3NhZ2UsIHJ1bGUsIHR5cGUsIG5hbWUsIGlkLCBvcHRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICBULmNhbGwodGhpcywgbWVzc2FnZSwgbmFtZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBAb3ZlcnJpZGVcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jbGFzc05hbWUgPSBcIk1lc3NhZ2UuRmllbGRcIjtcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIE1lc3NhZ2UgZmllbGQgcmVxdWlyZWQgZmxhZy5cclxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlcXVpcmVkID0gcnVsZSA9PSBcInJlcXVpcmVkXCI7XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBNZXNzYWdlIGZpZWxkIHJlcGVhdGVkIGZsYWcuXHJcbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZXBlYXRlZCA9IHJ1bGUgPT0gXCJyZXBlYXRlZFwiO1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogTWVzc2FnZSBmaWVsZCB0eXBlLiBUeXBlIHJlZmVyZW5jZSBzdHJpbmcgaWYgdW5yZXNvbHZlZCwgcHJvdG9idWYgdHlwZSBpZiByZXNvbHZlZC5cclxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtzdHJpbmd8e25hbWU6IHN0cmluZywgd2lyZVR5cGU6IG51bWJlcn19XHJcbiAgICAgICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBSZXNvbHZlZCB0eXBlIHJlZmVyZW5jZSBpbnNpZGUgdGhlIGdsb2JhbCBuYW1lc3BhY2UuXHJcbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7UHJvdG9CdWYuUmVmbGVjdC5UfG51bGx9XHJcbiAgICAgICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMucmVzb2x2ZWRUeXBlID0gbnVsbDtcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFVuaXF1ZSBtZXNzYWdlIGZpZWxkIGlkLlxyXG4gICAgICAgICAgICAgICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pZCA9IGlkO1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogTWVzc2FnZSBmaWVsZCBvcHRpb25zLlxyXG4gICAgICAgICAgICAgICAgICogQHR5cGUgeyFPYmplY3QuPHN0cmluZywqPn1cclxuICAgICAgICAgICAgICAgICAqIEBkaWN0XHJcbiAgICAgICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBPcmlnaW5hbCBmaWVsZCBuYW1lLlxyXG4gICAgICAgICAgICAgICAgICogQHR5cGUge3N0cmluZ31cclxuICAgICAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vcmlnaW5hbE5hbWUgPSB0aGlzLm5hbWU7IC8vIFVzZWQgdG8gcmV2ZXJ0IGNhbWVsY2FzZSB0cmFuc2Zvcm1hdGlvbiBvbiBuYW1pbmcgY29sbGlzaW9uc1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgZmllbGQgbmFtZXMgdG8gY2FtZWwgY2FzZSBub3RhdGlvbiBpZiB0aGUgb3ZlcnJpZGUgaXMgc2V0XHJcbiAgICAgICAgICAgICAgICBpZiAoUHJvdG9CdWYuY29udmVydEZpZWxkc1RvQ2FtZWxDYXNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uYW1lID0gdGhpcy5uYW1lLnJlcGxhY2UoL18oW2EtekEtWl0pL2csIGZ1bmN0aW9uKCQwLCAkMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJDEudG9VcHBlckNhc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8vIEV4dGVuZHMgVFxyXG4gICAgICAgICAgICBGaWVsZC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFQucHJvdG90eXBlKTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBNYWtlcyBhIExvbmcgZnJvbSBhIHZhbHVlLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3tsb3c6IG51bWJlciwgaGlnaDogbnVtYmVyLCB1bnNpZ25lZDogYm9vbGVhbn18c3RyaW5nfG51bWJlcn0gdmFsdWUgVmFsdWVcclxuICAgICAgICAgICAgICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QsIGRlZmF1bHRzIHRvIHJldXNlIGl0IGZyb20gTG9uZy1saWtlIG9iamVjdHMgb3IgdG8gc2lnbmVkIGZvclxyXG4gICAgICAgICAgICAgKiAgc3RyaW5ncyBhbmQgbnVtYmVyc1xyXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7IUxvbmd9XHJcbiAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgdmFsdWUgY2Fubm90IGJlIGNvbnZlcnRlZCB0byBhIExvbmdcclxuICAgICAgICAgICAgICogQGlubmVyXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBta0xvbmcodmFsdWUsIHVuc2lnbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlLmxvdyA9PT0gJ251bWJlcicgJiYgdHlwZW9mIHZhbHVlLmhpZ2ggPT09ICdudW1iZXInICYmIHR5cGVvZiB2YWx1ZS51bnNpZ25lZCA9PT0gJ2Jvb2xlYW4nXHJcbiAgICAgICAgICAgICAgICAgICAgJiYgdmFsdWUubG93ID09PSB2YWx1ZS5sb3cgJiYgdmFsdWUuaGlnaCA9PT0gdmFsdWUuaGlnaClcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb3RvQnVmLkxvbmcodmFsdWUubG93LCB2YWx1ZS5oaWdoLCB0eXBlb2YgdW5zaWduZWQgPT09ICd1bmRlZmluZWQnID8gdmFsdWUudW5zaWduZWQgOiB1bnNpZ25lZCk7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJylcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvdG9CdWYuTG9uZy5mcm9tU3RyaW5nKHZhbHVlLCB1bnNpZ25lZCB8fCBmYWxzZSwgMTApO1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb3RvQnVmLkxvbmcuZnJvbU51bWJlcih2YWx1ZSwgdW5zaWduZWQgfHwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJub3QgY29udmVydGlibGUgdG8gTG9uZ1wiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gdmFsdWUgY2FuIGJlIHNldCBmb3IgdGhpcyBmaWVsZC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byBjaGVja1xyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBza2lwUmVwZWF0ZWQgV2hldGhlciB0byBza2lwIHRoZSByZXBlYXRlZCB2YWx1ZSBjaGVjayBvciBub3QuIERlZmF1bHRzIHRvIGZhbHNlLlxyXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHsqfSBWZXJpZmllZCwgbWF5YmUgYWRqdXN0ZWQsIHZhbHVlXHJcbiAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgdmFsdWUgY2Fubm90IGJlIHNldCBmb3IgdGhpcyBmaWVsZFxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBGaWVsZC5wcm90b3R5cGUudmVyaWZ5VmFsdWUgPSBmdW5jdGlvbih2YWx1ZSwgc2tpcFJlcGVhdGVkKSB7XHJcbiAgICAgICAgICAgICAgICBza2lwUmVwZWF0ZWQgPSBza2lwUmVwZWF0ZWQgfHwgZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB2YXIgZmFpbCA9IGZ1bmN0aW9uKHZhbCwgbXNnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIHZhbHVlIGZvciBcIit0aGlzLnRvU3RyaW5nKHRydWUpK1wiIG9mIHR5cGUgXCIrdGhpcy50eXBlLm5hbWUrXCI6IFwiK3ZhbCtcIiAoXCIrbXNnK1wiKVwiKTtcclxuICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKTtcclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkgeyAvLyBOVUxMIHZhbHVlcyBmb3Igb3B0aW9uYWwgZmllbGRzXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucmVxdWlyZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhaWwodHlwZW9mIHZhbHVlLCBcInJlcXVpcmVkXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZXBlYXRlZCAmJiAhc2tpcFJlcGVhdGVkKSB7IC8vIFJlcGVhdGVkIHZhbHVlcyBhcyBhcnJheXNcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIVByb3RvQnVmLlV0aWwuaXNBcnJheSh2YWx1ZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gW3ZhbHVlXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpPTA7IGk8dmFsdWUubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcy5wdXNoKHRoaXMudmVyaWZ5VmFsdWUodmFsdWVbaV0sIHRydWUpKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gQWxsIG5vbi1yZXBlYXRlZCBmaWVsZHMgZXhwZWN0IG5vIGFycmF5XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMucmVwZWF0ZWQgJiYgUHJvdG9CdWYuVXRpbC5pc0FycmF5KHZhbHVlKSlcclxuICAgICAgICAgICAgICAgICAgICBmYWlsKHR5cGVvZiB2YWx1ZSwgXCJubyBhcnJheSBleHBlY3RlZFwiKTtcclxuXHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFNpZ25lZCAzMmJpdFxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJpbnQzMlwiXTpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wic2ludDMyXCJdOlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJzZml4ZWQzMlwiXTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWNjb3VudCBmb3IgIU5hTjogdmFsdWUgPT09IHZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInIHx8ICh2YWx1ZSA9PT0gdmFsdWUgJiYgdmFsdWUgJSAxICE9PSAwKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhaWwodHlwZW9mIHZhbHVlLCBcIm5vdCBhbiBpbnRlZ2VyXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgPiA0Mjk0OTY3Mjk1ID8gdmFsdWUgfCAwIDogdmFsdWU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFVuc2lnbmVkIDMyYml0XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInVpbnQzMlwiXTpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiZml4ZWQzMlwiXTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicgfHwgKHZhbHVlID09PSB2YWx1ZSAmJiB2YWx1ZSAlIDEgIT09IDApKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFpbCh0eXBlb2YgdmFsdWUsIFwibm90IGFuIGludGVnZXJcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSA8IDAgPyB2YWx1ZSA+Pj4gMCA6IHZhbHVlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBTaWduZWQgNjRiaXRcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiaW50NjRcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInNpbnQ2NFwiXTpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wic2ZpeGVkNjRcIl06IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFByb3RvQnVmLkxvbmcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBta0xvbmcodmFsdWUsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWlsKHR5cGVvZiB2YWx1ZSwgZS5tZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFpbCh0eXBlb2YgdmFsdWUsIFwicmVxdWlyZXMgTG9uZy5qc1wiKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFVuc2lnbmVkIDY0Yml0XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInVpbnQ2NFwiXTpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiZml4ZWQ2NFwiXToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoUHJvdG9CdWYuTG9uZylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1rTG9uZyh2YWx1ZSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFpbCh0eXBlb2YgdmFsdWUsIGUubWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhaWwodHlwZW9mIHZhbHVlLCBcInJlcXVpcmVzIExvbmcuanNcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBCb29sXHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImJvb2xcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdib29sZWFuJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhaWwodHlwZW9mIHZhbHVlLCBcIm5vdCBhIGJvb2xlYW5cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRmxvYXRcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiZmxvYXRcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImRvdWJsZVwiXTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWlsKHR5cGVvZiB2YWx1ZSwgXCJub3QgYSBudW1iZXJcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTGVuZ3RoLWRlbGltaXRlZCBzdHJpbmdcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wic3RyaW5nXCJdOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJyAmJiAhKHZhbHVlICYmIHZhbHVlIGluc3RhbmNlb2YgU3RyaW5nKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhaWwodHlwZW9mIHZhbHVlLCBcIm5vdCBhIHN0cmluZ1wiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiXCIrdmFsdWU7IC8vIENvbnZlcnQgU3RyaW5nIG9iamVjdCB0byBzdHJpbmdcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTGVuZ3RoLWRlbGltaXRlZCBieXRlc1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJieXRlc1wiXTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlICYmIHZhbHVlIGluc3RhbmNlb2YgQnl0ZUJ1ZmZlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBCeXRlQnVmZmVyLndyYXAodmFsdWUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBDb25zdGFudCBlbnVtIHZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImVudW1cIl06IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlcyA9IHRoaXMucmVzb2x2ZWRUeXBlLmdldENoaWxkcmVuKEVudW0uVmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGk9MDsgaTx2YWx1ZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZXNbaV0ubmFtZSA9PSB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZXNbaV0uaWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlc1tpXS5pZCA9PSB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZXNbaV0uaWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZmFpbCh2YWx1ZSwgXCJub3QgYSB2YWxpZCBlbnVtIHZhbHVlXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyBFbWJlZGRlZCBtZXNzYWdlXHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImdyb3VwXCJdOlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJtZXNzYWdlXCJdOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdmFsdWUgfHwgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhaWwodHlwZW9mIHZhbHVlLCBcIm9iamVjdCBleHBlY3RlZFwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgdGhpcy5yZXNvbHZlZFR5cGUuY2xhenopXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVsc2UgbGV0J3MgdHJ5IHRvIGNvbnN0cnVjdCBvbmUgZnJvbSBhIGtleS12YWx1ZSBvYmplY3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyAodGhpcy5yZXNvbHZlZFR5cGUuY2xhenopKHZhbHVlKTsgLy8gTWF5IHRocm93IGZvciBhIGh1bmRyZWQgb2YgcmVhc29uc1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBXZSBzaG91bGQgbmV2ZXIgZW5kIGhlcmVcclxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiW0lOVEVSTkFMXSBJbGxlZ2FsIHZhbHVlIGZvciBcIit0aGlzLnRvU3RyaW5nKHRydWUpK1wiOiBcIit2YWx1ZStcIiAodW5kZWZpbmVkIHR5cGUgXCIrdGhpcy50eXBlK1wiKVwiKTtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgZmllbGQgdmFsdWUgdG8gdGhlIHNwZWNpZmllZCBidWZmZXIuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgRmllbGQgdmFsdWVcclxuICAgICAgICAgICAgICogQHBhcmFtIHtCeXRlQnVmZmVyfSBidWZmZXIgQnl0ZUJ1ZmZlciB0byBlbmNvZGUgdG9cclxuICAgICAgICAgICAgICogQHJldHVybiB7Qnl0ZUJ1ZmZlcn0gVGhlIEJ5dGVCdWZmZXIgZm9yIGNoYWluaW5nXHJcbiAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgZmllbGQgY2Fubm90IGJlIGVuY29kZWRcclxuICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgRmllbGQucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uKHZhbHVlLCBidWZmZXIpIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy52ZXJpZnlWYWx1ZSh2YWx1ZSk7IC8vIE1heSB0aHJvd1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gbnVsbCB8fCB0eXBlb2YgdGhpcy50eXBlICE9PSAnb2JqZWN0JylcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIltJTlRFUk5BTF0gVW5yZXNvbHZlZCB0eXBlIGluIFwiK3RoaXMudG9TdHJpbmcodHJ1ZSkrXCI6IFwiK3RoaXMudHlwZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgKHRoaXMucmVwZWF0ZWQgJiYgdmFsdWUubGVuZ3RoID09IDApKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBidWZmZXI7IC8vIE9wdGlvbmFsIG9taXR0ZWRcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucmVwZWF0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFwiT25seSByZXBlYXRlZCBmaWVsZHMgb2YgcHJpbWl0aXZlIG51bWVyaWMgdHlwZXMgKHR5cGVzIHdoaWNoIHVzZSB0aGUgdmFyaW50LCAzMi1iaXQsIG9yIDY0LWJpdCB3aXJlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHR5cGVzKSBjYW4gYmUgZGVjbGFyZWQgJ3BhY2tlZCcuXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9uc1tcInBhY2tlZFwiXSAmJiBQcm90b0J1Zi5QQUNLQUJMRV9XSVJFX1RZUEVTLmluZGV4T2YodGhpcy50eXBlLndpcmVUeXBlKSA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBcIkFsbCBvZiB0aGUgZWxlbWVudHMgb2YgdGhlIGZpZWxkIGFyZSBwYWNrZWQgaW50byBhIHNpbmdsZSBrZXktdmFsdWUgcGFpciB3aXRoIHdpcmUgdHlwZSAyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAobGVuZ3RoLWRlbGltaXRlZCkuIEVhY2ggZWxlbWVudCBpcyBlbmNvZGVkIHRoZSBzYW1lIHdheSBpdCB3b3VsZCBiZSBub3JtYWxseSwgZXhjZXB0IHdpdGhvdXQgYVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGFnIHByZWNlZGluZyBpdC5cIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLndyaXRlVmFyaW50MzIoKHRoaXMuaWQgPDwgMykgfCBQcm90b0J1Zi5XSVJFX1RZUEVTLkxERUxJTSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIuZW5zdXJlQ2FwYWNpdHkoYnVmZmVyLm9mZnNldCArPSAxKTsgLy8gV2UgZG8gbm90IGtub3cgdGhlIGxlbmd0aCB5ZXQsIHNvIGxldCdzIGFzc3VtZSBhIHZhcmludCBvZiBsZW5ndGggMVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gYnVmZmVyLm9mZnNldDsgLy8gUmVtZW1iZXIgd2hlcmUgdGhlIGNvbnRlbnRzIGJlZ2luXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGk9MDsgaTx2YWx1ZS5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVuY29kZVZhbHVlKHZhbHVlW2ldLCBidWZmZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxlbiA9IGJ1ZmZlci5vZmZzZXQtc3RhcnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFyaW50TGVuID0gQnl0ZUJ1ZmZlci5jYWxjdWxhdGVWYXJpbnQzMihsZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhcmludExlbiA+IDEpIHsgLy8gV2UgbmVlZCB0byBtb3ZlIHRoZSBjb250ZW50c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb250ZW50cyA9IGJ1ZmZlci5zbGljZShzdGFydCwgYnVmZmVyLm9mZnNldCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgKz0gdmFyaW50TGVuLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLm9mZnNldCA9IHN0YXJ0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci5hcHBlbmQoY29udGVudHMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLndyaXRlVmFyaW50MzIobGVuLCBzdGFydC12YXJpbnRMZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gXCJJZiB5b3VyIG1lc3NhZ2UgZGVmaW5pdGlvbiBoYXMgcmVwZWF0ZWQgZWxlbWVudHMgKHdpdGhvdXQgdGhlIFtwYWNrZWQ9dHJ1ZV0gb3B0aW9uKSwgdGhlIGVuY29kZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1lc3NhZ2UgaGFzIHplcm8gb3IgbW9yZSBrZXktdmFsdWUgcGFpcnMgd2l0aCB0aGUgc2FtZSB0YWcgbnVtYmVyXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaT0wOyBpPHZhbHVlLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci53cml0ZVZhcmludDMyKCh0aGlzLmlkIDw8IDMpIHwgdGhpcy50eXBlLndpcmVUeXBlKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVuY29kZVZhbHVlKHZhbHVlW2ldLCBidWZmZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci53cml0ZVZhcmludDMyKCh0aGlzLmlkIDw8IDMpIHwgdGhpcy50eXBlLndpcmVUeXBlKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbmNvZGVWYWx1ZSh2YWx1ZSwgYnVmZmVyKTtcclxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIklsbGVnYWwgdmFsdWUgZm9yIFwiK3RoaXMudG9TdHJpbmcodHJ1ZSkrXCI6IFwiK3ZhbHVlK1wiIChcIitlK1wiKVwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBidWZmZXI7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogRW5jb2RlcyBhIHZhbHVlIHRvIHRoZSBzcGVjaWZpZWQgYnVmZmVyLiBEb2VzIG5vdCBlbmNvZGUgdGhlIGtleS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBGaWVsZCB2YWx1ZVxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0J5dGVCdWZmZXJ9IGJ1ZmZlciBCeXRlQnVmZmVyIHRvIGVuY29kZSB0b1xyXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHtCeXRlQnVmZmVyfSBUaGUgQnl0ZUJ1ZmZlciBmb3IgY2hhaW5pbmdcclxuICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSB2YWx1ZSBjYW5ub3QgYmUgZW5jb2RlZFxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBGaWVsZC5wcm90b3R5cGUuZW5jb2RlVmFsdWUgPSBmdW5jdGlvbih2YWx1ZSwgYnVmZmVyKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHJldHVybiBidWZmZXI7IC8vIE5vdGhpbmcgdG8gZW5jb2RlXHJcbiAgICAgICAgICAgICAgICAvLyBUYWcgaGFzIGFscmVhZHkgYmVlbiB3cml0dGVuXHJcblxyXG4gICAgICAgICAgICAgICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyAzMmJpdCBzaWduZWQgdmFyaW50XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImludDMyXCJdOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBcIklmIHlvdSB1c2UgaW50MzIgb3IgaW50NjQgYXMgdGhlIHR5cGUgZm9yIGEgbmVnYXRpdmUgbnVtYmVyLCB0aGUgcmVzdWx0aW5nIHZhcmludCBpcyBhbHdheXMgdGVuIGJ5dGVzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxvbmcg4oCTIGl0IGlzLCBlZmZlY3RpdmVseSwgdHJlYXRlZCBsaWtlIGEgdmVyeSBsYXJnZSB1bnNpZ25lZCBpbnRlZ2VyLlwiIChzZWUgIzEyMilcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlIDwgMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci53cml0ZVZhcmludDY0KHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLndyaXRlVmFyaW50MzIodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gMzJiaXQgdW5zaWduZWQgdmFyaW50XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInVpbnQzMlwiXTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLndyaXRlVmFyaW50MzIodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gMzJiaXQgdmFyaW50IHppZy16YWdcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wic2ludDMyXCJdOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIud3JpdGVWYXJpbnQzMlppZ1phZyh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBGaXhlZCB1bnNpZ25lZCAzMmJpdFxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJmaXhlZDMyXCJdOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIud3JpdGVVaW50MzIodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRml4ZWQgc2lnbmVkIDMyYml0XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInNmaXhlZDMyXCJdOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIud3JpdGVJbnQzMih2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyA2NGJpdCB2YXJpbnQgYXMtaXNcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiaW50NjRcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInVpbnQ2NFwiXTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLndyaXRlVmFyaW50NjQodmFsdWUpOyAvLyB0aHJvd3NcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIDY0Yml0IHZhcmludCB6aWctemFnXHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInNpbnQ2NFwiXTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLndyaXRlVmFyaW50NjRaaWdaYWcodmFsdWUpOyAvLyB0aHJvd3NcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEZpeGVkIHVuc2lnbmVkIDY0Yml0XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImZpeGVkNjRcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci53cml0ZVVpbnQ2NCh2YWx1ZSk7IC8vIHRocm93c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRml4ZWQgc2lnbmVkIDY0Yml0XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInNmaXhlZDY0XCJdOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIud3JpdGVJbnQ2NCh2YWx1ZSk7IC8vIHRocm93c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQm9vbFxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJib29sXCJdOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci53cml0ZVZhcmludDMyKHZhbHVlLnRvTG93ZXJDYXNlKCkgPT09ICdmYWxzZScgPyAwIDogISF2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci53cml0ZVZhcmludDMyKHZhbHVlID8gMSA6IDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ29uc3RhbnQgZW51bSB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJlbnVtXCJdOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIud3JpdGVWYXJpbnQzMih2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyAzMmJpdCBmbG9hdFxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJmbG9hdFwiXTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLndyaXRlRmxvYXQzMih2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyA2NGJpdCBmbG9hdFxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJkb3VibGVcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci53cml0ZUZsb2F0NjQodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTGVuZ3RoLWRlbGltaXRlZCBzdHJpbmdcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wic3RyaW5nXCJdOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIud3JpdGVWU3RyaW5nKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIExlbmd0aC1kZWxpbWl0ZWQgYnl0ZXNcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiYnl0ZXNcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5yZW1haW5pbmcoKSA8IDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIklsbGVnYWwgdmFsdWUgZm9yIFwiK3RoaXMudG9TdHJpbmcodHJ1ZSkrXCI6IFwiK3ZhbHVlLnJlbWFpbmluZygpK1wiIGJ5dGVzIHJlbWFpbmluZ1wiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByZXZPZmZzZXQgPSB2YWx1ZS5vZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci53cml0ZVZhcmludDMyKHZhbHVlLnJlbWFpbmluZygpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLmFwcGVuZCh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLm9mZnNldCA9IHByZXZPZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBFbWJlZGRlZCBtZXNzYWdlXHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcIm1lc3NhZ2VcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBiYiA9IG5ldyBCeXRlQnVmZmVyKCkuTEUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNvbHZlZFR5cGUuZW5jb2RlKHZhbHVlLCBiYik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci53cml0ZVZhcmludDMyKGJiLm9mZnNldCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci5hcHBlbmQoYmIuZmxpcCgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIExlZ2FjeSBncm91cFxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJncm91cFwiXTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNvbHZlZFR5cGUuZW5jb2RlKHZhbHVlLCBidWZmZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIud3JpdGVWYXJpbnQzMigodGhpcy5pZCA8PCAzKSB8IFByb3RvQnVmLldJUkVfVFlQRVMuRU5ER1JPVVApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2Ugc2hvdWxkIG5ldmVyIGVuZCBoZXJlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiW0lOVEVSTkFMXSBJbGxlZ2FsIHZhbHVlIHRvIGVuY29kZSBpbiBcIit0aGlzLnRvU3RyaW5nKHRydWUpK1wiOiBcIit2YWx1ZStcIiAodW5rbm93biB0eXBlKVwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBidWZmZXI7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQ2FsY3VsYXRlcyB0aGUgbGVuZ3RoIG9mIHRoaXMgZmllbGQncyB2YWx1ZSBvbiB0aGUgbmV0d29yayBsZXZlbC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBGaWVsZCB2YWx1ZVxyXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBCeXRlIGxlbmd0aFxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBGaWVsZC5wcm90b3R5cGUuY2FsY3VsYXRlID0gZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy52ZXJpZnlWYWx1ZSh2YWx1ZSk7IC8vIE1heSB0aHJvd1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gbnVsbCB8fCB0eXBlb2YgdGhpcy50eXBlICE9PSAnb2JqZWN0JylcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIltJTlRFUk5BTF0gVW5yZXNvbHZlZCB0eXBlIGluIFwiK3RoaXMudG9TdHJpbmcodHJ1ZSkrXCI6IFwiK3RoaXMudHlwZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgKHRoaXMucmVwZWF0ZWQgJiYgdmFsdWUubGVuZ3RoID09IDApKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwOyAvLyBPcHRpb25hbCBvbWl0dGVkXHJcbiAgICAgICAgICAgICAgICB2YXIgbiA9IDA7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlcGVhdGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpLCBuaTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9uc1tcInBhY2tlZFwiXSAmJiBQcm90b0J1Zi5QQUNLQUJMRV9XSVJFX1RZUEVTLmluZGV4T2YodGhpcy50eXBlLndpcmVUeXBlKSA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuICs9IEJ5dGVCdWZmZXIuY2FsY3VsYXRlVmFyaW50MzIoKHRoaXMuaWQgPDwgMykgfCBQcm90b0J1Zi5XSVJFX1RZUEVTLkxERUxJTSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuaSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGk9MDsgaTx2YWx1ZS5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuaSArPSB0aGlzLmNhbGN1bGF0ZVZhbHVlKHZhbHVlW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG4gKz0gQnl0ZUJ1ZmZlci5jYWxjdWxhdGVWYXJpbnQzMihuaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuICs9IG5pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpPTA7IGk8dmFsdWUubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbiArPSBCeXRlQnVmZmVyLmNhbGN1bGF0ZVZhcmludDMyKCh0aGlzLmlkIDw8IDMpIHwgdGhpcy50eXBlLndpcmVUeXBlKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuICs9IHRoaXMuY2FsY3VsYXRlVmFsdWUodmFsdWVbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbiArPSBCeXRlQnVmZmVyLmNhbGN1bGF0ZVZhcmludDMyKCh0aGlzLmlkIDw8IDMpIHwgdGhpcy50eXBlLndpcmVUeXBlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbiArPSB0aGlzLmNhbGN1bGF0ZVZhbHVlKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIHZhbHVlIGZvciBcIit0aGlzLnRvU3RyaW5nKHRydWUpK1wiOiBcIit2YWx1ZStcIiAoXCIrZStcIilcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbjtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBDYWxjdWxhdGVzIHRoZSBieXRlIGxlbmd0aCBvZiBhIHZhbHVlLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0geyp9IHZhbHVlIEZpZWxkIHZhbHVlXHJcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IEJ5dGUgbGVuZ3RoXHJcbiAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgdmFsdWUgY2Fubm90IGJlIGNhbGN1bGF0ZWRcclxuICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgRmllbGQucHJvdG90eXBlLmNhbGN1bGF0ZVZhbHVlID0gZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkgcmV0dXJuIDA7IC8vIE5vdGhpbmcgdG8gZW5jb2RlXHJcbiAgICAgICAgICAgICAgICAvLyBUYWcgaGFzIGFscmVhZHkgYmVlbiB3cml0dGVuXHJcbiAgICAgICAgICAgICAgICB2YXIgbjtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImludDMyXCJdOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgPCAwID8gQnl0ZUJ1ZmZlci5jYWxjdWxhdGVWYXJpbnQ2NCh2YWx1ZSkgOiBCeXRlQnVmZmVyLmNhbGN1bGF0ZVZhcmludDMyKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1widWludDMyXCJdOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gQnl0ZUJ1ZmZlci5jYWxjdWxhdGVWYXJpbnQzMih2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInNpbnQzMlwiXTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJ5dGVCdWZmZXIuY2FsY3VsYXRlVmFyaW50MzIoQnl0ZUJ1ZmZlci56aWdaYWdFbmNvZGUzMih2YWx1ZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJmaXhlZDMyXCJdOlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJzZml4ZWQzMlwiXTpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiZmxvYXRcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiA0O1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJpbnQ2NFwiXTpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1widWludDY0XCJdOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gQnl0ZUJ1ZmZlci5jYWxjdWxhdGVWYXJpbnQ2NCh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInNpbnQ2NFwiXTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJ5dGVCdWZmZXIuY2FsY3VsYXRlVmFyaW50NjQoQnl0ZUJ1ZmZlci56aWdaYWdFbmNvZGU2NCh2YWx1ZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJmaXhlZDY0XCJdOlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJzZml4ZWQ2NFwiXTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDg7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImJvb2xcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJlbnVtXCJdOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gQnl0ZUJ1ZmZlci5jYWxjdWxhdGVWYXJpbnQzMih2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImRvdWJsZVwiXTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDg7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInN0cmluZ1wiXTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgbiA9IEJ5dGVCdWZmZXIuY2FsY3VsYXRlVVRGOEJ5dGVzKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJ5dGVCdWZmZXIuY2FsY3VsYXRlVmFyaW50MzIobikgKyBuO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJieXRlc1wiXTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlLnJlbWFpbmluZygpIDwgMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCB2YWx1ZSBmb3IgXCIrdGhpcy50b1N0cmluZyh0cnVlKStcIjogXCIrdmFsdWUucmVtYWluaW5nKCkrXCIgYnl0ZXMgcmVtYWluaW5nXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gQnl0ZUJ1ZmZlci5jYWxjdWxhdGVWYXJpbnQzMih2YWx1ZS5yZW1haW5pbmcoKSkgKyB2YWx1ZS5yZW1haW5pbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wibWVzc2FnZVwiXTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgbiA9IHRoaXMucmVzb2x2ZWRUeXBlLmNhbGN1bGF0ZSh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBCeXRlQnVmZmVyLmNhbGN1bGF0ZVZhcmludDMyKG4pICsgbjtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiZ3JvdXBcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG4gPSB0aGlzLnJlc29sdmVkVHlwZS5jYWxjdWxhdGUodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbiArIEJ5dGVCdWZmZXIuY2FsY3VsYXRlVmFyaW50MzIoKHRoaXMuaWQgPDwgMykgfCBQcm90b0J1Zi5XSVJFX1RZUEVTLkVOREdST1VQKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIFdlIHNob3VsZCBuZXZlciBlbmQgaGVyZVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJbSU5URVJOQUxdIElsbGVnYWwgdmFsdWUgdG8gZW5jb2RlIGluIFwiK3RoaXMudG9TdHJpbmcodHJ1ZSkrXCI6IFwiK3ZhbHVlK1wiICh1bmtub3duIHR5cGUpXCIpO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIERlY29kZSB0aGUgZmllbGQgdmFsdWUgZnJvbSB0aGUgc3BlY2lmaWVkIGJ1ZmZlci5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHdpcmVUeXBlIExlYWRpbmcgd2lyZSB0eXBlXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7Qnl0ZUJ1ZmZlcn0gYnVmZmVyIEJ5dGVCdWZmZXIgdG8gZGVjb2RlIGZyb21cclxuICAgICAgICAgICAgICogQHBhcmFtIHtib29sZWFuPX0gc2tpcFJlcGVhdGVkIFdoZXRoZXIgdG8gc2tpcCB0aGUgcmVwZWF0ZWQgY2hlY2sgb3Igbm90LiBEZWZhdWx0cyB0byBmYWxzZS5cclxuICAgICAgICAgICAgICogQHJldHVybiB7Kn0gRGVjb2RlZCB2YWx1ZVxyXG4gICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGZpZWxkIGNhbm5vdCBiZSBkZWNvZGVkXHJcbiAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEZpZWxkLnByb3RvdHlwZS5kZWNvZGUgPSBmdW5jdGlvbih3aXJlVHlwZSwgYnVmZmVyLCBza2lwUmVwZWF0ZWQpIHtcclxuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSwgbkJ5dGVzO1xyXG4gICAgICAgICAgICAgICAgaWYgKHdpcmVUeXBlICE9IHRoaXMudHlwZS53aXJlVHlwZSAmJiAoc2tpcFJlcGVhdGVkIHx8ICh3aXJlVHlwZSAhPSBQcm90b0J1Zi5XSVJFX1RZUEVTLkxERUxJTSB8fCAhdGhpcy5yZXBlYXRlZCkpKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCB3aXJlIHR5cGUgZm9yIGZpZWxkIFwiK3RoaXMudG9TdHJpbmcodHJ1ZSkrXCI6IFwiK3dpcmVUeXBlK1wiIChcIit0aGlzLnR5cGUud2lyZVR5cGUrXCIgZXhwZWN0ZWQpXCIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHdpcmVUeXBlID09IFByb3RvQnVmLldJUkVfVFlQRVMuTERFTElNICYmIHRoaXMucmVwZWF0ZWQgJiYgdGhpcy5vcHRpb25zW1wicGFja2VkXCJdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFza2lwUmVwZWF0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbkJ5dGVzID0gYnVmZmVyLnJlYWRWYXJpbnQzMigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuQnl0ZXMgPSBidWZmZXIub2Zmc2V0ICsgbkJ5dGVzOyAvLyBMaW1pdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWVzID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChidWZmZXIub2Zmc2V0IDwgbkJ5dGVzKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzLnB1c2godGhpcy5kZWNvZGUodGhpcy50eXBlLndpcmVUeXBlLCBidWZmZXIsIHRydWUpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlcztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVhZCB0aGUgbmV4dCB2YWx1ZSBvdGhlcndpc2UuLi5cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gMzJiaXQgc2lnbmVkIHZhcmludFxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJpbnQzMlwiXTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlci5yZWFkVmFyaW50MzIoKSB8IDA7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIDMyYml0IHVuc2lnbmVkIHZhcmludFxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJ1aW50MzJcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBidWZmZXIucmVhZFZhcmludDMyKCkgPj4+IDA7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIDMyYml0IHNpZ25lZCB2YXJpbnQgemlnLXphZ1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJzaW50MzJcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBidWZmZXIucmVhZFZhcmludDMyWmlnWmFnKCkgfCAwO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBGaXhlZCAzMmJpdCB1bnNpZ25lZFxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJmaXhlZDMyXCJdOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYnVmZmVyLnJlYWRVaW50MzIoKSA+Pj4gMDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInNmaXhlZDMyXCJdOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYnVmZmVyLnJlYWRJbnQzMigpIHwgMDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gNjRiaXQgc2lnbmVkIHZhcmludFxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJpbnQ2NFwiXTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlci5yZWFkVmFyaW50NjQoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gNjRiaXQgdW5zaWduZWQgdmFyaW50XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInVpbnQ2NFwiXTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlci5yZWFkVmFyaW50NjQoKS50b1Vuc2lnbmVkKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIDY0Yml0IHNpZ25lZCB2YXJpbnQgemlnLXphZ1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJzaW50NjRcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBidWZmZXIucmVhZFZhcmludDY0WmlnWmFnKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEZpeGVkIDY0Yml0IHVuc2lnbmVkXHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImZpeGVkNjRcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBidWZmZXIucmVhZFVpbnQ2NCgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBGaXhlZCA2NGJpdCBzaWduZWRcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wic2ZpeGVkNjRcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBidWZmZXIucmVhZEludDY0KCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEJvb2wgdmFyaW50XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImJvb2xcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhIWJ1ZmZlci5yZWFkVmFyaW50MzIoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ29uc3RhbnQgZW51bSB2YWx1ZSAodmFyaW50KVxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJlbnVtXCJdOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgZm9sbG93aW5nIEJ1aWxkZXIuTWVzc2FnZSNzZXQgd2lsbCBhbHJlYWR5IHRocm93XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBidWZmZXIucmVhZFZhcmludDMyKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIDMyYml0IGZsb2F0XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImZsb2F0XCJdOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYnVmZmVyLnJlYWRGbG9hdCgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyA2NGJpdCBmbG9hdFxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJkb3VibGVcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBidWZmZXIucmVhZERvdWJsZSgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBMZW5ndGgtZGVsaW1pdGVkIHN0cmluZ1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJzdHJpbmdcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBidWZmZXIucmVhZFZTdHJpbmcoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTGVuZ3RoLWRlbGltaXRlZCBieXRlc1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJieXRlc1wiXToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuQnl0ZXMgPSBidWZmZXIucmVhZFZhcmludDMyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChidWZmZXIucmVtYWluaW5nKCkgPCBuQnl0ZXMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIklsbGVnYWwgbnVtYmVyIG9mIGJ5dGVzIGZvciBcIit0aGlzLnRvU3RyaW5nKHRydWUpK1wiOiBcIituQnl0ZXMrXCIgcmVxdWlyZWQgYnV0IGdvdCBvbmx5IFwiK2J1ZmZlci5yZW1haW5pbmcoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gYnVmZmVyLmNsb25lKCk7IC8vIE9mZnNldCBhbHJlYWR5IHNldFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZS5saW1pdCA9IHZhbHVlLm9mZnNldCtuQnl0ZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci5vZmZzZXQgKz0gbkJ5dGVzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBMZW5ndGgtZGVsaW1pdGVkIGVtYmVkZGVkIG1lc3NhZ2VcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wibWVzc2FnZVwiXToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuQnl0ZXMgPSBidWZmZXIucmVhZFZhcmludDMyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc29sdmVkVHlwZS5kZWNvZGUoYnVmZmVyLCBuQnl0ZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTGVnYWN5IGdyb3VwXHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImdyb3VwXCJdOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZXNvbHZlZFR5cGUuZGVjb2RlKGJ1ZmZlciwgLTEsIHRoaXMuaWQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIFdlIHNob3VsZCBuZXZlciBlbmQgaGVyZVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJbSU5URVJOQUxdIElsbGVnYWwgd2lyZSB0eXBlIGZvciBcIit0aGlzLnRvU3RyaW5nKHRydWUpK1wiOiBcIit3aXJlVHlwZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBAYWxpYXMgUHJvdG9CdWYuUmVmbGVjdC5NZXNzYWdlLkZpZWxkXHJcbiAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFJlZmxlY3QuTWVzc2FnZS5GaWVsZCA9IEZpZWxkO1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgTWVzc2FnZSBFeHRlbnNpb25GaWVsZC5cclxuICAgICAgICAgICAgICogQGV4cG9ydHMgUHJvdG9CdWYuUmVmbGVjdC5NZXNzYWdlLkV4dGVuc2lvbkZpZWxkXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7UHJvdG9CdWYuUmVmbGVjdC5NZXNzYWdlfSBtZXNzYWdlIE1lc3NhZ2UgcmVmZXJlbmNlXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBydWxlIFJ1bGUsIG9uZSBvZiByZXF1cmllZCwgb3B0aW9uYWwsIHJlcGVhdGVkXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIERhdGEgdHlwZSwgZS5nLiBpbnQzMlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBGaWVsZCBuYW1lXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpZCBVbmlxdWUgZmllbGQgaWRcclxuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZy4qPj19IG9wdGlvbnMgT3B0aW9uc1xyXG4gICAgICAgICAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAgICAgICAgICogQGV4dGVuZHMgUHJvdG9CdWYuUmVmbGVjdC5NZXNzYWdlLkZpZWxkXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB2YXIgRXh0ZW5zaW9uRmllbGQgPSBmdW5jdGlvbihtZXNzYWdlLCBydWxlLCB0eXBlLCBuYW1lLCBpZCwgb3B0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgRmllbGQuY2FsbCh0aGlzLCBtZXNzYWdlLCBydWxlLCB0eXBlLCBuYW1lLCBpZCwgb3B0aW9ucyk7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvLyBFeHRlbmRzIEZpZWxkXHJcbiAgICAgICAgICAgIEV4dGVuc2lvbkZpZWxkLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRmllbGQucHJvdG90eXBlKTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBAYWxpYXMgUHJvdG9CdWYuUmVmbGVjdC5NZXNzYWdlLkV4dGVuc2lvbkZpZWxkXHJcbiAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFJlZmxlY3QuTWVzc2FnZS5FeHRlbnNpb25GaWVsZCA9IEV4dGVuc2lvbkZpZWxkO1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgRW51bS5cclxuICAgICAgICAgICAgICogQGV4cG9ydHMgUHJvdG9CdWYuUmVmbGVjdC5FbnVtXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7IVByb3RvQnVmLlJlZmxlY3QuVH0gcGFyZW50IFBhcmVudCBSZWZsZWN0IG9iamVjdFxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBFbnVtIG5hbWVcclxuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZy4qPj19IG9wdGlvbnMgRW51bSBvcHRpb25zXHJcbiAgICAgICAgICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICAgICAgICAgKiBAZXh0ZW5kcyBQcm90b0J1Zi5SZWZsZWN0Lk5hbWVzcGFjZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdmFyIEVudW0gPSBmdW5jdGlvbihwYXJlbnQsIG5hbWUsIG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgIE5hbWVzcGFjZS5jYWxsKHRoaXMsIHBhcmVudCwgbmFtZSwgb3B0aW9ucyk7XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBAb3ZlcnJpZGVcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jbGFzc05hbWUgPSBcIkVudW1cIjtcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFJ1bnRpbWUgZW51bSBvYmplY3QuXHJcbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsbnVtYmVyPnxudWxsfVxyXG4gICAgICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLm9iamVjdCA9IG51bGw7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvLyBFeHRlbmRzIE5hbWVzcGFjZVxyXG4gICAgICAgICAgICBFbnVtLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTmFtZXNwYWNlLnByb3RvdHlwZSk7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQnVpbGRzIHRoaXMgZW51bSBhbmQgcmV0dXJucyB0aGUgcnVudGltZSBjb3VudGVycGFydC5cclxuICAgICAgICAgICAgICogQHJldHVybiB7T2JqZWN0PHN0cmluZywqPn1cclxuICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgRW51bS5wcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHZhciBlbm0gPSB7fTtcclxuICAgICAgICAgICAgICAgIHZhciB2YWx1ZXMgPSB0aGlzLmdldENoaWxkcmVuKEVudW0uVmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpPHZhbHVlcy5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICBlbm1bdmFsdWVzW2ldWyduYW1lJ11dID0gdmFsdWVzW2ldWydpZCddO1xyXG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSlcclxuICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZW5tLCAnJG9wdGlvbnMnLCB7IFwidmFsdWVcIjogdGhpcy5idWlsZE9wdCgpIH0pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub2JqZWN0ID0gZW5tO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEBhbGlhcyBQcm90b0J1Zi5SZWZsZWN0LkVudW1cclxuICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgUmVmbGVjdC5FbnVtID0gRW51bTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IEVudW0gVmFsdWUuXHJcbiAgICAgICAgICAgICAqIEBleHBvcnRzIFByb3RvQnVmLlJlZmxlY3QuRW51bS5WYWx1ZVxyXG4gICAgICAgICAgICAgKiBAcGFyYW0geyFQcm90b0J1Zi5SZWZsZWN0LkVudW19IGVubSBFbnVtIHJlZmVyZW5jZVxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBGaWVsZCBuYW1lXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpZCBVbmlxdWUgZmllbGQgaWRcclxuICAgICAgICAgICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgICAgICAgICAqIEBleHRlbmRzIFByb3RvQnVmLlJlZmxlY3QuVFxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdmFyIFZhbHVlID0gZnVuY3Rpb24oZW5tLCBuYW1lLCBpZCkge1xyXG4gICAgICAgICAgICAgICAgVC5jYWxsKHRoaXMsIGVubSwgbmFtZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBAb3ZlcnJpZGVcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jbGFzc05hbWUgPSBcIkVudW0uVmFsdWVcIjtcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFVuaXF1ZSBlbnVtIHZhbHVlIGlkLlxyXG4gICAgICAgICAgICAgICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pZCA9IGlkO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLy8gRXh0ZW5kcyBUXHJcbiAgICAgICAgICAgIFZhbHVlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoVC5wcm90b3R5cGUpO1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEBhbGlhcyBQcm90b0J1Zi5SZWZsZWN0LkVudW0uVmFsdWVcclxuICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgUmVmbGVjdC5FbnVtLlZhbHVlID0gVmFsdWU7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQ29uc3RydWN0cyBhIG5ldyBTZXJ2aWNlLlxyXG4gICAgICAgICAgICAgKiBAZXhwb3J0cyBQcm90b0J1Zi5SZWZsZWN0LlNlcnZpY2VcclxuICAgICAgICAgICAgICogQHBhcmFtIHshUHJvdG9CdWYuUmVmbGVjdC5OYW1lc3BhY2V9IHJvb3QgUm9vdFxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBTZXJ2aWNlIG5hbWVcclxuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPj19IG9wdGlvbnMgT3B0aW9uc1xyXG4gICAgICAgICAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAgICAgICAgICogQGV4dGVuZHMgUHJvdG9CdWYuUmVmbGVjdC5OYW1lc3BhY2VcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHZhciBTZXJ2aWNlID0gZnVuY3Rpb24ocm9vdCwgbmFtZSwgb3B0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgTmFtZXNwYWNlLmNhbGwodGhpcywgcm9vdCwgbmFtZSwgb3B0aW9ucyk7XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBAb3ZlcnJpZGVcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jbGFzc05hbWUgPSBcIlNlcnZpY2VcIjtcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEJ1aWx0IHJ1bnRpbWUgc2VydmljZSBjbGFzcy5cclxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHs/ZnVuY3Rpb24obmV3OlByb3RvQnVmLkJ1aWxkZXIuU2VydmljZSl9XHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuY2xhenogPSBudWxsO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLy8gRXh0ZW5kcyBOYW1lc3BhY2VcclxuICAgICAgICAgICAgU2VydmljZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKE5hbWVzcGFjZS5wcm90b3R5cGUpO1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEJ1aWxkcyB0aGUgc2VydmljZSBhbmQgcmV0dXJucyB0aGUgcnVudGltZSBjb3VudGVycGFydCwgd2hpY2ggaXMgYSBmdWxseSBmdW5jdGlvbmFsIGNsYXNzLlxyXG4gICAgICAgICAgICAgKiBAc2VlIFByb3RvQnVmLkJ1aWxkZXIuU2VydmljZVxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSByZWJ1aWxkIFdoZXRoZXIgdG8gcmVidWlsZCBvciBub3RcclxuICAgICAgICAgICAgICogQHJldHVybiB7RnVuY3Rpb259IFNlcnZpY2UgY2xhc3NcclxuICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBtZXNzYWdlIGNhbm5vdCBiZSBidWlsdFxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBTZXJ2aWNlLnByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uKHJlYnVpbGQpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNsYXp6ICYmICFyZWJ1aWxkKSByZXR1cm4gdGhpcy5jbGF6ejtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNsYXp6ID0gKGZ1bmN0aW9uKFByb3RvQnVmLCBUKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgcnVudGltZSBTZXJ2aWNlLlxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBuYW1lIFByb3RvQnVmLkJ1aWxkZXIuU2VydmljZVxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oc3RyaW5nLCBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UsIGZ1bmN0aW9uKEVycm9yLCBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2U9KSk9fSBycGNJbXBsIFJQQyBpbXBsZW1lbnRhdGlvbiByZWNlaXZpbmcgdGhlIG1ldGhvZCBuYW1lIGFuZCB0aGUgbWVzc2FnZVxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBjbGFzcyBCYXJlYm9uZSBvZiBhbGwgcnVudGltZSBzZXJ2aWNlcy5cclxuICAgICAgICAgICAgICAgICAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAgICAgICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHNlcnZpY2UgY2Fubm90IGJlIGNyZWF0ZWRcclxuICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICB2YXIgU2VydmljZSA9IGZ1bmN0aW9uKHJwY0ltcGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgUHJvdG9CdWYuQnVpbGRlci5TZXJ2aWNlLmNhbGwodGhpcyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAgICAgICAgICogU2VydmljZSBpbXBsZW1lbnRhdGlvbi5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICogQG5hbWUgUHJvdG9CdWYuQnVpbGRlci5TZXJ2aWNlI3JwY0ltcGxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICogQHR5cGUgeyFmdW5jdGlvbihzdHJpbmcsIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZSwgZnVuY3Rpb24oRXJyb3IsIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZT0pKX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ycGNJbXBsID0gcnBjSW1wbCB8fCBmdW5jdGlvbihuYW1lLCBtc2csIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIHdoYXQgYSB1c2VyIGhhcyB0byBpbXBsZW1lbnQ6IEEgZnVuY3Rpb24gcmVjZWl2aW5nIHRoZSBtZXRob2QgbmFtZSwgdGhlIGFjdHVhbCBtZXNzYWdlIHRvXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzZW5kICh0eXBlIGNoZWNrZWQpIGFuZCB0aGUgY2FsbGJhY2sgdGhhdCdzIGVpdGhlciBwcm92aWRlZCB3aXRoIHRoZSBlcnJvciBhcyBpdHMgZmlyc3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFyZ3VtZW50IG9yIG51bGwgYW5kIHRoZSBhY3R1YWwgcmVzcG9uc2UgbWVzc2FnZS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoY2FsbGJhY2suYmluZCh0aGlzLCBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZCwgc2VlOiBodHRwczovL2dpdGh1Yi5jb20vZGNvZGVJTy9Qcm90b0J1Zi5qcy93aWtpL1NlcnZpY2VzXCIpKSwgMCk7IC8vIE11c3QgYmUgYXN5bmMhXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRXh0ZW5kcyBQcm90b0J1Zi5CdWlsZGVyLlNlcnZpY2VcclxuICAgICAgICAgICAgICAgICAgICBTZXJ2aWNlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoUHJvdG9CdWYuQnVpbGRlci5TZXJ2aWNlLnByb3RvdHlwZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTZXJ2aWNlLCBcIiRvcHRpb25zXCIsIHsgXCJ2YWx1ZVwiOiBULmJ1aWxkT3B0KCkgfSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTZXJ2aWNlLnByb3RvdHlwZSwgXCIkb3B0aW9uc1wiLCB7IFwidmFsdWVcIjogU2VydmljZVtcIiRvcHRpb25zXCJdIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAgICAgKiBBc3luY2hyb25vdXNseSBwZXJmb3JtcyBhbiBSUEMgY2FsbCB1c2luZyB0aGUgZ2l2ZW4gUlBDIGltcGxlbWVudGF0aW9uLlxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBuYW1lIFByb3RvQnVmLkJ1aWxkZXIuU2VydmljZS5bTWV0aG9kXVxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7IWZ1bmN0aW9uKHN0cmluZywgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlLCBmdW5jdGlvbihFcnJvciwgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlPSkpfSBycGNJbXBsIFJQQyBpbXBsZW1lbnRhdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7UHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlfSByZXEgUmVxdWVzdFxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIChQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2V8Qnl0ZUJ1ZmZlcnxCdWZmZXJ8c3RyaW5nKT0pfSBjYWxsYmFjayBDYWxsYmFjayByZWNlaXZpbmdcclxuICAgICAgICAgICAgICAgICAgICAgKiAgdGhlIGVycm9yIGlmIGFueSBhbmQgdGhlIHJlc3BvbnNlIGVpdGhlciBhcyBhIHByZS1wYXJzZWQgbWVzc2FnZSBvciBhcyBpdHMgcmF3IGJ5dGVzXHJcbiAgICAgICAgICAgICAgICAgICAgICogQGFic3RyYWN0XHJcbiAgICAgICAgICAgICAgICAgICAgICovXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAqIEFzeW5jaHJvbm91c2x5IHBlcmZvcm1zIGFuIFJQQyBjYWxsIHVzaW5nIHRoZSBpbnN0YW5jZSdzIFJQQyBpbXBsZW1lbnRhdGlvbi5cclxuICAgICAgICAgICAgICAgICAgICAgKiBAbmFtZSBQcm90b0J1Zi5CdWlsZGVyLlNlcnZpY2UjW01ldGhvZF1cclxuICAgICAgICAgICAgICAgICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge1Byb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZX0gcmVxIFJlcXVlc3RcclxuICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yLCAoUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlfEJ5dGVCdWZmZXJ8QnVmZmVyfHN0cmluZyk9KX0gY2FsbGJhY2sgQ2FsbGJhY2sgcmVjZWl2aW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICogIHRoZSBlcnJvciBpZiBhbnkgYW5kIHRoZSByZXNwb25zZSBlaXRoZXIgYXMgYSBwcmUtcGFyc2VkIG1lc3NhZ2Ugb3IgYXMgaXRzIHJhdyBieXRlc1xyXG4gICAgICAgICAgICAgICAgICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICAgICAgICAgICAgICAgICAqL1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgcnBjID0gVC5nZXRDaGlsZHJlbihQcm90b0J1Zi5SZWZsZWN0LlNlcnZpY2UuUlBDTWV0aG9kKTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8cnBjLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChmdW5jdGlvbihtZXRob2QpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzZXJ2aWNlI01ldGhvZChtZXNzYWdlLCBjYWxsYmFjaylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNlcnZpY2UucHJvdG90eXBlW21ldGhvZC5uYW1lXSA9IGZ1bmN0aW9uKHJlcSwgY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJlcSB8fCAhKHJlcSBpbnN0YW5jZW9mIG1ldGhvZC5yZXNvbHZlZFJlcXVlc3RUeXBlLmNsYXp6KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChjYWxsYmFjay5iaW5kKHRoaXMsIEVycm9yKFwiSWxsZWdhbCByZXF1ZXN0IHR5cGUgcHJvdmlkZWQgdG8gc2VydmljZSBtZXRob2QgXCIrVC5uYW1lK1wiI1wiK21ldGhvZC5uYW1lKSksIDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucnBjSW1wbChtZXRob2QuZnFuKCksIHJlcSwgZnVuY3Rpb24oZXJyLCByZXMpIHsgLy8gQXNzdW1lcyB0aGF0IHRoaXMgaXMgcHJvcGVybHkgYXN5bmNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7IHJlcyA9IG1ldGhvZC5yZXNvbHZlZFJlc3BvbnNlVHlwZS5jbGF6ei5kZWNvZGUocmVzKTsgfSBjYXRjaCAobm90QUJ1ZmZlcikge31cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcmVzIHx8ICEocmVzIGluc3RhbmNlb2YgbWV0aG9kLnJlc29sdmVkUmVzcG9uc2VUeXBlLmNsYXp6KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKEVycm9yKFwiSWxsZWdhbCByZXNwb25zZSB0eXBlIHJlY2VpdmVkIGluIHNlcnZpY2UgbWV0aG9kIFwiKyBULm5hbWUrXCIjXCIrbWV0aG9kLm5hbWUpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCByZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChjYWxsYmFjay5iaW5kKHRoaXMsIGVyciksIDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2VydmljZS5NZXRob2QocnBjSW1wbCwgbWVzc2FnZSwgY2FsbGJhY2spXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBTZXJ2aWNlW21ldGhvZC5uYW1lXSA9IGZ1bmN0aW9uKHJwY0ltcGwsIHJlcSwgY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgU2VydmljZShycGNJbXBsKVttZXRob2QubmFtZV0ocmVxLCBjYWxsYmFjayk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNlcnZpY2VbbWV0aG9kLm5hbWVdLCBcIiRvcHRpb25zXCIsIHsgXCJ2YWx1ZVwiOiBtZXRob2QuYnVpbGRPcHQoKSB9KSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2VydmljZS5wcm90b3R5cGVbbWV0aG9kLm5hbWVdLCBcIiRvcHRpb25zXCIsIHsgXCJ2YWx1ZVwiOiBTZXJ2aWNlW21ldGhvZC5uYW1lXVtcIiRvcHRpb25zXCJdIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KShycGNbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFNlcnZpY2U7XHJcblxyXG4gICAgICAgICAgICAgICAgfSkoUHJvdG9CdWYsIHRoaXMpO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEBhbGlhcyBQcm90b0J1Zi5SZWZsZWN0LlNlcnZpY2VcclxuICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgUmVmbGVjdC5TZXJ2aWNlID0gU2VydmljZTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBBYnN0cmFjdCBzZXJ2aWNlIG1ldGhvZC5cclxuICAgICAgICAgICAgICogQGV4cG9ydHMgUHJvdG9CdWYuUmVmbGVjdC5TZXJ2aWNlLk1ldGhvZFxyXG4gICAgICAgICAgICAgKiBAcGFyYW0geyFQcm90b0J1Zi5SZWZsZWN0LlNlcnZpY2V9IHN2YyBTZXJ2aWNlXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE1ldGhvZCBuYW1lXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj49fSBvcHRpb25zIE9wdGlvbnNcclxuICAgICAgICAgICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgICAgICAgICAqIEBleHRlbmRzIFByb3RvQnVmLlJlZmxlY3QuVFxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdmFyIE1ldGhvZCA9IGZ1bmN0aW9uKHN2YywgbmFtZSwgb3B0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgVC5jYWxsKHRoaXMsIHN2YywgbmFtZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBAb3ZlcnJpZGVcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jbGFzc05hbWUgPSBcIlNlcnZpY2UuTWV0aG9kXCI7XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBPcHRpb25zLlxyXG4gICAgICAgICAgICAgICAgICogQHR5cGUge09iamVjdC48c3RyaW5nLCAqPn1cclxuICAgICAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8vIEV4dGVuZHMgVFxyXG4gICAgICAgICAgICBNZXRob2QucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShULnByb3RvdHlwZSk7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQnVpbGRzIHRoZSBtZXRob2QncyAnJG9wdGlvbnMnIHByb3BlcnR5LlxyXG4gICAgICAgICAgICAgKiBAbmFtZSBQcm90b0J1Zi5SZWZsZWN0LlNlcnZpY2UuTWV0aG9kI2J1aWxkT3B0XHJcbiAgICAgICAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3QuPHN0cmluZywqPn1cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIE1ldGhvZC5wcm90b3R5cGUuYnVpbGRPcHQgPSBOYW1lc3BhY2UucHJvdG90eXBlLmJ1aWxkT3B0O1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEBhbGlhcyBQcm90b0J1Zi5SZWZsZWN0LlNlcnZpY2UuTWV0aG9kXHJcbiAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFJlZmxlY3QuU2VydmljZS5NZXRob2QgPSBNZXRob2Q7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUlBDIHNlcnZpY2UgbWV0aG9kLlxyXG4gICAgICAgICAgICAgKiBAZXhwb3J0cyBQcm90b0J1Zi5SZWZsZWN0LlNlcnZpY2UuUlBDTWV0aG9kXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7IVByb3RvQnVmLlJlZmxlY3QuU2VydmljZX0gc3ZjIFNlcnZpY2VcclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgTWV0aG9kIG5hbWVcclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHJlcXVlc3QgUmVxdWVzdCBtZXNzYWdlIG5hbWVcclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHJlc3BvbnNlIFJlc3BvbnNlIG1lc3NhZ2UgbmFtZVxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+PX0gb3B0aW9ucyBPcHRpb25zXHJcbiAgICAgICAgICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICAgICAgICAgKiBAZXh0ZW5kcyBQcm90b0J1Zi5SZWZsZWN0LlNlcnZpY2UuTWV0aG9kXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB2YXIgUlBDTWV0aG9kID0gZnVuY3Rpb24oc3ZjLCBuYW1lLCByZXF1ZXN0LCByZXNwb25zZSwgb3B0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgTWV0aG9kLmNhbGwodGhpcywgc3ZjLCBuYW1lLCBvcHRpb25zKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEBvdmVycmlkZVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLmNsYXNzTmFtZSA9IFwiU2VydmljZS5SUENNZXRob2RcIjtcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFJlcXVlc3QgbWVzc2FnZSBuYW1lLlxyXG4gICAgICAgICAgICAgICAgICogQHR5cGUge3N0cmluZ31cclxuICAgICAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZXF1ZXN0TmFtZSA9IHJlcXVlc3Q7XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBSZXNwb25zZSBtZXNzYWdlIG5hbWUuXHJcbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAgICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3BvbnNlTmFtZSA9IHJlc3BvbnNlO1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogUmVzb2x2ZWQgcmVxdWVzdCBtZXNzYWdlIHR5cGUuXHJcbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7UHJvdG9CdWYuUmVmbGVjdC5NZXNzYWdlfVxyXG4gICAgICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlc29sdmVkUmVxdWVzdFR5cGUgPSBudWxsO1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogUmVzb2x2ZWQgcmVzcG9uc2UgbWVzc2FnZSB0eXBlLlxyXG4gICAgICAgICAgICAgICAgICogQHR5cGUge1Byb3RvQnVmLlJlZmxlY3QuTWVzc2FnZX1cclxuICAgICAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZXNvbHZlZFJlc3BvbnNlVHlwZSA9IG51bGw7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvLyBFeHRlbmRzIE1ldGhvZFxyXG4gICAgICAgICAgICBSUENNZXRob2QucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShNZXRob2QucHJvdG90eXBlKTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBAYWxpYXMgUHJvdG9CdWYuUmVmbGVjdC5TZXJ2aWNlLlJQQ01ldGhvZFxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBSZWZsZWN0LlNlcnZpY2UuUlBDTWV0aG9kID0gUlBDTWV0aG9kO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3Q7XHJcbiAgICAgICAgfSkoUHJvdG9CdWYpO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAYWxpYXMgUHJvdG9CdWYuQnVpbGRlclxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBQcm90b0J1Zi5CdWlsZGVyID0gKGZ1bmN0aW9uKFByb3RvQnVmLCBMYW5nLCBSZWZsZWN0KSB7XHJcbiAgICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgQnVpbGRlci5cclxuICAgICAgICAgICAgICogQGV4cG9ydHMgUHJvdG9CdWYuQnVpbGRlclxyXG4gICAgICAgICAgICAgKiBAY2xhc3MgUHJvdmlkZXMgdGhlIGZ1bmN0aW9uYWxpdHkgdG8gYnVpbGQgcHJvdG9jb2wgbWVzc2FnZXMuXHJcbiAgICAgICAgICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdmFyIEJ1aWxkZXIgPSBmdW5jdGlvbigpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIE5hbWVzcGFjZS5cclxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtQcm90b0J1Zi5SZWZsZWN0Lk5hbWVzcGFjZX1cclxuICAgICAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ucyA9IG5ldyBSZWZsZWN0Lk5hbWVzcGFjZShudWxsLCBcIlwiKTsgLy8gR2xvYmFsIG5hbWVzcGFjZVxyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogTmFtZXNwYWNlIHBvaW50ZXIuXHJcbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7UHJvdG9CdWYuUmVmbGVjdC5UfVxyXG4gICAgICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLnB0ciA9IHRoaXMubnM7XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBSZXNvbHZlZCBmbGFnLlxyXG4gICAgICAgICAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMucmVzb2x2ZWQgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFRoZSBjdXJyZW50IGJ1aWxkaW5nIHJlc3VsdC5cclxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZyxQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2V8T2JqZWN0PnxudWxsfVxyXG4gICAgICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdCA9IG51bGw7XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBJbXBvcnRlZCBmaWxlcy5cclxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtBcnJheS48c3RyaW5nPn1cclxuICAgICAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5maWxlcyA9IHt9O1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogSW1wb3J0IHJvb3Qgb3ZlcnJpZGUuXHJcbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7P3N0cmluZ31cclxuICAgICAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbXBvcnRSb290ID0gbnVsbDtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBSZXNldHMgdGhlIHBvaW50ZXIgdG8gdGhlIHJvb3QgbmFtZXNwYWNlLlxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBCdWlsZGVyLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wdHIgPSB0aGlzLm5zO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIERlZmluZXMgYSBwYWNrYWdlIG9uIHRvcCBvZiB0aGUgY3VycmVudCBwb2ludGVyIHBvc2l0aW9uIGFuZCBwbGFjZXMgdGhlIHBvaW50ZXIgb24gaXQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwa2dcclxuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPj19IG9wdGlvbnNcclxuICAgICAgICAgICAgICogQHJldHVybiB7UHJvdG9CdWYuQnVpbGRlcn0gdGhpc1xyXG4gICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBhY2thZ2UgbmFtZSBpcyBpbnZhbGlkXHJcbiAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEJ1aWxkZXIucHJvdG90eXBlLmRlZmluZSA9IGZ1bmN0aW9uKHBrZywgb3B0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwa2cgIT09ICdzdHJpbmcnIHx8ICFMYW5nLlRZUEVSRUYudGVzdChwa2cpKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCBwYWNrYWdlOiBcIitwa2cpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHBhcnQgPSBwa2cuc3BsaXQoXCIuXCIpLCBpO1xyXG4gICAgICAgICAgICAgICAgZm9yIChpPTA7IGk8cGFydC5sZW5ndGg7IGkrKykgLy8gVG8gYmUgYWJzb2x1dGVseSBzdXJlXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFMYW5nLk5BTUUudGVzdChwYXJ0W2ldKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIHBhY2thZ2U6IFwiK3BhcnRbaV0pO1xyXG4gICAgICAgICAgICAgICAgZm9yIChpPTA7IGk8cGFydC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5wdHIuaGFzQ2hpbGQocGFydFtpXSkpIC8vIEtlZXAgZXhpc3RpbmcgbmFtZXNwYWNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHRyLmFkZENoaWxkKG5ldyBSZWZsZWN0Lk5hbWVzcGFjZSh0aGlzLnB0ciwgcGFydFtpXSwgb3B0aW9ucykpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHRyID0gdGhpcy5wdHIuZ2V0Q2hpbGQocGFydFtpXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUZXN0cyBpZiBhIGRlZmluaXRpb24gaXMgYSB2YWxpZCBtZXNzYWdlIGRlZmluaXRpb24uXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IGRlZiBEZWZpbml0aW9uXHJcbiAgICAgICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgdmFsaWQsIGVsc2UgZmFsc2VcclxuICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQnVpbGRlci5pc1ZhbGlkTWVzc2FnZSA9IGZ1bmN0aW9uKGRlZikge1xyXG4gICAgICAgICAgICAgICAgLy8gTWVzc2FnZXMgcmVxdWlyZSBhIHN0cmluZyBuYW1lXHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGRlZltcIm5hbWVcIl0gIT09ICdzdHJpbmcnIHx8ICFMYW5nLk5BTUUudGVzdChkZWZbXCJuYW1lXCJdKSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAvLyBNZXNzYWdlcyBtdXN0IG5vdCBjb250YWluIHZhbHVlcyAodGhhdCdkIGJlIGFuIGVudW0pIG9yIG1ldGhvZHMgKHRoYXQnZCBiZSBhIHNlcnZpY2UpXHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGRlZltcInZhbHVlc1wiXSAhPT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIGRlZltcInJwY1wiXSAhPT0gJ3VuZGVmaW5lZCcpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgLy8gRmllbGRzLCBlbnVtcyBhbmQgbWVzc2FnZXMgYXJlIGFycmF5cyBpZiBwcm92aWRlZFxyXG4gICAgICAgICAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGRlZltcImZpZWxkc1wiXSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIVByb3RvQnVmLlV0aWwuaXNBcnJheShkZWZbXCJmaWVsZHNcIl0pKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlkcyA9IFtdLCBpZDsgLy8gSURzIG11c3QgYmUgdW5pcXVlXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpPTA7IGk8ZGVmW1wiZmllbGRzXCJdLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghQnVpbGRlci5pc1ZhbGlkTWVzc2FnZUZpZWxkKGRlZltcImZpZWxkc1wiXVtpXSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkID0gcGFyc2VJbnQoZGVmW1wiZmllbGRzXCJdW2ldW1wiaWRcIl0sIDEwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlkcy5pbmRleE9mKGlkKSA+PSAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZHMucHVzaChpZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlkcyA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGRlZltcImVudW1zXCJdICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghUHJvdG9CdWYuVXRpbC5pc0FycmF5KGRlZltcImVudW1zXCJdKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaT0wOyBpPGRlZltcImVudW1zXCJdLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIUJ1aWxkZXIuaXNWYWxpZEVudW0oZGVmW1wiZW51bXNcIl1baV0pKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkZWZbXCJtZXNzYWdlc1wiXSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIVByb3RvQnVmLlV0aWwuaXNBcnJheShkZWZbXCJtZXNzYWdlc1wiXSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGk9MDsgaTxkZWZbXCJtZXNzYWdlc1wiXS5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFCdWlsZGVyLmlzVmFsaWRNZXNzYWdlKGRlZltcIm1lc3NhZ2VzXCJdW2ldKSAmJiAhQnVpbGRlci5pc1ZhbGlkRXh0ZW5kKGRlZltcIm1lc3NhZ2VzXCJdW2ldKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZGVmW1wiZXh0ZW5zaW9uc1wiXSAhPT0gJ3VuZGVmaW5lZCcpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFQcm90b0J1Zi5VdGlsLmlzQXJyYXkoZGVmW1wiZXh0ZW5zaW9uc1wiXSkgfHwgZGVmW1wiZXh0ZW5zaW9uc1wiXS5sZW5ndGggIT09IDIgfHwgdHlwZW9mIGRlZltcImV4dGVuc2lvbnNcIl1bMF0gIT09ICdudW1iZXInIHx8IHR5cGVvZiBkZWZbXCJleHRlbnNpb25zXCJdWzFdICE9PSAnbnVtYmVyJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGVzdHMgaWYgYSBkZWZpbml0aW9uIGlzIGEgdmFsaWQgbWVzc2FnZSBmaWVsZCBkZWZpbml0aW9uLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZGVmIERlZmluaXRpb25cclxuICAgICAgICAgICAgICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiB2YWxpZCwgZWxzZSBmYWxzZVxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBCdWlsZGVyLmlzVmFsaWRNZXNzYWdlRmllbGQgPSBmdW5jdGlvbihkZWYpIHtcclxuICAgICAgICAgICAgICAgIC8vIE1lc3NhZ2UgZmllbGRzIHJlcXVpcmUgYSBzdHJpbmcgcnVsZSwgbmFtZSBhbmQgdHlwZSBhbmQgYW4gaWRcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZGVmW1wicnVsZVwiXSAhPT0gJ3N0cmluZycgfHwgdHlwZW9mIGRlZltcIm5hbWVcIl0gIT09ICdzdHJpbmcnIHx8IHR5cGVvZiBkZWZbXCJ0eXBlXCJdICE9PSAnc3RyaW5nJyB8fCB0eXBlb2YgZGVmW1wiaWRcIl0gPT09ICd1bmRlZmluZWQnKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGlmICghTGFuZy5SVUxFLnRlc3QoZGVmW1wicnVsZVwiXSkgfHwgIUxhbmcuTkFNRS50ZXN0KGRlZltcIm5hbWVcIl0pIHx8ICFMYW5nLlRZUEVSRUYudGVzdChkZWZbXCJ0eXBlXCJdKSB8fCAhTGFuZy5JRC50ZXN0KFwiXCIrZGVmW1wiaWRcIl0pKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZGVmW1wib3B0aW9uc1wiXSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBPcHRpb25zIGFyZSBvYmplY3RzXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkZWZbXCJvcHRpb25zXCJdICE9PSAnb2JqZWN0JylcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIE9wdGlvbnMgYXJlIDxzdHJpbmcsc3RyaW5nfG51bWJlcnxib29sZWFuPlxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZGVmW1wib3B0aW9uc1wiXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaT0wLCBrZXk7IGk8a2V5cy5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAoa2V5ID0ga2V5c1tpXSkgIT09ICdzdHJpbmcnIHx8ICh0eXBlb2YgZGVmW1wib3B0aW9uc1wiXVtrZXldICE9PSAnc3RyaW5nJyAmJiB0eXBlb2YgZGVmW1wib3B0aW9uc1wiXVtrZXldICE9PSAnbnVtYmVyJyAmJiB0eXBlb2YgZGVmW1wib3B0aW9uc1wiXVtrZXldICE9PSAnYm9vbGVhbicpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGVzdHMgaWYgYSBkZWZpbml0aW9uIGlzIGEgdmFsaWQgZW51bSBkZWZpbml0aW9uLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZGVmIERlZmluaXRpb25cclxuICAgICAgICAgICAgICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiB2YWxpZCwgZWxzZSBmYWxzZVxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBCdWlsZGVyLmlzVmFsaWRFbnVtID0gZnVuY3Rpb24oZGVmKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBFbnVtcyByZXF1aXJlIGEgc3RyaW5nIG5hbWVcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZGVmW1wibmFtZVwiXSAhPT0gJ3N0cmluZycgfHwgIUxhbmcuTkFNRS50ZXN0KGRlZltcIm5hbWVcIl0pKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIC8vIEVudW1zIHJlcXVpcmUgYXQgbGVhc3Qgb25lIHZhbHVlXHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGRlZltcInZhbHVlc1wiXSA9PT0gJ3VuZGVmaW5lZCcgfHwgIVByb3RvQnVmLlV0aWwuaXNBcnJheShkZWZbXCJ2YWx1ZXNcIl0pIHx8IGRlZltcInZhbHVlc1wiXS5sZW5ndGggPT0gMClcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8ZGVmW1widmFsdWVzXCJdLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVmFsdWVzIGFyZSBvYmplY3RzXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkZWZbXCJ2YWx1ZXNcIl1baV0gIT0gXCJvYmplY3RcIilcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFZhbHVlcyByZXF1aXJlIGEgc3RyaW5nIG5hbWUgYW5kIGFuIGlkXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkZWZbXCJ2YWx1ZXNcIl1baV1bXCJuYW1lXCJdICE9PSAnc3RyaW5nJyB8fCB0eXBlb2YgZGVmW1widmFsdWVzXCJdW2ldW1wiaWRcIl0gPT09ICd1bmRlZmluZWQnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFMYW5nLk5BTUUudGVzdChkZWZbXCJ2YWx1ZXNcIl1baV1bXCJuYW1lXCJdKSB8fCAhTGFuZy5ORUdJRC50ZXN0KFwiXCIrZGVmW1widmFsdWVzXCJdW2ldW1wiaWRcIl0pKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBJdCdzIG5vdCBpbXBvcnRhbnQgaWYgdGhlcmUgYXJlIG90aGVyIGZpZWxkcyBiZWNhdXNlIFtcInZhbHVlc1wiXSBpcyBhbHJlYWR5IHVuaXF1ZVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQ3JlYXRlcyB0aHMgc3BlY2lmaWVkIHByb3RvY29sIHR5cGVzIGF0IHRoZSBjdXJyZW50IHBvaW50ZXIgcG9zaXRpb24uXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXkuPE9iamVjdC48c3RyaW5nLCo+Pn0gZGVmcyBNZXNzYWdlcywgZW51bXMgb3Igc2VydmljZXMgdG8gY3JlYXRlXHJcbiAgICAgICAgICAgICAqIEByZXR1cm4ge1Byb3RvQnVmLkJ1aWxkZXJ9IHRoaXNcclxuICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIGEgbWVzc2FnZSBkZWZpbml0aW9uIGlzIGludmFsaWRcclxuICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQnVpbGRlci5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24oZGVmcykge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFkZWZzKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzOyAvLyBOb3RoaW5nIHRvIGNyZWF0ZVxyXG4gICAgICAgICAgICAgICAgaWYgKCFQcm90b0J1Zi5VdGlsLmlzQXJyYXkoZGVmcykpXHJcbiAgICAgICAgICAgICAgICAgICAgZGVmcyA9IFtkZWZzXTtcclxuICAgICAgICAgICAgICAgIGlmIChkZWZzLmxlbmd0aCA9PSAwKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEl0J3MgcXVpdGUgaGFyZCB0byBrZWVwIHRyYWNrIG9mIHNjb3BlcyBhbmQgbWVtb3J5IGhlcmUsIHNvIGxldCdzIGRvIHRoaXMgaXRlcmF0aXZlbHkuXHJcbiAgICAgICAgICAgICAgICB2YXIgc3RhY2sgPSBbXSwgZGVmLCBvYmosIHN1Yk9iaiwgaSwgajtcclxuICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goZGVmcyk7IC8vIE9uZSBsZXZlbCBbYSwgYiwgY11cclxuICAgICAgICAgICAgICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmcyA9IHN0YWNrLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChQcm90b0J1Zi5VdGlsLmlzQXJyYXkoZGVmcykpIHsgLy8gU3RhY2sgYWx3YXlzIGNvbnRhaW5zIGVudGlyZSBuYW1lc3BhY2VzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChkZWZzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZiA9IGRlZnMuc2hpZnQoKTsgLy8gTmFtZXNwYWNlIGFsd2F5cyBjb250YWlucyBhbiBhcnJheSBvZiBtZXNzYWdlcywgZW51bXMgYW5kIHNlcnZpY2VzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoQnVpbGRlci5pc1ZhbGlkTWVzc2FnZShkZWYpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqID0gbmV3IFJlZmxlY3QuTWVzc2FnZSh0aGlzLnB0ciwgZGVmW1wibmFtZVwiXSwgZGVmW1wib3B0aW9uc1wiXSwgZGVmW1wiaXNHcm91cFwiXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGZpZWxkc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWZbXCJmaWVsZHNcIl0gJiYgZGVmW1wiZmllbGRzXCJdLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpPTA7IGk8ZGVmW1wiZmllbGRzXCJdLmxlbmd0aDsgaSsrKSB7IC8vIGk9RmllbGRzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob2JqLmhhc0NoaWxkKGRlZlsnZmllbGRzJ11baV1bJ2lkJ10pKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiRHVwbGljYXRlIGZpZWxkIGlkIGluIG1lc3NhZ2UgXCIrb2JqLm5hbWUrXCI6IFwiK2RlZlsnZmllbGRzJ11baV1bJ2lkJ10pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlZltcImZpZWxkc1wiXVtpXVtcIm9wdGlvbnNcIl0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJPYmogPSBPYmplY3Qua2V5cyhkZWZbXCJmaWVsZHNcIl1baV1bXCJvcHRpb25zXCJdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGo9MDsgajxzdWJPYmoubGVuZ3RoOyBqKyspIHsgLy8gaj1PcHRpb24gbmFtZXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzdWJPYmpbal0gIT09ICdzdHJpbmcnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIGZpZWxkIG9wdGlvbiBuYW1lIGluIG1lc3NhZ2UgXCIrb2JqLm5hbWUrXCIjXCIrZGVmW1wiZmllbGRzXCJdW2ldW1wibmFtZVwiXStcIjogXCIrc3ViT2JqW2pdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkZWZbXCJmaWVsZHNcIl1baV1bXCJvcHRpb25zXCJdW3N1Yk9ialtqXV0gIT09ICdzdHJpbmcnICYmIHR5cGVvZiBkZWZbXCJmaWVsZHNcIl1baV1bXCJvcHRpb25zXCJdW3N1Yk9ialtqXV0gIT09ICdudW1iZXInICYmIHR5cGVvZiBkZWZbXCJmaWVsZHNcIl1baV1bXCJvcHRpb25zXCJdW3N1Yk9ialtqXV0gIT09ICdib29sZWFuJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCBmaWVsZCBvcHRpb24gdmFsdWUgaW4gbWVzc2FnZSBcIitvYmoubmFtZStcIiNcIitkZWZbXCJmaWVsZHNcIl1baV1bXCJuYW1lXCJdK1wiI1wiK3N1Yk9ialtqXStcIjogXCIrZGVmW1wiZmllbGRzXCJdW2ldW1wib3B0aW9uc1wiXVtzdWJPYmpbal1dKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViT2JqID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iai5hZGRDaGlsZChuZXcgUmVmbGVjdC5NZXNzYWdlLkZpZWxkKG9iaiwgZGVmW1wiZmllbGRzXCJdW2ldW1wicnVsZVwiXSwgZGVmW1wiZmllbGRzXCJdW2ldW1widHlwZVwiXSwgZGVmW1wiZmllbGRzXCJdW2ldW1wibmFtZVwiXSwgZGVmW1wiZmllbGRzXCJdW2ldW1wiaWRcIl0sIGRlZltcImZpZWxkc1wiXVtpXVtcIm9wdGlvbnNcIl0pKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBQdXNoIGVudW1zIGFuZCBtZXNzYWdlcyB0byBzdGFja1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Yk9iaiA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZGVmW1wiZW51bXNcIl0gIT09ICd1bmRlZmluZWQnICYmIGRlZlsnZW51bXMnXS5sZW5ndGggPiAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGk9MDsgaTxkZWZbXCJlbnVtc1wiXS5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Yk9iai5wdXNoKGRlZltcImVudW1zXCJdW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVmW1wibWVzc2FnZXNcIl0gJiYgZGVmW1wibWVzc2FnZXNcIl0ubGVuZ3RoID4gMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpPTA7IGk8ZGVmW1wibWVzc2FnZXNcIl0ubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJPYmoucHVzaChkZWZbXCJtZXNzYWdlc1wiXVtpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2V0IGV4dGVuc2lvbiByYW5nZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWZbXCJleHRlbnNpb25zXCJdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iai5leHRlbnNpb25zID0gZGVmW1wiZXh0ZW5zaW9uc1wiXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9iai5leHRlbnNpb25zWzBdIDwgUHJvdG9CdWYuSURfTUlOKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqLmV4dGVuc2lvbnNbMF0gPSBQcm90b0J1Zi5JRF9NSU47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvYmouZXh0ZW5zaW9uc1sxXSA+IFByb3RvQnVmLklEX01BWClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iai5leHRlbnNpb25zWzFdID0gUHJvdG9CdWYuSURfTUFYO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnB0ci5hZGRDaGlsZChvYmopOyAvLyBBZGQgdG8gY3VycmVudCBuYW1lc3BhY2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3ViT2JqLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaChkZWZzKTsgLy8gUHVzaCB0aGUgY3VycmVudCBsZXZlbCBiYWNrXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZnMgPSBzdWJPYmo7IC8vIENvbnRpbnVlIHByb2Nlc3Npbmcgc3ViIGxldmVsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Yk9iaiA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHRyID0gb2JqOyAvLyBBbmQgbW92ZSB0aGUgcG9pbnRlciB0byB0aGlzIG5hbWVzcGFjZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmogPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViT2JqID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmogPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChCdWlsZGVyLmlzVmFsaWRFbnVtKGRlZikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmogPSBuZXcgUmVmbGVjdC5FbnVtKHRoaXMucHRyLCBkZWZbXCJuYW1lXCJdLCBkZWZbXCJvcHRpb25zXCJdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGk9MDsgaTxkZWZbXCJ2YWx1ZXNcIl0ubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iai5hZGRDaGlsZChuZXcgUmVmbGVjdC5FbnVtLlZhbHVlKG9iaiwgZGVmW1widmFsdWVzXCJdW2ldW1wibmFtZVwiXSwgZGVmW1widmFsdWVzXCJdW2ldW1wiaWRcIl0pKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnB0ci5hZGRDaGlsZChvYmopO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iaiA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKEJ1aWxkZXIuaXNWYWxpZFNlcnZpY2UoZGVmKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iaiA9IG5ldyBSZWZsZWN0LlNlcnZpY2UodGhpcy5wdHIsIGRlZltcIm5hbWVcIl0sIGRlZltcIm9wdGlvbnNcIl0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSBpbiBkZWZbXCJycGNcIl0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWZbXCJycGNcIl0uaGFzT3duUHJvcGVydHkoaSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmouYWRkQ2hpbGQobmV3IFJlZmxlY3QuU2VydmljZS5SUENNZXRob2Qob2JqLCBpLCBkZWZbXCJycGNcIl1baV1bXCJyZXF1ZXN0XCJdLCBkZWZbXCJycGNcIl1baV1bXCJyZXNwb25zZVwiXSwgZGVmW1wicnBjXCJdW2ldW1wib3B0aW9uc1wiXSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHRyLmFkZENoaWxkKG9iaik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoQnVpbGRlci5pc1ZhbGlkRXh0ZW5kKGRlZikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmogPSB0aGlzLnB0ci5yZXNvbHZlKGRlZltcInJlZlwiXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9iaikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGk9MDsgaTxkZWZbXCJmaWVsZHNcIl0ubGVuZ3RoOyBpKyspIHsgLy8gaT1GaWVsZHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvYmouaGFzQ2hpbGQoZGVmWydmaWVsZHMnXVtpXVsnaWQnXSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJEdXBsaWNhdGUgZXh0ZW5kZWQgZmllbGQgaWQgaW4gbWVzc2FnZSBcIitvYmoubmFtZStcIjogXCIrZGVmWydmaWVsZHMnXVtpXVsnaWQnXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVmWydmaWVsZHMnXVtpXVsnaWQnXSA8IG9iai5leHRlbnNpb25zWzBdIHx8IGRlZlsnZmllbGRzJ11baV1bJ2lkJ10gPiBvYmouZXh0ZW5zaW9uc1sxXSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIklsbGVnYWwgZXh0ZW5kZWQgZmllbGQgaWQgaW4gbWVzc2FnZSBcIitvYmoubmFtZStcIjogXCIrZGVmWydmaWVsZHMnXVtpXVsnaWQnXStcIiAoXCIrb2JqLmV4dGVuc2lvbnMuam9pbignIHRvICcpK1wiIGV4cGVjdGVkKVwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IFNlZSAjMTYxXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBzdWJPYmogPSBuZXcgKHRoaXMucHRyIGluc3RhbmNlb2YgUmVmbGVjdC5NZXNzYWdlID8gUmVmbGVjdC5NZXNzYWdlLkV4dGVuc2lvbkZpZWxkIDogUmVmbGVjdC5NZXNzYWdlLkZpZWxkKShvYmosIGRlZltcImZpZWxkc1wiXVtpXVtcInJ1bGVcIl0sIGRlZltcImZpZWxkc1wiXVtpXVtcInR5cGVcIl0sIGRlZltcImZpZWxkc1wiXVtpXVtcIm5hbWVcIl0sIGRlZltcImZpZWxkc1wiXVtpXVtcImlkXCJdLCBkZWZbXCJmaWVsZHNcIl1baV1bXCJvcHRpb25zXCJdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnB0ciBpbnN0YW5jZW9mIFJlZmxlY3QuTWVzc2FnZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnB0ci5hZGRDaGlsZChzdWJPYmopO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iai5hZGRDaGlsZChzdWJPYmopOyAqL1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqLmFkZENoaWxkKG5ldyBSZWZsZWN0Lk1lc3NhZ2UuRmllbGQob2JqLCBkZWZbXCJmaWVsZHNcIl1baV1bXCJydWxlXCJdLCBkZWZbXCJmaWVsZHNcIl1baV1bXCJ0eXBlXCJdLCBkZWZbXCJmaWVsZHNcIl1baV1bXCJuYW1lXCJdLCBkZWZbXCJmaWVsZHNcIl1baV1bXCJpZFwiXSwgZGVmW1wiZmllbGRzXCJdW2ldW1wib3B0aW9uc1wiXSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICghL1xcLj9nb29nbGVcXC5wcm90b2J1ZlxcLi8udGVzdChkZWZbXCJyZWZcIl0pKSAvLyBTaWxlbnRseSBza2lwIGludGVybmFsIGV4dGVuc2lvbnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJFeHRlbmRlZCBtZXNzYWdlIFwiK2RlZltcInJlZlwiXStcIiBpcyBub3QgZGVmaW5lZFwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiTm90IGEgdmFsaWQgZGVmaW5pdGlvbjogXCIrSlNPTi5zdHJpbmdpZnkoZGVmKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWYgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJyZWFrIGdvZXMgaGVyZVxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIk5vdCBhIHZhbGlkIG5hbWVzcGFjZTogXCIrSlNPTi5zdHJpbmdpZnkoZGVmcykpO1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZnMgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHRyID0gdGhpcy5wdHIucGFyZW50OyAvLyBUaGlzIG5hbWVzcGFjZSBpcyBzIGRvbmVcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMucmVzb2x2ZWQgPSBmYWxzZTsgLy8gUmVxdWlyZSByZS1yZXNvbHZlXHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdCA9IG51bGw7IC8vIFJlcXVpcmUgcmUtYnVpbGRcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEltcG9ydHMgYW5vdGhlciBkZWZpbml0aW9uIGludG8gdGhpcyBidWlsZGVyLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBqc29uIFBhcnNlZCBpbXBvcnRcclxuICAgICAgICAgICAgICogQHBhcmFtIHsoc3RyaW5nfHtyb290OiBzdHJpbmcsIGZpbGU6IHN0cmluZ30pPX0gZmlsZW5hbWUgSW1wb3J0ZWQgZmlsZSBuYW1lXHJcbiAgICAgICAgICAgICAqIEByZXR1cm4ge1Byb3RvQnVmLkJ1aWxkZXJ9IHRoaXNcclxuICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBkZWZpbml0aW9uIG9yIGZpbGUgY2Fubm90IGJlIGltcG9ydGVkXHJcbiAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEJ1aWxkZXIucHJvdG90eXBlW1wiaW1wb3J0XCJdID0gZnVuY3Rpb24oanNvbiwgZmlsZW5hbWUpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZmlsZW5hbWUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKFByb3RvQnVmLlV0aWwuSVNfTk9ERSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZW5hbWUgPSByZXF1aXJlKFwicGF0aFwiKVsncmVzb2x2ZSddKGZpbGVuYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5maWxlc1tmaWxlbmFtZV0gPT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpczsgLy8gU2tpcCBkdXBsaWNhdGUgaW1wb3J0c1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbGVzW2ZpbGVuYW1lXSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoISFqc29uWydpbXBvcnRzJ10gJiYganNvblsnaW1wb3J0cyddLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaW1wb3J0Um9vdCwgZGVsaW0gPSAnLycsIHJlc2V0Um9vdCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZmlsZW5hbWUgPT09ICdvYmplY3QnKSB7IC8vIElmIGFuIGltcG9ydCByb290IGlzIHNwZWNpZmllZCwgb3ZlcnJpZGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbXBvcnRSb290ID0gZmlsZW5hbWVbXCJyb290XCJdOyByZXNldFJvb3QgPSB0cnVlOyAvLyAuLi4gYW5kIHJlc2V0IGFmdGVyd2FyZHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW1wb3J0Um9vdCA9IHRoaXMuaW1wb3J0Um9vdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZW5hbWUgPSBmaWxlbmFtZVtcImZpbGVcIl07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbXBvcnRSb290LmluZGV4T2YoXCJcXFxcXCIpID49IDAgfHwgZmlsZW5hbWUuaW5kZXhPZihcIlxcXFxcIikgPj0gMCkgZGVsaW0gPSAnXFxcXCc7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZmlsZW5hbWUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmltcG9ydFJvb3QpIC8vIElmIGltcG9ydCByb290IGlzIG92ZXJyaWRkZW4sIHVzZSBpdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1wb3J0Um9vdCA9IHRoaXMuaW1wb3J0Um9vdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7IC8vIE90aGVyd2lzZSBjb21wdXRlIGZyb20gZmlsZW5hbWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaWxlbmFtZS5pbmRleE9mKFwiL1wiKSA+PSAwKSB7IC8vIFVuaXhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbXBvcnRSb290ID0gZmlsZW5hbWUucmVwbGFjZSgvXFwvW15cXC9dKiQvLCBcIlwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoLyogL2ZpbGUucHJvdG8gKi8gaW1wb3J0Um9vdCA9PT0gXCJcIilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1wb3J0Um9vdCA9IFwiL1wiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChmaWxlbmFtZS5pbmRleE9mKFwiXFxcXFwiKSA+PSAwKSB7IC8vIFdpbmRvd3NcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbXBvcnRSb290ID0gZmlsZW5hbWUucmVwbGFjZSgvXFxcXFteXFxcXF0qJC8sIFwiXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGltID0gJ1xcXFwnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1wb3J0Um9vdCA9IFwiLlwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGltcG9ydFJvb3QgPSBudWxsO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8anNvblsnaW1wb3J0cyddLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YganNvblsnaW1wb3J0cyddW2ldID09PSAnc3RyaW5nJykgeyAvLyBJbXBvcnQgZmlsZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpbXBvcnRSb290KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiQ2Fubm90IGRldGVybWluZSBpbXBvcnQgcm9vdDogRmlsZSBuYW1lIGlzIHVua25vd25cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW1wb3J0RmlsZW5hbWUgPSBqc29uWydpbXBvcnRzJ11baV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoL15nb29nbGVcXC9wcm90b2J1ZlxcLy8udGVzdChpbXBvcnRGaWxlbmFtZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7IC8vIE5vdCBuZWVkZWQgYW5kIHRoZXJlZm9yZSBub3QgdXNlZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1wb3J0RmlsZW5hbWUgPSBpbXBvcnRSb290K2RlbGltK2ltcG9ydEZpbGVuYW1lO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZmlsZXNbaW1wb3J0RmlsZW5hbWVdID09PSB0cnVlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlOyAvLyBBbHJlYWR5IGltcG9ydGVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoL1xcLnByb3RvJC9pLnRlc3QoaW1wb3J0RmlsZW5hbWUpICYmICFQcm90b0J1Zi5Eb3RQcm90bykgICAgIC8vIElmIHRoaXMgaXMgYSBOT1BBUlNFIGJ1aWxkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1wb3J0RmlsZW5hbWUgPSBpbXBvcnRGaWxlbmFtZS5yZXBsYWNlKC9cXC5wcm90byQvLCBcIi5qc29uXCIpOyAvLyBhbHdheXMgbG9hZCB0aGUgSlNPTiBmaWxlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29udGVudHMgPSBQcm90b0J1Zi5VdGlsLmZldGNoKGltcG9ydEZpbGVuYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250ZW50cyA9PT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIkZhaWxlZCB0byBpbXBvcnQgJ1wiK2ltcG9ydEZpbGVuYW1lK1wiJyBpbiAnXCIrZmlsZW5hbWUrXCInOiBGaWxlIG5vdCBmb3VuZFwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgvXFwuanNvbiQvaS50ZXN0KGltcG9ydEZpbGVuYW1lKSkgLy8gQWx3YXlzIHBvc3NpYmxlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1tcImltcG9ydFwiXShKU09OLnBhcnNlKGNvbnRlbnRzK1wiXCIpLCBpbXBvcnRGaWxlbmFtZSk7IC8vIE1heSB0aHJvd1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbXCJpbXBvcnRcIl0oKG5ldyBQcm90b0J1Zi5Eb3RQcm90by5QYXJzZXIoY29udGVudHMrXCJcIikpLnBhcnNlKCksIGltcG9ydEZpbGVuYW1lKTsgLy8gTWF5IHRocm93XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSAvLyBJbXBvcnQgc3RydWN0dXJlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWZpbGVuYW1lKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbXCJpbXBvcnRcIl0oanNvblsnaW1wb3J0cyddW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKC9cXC4oXFx3KykkLy50ZXN0KGZpbGVuYW1lKSkgLy8gV2l0aCBleHRlbnNpb246IEFwcGVuZCBfaW1wb3J0TiB0byB0aGUgbmFtZSBwb3J0aW9uIHRvIG1ha2UgaXQgdW5pcXVlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1tcImltcG9ydFwiXShqc29uWydpbXBvcnRzJ11baV0sIGZpbGVuYW1lLnJlcGxhY2UoL14oLispXFwuKFxcdyspJC8sIGZ1bmN0aW9uKCQwLCAkMSwgJDIpIHsgcmV0dXJuICQxK1wiX2ltcG9ydFwiK2krXCIuXCIrJDI7IH0pKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgLy8gV2l0aG91dCBleHRlbnNpb246IEFwcGVuZCBfaW1wb3J0TiB0byBtYWtlIGl0IHVuaXF1ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbXCJpbXBvcnRcIl0oanNvblsnaW1wb3J0cyddW2ldLCBmaWxlbmFtZStcIl9pbXBvcnRcIitpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc2V0Um9vdCkgLy8gUmVzZXQgaW1wb3J0IHJvb3Qgb3ZlcnJpZGUgd2hlbiBhbGwgaW1wb3J0cyBhcmUgZG9uZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmltcG9ydFJvb3QgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGpzb25bJ21lc3NhZ2VzJ10pIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoanNvblsncGFja2FnZSddKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRlZmluZShqc29uWydwYWNrYWdlJ10sIGpzb25bXCJvcHRpb25zXCJdKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZShqc29uWydtZXNzYWdlcyddKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc2V0KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoanNvblsnZW51bXMnXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChqc29uWydwYWNrYWdlJ10pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVmaW5lKGpzb25bJ3BhY2thZ2UnXSwganNvbltcIm9wdGlvbnNcIl0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlKGpzb25bJ2VudW1zJ10pO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChqc29uWydzZXJ2aWNlcyddKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGpzb25bJ3BhY2thZ2UnXSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWZpbmUoanNvblsncGFja2FnZSddLCBqc29uW1wib3B0aW9uc1wiXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jcmVhdGUoanNvblsnc2VydmljZXMnXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGpzb25bJ2V4dGVuZHMnXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChqc29uWydwYWNrYWdlJ10pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVmaW5lKGpzb25bJ3BhY2thZ2UnXSwganNvbltcIm9wdGlvbnNcIl0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlKGpzb25bJ2V4dGVuZHMnXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGVzdHMgaWYgYSBkZWZpbml0aW9uIGlzIGEgdmFsaWQgc2VydmljZSBkZWZpbml0aW9uLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZGVmIERlZmluaXRpb25cclxuICAgICAgICAgICAgICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiB2YWxpZCwgZWxzZSBmYWxzZVxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBCdWlsZGVyLmlzVmFsaWRTZXJ2aWNlID0gZnVuY3Rpb24oZGVmKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBTZXJ2aWNlcyByZXF1aXJlIGEgc3RyaW5nIG5hbWUgYW5kIGFuIHJwYyBvYmplY3RcclxuICAgICAgICAgICAgICAgIHJldHVybiAhKHR5cGVvZiBkZWZbXCJuYW1lXCJdICE9PSAnc3RyaW5nJyB8fCAhTGFuZy5OQU1FLnRlc3QoZGVmW1wibmFtZVwiXSkgfHwgdHlwZW9mIGRlZltcInJwY1wiXSAhPT0gJ29iamVjdCcpO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRlc3RzIGlmIGEgZGVmaW5pdGlvbiBpcyBhIHZhbGlkIGV4dGVuc2lvbi5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGRlZiBEZWZpbml0aW9uXHJcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHZhbGlkLCBlbHNlIGZhbHNlXHJcbiAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQnVpbGRlci5pc1ZhbGlkRXh0ZW5kID0gZnVuY3Rpb24oZGVmKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGRlZltcInJlZlwiXSAhPT0gJ3N0cmluZycgfHwgIUxhbmcuVFlQRVJFRi50ZXN0KGRlZltcInJlZlwiXSkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGRlZltcImZpZWxkc1wiXSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIVByb3RvQnVmLlV0aWwuaXNBcnJheShkZWZbXCJmaWVsZHNcIl0pKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlkcyA9IFtdLCBpZDsgLy8gSURzIG11c3QgYmUgdW5pcXVlIChkb2VzIG5vdCB5ZXQgdGVzdCBmb3IgdGhlIGV4dGVuZGVkIG1lc3NhZ2UncyBpZHMpXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpPTA7IGk8ZGVmW1wiZmllbGRzXCJdLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghQnVpbGRlci5pc1ZhbGlkTWVzc2FnZUZpZWxkKGRlZltcImZpZWxkc1wiXVtpXSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkID0gcGFyc2VJbnQoZGVmW1wiaWRcIl0sIDEwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlkcy5pbmRleE9mKGlkKSA+PSAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZHMucHVzaChpZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlkcyA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBSZXNvbHZlcyBhbGwgbmFtZXNwYWNlIG9iamVjdHMuXHJcbiAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiBhIHR5cGUgY2Fubm90IGJlIHJlc29sdmVkXHJcbiAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEJ1aWxkZXIucHJvdG90eXBlLnJlc29sdmVBbGwgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIC8vIFJlc29sdmUgYWxsIHJlZmxlY3RlZCBvYmplY3RzXHJcbiAgICAgICAgICAgICAgICB2YXIgcmVzO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucHRyID09IG51bGwgfHwgdHlwZW9mIHRoaXMucHRyLnR5cGUgPT09ICdvYmplY3QnKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjsgLy8gRG9uZSAoYWxyZWFkeSByZXNvbHZlZClcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnB0ciBpbnN0YW5jZW9mIFJlZmxlY3QuTmFtZXNwYWNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQnVpbGQgYWxsIGNoaWxkcmVuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5wdHIuZ2V0Q2hpbGRyZW4oKTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8Y2hpbGRyZW4ubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHRyID0gY2hpbGRyZW5baV0sIHRoaXMucmVzb2x2ZUFsbCgpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnB0ciBpbnN0YW5jZW9mIFJlZmxlY3QuTWVzc2FnZS5GaWVsZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghTGFuZy5UWVBFLnRlc3QodGhpcy5wdHIudHlwZSkpIHsgLy8gUmVzb2x2ZSB0eXBlLi4uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghTGFuZy5UWVBFUkVGLnRlc3QodGhpcy5wdHIudHlwZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIklsbGVnYWwgdHlwZSByZWZlcmVuY2UgaW4gXCIrdGhpcy5wdHIudG9TdHJpbmcodHJ1ZSkrXCI6IFwiK3RoaXMucHRyLnR5cGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXMgPSB0aGlzLnB0ci5wYXJlbnQucmVzb2x2ZSh0aGlzLnB0ci50eXBlLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIlVucmVzb2x2YWJsZSB0eXBlIHJlZmVyZW5jZSBpbiBcIit0aGlzLnB0ci50b1N0cmluZyh0cnVlKStcIjogXCIrdGhpcy5wdHIudHlwZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHRyLnJlc29sdmVkVHlwZSA9IHJlcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlcyBpbnN0YW5jZW9mIFJlZmxlY3QuRW51bSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHRyLnR5cGUgPSBQcm90b0J1Zi5UWVBFU1tcImVudW1cIl07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlcyBpbnN0YW5jZW9mIFJlZmxlY3QuTWVzc2FnZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHRyLnR5cGUgPSByZXMuaXNHcm91cCA/IFByb3RvQnVmLlRZUEVTW1wiZ3JvdXBcIl0gOiBQcm90b0J1Zi5UWVBFU1tcIm1lc3NhZ2VcIl07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCB0eXBlIHJlZmVyZW5jZSBpbiBcIit0aGlzLnB0ci50b1N0cmluZyh0cnVlKStcIjogXCIrdGhpcy5wdHIudHlwZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHRyLnR5cGUgPSBQcm90b0J1Zi5UWVBFU1t0aGlzLnB0ci50eXBlXTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5wdHIgaW5zdGFuY2VvZiBQcm90b0J1Zi5SZWZsZWN0LkVudW0uVmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBObyBuZWVkIHRvIGJ1aWxkIGVudW0gdmFsdWVzIChidWlsdCBpbiBlbnVtKVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnB0ciBpbnN0YW5jZW9mIFByb3RvQnVmLlJlZmxlY3QuU2VydmljZS5NZXRob2QpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wdHIgaW5zdGFuY2VvZiBQcm90b0J1Zi5SZWZsZWN0LlNlcnZpY2UuUlBDTWV0aG9kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcyA9IHRoaXMucHRyLnBhcmVudC5yZXNvbHZlKHRoaXMucHRyLnJlcXVlc3ROYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXMgfHwgIShyZXMgaW5zdGFuY2VvZiBQcm90b0J1Zi5SZWZsZWN0Lk1lc3NhZ2UpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIHR5cGUgcmVmZXJlbmNlIGluIFwiK3RoaXMucHRyLnRvU3RyaW5nKHRydWUpK1wiOiBcIit0aGlzLnB0ci5yZXF1ZXN0TmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHRyLnJlc29sdmVkUmVxdWVzdFR5cGUgPSByZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcyA9IHRoaXMucHRyLnBhcmVudC5yZXNvbHZlKHRoaXMucHRyLnJlc3BvbnNlTmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcmVzIHx8ICEocmVzIGluc3RhbmNlb2YgUHJvdG9CdWYuUmVmbGVjdC5NZXNzYWdlKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCB0eXBlIHJlZmVyZW5jZSBpbiBcIit0aGlzLnB0ci50b1N0cmluZyh0cnVlKStcIjogXCIrdGhpcy5wdHIucmVzcG9uc2VOYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wdHIucmVzb2x2ZWRSZXNwb25zZVR5cGUgPSByZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2hvdWxkIG5vdCBoYXBwZW4gYXMgbm90aGluZyBlbHNlIGlzIGltcGxlbWVudGVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCBzZXJ2aWNlIHR5cGUgaW4gXCIrdGhpcy5wdHIudG9TdHJpbmcodHJ1ZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCBvYmplY3QgaW4gbmFtZXNwYWNlOiBcIit0eXBlb2YodGhpcy5wdHIpK1wiOlwiK3RoaXMucHRyKTtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBCdWlsZHMgdGhlIHByb3RvY29sLiBUaGlzIHdpbGwgZmlyc3QgdHJ5IHRvIHJlc29sdmUgYWxsIGRlZmluaXRpb25zIGFuZCwgaWYgdGhpcyBoYXMgYmVlbiBzdWNjZXNzZnVsLFxyXG4gICAgICAgICAgICAgKiByZXR1cm4gdGhlIGJ1aWx0IHBhY2thZ2UuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nPX0gcGF0aCBTcGVjaWZpZXMgd2hhdCB0byByZXR1cm4uIElmIG9taXR0ZWQsIHRoZSBlbnRpcmUgbmFtZXNwYWNlIHdpbGwgYmUgcmV0dXJuZWQuXHJcbiAgICAgICAgICAgICAqIEByZXR1cm4ge1Byb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZXxPYmplY3QuPHN0cmluZywqPn1cclxuICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIGEgdHlwZSBjb3VsZCBub3QgYmUgcmVzb2x2ZWRcclxuICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQnVpbGRlci5wcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbihwYXRoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2V0KCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMucmVzb2x2ZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNvbHZlQWxsKCksXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNvbHZlZCA9IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXN1bHQgPSBudWxsOyAvLyBSZXF1aXJlIHJlLWJ1aWxkXHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZXN1bHQgPT0gbnVsbCkgLy8gKFJlLSlCdWlsZFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzdWx0ID0gdGhpcy5ucy5idWlsZCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFwYXRoKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc3VsdDtcclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJ0ID0gcGF0aC5zcGxpdChcIi5cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHB0ciA9IHRoaXMucmVzdWx0OyAvLyBCdWlsZCBuYW1lc3BhY2UgcG9pbnRlciAobm8gaGFzQ2hpbGQgZXRjLilcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8cGFydC5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHB0cltwYXJ0W2ldXSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB0ciA9IHB0cltwYXJ0W2ldXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdHIgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHRyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFNpbWlsYXIgdG8ge0BsaW5rIFByb3RvQnVmLkJ1aWxkZXIjYnVpbGR9LCBidXQgbG9va3MgdXAgdGhlIGludGVybmFsIHJlZmxlY3Rpb24gZGVzY3JpcHRvci5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmc9fSBwYXRoIFNwZWNpZmllcyB3aGF0IHRvIHJldHVybi4gSWYgb21pdHRlZCwgdGhlIGVudGlyZSBuYW1lc3BhY2Ugd2lpbCBiZSByZXR1cm5lZC5cclxuICAgICAgICAgICAgICogQHJldHVybiB7UHJvdG9CdWYuUmVmbGVjdC5UfSBSZWZsZWN0aW9uIGRlc2NyaXB0b3Igb3IgYG51bGxgIGlmIG5vdCBmb3VuZFxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQnVpbGRlci5wcm90b3R5cGUubG9va3VwID0gZnVuY3Rpb24ocGF0aCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhdGggPyB0aGlzLm5zLnJlc29sdmUocGF0aCkgOiB0aGlzLm5zO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBvYmplY3QuXHJcbiAgICAgICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gU3RyaW5nIHJlcHJlc2VudGF0aW9uIGFzIG9mIFwiQnVpbGRlclwiXHJcbiAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEJ1aWxkZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJCdWlsZGVyXCI7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvLyBQc2V1ZG8gdHlwZXMgZG9jdW1lbnRlZCBpbiBSZWZsZWN0LmpzLlxyXG4gICAgICAgICAgICAvLyBFeGlzdCBmb3IgdGhlIHNvbGUgcHVycG9zZSBvZiBiZWluZyBhYmxlIHRvIFwiLi4uIGluc3RhbmNlb2YgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlXCIgZXRjLlxyXG4gICAgICAgICAgICBCdWlsZGVyLk1lc3NhZ2UgPSBmdW5jdGlvbigpIHt9O1xyXG4gICAgICAgICAgICBCdWlsZGVyLlNlcnZpY2UgPSBmdW5jdGlvbigpIHt9O1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIEJ1aWxkZXI7XHJcblxyXG4gICAgICAgIH0pKFByb3RvQnVmLCBQcm90b0J1Zi5MYW5nLCBQcm90b0J1Zi5SZWZsZWN0KTtcclxuXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIExvYWRzIGEgLnByb3RvIHN0cmluZyBhbmQgcmV0dXJucyB0aGUgQnVpbGRlci5cclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvdG8gLnByb3RvIGZpbGUgY29udGVudHNcclxuICAgICAgICAgKiBAcGFyYW0geyhQcm90b0J1Zi5CdWlsZGVyfHN0cmluZ3x7cm9vdDogc3RyaW5nLCBmaWxlOiBzdHJpbmd9KT19IGJ1aWxkZXIgQnVpbGRlciB0byBhcHBlbmQgdG8uIFdpbGwgY3JlYXRlIGEgbmV3IG9uZSBpZiBvbWl0dGVkLlxyXG4gICAgICAgICAqIEBwYXJhbSB7KHN0cmluZ3x7cm9vdDogc3RyaW5nLCBmaWxlOiBzdHJpbmd9KT19IGZpbGVuYW1lIFRoZSBjb3JyZXNwb25kaW5nIGZpbGUgbmFtZSBpZiBrbm93bi4gTXVzdCBiZSBzcGVjaWZpZWQgZm9yIGltcG9ydHMuXHJcbiAgICAgICAgICogQHJldHVybiB7UHJvdG9CdWYuQnVpbGRlcn0gQnVpbGRlciB0byBjcmVhdGUgbmV3IG1lc3NhZ2VzXHJcbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBkZWZpbml0aW9uIGNhbm5vdCBiZSBwYXJzZWQgb3IgYnVpbHRcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUHJvdG9CdWYubG9hZFByb3RvID0gZnVuY3Rpb24ocHJvdG8sIGJ1aWxkZXIsIGZpbGVuYW1lKSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYnVpbGRlciA9PT0gJ3N0cmluZycgfHwgKGJ1aWxkZXIgJiYgdHlwZW9mIGJ1aWxkZXJbXCJmaWxlXCJdID09PSAnc3RyaW5nJyAmJiB0eXBlb2YgYnVpbGRlcltcInJvb3RcIl0gPT09ICdzdHJpbmcnKSkge1xyXG4gICAgICAgICAgICAgICAgZmlsZW5hbWUgPSBidWlsZGVyO1xyXG4gICAgICAgICAgICAgICAgYnVpbGRlciA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIFByb3RvQnVmLmxvYWRKc29uKChuZXcgUHJvdG9CdWYuRG90UHJvdG8uUGFyc2VyKHByb3RvKSkucGFyc2UoKSwgYnVpbGRlciwgZmlsZW5hbWUpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIExvYWRzIGEgLnByb3RvIHN0cmluZyBhbmQgcmV0dXJucyB0aGUgQnVpbGRlci4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgUHJvdG9CdWYubG9hZFByb3RvfS5cclxuICAgICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvdG8gLnByb3RvIGZpbGUgY29udGVudHNcclxuICAgICAgICAgKiBAcGFyYW0geyhQcm90b0J1Zi5CdWlsZGVyfHN0cmluZyk9fSBidWlsZGVyIEJ1aWxkZXIgdG8gYXBwZW5kIHRvLiBXaWxsIGNyZWF0ZSBhIG5ldyBvbmUgaWYgb21pdHRlZC5cclxuICAgICAgICAgKiBAcGFyYW0geyhzdHJpbmd8e3Jvb3Q6IHN0cmluZywgZmlsZTogc3RyaW5nfSk9fSBmaWxlbmFtZSBUaGUgY29ycmVzcG9uZGluZyBmaWxlIG5hbWUgaWYga25vd24uIE11c3QgYmUgc3BlY2lmaWVkIGZvciBpbXBvcnRzLlxyXG4gICAgICAgICAqIEByZXR1cm4ge1Byb3RvQnVmLkJ1aWxkZXJ9IEJ1aWxkZXIgdG8gY3JlYXRlIG5ldyBtZXNzYWdlc1xyXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgZGVmaW5pdGlvbiBjYW5ub3QgYmUgcGFyc2VkIG9yIGJ1aWx0XHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFByb3RvQnVmLnByb3RvRnJvbVN0cmluZyA9IFByb3RvQnVmLmxvYWRQcm90bzsgLy8gTGVnYWN5XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIExvYWRzIGEgLnByb3RvIGZpbGUgYW5kIHJldHVybnMgdGhlIEJ1aWxkZXIuXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd8e3Jvb3Q6IHN0cmluZywgZmlsZTogc3RyaW5nfX0gZmlsZW5hbWUgUGF0aCB0byBwcm90byBmaWxlIG9yIGFuIG9iamVjdCBzcGVjaWZ5aW5nICdmaWxlJyB3aXRoXHJcbiAgICAgICAgICogIGFuIG92ZXJyaWRkZW4gJ3Jvb3QnIHBhdGggZm9yIGFsbCBpbXBvcnRlZCBmaWxlcy5cclxuICAgICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKD9FcnJvciwgIVByb3RvQnVmLkJ1aWxkZXI9KT19IGNhbGxiYWNrIENhbGxiYWNrIHRoYXQgd2lsbCByZWNlaXZlIGBudWxsYCBhcyB0aGUgZmlyc3QgYW5kXHJcbiAgICAgICAgICogIHRoZSBCdWlsZGVyIGFzIGl0cyBzZWNvbmQgYXJndW1lbnQgb24gc3VjY2Vzcywgb3RoZXJ3aXNlIHRoZSBlcnJvciBhcyBpdHMgZmlyc3QgYXJndW1lbnQuIElmIG9taXR0ZWQsIHRoZVxyXG4gICAgICAgICAqICBmaWxlIHdpbGwgYmUgcmVhZCBzeW5jaHJvbm91c2x5IGFuZCB0aGlzIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIHRoZSBCdWlsZGVyLlxyXG4gICAgICAgICAqIEBwYXJhbSB7UHJvdG9CdWYuQnVpbGRlcj19IGJ1aWxkZXIgQnVpbGRlciB0byBhcHBlbmQgdG8uIFdpbGwgY3JlYXRlIGEgbmV3IG9uZSBpZiBvbWl0dGVkLlxyXG4gICAgICAgICAqIEByZXR1cm4gez9Qcm90b0J1Zi5CdWlsZGVyfHVuZGVmaW5lZH0gVGhlIEJ1aWxkZXIgaWYgc3luY2hyb25vdXMgKG5vIGNhbGxiYWNrIHNwZWNpZmllZCwgd2lsbCBiZSBOVUxMIGlmIHRoZVxyXG4gICAgICAgICAqICAgcmVxdWVzdCBoYXMgZmFpbGVkKSwgZWxzZSB1bmRlZmluZWRcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUHJvdG9CdWYubG9hZFByb3RvRmlsZSA9IGZ1bmN0aW9uKGZpbGVuYW1lLCBjYWxsYmFjaywgYnVpbGRlcikge1xyXG4gICAgICAgICAgICBpZiAoY2FsbGJhY2sgJiYgdHlwZW9mIGNhbGxiYWNrID09PSAnb2JqZWN0JylcclxuICAgICAgICAgICAgICAgIGJ1aWxkZXIgPSBjYWxsYmFjayxcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gbnVsbDtcclxuICAgICAgICAgICAgZWxzZSBpZiAoIWNhbGxiYWNrIHx8IHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJylcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gbnVsbDtcclxuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb3RvQnVmLlV0aWwuZmV0Y2godHlwZW9mIGZpbGVuYW1lID09PSAnc3RyaW5nJyA/IGZpbGVuYW1lIDogZmlsZW5hbWVbXCJyb290XCJdK1wiL1wiK2ZpbGVuYW1lW1wiZmlsZVwiXSwgZnVuY3Rpb24oY29udGVudHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY29udGVudHMgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soRXJyb3IoXCJGYWlsZWQgdG8gZmV0Y2ggZmlsZVwiKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgUHJvdG9CdWYubG9hZFByb3RvKGNvbnRlbnRzLCBidWlsZGVyLCBmaWxlbmFtZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHZhciBjb250ZW50cyA9IFByb3RvQnVmLlV0aWwuZmV0Y2godHlwZW9mIGZpbGVuYW1lID09PSAnb2JqZWN0JyA/IGZpbGVuYW1lW1wicm9vdFwiXStcIi9cIitmaWxlbmFtZVtcImZpbGVcIl0gOiBmaWxlbmFtZSk7XHJcbiAgICAgICAgICAgIHJldHVybiBjb250ZW50cyA9PT0gbnVsbCA/IG51bGwgOiBQcm90b0J1Zi5sb2FkUHJvdG8oY29udGVudHMsIGJ1aWxkZXIsIGZpbGVuYW1lKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBMb2FkcyBhIC5wcm90byBmaWxlIGFuZCByZXR1cm5zIHRoZSBCdWlsZGVyLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBQcm90b0J1Zi5sb2FkUHJvdG9GaWxlfS5cclxuICAgICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ3x7cm9vdDogc3RyaW5nLCBmaWxlOiBzdHJpbmd9fSBmaWxlbmFtZSBQYXRoIHRvIHByb3RvIGZpbGUgb3IgYW4gb2JqZWN0IHNwZWNpZnlpbmcgJ2ZpbGUnIHdpdGhcclxuICAgICAgICAgKiAgYW4gb3ZlcnJpZGRlbiAncm9vdCcgcGF0aCBmb3IgYWxsIGltcG9ydGVkIGZpbGVzLlxyXG4gICAgICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oP0Vycm9yLCAhUHJvdG9CdWYuQnVpbGRlcj0pPX0gY2FsbGJhY2sgQ2FsbGJhY2sgdGhhdCB3aWxsIHJlY2VpdmUgYG51bGxgIGFzIHRoZSBmaXJzdCBhbmRcclxuICAgICAgICAgKiAgdGhlIEJ1aWxkZXIgYXMgaXRzIHNlY29uZCBhcmd1bWVudCBvbiBzdWNjZXNzLCBvdGhlcndpc2UgdGhlIGVycm9yIGFzIGl0cyBmaXJzdCBhcmd1bWVudC4gSWYgb21pdHRlZCwgdGhlXHJcbiAgICAgICAgICogIGZpbGUgd2lsbCBiZSByZWFkIHN5bmNocm9ub3VzbHkgYW5kIHRoaXMgZnVuY3Rpb24gd2lsbCByZXR1cm4gdGhlIEJ1aWxkZXIuXHJcbiAgICAgICAgICogQHBhcmFtIHtQcm90b0J1Zi5CdWlsZGVyPX0gYnVpbGRlciBCdWlsZGVyIHRvIGFwcGVuZCB0by4gV2lsbCBjcmVhdGUgYSBuZXcgb25lIGlmIG9taXR0ZWQuXHJcbiAgICAgICAgICogQHJldHVybiB7IVByb3RvQnVmLkJ1aWxkZXJ8dW5kZWZpbmVkfSBUaGUgQnVpbGRlciBpZiBzeW5jaHJvbm91cyAobm8gY2FsbGJhY2sgc3BlY2lmaWVkLCB3aWxsIGJlIE5VTEwgaWYgdGhlXHJcbiAgICAgICAgICogICByZXF1ZXN0IGhhcyBmYWlsZWQpLCBlbHNlIHVuZGVmaW5lZFxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBQcm90b0J1Zi5wcm90b0Zyb21GaWxlID0gUHJvdG9CdWYubG9hZFByb3RvRmlsZTsgLy8gTGVnYWN5XHJcblxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IEJ1aWxkZXIgd2l0aCB0aGUgc3BlY2lmaWVkIHBhY2thZ2UgZGVmaW5lZC5cclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZz19IHBrZyBQYWNrYWdlIG5hbWUgYXMgZnVsbHkgcXVhbGlmaWVkIG5hbWUsIGUuZy4gXCJNeS5HYW1lXCIuIElmIG5vIHBhY2thZ2UgaXMgc3BlY2lmaWVkLCB0aGVcclxuICAgICAgICAgKiBidWlsZGVyIHdpbGwgb25seSBjb250YWluIGEgZ2xvYmFsIG5hbWVzcGFjZS5cclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+PX0gb3B0aW9ucyBUb3AgbGV2ZWwgb3B0aW9uc1xyXG4gICAgICAgICAqIEByZXR1cm4ge1Byb3RvQnVmLkJ1aWxkZXJ9IE5ldyBCdWlsZGVyXHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFByb3RvQnVmLm5ld0J1aWxkZXIgPSBmdW5jdGlvbihwa2csIG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgdmFyIGJ1aWxkZXIgPSBuZXcgUHJvdG9CdWYuQnVpbGRlcigpO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHBrZyAhPT0gJ3VuZGVmaW5lZCcgJiYgcGtnICE9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgYnVpbGRlci5kZWZpbmUocGtnLCBvcHRpb25zKTtcclxuICAgICAgICAgICAgcmV0dXJuIGJ1aWxkZXI7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTG9hZHMgYSAuanNvbiBkZWZpbml0aW9uIGFuZCByZXR1cm5zIHRoZSBCdWlsZGVyLlxyXG4gICAgICAgICAqIEBwYXJhbSB7ISp8c3RyaW5nfSBqc29uIEpTT04gZGVmaW5pdGlvblxyXG4gICAgICAgICAqIEBwYXJhbSB7KFByb3RvQnVmLkJ1aWxkZXJ8c3RyaW5nfHtyb290OiBzdHJpbmcsIGZpbGU6IHN0cmluZ30pPX0gYnVpbGRlciBCdWlsZGVyIHRvIGFwcGVuZCB0by4gV2lsbCBjcmVhdGUgYSBuZXcgb25lIGlmIG9taXR0ZWQuXHJcbiAgICAgICAgICogQHBhcmFtIHsoc3RyaW5nfHtyb290OiBzdHJpbmcsIGZpbGU6IHN0cmluZ30pPX0gZmlsZW5hbWUgVGhlIGNvcnJlc3BvbmRpbmcgZmlsZSBuYW1lIGlmIGtub3duLiBNdXN0IGJlIHNwZWNpZmllZCBmb3IgaW1wb3J0cy5cclxuICAgICAgICAgKiBAcmV0dXJuIHtQcm90b0J1Zi5CdWlsZGVyfSBCdWlsZGVyIHRvIGNyZWF0ZSBuZXcgbWVzc2FnZXNcclxuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGRlZmluaXRpb24gY2Fubm90IGJlIHBhcnNlZCBvciBidWlsdFxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBQcm90b0J1Zi5sb2FkSnNvbiA9IGZ1bmN0aW9uKGpzb24sIGJ1aWxkZXIsIGZpbGVuYW1lKSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYnVpbGRlciA9PT0gJ3N0cmluZycgfHwgKGJ1aWxkZXIgJiYgdHlwZW9mIGJ1aWxkZXJbXCJmaWxlXCJdID09PSAnc3RyaW5nJyAmJiB0eXBlb2YgYnVpbGRlcltcInJvb3RcIl0gPT09ICdzdHJpbmcnKSlcclxuICAgICAgICAgICAgICAgIGZpbGVuYW1lID0gYnVpbGRlcixcclxuICAgICAgICAgICAgICAgIGJ1aWxkZXIgPSBudWxsO1xyXG4gICAgICAgICAgICBpZiAoIWJ1aWxkZXIgfHwgdHlwZW9mIGJ1aWxkZXIgIT09ICdvYmplY3QnKVxyXG4gICAgICAgICAgICAgICAgYnVpbGRlciA9IFByb3RvQnVmLm5ld0J1aWxkZXIoKTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBqc29uID09PSAnc3RyaW5nJylcclxuICAgICAgICAgICAgICAgIGpzb24gPSBKU09OLnBhcnNlKGpzb24pO1xyXG4gICAgICAgICAgICBidWlsZGVyW1wiaW1wb3J0XCJdKGpzb24sIGZpbGVuYW1lKTtcclxuICAgICAgICAgICAgYnVpbGRlci5yZXNvbHZlQWxsKCk7XHJcbiAgICAgICAgICAgIGJ1aWxkZXIuYnVpbGQoKTtcclxuICAgICAgICAgICAgcmV0dXJuIGJ1aWxkZXI7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTG9hZHMgYSAuanNvbiBmaWxlIGFuZCByZXR1cm5zIHRoZSBCdWlsZGVyLlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfCF7cm9vdDogc3RyaW5nLCBmaWxlOiBzdHJpbmd9fSBmaWxlbmFtZSBQYXRoIHRvIGpzb24gZmlsZSBvciBhbiBvYmplY3Qgc3BlY2lmeWluZyAnZmlsZScgd2l0aFxyXG4gICAgICAgICAqICBhbiBvdmVycmlkZGVuICdyb290JyBwYXRoIGZvciBhbGwgaW1wb3J0ZWQgZmlsZXMuXHJcbiAgICAgICAgICogQHBhcmFtIHtmdW5jdGlvbig/RXJyb3IsICFQcm90b0J1Zi5CdWlsZGVyPSk9fSBjYWxsYmFjayBDYWxsYmFjayB0aGF0IHdpbGwgcmVjZWl2ZSBgbnVsbGAgYXMgdGhlIGZpcnN0IGFuZFxyXG4gICAgICAgICAqICB0aGUgQnVpbGRlciBhcyBpdHMgc2Vjb25kIGFyZ3VtZW50IG9uIHN1Y2Nlc3MsIG90aGVyd2lzZSB0aGUgZXJyb3IgYXMgaXRzIGZpcnN0IGFyZ3VtZW50LiBJZiBvbWl0dGVkLCB0aGVcclxuICAgICAgICAgKiAgZmlsZSB3aWxsIGJlIHJlYWQgc3luY2hyb25vdXNseSBhbmQgdGhpcyBmdW5jdGlvbiB3aWxsIHJldHVybiB0aGUgQnVpbGRlci5cclxuICAgICAgICAgKiBAcGFyYW0ge1Byb3RvQnVmLkJ1aWxkZXI9fSBidWlsZGVyIEJ1aWxkZXIgdG8gYXBwZW5kIHRvLiBXaWxsIGNyZWF0ZSBhIG5ldyBvbmUgaWYgb21pdHRlZC5cclxuICAgICAgICAgKiBAcmV0dXJuIHs/UHJvdG9CdWYuQnVpbGRlcnx1bmRlZmluZWR9IFRoZSBCdWlsZGVyIGlmIHN5bmNocm9ub3VzIChubyBjYWxsYmFjayBzcGVjaWZpZWQsIHdpbGwgYmUgTlVMTCBpZiB0aGVcclxuICAgICAgICAgKiAgIHJlcXVlc3QgaGFzIGZhaWxlZCksIGVsc2UgdW5kZWZpbmVkXHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFByb3RvQnVmLmxvYWRKc29uRmlsZSA9IGZ1bmN0aW9uKGZpbGVuYW1lLCBjYWxsYmFjaywgYnVpbGRlcikge1xyXG4gICAgICAgICAgICBpZiAoY2FsbGJhY2sgJiYgdHlwZW9mIGNhbGxiYWNrID09PSAnb2JqZWN0JylcclxuICAgICAgICAgICAgICAgIGJ1aWxkZXIgPSBjYWxsYmFjayxcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gbnVsbDtcclxuICAgICAgICAgICAgZWxzZSBpZiAoIWNhbGxiYWNrIHx8IHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJylcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gbnVsbDtcclxuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb3RvQnVmLlV0aWwuZmV0Y2godHlwZW9mIGZpbGVuYW1lID09PSAnc3RyaW5nJyA/IGZpbGVuYW1lIDogZmlsZW5hbWVbXCJyb290XCJdK1wiL1wiK2ZpbGVuYW1lW1wiZmlsZVwiXSwgZnVuY3Rpb24oY29udGVudHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY29udGVudHMgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soRXJyb3IoXCJGYWlsZWQgdG8gZmV0Y2ggZmlsZVwiKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgUHJvdG9CdWYubG9hZEpzb24oSlNPTi5wYXJzZShjb250ZW50cyksIGJ1aWxkZXIsIGZpbGVuYW1lKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdmFyIGNvbnRlbnRzID0gUHJvdG9CdWYuVXRpbC5mZXRjaCh0eXBlb2YgZmlsZW5hbWUgPT09ICdvYmplY3QnID8gZmlsZW5hbWVbXCJyb290XCJdK1wiL1wiK2ZpbGVuYW1lW1wiZmlsZVwiXSA6IGZpbGVuYW1lKTtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnRzID09PSBudWxsID8gbnVsbCA6IFByb3RvQnVmLmxvYWRKc29uKEpTT04ucGFyc2UoY29udGVudHMpLCBidWlsZGVyLCBmaWxlbmFtZSk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgcmV0dXJuIFByb3RvQnVmO1xyXG4gICAgfVxyXG5cclxuICAgIC8qIENvbW1vbkpTICovIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGVbXCJleHBvcnRzXCJdKVxyXG4gICAgICAgIG1vZHVsZVtcImV4cG9ydHNcIl0gPSBpbml0KHJlcXVpcmUoXCJieXRlYnVmZmVyXCIpKTtcclxuICAgIC8qIEFNRCAqLyBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZVtcImFtZFwiXSlcclxuICAgICAgICBkZWZpbmUoW1wiQnl0ZUJ1ZmZlclwiXSwgaW5pdCk7XHJcbiAgICAvKiBHbG9iYWwgKi8gZWxzZVxyXG4gICAgICAgIChnbG9iYWxbXCJkY29kZUlPXCJdID0gZ2xvYmFsW1wiZGNvZGVJT1wiXSB8fCB7fSlbXCJQcm90b0J1ZlwiXSA9IGluaXQoZ2xvYmFsW1wiZGNvZGVJT1wiXVtcIkJ5dGVCdWZmZXJcIl0pO1xyXG5cclxufSkodGhpcyk7XHJcbiIsIi8qXHJcbiBDb3B5cmlnaHQgMjAxMyBEYW5pZWwgV2lydHogPGRjb2RlQGRjb2RlLmlvPlxyXG5cclxuIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuXHJcbiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcbiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxudmFyIFByb3RvQnVmID0gcmVxdWlyZShcIi4vZGlzdC9Qcm90b0J1Zi5qc1wiKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUHJvdG9CdWY7XHJcbiIsIi8qXG4gQnl0ZUJ1ZmZlci5qcyAoYykgMjAxMy0yMDE0IERhbmllbCBXaXJ0eiA8ZGNvZGVAZGNvZGUuaW8+XG4gVGhpcyB2ZXJzaW9uIG9mIEJ5dGVCdWZmZXIuanMgdXNlcyBhbiBBcnJheUJ1ZmZlciAoQUIpIGFzIGl0cyBiYWNraW5nIGJ1ZmZlciBhbmQgaXMgY29tcGF0aWJsZSB3aXRoIG1vZGVybiBicm93c2Vycy5cbiBSZWxlYXNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wXG4gc2VlOiBodHRwczovL2dpdGh1Yi5jb20vZGNvZGVJTy9CeXRlQnVmZmVyLmpzIGZvciBkZXRhaWxzXG4qL1xuKGZ1bmN0aW9uKHIpe2Z1bmN0aW9uIHMobCl7ZnVuY3Rpb24gZChhLGIsYyl7XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBhJiYoYT1kLkRFRkFVTFRfQ0FQQUNJVFkpO1widW5kZWZpbmVkXCI9PT10eXBlb2YgYiYmKGI9ZC5ERUZBVUxUX0VORElBTik7XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBjJiYoYz1kLkRFRkFVTFRfTk9BU1NFUlQpO2lmKCFjKXthfD0wO2lmKDA+YSl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIklsbGVnYWwgY2FwYWNpdHk6IDAgPD0gXCIrYSk7aWYoXCJib29sZWFuXCIhPT10eXBlb2YgYil0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBsaXR0bGVFbmRpYW46IE5vdCBhIGJvb2xlYW5cIik7aWYoXCJib29sZWFuXCIhPT10eXBlb2YgYyl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBub0Fzc2VydDogTm90IGEgYm9vbGVhblwiKTt9dGhpcy5idWZmZXI9MD09PWE/cjpuZXcgQXJyYXlCdWZmZXIoYSk7dGhpcy52aWV3PTA9PT1hP251bGw6bmV3IERhdGFWaWV3KHRoaXMuYnVmZmVyKTtcbnRoaXMub2Zmc2V0PTA7dGhpcy5tYXJrZWRPZmZzZXQ9LTE7dGhpcy5saW1pdD1hO3RoaXMubGl0dGxlRW5kaWFuPVwidW5kZWZpbmVkXCIhPT10eXBlb2YgYj8hIWI6ITE7dGhpcy5ub0Fzc2VydD0hIWN9ZC5WRVJTSU9OPVwiMy4xLjBcIjtkLkxJVFRMRV9FTkRJQU49ITA7ZC5CSUdfRU5ESUFOPSExO2QuREVGQVVMVF9DQVBBQ0lUWT0xNjtkLkRFRkFVTFRfRU5ESUFOPWQuQklHX0VORElBTjtkLkRFRkFVTFRfTk9BU1NFUlQ9ITE7ZC5Mb25nPWx8fG51bGw7dmFyIHI9bmV3IEFycmF5QnVmZmVyKDApO2QuYWxsb2NhdGU9ZnVuY3Rpb24oYSxiLGMpe3JldHVybiBuZXcgZChhLGIsYyl9O2QuY29uY2F0PWZ1bmN0aW9uKGEsYixjLGUpe2lmKFwiYm9vbGVhblwiPT09dHlwZW9mIGJ8fFwic3RyaW5nXCIhPT10eXBlb2YgYillPWMsYz1iLGI9dm9pZCAwO2Zvcih2YXIgaD0wLGY9MCxnPWEubGVuZ3RoLG47ZjxnOysrZilkLmlzQnl0ZUJ1ZmZlcihhW2ZdKXx8KGFbZl09ZC53cmFwKGFbZl0sYikpLG49XG5hW2ZdLmxpbWl0LWFbZl0ub2Zmc2V0LDA8biYmKGgrPW4pO2lmKDA9PT1oKXJldHVybiBuZXcgZCgwLGMsZSk7Yj1uZXcgZChoLGMsZSk7ZT1uZXcgVWludDhBcnJheShiLmJ1ZmZlcik7Zm9yKGY9MDtmPGc7KWM9YVtmKytdLG49Yy5saW1pdC1jLm9mZnNldCwwPj1ufHwoZS5zZXQoKG5ldyBVaW50OEFycmF5KGMuYnVmZmVyKSkuc3ViYXJyYXkoYy5vZmZzZXQsYy5saW1pdCksYi5vZmZzZXQpLGIub2Zmc2V0Kz1uKTtiLmxpbWl0PWIub2Zmc2V0O2Iub2Zmc2V0PTA7cmV0dXJuIGJ9O2QuaXNCeXRlQnVmZmVyPWZ1bmN0aW9uKGEpe3JldHVybiBhJiZhIGluc3RhbmNlb2YgZH07ZC50eXBlPWZ1bmN0aW9uKCl7cmV0dXJuIEFycmF5QnVmZmVyfTtkLndyYXA9ZnVuY3Rpb24oYSxiLGMsZSl7XCJzdHJpbmdcIiE9PXR5cGVvZiBiJiYoZT1jLGM9YixiPXZvaWQgMCk7aWYoXCJzdHJpbmdcIj09PXR5cGVvZiBhKXN3aXRjaChcInVuZGVmaW5lZFwiPT09dHlwZW9mIGImJihiPVwidXRmOFwiKSxiKXtjYXNlIFwiYmFzZTY0XCI6cmV0dXJuIGQuZnJvbUJhc2U2NChhLFxuYyk7Y2FzZSBcImhleFwiOnJldHVybiBkLmZyb21IZXgoYSxjKTtjYXNlIFwiYmluYXJ5XCI6cmV0dXJuIGQuZnJvbUJpbmFyeShhLGMpO2Nhc2UgXCJ1dGY4XCI6cmV0dXJuIGQuZnJvbVVURjgoYSxjKTtjYXNlIFwiZGVidWdcIjpyZXR1cm4gZC5mcm9tRGVidWcoYSxjKTtkZWZhdWx0OnRocm93IG5ldyBUeXBlRXJyb3IoXCJVbnN1cHBvcnRlZCBlbmNvZGluZzogXCIrYik7fWlmKG51bGw9PT1hfHxcIm9iamVjdFwiIT09dHlwZW9mIGEpdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgYnVmZmVyOiBudWxsIG9yIG5vbi1vYmplY3RcIik7aWYoZC5pc0J5dGVCdWZmZXIoYSkpcmV0dXJuIGI9ZC5wcm90b3R5cGUuY2xvbmUuY2FsbChhKSxiLm1hcmtlZE9mZnNldD0tMSxiO2lmKGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KWI9bmV3IGQoMCxjLGUpLDA8YS5sZW5ndGgmJihiLmJ1ZmZlcj1hLmJ1ZmZlcixiLm9mZnNldD1hLmJ5dGVPZmZzZXQsYi5saW1pdD1hLmJ5dGVPZmZzZXQrYS5sZW5ndGgsYi52aWV3PVxuMDxhLmxlbmd0aD9uZXcgRGF0YVZpZXcoYS5idWZmZXIpOm51bGwpO2Vsc2UgaWYoYSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKWI9bmV3IGQoMCxjLGUpLDA8YS5ieXRlTGVuZ3RoJiYoYi5idWZmZXI9YSxiLm9mZnNldD0wLGIubGltaXQ9YS5ieXRlTGVuZ3RoLGIudmlldz0wPGEuYnl0ZUxlbmd0aD9uZXcgRGF0YVZpZXcoYSk6bnVsbCk7ZWxzZSBpZihcIltvYmplY3QgQXJyYXldXCI9PT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYSkpZm9yKGI9bmV3IGQoYS5sZW5ndGgsYyxlKSxiLmxpbWl0PWEubGVuZ3RoLGk9MDtpPGEubGVuZ3RoOysraSliLnZpZXcuc2V0VWludDgoaSxhW2ldKTtlbHNlIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGJ1ZmZlclwiKTtyZXR1cm4gYn07ZC5wcm90b3R5cGUud3JpdGVJbnQ4PWZ1bmN0aW9uKGEsYil7dmFyIGM9XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBiO2MmJihiPXRoaXMub2Zmc2V0KTtpZighdGhpcy5ub0Fzc2VydCl7aWYoXCJudW1iZXJcIiE9PVxudHlwZW9mIGF8fDAhPT1hJTEpdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgdmFsdWU6IFwiK2ErXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTthfD0wO2lmKFwibnVtYmVyXCIhPT10eXBlb2YgYnx8MCE9PWIlMSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK2IrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtiPj4+PTA7aWYoMD5ifHxiKzA+dGhpcy5idWZmZXIuYnl0ZUxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK2IrXCIgKCswKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTt9Yis9MTt2YXIgZT10aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoO2I+ZSYmdGhpcy5yZXNpemUoKGUqPTIpPmI/ZTpiKTt0aGlzLnZpZXcuc2V0SW50OChiLTEsYSk7YyYmKHRoaXMub2Zmc2V0Kz0xKTtyZXR1cm4gdGhpc307ZC5wcm90b3R5cGUud3JpdGVCeXRlPWQucHJvdG90eXBlLndyaXRlSW50ODtkLnByb3RvdHlwZS5yZWFkSW50OD1mdW5jdGlvbihhKXt2YXIgYj1cblwidW5kZWZpbmVkXCI9PT10eXBlb2YgYTtiJiYoYT10aGlzLm9mZnNldCk7aWYoIXRoaXMubm9Bc3NlcnQpe2lmKFwibnVtYmVyXCIhPT10eXBlb2YgYXx8MCE9PWElMSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK2ErXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTthPj4+PTA7aWYoMD5hfHxhKzE+dGhpcy5idWZmZXIuYnl0ZUxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK2ErXCIgKCsxKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTt9YT10aGlzLnZpZXcuZ2V0SW50OChhKTtiJiYodGhpcy5vZmZzZXQrPTEpO3JldHVybiBhfTtkLnByb3RvdHlwZS5yZWFkQnl0ZT1kLnByb3RvdHlwZS5yZWFkSW50ODtkLnByb3RvdHlwZS53cml0ZVVpbnQ4PWZ1bmN0aW9uKGEsYil7dmFyIGM9XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBiO2MmJihiPXRoaXMub2Zmc2V0KTtpZighdGhpcy5ub0Fzc2VydCl7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBhfHxcbjAhPT1hJTEpdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgdmFsdWU6IFwiK2ErXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTthPj4+PTA7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBifHwwIT09YiUxKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrYitcIiAobm90IGFuIGludGVnZXIpXCIpO2I+Pj49MDtpZigwPmJ8fGIrMD50aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrYitcIiAoKzApIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO31iKz0xO3ZhciBlPXRoaXMuYnVmZmVyLmJ5dGVMZW5ndGg7Yj5lJiZ0aGlzLnJlc2l6ZSgoZSo9Mik+Yj9lOmIpO3RoaXMudmlldy5zZXRVaW50OChiLTEsYSk7YyYmKHRoaXMub2Zmc2V0Kz0xKTtyZXR1cm4gdGhpc307ZC5wcm90b3R5cGUucmVhZFVpbnQ4PWZ1bmN0aW9uKGEpe3ZhciBiPVwidW5kZWZpbmVkXCI9PT10eXBlb2YgYTtiJiYoYT10aGlzLm9mZnNldCk7XG5pZighdGhpcy5ub0Fzc2VydCl7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBhfHwwIT09YSUxKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrYStcIiAobm90IGFuIGludGVnZXIpXCIpO2E+Pj49MDtpZigwPmF8fGErMT50aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrYStcIiAoKzEpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO31hPXRoaXMudmlldy5nZXRVaW50OChhKTtiJiYodGhpcy5vZmZzZXQrPTEpO3JldHVybiBhfTtkLnByb3RvdHlwZS53cml0ZUludDE2PWZ1bmN0aW9uKGEsYil7dmFyIGM9XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBiO2MmJihiPXRoaXMub2Zmc2V0KTtpZighdGhpcy5ub0Fzc2VydCl7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBhfHwwIT09YSUxKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIHZhbHVlOiBcIithK1wiIChub3QgYW4gaW50ZWdlcilcIik7YXw9MDtpZihcIm51bWJlclwiIT09XG50eXBlb2YgYnx8MCE9PWIlMSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK2IrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtiPj4+PTA7aWYoMD5ifHxiKzA+dGhpcy5idWZmZXIuYnl0ZUxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK2IrXCIgKCswKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTt9Yis9Mjt2YXIgZT10aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoO2I+ZSYmdGhpcy5yZXNpemUoKGUqPTIpPmI/ZTpiKTt0aGlzLnZpZXcuc2V0SW50MTYoYi0yLGEsdGhpcy5saXR0bGVFbmRpYW4pO2MmJih0aGlzLm9mZnNldCs9Mik7cmV0dXJuIHRoaXN9O2QucHJvdG90eXBlLndyaXRlU2hvcnQ9ZC5wcm90b3R5cGUud3JpdGVJbnQxNjtkLnByb3RvdHlwZS5yZWFkSW50MTY9ZnVuY3Rpb24oYSl7dmFyIGI9XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBhO2ImJihhPXRoaXMub2Zmc2V0KTtpZighdGhpcy5ub0Fzc2VydCl7aWYoXCJudW1iZXJcIiE9PVxudHlwZW9mIGF8fDAhPT1hJTEpdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIithK1wiIChub3QgYW4gaW50ZWdlcilcIik7YT4+Pj0wO2lmKDA+YXx8YSsyPnRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIithK1wiICgrMikgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7fWE9dGhpcy52aWV3LmdldEludDE2KGEsdGhpcy5saXR0bGVFbmRpYW4pO2ImJih0aGlzLm9mZnNldCs9Mik7cmV0dXJuIGF9O2QucHJvdG90eXBlLnJlYWRTaG9ydD1kLnByb3RvdHlwZS5yZWFkSW50MTY7ZC5wcm90b3R5cGUud3JpdGVVaW50MTY9ZnVuY3Rpb24oYSxiKXt2YXIgYz1cInVuZGVmaW5lZFwiPT09dHlwZW9mIGI7YyYmKGI9dGhpcy5vZmZzZXQpO2lmKCF0aGlzLm5vQXNzZXJ0KXtpZihcIm51bWJlclwiIT09dHlwZW9mIGF8fDAhPT1hJTEpdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgdmFsdWU6IFwiK2ErXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbmE+Pj49MDtpZihcIm51bWJlclwiIT09dHlwZW9mIGJ8fDAhPT1iJTEpdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitiK1wiIChub3QgYW4gaW50ZWdlcilcIik7Yj4+Pj0wO2lmKDA+Ynx8YiswPnRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitiK1wiICgrMCkgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7fWIrPTI7dmFyIGU9dGhpcy5idWZmZXIuYnl0ZUxlbmd0aDtiPmUmJnRoaXMucmVzaXplKChlKj0yKT5iP2U6Yik7dGhpcy52aWV3LnNldFVpbnQxNihiLTIsYSx0aGlzLmxpdHRsZUVuZGlhbik7YyYmKHRoaXMub2Zmc2V0Kz0yKTtyZXR1cm4gdGhpc307ZC5wcm90b3R5cGUucmVhZFVpbnQxNj1mdW5jdGlvbihhKXt2YXIgYj1cInVuZGVmaW5lZFwiPT09dHlwZW9mIGE7YiYmKGE9dGhpcy5vZmZzZXQpO2lmKCF0aGlzLm5vQXNzZXJ0KXtpZihcIm51bWJlclwiIT09dHlwZW9mIGF8fDAhPT1hJVxuMSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK2ErXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTthPj4+PTA7aWYoMD5hfHxhKzI+dGhpcy5idWZmZXIuYnl0ZUxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK2ErXCIgKCsyKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTt9YT10aGlzLnZpZXcuZ2V0VWludDE2KGEsdGhpcy5saXR0bGVFbmRpYW4pO2ImJih0aGlzLm9mZnNldCs9Mik7cmV0dXJuIGF9O2QucHJvdG90eXBlLndyaXRlSW50MzI9ZnVuY3Rpb24oYSxiKXt2YXIgYz1cInVuZGVmaW5lZFwiPT09dHlwZW9mIGI7YyYmKGI9dGhpcy5vZmZzZXQpO2lmKCF0aGlzLm5vQXNzZXJ0KXtpZihcIm51bWJlclwiIT09dHlwZW9mIGF8fDAhPT1hJTEpdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgdmFsdWU6IFwiK2ErXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTthfD0wO2lmKFwibnVtYmVyXCIhPT10eXBlb2YgYnx8MCE9PWIlMSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK1xuYitcIiAobm90IGFuIGludGVnZXIpXCIpO2I+Pj49MDtpZigwPmJ8fGIrMD50aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrYitcIiAoKzApIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO31iKz00O3ZhciBlPXRoaXMuYnVmZmVyLmJ5dGVMZW5ndGg7Yj5lJiZ0aGlzLnJlc2l6ZSgoZSo9Mik+Yj9lOmIpO3RoaXMudmlldy5zZXRJbnQzMihiLTQsYSx0aGlzLmxpdHRsZUVuZGlhbik7YyYmKHRoaXMub2Zmc2V0Kz00KTtyZXR1cm4gdGhpc307ZC5wcm90b3R5cGUud3JpdGVJbnQ9ZC5wcm90b3R5cGUud3JpdGVJbnQzMjtkLnByb3RvdHlwZS5yZWFkSW50MzI9ZnVuY3Rpb24oYSl7dmFyIGI9XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBhO2ImJihhPXRoaXMub2Zmc2V0KTtpZighdGhpcy5ub0Fzc2VydCl7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBhfHwwIT09YSUxKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrXG5hK1wiIChub3QgYW4gaW50ZWdlcilcIik7YT4+Pj0wO2lmKDA+YXx8YSs0PnRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIithK1wiICgrNCkgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7fWE9dGhpcy52aWV3LmdldEludDMyKGEsdGhpcy5saXR0bGVFbmRpYW4pO2ImJih0aGlzLm9mZnNldCs9NCk7cmV0dXJuIGF9O2QucHJvdG90eXBlLnJlYWRJbnQ9ZC5wcm90b3R5cGUucmVhZEludDMyO2QucHJvdG90eXBlLndyaXRlVWludDMyPWZ1bmN0aW9uKGEsYil7dmFyIGM9XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBiO2MmJihiPXRoaXMub2Zmc2V0KTtpZighdGhpcy5ub0Fzc2VydCl7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBhfHwwIT09YSUxKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIHZhbHVlOiBcIithK1wiIChub3QgYW4gaW50ZWdlcilcIik7YT4+Pj0wO2lmKFwibnVtYmVyXCIhPT10eXBlb2YgYnx8MCE9PWIlMSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK1xuYitcIiAobm90IGFuIGludGVnZXIpXCIpO2I+Pj49MDtpZigwPmJ8fGIrMD50aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrYitcIiAoKzApIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO31iKz00O3ZhciBlPXRoaXMuYnVmZmVyLmJ5dGVMZW5ndGg7Yj5lJiZ0aGlzLnJlc2l6ZSgoZSo9Mik+Yj9lOmIpO3RoaXMudmlldy5zZXRVaW50MzIoYi00LGEsdGhpcy5saXR0bGVFbmRpYW4pO2MmJih0aGlzLm9mZnNldCs9NCk7cmV0dXJuIHRoaXN9O2QucHJvdG90eXBlLnJlYWRVaW50MzI9ZnVuY3Rpb24oYSl7dmFyIGI9XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBhO2ImJihhPXRoaXMub2Zmc2V0KTtpZighdGhpcy5ub0Fzc2VydCl7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBhfHwwIT09YSUxKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrYStcIiAobm90IGFuIGludGVnZXIpXCIpO2E+Pj49MDtpZigwPmF8fFxuYSs0PnRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIithK1wiICgrNCkgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7fWE9dGhpcy52aWV3LmdldFVpbnQzMihhLHRoaXMubGl0dGxlRW5kaWFuKTtiJiYodGhpcy5vZmZzZXQrPTQpO3JldHVybiBhfTtsJiYoZC5wcm90b3R5cGUud3JpdGVJbnQ2ND1mdW5jdGlvbihhLGIpe3ZhciBjPVwidW5kZWZpbmVkXCI9PT10eXBlb2YgYjtjJiYoYj10aGlzLm9mZnNldCk7aWYoIXRoaXMubm9Bc3NlcnQpe2lmKFwibnVtYmVyXCI9PT10eXBlb2YgYSlhPWwuZnJvbU51bWJlcihhKTtlbHNlIGlmKCEoYSYmYSBpbnN0YW5jZW9mIGwpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIHZhbHVlOiBcIithK1wiIChub3QgYW4gaW50ZWdlciBvciBMb25nKVwiKTtpZihcIm51bWJlclwiIT09dHlwZW9mIGJ8fDAhPT1iJTEpdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitcbmIrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtiPj4+PTA7aWYoMD5ifHxiKzA+dGhpcy5idWZmZXIuYnl0ZUxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK2IrXCIgKCswKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTt9XCJudW1iZXJcIj09PXR5cGVvZiBhJiYoYT1sLmZyb21OdW1iZXIoYSkpO2IrPTg7dmFyIGU9dGhpcy5idWZmZXIuYnl0ZUxlbmd0aDtiPmUmJnRoaXMucmVzaXplKChlKj0yKT5iP2U6Yik7Yi09ODt0aGlzLmxpdHRsZUVuZGlhbj8odGhpcy52aWV3LnNldEludDMyKGIsYS5sb3csITApLHRoaXMudmlldy5zZXRJbnQzMihiKzQsYS5oaWdoLCEwKSk6KHRoaXMudmlldy5zZXRJbnQzMihiLGEuaGlnaCwhMSksdGhpcy52aWV3LnNldEludDMyKGIrNCxhLmxvdywhMSkpO2MmJih0aGlzLm9mZnNldCs9OCk7cmV0dXJuIHRoaXN9LGQucHJvdG90eXBlLndyaXRlTG9uZz1kLnByb3RvdHlwZS53cml0ZUludDY0LGQucHJvdG90eXBlLnJlYWRJbnQ2ND1cbmZ1bmN0aW9uKGEpe3ZhciBiPVwidW5kZWZpbmVkXCI9PT10eXBlb2YgYTtiJiYoYT10aGlzLm9mZnNldCk7aWYoIXRoaXMubm9Bc3NlcnQpe2lmKFwibnVtYmVyXCIhPT10eXBlb2YgYXx8MCE9PWElMSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK2ErXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTthPj4+PTA7aWYoMD5hfHxhKzg+dGhpcy5idWZmZXIuYnl0ZUxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK2ErXCIgKCs4KSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTt9YT10aGlzLmxpdHRsZUVuZGlhbj9uZXcgbCh0aGlzLnZpZXcuZ2V0SW50MzIoYSwhMCksdGhpcy52aWV3LmdldEludDMyKGErNCwhMCksITEpOm5ldyBsKHRoaXMudmlldy5nZXRJbnQzMihhKzQsITEpLHRoaXMudmlldy5nZXRJbnQzMihhLCExKSwhMSk7YiYmKHRoaXMub2Zmc2V0Kz04KTtyZXR1cm4gYX0sZC5wcm90b3R5cGUucmVhZExvbmc9ZC5wcm90b3R5cGUucmVhZEludDY0LFxuZC5wcm90b3R5cGUud3JpdGVVaW50NjQ9ZnVuY3Rpb24oYSxiKXt2YXIgYz1cInVuZGVmaW5lZFwiPT09dHlwZW9mIGI7YyYmKGI9dGhpcy5vZmZzZXQpO2lmKCF0aGlzLm5vQXNzZXJ0KXtpZihcIm51bWJlclwiPT09dHlwZW9mIGEpYT1sLmZyb21OdW1iZXIoYSk7ZWxzZSBpZighKGEmJmEgaW5zdGFuY2VvZiBsKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCB2YWx1ZTogXCIrYStcIiAobm90IGFuIGludGVnZXIgb3IgTG9uZylcIik7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBifHwwIT09YiUxKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrYitcIiAobm90IGFuIGludGVnZXIpXCIpO2I+Pj49MDtpZigwPmJ8fGIrMD50aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrYitcIiAoKzApIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO31cIm51bWJlclwiPT09dHlwZW9mIGEmJihhPWwuZnJvbU51bWJlcihhKSk7XG5iKz04O3ZhciBlPXRoaXMuYnVmZmVyLmJ5dGVMZW5ndGg7Yj5lJiZ0aGlzLnJlc2l6ZSgoZSo9Mik+Yj9lOmIpO2ItPTg7dGhpcy5saXR0bGVFbmRpYW4/KHRoaXMudmlldy5zZXRJbnQzMihiLGEubG93LCEwKSx0aGlzLnZpZXcuc2V0SW50MzIoYis0LGEuaGlnaCwhMCkpOih0aGlzLnZpZXcuc2V0SW50MzIoYixhLmhpZ2gsITEpLHRoaXMudmlldy5zZXRJbnQzMihiKzQsYS5sb3csITEpKTtjJiYodGhpcy5vZmZzZXQrPTgpO3JldHVybiB0aGlzfSxkLnByb3RvdHlwZS5yZWFkVWludDY0PWZ1bmN0aW9uKGEpe3ZhciBiPVwidW5kZWZpbmVkXCI9PT10eXBlb2YgYTtiJiYoYT10aGlzLm9mZnNldCk7aWYoIXRoaXMubm9Bc3NlcnQpe2lmKFwibnVtYmVyXCIhPT10eXBlb2YgYXx8MCE9PWElMSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK2ErXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTthPj4+PTA7aWYoMD5hfHxhKzg+dGhpcy5idWZmZXIuYnl0ZUxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK1xuYStcIiAoKzgpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO31hPXRoaXMubGl0dGxlRW5kaWFuP25ldyBsKHRoaXMudmlldy5nZXRJbnQzMihhLCEwKSx0aGlzLnZpZXcuZ2V0SW50MzIoYSs0LCEwKSwhMCk6bmV3IGwodGhpcy52aWV3LmdldEludDMyKGErNCwhMSksdGhpcy52aWV3LmdldEludDMyKGEsITEpLCEwKTtiJiYodGhpcy5vZmZzZXQrPTgpO3JldHVybiBhfSk7ZC5wcm90b3R5cGUud3JpdGVGbG9hdDMyPWZ1bmN0aW9uKGEsYil7dmFyIGM9XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBiO2MmJihiPXRoaXMub2Zmc2V0KTtpZighdGhpcy5ub0Fzc2VydCl7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBhKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIHZhbHVlOiBcIithK1wiIChub3QgYSBudW1iZXIpXCIpO2lmKFwibnVtYmVyXCIhPT10eXBlb2YgYnx8MCE9PWIlMSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK2IrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtiPj4+PVxuMDtpZigwPmJ8fGIrMD50aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrYitcIiAoKzApIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO31iKz00O3ZhciBlPXRoaXMuYnVmZmVyLmJ5dGVMZW5ndGg7Yj5lJiZ0aGlzLnJlc2l6ZSgoZSo9Mik+Yj9lOmIpO3RoaXMudmlldy5zZXRGbG9hdDMyKGItNCxhLHRoaXMubGl0dGxlRW5kaWFuKTtjJiYodGhpcy5vZmZzZXQrPTQpO3JldHVybiB0aGlzfTtkLnByb3RvdHlwZS53cml0ZUZsb2F0PWQucHJvdG90eXBlLndyaXRlRmxvYXQzMjtkLnByb3RvdHlwZS5yZWFkRmxvYXQzMj1mdW5jdGlvbihhKXt2YXIgYj1cInVuZGVmaW5lZFwiPT09dHlwZW9mIGE7YiYmKGE9dGhpcy5vZmZzZXQpO2lmKCF0aGlzLm5vQXNzZXJ0KXtpZihcIm51bWJlclwiIT09dHlwZW9mIGF8fDAhPT1hJTEpdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIithK1wiIChub3QgYW4gaW50ZWdlcilcIik7XG5hPj4+PTA7aWYoMD5hfHxhKzQ+dGhpcy5idWZmZXIuYnl0ZUxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK2ErXCIgKCs0KSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTt9YT10aGlzLnZpZXcuZ2V0RmxvYXQzMihhLHRoaXMubGl0dGxlRW5kaWFuKTtiJiYodGhpcy5vZmZzZXQrPTQpO3JldHVybiBhfTtkLnByb3RvdHlwZS5yZWFkRmxvYXQ9ZC5wcm90b3R5cGUucmVhZEZsb2F0MzI7ZC5wcm90b3R5cGUud3JpdGVGbG9hdDY0PWZ1bmN0aW9uKGEsYil7dmFyIGM9XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBiO2MmJihiPXRoaXMub2Zmc2V0KTtpZighdGhpcy5ub0Fzc2VydCl7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBhKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIHZhbHVlOiBcIithK1wiIChub3QgYSBudW1iZXIpXCIpO2lmKFwibnVtYmVyXCIhPT10eXBlb2YgYnx8MCE9PWIlMSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK1xuYitcIiAobm90IGFuIGludGVnZXIpXCIpO2I+Pj49MDtpZigwPmJ8fGIrMD50aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrYitcIiAoKzApIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO31iKz04O3ZhciBlPXRoaXMuYnVmZmVyLmJ5dGVMZW5ndGg7Yj5lJiZ0aGlzLnJlc2l6ZSgoZSo9Mik+Yj9lOmIpO3RoaXMudmlldy5zZXRGbG9hdDY0KGItOCxhLHRoaXMubGl0dGxlRW5kaWFuKTtjJiYodGhpcy5vZmZzZXQrPTgpO3JldHVybiB0aGlzfTtkLnByb3RvdHlwZS53cml0ZURvdWJsZT1kLnByb3RvdHlwZS53cml0ZUZsb2F0NjQ7ZC5wcm90b3R5cGUucmVhZEZsb2F0NjQ9ZnVuY3Rpb24oYSl7dmFyIGI9XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBhO2ImJihhPXRoaXMub2Zmc2V0KTtpZighdGhpcy5ub0Fzc2VydCl7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBhfHwwIT09YSUxKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrXG5hK1wiIChub3QgYW4gaW50ZWdlcilcIik7YT4+Pj0wO2lmKDA+YXx8YSs4PnRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIithK1wiICgrOCkgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7fWE9dGhpcy52aWV3LmdldEZsb2F0NjQoYSx0aGlzLmxpdHRsZUVuZGlhbik7YiYmKHRoaXMub2Zmc2V0Kz04KTtyZXR1cm4gYX07ZC5wcm90b3R5cGUucmVhZERvdWJsZT1kLnByb3RvdHlwZS5yZWFkRmxvYXQ2NDtkLk1BWF9WQVJJTlQzMl9CWVRFUz01O2QuY2FsY3VsYXRlVmFyaW50MzI9ZnVuY3Rpb24oYSl7YT4+Pj0wO3JldHVybiAxMjg+YT8xOjE2Mzg0PmE/MjoyMDk3MTUyPmE/MzoyNjg0MzU0NTY+YT80OjV9O2QuemlnWmFnRW5jb2RlMzI9ZnVuY3Rpb24oYSl7cmV0dXJuKChhfD0wKTw8MV5hPj4zMSk+Pj4wfTtkLnppZ1phZ0RlY29kZTMyPWZ1bmN0aW9uKGEpe3JldHVybiBhPj4+MV4tKGEmMSl8MH07ZC5wcm90b3R5cGUud3JpdGVWYXJpbnQzMj1cbmZ1bmN0aW9uKGEsYil7dmFyIGM9XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBiO2MmJihiPXRoaXMub2Zmc2V0KTtpZighdGhpcy5ub0Fzc2VydCl7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBhfHwwIT09YSUxKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIHZhbHVlOiBcIithK1wiIChub3QgYW4gaW50ZWdlcilcIik7YXw9MDtpZihcIm51bWJlclwiIT09dHlwZW9mIGJ8fDAhPT1iJTEpdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitiK1wiIChub3QgYW4gaW50ZWdlcilcIik7Yj4+Pj0wO2lmKDA+Ynx8YiswPnRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitiK1wiICgrMCkgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7fXZhciBlPWQuY2FsY3VsYXRlVmFyaW50MzIoYSk7Yis9ZTt2YXIgaD10aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoO2I+aCYmdGhpcy5yZXNpemUoKGgqPTIpPmI/aDpiKTtiLT1lO3RoaXMudmlldy5zZXRVaW50OChiLFxuZT1hfDEyOCk7YT4+Pj0wOzEyODw9YT8oZT1hPj43fDEyOCx0aGlzLnZpZXcuc2V0VWludDgoYisxLGUpLDE2Mzg0PD1hPyhlPWE+PjE0fDEyOCx0aGlzLnZpZXcuc2V0VWludDgoYisyLGUpLDIwOTcxNTI8PWE/KGU9YT4+MjF8MTI4LHRoaXMudmlldy5zZXRVaW50OChiKzMsZSksMjY4NDM1NDU2PD1hPyh0aGlzLnZpZXcuc2V0VWludDgoYis0LGE+PjI4JjE1KSxlPTUpOih0aGlzLnZpZXcuc2V0VWludDgoYiszLGUmMTI3KSxlPTQpKToodGhpcy52aWV3LnNldFVpbnQ4KGIrMixlJjEyNyksZT0zKSk6KHRoaXMudmlldy5zZXRVaW50OChiKzEsZSYxMjcpLGU9MikpOih0aGlzLnZpZXcuc2V0VWludDgoYixlJjEyNyksZT0xKTtyZXR1cm4gYz8odGhpcy5vZmZzZXQrPWUsdGhpcyk6ZX07ZC5wcm90b3R5cGUud3JpdGVWYXJpbnQzMlppZ1phZz1mdW5jdGlvbihhLGIpe3JldHVybiB0aGlzLndyaXRlVmFyaW50MzIoZC56aWdaYWdFbmNvZGUzMihhKSxiKX07ZC5wcm90b3R5cGUucmVhZFZhcmludDMyPVxuZnVuY3Rpb24oYSl7dmFyIGI9XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBhO2ImJihhPXRoaXMub2Zmc2V0KTtpZighdGhpcy5ub0Fzc2VydCl7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBhfHwwIT09YSUxKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrYStcIiAobm90IGFuIGludGVnZXIpXCIpO2E+Pj49MDtpZigwPmF8fGErMT50aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrYStcIiAoKzEpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO312YXIgYz0wLGU9MCxkO2RvIGQ9dGhpcy52aWV3LmdldFVpbnQ4KGErYyksNT5jJiYoZXw9KGQmMTI3KTw8NypjPj4+MCksKytjO3doaWxlKDEyOD09PShkJjEyOCkpO2V8PTA7cmV0dXJuIGI/KHRoaXMub2Zmc2V0Kz1jLGUpOnt2YWx1ZTplLGxlbmd0aDpjfX07ZC5wcm90b3R5cGUucmVhZFZhcmludDMyWmlnWmFnPWZ1bmN0aW9uKGEpe2E9dGhpcy5yZWFkVmFyaW50MzIoYSk7XG5cIm9iamVjdFwiPT09dHlwZW9mIGE/YS52YWx1ZT1kLnppZ1phZ0RlY29kZTMyKGEudmFsdWUpOmE9ZC56aWdaYWdEZWNvZGUzMihhKTtyZXR1cm4gYX07bCYmKGQuTUFYX1ZBUklOVDY0X0JZVEVTPTEwLGQuY2FsY3VsYXRlVmFyaW50NjQ9ZnVuY3Rpb24oYSl7XCJudW1iZXJcIj09PXR5cGVvZiBhJiYoYT1sLmZyb21OdW1iZXIoYSkpO3ZhciBiPWEudG9JbnQoKT4+PjAsYz1hLnNoaWZ0UmlnaHRVbnNpZ25lZCgyOCkudG9JbnQoKT4+PjA7YT1hLnNoaWZ0UmlnaHRVbnNpZ25lZCg1NikudG9JbnQoKT4+PjA7cmV0dXJuIDA9PWE/MD09Yz8xNjM4ND5iPzEyOD5iPzE6MjoyMDk3MTUyPmI/Mzo0OjE2Mzg0PmM/MTI4PmM/NTo2OjIwOTcxNTI+Yz83Ojg6MTI4PmE/OToxMH0sZC56aWdaYWdFbmNvZGU2ND1mdW5jdGlvbihhKXtcIm51bWJlclwiPT09dHlwZW9mIGE/YT1sLmZyb21OdW1iZXIoYSwhMSk6ITEhPT1hLnVuc2lnbmVkJiYoYT1hLnRvU2lnbmVkKCkpO3JldHVybiBhLnNoaWZ0TGVmdCgxKS54b3IoYS5zaGlmdFJpZ2h0KDYzKSkudG9VbnNpZ25lZCgpfSxcbmQuemlnWmFnRGVjb2RlNjQ9ZnVuY3Rpb24oYSl7XCJudW1iZXJcIj09PXR5cGVvZiBhP2E9bC5mcm9tTnVtYmVyKGEsITEpOiExIT09YS51bnNpZ25lZCYmKGE9YS50b1NpZ25lZCgpKTtyZXR1cm4gYS5zaGlmdFJpZ2h0VW5zaWduZWQoMSkueG9yKGEuYW5kKGwuT05FKS50b1NpZ25lZCgpLm5lZ2F0ZSgpKS50b1NpZ25lZCgpfSxkLnByb3RvdHlwZS53cml0ZVZhcmludDY0PWZ1bmN0aW9uKGEsYil7dmFyIGM9XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBiO2MmJihiPXRoaXMub2Zmc2V0KTtpZighdGhpcy5ub0Fzc2VydCl7aWYoXCJudW1iZXJcIj09PXR5cGVvZiBhKWE9bC5mcm9tTnVtYmVyKGEpO2Vsc2UgaWYoIShhJiZhIGluc3RhbmNlb2YgbCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgdmFsdWU6IFwiK2ErXCIgKG5vdCBhbiBpbnRlZ2VyIG9yIExvbmcpXCIpO2lmKFwibnVtYmVyXCIhPT10eXBlb2YgYnx8MCE9PWIlMSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK1xuYitcIiAobm90IGFuIGludGVnZXIpXCIpO2I+Pj49MDtpZigwPmJ8fGIrMD50aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrYitcIiAoKzApIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO31cIm51bWJlclwiPT09dHlwZW9mIGE/YT1sLmZyb21OdW1iZXIoYSwhMSk6ITEhPT1hLnVuc2lnbmVkJiYoYT1hLnRvU2lnbmVkKCkpO3ZhciBlPWQuY2FsY3VsYXRlVmFyaW50NjQoYSksaD1hLnRvSW50KCk+Pj4wLGY9YS5zaGlmdFJpZ2h0VW5zaWduZWQoMjgpLnRvSW50KCk+Pj4wLGc9YS5zaGlmdFJpZ2h0VW5zaWduZWQoNTYpLnRvSW50KCk+Pj4wO2IrPWU7dmFyIG49dGhpcy5idWZmZXIuYnl0ZUxlbmd0aDtiPm4mJnRoaXMucmVzaXplKChuKj0yKT5iP246Yik7Yi09ZTtzd2l0Y2goZSl7Y2FzZSAxMDp0aGlzLnZpZXcuc2V0VWludDgoYis5LGc+Pj43JjEpO2Nhc2UgOTp0aGlzLnZpZXcuc2V0VWludDgoYis4LDkhPT1cbmU/Z3wxMjg6ZyYxMjcpO2Nhc2UgODp0aGlzLnZpZXcuc2V0VWludDgoYis3LDghPT1lP2Y+Pj4yMXwxMjg6Zj4+PjIxJjEyNyk7Y2FzZSA3OnRoaXMudmlldy5zZXRVaW50OChiKzYsNyE9PWU/Zj4+PjE0fDEyODpmPj4+MTQmMTI3KTtjYXNlIDY6dGhpcy52aWV3LnNldFVpbnQ4KGIrNSw2IT09ZT9mPj4+N3wxMjg6Zj4+PjcmMTI3KTtjYXNlIDU6dGhpcy52aWV3LnNldFVpbnQ4KGIrNCw1IT09ZT9mfDEyODpmJjEyNyk7Y2FzZSA0OnRoaXMudmlldy5zZXRVaW50OChiKzMsNCE9PWU/aD4+PjIxfDEyODpoPj4+MjEmMTI3KTtjYXNlIDM6dGhpcy52aWV3LnNldFVpbnQ4KGIrMiwzIT09ZT9oPj4+MTR8MTI4Omg+Pj4xNCYxMjcpO2Nhc2UgMjp0aGlzLnZpZXcuc2V0VWludDgoYisxLDIhPT1lP2g+Pj43fDEyODpoPj4+NyYxMjcpO2Nhc2UgMTp0aGlzLnZpZXcuc2V0VWludDgoYiwxIT09ZT9ofDEyODpoJjEyNyl9cmV0dXJuIGM/KHRoaXMub2Zmc2V0Kz1lLHRoaXMpOmV9LGQucHJvdG90eXBlLndyaXRlVmFyaW50NjRaaWdaYWc9XG5mdW5jdGlvbihhLGIpe3JldHVybiB0aGlzLndyaXRlVmFyaW50NjQoZC56aWdaYWdFbmNvZGU2NChhKSxiKX0sZC5wcm90b3R5cGUucmVhZFZhcmludDY0PWZ1bmN0aW9uKGEpe3ZhciBiPVwidW5kZWZpbmVkXCI9PT10eXBlb2YgYTtiJiYoYT10aGlzLm9mZnNldCk7aWYoIXRoaXMubm9Bc3NlcnQpe2lmKFwibnVtYmVyXCIhPT10eXBlb2YgYXx8MCE9PWElMSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK2ErXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTthPj4+PTA7aWYoMD5hfHxhKzE+dGhpcy5idWZmZXIuYnl0ZUxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK2ErXCIgKCsxKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTt9dmFyIGM9YSxlPTAsZD0wLGY9MCxnPTAsZz10aGlzLnZpZXcuZ2V0VWludDgoYSsrKSxlPWcmMTI3O2lmKGcmMTI4JiYoZz10aGlzLnZpZXcuZ2V0VWludDgoYSsrKSxlfD0oZyYxMjcpPDw3LGcmMTI4JiZcbihnPXRoaXMudmlldy5nZXRVaW50OChhKyspLGV8PShnJjEyNyk8PDE0LGcmMTI4JiYoZz10aGlzLnZpZXcuZ2V0VWludDgoYSsrKSxlfD0oZyYxMjcpPDwyMSxnJjEyOCYmKGc9dGhpcy52aWV3LmdldFVpbnQ4KGErKyksZD1nJjEyNyxnJjEyOCYmKGc9dGhpcy52aWV3LmdldFVpbnQ4KGErKyksZHw9KGcmMTI3KTw8NyxnJjEyOCYmKGc9dGhpcy52aWV3LmdldFVpbnQ4KGErKyksZHw9KGcmMTI3KTw8MTQsZyYxMjgmJihnPXRoaXMudmlldy5nZXRVaW50OChhKyspLGR8PShnJjEyNyk8PDIxLGcmMTI4JiYoZz10aGlzLnZpZXcuZ2V0VWludDgoYSsrKSxmPWcmMTI3LGcmMTI4JiYoZz10aGlzLnZpZXcuZ2V0VWludDgoYSsrKSxmfD0oZyYxMjcpPDw3LGcmMTI4KSkpKSkpKSkpKXRocm93IEVycm9yKFwiRGF0YSBtdXN0IGJlIGNvcnJ1cHQ6IEJ1ZmZlciBvdmVycnVuXCIpO2U9bC5mcm9tMjhCaXRzKGUsZCxmLCExKTtyZXR1cm4gYj8odGhpcy5vZmZzZXQ9YSxlKTp7dmFsdWU6ZSxsZW5ndGg6YS1cbmN9fSxkLnByb3RvdHlwZS5yZWFkVmFyaW50NjRaaWdaYWc9ZnVuY3Rpb24oYSl7KGE9dGhpcy5yZWFkVmFyaW50NjQoYSkpJiZhLnZhbHVlIGluc3RhbmNlb2YgbD9hLnZhbHVlPWQuemlnWmFnRGVjb2RlNjQoYS52YWx1ZSk6YT1kLnppZ1phZ0RlY29kZTY0KGEpO3JldHVybiBhfSk7ZC5wcm90b3R5cGUud3JpdGVDU3RyaW5nPWZ1bmN0aW9uKGEsYil7dmFyIGM9XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBiO2MmJihiPXRoaXMub2Zmc2V0KTt2YXIgZSxkPWEubGVuZ3RoO2lmKCF0aGlzLm5vQXNzZXJ0KXtpZihcInN0cmluZ1wiIT09dHlwZW9mIGEpdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgc3RyOiBOb3QgYSBzdHJpbmdcIik7Zm9yKGU9MDtlPGQ7KytlKWlmKDA9PT1hLmNoYXJDb2RlQXQoZSkpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIHN0cjogQ29udGFpbnMgTlVMTC1jaGFyYWN0ZXJzXCIpO2lmKFwibnVtYmVyXCIhPT10eXBlb2YgYnx8MCE9PWIlMSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK1xuYitcIiAobm90IGFuIGludGVnZXIpXCIpO2I+Pj49MDtpZigwPmJ8fGIrMD50aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrYitcIiAoKzApIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO31lPWI7ZD1rLmIoay5hKGEpKVsxXTtiKz1kKzE7dmFyIGY9dGhpcy5idWZmZXIuYnl0ZUxlbmd0aDtiPmYmJnRoaXMucmVzaXplKChmKj0yKT5iP2Y6Yik7Yi09ZCsxO2suZShrLmEoYSksZnVuY3Rpb24oYSl7dGhpcy52aWV3LnNldFVpbnQ4KGIrKyxhKX0uYmluZCh0aGlzKSk7dGhpcy52aWV3LnNldFVpbnQ4KGIrKywwKTtyZXR1cm4gYz8odGhpcy5vZmZzZXQ9Yi1lLHRoaXMpOmR9O2QucHJvdG90eXBlLnJlYWRDU3RyaW5nPWZ1bmN0aW9uKGEpe3ZhciBiPVwidW5kZWZpbmVkXCI9PT10eXBlb2YgYTtiJiYoYT10aGlzLm9mZnNldCk7aWYoIXRoaXMubm9Bc3NlcnQpe2lmKFwibnVtYmVyXCIhPT10eXBlb2YgYXx8MCE9PWElMSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK1xuYStcIiAobm90IGFuIGludGVnZXIpXCIpO2E+Pj49MDtpZigwPmF8fGErMT50aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrYStcIiAoKzEpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO312YXIgYz1hLGUsZD0tMTtrLmQoZnVuY3Rpb24oKXtpZigwPT09ZClyZXR1cm4gbnVsbDtpZihhPj10aGlzLmxpbWl0KXRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIHJhbmdlOiBUcnVuY2F0ZWQgZGF0YSwgXCIrYStcIiA8IFwiK3RoaXMubGltaXQpO3JldHVybiAwPT09KGQ9dGhpcy52aWV3LmdldFVpbnQ4KGErKykpP251bGw6ZH0uYmluZCh0aGlzKSxlPWsuYygpLCEwKTtyZXR1cm4gYj8odGhpcy5vZmZzZXQ9YSxlKCkpOntzdHJpbmc6ZSgpLGxlbmd0aDphLWN9fTtkLnByb3RvdHlwZS53cml0ZUlTdHJpbmc9ZnVuY3Rpb24oYSxiKXt2YXIgYz1cInVuZGVmaW5lZFwiPT09dHlwZW9mIGI7YyYmKGI9dGhpcy5vZmZzZXQpO2lmKCF0aGlzLm5vQXNzZXJ0KXtpZihcInN0cmluZ1wiIT09XG50eXBlb2YgYSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBzdHI6IE5vdCBhIHN0cmluZ1wiKTtpZihcIm51bWJlclwiIT09dHlwZW9mIGJ8fDAhPT1iJTEpdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitiK1wiIChub3QgYW4gaW50ZWdlcilcIik7Yj4+Pj0wO2lmKDA+Ynx8YiswPnRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitiK1wiICgrMCkgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7fXZhciBlPWIsZDtkPWsuYihrLmEoYSksdGhpcy5ub0Fzc2VydClbMV07Yis9NCtkO3ZhciBmPXRoaXMuYnVmZmVyLmJ5dGVMZW5ndGg7Yj5mJiZ0aGlzLnJlc2l6ZSgoZio9Mik+Yj9mOmIpO2ItPTQrZDt0aGlzLnZpZXcuc2V0VWludDMyKGIsZCx0aGlzLmxpdHRsZUVuZGlhbik7Yis9NDtrLmUoay5hKGEpLGZ1bmN0aW9uKGEpe3RoaXMudmlldy5zZXRVaW50OChiKyssYSl9LmJpbmQodGhpcykpO1xuaWYoYiE9PWUrNCtkKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSWxsZWdhbCByYW5nZTogVHJ1bmNhdGVkIGRhdGEsIFwiK2IrXCIgPT0gXCIrKGIrNCtkKSk7cmV0dXJuIGM/KHRoaXMub2Zmc2V0PWIsdGhpcyk6Yi1lfTtkLnByb3RvdHlwZS5yZWFkSVN0cmluZz1mdW5jdGlvbihhKXt2YXIgYj1cInVuZGVmaW5lZFwiPT09dHlwZW9mIGE7YiYmKGE9dGhpcy5vZmZzZXQpO2lmKCF0aGlzLm5vQXNzZXJ0KXtpZihcIm51bWJlclwiIT09dHlwZW9mIGF8fDAhPT1hJTEpdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIithK1wiIChub3QgYW4gaW50ZWdlcilcIik7YT4+Pj0wO2lmKDA+YXx8YSs0PnRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIithK1wiICgrNCkgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7fXZhciBjPTAsZT1hLGM9dGhpcy52aWV3LmdldFVpbnQzMihhLHRoaXMubGl0dGxlRW5kaWFuKTthKz1cbjQ7dmFyIGQ9YStjO2suZChmdW5jdGlvbigpe3JldHVybiBhPGQ/dGhpcy52aWV3LmdldFVpbnQ4KGErKyk6bnVsbH0uYmluZCh0aGlzKSxjPWsuYygpLHRoaXMubm9Bc3NlcnQpO2M9YygpO3JldHVybiBiPyh0aGlzLm9mZnNldD1hLGMpOntzdHJpbmc6YyxsZW5ndGg6YS1lfX07ZC5NRVRSSUNTX0NIQVJTPVwiY1wiO2QuTUVUUklDU19CWVRFUz1cImJcIjtkLnByb3RvdHlwZS53cml0ZVVURjhTdHJpbmc9ZnVuY3Rpb24oYSxiKXt2YXIgYz1cInVuZGVmaW5lZFwiPT09dHlwZW9mIGI7YyYmKGI9dGhpcy5vZmZzZXQpO2lmKCF0aGlzLm5vQXNzZXJ0KXtpZihcIm51bWJlclwiIT09dHlwZW9mIGJ8fDAhPT1iJTEpdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitiK1wiIChub3QgYW4gaW50ZWdlcilcIik7Yj4+Pj0wO2lmKDA+Ynx8YiswPnRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitiK1wiICgrMCkgPD0gXCIrXG50aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTt9dmFyIGUsZD1iO2U9ay5iKGsuYShhKSlbMV07Yis9ZTt2YXIgZj10aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoO2I+ZiYmdGhpcy5yZXNpemUoKGYqPTIpPmI/ZjpiKTtiLT1lO2suZShrLmEoYSksZnVuY3Rpb24oYSl7dGhpcy52aWV3LnNldFVpbnQ4KGIrKyxhKX0uYmluZCh0aGlzKSk7cmV0dXJuIGM/KHRoaXMub2Zmc2V0PWIsdGhpcyk6Yi1kfTtkLnByb3RvdHlwZS53cml0ZVN0cmluZz1kLnByb3RvdHlwZS53cml0ZVVURjhTdHJpbmc7ZC5jYWxjdWxhdGVVVEY4Q2hhcnM9ZnVuY3Rpb24oYSl7cmV0dXJuIGsuYihrLmEoYSkpWzBdfTtkLmNhbGN1bGF0ZVVURjhCeXRlcz1mdW5jdGlvbihhKXtyZXR1cm4gay5iKGsuYShhKSlbMV19O2QucHJvdG90eXBlLnJlYWRVVEY4U3RyaW5nPWZ1bmN0aW9uKGEsYixjKXtcIm51bWJlclwiPT09dHlwZW9mIGImJihjPWIsYj12b2lkIDApO3ZhciBlPVwidW5kZWZpbmVkXCI9PT10eXBlb2YgYztlJiYoYz10aGlzLm9mZnNldCk7XG5cInVuZGVmaW5lZFwiPT09dHlwZW9mIGImJihiPWQuTUVUUklDU19DSEFSUyk7aWYoIXRoaXMubm9Bc3NlcnQpe2lmKFwibnVtYmVyXCIhPT10eXBlb2YgYXx8MCE9PWElMSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBsZW5ndGg6IFwiK2ErXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTthfD0wO2lmKFwibnVtYmVyXCIhPT10eXBlb2YgY3x8MCE9PWMlMSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK2MrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtjPj4+PTA7aWYoMD5jfHxjKzA+dGhpcy5idWZmZXIuYnl0ZUxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK2MrXCIgKCswKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTt9dmFyIGg9MCxmPWMsZztpZihiPT09ZC5NRVRSSUNTX0NIQVJTKXtnPWsuYygpO2suaShmdW5jdGlvbigpe3JldHVybiBoPGEmJmM8dGhpcy5saW1pdD90aGlzLnZpZXcuZ2V0VWludDgoYysrKTpudWxsfS5iaW5kKHRoaXMpLFxuZnVuY3Rpb24oYSl7KytoO2suZyhhLGcpfS5iaW5kKHRoaXMpKTtpZihoIT09YSl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIklsbGVnYWwgcmFuZ2U6IFRydW5jYXRlZCBkYXRhLCBcIitoK1wiID09IFwiK2EpO3JldHVybiBlPyh0aGlzLm9mZnNldD1jLGcoKSk6e3N0cmluZzpnKCksbGVuZ3RoOmMtZn19aWYoYj09PWQuTUVUUklDU19CWVRFUyl7aWYoIXRoaXMubm9Bc3NlcnQpe2lmKFwibnVtYmVyXCIhPT10eXBlb2YgY3x8MCE9PWMlMSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK2MrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtjPj4+PTA7aWYoMD5jfHxjK2E+dGhpcy5idWZmZXIuYnl0ZUxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK2MrXCIgKCtcIithK1wiKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTt9dmFyIG49YythO2suZChmdW5jdGlvbigpe3JldHVybiBjPG4/dGhpcy52aWV3LmdldFVpbnQ4KGMrKyk6bnVsbH0uYmluZCh0aGlzKSxcbmc9ay5jKCksdGhpcy5ub0Fzc2VydCk7aWYoYyE9PW4pdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIHJhbmdlOiBUcnVuY2F0ZWQgZGF0YSwgXCIrYytcIiA9PSBcIituKTtyZXR1cm4gZT8odGhpcy5vZmZzZXQ9YyxnKCkpOntzdHJpbmc6ZygpLGxlbmd0aDpjLWZ9fXRocm93IG5ldyBUeXBlRXJyb3IoXCJVbnN1cHBvcnRlZCBtZXRyaWNzOiBcIitiKTt9O2QucHJvdG90eXBlLnJlYWRTdHJpbmc9ZC5wcm90b3R5cGUucmVhZFVURjhTdHJpbmc7ZC5wcm90b3R5cGUud3JpdGVWU3RyaW5nPWZ1bmN0aW9uKGEsYil7dmFyIGM9XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBiO2MmJihiPXRoaXMub2Zmc2V0KTtpZighdGhpcy5ub0Fzc2VydCl7aWYoXCJzdHJpbmdcIiE9PXR5cGVvZiBhKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIHN0cjogTm90IGEgc3RyaW5nXCIpO2lmKFwibnVtYmVyXCIhPT10eXBlb2YgYnx8MCE9PWIlMSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK2IrXG5cIiAobm90IGFuIGludGVnZXIpXCIpO2I+Pj49MDtpZigwPmJ8fGIrMD50aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrYitcIiAoKzApIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO312YXIgZT1iLGgsZjtoPWsuYihrLmEoYSksdGhpcy5ub0Fzc2VydClbMV07Zj1kLmNhbGN1bGF0ZVZhcmludDMyKGgpO2IrPWYraDt2YXIgZz10aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoO2I+ZyYmdGhpcy5yZXNpemUoKGcqPTIpPmI/ZzpiKTtiLT1mK2g7Yis9dGhpcy53cml0ZVZhcmludDMyKGgsYik7ay5lKGsuYShhKSxmdW5jdGlvbihhKXt0aGlzLnZpZXcuc2V0VWludDgoYisrLGEpfS5iaW5kKHRoaXMpKTtpZihiIT09ZStoK2YpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIHJhbmdlOiBUcnVuY2F0ZWQgZGF0YSwgXCIrYitcIiA9PSBcIisoYitoK2YpKTtyZXR1cm4gYz8odGhpcy5vZmZzZXQ9Yix0aGlzKTpiLWV9O2QucHJvdG90eXBlLnJlYWRWU3RyaW5nPVxuZnVuY3Rpb24oYSl7dmFyIGI9XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBhO2ImJihhPXRoaXMub2Zmc2V0KTtpZighdGhpcy5ub0Fzc2VydCl7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBhfHwwIT09YSUxKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrYStcIiAobm90IGFuIGludGVnZXIpXCIpO2E+Pj49MDtpZigwPmF8fGErMT50aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrYStcIiAoKzEpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO312YXIgYz10aGlzLnJlYWRWYXJpbnQzMihhKSxlPWE7YSs9Yy5sZW5ndGg7dmFyIGM9Yy52YWx1ZSxkPWErYyxjPWsuYygpO2suZChmdW5jdGlvbigpe3JldHVybiBhPGQ/dGhpcy52aWV3LmdldFVpbnQ4KGErKyk6bnVsbH0uYmluZCh0aGlzKSxjLHRoaXMubm9Bc3NlcnQpO2M9YygpO3JldHVybiBiPyh0aGlzLm9mZnNldD1hLGMpOntzdHJpbmc6YyxsZW5ndGg6YS1cbmV9fTtkLnByb3RvdHlwZS5hcHBlbmQ9ZnVuY3Rpb24oYSxiLGMpe2lmKFwibnVtYmVyXCI9PT10eXBlb2YgYnx8XCJzdHJpbmdcIiE9PXR5cGVvZiBiKWM9YixiPXZvaWQgMDt2YXIgZT1cInVuZGVmaW5lZFwiPT09dHlwZW9mIGM7ZSYmKGM9dGhpcy5vZmZzZXQpO2lmKCF0aGlzLm5vQXNzZXJ0KXtpZihcIm51bWJlclwiIT09dHlwZW9mIGN8fDAhPT1jJTEpdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitjK1wiIChub3QgYW4gaW50ZWdlcilcIik7Yz4+Pj0wO2lmKDA+Y3x8YyswPnRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitjK1wiICgrMCkgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7fWEgaW5zdGFuY2VvZiBkfHwoYT1kLndyYXAoYSxiKSk7Yj1hLmxpbWl0LWEub2Zmc2V0O2lmKDA+PWIpcmV0dXJuIHRoaXM7Yys9Yjt2YXIgaD10aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoO2M+aCYmdGhpcy5yZXNpemUoKGgqPVxuMik+Yz9oOmMpOyhuZXcgVWludDhBcnJheSh0aGlzLmJ1ZmZlcixjLWIpKS5zZXQoKG5ldyBVaW50OEFycmF5KGEuYnVmZmVyKSkuc3ViYXJyYXkoYS5vZmZzZXQsYS5saW1pdCkpO2Eub2Zmc2V0Kz1iO2UmJih0aGlzLm9mZnNldCs9Yik7cmV0dXJuIHRoaXN9O2QucHJvdG90eXBlLmFwcGVuZFRvPWZ1bmN0aW9uKGEsYil7YS5hcHBlbmQodGhpcyxiKTtyZXR1cm4gdGhpc307ZC5wcm90b3R5cGUuYXNzZXJ0PWZ1bmN0aW9uKGEpe3RoaXMubm9Bc3NlcnQ9IWE7cmV0dXJuIHRoaXN9O2QucHJvdG90eXBlLmNhcGFjaXR5PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGh9O2QucHJvdG90eXBlLmNsZWFyPWZ1bmN0aW9uKCl7dGhpcy5vZmZzZXQ9MDt0aGlzLmxpbWl0PXRoaXMuYnVmZmVyLmJ5dGVMZW5ndGg7dGhpcy5tYXJrZWRPZmZzZXQ9LTE7cmV0dXJuIHRoaXN9O2QucHJvdG90eXBlLmNsb25lPWZ1bmN0aW9uKGEpe3ZhciBiPW5ldyBkKDAsdGhpcy5saXR0bGVFbmRpYW4sXG50aGlzLm5vQXNzZXJ0KTthPyhhPW5ldyBBcnJheUJ1ZmZlcih0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKSwobmV3IFVpbnQ4QXJyYXkoYSkpLnNldCh0aGlzLmJ1ZmZlciksYi5idWZmZXI9YSxiLnZpZXc9bmV3IERhdGFWaWV3KGEpKTooYi5idWZmZXI9dGhpcy5idWZmZXIsYi52aWV3PXRoaXMudmlldyk7Yi5vZmZzZXQ9dGhpcy5vZmZzZXQ7Yi5tYXJrZWRPZmZzZXQ9dGhpcy5tYXJrZWRPZmZzZXQ7Yi5saW1pdD10aGlzLmxpbWl0O3JldHVybiBifTtkLnByb3RvdHlwZS5jb21wYWN0PWZ1bmN0aW9uKGEsYil7XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBhJiYoYT10aGlzLm9mZnNldCk7XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBiJiYoYj10aGlzLmxpbWl0KTtpZighdGhpcy5ub0Fzc2VydCl7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBhfHwwIT09YSUxKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGJlZ2luOiBOb3QgYW4gaW50ZWdlclwiKTthPj4+PTA7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBifHxcbjAhPT1iJTEpdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgZW5kOiBOb3QgYW4gaW50ZWdlclwiKTtiPj4+PTA7aWYoMD5hfHxhPmJ8fGI+dGhpcy5idWZmZXIuYnl0ZUxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIklsbGVnYWwgcmFuZ2U6IDAgPD0gXCIrYStcIiA8PSBcIitiK1wiIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO31pZigwPT09YSYmYj09PXRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpcmV0dXJuIHRoaXM7dmFyIGM9Yi1hO2lmKDA9PT1jKXJldHVybiB0aGlzLmJ1ZmZlcj1yLHRoaXMudmlldz1udWxsLDA8PXRoaXMubWFya2VkT2Zmc2V0JiYodGhpcy5tYXJrZWRPZmZzZXQtPWEpLHRoaXMubGltaXQ9dGhpcy5vZmZzZXQ9MCx0aGlzO3ZhciBlPW5ldyBBcnJheUJ1ZmZlcihjKTsobmV3IFVpbnQ4QXJyYXkoZSkpLnNldCgobmV3IFVpbnQ4QXJyYXkodGhpcy5idWZmZXIpKS5zdWJhcnJheShhLGIpKTt0aGlzLmJ1ZmZlcj1lO3RoaXMudmlldz1uZXcgRGF0YVZpZXcoZSk7XG4wPD10aGlzLm1hcmtlZE9mZnNldCYmKHRoaXMubWFya2VkT2Zmc2V0LT1hKTt0aGlzLm9mZnNldD0wO3RoaXMubGltaXQ9YztyZXR1cm4gdGhpc307ZC5wcm90b3R5cGUuY29weT1mdW5jdGlvbihhLGIpe1widW5kZWZpbmVkXCI9PT10eXBlb2YgYSYmKGE9dGhpcy5vZmZzZXQpO1widW5kZWZpbmVkXCI9PT10eXBlb2YgYiYmKGI9dGhpcy5saW1pdCk7aWYoIXRoaXMubm9Bc3NlcnQpe2lmKFwibnVtYmVyXCIhPT10eXBlb2YgYXx8MCE9PWElMSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBiZWdpbjogTm90IGFuIGludGVnZXJcIik7YT4+Pj0wO2lmKFwibnVtYmVyXCIhPT10eXBlb2YgYnx8MCE9PWIlMSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBlbmQ6IE5vdCBhbiBpbnRlZ2VyXCIpO2I+Pj49MDtpZigwPmF8fGE+Ynx8Yj50aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSWxsZWdhbCByYW5nZTogMCA8PSBcIithK1wiIDw9IFwiK2IrXCIgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG59aWYoYT09PWIpcmV0dXJuIG5ldyBkKDAsdGhpcy5saXR0bGVFbmRpYW4sdGhpcy5ub0Fzc2VydCk7dmFyIGM9Yi1hLGU9bmV3IGQoYyx0aGlzLmxpdHRsZUVuZGlhbix0aGlzLm5vQXNzZXJ0KTtlLm9mZnNldD0wO2UubGltaXQ9YzswPD1lLm1hcmtlZE9mZnNldCYmKGUubWFya2VkT2Zmc2V0LT1hKTt0aGlzLmNvcHlUbyhlLDAsYSxiKTtyZXR1cm4gZX07ZC5wcm90b3R5cGUuY29weVRvPWZ1bmN0aW9uKGEsYixjLGUpe3ZhciBoLGY7aWYoIXRoaXMubm9Bc3NlcnQmJiFkLmlzQnl0ZUJ1ZmZlcihhKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCB0YXJnZXQ6IE5vdCBhIEJ5dGVCdWZmZXJcIik7Yj0oZj1cInVuZGVmaW5lZFwiPT09dHlwZW9mIGIpP2Eub2Zmc2V0OmJ8MDtjPShoPVwidW5kZWZpbmVkXCI9PT10eXBlb2YgYyk/dGhpcy5vZmZzZXQ6Y3wwO2U9XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBlP3RoaXMubGltaXQ6ZXwwO2lmKDA+Ynx8Yj5hLmJ1ZmZlci5ieXRlTGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSWxsZWdhbCB0YXJnZXQgcmFuZ2U6IDAgPD0gXCIrXG5iK1wiIDw9IFwiK2EuYnVmZmVyLmJ5dGVMZW5ndGgpO2lmKDA+Y3x8ZT50aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSWxsZWdhbCBzb3VyY2UgcmFuZ2U6IDAgPD0gXCIrYytcIiA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTt2YXIgZz1lLWM7aWYoMD09PWcpcmV0dXJuIGE7YS5lbnN1cmVDYXBhY2l0eShiK2cpOyhuZXcgVWludDhBcnJheShhLmJ1ZmZlcikpLnNldCgobmV3IFVpbnQ4QXJyYXkodGhpcy5idWZmZXIpKS5zdWJhcnJheShjLGUpLGIpO2gmJih0aGlzLm9mZnNldCs9Zyk7ZiYmKGEub2Zmc2V0Kz1nKTtyZXR1cm4gdGhpc307ZC5wcm90b3R5cGUuZW5zdXJlQ2FwYWNpdHk9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5idWZmZXIuYnl0ZUxlbmd0aDtyZXR1cm4gYjxhP3RoaXMucmVzaXplKChiKj0yKT5hP2I6YSk6dGhpc307ZC5wcm90b3R5cGUuZmlsbD1mdW5jdGlvbihhLGIsYyl7dmFyIGU9XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBiO2UmJlxuKGI9dGhpcy5vZmZzZXQpO1wic3RyaW5nXCI9PT10eXBlb2YgYSYmMDxhLmxlbmd0aCYmKGE9YS5jaGFyQ29kZUF0KDApKTtcInVuZGVmaW5lZFwiPT09dHlwZW9mIGImJihiPXRoaXMub2Zmc2V0KTtcInVuZGVmaW5lZFwiPT09dHlwZW9mIGMmJihjPXRoaXMubGltaXQpO2lmKCF0aGlzLm5vQXNzZXJ0KXtpZihcIm51bWJlclwiIT09dHlwZW9mIGF8fDAhPT1hJTEpdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgdmFsdWU6IFwiK2ErXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTthfD0wO2lmKFwibnVtYmVyXCIhPT10eXBlb2YgYnx8MCE9PWIlMSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBiZWdpbjogTm90IGFuIGludGVnZXJcIik7Yj4+Pj0wO2lmKFwibnVtYmVyXCIhPT10eXBlb2YgY3x8MCE9PWMlMSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBlbmQ6IE5vdCBhbiBpbnRlZ2VyXCIpO2M+Pj49MDtpZigwPmJ8fGI+Y3x8Yz50aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSWxsZWdhbCByYW5nZTogMCA8PSBcIitcbmIrXCIgPD0gXCIrYytcIiA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTt9aWYoYj49YylyZXR1cm4gdGhpcztmb3IoO2I8YzspdGhpcy52aWV3LnNldFVpbnQ4KGIrKyxhKTtlJiYodGhpcy5vZmZzZXQ9Yik7cmV0dXJuIHRoaXN9O2QucHJvdG90eXBlLmZsaXA9ZnVuY3Rpb24oKXt0aGlzLmxpbWl0PXRoaXMub2Zmc2V0O3RoaXMub2Zmc2V0PTA7cmV0dXJuIHRoaXN9O2QucHJvdG90eXBlLm1hcms9ZnVuY3Rpb24oYSl7YT1cInVuZGVmaW5lZFwiPT09dHlwZW9mIGE/dGhpcy5vZmZzZXQ6YTtpZighdGhpcy5ub0Fzc2VydCl7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBhfHwwIT09YSUxKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrYStcIiAobm90IGFuIGludGVnZXIpXCIpO2E+Pj49MDtpZigwPmF8fGErMD50aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrYStcIiAoKzApIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xufXRoaXMubWFya2VkT2Zmc2V0PWE7cmV0dXJuIHRoaXN9O2QucHJvdG90eXBlLm9yZGVyPWZ1bmN0aW9uKGEpe2lmKCF0aGlzLm5vQXNzZXJ0JiZcImJvb2xlYW5cIiE9PXR5cGVvZiBhKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGxpdHRsZUVuZGlhbjogTm90IGEgYm9vbGVhblwiKTt0aGlzLmxpdHRsZUVuZGlhbj0hIWE7cmV0dXJuIHRoaXN9O2QucHJvdG90eXBlLkxFPWZ1bmN0aW9uKGEpe3RoaXMubGl0dGxlRW5kaWFuPVwidW5kZWZpbmVkXCIhPT10eXBlb2YgYT8hIWE6ITA7cmV0dXJuIHRoaXN9O2QucHJvdG90eXBlLkJFPWZ1bmN0aW9uKGEpe3RoaXMubGl0dGxlRW5kaWFuPVwidW5kZWZpbmVkXCIhPT10eXBlb2YgYT8hYTohMTtyZXR1cm4gdGhpc307ZC5wcm90b3R5cGUucHJlcGVuZD1mdW5jdGlvbihhLGIsYyl7aWYoXCJudW1iZXJcIj09PXR5cGVvZiBifHxcInN0cmluZ1wiIT09dHlwZW9mIGIpYz1iLGI9dm9pZCAwO3ZhciBlPVwidW5kZWZpbmVkXCI9PT10eXBlb2YgYztlJiYoYz1cbnRoaXMub2Zmc2V0KTtpZighdGhpcy5ub0Fzc2VydCl7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBjfHwwIT09YyUxKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrYytcIiAobm90IGFuIGludGVnZXIpXCIpO2M+Pj49MDtpZigwPmN8fGMrMD50aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrYytcIiAoKzApIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO31hIGluc3RhbmNlb2YgZHx8KGE9ZC53cmFwKGEsYikpO2I9YS5saW1pdC1hLm9mZnNldDtpZigwPj1iKXJldHVybiB0aGlzO3ZhciBoPWItYyxmO2lmKDA8aCl7dmFyIGc9bmV3IEFycmF5QnVmZmVyKHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgraCk7Zj1uZXcgVWludDhBcnJheShnKTtmLnNldCgobmV3IFVpbnQ4QXJyYXkodGhpcy5idWZmZXIpKS5zdWJhcnJheShjLHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpLGIpO3RoaXMuYnVmZmVyPWc7dGhpcy52aWV3PVxubmV3IERhdGFWaWV3KGcpO3RoaXMub2Zmc2V0Kz1oOzA8PXRoaXMubWFya2VkT2Zmc2V0JiYodGhpcy5tYXJrZWRPZmZzZXQrPWgpO3RoaXMubGltaXQrPWg7Yys9aH1lbHNlIGY9bmV3IFVpbnQ4QXJyYXkodGhpcy5idWZmZXIpO2Yuc2V0KChuZXcgVWludDhBcnJheShhLmJ1ZmZlcikpLnN1YmFycmF5KGEub2Zmc2V0LGEubGltaXQpLGMtYik7YS5vZmZzZXQ9YS5saW1pdDtlJiYodGhpcy5vZmZzZXQtPWIpO3JldHVybiB0aGlzfTtkLnByb3RvdHlwZS5wcmVwZW5kVG89ZnVuY3Rpb24oYSxiKXthLnByZXBlbmQodGhpcyxiKTtyZXR1cm4gdGhpc307ZC5wcm90b3R5cGUucHJpbnREZWJ1Zz1mdW5jdGlvbihhKXtcImZ1bmN0aW9uXCIhPT10eXBlb2YgYSYmKGE9Y29uc29sZS5sb2cuYmluZChjb25zb2xlKSk7YSh0aGlzLnRvU3RyaW5nKCkrXCJcXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuXCIrdGhpcy50b0RlYnVnKCEwKSl9O1xuZC5wcm90b3R5cGUucmVtYWluaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubGltaXQtdGhpcy5vZmZzZXR9O2QucHJvdG90eXBlLnJlc2V0PWZ1bmN0aW9uKCl7MDw9dGhpcy5tYXJrZWRPZmZzZXQ/KHRoaXMub2Zmc2V0PXRoaXMubWFya2VkT2Zmc2V0LHRoaXMubWFya2VkT2Zmc2V0PS0xKTp0aGlzLm9mZnNldD0wO3JldHVybiB0aGlzfTtkLnByb3RvdHlwZS5yZXNpemU9ZnVuY3Rpb24oYSl7aWYoIXRoaXMubm9Bc3NlcnQpe2lmKFwibnVtYmVyXCIhPT10eXBlb2YgYXx8MCE9PWElMSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBjYXBhY2l0eTogXCIrYStcIiAobm90IGFuIGludGVnZXIpXCIpO2F8PTA7aWYoMD5hKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSWxsZWdhbCBjYXBhY2l0eTogMCA8PSBcIithKTt9dGhpcy5idWZmZXIuYnl0ZUxlbmd0aDxhJiYoYT1uZXcgQXJyYXlCdWZmZXIoYSksKG5ldyBVaW50OEFycmF5KGEpKS5zZXQobmV3IFVpbnQ4QXJyYXkodGhpcy5idWZmZXIpKSxcbnRoaXMuYnVmZmVyPWEsdGhpcy52aWV3PW5ldyBEYXRhVmlldyhhKSk7cmV0dXJuIHRoaXN9O2QucHJvdG90eXBlLnJldmVyc2U9ZnVuY3Rpb24oYSxiKXtcInVuZGVmaW5lZFwiPT09dHlwZW9mIGEmJihhPXRoaXMub2Zmc2V0KTtcInVuZGVmaW5lZFwiPT09dHlwZW9mIGImJihiPXRoaXMubGltaXQpO2lmKCF0aGlzLm5vQXNzZXJ0KXtpZihcIm51bWJlclwiIT09dHlwZW9mIGF8fDAhPT1hJTEpdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgYmVnaW46IE5vdCBhbiBpbnRlZ2VyXCIpO2E+Pj49MDtpZihcIm51bWJlclwiIT09dHlwZW9mIGJ8fDAhPT1iJTEpdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgZW5kOiBOb3QgYW4gaW50ZWdlclwiKTtiPj4+PTA7aWYoMD5hfHxhPmJ8fGI+dGhpcy5idWZmZXIuYnl0ZUxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIklsbGVnYWwgcmFuZ2U6IDAgPD0gXCIrYStcIiA8PSBcIitiK1wiIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO31pZihhPT09YilyZXR1cm4gdGhpcztcbkFycmF5LnByb3RvdHlwZS5yZXZlcnNlLmNhbGwoKG5ldyBVaW50OEFycmF5KHRoaXMuYnVmZmVyKSkuc3ViYXJyYXkoYSxiKSk7dGhpcy52aWV3PW5ldyBEYXRhVmlldyh0aGlzLmJ1ZmZlcik7cmV0dXJuIHRoaXN9O2QucHJvdG90eXBlLnNraXA9ZnVuY3Rpb24oYSl7aWYoIXRoaXMubm9Bc3NlcnQpe2lmKFwibnVtYmVyXCIhPT10eXBlb2YgYXx8MCE9PWElMSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBsZW5ndGg6IFwiK2ErXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTthfD0wfXZhciBiPXRoaXMub2Zmc2V0K2E7aWYoIXRoaXMubm9Bc3NlcnQmJigwPmJ8fGI+dGhpcy5idWZmZXIuYnl0ZUxlbmd0aCkpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIGxlbmd0aDogMCA8PSBcIit0aGlzLm9mZnNldCtcIiArIFwiK2ErXCIgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7dGhpcy5vZmZzZXQ9YjtyZXR1cm4gdGhpc307ZC5wcm90b3R5cGUuc2xpY2U9ZnVuY3Rpb24oYSxiKXtcInVuZGVmaW5lZFwiPT09XG50eXBlb2YgYSYmKGE9dGhpcy5vZmZzZXQpO1widW5kZWZpbmVkXCI9PT10eXBlb2YgYiYmKGI9dGhpcy5saW1pdCk7aWYoIXRoaXMubm9Bc3NlcnQpe2lmKFwibnVtYmVyXCIhPT10eXBlb2YgYXx8MCE9PWElMSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBiZWdpbjogTm90IGFuIGludGVnZXJcIik7YT4+Pj0wO2lmKFwibnVtYmVyXCIhPT10eXBlb2YgYnx8MCE9PWIlMSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBlbmQ6IE5vdCBhbiBpbnRlZ2VyXCIpO2I+Pj49MDtpZigwPmF8fGE+Ynx8Yj50aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSWxsZWdhbCByYW5nZTogMCA8PSBcIithK1wiIDw9IFwiK2IrXCIgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7fXZhciBjPXRoaXMuY2xvbmUoKTtjLm9mZnNldD1hO2MubGltaXQ9YjtyZXR1cm4gY307ZC5wcm90b3R5cGUudG9CdWZmZXI9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5vZmZzZXQsYz10aGlzLmxpbWl0O1xuaWYoYj5jKXZhciBlPWIsYj1jLGM9ZTtpZighdGhpcy5ub0Fzc2VydCl7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBifHwwIT09YiUxKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogTm90IGFuIGludGVnZXJcIik7Yj4+Pj0wO2lmKFwibnVtYmVyXCIhPT10eXBlb2YgY3x8MCE9PWMlMSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBsaW1pdDogTm90IGFuIGludGVnZXJcIik7Yz4+Pj0wO2lmKDA+Ynx8Yj5jfHxjPnRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIHJhbmdlOiAwIDw9IFwiK2IrXCIgPD0gXCIrYytcIiA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTt9aWYoIWEmJjA9PT1iJiZjPT09dGhpcy5idWZmZXIuYnl0ZUxlbmd0aClyZXR1cm4gdGhpcy5idWZmZXI7aWYoYj09PWMpcmV0dXJuIHI7YT1uZXcgQXJyYXlCdWZmZXIoYy1iKTsobmV3IFVpbnQ4QXJyYXkoYSkpLnNldCgobmV3IFVpbnQ4QXJyYXkodGhpcy5idWZmZXIpKS5zdWJhcnJheShiLFxuYyksMCk7cmV0dXJuIGF9O2QucHJvdG90eXBlLnRvQXJyYXlCdWZmZXI9ZC5wcm90b3R5cGUudG9CdWZmZXI7ZC5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24oYSl7aWYoXCJ1bmRlZmluZWRcIj09PXR5cGVvZiBhKXJldHVyblwiQnl0ZUJ1ZmZlckFCKG9mZnNldD1cIit0aGlzLm9mZnNldCtcIixtYXJrZWRPZmZzZXQ9XCIrdGhpcy5tYXJrZWRPZmZzZXQrXCIsbGltaXQ9XCIrdGhpcy5saW1pdCtcIixjYXBhY2l0eT1cIit0aGlzLmNhcGFjaXR5KCkrXCIpXCI7c3dpdGNoKGEpe2Nhc2UgXCJ1dGY4XCI6cmV0dXJuIHRoaXMudG9VVEY4KCk7Y2FzZSBcImJhc2U2NFwiOnJldHVybiB0aGlzLnRvQmFzZTY0KCk7Y2FzZSBcImhleFwiOnJldHVybiB0aGlzLnRvSGV4KCk7Y2FzZSBcImJpbmFyeVwiOnJldHVybiB0aGlzLnRvQmluYXJ5KCk7Y2FzZSBcImRlYnVnXCI6cmV0dXJuIHRoaXMudG9EZWJ1ZygpO2Nhc2UgXCJjb2x1bW5zXCI6cmV0dXJuIHRoaXMubygpO2RlZmF1bHQ6dGhyb3cgRXJyb3IoXCJVbnN1cHBvcnRlZCBlbmNvZGluZzogXCIrXG5hKTt9fTt2YXIgbT1cIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89XCIsbT1tK1wiXCI7ZC5wcm90b3R5cGUudG9CYXNlNjQ9ZnVuY3Rpb24oYSxiKXtcInVuZGVmaW5lZFwiPT09dHlwZW9mIGEmJihhPXRoaXMub2Zmc2V0KTtcInVuZGVmaW5lZFwiPT09dHlwZW9mIGImJihiPXRoaXMubGltaXQpO2lmKCF0aGlzLm5vQXNzZXJ0KXtpZihcIm51bWJlclwiIT09dHlwZW9mIGF8fDAhPT1hJTEpdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgYmVnaW46IE5vdCBhbiBpbnRlZ2VyXCIpO2E+Pj49MDtpZihcIm51bWJlclwiIT09dHlwZW9mIGJ8fDAhPT1iJTEpdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgZW5kOiBOb3QgYW4gaW50ZWdlclwiKTtiPj4+PTA7aWYoMD5hfHxhPmJ8fGI+dGhpcy5idWZmZXIuYnl0ZUxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIklsbGVnYWwgcmFuZ2U6IDAgPD0gXCIrYStcIiA8PSBcIitiK1wiIDw9IFwiK1xudGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7fWlmKGE9PT1iKXJldHVyblwiXCI7Zm9yKHZhciBjLGUsZCxmLGcsayxsPVwiXCI7YTxiOyljPXRoaXMudmlldy5nZXRVaW50OChhKyspLGU9KGY9YTxiKT90aGlzLnZpZXcuZ2V0VWludDgoYSsrKTowLGQ9KGc9YTxiKT90aGlzLnZpZXcuZ2V0VWludDgoYSsrKTowLGs9Yz4+MixjPShjJjMpPDw0fGU+PjQsZT0oZSYxNSk8PDJ8ZD4+NixkJj02MyxnfHwoZD02NCxmfHwoZT02NCkpLGwrPW0uY2hhckF0KGspK20uY2hhckF0KGMpK20uY2hhckF0KGUpK20uY2hhckF0KGQpO3JldHVybiBsfTtkLmZyb21CYXNlNjQ9ZnVuY3Rpb24oYSxiLGMpe2lmKCFjKXtpZihcInN0cmluZ1wiIT09dHlwZW9mIGEpdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgc3RyOiBOb3QgYSBzdHJpbmdcIik7aWYoMCE9PWEubGVuZ3RoJTQpdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgc3RyOiBMZW5ndGggbm90IGEgbXVsdGlwbGUgb2YgNFwiKTt9dmFyIGU9YS5sZW5ndGgsXG5oPTAsZjtmb3IoZj1hLmxlbmd0aC0xOzA8PWY7LS1mKWlmKFwiPVwiPT09YS5jaGFyQXQoZikpaCsrO2Vsc2UgYnJlYWs7aWYoMjxoKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIHN0cjogU3VmZml4IGlzIHRvbyBsYXJnZVwiKTtpZigwPT09ZSlyZXR1cm4gbmV3IGQoMCxiLGMpO3ZhciBnLGssbCxwPW5ldyBkKGUvNCozLWgsYixjKTtmb3IoYj1mPTA7ZjxlOyl7aD1tLmluZGV4T2YoYS5jaGFyQXQoZisrKSk7Zz1mPGU/bS5pbmRleE9mKGEuY2hhckF0KGYrKykpOjA7az1mPGU/bS5pbmRleE9mKGEuY2hhckF0KGYrKykpOjA7bD1mPGU/bS5pbmRleE9mKGEuY2hhckF0KGYrKykpOjA7aWYoIWMmJigwPmh8fDA+Z3x8MD5rfHwwPmwpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIHN0cjogQ29udGFpbnMgbm9uLWJhc2U2NCBjaGFyYWN0ZXJzXCIpO3Audmlldy5zZXRVaW50OChiKyssaDw8MnxnPj40KTs2NCE9PWsmJihwLnZpZXcuc2V0VWludDgoYisrLGc8PDQmMjQwfGs+PjIsXG5iKSw2NCE9PWwmJnAudmlldy5zZXRVaW50OChiKyssazw8NiYxOTJ8bCkpfXAubGltaXQ9YjtyZXR1cm4gcH07ZC5idG9hPWZ1bmN0aW9uKGEpe3JldHVybiBkLmZyb21CaW5hcnkoYSkudG9CYXNlNjQoKX07ZC5hdG9iPWZ1bmN0aW9uKGEpe3JldHVybiBkLmZyb21CYXNlNjQoYSkudG9CaW5hcnkoKX07ZC5wcm90b3R5cGUudG9CaW5hcnk9ZnVuY3Rpb24oYSxiKXthPVwidW5kZWZpbmVkXCI9PT10eXBlb2YgYT90aGlzLm9mZnNldDphO2I9XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBiP3RoaXMubGltaXQ6YjtpZighdGhpcy5ub0Fzc2VydCl7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBhfHwwIT09YSUxKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGJlZ2luOiBOb3QgYW4gaW50ZWdlclwiKTthPj4+PTA7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBifHwwIT09YiUxKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGVuZDogTm90IGFuIGludGVnZXJcIik7Yj4+Pj0wO2lmKDA+YXx8YT5ifHxiPnRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIHJhbmdlOiAwIDw9IFwiK1xuYStcIiA8PSBcIitiK1wiIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO31pZihhPT09YilyZXR1cm5cIlwiO2Zvcih2YXIgYz1bXTthPGI7KWMucHVzaCh0aGlzLnZpZXcuZ2V0VWludDgoYSsrKSk7cmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLGMpfTtkLmZyb21CaW5hcnk9ZnVuY3Rpb24oYSxiLGMpe2lmKCFjJiZcInN0cmluZ1wiIT09dHlwZW9mIGEpdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgc3RyOiBOb3QgYSBzdHJpbmdcIik7Zm9yKHZhciBlPTAsaD1hLmxlbmd0aCxmPW5ldyBkKGgsYixjKTtlPGg7KXtiPWEuY2hhckNvZGVBdChlKTtpZighYyYmMjU1PGIpdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgY2hhckNvZGUgYXQgXCIrZStcIjogMCA8PSBcIitiK1wiIDw9IDI1NVwiKTtmLnZpZXcuc2V0VWludDgoZSsrLGIpfWYubGltaXQ9aDtyZXR1cm4gZn07ZC5wcm90b3R5cGUudG9EZWJ1Zz1mdW5jdGlvbihhKXtmb3IodmFyIGI9LTEsYz10aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoLFxuZSxkPVwiXCIsZj1cIlwiLGc9XCJcIjtiPGM7KXstMSE9PWImJihlPXRoaXMudmlldy5nZXRVaW50OChiKSxkPTE2PmU/ZCsoXCIwXCIrZS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSk6ZCtlLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpLGEmJihmKz0zMjxlJiYxMjc+ZT9TdHJpbmcuZnJvbUNoYXJDb2RlKGUpOlwiLlwiKSk7KytiO2lmKGEmJjA8YiYmMD09PWIlMTYmJmIhPT1jKXtmb3IoOzUxPmQubGVuZ3RoOylkKz1cIiBcIjtnKz1kK2YrXCJcXG5cIjtkPWY9XCJcIn1kPWI9PT10aGlzLm9mZnNldCYmYj09PXRoaXMubGltaXQ/ZCsoYj09PXRoaXMubWFya2VkT2Zmc2V0P1wiIVwiOlwifFwiKTpiPT09dGhpcy5vZmZzZXQ/ZCsoYj09PXRoaXMubWFya2VkT2Zmc2V0P1wiW1wiOlwiPFwiKTpiPT09dGhpcy5saW1pdD9kKyhiPT09dGhpcy5tYXJrZWRPZmZzZXQ/XCJdXCI6XCI+XCIpOmQrKGI9PT10aGlzLm1hcmtlZE9mZnNldD9cIidcIjphfHwwIT09YiYmYiE9PWM/XCIgXCI6XCJcIil9aWYoYSYmXCIgXCIhPT1kKXtmb3IoOzUxPmQubGVuZ3RoOylkKz1cblwiIFwiO2crPWQrZitcIlxcblwifXJldHVybiBhP2c6ZH07ZC5mcm9tRGVidWc9ZnVuY3Rpb24oYSxiLGMpe3ZhciBlPWEubGVuZ3RoO2I9bmV3IGQoKGUrMSkvM3wwLGIsYyk7Zm9yKHZhciBoPTAsZj0wLGcsaz0hMSxsPSExLHA9ITEsbT0hMSxxPSExO2g8ZTspe3N3aXRjaChnPWEuY2hhckF0KGgrKykpe2Nhc2UgXCIhXCI6aWYoIWMpe2lmKGx8fHB8fG0pe3E9ITA7YnJlYWt9bD1wPW09ITB9Yi5vZmZzZXQ9Yi5tYXJrZWRPZmZzZXQ9Yi5saW1pdD1mO2s9ITE7YnJlYWs7Y2FzZSBcInxcIjppZighYyl7aWYobHx8bSl7cT0hMDticmVha31sPW09ITB9Yi5vZmZzZXQ9Yi5saW1pdD1mO2s9ITE7YnJlYWs7Y2FzZSBcIltcIjppZighYyl7aWYobHx8cCl7cT0hMDticmVha31sPXA9ITB9Yi5vZmZzZXQ9Yi5tYXJrZWRPZmZzZXQ9ZjtrPSExO2JyZWFrO2Nhc2UgXCI8XCI6aWYoIWMpe2lmKGwpe3E9ITA7YnJlYWt9bD0hMH1iLm9mZnNldD1mO2s9ITE7YnJlYWs7Y2FzZSBcIl1cIjppZighYyl7aWYobXx8cCl7cT1cbiEwO2JyZWFrfW09cD0hMH1iLmxpbWl0PWIubWFya2VkT2Zmc2V0PWY7az0hMTticmVhaztjYXNlIFwiPlwiOmlmKCFjKXtpZihtKXtxPSEwO2JyZWFrfW09ITB9Yi5saW1pdD1mO2s9ITE7YnJlYWs7Y2FzZSBcIidcIjppZighYyl7aWYocCl7cT0hMDticmVha31wPSEwfWIubWFya2VkT2Zmc2V0PWY7az0hMTticmVhaztjYXNlIFwiIFwiOms9ITE7YnJlYWs7ZGVmYXVsdDppZighYyYmayl7cT0hMDticmVha31nPXBhcnNlSW50KGcrYS5jaGFyQXQoaCsrKSwxNik7aWYoIWMmJihpc05hTihnKXx8MD5nfHwyNTU8ZykpdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgc3RyOiBOb3QgYSBkZWJ1ZyBlbmNvZGVkIHN0cmluZ1wiKTtiLnZpZXcuc2V0VWludDgoZisrLGcpO2s9ITB9aWYocSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBzdHI6IEludmFsaWQgc3ltYm9sIGF0IFwiK2gpO31pZighYyl7aWYoIWx8fCFtKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIHN0cjogTWlzc2luZyBvZmZzZXQgb3IgbGltaXRcIik7XG5pZihmPGIuYnVmZmVyLmJ5dGVMZW5ndGgpdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgc3RyOiBOb3QgYSBkZWJ1ZyBlbmNvZGVkIHN0cmluZyAoaXMgaXQgaGV4PykgXCIrZitcIiA8IFwiK2UpO31yZXR1cm4gYn07ZC5wcm90b3R5cGUudG9IZXg9ZnVuY3Rpb24oYSxiKXthPVwidW5kZWZpbmVkXCI9PT10eXBlb2YgYT90aGlzLm9mZnNldDphO2I9XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBiP3RoaXMubGltaXQ6YjtpZighdGhpcy5ub0Fzc2VydCl7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBhfHwwIT09YSUxKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGJlZ2luOiBOb3QgYW4gaW50ZWdlclwiKTthPj4+PTA7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBifHwwIT09YiUxKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGVuZDogTm90IGFuIGludGVnZXJcIik7Yj4+Pj0wO2lmKDA+YXx8YT5ifHxiPnRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIHJhbmdlOiAwIDw9IFwiK1xuYStcIiA8PSBcIitiK1wiIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO31mb3IodmFyIGM9QXJyYXkoYi1hKSxlO2E8YjspZT10aGlzLnZpZXcuZ2V0VWludDgoYSsrKSwxNj5lP2MucHVzaChcIjBcIixlLnRvU3RyaW5nKDE2KSk6Yy5wdXNoKGUudG9TdHJpbmcoMTYpKTtyZXR1cm4gYy5qb2luKFwiXCIpfTtkLmZyb21IZXg9ZnVuY3Rpb24oYSxiLGMpe2lmKCFjKXtpZihcInN0cmluZ1wiIT09dHlwZW9mIGEpdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgc3RyOiBOb3QgYSBzdHJpbmdcIik7aWYoMCE9PWEubGVuZ3RoJTIpdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgc3RyOiBMZW5ndGggbm90IGEgbXVsdGlwbGUgb2YgMlwiKTt9dmFyIGU9YS5sZW5ndGg7Yj1uZXcgZChlLzJ8MCxiKTtmb3IodmFyIGgsZj0wLGc9MDtmPGU7Zis9Mil7aD1wYXJzZUludChhLnN1YnN0cmluZyhmLGYrMiksMTYpO2lmKCFjJiYoIWlzRmluaXRlKGgpfHwwPmh8fDI1NTxoKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBzdHI6IENvbnRhaW5zIG5vbi1oZXggY2hhcmFjdGVyc1wiKTtcbmIudmlldy5zZXRVaW50OChnKyssaCl9Yi5saW1pdD1nO3JldHVybiBifTt2YXIgaz1mdW5jdGlvbigpe3ZhciBhPXtqOmZ1bmN0aW9uKGEsYyl7dmFyIGU9bnVsbDtcIm51bWJlclwiPT09dHlwZW9mIGEmJihlPWEsYT1mdW5jdGlvbigpe3JldHVybiBudWxsfSk7Zm9yKDtudWxsIT09ZXx8bnVsbCE9PShlPWEoKSk7KTEyOD5lP2MoZSYxMjcpOigyMDQ4PmU/YyhlPj42JjMxfDE5Mik6KDY1NTM2PmU/YyhlPj4xMiYxNXwyMjQpOihjKGU+PjE4Jjd8MjQwKSxjKGU+PjEyJjYzfDEyOCkpLGMoZT4+NiY2M3wxMjgpKSxjKGUmNjN8MTI4KSksZT1udWxsfSxpOmZ1bmN0aW9uKGEsYyl7ZnVuY3Rpb24gZShhKXthPWEuc2xpY2UoMCxhLmluZGV4T2YobnVsbCkpO3ZhciBiPUVycm9yKGEudG9TdHJpbmcoKSk7Yi5uYW1lPVwiVHJ1bmNhdGVkRXJyb3JcIjtiLmJ5dGVzPWE7dGhyb3cgYjt9Zm9yKHZhciBkLGYsZyxrO251bGwhPT0oZD1hKCkpOylpZigwPT09KGQmMTI4KSljKGQpO2Vsc2UgaWYoMTkyPT09XG4oZCYyMjQpKW51bGw9PT0oZj1hKCkpJiZlKFtkLGZdKSxjKChkJjMxKTw8NnxmJjYzKTtlbHNlIGlmKDIyND09PShkJjI0MCkpbnVsbCE9PShmPWEoKSkmJm51bGwhPT0oZz1hKCkpfHxlKFtkLGYsZ10pLGMoKGQmMTUpPDwxMnwoZiY2Myk8PDZ8ZyY2Myk7ZWxzZSBpZigyNDA9PT0oZCYyNDgpKW51bGwhPT0oZj1hKCkpJiZudWxsIT09KGc9YSgpKSYmbnVsbCE9PShrPWEoKSl8fGUoW2QsZixnLGtdKSxjKChkJjcpPDwxOHwoZiY2Myk8PDEyfChnJjYzKTw8NnxrJjYzKTtlbHNlIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIHN0YXJ0aW5nIGJ5dGU6IFwiK2QpO30sZjpmdW5jdGlvbihhLGMpe2Zvcih2YXIgZSxkPW51bGw7bnVsbCE9PShlPW51bGwhPT1kP2Q6YSgpKTspNTUyOTY8PWUmJjU3MzQzPj1lJiZudWxsIT09KGQ9YSgpKSYmNTYzMjA8PWQmJjU3MzQzPj1kPyhjKDEwMjQqKGUtNTUyOTYpK2QtNTYzMjArNjU1MzYpLGQ9bnVsbCk6YyhlKTtudWxsIT09ZCYmYyhkKX0sZzpmdW5jdGlvbihhLFxuYyl7dmFyIGU9bnVsbDtcIm51bWJlclwiPT09dHlwZW9mIGEmJihlPWEsYT1mdW5jdGlvbigpe3JldHVybiBudWxsfSk7Zm9yKDtudWxsIT09ZXx8bnVsbCE9PShlPWEoKSk7KTY1NTM1Pj1lP2MoZSk6KGUtPTY1NTM2LGMoKGU+PjEwKSs1NTI5NiksYyhlJTEwMjQrNTYzMjApKSxlPW51bGx9LGU6ZnVuY3Rpb24oYixjKXthLmYoYixmdW5jdGlvbihiKXthLmooYixjKX0pfSxkOmZ1bmN0aW9uKGIsYyl7YS5pKGIsZnVuY3Rpb24oYil7YS5nKGIsYyl9KX0sazpmdW5jdGlvbihhKXtpZihcIm51bWJlclwiIT09dHlwZW9mIGF8fGEhPT1hKXRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgYnl0ZTogXCIrdHlwZW9mIGEpO2lmKC0xMjg+YXx8MjU1PGEpdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgYnl0ZTogXCIrYSk7cmV0dXJuIGF9LGw6ZnVuY3Rpb24oYSl7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBhfHxhIT09YSl0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGNoYXIgY29kZTogXCIrdHlwZW9mIGEpO2lmKDA+XG5hfHw2NTUzNTxhKXRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIGNoYXIgY29kZTogXCIrYSk7cmV0dXJuIGF9LG06ZnVuY3Rpb24oYSl7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBhfHxhIT09YSl0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGNvZGUgcG9pbnQ6IFwiK3R5cGVvZiBhKTtpZigwPmF8fDExMTQxMTE8YSl0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBjb2RlIHBvaW50OiBcIithKTtyZXR1cm4gYX0saDpmdW5jdGlvbihhKXtyZXR1cm4gMTI4PmE/MToyMDQ4PmE/Mjo2NTUzNj5hPzM6NH0sbjpmdW5jdGlvbihiKXtmb3IodmFyIGMsZD0wO251bGwhPT0oYz1iKCkpOylkKz1hLmgoYyk7cmV0dXJuIGR9LGI6ZnVuY3Rpb24oYil7dmFyIGM9MCxkPTA7YS5mKGIsZnVuY3Rpb24oYil7KytjO2QrPWEuaChiKX0pO3JldHVybltjLGRdfX07cmV0dXJuIGF9KCkscz1TdHJpbmcuZnJvbUNoYXJDb2RlO2suYT1mdW5jdGlvbihhKXt2YXIgYj0wO3JldHVybiBmdW5jdGlvbigpe3JldHVybiBiPFxuYS5sZW5ndGg/YS5jaGFyQ29kZUF0KGIrKyk6bnVsbH19O2suYz1mdW5jdGlvbigpe3ZhciBhPVtdLGI9W107cmV0dXJuIGZ1bmN0aW9uKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIGIuam9pbihcIlwiKStzLmFwcGx5KFN0cmluZyxhKTsxMDI0PGEubGVuZ3RoK2FyZ3VtZW50cy5sZW5ndGgmJihiLnB1c2gocy5hcHBseShTdHJpbmcsYSkpLGEubGVuZ3RoPTApO0FycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGEsYXJndW1lbnRzKX19O2QucHJvdG90eXBlLnRvVVRGOD1mdW5jdGlvbihhLGIpe1widW5kZWZpbmVkXCI9PT10eXBlb2YgYSYmKGE9dGhpcy5vZmZzZXQpO1widW5kZWZpbmVkXCI9PT10eXBlb2YgYiYmKGI9dGhpcy5saW1pdCk7aWYoIXRoaXMubm9Bc3NlcnQpe2lmKFwibnVtYmVyXCIhPT10eXBlb2YgYXx8MCE9PWElMSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBiZWdpbjogTm90IGFuIGludGVnZXJcIik7YT4+Pj0wO2lmKFwibnVtYmVyXCIhPT10eXBlb2YgYnx8XG4wIT09YiUxKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGVuZDogTm90IGFuIGludGVnZXJcIik7Yj4+Pj0wO2lmKDA+YXx8YT5ifHxiPnRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIHJhbmdlOiAwIDw9IFwiK2ErXCIgPD0gXCIrYitcIiA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTt9dmFyIGM9dGhpcyxkO3RyeXtrLmQoZnVuY3Rpb24oKXtyZXR1cm4gYTxiP2Mudmlldy5nZXRVaW50OChhKyspOm51bGx9LGQ9ay5jKCkpfWNhdGNoKGgpe2lmKGEhPT1iKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSWxsZWdhbCByYW5nZTogVHJ1bmNhdGVkIGRhdGEsIFwiK2ErXCIgIT0gXCIrYik7fXJldHVybiBkKCl9O2QuZnJvbVVURjg9ZnVuY3Rpb24oYSxiLGMpe2lmKCFjJiZcInN0cmluZ1wiIT09dHlwZW9mIGEpdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgc3RyOiBOb3QgYSBzdHJpbmdcIik7dmFyIGU9bmV3IGQoay5iKGsuYShhKSwhMClbMV0sXG5iLGMpLGg9MDtrLmUoay5hKGEpLGZ1bmN0aW9uKGEpe2Uudmlldy5zZXRVaW50OChoKyssYSl9KTtlLmxpbWl0PWg7cmV0dXJuIGV9O3JldHVybiBkfVwidW5kZWZpbmVkXCIhPXR5cGVvZiBtb2R1bGUmJm1vZHVsZS5leHBvcnRzP21vZHVsZS5leHBvcnRzPXMocmVxdWlyZShcImxvbmdcIikpOlwidW5kZWZpbmVkXCIhPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShcIkJ5dGVCdWZmZXJcIixbXCJNYXRoL0xvbmdcIl0sZnVuY3Rpb24obCl7cmV0dXJuIHMobCl9KTooci5kY29kZUlPfHwoci5kY29kZUlPPXt9KSxyLmRjb2RlSU8uQnl0ZUJ1ZmZlcj1zKHIuZGNvZGVJTy5Mb25nKSl9KSh0aGlzKTtcbiIsIi8qXHJcbiBDb3B5cmlnaHQgMjAxMyBEYW5pZWwgV2lydHogPGRjb2RlQGRjb2RlLmlvPlxyXG4gQ29weXJpZ2h0IDIwMDkgVGhlIENsb3N1cmUgTGlicmFyeSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG5cclxuIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuXHJcbiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcbiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTLUlTXCIgQkFTSVMsXHJcbiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEBsaWNlbnNlIExvbmcuanMgKGMpIDIwMTMgRGFuaWVsIFdpcnR6IDxkY29kZUBkY29kZS5pbz5cclxuICogUmVsZWFzZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMFxyXG4gKiBEZXJpdmVkIGZyb20gZ29vZy5tYXRoLkxvbmcgZnJvbSB0aGUgQ2xvc3VyZSBMaWJyYXJ5XHJcbiAqIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Rjb2RlSU8vTG9uZy5qcyBmb3IgZGV0YWlsc1xyXG4gKi9cclxuKGZ1bmN0aW9uKGdsb2JhbCkge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb25zdHJ1Y3RzIGEgNjQtYml0IHR3bydzLWNvbXBsZW1lbnQgaW50ZWdlciwgZ2l2ZW4gaXRzIGxvdyBhbmQgaGlnaCAzMi1iaXRcclxuICAgICAqIHZhbHVlcyBhcyAqc2lnbmVkKiBpbnRlZ2Vycy4gIFNlZSB0aGUgZnJvbSogZnVuY3Rpb25zIGJlbG93IGZvciBtb3JlXHJcbiAgICAgKiBjb252ZW5pZW50IHdheXMgb2YgY29uc3RydWN0aW5nIExvbmdzLlxyXG4gICAgICpcclxuICAgICAqIFRoZSBpbnRlcm5hbCByZXByZXNlbnRhdGlvbiBvZiBhIGxvbmcgaXMgdGhlIHR3byBnaXZlbiBzaWduZWQsIDMyLWJpdCB2YWx1ZXMuXHJcbiAgICAgKiBXZSB1c2UgMzItYml0IHBpZWNlcyBiZWNhdXNlIHRoZXNlIGFyZSB0aGUgc2l6ZSBvZiBpbnRlZ2VycyBvbiB3aGljaFxyXG4gICAgICogSmF2YXNjcmlwdCBwZXJmb3JtcyBiaXQtb3BlcmF0aW9ucy4gIEZvciBvcGVyYXRpb25zIGxpa2UgYWRkaXRpb24gYW5kXHJcbiAgICAgKiBtdWx0aXBsaWNhdGlvbiwgd2Ugc3BsaXQgZWFjaCBudW1iZXIgaW50byAxNi1iaXQgcGllY2VzLCB3aGljaCBjYW4gZWFzaWx5IGJlXHJcbiAgICAgKiBtdWx0aXBsaWVkIHdpdGhpbiBKYXZhc2NyaXB0J3MgZmxvYXRpbmctcG9pbnQgcmVwcmVzZW50YXRpb24gd2l0aG91dCBvdmVyZmxvd1xyXG4gICAgICogb3IgY2hhbmdlIGluIHNpZ24uXHJcbiAgICAgKlxyXG4gICAgICogSW4gdGhlIGFsZ29yaXRobXMgYmVsb3csIHdlIGZyZXF1ZW50bHkgcmVkdWNlIHRoZSBuZWdhdGl2ZSBjYXNlIHRvIHRoZVxyXG4gICAgICogcG9zaXRpdmUgY2FzZSBieSBuZWdhdGluZyB0aGUgaW5wdXQocykgYW5kIHRoZW4gcG9zdC1wcm9jZXNzaW5nIHRoZSByZXN1bHQuXHJcbiAgICAgKiBOb3RlIHRoYXQgd2UgbXVzdCBBTFdBWVMgY2hlY2sgc3BlY2lhbGx5IHdoZXRoZXIgdGhvc2UgdmFsdWVzIGFyZSBNSU5fVkFMVUVcclxuICAgICAqICgtMl42MykgYmVjYXVzZSAtTUlOX1ZBTFVFID09IE1JTl9WQUxVRSAoc2luY2UgMl42MyBjYW5ub3QgYmUgcmVwcmVzZW50ZWQgYXNcclxuICAgICAqIGEgcG9zaXRpdmUgbnVtYmVyLCBpdCBvdmVyZmxvd3MgYmFjayBpbnRvIGEgbmVnYXRpdmUpLiAgTm90IGhhbmRsaW5nIHRoaXNcclxuICAgICAqIGNhc2Ugd291bGQgb2Z0ZW4gcmVzdWx0IGluIGluZmluaXRlIHJlY3Vyc2lvbi5cclxuICAgICAqIFxyXG4gICAgICogQGV4cG9ydHMgTG9uZ1xyXG4gICAgICogQGNsYXNzIEEgTG9uZyBjbGFzcyBmb3IgcmVwcmVzZW50aW5nIGEgNjQtYml0IHR3bydzLWNvbXBsZW1lbnQgaW50ZWdlciB2YWx1ZS5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfCF7bG93OiBudW1iZXIsIGhpZ2g6IG51bWJlciwgdW5zaWduZWQ6IGJvb2xlYW59fSBsb3cgVGhlIGxvdyAoc2lnbmVkKSAzMiBiaXRzIG9mIHRoZSBsb25nLlxyXG4gICAgICogIE9wdGlvbmFsbHkgYWNjZXB0cyBhIExvbmctbGlrZSBvYmplY3QgYXMgdGhlIGZpcnN0IHBhcmFtZXRlci5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gaGlnaCBUaGUgaGlnaCAoc2lnbmVkKSAzMiBiaXRzIG9mIHRoZSBsb25nLlxyXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QuIERlZmF1bHRzIHRvIGBmYWxzZWAgKHNpZ25lZCkuXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqL1xyXG4gICAgdmFyIExvbmcgPSBmdW5jdGlvbihsb3csIGhpZ2gsIHVuc2lnbmVkKSB7XHJcbiAgICAgICAgaWYgKGxvdyAmJiB0eXBlb2YgbG93ID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICBoaWdoID0gbG93LmhpZ2g7XHJcbiAgICAgICAgICAgIHVuc2lnbmVkID0gbG93LnVuc2lnbmVkO1xyXG4gICAgICAgICAgICBsb3cgPSBsb3cubG93O1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgbG93IDMyIGJpdHMgYXMgYSBzaWduZWQgdmFsdWUuXHJcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5sb3cgPSBsb3cgfCAwO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgaGlnaCAzMiBiaXRzIGFzIGEgc2lnbmVkIHZhbHVlLlxyXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuaGlnaCA9IGhpZ2ggfCAwO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdC5cclxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy51bnNpZ25lZCA9ICEhdW5zaWduZWQ7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIE5PVEU6IENvbW1vbiBjb25zdGFudCB2YWx1ZXMgWkVSTywgT05FLCBORUdfT05FLCBldGMuIGFyZSBkZWZpbmVkIGJlbG93IHRoZSBmcm9tKiBtZXRob2RzIG9uIHdoaWNoIHRoZXkgZGVwZW5kLlxyXG5cclxuICAgIC8vIE5PVEU6IFRoZSBmb2xsb3dpbmcgY2FjaGUgdmFyaWFibGVzIGFyZSB1c2VkIGludGVybmFsbHkgb25seSBhbmQgYXJlIHRoZXJlZm9yZSBub3QgZXhwb3NlZCBhcyBwcm9wZXJ0aWVzIG9mIHRoZVxyXG4gICAgLy8gTG9uZyBjbGFzcy5cclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGNhY2hlIG9mIHRoZSBMb25nIHJlcHJlc2VudGF0aW9ucyBvZiBzbWFsbCBpbnRlZ2VyIHZhbHVlcy5cclxuICAgICAqIEB0eXBlIHshT2JqZWN0fVxyXG4gICAgICovXHJcbiAgICB2YXIgSU5UX0NBQ0hFID0ge307XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGNhY2hlIG9mIHRoZSBMb25nIHJlcHJlc2VudGF0aW9ucyBvZiBzbWFsbCB1bnNpZ25lZCBpbnRlZ2VyIHZhbHVlcy5cclxuICAgICAqIEB0eXBlIHshT2JqZWN0fVxyXG4gICAgICovXHJcbiAgICB2YXIgVUlOVF9DQUNIRSA9IHt9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIExvbmcgcmVwcmVzZW50aW5nIHRoZSBnaXZlbiAoMzItYml0KSBpbnRlZ2VyIHZhbHVlLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSAzMi1iaXQgaW50ZWdlciBpbiBxdWVzdGlvbi5cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LiBEZWZhdWx0cyB0byBmYWxzZSAoc2lnbmVkKS5cclxuICAgICAqIEByZXR1cm4geyFMb25nfSBUaGUgY29ycmVzcG9uZGluZyBMb25nIHZhbHVlLlxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBMb25nLmZyb21JbnQgPSBmdW5jdGlvbih2YWx1ZSwgdW5zaWduZWQpIHtcclxuICAgICAgICB2YXIgb2JqLCBjYWNoZWRPYmo7XHJcbiAgICAgICAgaWYgKCF1bnNpZ25lZCkge1xyXG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlIHwgMDtcclxuICAgICAgICAgICAgaWYgKC0xMjggPD0gdmFsdWUgJiYgdmFsdWUgPCAxMjgpIHtcclxuICAgICAgICAgICAgICAgIGNhY2hlZE9iaiA9IElOVF9DQUNIRVt2YWx1ZV07XHJcbiAgICAgICAgICAgICAgICBpZiAoY2FjaGVkT2JqKSByZXR1cm4gY2FjaGVkT2JqO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9iaiA9IG5ldyBMb25nKHZhbHVlLCB2YWx1ZSA8IDAgPyAtMSA6IDAsIGZhbHNlKTtcclxuICAgICAgICAgICAgaWYgKC0xMjggPD0gdmFsdWUgJiYgdmFsdWUgPCAxMjgpIHtcclxuICAgICAgICAgICAgICAgIElOVF9DQUNIRVt2YWx1ZV0gPSBvYmo7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG9iajtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlID4+PiAwO1xyXG4gICAgICAgICAgICBpZiAoMCA8PSB2YWx1ZSAmJiB2YWx1ZSA8IDI1Nikge1xyXG4gICAgICAgICAgICAgICAgY2FjaGVkT2JqID0gVUlOVF9DQUNIRVt2YWx1ZV07XHJcbiAgICAgICAgICAgICAgICBpZiAoY2FjaGVkT2JqKSByZXR1cm4gY2FjaGVkT2JqO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9iaiA9IG5ldyBMb25nKHZhbHVlLCAodmFsdWUgfCAwKSA8IDAgPyAtMSA6IDAsIHRydWUpO1xyXG4gICAgICAgICAgICBpZiAoMCA8PSB2YWx1ZSAmJiB2YWx1ZSA8IDI1Nikge1xyXG4gICAgICAgICAgICAgICAgVUlOVF9DQUNIRVt2YWx1ZV0gPSBvYmo7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG9iajtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIExvbmcgcmVwcmVzZW50aW5nIHRoZSBnaXZlbiB2YWx1ZSwgcHJvdmlkZWQgdGhhdCBpdCBpcyBhIGZpbml0ZVxyXG4gICAgICogbnVtYmVyLiAgT3RoZXJ3aXNlLCB6ZXJvIGlzIHJldHVybmVkLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSBudW1iZXIgaW4gcXVlc3Rpb24uXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdC4gRGVmYXVsdHMgdG8gZmFsc2UgKHNpZ25lZCkuXHJcbiAgICAgKiBAcmV0dXJuIHshTG9uZ30gVGhlIGNvcnJlc3BvbmRpbmcgTG9uZyB2YWx1ZS5cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgTG9uZy5mcm9tTnVtYmVyID0gZnVuY3Rpb24odmFsdWUsIHVuc2lnbmVkKSB7XHJcbiAgICAgICAgdW5zaWduZWQgPSAhIXVuc2lnbmVkO1xyXG4gICAgICAgIGlmIChpc05hTih2YWx1ZSkgfHwgIWlzRmluaXRlKHZhbHVlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gTG9uZy5aRVJPO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoIXVuc2lnbmVkICYmIHZhbHVlIDw9IC1UV09fUFdSXzYzX0RCTCkge1xyXG4gICAgICAgICAgICByZXR1cm4gTG9uZy5NSU5fU0lHTkVEX1ZBTFVFO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodW5zaWduZWQgJiYgdmFsdWUgPD0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gTG9uZy5NSU5fVU5TSUdORURfVkFMVUU7XHJcbiAgICAgICAgfSBlbHNlIGlmICghdW5zaWduZWQgJiYgdmFsdWUgKyAxID49IFRXT19QV1JfNjNfREJMKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBMb25nLk1BWF9TSUdORURfVkFMVUU7XHJcbiAgICAgICAgfSBlbHNlIGlmICh1bnNpZ25lZCAmJiB2YWx1ZSA+PSBUV09fUFdSXzY0X0RCTCkge1xyXG4gICAgICAgICAgICByZXR1cm4gTG9uZy5NQVhfVU5TSUdORURfVkFMVUU7XHJcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA8IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIExvbmcuZnJvbU51bWJlcigtdmFsdWUsIGZhbHNlKS5uZWdhdGUoKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IExvbmcoKHZhbHVlICUgVFdPX1BXUl8zMl9EQkwpIHwgMCwgKHZhbHVlIC8gVFdPX1BXUl8zMl9EQkwpIHwgMCwgdW5zaWduZWQpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgTG9uZyByZXByZXNlbnRpbmcgdGhlIDY0Yml0IGludGVnZXIgdGhhdCBjb21lcyBieSBjb25jYXRlbmF0aW5nIHRoZSBnaXZlbiBsb3cgYW5kIGhpZ2ggYml0cy4gRWFjaCBpc1xyXG4gICAgICogIGFzc3VtZWQgdG8gdXNlIDMyIGJpdHMuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbG93Qml0cyBUaGUgbG93IDMyIGJpdHMuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaGlnaEJpdHMgVGhlIGhpZ2ggMzIgYml0cy5cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LiBEZWZhdWx0cyB0byBmYWxzZSAoc2lnbmVkKS5cclxuICAgICAqIEByZXR1cm4geyFMb25nfSBUaGUgY29ycmVzcG9uZGluZyBMb25nIHZhbHVlLlxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBMb25nLmZyb21CaXRzID0gZnVuY3Rpb24obG93Qml0cywgaGlnaEJpdHMsIHVuc2lnbmVkKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBMb25nKGxvd0JpdHMsIGhpZ2hCaXRzLCB1bnNpZ25lZCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIExvbmcgcmVwcmVzZW50aW5nIHRoZSA2NGJpdCBpbnRlZ2VyIHRoYXQgY29tZXMgYnkgY29uY2F0ZW5hdGluZyB0aGUgZ2l2ZW4gbG93LCBtaWRkbGUgYW5kIGhpZ2ggYml0cy5cclxuICAgICAqICBFYWNoIGlzIGFzc3VtZWQgdG8gdXNlIDI4IGJpdHMuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGFydDAgVGhlIGxvdyAyOCBiaXRzXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGFydDEgVGhlIG1pZGRsZSAyOCBiaXRzXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGFydDIgVGhlIGhpZ2ggMjggKDgpIGJpdHNcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LiBEZWZhdWx0cyB0byBmYWxzZSAoc2lnbmVkKS5cclxuICAgICAqIEByZXR1cm4geyFMb25nfVxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBMb25nLmZyb20yOEJpdHMgPSBmdW5jdGlvbihwYXJ0MCwgcGFydDEsIHBhcnQyLCB1bnNpZ25lZCkge1xyXG4gICAgICAgIC8vIDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxMTExIDExMTExMTExMTExMTExMTExMTExMTExMTIyMjIyMjIyIDIyMjIyMjIyMjIyMjJcclxuICAgICAgICAvLyBMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTCBISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISFxyXG4gICAgICAgIHJldHVybiBMb25nLmZyb21CaXRzKHBhcnQwIHwgKHBhcnQxIDw8IDI4KSwgKHBhcnQxID4+PiA0KSB8IChwYXJ0MikgPDwgMjQsIHVuc2lnbmVkKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgTG9uZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gc3RyaW5nLCB3cml0dGVuIHVzaW5nIHRoZSBnaXZlblxyXG4gICAgICogcmFkaXguXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIFRoZSB0ZXh0dWFsIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBMb25nLlxyXG4gICAgICogQHBhcmFtIHsoYm9vbGVhbnxudW1iZXIpPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QuIERlZmF1bHRzIHRvIGZhbHNlIChzaWduZWQpLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSByYWRpeCBUaGUgcmFkaXggaW4gd2hpY2ggdGhlIHRleHQgaXMgd3JpdHRlbi5cclxuICAgICAqIEByZXR1cm4geyFMb25nfSBUaGUgY29ycmVzcG9uZGluZyBMb25nIHZhbHVlLlxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBMb25nLmZyb21TdHJpbmcgPSBmdW5jdGlvbihzdHIsIHVuc2lnbmVkLCByYWRpeCkge1xyXG4gICAgICAgIGlmIChzdHIubGVuZ3RoID09IDApIHtcclxuICAgICAgICAgICAgdGhyb3cobmV3IEVycm9yKCdudW1iZXIgZm9ybWF0IGVycm9yOiBlbXB0eSBzdHJpbmcnKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzdHIgPT09IFwiTmFOXCIgfHwgc3RyID09PSBcIkluZmluaXR5XCIgfHwgc3RyID09PSBcIitJbmZpbml0eVwiIHx8IHN0ciA9PT0gXCItSW5maW5pdHlcIikge1xyXG4gICAgICAgICAgICByZXR1cm4gTG9uZy5aRVJPO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIHVuc2lnbmVkID09PSAnbnVtYmVyJykgeyAvLyBGb3IgZ29vZy5tYXRoLkxvbmcgY29tcGF0aWJpbGl0eVxyXG4gICAgICAgICAgICByYWRpeCA9IHVuc2lnbmVkO1xyXG4gICAgICAgICAgICB1bnNpZ25lZCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByYWRpeCA9IHJhZGl4IHx8IDEwO1xyXG4gICAgICAgIGlmIChyYWRpeCA8IDIgfHwgMzYgPCByYWRpeCkge1xyXG4gICAgICAgICAgICB0aHJvdyhuZXcgRXJyb3IoJ3JhZGl4IG91dCBvZiByYW5nZTogJyArIHJhZGl4KSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoc3RyLmNoYXJBdCgwKSA9PSAnLScpIHtcclxuICAgICAgICAgICAgcmV0dXJuIExvbmcuZnJvbVN0cmluZyhzdHIuc3Vic3RyaW5nKDEpLCB1bnNpZ25lZCwgcmFkaXgpLm5lZ2F0ZSgpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoc3RyLmluZGV4T2YoJy0nKSA+PSAwKSB7XHJcbiAgICAgICAgICAgIHRocm93KG5ldyBFcnJvcignbnVtYmVyIGZvcm1hdCBlcnJvcjogaW50ZXJpb3IgXCItXCIgY2hhcmFjdGVyOiAnICsgc3RyKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBEbyBzZXZlcmFsICg4KSBkaWdpdHMgZWFjaCB0aW1lIHRocm91Z2ggdGhlIGxvb3AsIHNvIGFzIHRvXHJcbiAgICAgICAgLy8gbWluaW1pemUgdGhlIGNhbGxzIHRvIHRoZSB2ZXJ5IGV4cGVuc2l2ZSBlbXVsYXRlZCBkaXYuXHJcbiAgICAgICAgdmFyIHJhZGl4VG9Qb3dlciA9IExvbmcuZnJvbU51bWJlcihNYXRoLnBvdyhyYWRpeCwgOCkpO1xyXG5cclxuICAgICAgICB2YXIgcmVzdWx0ID0gTG9uZy5aRVJPO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSArPSA4KSB7XHJcbiAgICAgICAgICAgIHZhciBzaXplID0gTWF0aC5taW4oOCwgc3RyLmxlbmd0aCAtIGkpO1xyXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBwYXJzZUludChzdHIuc3Vic3RyaW5nKGksIGkgKyBzaXplKSwgcmFkaXgpO1xyXG4gICAgICAgICAgICBpZiAoc2l6ZSA8IDgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBwb3dlciA9IExvbmcuZnJvbU51bWJlcihNYXRoLnBvdyhyYWRpeCwgc2l6ZSkpO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0Lm11bHRpcGx5KHBvd2VyKS5hZGQoTG9uZy5mcm9tTnVtYmVyKHZhbHVlKSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQubXVsdGlwbHkocmFkaXhUb1Bvd2VyKTtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5hZGQoTG9uZy5mcm9tTnVtYmVyKHZhbHVlKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmVzdWx0LnVuc2lnbmVkID0gdW5zaWduZWQ7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcblxyXG4gICAgLy8gTk9URTogdGhlIGNvbXBpbGVyIHNob3VsZCBpbmxpbmUgdGhlc2UgY29uc3RhbnQgdmFsdWVzIGJlbG93IGFuZCB0aGVuIHJlbW92ZSB0aGVzZSB2YXJpYWJsZXMsIHNvIHRoZXJlIHNob3VsZCBiZVxyXG4gICAgLy8gbm8gcnVudGltZSBwZW5hbHR5IGZvciB0aGVzZS5cclxuICAgIFxyXG4gICAgLy8gTk9URTogVGhlIGZvbGxvd2luZyBjb25zdGFudCB2YWx1ZXMgYXJlIHVzZWQgaW50ZXJuYWxseSBvbmx5IGFuZCBhcmUgdGhlcmVmb3JlIG5vdCBleHBvc2VkIGFzIHByb3BlcnRpZXMgb2YgdGhlXHJcbiAgICAvLyBMb25nIGNsYXNzLlxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgdmFyIFRXT19QV1JfMTZfREJMID0gMSA8PCAxNjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHZhciBUV09fUFdSXzI0X0RCTCA9IDEgPDwgMjQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB2YXIgVFdPX1BXUl8zMl9EQkwgPSBUV09fUFdSXzE2X0RCTCAqIFRXT19QV1JfMTZfREJMO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgdmFyIFRXT19QV1JfMzFfREJMID0gVFdPX1BXUl8zMl9EQkwgLyAyO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgdmFyIFRXT19QV1JfNDhfREJMID0gVFdPX1BXUl8zMl9EQkwgKiBUV09fUFdSXzE2X0RCTDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHZhciBUV09fUFdSXzY0X0RCTCA9IFRXT19QV1JfMzJfREJMICogVFdPX1BXUl8zMl9EQkw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB2YXIgVFdPX1BXUl82M19EQkwgPSBUV09fUFdSXzY0X0RCTCAvIDI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAdHlwZSB7IUxvbmd9XHJcbiAgICAgKi9cclxuICAgIHZhciBUV09fUFdSXzI0ID0gTG9uZy5mcm9tSW50KDEgPDwgMjQpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUgeyFMb25nfVxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBMb25nLlpFUk8gPSBMb25nLmZyb21JbnQoMCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAdHlwZSB7IUxvbmd9XHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIExvbmcuVVpFUk8gPSBMb25nLmZyb21JbnQoMCwgdHJ1ZSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAdHlwZSB7IUxvbmd9XHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIExvbmcuT05FID0gTG9uZy5mcm9tSW50KDEpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUgeyFMb25nfVxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBMb25nLlVPTkUgPSBMb25nLmZyb21JbnQoMSwgdHJ1ZSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAdHlwZSB7IUxvbmd9XHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIExvbmcuTkVHX09ORSA9IExvbmcuZnJvbUludCgtMSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAdHlwZSB7IUxvbmd9XHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIExvbmcuTUFYX1NJR05FRF9WQUxVRSA9IExvbmcuZnJvbUJpdHMoMHhGRkZGRkZGRiB8IDAsIDB4N0ZGRkZGRkYgfCAwLCBmYWxzZSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAdHlwZSB7IUxvbmd9XHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIExvbmcuTUFYX1VOU0lHTkVEX1ZBTFVFID0gTG9uZy5mcm9tQml0cygweEZGRkZGRkZGIHwgMCwgMHhGRkZGRkZGRiB8IDAsIHRydWUpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWxpYXMgb2Yge0BsaW5rIExvbmcuTUFYX1NJR05FRF9WQUxVRX0gZm9yIGdvb2cubWF0aC5Mb25nIGNvbXBhdGliaWxpdHkuXHJcbiAgICAgKiBAdHlwZSB7IUxvbmd9XHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIExvbmcuTUFYX1ZBTFVFID0gTG9uZy5NQVhfU0lHTkVEX1ZBTFVFO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUgeyFMb25nfVxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBMb25nLk1JTl9TSUdORURfVkFMVUUgPSBMb25nLmZyb21CaXRzKDAsIDB4ODAwMDAwMDAgfCAwLCBmYWxzZSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAdHlwZSB7IUxvbmd9XHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIExvbmcuTUlOX1VOU0lHTkVEX1ZBTFVFID0gTG9uZy5mcm9tQml0cygwLCAwLCB0cnVlKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFsaWFzIG9mIHtAbGluayBMb25nLk1JTl9TSUdORURfVkFMVUV9ICBmb3IgZ29vZy5tYXRoLkxvbmcgY29tcGF0aWJpbGl0eS5cclxuICAgICAqIEB0eXBlIHshTG9uZ31cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgTG9uZy5NSU5fVkFMVUUgPSBMb25nLk1JTl9TSUdORURfVkFMVUU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSB2YWx1ZSwgYXNzdW1pbmcgaXQgaXMgYSAzMi1iaXQgaW50ZWdlci5cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgTG9uZy5wcm90b3R5cGUudG9JbnQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy51bnNpZ25lZCA/IHRoaXMubG93ID4+PiAwIDogdGhpcy5sb3c7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgY2xvc2VzdCBmbG9hdGluZy1wb2ludCByZXByZXNlbnRhdGlvbiB0byB0aGlzIHZhbHVlLlxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBMb25nLnByb3RvdHlwZS50b051bWJlciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnVuc2lnbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAoKHRoaXMuaGlnaCA+Pj4gMCkgKiBUV09fUFdSXzMyX0RCTCkgKyAodGhpcy5sb3cgPj4+IDApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5oaWdoICogVFdPX1BXUl8zMl9EQkwgKyAodGhpcy5sb3cgPj4+IDApO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gcmFkaXggVGhlIHJhZGl4IGluIHdoaWNoIHRoZSB0ZXh0IHNob3VsZCBiZSB3cml0dGVuLlxyXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgdGV4dHVhbCByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHZhbHVlLlxyXG4gICAgICogQG92ZXJyaWRlXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIExvbmcucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24ocmFkaXgpIHtcclxuICAgICAgICByYWRpeCA9IHJhZGl4IHx8IDEwO1xyXG4gICAgICAgIGlmIChyYWRpeCA8IDIgfHwgMzYgPCByYWRpeCkge1xyXG4gICAgICAgICAgICB0aHJvdyhuZXcgRXJyb3IoJ3JhZGl4IG91dCBvZiByYW5nZTogJyArIHJhZGl4KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmlzWmVybygpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnMCc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciByZW07XHJcbiAgICAgICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpKSB7IC8vIFVuc2lnbmVkIExvbmdzIGFyZSBuZXZlciBuZWdhdGl2ZVxyXG4gICAgICAgICAgICBpZiAodGhpcy5lcXVhbHMoTG9uZy5NSU5fU0lHTkVEX1ZBTFVFKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBjaGFuZ2UgdGhlIExvbmcgdmFsdWUgYmVmb3JlIGl0IGNhbiBiZSBuZWdhdGVkLCBzbyB3ZSByZW1vdmVcclxuICAgICAgICAgICAgICAgIC8vIHRoZSBib3R0b20tbW9zdCBkaWdpdCBpbiB0aGlzIGJhc2UgYW5kIHRoZW4gcmVjdXJzZSB0byBkbyB0aGUgcmVzdC5cclxuICAgICAgICAgICAgICAgIHZhciByYWRpeExvbmcgPSBMb25nLmZyb21OdW1iZXIocmFkaXgpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGRpdiA9IHRoaXMuZGl2KHJhZGl4TG9uZyk7XHJcbiAgICAgICAgICAgICAgICByZW0gPSBkaXYubXVsdGlwbHkocmFkaXhMb25nKS5zdWJ0cmFjdCh0aGlzKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBkaXYudG9TdHJpbmcocmFkaXgpICsgcmVtLnRvSW50KCkudG9TdHJpbmcocmFkaXgpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICctJyArIHRoaXMubmVnYXRlKCkudG9TdHJpbmcocmFkaXgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBEbyBzZXZlcmFsICg2KSBkaWdpdHMgZWFjaCB0aW1lIHRocm91Z2ggdGhlIGxvb3AsIHNvIGFzIHRvXHJcbiAgICAgICAgLy8gbWluaW1pemUgdGhlIGNhbGxzIHRvIHRoZSB2ZXJ5IGV4cGVuc2l2ZSBlbXVsYXRlZCBkaXYuXHJcbiAgICAgICAgdmFyIHJhZGl4VG9Qb3dlciA9IExvbmcuZnJvbU51bWJlcihNYXRoLnBvdyhyYWRpeCwgNikpO1xyXG4gICAgICAgIHJlbSA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9ICcnO1xyXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgICAgIHZhciByZW1EaXYgPSByZW0uZGl2KHJhZGl4VG9Qb3dlcik7XHJcbiAgICAgICAgICAgIHZhciBpbnR2YWwgPSByZW0uc3VidHJhY3QocmVtRGl2Lm11bHRpcGx5KHJhZGl4VG9Qb3dlcikpLnRvSW50KCk7XHJcbiAgICAgICAgICAgIHZhciBkaWdpdHMgPSBpbnR2YWwudG9TdHJpbmcocmFkaXgpO1xyXG4gICAgICAgICAgICByZW0gPSByZW1EaXY7XHJcbiAgICAgICAgICAgIGlmIChyZW0uaXNaZXJvKCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBkaWdpdHMgKyByZXN1bHQ7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoZGlnaXRzLmxlbmd0aCA8IDYpIHtcclxuICAgICAgICAgICAgICAgICAgICBkaWdpdHMgPSAnMCcgKyBkaWdpdHM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSAnJyArIGRpZ2l0cyArIHJlc3VsdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBoaWdoIDMyIGJpdHMgYXMgYSBzaWduZWQgdmFsdWUuXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIExvbmcucHJvdG90eXBlLmdldEhpZ2hCaXRzID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaGlnaDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBoaWdoIDMyIGJpdHMgYXMgYW4gdW5zaWduZWQgdmFsdWUuXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIExvbmcucHJvdG90eXBlLmdldEhpZ2hCaXRzVW5zaWduZWQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5oaWdoID4+PiAwO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4ge251bWJlcn0gVGhlIGxvdyAzMiBiaXRzIGFzIGEgc2lnbmVkIHZhbHVlLlxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBMb25nLnByb3RvdHlwZS5nZXRMb3dCaXRzID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubG93O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4ge251bWJlcn0gVGhlIGxvdyAzMiBiaXRzIGFzIGFuIHVuc2lnbmVkIHZhbHVlLlxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBMb25nLnByb3RvdHlwZS5nZXRMb3dCaXRzVW5zaWduZWQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5sb3cgPj4+IDA7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBSZXR1cm5zIHRoZSBudW1iZXIgb2YgYml0cyBuZWVkZWQgdG8gcmVwcmVzZW50IHRoZSBhYnNvbHV0ZVxyXG4gICAgICogICAgIHZhbHVlIG9mIHRoaXMgTG9uZy5cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgTG9uZy5wcm90b3R5cGUuZ2V0TnVtQml0c0FicyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSkgeyAvLyBVbnNpZ25lZCBMb25ncyBhcmUgbmV2ZXIgbmVnYXRpdmVcclxuICAgICAgICAgICAgaWYgKHRoaXMuZXF1YWxzKExvbmcuTUlOX1NJR05FRF9WQUxVRSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiA2NDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm5lZ2F0ZSgpLmdldE51bUJpdHNBYnMoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciB2YWwgPSB0aGlzLmhpZ2ggIT0gMCA/IHRoaXMuaGlnaCA6IHRoaXMubG93O1xyXG4gICAgICAgICAgICBmb3IgKHZhciBiaXQgPSAzMTsgYml0ID4gMDsgYml0LS0pIHtcclxuICAgICAgICAgICAgICAgIGlmICgodmFsICYgKDEgPDwgYml0KSkgIT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhpZ2ggIT0gMCA/IGJpdCArIDMzIDogYml0ICsgMTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGlzIHZhbHVlIGlzIHplcm8uXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIExvbmcucHJvdG90eXBlLmlzWmVybyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmhpZ2ggPT0gMCAmJiB0aGlzLmxvdyA9PSAwO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhpcyB2YWx1ZSBpcyBuZWdhdGl2ZS5cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgTG9uZy5wcm90b3R5cGUuaXNOZWdhdGl2ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiAhdGhpcy51bnNpZ25lZCAmJiB0aGlzLmhpZ2ggPCAwO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhpcyB2YWx1ZSBpcyBvZGQuXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIExvbmcucHJvdG90eXBlLmlzT2RkID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLmxvdyAmIDEpID09IDE7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGlzIHZhbHVlIGlzIGV2ZW4uXHJcbiAgICAgKi9cclxuICAgIExvbmcucHJvdG90eXBlLmlzRXZlbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5sb3cgJiAxKSA9PSAwO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7TG9uZ30gb3RoZXIgTG9uZyB0byBjb21wYXJlIGFnYWluc3QuXHJcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoaXMgTG9uZyBlcXVhbHMgdGhlIG90aGVyLlxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBMb25nLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbihvdGhlcikge1xyXG4gICAgICAgIGlmICh0aGlzLnVuc2lnbmVkICE9IG90aGVyLnVuc2lnbmVkICYmICh0aGlzLmhpZ2ggPj4+IDMxKSAhPSAob3RoZXIuaGlnaCA+Pj4gMzEpKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLmhpZ2ggPT0gb3RoZXIuaGlnaCkgJiYgKHRoaXMubG93ID09IG90aGVyLmxvdyk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHtMb25nfSBvdGhlciBMb25nIHRvIGNvbXBhcmUgYWdhaW5zdC5cclxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhpcyBMb25nIGRvZXMgbm90IGVxdWFsIHRoZSBvdGhlci5cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgTG9uZy5wcm90b3R5cGUubm90RXF1YWxzID0gZnVuY3Rpb24ob3RoZXIpIHtcclxuICAgICAgICByZXR1cm4gIXRoaXMuZXF1YWxzKG90aGVyKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge0xvbmd9IG90aGVyIExvbmcgdG8gY29tcGFyZSBhZ2FpbnN0LlxyXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGlzIExvbmcgaXMgbGVzcyB0aGFuIHRoZSBvdGhlci5cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgTG9uZy5wcm90b3R5cGUubGVzc1RoYW4gPSBmdW5jdGlvbihvdGhlcikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBhcmUob3RoZXIpIDwgMDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge0xvbmd9IG90aGVyIExvbmcgdG8gY29tcGFyZSBhZ2FpbnN0LlxyXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGlzIExvbmcgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBvdGhlci5cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgTG9uZy5wcm90b3R5cGUubGVzc1RoYW5PckVxdWFsID0gZnVuY3Rpb24ob3RoZXIpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb21wYXJlKG90aGVyKSA8PSAwO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7TG9uZ30gb3RoZXIgTG9uZyB0byBjb21wYXJlIGFnYWluc3QuXHJcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoaXMgTG9uZyBpcyBncmVhdGVyIHRoYW4gdGhlIG90aGVyLlxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBMb25nLnByb3RvdHlwZS5ncmVhdGVyVGhhbiA9IGZ1bmN0aW9uKG90aGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGFyZShvdGhlcikgPiAwO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7TG9uZ30gb3RoZXIgTG9uZyB0byBjb21wYXJlIGFnYWluc3QuXHJcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoaXMgTG9uZyBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gdGhlIG90aGVyLlxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBMb25nLnByb3RvdHlwZS5ncmVhdGVyVGhhbk9yRXF1YWwgPSBmdW5jdGlvbihvdGhlcikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBhcmUob3RoZXIpID49IDA7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29tcGFyZXMgdGhpcyBMb25nIHdpdGggdGhlIGdpdmVuIG9uZS5cclxuICAgICAqIEBwYXJhbSB7TG9uZ30gb3RoZXIgTG9uZyB0byBjb21wYXJlIGFnYWluc3QuXHJcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IDAgaWYgdGhleSBhcmUgdGhlIHNhbWUsIDEgaWYgdGhlIHRoaXMgaXMgZ3JlYXRlciwgYW5kIC0xXHJcbiAgICAgKiAgICAgaWYgdGhlIGdpdmVuIG9uZSBpcyBncmVhdGVyLlxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBMb25nLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24ob3RoZXIpIHtcclxuICAgICAgICBpZiAodGhpcy5lcXVhbHMob3RoZXIpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgdGhpc05lZyA9IHRoaXMuaXNOZWdhdGl2ZSgpO1xyXG4gICAgICAgIHZhciBvdGhlck5lZyA9IG90aGVyLmlzTmVnYXRpdmUoKTtcclxuICAgICAgICBpZiAodGhpc05lZyAmJiAhb3RoZXJOZWcpIHJldHVybiAtMTtcclxuICAgICAgICBpZiAoIXRoaXNOZWcgJiYgb3RoZXJOZWcpIHJldHVybiAxO1xyXG4gICAgICAgIGlmICghdGhpcy51bnNpZ25lZCkge1xyXG4gICAgICAgICAgICAvLyBBdCB0aGlzIHBvaW50IHRoZSBzaWducyBhcmUgdGhlIHNhbWVcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3VidHJhY3Qob3RoZXIpLmlzTmVnYXRpdmUoKSA/IC0xIDogMTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBCb3RoIGFyZSBwb3NpdGl2ZSBpZiBhdCBsZWFzdCBvbmUgaXMgdW5zaWduZWRcclxuICAgICAgICAgICAgcmV0dXJuIChvdGhlci5oaWdoID4+PiAwKSA+ICh0aGlzLmhpZ2ggPj4+IDApIHx8IChvdGhlci5oaWdoID09IHRoaXMuaGlnaCAmJiAob3RoZXIubG93ID4+PiAwKSA+ICh0aGlzLmxvdyA+Pj4gMCkpID8gLTEgOiAxO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIHshTG9uZ30gVGhlIG5lZ2F0aW9uIG9mIHRoaXMgdmFsdWUuXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIExvbmcucHJvdG90eXBlLm5lZ2F0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmICghdGhpcy51bnNpZ25lZCAmJiB0aGlzLmVxdWFscyhMb25nLk1JTl9TSUdORURfVkFMVUUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBMb25nLk1JTl9TSUdORURfVkFMVUU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLm5vdCgpLmFkZChMb25nLk9ORSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgc3VtIG9mIHRoaXMgYW5kIHRoZSBnaXZlbiBMb25nLlxyXG4gICAgICogQHBhcmFtIHtMb25nfSBvdGhlciBMb25nIHRvIGFkZCB0byB0aGlzIG9uZS5cclxuICAgICAqIEByZXR1cm4geyFMb25nfSBUaGUgc3VtIG9mIHRoaXMgYW5kIHRoZSBnaXZlbiBMb25nLlxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBMb25nLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihvdGhlcikge1xyXG4gICAgICAgIC8vIERpdmlkZSBlYWNoIG51bWJlciBpbnRvIDQgY2h1bmtzIG9mIDE2IGJpdHMsIGFuZCB0aGVuIHN1bSB0aGUgY2h1bmtzLlxyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBhNDggPSB0aGlzLmhpZ2ggPj4+IDE2O1xyXG4gICAgICAgIHZhciBhMzIgPSB0aGlzLmhpZ2ggJiAweEZGRkY7XHJcbiAgICAgICAgdmFyIGExNiA9IHRoaXMubG93ID4+PiAxNjtcclxuICAgICAgICB2YXIgYTAwID0gdGhpcy5sb3cgJiAweEZGRkY7XHJcblxyXG4gICAgICAgIHZhciBiNDggPSBvdGhlci5oaWdoID4+PiAxNjtcclxuICAgICAgICB2YXIgYjMyID0gb3RoZXIuaGlnaCAmIDB4RkZGRjtcclxuICAgICAgICB2YXIgYjE2ID0gb3RoZXIubG93ID4+PiAxNjtcclxuICAgICAgICB2YXIgYjAwID0gb3RoZXIubG93ICYgMHhGRkZGO1xyXG5cclxuICAgICAgICB2YXIgYzQ4ID0gMCwgYzMyID0gMCwgYzE2ID0gMCwgYzAwID0gMDtcclxuICAgICAgICBjMDAgKz0gYTAwICsgYjAwO1xyXG4gICAgICAgIGMxNiArPSBjMDAgPj4+IDE2O1xyXG4gICAgICAgIGMwMCAmPSAweEZGRkY7XHJcbiAgICAgICAgYzE2ICs9IGExNiArIGIxNjtcclxuICAgICAgICBjMzIgKz0gYzE2ID4+PiAxNjtcclxuICAgICAgICBjMTYgJj0gMHhGRkZGO1xyXG4gICAgICAgIGMzMiArPSBhMzIgKyBiMzI7XHJcbiAgICAgICAgYzQ4ICs9IGMzMiA+Pj4gMTY7XHJcbiAgICAgICAgYzMyICY9IDB4RkZGRjtcclxuICAgICAgICBjNDggKz0gYTQ4ICsgYjQ4O1xyXG4gICAgICAgIGM0OCAmPSAweEZGRkY7XHJcbiAgICAgICAgcmV0dXJuIExvbmcuZnJvbUJpdHMoKGMxNiA8PCAxNikgfCBjMDAsIChjNDggPDwgMTYpIHwgYzMyLCB0aGlzLnVuc2lnbmVkKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBkaWZmZXJlbmNlIG9mIHRoaXMgYW5kIHRoZSBnaXZlbiBMb25nLlxyXG4gICAgICogQHBhcmFtIHtMb25nfSBvdGhlciBMb25nIHRvIHN1YnRyYWN0IGZyb20gdGhpcy5cclxuICAgICAqIEByZXR1cm4geyFMb25nfSBUaGUgZGlmZmVyZW5jZSBvZiB0aGlzIGFuZCB0aGUgZ2l2ZW4gTG9uZy5cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgTG9uZy5wcm90b3R5cGUuc3VidHJhY3QgPSBmdW5jdGlvbihvdGhlcikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmFkZChvdGhlci5uZWdhdGUoKSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgcHJvZHVjdCBvZiB0aGlzIGFuZCB0aGUgZ2l2ZW4gbG9uZy5cclxuICAgICAqIEBwYXJhbSB7TG9uZ30gb3RoZXIgTG9uZyB0byBtdWx0aXBseSB3aXRoIHRoaXMuXHJcbiAgICAgKiBAcmV0dXJuIHshTG9uZ30gVGhlIHByb2R1Y3Qgb2YgdGhpcyBhbmQgdGhlIG90aGVyLlxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBMb25nLnByb3RvdHlwZS5tdWx0aXBseSA9IGZ1bmN0aW9uKG90aGVyKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNaZXJvKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIExvbmcuWkVSTztcclxuICAgICAgICB9IGVsc2UgaWYgKG90aGVyLmlzWmVybygpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBMb25nLlpFUk87XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5lcXVhbHMoTG9uZy5NSU5fVkFMVUUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvdGhlci5pc09kZCgpID8gTG9uZy5NSU5fVkFMVUUgOiBMb25nLlpFUk87XHJcbiAgICAgICAgfSBlbHNlIGlmIChvdGhlci5lcXVhbHMoTG9uZy5NSU5fVkFMVUUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlzT2RkKCkgPyBMb25nLk1JTl9WQUxVRSA6IExvbmcuWkVSTztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSkge1xyXG4gICAgICAgICAgICBpZiAob3RoZXIuaXNOZWdhdGl2ZSgpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5uZWdhdGUoKS5tdWx0aXBseShvdGhlci5uZWdhdGUoKSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5uZWdhdGUoKS5tdWx0aXBseShvdGhlcikubmVnYXRlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2UgaWYgKG90aGVyLmlzTmVnYXRpdmUoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tdWx0aXBseShvdGhlci5uZWdhdGUoKSkubmVnYXRlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIElmIGJvdGggbG9uZ3MgYXJlIHNtYWxsLCB1c2UgZmxvYXQgbXVsdGlwbGljYXRpb25cclxuICAgICAgICBpZiAodGhpcy5sZXNzVGhhbihUV09fUFdSXzI0KSAmJlxyXG4gICAgICAgICAgICBvdGhlci5sZXNzVGhhbihUV09fUFdSXzI0KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gTG9uZy5mcm9tTnVtYmVyKHRoaXMudG9OdW1iZXIoKSAqIG90aGVyLnRvTnVtYmVyKCksIHRoaXMudW5zaWduZWQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRGl2aWRlIGVhY2ggbG9uZyBpbnRvIDQgY2h1bmtzIG9mIDE2IGJpdHMsIGFuZCB0aGVuIGFkZCB1cCA0eDQgcHJvZHVjdHMuXHJcbiAgICAgICAgLy8gV2UgY2FuIHNraXAgcHJvZHVjdHMgdGhhdCB3b3VsZCBvdmVyZmxvdy5cclxuICAgICAgICBcclxuICAgICAgICB2YXIgYTQ4ID0gdGhpcy5oaWdoID4+PiAxNjtcclxuICAgICAgICB2YXIgYTMyID0gdGhpcy5oaWdoICYgMHhGRkZGO1xyXG4gICAgICAgIHZhciBhMTYgPSB0aGlzLmxvdyA+Pj4gMTY7XHJcbiAgICAgICAgdmFyIGEwMCA9IHRoaXMubG93ICYgMHhGRkZGO1xyXG5cclxuICAgICAgICB2YXIgYjQ4ID0gb3RoZXIuaGlnaCA+Pj4gMTY7XHJcbiAgICAgICAgdmFyIGIzMiA9IG90aGVyLmhpZ2ggJiAweEZGRkY7XHJcbiAgICAgICAgdmFyIGIxNiA9IG90aGVyLmxvdyA+Pj4gMTY7XHJcbiAgICAgICAgdmFyIGIwMCA9IG90aGVyLmxvdyAmIDB4RkZGRjtcclxuXHJcbiAgICAgICAgdmFyIGM0OCA9IDAsIGMzMiA9IDAsIGMxNiA9IDAsIGMwMCA9IDA7XHJcbiAgICAgICAgYzAwICs9IGEwMCAqIGIwMDtcclxuICAgICAgICBjMTYgKz0gYzAwID4+PiAxNjtcclxuICAgICAgICBjMDAgJj0gMHhGRkZGO1xyXG4gICAgICAgIGMxNiArPSBhMTYgKiBiMDA7XHJcbiAgICAgICAgYzMyICs9IGMxNiA+Pj4gMTY7XHJcbiAgICAgICAgYzE2ICY9IDB4RkZGRjtcclxuICAgICAgICBjMTYgKz0gYTAwICogYjE2O1xyXG4gICAgICAgIGMzMiArPSBjMTYgPj4+IDE2O1xyXG4gICAgICAgIGMxNiAmPSAweEZGRkY7XHJcbiAgICAgICAgYzMyICs9IGEzMiAqIGIwMDtcclxuICAgICAgICBjNDggKz0gYzMyID4+PiAxNjtcclxuICAgICAgICBjMzIgJj0gMHhGRkZGO1xyXG4gICAgICAgIGMzMiArPSBhMTYgKiBiMTY7XHJcbiAgICAgICAgYzQ4ICs9IGMzMiA+Pj4gMTY7XHJcbiAgICAgICAgYzMyICY9IDB4RkZGRjtcclxuICAgICAgICBjMzIgKz0gYTAwICogYjMyO1xyXG4gICAgICAgIGM0OCArPSBjMzIgPj4+IDE2O1xyXG4gICAgICAgIGMzMiAmPSAweEZGRkY7XHJcbiAgICAgICAgYzQ4ICs9IGE0OCAqIGIwMCArIGEzMiAqIGIxNiArIGExNiAqIGIzMiArIGEwMCAqIGI0ODtcclxuICAgICAgICBjNDggJj0gMHhGRkZGO1xyXG4gICAgICAgIHJldHVybiBMb25nLmZyb21CaXRzKChjMTYgPDwgMTYpIHwgYzAwLCAoYzQ4IDw8IDE2KSB8IGMzMiwgdGhpcy51bnNpZ25lZCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGlzIExvbmcgZGl2aWRlZCBieSB0aGUgZ2l2ZW4gb25lLlxyXG4gICAgICogQHBhcmFtIHtMb25nfSBvdGhlciBMb25nIGJ5IHdoaWNoIHRvIGRpdmlkZS5cclxuICAgICAqIEByZXR1cm4geyFMb25nfSBUaGlzIExvbmcgZGl2aWRlZCBieSB0aGUgZ2l2ZW4gb25lLlxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBMb25nLnByb3RvdHlwZS5kaXYgPSBmdW5jdGlvbihvdGhlcikge1xyXG4gICAgICAgIGlmIChvdGhlci5pc1plcm8oKSkge1xyXG4gICAgICAgICAgICB0aHJvdyhuZXcgRXJyb3IoJ2RpdmlzaW9uIGJ5IHplcm8nKSk7XHJcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmlzWmVybygpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVuc2lnbmVkID8gTG9uZy5VWkVSTyA6IExvbmcuWkVSTztcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGFwcHJveCwgcmVtLCByZXM7XHJcbiAgICAgICAgaWYgKHRoaXMuZXF1YWxzKExvbmcuTUlOX1NJR05FRF9WQUxVRSkpIHtcclxuICAgICAgICAgICAgaWYgKG90aGVyLmVxdWFscyhMb25nLk9ORSkgfHwgb3RoZXIuZXF1YWxzKExvbmcuTkVHX09ORSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBMb25nLk1JTl9TSUdORURfVkFMVUU7ICAvLyByZWNhbGwgdGhhdCAtTUlOX1ZBTFVFID09IE1JTl9WQUxVRVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG90aGVyLmVxdWFscyhMb25nLk1JTl9TSUdORURfVkFMVUUpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gTG9uZy5PTkU7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBBdCB0aGlzIHBvaW50LCB3ZSBoYXZlIHxvdGhlcnwgPj0gMiwgc28gfHRoaXMvb3RoZXJ8IDwgfE1JTl9WQUxVRXwuXHJcbiAgICAgICAgICAgICAgICB2YXIgaGFsZlRoaXMgPSB0aGlzLnNoaWZ0UmlnaHQoMSk7XHJcbiAgICAgICAgICAgICAgICBhcHByb3ggPSBoYWxmVGhpcy5kaXYob3RoZXIpLnNoaWZ0TGVmdCgxKTtcclxuICAgICAgICAgICAgICAgIGlmIChhcHByb3guZXF1YWxzKExvbmcuWkVSTykpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3RoZXIuaXNOZWdhdGl2ZSgpID8gTG9uZy5PTkUgOiBMb25nLk5FR19PTkU7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbSA9IHRoaXMuc3VidHJhY3Qob3RoZXIubXVsdGlwbHkoYXBwcm94KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzID0gYXBwcm94LmFkZChyZW0uZGl2KG90aGVyKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAob3RoZXIuZXF1YWxzKExvbmcuTUlOX1NJR05FRF9WQUxVRSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudW5zaWduZWQgPyBMb25nLlVaRVJPIDogTG9uZy5aRVJPO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpIHtcclxuICAgICAgICAgICAgaWYgKG90aGVyLmlzTmVnYXRpdmUoKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubmVnYXRlKCkuZGl2KG90aGVyLm5lZ2F0ZSgpKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm5lZ2F0ZSgpLmRpdihvdGhlcikubmVnYXRlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2UgaWYgKG90aGVyLmlzTmVnYXRpdmUoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kaXYob3RoZXIubmVnYXRlKCkpLm5lZ2F0ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICAvLyBSZXBlYXQgdGhlIGZvbGxvd2luZyB1bnRpbCB0aGUgcmVtYWluZGVyIGlzIGxlc3MgdGhhbiBvdGhlcjogIGZpbmQgYVxyXG4gICAgICAgIC8vIGZsb2F0aW5nLXBvaW50IHRoYXQgYXBwcm94aW1hdGVzIHJlbWFpbmRlciAvIG90aGVyICpmcm9tIGJlbG93KiwgYWRkIHRoaXNcclxuICAgICAgICAvLyBpbnRvIHRoZSByZXN1bHQsIGFuZCBzdWJ0cmFjdCBpdCBmcm9tIHRoZSByZW1haW5kZXIuICBJdCBpcyBjcml0aWNhbCB0aGF0XHJcbiAgICAgICAgLy8gdGhlIGFwcHJveGltYXRlIHZhbHVlIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgcmVhbCB2YWx1ZSBzbyB0aGF0IHRoZVxyXG4gICAgICAgIC8vIHJlbWFpbmRlciBuZXZlciBiZWNvbWVzIG5lZ2F0aXZlLlxyXG4gICAgICAgIHJlcyA9IExvbmcuWkVSTztcclxuICAgICAgICByZW0gPSB0aGlzO1xyXG4gICAgICAgIHdoaWxlIChyZW0uZ3JlYXRlclRoYW5PckVxdWFsKG90aGVyKSkge1xyXG4gICAgICAgICAgICAvLyBBcHByb3hpbWF0ZSB0aGUgcmVzdWx0IG9mIGRpdmlzaW9uLiBUaGlzIG1heSBiZSBhIGxpdHRsZSBncmVhdGVyIG9yXHJcbiAgICAgICAgICAgIC8vIHNtYWxsZXIgdGhhbiB0aGUgYWN0dWFsIHZhbHVlLlxyXG4gICAgICAgICAgICBhcHByb3ggPSBNYXRoLm1heCgxLCBNYXRoLmZsb29yKHJlbS50b051bWJlcigpIC8gb3RoZXIudG9OdW1iZXIoKSkpO1xyXG5cclxuICAgICAgICAgICAgLy8gV2Ugd2lsbCB0d2VhayB0aGUgYXBwcm94aW1hdGUgcmVzdWx0IGJ5IGNoYW5naW5nIGl0IGluIHRoZSA0OC10aCBkaWdpdCBvclxyXG4gICAgICAgICAgICAvLyB0aGUgc21hbGxlc3Qgbm9uLWZyYWN0aW9uYWwgZGlnaXQsIHdoaWNoZXZlciBpcyBsYXJnZXIuXHJcbiAgICAgICAgICAgIHZhciBsb2cyID0gTWF0aC5jZWlsKE1hdGgubG9nKGFwcHJveCkgLyBNYXRoLkxOMik7XHJcbiAgICAgICAgICAgIHZhciBkZWx0YSA9IChsb2cyIDw9IDQ4KSA/IDEgOiBNYXRoLnBvdygyLCBsb2cyIC0gNDgpO1xyXG5cclxuICAgICAgICAgICAgLy8gRGVjcmVhc2UgdGhlIGFwcHJveGltYXRpb24gdW50aWwgaXQgaXMgc21hbGxlciB0aGFuIHRoZSByZW1haW5kZXIuICBOb3RlXHJcbiAgICAgICAgICAgIC8vIHRoYXQgaWYgaXQgaXMgdG9vIGxhcmdlLCB0aGUgcHJvZHVjdCBvdmVyZmxvd3MgYW5kIGlzIG5lZ2F0aXZlLlxyXG4gICAgICAgICAgICB2YXIgYXBwcm94UmVzID0gTG9uZy5mcm9tTnVtYmVyKGFwcHJveCwgdGhpcy51bnNpZ25lZCk7XHJcbiAgICAgICAgICAgIHZhciBhcHByb3hSZW0gPSBhcHByb3hSZXMubXVsdGlwbHkob3RoZXIpO1xyXG4gICAgICAgICAgICB3aGlsZSAoYXBwcm94UmVtLmlzTmVnYXRpdmUoKSB8fCBhcHByb3hSZW0uZ3JlYXRlclRoYW4ocmVtKSkge1xyXG4gICAgICAgICAgICAgICAgYXBwcm94IC09IGRlbHRhO1xyXG4gICAgICAgICAgICAgICAgYXBwcm94UmVzID0gTG9uZy5mcm9tTnVtYmVyKGFwcHJveCwgdGhpcy51bnNpZ25lZCk7XHJcbiAgICAgICAgICAgICAgICBhcHByb3hSZW0gPSBhcHByb3hSZXMubXVsdGlwbHkob3RoZXIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBXZSBrbm93IHRoZSBhbnN3ZXIgY2FuJ3QgYmUgemVyby4uLiBhbmQgYWN0dWFsbHksIHplcm8gd291bGQgY2F1c2VcclxuICAgICAgICAgICAgLy8gaW5maW5pdGUgcmVjdXJzaW9uIHNpbmNlIHdlIHdvdWxkIG1ha2Ugbm8gcHJvZ3Jlc3MuXHJcbiAgICAgICAgICAgIGlmIChhcHByb3hSZXMuaXNaZXJvKCkpIHtcclxuICAgICAgICAgICAgICAgIGFwcHJveFJlcyA9IExvbmcuT05FO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXMgPSByZXMuYWRkKGFwcHJveFJlcyk7XHJcbiAgICAgICAgICAgIHJlbSA9IHJlbS5zdWJ0cmFjdChhcHByb3hSZW0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhpcyBMb25nIG1vZHVsbyB0aGUgZ2l2ZW4gb25lLlxyXG4gICAgICogQHBhcmFtIHtMb25nfSBvdGhlciBMb25nIGJ5IHdoaWNoIHRvIG1vZC5cclxuICAgICAqIEByZXR1cm4geyFMb25nfSBUaGlzIExvbmcgbW9kdWxvIHRoZSBnaXZlbiBvbmUuXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIExvbmcucHJvdG90eXBlLm1vZHVsbyA9IGZ1bmN0aW9uKG90aGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3VidHJhY3QodGhpcy5kaXYob3RoZXIpLm11bHRpcGx5KG90aGVyKSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiB7IUxvbmd9IFRoZSBiaXR3aXNlLU5PVCBvZiB0aGlzIHZhbHVlLlxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBMb25nLnByb3RvdHlwZS5ub3QgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gTG9uZy5mcm9tQml0cyh+dGhpcy5sb3csIH50aGlzLmhpZ2gsIHRoaXMudW5zaWduZWQpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGJpdHdpc2UtQU5EIG9mIHRoaXMgTG9uZyBhbmQgdGhlIGdpdmVuIG9uZS5cclxuICAgICAqIEBwYXJhbSB7TG9uZ30gb3RoZXIgVGhlIExvbmcgd2l0aCB3aGljaCB0byBBTkQuXHJcbiAgICAgKiBAcmV0dXJuIHshTG9uZ30gVGhlIGJpdHdpc2UtQU5EIG9mIHRoaXMgYW5kIHRoZSBvdGhlci5cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgTG9uZy5wcm90b3R5cGUuYW5kID0gZnVuY3Rpb24ob3RoZXIpIHtcclxuICAgICAgICByZXR1cm4gTG9uZy5mcm9tQml0cyh0aGlzLmxvdyAmIG90aGVyLmxvdywgdGhpcy5oaWdoICYgb3RoZXIuaGlnaCwgdGhpcy51bnNpZ25lZCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgYml0d2lzZS1PUiBvZiB0aGlzIExvbmcgYW5kIHRoZSBnaXZlbiBvbmUuXHJcbiAgICAgKiBAcGFyYW0ge0xvbmd9IG90aGVyIFRoZSBMb25nIHdpdGggd2hpY2ggdG8gT1IuXHJcbiAgICAgKiBAcmV0dXJuIHshTG9uZ30gVGhlIGJpdHdpc2UtT1Igb2YgdGhpcyBhbmQgdGhlIG90aGVyLlxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBMb25nLnByb3RvdHlwZS5vciA9IGZ1bmN0aW9uKG90aGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIExvbmcuZnJvbUJpdHModGhpcy5sb3cgfCBvdGhlci5sb3csIHRoaXMuaGlnaCB8IG90aGVyLmhpZ2gsIHRoaXMudW5zaWduZWQpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGJpdHdpc2UtWE9SIG9mIHRoaXMgTG9uZyBhbmQgdGhlIGdpdmVuIG9uZS5cclxuICAgICAqIEBwYXJhbSB7TG9uZ30gb3RoZXIgVGhlIExvbmcgd2l0aCB3aGljaCB0byBYT1IuXHJcbiAgICAgKiBAcmV0dXJuIHshTG9uZ30gVGhlIGJpdHdpc2UtWE9SIG9mIHRoaXMgYW5kIHRoZSBvdGhlci5cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgTG9uZy5wcm90b3R5cGUueG9yID0gZnVuY3Rpb24ob3RoZXIpIHtcclxuICAgICAgICByZXR1cm4gTG9uZy5mcm9tQml0cyh0aGlzLmxvdyBeIG90aGVyLmxvdywgdGhpcy5oaWdoIF4gb3RoZXIuaGlnaCwgdGhpcy51bnNpZ25lZCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGlzIExvbmcgd2l0aCBiaXRzIHNoaWZ0ZWQgdG8gdGhlIGxlZnQgYnkgdGhlIGdpdmVuIGFtb3VudC5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1CaXRzIFRoZSBudW1iZXIgb2YgYml0cyBieSB3aGljaCB0byBzaGlmdC5cclxuICAgICAqIEByZXR1cm4geyFMb25nfSBUaGlzIHNoaWZ0ZWQgdG8gdGhlIGxlZnQgYnkgdGhlIGdpdmVuIGFtb3VudC5cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgTG9uZy5wcm90b3R5cGUuc2hpZnRMZWZ0ID0gZnVuY3Rpb24obnVtQml0cykge1xyXG4gICAgICAgIG51bUJpdHMgJj0gNjM7XHJcbiAgICAgICAgaWYgKG51bUJpdHMgPT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgbG93ID0gdGhpcy5sb3c7XHJcbiAgICAgICAgICAgIGlmIChudW1CaXRzIDwgMzIpIHtcclxuICAgICAgICAgICAgICAgIHZhciBoaWdoID0gdGhpcy5oaWdoO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIExvbmcuZnJvbUJpdHMobG93IDw8IG51bUJpdHMsIChoaWdoIDw8IG51bUJpdHMpIHwgKGxvdyA+Pj4gKDMyIC0gbnVtQml0cykpLCB0aGlzLnVuc2lnbmVkKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBMb25nLmZyb21CaXRzKDAsIGxvdyA8PCAobnVtQml0cyAtIDMyKSwgdGhpcy51bnNpZ25lZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGlzIExvbmcgd2l0aCBiaXRzIHNoaWZ0ZWQgdG8gdGhlIHJpZ2h0IGJ5IHRoZSBnaXZlbiBhbW91bnQuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtQml0cyBUaGUgbnVtYmVyIG9mIGJpdHMgYnkgd2hpY2ggdG8gc2hpZnQuXHJcbiAgICAgKiBAcmV0dXJuIHshTG9uZ30gVGhpcyBzaGlmdGVkIHRvIHRoZSByaWdodCBieSB0aGUgZ2l2ZW4gYW1vdW50LlxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBMb25nLnByb3RvdHlwZS5zaGlmdFJpZ2h0ID0gZnVuY3Rpb24obnVtQml0cykge1xyXG4gICAgICAgIG51bUJpdHMgJj0gNjM7XHJcbiAgICAgICAgaWYgKG51bUJpdHMgPT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgaGlnaCA9IHRoaXMuaGlnaDtcclxuICAgICAgICAgICAgaWYgKG51bUJpdHMgPCAzMikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGxvdyA9IHRoaXMubG93O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIExvbmcuZnJvbUJpdHMoKGxvdyA+Pj4gbnVtQml0cykgfCAoaGlnaCA8PCAoMzIgLSBudW1CaXRzKSksIGhpZ2ggPj4gbnVtQml0cywgdGhpcy51bnNpZ25lZCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gTG9uZy5mcm9tQml0cyhoaWdoID4+IChudW1CaXRzIC0gMzIpLCBoaWdoID49IDAgPyAwIDogLTEsIHRoaXMudW5zaWduZWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyBzaGlmdGVkIHRvIHRoZSByaWdodCBieSB0aGUgZ2l2ZW4gYW1vdW50LCB3aXRoXHJcbiAgICAgKiB0aGUgbmV3IHRvcCBiaXRzIG1hdGNoaW5nIHRoZSBjdXJyZW50IHNpZ24gYml0LlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG51bUJpdHMgVGhlIG51bWJlciBvZiBiaXRzIGJ5IHdoaWNoIHRvIHNoaWZ0LlxyXG4gICAgICogQHJldHVybiB7IUxvbmd9IFRoaXMgc2hpZnRlZCB0byB0aGUgcmlnaHQgYnkgdGhlIGdpdmVuIGFtb3VudCwgd2l0aFxyXG4gICAgICogICAgIHplcm9zIHBsYWNlZCBpbnRvIHRoZSBuZXcgbGVhZGluZyBiaXRzLlxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBMb25nLnByb3RvdHlwZS5zaGlmdFJpZ2h0VW5zaWduZWQgPSBmdW5jdGlvbihudW1CaXRzKSB7XHJcbiAgICAgICAgbnVtQml0cyAmPSA2MztcclxuICAgICAgICBpZiAobnVtQml0cyA9PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBoaWdoID0gdGhpcy5oaWdoO1xyXG4gICAgICAgICAgICBpZiAobnVtQml0cyA8IDMyKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbG93ID0gdGhpcy5sb3c7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gTG9uZy5mcm9tQml0cygobG93ID4+PiBudW1CaXRzKSB8IChoaWdoIDw8ICgzMiAtIG51bUJpdHMpKSwgaGlnaCA+Pj4gbnVtQml0cywgdGhpcy51bnNpZ25lZCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobnVtQml0cyA9PSAzMikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIExvbmcuZnJvbUJpdHMoaGlnaCwgMCwgdGhpcy51bnNpZ25lZCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gTG9uZy5mcm9tQml0cyhoaWdoID4+PiAobnVtQml0cyAtIDMyKSwgMCwgdGhpcy51bnNpZ25lZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiB7IUxvbmd9IFNpZ25lZCBsb25nXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIExvbmcucHJvdG90eXBlLnRvU2lnbmVkID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIGwgPSB0aGlzLmNsb25lKCk7XHJcbiAgICAgICAgbC51bnNpZ25lZCA9IGZhbHNlO1xyXG4gICAgICAgIHJldHVybiBsO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4geyFMb25nfSBVbnNpZ25lZCBsb25nXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIExvbmcucHJvdG90eXBlLnRvVW5zaWduZWQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgbCA9IHRoaXMuY2xvbmUoKTtcclxuICAgICAgICBsLnVuc2lnbmVkID0gdHJ1ZTtcclxuICAgICAgICByZXR1cm4gbDtcclxuICAgIH07XHJcbiAgICBcclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiB7TG9uZ30gQ2xvbmVkIGluc3RhbmNlIHdpdGggdGhlIHNhbWUgbG93L2hpZ2ggYml0cyBhbmQgdW5zaWduZWQgZmxhZy5cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgTG9uZy5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gbmV3IExvbmcodGhpcy5sb3csIHRoaXMuaGlnaCwgdGhpcy51bnNpZ25lZCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIEVuYWJsZSBtb2R1bGUgbG9hZGluZyBpZiBhdmFpbGFibGVcclxuICAgIGlmICh0eXBlb2YgbW9kdWxlICE9ICd1bmRlZmluZWQnICYmIG1vZHVsZVtcImV4cG9ydHNcIl0pIHsgLy8gQ29tbW9uSlNcclxuICAgICAgICBtb2R1bGVbXCJleHBvcnRzXCJdID0gTG9uZztcclxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSAhPSAndW5kZWZpbmVkJyAmJiBkZWZpbmVbXCJhbWRcIl0pIHsgLy8gQU1EXHJcbiAgICAgICAgZGVmaW5lKFwiTWF0aC9Mb25nXCIsIFtdLCBmdW5jdGlvbigpIHsgcmV0dXJuIExvbmc7IH0pO1xyXG4gICAgfSBlbHNlIHsgLy8gU2hpbVxyXG4gICAgICAgIGlmICghZ2xvYmFsW1wiZGNvZGVJT1wiXSkge1xyXG4gICAgICAgICAgICBnbG9iYWxbXCJkY29kZUlPXCJdID0ge307XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGdsb2JhbFtcImRjb2RlSU9cIl1bXCJMb25nXCJdID0gTG9uZztcclxuICAgIH1cclxuXHJcbn0pKHRoaXMpO1xyXG4iLCIvKlxyXG4gQ29weXJpZ2h0IDIwMTMgRGFuaWVsIFdpcnR6IDxkY29kZUBkY29kZS5pbz5cclxuIENvcHlyaWdodCAyMDA5IFRoZSBDbG9zdXJlIExpYnJhcnkgQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cclxuXHJcbiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcblxyXG4gaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcblxyXG4gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUy1JU1wiIEJBU0lTLFxyXG4gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL2Rpc3QvTG9uZy5qc1wiKTtcclxuIiwidmFyIGZ1cmlvdXMgPSByZXF1aXJlKFwiLi4vbGliL2Z1cmlvdXMuanNcIik7XHJcbnZhciBleHBlY3QgPSByZXF1aXJlKFwiY2hhaVwiKS5leHBlY3Q7XHJcblxyXG52YXIgY29udGV4dCA9IG51bGw7XHJcbmJlZm9yZShmdW5jdGlvbihkb25lKSB7XHJcblx0ZnVyaW91cy5pbml0KGZ1bmN0aW9uKGN0eCkge1xyXG5cdFx0Y29udGV4dCA9IGN0eDtcclxuXHRcdGRvbmUoKTtcclxuXHR9KTtcclxufSk7XHJcblxyXG5kZXNjcmliZShcIkNvbnRleHRcIiwgZnVuY3Rpb24oKXtcclxuXHRkZXNjcmliZShcImJhcnJpZXJcIiwgZnVuY3Rpb24oKSB7XHJcblx0XHRpdChcIkNhbGxzIHRoZSBjYWxsYmFja1wiLCBmdW5jdGlvbihkb25lKSB7XHJcblx0XHRcdGNvbnRleHQuYmFycmllcihmdW5jdGlvbiAoKSB7XHJcblx0XHRcdFx0ZG9uZSgpO1xyXG5cdFx0XHR9KTtcclxuXHRcdH0pO1xyXG5cdFx0aXQoXCJFeGVjdXRlcyBhZnRlciBwcmVjZWVkaW5nIGNvbW1hbmRzIGhhdmUgZmluaXNoZWRcIiwgZnVuY3Rpb24oZG9uZSkge1xyXG5cdFx0XHR2YXIgeCA9IGNvbnRleHQuemVyb3MoWzMsIDNdKTtcclxuXHRcdFx0dmFyIGdldEhhc0ZpbmlzaGVkID0gZmFsc2U7XHJcblx0XHRcdHguZ2V0KGZ1bmN0aW9uKGRhdGEpIHtcclxuXHRcdFx0XHRnZXRIYXNGaW5pc2hlZCA9IHRydWU7XHJcblx0XHRcdH0pO1xyXG5cdFx0XHRjb250ZXh0LmJhcnJpZXIoZnVuY3Rpb24gKCl7XHJcblx0XHRcdFx0ZXhwZWN0KGdldEhhc0ZpbmlzaGVkKS50by5iZS50cnVlO1xyXG5cdFx0XHRcdGRvbmUoKTtcclxuXHRcdFx0fSk7XHJcblx0XHR9KTtcclxuXHRcdGl0KFwiRXhlY3V0ZXMgYmVmb3JlIHN1YnNlcXVlbnQgY29tbWFuZHMgaGF2ZSBzdGFydGVkXCIsIGZ1bmN0aW9uKGRvbmUpIHtcclxuXHRcdFx0dmFyIHggPSBjb250ZXh0Lnplcm9zKFszLCAzXSk7XHJcblx0XHRcdHZhciBiYXJyaWVySGFzRmluaXNoZWQgPSBmYWxzZTtcclxuXHRcdFx0Y29udGV4dC5iYXJyaWVyKGZ1bmN0aW9uICgpe1xyXG5cdFx0XHRcdGJhcnJpZXJIYXNGaW5pc2hlZCA9IHRydWU7XHJcblx0XHRcdH0pO1xyXG5cdFx0XHR4LmdldChmdW5jdGlvbih4KSB7XHJcblx0XHRcdFx0ZXhwZWN0KGJhcnJpZXJIYXNGaW5pc2hlZCkudG8uYmUudHJ1ZTtcclxuXHRcdFx0XHRkb25lKCk7XHJcblx0XHRcdH0pO1xyXG5cdFx0fSk7XHJcblx0fSk7XHJcblx0ZGVzY3JpYmUoXCJlbXB0eVwiLCBmdW5jdGlvbigpe1xyXG5cdFx0aXQoXCJDcmVhdGVzIGFycmF5IHdpdGggc3BlY2lmaWVkIHNoYXBlXCIsIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHR2YXIgeCA9IGNvbnRleHQuZW1wdHkoNDIpO1xyXG5cdFx0XHR2YXIgeSA9IGNvbnRleHQuZW1wdHkoWzQyXSk7XHJcblx0XHRcdHZhciB6ID0gY29udGV4dC5lbXB0eShbNCwgMl0pO1xyXG5cdFx0XHRleHBlY3QoeC5zaGFwZSkudG8uZGVlcC5lcXVhbChbNDJdKTtcclxuXHRcdFx0ZXhwZWN0KHkuc2hhcGUpLnRvLmRlZXAuZXF1YWwoWzQyXSk7XHJcblx0XHRcdGV4cGVjdCh6LnNoYXBlKS50by5kZWVwLmVxdWFsKFs0LCAyXSk7XHJcblx0XHRcdHguaW52YWxpZGF0ZSgpO1xyXG5cdFx0XHR5LmludmFsaWRhdGUoKTtcclxuXHRcdFx0ei5pbnZhbGlkYXRlKCk7XHJcblx0XHR9KTtcclxuXHRcdGl0KFwiQ3JlYXRlcyBhcnJheSB3aXRoIHNwZWNpZmllZCBkYXRhIHR5cGUgKGY2NCBieSBkZWZhdWx0KVwiLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0dmFyIHggPSBjb250ZXh0LmVtcHR5KFs0LCAyXSk7XHJcblx0XHRcdHZhciB5ID0gY29udGV4dC5lbXB0eShbNCwgMl0sIG5ldyBmdXJpb3VzLkRhdGFUeXBlKFwiZjY0XCIpKTtcclxuXHRcdFx0dmFyIHogPSBjb250ZXh0LmVtcHR5KFs0LCAyXSwgbmV3IGZ1cmlvdXMuRGF0YVR5cGUoXCJmMzJcIikpO1xyXG5cdFx0XHRleHBlY3QoeC5kYXRhVHlwZS5lcXVhbHMobmV3IGZ1cmlvdXMuRGF0YVR5cGUoXCJmNjRcIikpKS50by5iZS50cnVlO1xyXG5cdFx0XHRleHBlY3QoeS5kYXRhVHlwZS5lcXVhbHMobmV3IGZ1cmlvdXMuRGF0YVR5cGUoXCJmNjRcIikpKS50by5iZS50cnVlO1xyXG5cdFx0XHRleHBlY3Qoei5kYXRhVHlwZS5lcXVhbHMobmV3IGZ1cmlvdXMuRGF0YVR5cGUoXCJmMzJcIikpKS50by5iZS50cnVlO1xyXG5cdFx0XHR4LmludmFsaWRhdGUoKTtcclxuXHRcdFx0eS5pbnZhbGlkYXRlKCk7XHJcblx0XHRcdHouaW52YWxpZGF0ZSgpO1xyXG5cdFx0fSk7XHJcblx0fSk7XHJcblx0ZGVzY3JpYmUoXCJ6ZXJvc1wiLCBmdW5jdGlvbigpe1xyXG5cdFx0aXQoXCJDcmVhdGVzIGFycmF5IHdpdGggc3BlY2lmaWVkIHNoYXBlXCIsIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHR2YXIgeCA9IGNvbnRleHQuemVyb3MoNDIpO1xyXG5cdFx0XHR2YXIgeSA9IGNvbnRleHQuemVyb3MoWzQyXSk7XHJcblx0XHRcdHZhciB6ID0gY29udGV4dC56ZXJvcyhbNCwgMl0pO1xyXG5cdFx0XHRleHBlY3QoeC5zaGFwZSkudG8uZGVlcC5lcXVhbChbNDJdKTtcclxuXHRcdFx0ZXhwZWN0KHkuc2hhcGUpLnRvLmRlZXAuZXF1YWwoWzQyXSk7XHJcblx0XHRcdGV4cGVjdCh6LnNoYXBlKS50by5kZWVwLmVxdWFsKFs0LCAyXSk7XHJcblx0XHRcdHguaW52YWxpZGF0ZSgpO1xyXG5cdFx0XHR5LmludmFsaWRhdGUoKTtcclxuXHRcdFx0ei5pbnZhbGlkYXRlKCk7XHJcblx0XHR9KTtcclxuXHRcdGl0KFwiQ3JlYXRlcyBhcnJheSB3aXRoIHNwZWNpZmllZCBkYXRhIHR5cGUgKGY2NCBieSBkZWZhdWx0KVwiLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0dmFyIHggPSBjb250ZXh0Lnplcm9zKFs0LCAyXSk7XHJcblx0XHRcdHZhciB5ID0gY29udGV4dC56ZXJvcyhbNCwgMl0sIG5ldyBmdXJpb3VzLkRhdGFUeXBlKFwiZjY0XCIpKTtcclxuXHRcdFx0dmFyIHogPSBjb250ZXh0Lnplcm9zKFs0LCAyXSwgbmV3IGZ1cmlvdXMuRGF0YVR5cGUoXCJmMzJcIikpO1xyXG5cdFx0XHRleHBlY3QoeC5kYXRhVHlwZS5lcXVhbHMobmV3IGZ1cmlvdXMuRGF0YVR5cGUoXCJmNjRcIikpKS50by5iZS50cnVlO1xyXG5cdFx0XHRleHBlY3QoeS5kYXRhVHlwZS5lcXVhbHMobmV3IGZ1cmlvdXMuRGF0YVR5cGUoXCJmNjRcIikpKS50by5iZS50cnVlO1xyXG5cdFx0XHRleHBlY3Qoei5kYXRhVHlwZS5lcXVhbHMobmV3IGZ1cmlvdXMuRGF0YVR5cGUoXCJmMzJcIikpKS50by5iZS50cnVlO1xyXG5cdFx0XHR4LmludmFsaWRhdGUoKTtcclxuXHRcdFx0eS5pbnZhbGlkYXRlKCk7XHJcblx0XHRcdHouaW52YWxpZGF0ZSgpO1xyXG5cdFx0fSk7XHJcblx0XHRpdChcIkNyZWF0ZXMgYXJyYXkgd2l0aCBhbGwgZWxlbWVudHMgaW5pdGlhbGl6ZWQgdG8gemVyb1wiLCBmdW5jdGlvbihkb25lKSB7XHJcblx0XHRcdHZhciB4ID0gY29udGV4dC56ZXJvcyhbMywgMl0sIG5ldyBmdXJpb3VzLkRhdGFUeXBlKFwiZjY0XCIpKTtcclxuXHRcdFx0dmFyIHkgPSBjb250ZXh0Lnplcm9zKFsyLCAzXSwgbmV3IGZ1cmlvdXMuRGF0YVR5cGUoXCJmMzJcIikpO1xyXG5cdFx0XHRjb250ZXh0LmdldCh4LCB5LCBmdW5jdGlvbih4LCB5KSB7XHJcblx0XHRcdFx0ZXhwZWN0KHgpLnRvLmRlZXAuZXF1YWwoW1swLjAsIDAuMF0sXHJcblx0XHRcdFx0ICAgICAgICAgICAgICAgICAgICAgICAgIFswLjAsIDAuMF0sXHJcblx0XHRcdFx0ICAgICAgICAgICAgICAgICAgICAgICAgIFswLjAsIDAuMF1dKTtcclxuXHRcdFx0XHRleHBlY3QoeSkudG8uZGVlcC5lcXVhbChbWzAuMCwgMC4wLCAwLjBdLFxyXG5cdFx0XHRcdCAgICAgICAgICAgICAgICAgICAgICAgICBbMC4wLCAwLjAsIDAuMF1dKTtcclxuXHRcdFx0XHRkb25lKCk7XHJcblx0XHRcdH0pO1xyXG5cdFx0fSk7XHJcblx0fSk7XHJcblx0ZGVzY3JpYmUoXCJvbmVzXCIsIGZ1bmN0aW9uKCl7XHJcblx0XHRpdChcIkNyZWF0ZXMgYXJyYXkgd2l0aCBzcGVjaWZpZWQgc2hhcGVcIiwgZnVuY3Rpb24oKSB7XHJcblx0XHRcdHZhciB4ID0gY29udGV4dC5vbmVzKDQyKTtcclxuXHRcdFx0dmFyIHkgPSBjb250ZXh0Lm9uZXMoWzQyXSk7XHJcblx0XHRcdHZhciB6ID0gY29udGV4dC5vbmVzKFs0LCAyXSk7XHJcblx0XHRcdGV4cGVjdCh4LnNoYXBlKS50by5kZWVwLmVxdWFsKFs0Ml0pO1xyXG5cdFx0XHRleHBlY3QoeS5zaGFwZSkudG8uZGVlcC5lcXVhbChbNDJdKTtcclxuXHRcdFx0ZXhwZWN0KHouc2hhcGUpLnRvLmRlZXAuZXF1YWwoWzQsIDJdKTtcclxuXHRcdFx0eC5pbnZhbGlkYXRlKCk7XHJcblx0XHRcdHkuaW52YWxpZGF0ZSgpO1xyXG5cdFx0XHR6LmludmFsaWRhdGUoKTtcclxuXHRcdH0pO1xyXG5cdFx0aXQoXCJDcmVhdGVzIGFycmF5IHdpdGggc3BlY2lmaWVkIGRhdGEgdHlwZSAoZjY0IGJ5IGRlZmF1bHQpXCIsIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHR2YXIgeCA9IGNvbnRleHQub25lcyhbNCwgMl0pO1xyXG5cdFx0XHR2YXIgeSA9IGNvbnRleHQub25lcyhbNCwgMl0sIG5ldyBmdXJpb3VzLkRhdGFUeXBlKFwiZjY0XCIpKTtcclxuXHRcdFx0dmFyIHogPSBjb250ZXh0Lm9uZXMoWzQsIDJdLCBuZXcgZnVyaW91cy5EYXRhVHlwZShcImYzMlwiKSk7XHJcblx0XHRcdGV4cGVjdCh4LmRhdGFUeXBlLmVxdWFscyhuZXcgZnVyaW91cy5EYXRhVHlwZShcImY2NFwiKSkpLnRvLmJlLnRydWU7XHJcblx0XHRcdGV4cGVjdCh5LmRhdGFUeXBlLmVxdWFscyhuZXcgZnVyaW91cy5EYXRhVHlwZShcImY2NFwiKSkpLnRvLmJlLnRydWU7XHJcblx0XHRcdGV4cGVjdCh6LmRhdGFUeXBlLmVxdWFscyhuZXcgZnVyaW91cy5EYXRhVHlwZShcImYzMlwiKSkpLnRvLmJlLnRydWU7XHJcblx0XHRcdHguaW52YWxpZGF0ZSgpO1xyXG5cdFx0XHR5LmludmFsaWRhdGUoKTtcclxuXHRcdFx0ei5pbnZhbGlkYXRlKCk7XHJcblx0XHR9KTtcclxuXHRcdGl0KFwiQ3JlYXRlcyBhcnJheSB3aXRoIGFsbCBlbGVtZW50cyBpbml0aWFsaXplZCB0byBvbmVcIiwgZnVuY3Rpb24oZG9uZSkge1xyXG5cdFx0XHR2YXIgeCA9IGNvbnRleHQub25lcyhbMywgMl0sIG5ldyBmdXJpb3VzLkRhdGFUeXBlKFwiZjY0XCIpKTtcclxuXHRcdFx0dmFyIHkgPSBjb250ZXh0Lm9uZXMoWzIsIDNdLCBuZXcgZnVyaW91cy5EYXRhVHlwZShcImYzMlwiKSk7XHJcblx0XHRcdGNvbnRleHQuZ2V0KHgsIHksIGZ1bmN0aW9uKHgsIHkpIHtcclxuXHRcdFx0XHRleHBlY3QoeCkudG8uZGVlcC5lcXVhbChbWzEuMCwgMS4wXSxcclxuXHRcdFx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgWzEuMCwgMS4wXSxcclxuXHRcdFx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgWzEuMCwgMS4wXV0pO1xyXG5cdFx0XHRcdGV4cGVjdCh5KS50by5kZWVwLmVxdWFsKFtbMS4wLCAxLjAsIDEuMF0sXHJcblx0XHRcdFx0ICAgICAgICAgICAgICAgICAgICAgICAgIFsxLjAsIDEuMCwgMS4wXV0pO1xyXG5cdFx0XHRcdGRvbmUoKTtcclxuXHRcdFx0fSk7XHJcblx0XHR9KTtcclxuXHR9KTtcclxuXHRkZXNjcmliZShcImFycmF5XCIsIGZ1bmN0aW9uKCl7XHJcblx0XHRpdChcIkNyZWF0ZXMgYXJyYXkgb2YgdGhlIHNhbWUgbGVuZ3RoIGFzIHRoZSBwcm92aWRlZCBhcnJheVwiLCBmdW5jdGlvbigpe1xyXG5cdFx0XHR2YXIgeCA9IGNvbnRleHQuYXJyYXkoWzAsIDFdKTtcclxuXHRcdFx0dmFyIHkgPSBjb250ZXh0LmFycmF5KFtbMCwgMV0sXHJcblx0XHRcdCAgICAgICAgICAgICAgICAgICAgICAgWzIsIDNdLFxyXG5cdFx0XHQgICAgICAgICAgICAgICAgICAgICAgIFszLCA0XV0pO1xyXG5cdFx0XHRleHBlY3QoeC5sZW5ndGgpLnRvLmVxdWFsKDIpO1xyXG5cdFx0XHRleHBlY3QoeS5sZW5ndGgpLnRvLmVxdWFsKDYpO1xyXG5cdFx0XHR4LmludmFsaWRhdGUoKTtcclxuXHRcdFx0eS5pbnZhbGlkYXRlKCk7XHJcblx0XHR9KTtcclxuXHRcdGl0KFwiQ3JlYXRlcyBhcnJheSBvZiB0aGUgc2FtZSBzaGFwZSBhcyB0aGUgcHJvdmlkZWQgYXJyYXlcIiwgZnVuY3Rpb24oKXtcclxuXHRcdFx0dmFyIHggPSBjb250ZXh0LmFycmF5KFswLCAxXSk7XHJcblx0XHRcdHZhciB5ID0gY29udGV4dC5hcnJheShbWzAsIDFdLFxyXG5cdFx0XHQgICAgICAgICAgICAgICAgICAgICAgIFsyLCAzXSxcclxuXHRcdFx0ICAgICAgICAgICAgICAgICAgICAgICBbMywgNF1dKTtcclxuXHRcdFx0dmFyIHogPSBjb250ZXh0LmFycmF5KFtbWzEsIDIsIDNdLCBbIDQsICA1LCAgNl1dLFxyXG5cdFx0XHQgICAgICAgICAgICAgICAgICAgICAgIFtbNywgOCwgOV0sIFsxMCwgMTEsIDEyXV1dKTtcclxuXHRcdFx0ZXhwZWN0KHguc2hhcGUpLnRvLmRlZXAuZXF1YWwoWzJdKTtcclxuXHRcdFx0ZXhwZWN0KHkuc2hhcGUpLnRvLmRlZXAuZXF1YWwoWzMsIDJdKTtcclxuXHRcdFx0ZXhwZWN0KHouc2hhcGUpLnRvLmRlZXAuZXF1YWwoWzIsIDIsIDNdKTtcclxuXHRcdFx0eC5pbnZhbGlkYXRlKCk7XHJcblx0XHRcdHkuaW52YWxpZGF0ZSgpO1xyXG5cdFx0XHR6LmludmFsaWRhdGUoKTtcclxuXHRcdH0pO1xyXG5cdFx0aXQoXCJDcmVhdGVzIGFycmF5IHdpdGggdGhlIHNhbWUgZGF0YSBhcyB0aGUgcHJvdmlkZWQgYXJyYXlcIiwgZnVuY3Rpb24oZG9uZSl7XHJcblx0XHRcdHZhciBhcnJheSA9IFtbWzEsIDIsIDNdLCBbIDQsICA1LCAgNl1dLFxyXG5cdFx0XHQgICAgICAgICAgICAgW1s3LCA4LCA5XSwgWzEwLCAxMSwgMTJdXV07XHJcblx0XHRcdHZhciB4ID0gY29udGV4dC5hcnJheShhcnJheSwgbmV3IGZ1cmlvdXMuRGF0YVR5cGUoXCJmNjRcIikpO1xyXG5cdFx0XHR2YXIgeSA9IGNvbnRleHQuYXJyYXkoYXJyYXksIG5ldyBmdXJpb3VzLkRhdGFUeXBlKFwiZjMyXCIpKTtcclxuXHRcdFx0Y29udGV4dC5nZXQoeCwgeSwgZnVuY3Rpb24oeCwgeSkge1xyXG5cdFx0XHRcdGV4cGVjdCh4KS50by5kZWVwLmVxdWFsKGFycmF5KTtcclxuXHRcdFx0XHRleHBlY3QoeSkudG8uZGVlcC5lcXVhbChhcnJheSk7XHJcblx0XHRcdFx0ZG9uZSgpO1xyXG5cdFx0XHR9KTtcclxuXHRcdH0pO1xyXG5cdH0pO1xyXG5cdGRlc2NyaWJlKFwibGluc3BhY2VcIiwgZnVuY3Rpb24oKXtcclxuXHRcdGl0KFwiSGFzIGxlbmd0aCBvZiA1MCB3aXRoIGRlZmF1bHQgYXJndW1lbnRzXCIsIGZ1bmN0aW9uKCl7XHJcblx0XHRcdGV4cGVjdCgoY29udGV4dC5saW5zcGFjZSgwLCAxKSkubGVuZ3RoKS50by5lcXVhbCg1MCk7XHJcblx0XHR9KTtcclxuXHRcdGl0KFwiSGFzIHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIHNhbXBsZXNcIiwgZnVuY3Rpb24oKXtcclxuXHRcdFx0ZXhwZWN0KChjb250ZXh0LmxpbnNwYWNlKDAsIDEsIDI0MykpLmxlbmd0aCkudG8uZXF1YWwoMjQzKTtcclxuXHRcdH0pO1xyXG5cdFx0aXQoXCJIYXMgZXhwZWN0ZWQgdmFsdWVzXCIsIGZ1bmN0aW9uKGRvbmUpe1xyXG5cdFx0XHR2YXIgc3RhcnQgPSA1MDtcclxuXHRcdFx0dmFyIHN0b3AgPSA5OTtcclxuXHRcdFx0dmFyIHggPSBjb250ZXh0LmxpbnNwYWNlKHN0YXJ0LCBzdG9wKTtcclxuXHRcdFx0eC5nZXQoZnVuY3Rpb24ocmVzdWx0KSB7XHJcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCByZXN1bHQubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRcdGV4cGVjdChyZXN1bHRbaV0pLnRvLmVxdWFsKHN0YXJ0K2kpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRkb25lKCk7XHJcblx0XHRcdH0pO1xyXG5cdFx0fSk7XHJcblx0XHRkZXNjcmliZShcIndpdGggaW5jbHVkZVN0b3AgPT09IGZhbHNlXCIsIGZ1bmN0aW9uKCl7XHJcblx0XHRcdGl0KFwiSGFzIHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIHNhbXBsZXNcIiwgZnVuY3Rpb24oKXtcclxuXHRcdFx0XHRleHBlY3QoKGNvbnRleHQubGluc3BhY2UoMCwgMSwgMjQzLCBmYWxzZSkpLmxlbmd0aCkudG8uZXF1YWwoMjQzKTtcclxuXHRcdFx0fSk7XHJcblx0XHRcdGl0KFwiRG9lcyBub3QgY29udGFpbiB0aGUgcmlnaHQgZW5kcG9pbnRcIiwgZnVuY3Rpb24oZG9uZSl7XHJcblx0XHRcdFx0dmFyIHggPSBjb250ZXh0LmxpbnNwYWNlKC0xLCAxLCAxMDAwLCBmYWxzZSk7XHJcblx0XHRcdFx0eC5nZXQoZnVuY3Rpb24ocmVzdWx0KSB7XHJcblx0XHRcdFx0XHRleHBlY3QocmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXSkudG8ubm90LmVxdWFsKDEpO1xyXG5cdFx0XHRcdFx0ZG9uZSgpO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9KTtcclxuXHRcdH0pO1xyXG5cdH0pO1xyXG5cdGRlc2NyaWJlKFwibmVnXCIsIGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIHhSZWYgPSBbIDEsIC03LjUsICAwLCAtMTVdO1xyXG5cdFx0dmFyIHlSZWYgPSBbLTEsICA3LjUsIC0wLCAgMTVdO1xyXG5cdFx0dmFyIGRhdGFUeXBlcyA9IFtcImYzMlwiLCBcImY2NFwiXTtcclxuXHJcblx0XHRkZXNjcmliZShcIldpdGggbm8gb3V0cHV0IGFycmF5IHN1cHBsaWVkXCIsIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRpdChcIkNyZWF0ZXMgYW4gb3V0cHV0IGFycmF5IHdpdGggdGhlIHNhbWUgc2hhcGUgYXMgaW5wdXQgYXJyYXlcIiwgZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0dmFyIHggPSBjb250ZXh0Lm9uZXMoWzIsIDMsIDRdKTtcclxuXHRcdFx0XHR2YXIgeSA9IGNvbnRleHQubmVnKHgpO1xyXG5cdFx0XHRcdGV4cGVjdCh5LnNoYXBlKS50by5kZWVwLmVxdWFsKFsyLCAzLCA0XSk7XHJcblx0XHRcdFx0eS5pbnZhbGlkYXRlKCk7XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhVHlwZXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHQoZnVuY3Rpb24oZGF0YVR5cGUpIHtcclxuXHRcdFx0XHRcdGl0KFwiQ3JlYXRlcyBhbiBvdXRwdXQgYXJyYXkgd2l0aCB0aGUgc2FtZSBkYXRhIHR5cGUgYXMgaW5wdXQgYXJyYXkgKFwiICsgZGF0YVR5cGUgKyBcIiBkYXRhIHR5cGUpXCIsIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0XHR2YXIgeCA9IGNvbnRleHQuYXJyYXkoeFJlZiwgbmV3IGZ1cmlvdXMuRGF0YVR5cGUoZGF0YVR5cGUpKTtcclxuXHRcdFx0XHRcdFx0dmFyIHkgPSBjb250ZXh0Lm5lZyh4KTtcclxuXHRcdFx0XHRcdFx0ZXhwZWN0KHkuZGF0YVR5cGUuZXF1YWxzKG5ldyBmdXJpb3VzLkRhdGFUeXBlKGRhdGFUeXBlKSkpLnRvLmJlLnRydWU7XHJcblx0XHRcdFx0XHRcdHkuaW52YWxpZGF0ZSgpO1xyXG5cdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0fSkoZGF0YVR5cGVzW2ldKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhVHlwZXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHQoZnVuY3Rpb24oZGF0YVR5cGUpIHtcclxuXHRcdFx0XHRcdGl0KFwiQ3JlYXRlcyBhbiBvdXRwdXQgYXJyYXkgd2l0aCBuZWdhdGVkIGVsZW1lbnRzIChcIiArIGRhdGFUeXBlICsgXCIgZGF0YSB0eXBlKVwiLCBmdW5jdGlvbihkb25lKSB7XHJcblx0XHRcdFx0XHRcdHZhciB4ID0gY29udGV4dC5hcnJheSh4UmVmLCBuZXcgZnVyaW91cy5EYXRhVHlwZShkYXRhVHlwZSkpO1xyXG5cdFx0XHRcdFx0XHR2YXIgeSA9IGNvbnRleHQubmVnKHgpO1xyXG5cdFx0XHRcdFx0XHR5LmdldChmdW5jdGlvbih5KSB7XHJcblx0XHRcdFx0XHRcdFx0ZXhwZWN0KHkpLnRvLmRlZXAuZXF1YWwoeVJlZik7XHJcblx0XHRcdFx0XHRcdFx0ZG9uZSgpO1xyXG5cdFx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdH0pKGRhdGFUeXBlc1tpXSk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdFx0ZGVzY3JpYmUoXCJXaXRoIGFuIG91dHB1dCBhcnJheVwiLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhVHlwZXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHQoZnVuY3Rpb24oZGF0YVR5cGUpIHtcclxuXHRcdFx0XHRcdGl0KFwiUG9wdWxhdGVzIHRoZSBvdXRwdXQgYXJyYXkgd2l0aCBuZWdhdGVkIGVsZW1lbnRzIChcIiArIGRhdGFUeXBlICsgXCIgZGF0YSB0eXBlKVwiLCBmdW5jdGlvbihkb25lKSB7XHJcblx0XHRcdFx0XHRcdHZhciB4ID0gY29udGV4dC5hcnJheSh4UmVmLCBuZXcgZnVyaW91cy5EYXRhVHlwZShkYXRhVHlwZSkpO1xyXG5cdFx0XHRcdFx0XHR2YXIgeSA9IGNvbnRleHQub25lcyh4LnNoYXBlLCB4LmRhdGFUeXBlKTtcclxuXHRcdFx0XHRcdFx0Y29udGV4dC5uZWcoeCwgeSk7XHJcblx0XHRcdFx0XHRcdHkuZ2V0KGZ1bmN0aW9uKHkpIHtcclxuXHRcdFx0XHRcdFx0XHRleHBlY3QoeSkudG8uZGVlcC5lcXVhbCh5UmVmKTtcclxuXHRcdFx0XHRcdFx0XHRkb25lKCk7XHJcblx0XHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0fSkoZGF0YVR5cGVzW2ldKTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0fSk7XHJcblx0ZGVzY3JpYmUoXCJhYnNcIiwgZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgeFJlZiA9IFsxLCAtNy41LCAwLCAtMTVdO1xyXG5cdFx0dmFyIHlSZWYgPSBbMSwgIDcuNSwgMCwgIDE1XTtcclxuXHRcdHZhciBkYXRhVHlwZXMgPSBbXCJmMzJcIiwgXCJmNjRcIl07XHJcblxyXG5cdFx0ZGVzY3JpYmUoXCJXaXRoIG5vIG91dHB1dCBhcnJheSBzdXBwbGllZFwiLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0aXQoXCJDcmVhdGVzIGFuIG91dHB1dCBhcnJheSB3aXRoIHRoZSBzYW1lIHNoYXBlIGFzIGlucHV0IGFycmF5XCIsIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHZhciB4ID0gY29udGV4dC5vbmVzKFsyLCAzLCA0XSk7XHJcblx0XHRcdFx0dmFyIHkgPSBjb250ZXh0LmFicyh4KTtcclxuXHRcdFx0XHRleHBlY3QoeS5zaGFwZSkudG8uZGVlcC5lcXVhbChbMiwgMywgNF0pO1xyXG5cdFx0XHRcdHkuaW52YWxpZGF0ZSgpO1xyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YVR5cGVzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0KGZ1bmN0aW9uKGRhdGFUeXBlKSB7XHJcblx0XHRcdFx0XHRpdChcIkNyZWF0ZXMgYW4gb3V0cHV0IGFycmF5IHdpdGggdGhlIHNhbWUgZGF0YSB0eXBlIGFzIGlucHV0IGFycmF5IChcIiArIGRhdGFUeXBlICsgXCIgZGF0YSB0eXBlKVwiLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRcdFx0dmFyIHggPSBjb250ZXh0LmFycmF5KHhSZWYsIG5ldyBmdXJpb3VzLkRhdGFUeXBlKGRhdGFUeXBlKSk7XHJcblx0XHRcdFx0XHRcdHZhciB5ID0gY29udGV4dC5hYnMoeCk7XHJcblx0XHRcdFx0XHRcdGV4cGVjdCh5LmRhdGFUeXBlLmVxdWFscyhuZXcgZnVyaW91cy5EYXRhVHlwZShkYXRhVHlwZSkpKS50by5iZS50cnVlO1xyXG5cdFx0XHRcdFx0XHR5LmludmFsaWRhdGUoKTtcclxuXHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdH0pKGRhdGFUeXBlc1tpXSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YVR5cGVzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0KGZ1bmN0aW9uKGRhdGFUeXBlKSB7XHJcblx0XHRcdFx0XHRpdChcIkNyZWF0ZXMgYW4gb3V0cHV0IGFycmF5IHdpdGggYWJzb2x1dGUgdmFsdWVzIG9mIGVsZW1lbnRzIChcIiArIGRhdGFUeXBlICsgXCIgZGF0YSB0eXBlKVwiLCBmdW5jdGlvbihkb25lKSB7XHJcblx0XHRcdFx0XHRcdHZhciB4ID0gY29udGV4dC5hcnJheSh4UmVmLCBuZXcgZnVyaW91cy5EYXRhVHlwZShkYXRhVHlwZSkpO1xyXG5cdFx0XHRcdFx0XHR2YXIgeSA9IGNvbnRleHQuYWJzKHgpO1xyXG5cdFx0XHRcdFx0XHR5LmdldChmdW5jdGlvbih5KSB7XHJcblx0XHRcdFx0XHRcdFx0ZXhwZWN0KHkpLnRvLmRlZXAuZXF1YWwoeVJlZik7XHJcblx0XHRcdFx0XHRcdFx0ZG9uZSgpO1xyXG5cdFx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdH0pKGRhdGFUeXBlc1tpXSk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdFx0ZGVzY3JpYmUoXCJXaXRoIGFuIG91dHB1dCBhcnJheVwiLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhVHlwZXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHQoZnVuY3Rpb24oZGF0YVR5cGUpIHtcclxuXHRcdFx0XHRcdGl0KFwiUG9wdWxhdGVzIHRoZSBvdXRwdXQgYXJyYXkgd2l0aCBhYnNvbHV0ZSB2YWx1ZXMgb2YgZWxlbWVudHMgKFwiICsgZGF0YVR5cGUgKyBcIiBkYXRhIHR5cGUpXCIsIGZ1bmN0aW9uKGRvbmUpIHtcclxuXHRcdFx0XHRcdFx0dmFyIHggPSBjb250ZXh0LmFycmF5KHhSZWYsIG5ldyBmdXJpb3VzLkRhdGFUeXBlKGRhdGFUeXBlKSk7XHJcblx0XHRcdFx0XHRcdHZhciB5ID0gY29udGV4dC5vbmVzKHguc2hhcGUsIHguZGF0YVR5cGUpO1xyXG5cdFx0XHRcdFx0XHRjb250ZXh0LmFicyh4LCB5KTtcclxuXHRcdFx0XHRcdFx0eS5nZXQoZnVuY3Rpb24oeSkge1xyXG5cdFx0XHRcdFx0XHRcdGV4cGVjdCh5KS50by5kZWVwLmVxdWFsKHlSZWYpO1xyXG5cdFx0XHRcdFx0XHRcdGRvbmUoKTtcclxuXHRcdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHR9KShkYXRhVHlwZXNbaV0pO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHR9KTtcclxuXHRkZXNjcmliZShcImV4cFwiLCBmdW5jdGlvbigpIHtcclxuXHRcdHZhciB4UmVmID0gWzEsIC0xLCAwXTtcclxuXHRcdHZhciBkYXRhVHlwZXMgPSBbXCJmMzJcIiwgXCJmNjRcIl07XHJcblxyXG5cdFx0ZGVzY3JpYmUoXCJXaXRoIG5vIG91dHB1dCBhcnJheSBzdXBwbGllZFwiLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0aXQoXCJDcmVhdGVzIGFuIG91dHB1dCBhcnJheSB3aXRoIHRoZSBzYW1lIHNoYXBlIGFzIGlucHV0IGFycmF5XCIsIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHZhciB4ID0gY29udGV4dC5vbmVzKFsyLCAzLCA0XSk7XHJcblx0XHRcdFx0dmFyIHkgPSBjb250ZXh0LmV4cCh4KTtcclxuXHRcdFx0XHRleHBlY3QoeS5zaGFwZSkudG8uZGVlcC5lcXVhbChbMiwgMywgNF0pO1xyXG5cdFx0XHRcdHkuaW52YWxpZGF0ZSgpO1xyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YVR5cGVzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0KGZ1bmN0aW9uKGRhdGFUeXBlKSB7XHJcblx0XHRcdFx0XHRpdChcIkNyZWF0ZXMgYW4gb3V0cHV0IGFycmF5IHdpdGggdGhlIHNhbWUgZGF0YSB0eXBlIGFzIGlucHV0IGFycmF5IChcIiArIGRhdGFUeXBlICsgXCIgZGF0YSB0eXBlKVwiLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRcdFx0dmFyIHggPSBjb250ZXh0LmFycmF5KHhSZWYsIG5ldyBmdXJpb3VzLkRhdGFUeXBlKGRhdGFUeXBlKSk7XHJcblx0XHRcdFx0XHRcdHZhciB5ID0gY29udGV4dC5leHAoeCk7XHJcblx0XHRcdFx0XHRcdGV4cGVjdCh5LmRhdGFUeXBlLmVxdWFscyhuZXcgZnVyaW91cy5EYXRhVHlwZShkYXRhVHlwZSkpKS50by5iZS50cnVlO1xyXG5cdFx0XHRcdFx0XHR5LmludmFsaWRhdGUoKTtcclxuXHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdH0pKGRhdGFUeXBlc1tpXSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YVR5cGVzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0KGZ1bmN0aW9uKGRhdGFUeXBlKSB7XHJcblx0XHRcdFx0XHRpdChcIkNyZWF0ZXMgYW4gb3V0cHV0IGFycmF5IHdpdGggYWJzb2x1dGUgdmFsdWVzIG9mIGVsZW1lbnRzIChcIiArIGRhdGFUeXBlICsgXCIgZGF0YSB0eXBlKVwiLCBmdW5jdGlvbihkb25lKSB7XHJcblx0XHRcdFx0XHRcdHZhciB4ID0gY29udGV4dC5hcnJheSh4UmVmLCBuZXcgZnVyaW91cy5EYXRhVHlwZShkYXRhVHlwZSkpO1xyXG5cdFx0XHRcdFx0XHR2YXIgeSA9IGNvbnRleHQuZXhwKHgpO1xyXG5cdFx0XHRcdFx0XHR5LmdldChmdW5jdGlvbih5KSB7XHJcblx0XHRcdFx0XHRcdFx0Zm9yICh2YXIgayA9IDA7IGsgPCB5Lmxlbmd0aDsgaysrKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRleHBlY3QoeVtrXSkudG8uYmUuY2xvc2VUbyhNYXRoLmV4cCh4UmVmW2tdKSwgTWF0aC5leHAoeFJlZltrXSkgKiAzICogeC5kYXRhVHlwZS5lcHNpbG9uKTtcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0ZG9uZSgpO1xyXG5cdFx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdH0pKGRhdGFUeXBlc1tpXSk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdFx0ZGVzY3JpYmUoXCJXaXRoIGFuIG91dHB1dCBhcnJheVwiLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhVHlwZXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHQoZnVuY3Rpb24oZGF0YVR5cGUpIHtcclxuXHRcdFx0XHRcdGl0KFwiUG9wdWxhdGVzIHRoZSBvdXRwdXQgYXJyYXkgd2l0aCBhYnNvbHV0ZSB2YWx1ZXMgb2YgZWxlbWVudHMgKFwiICsgZGF0YVR5cGUgKyBcIiBkYXRhIHR5cGUpXCIsIGZ1bmN0aW9uKGRvbmUpIHtcclxuXHRcdFx0XHRcdFx0dmFyIHggPSBjb250ZXh0LmFycmF5KHhSZWYsIG5ldyBmdXJpb3VzLkRhdGFUeXBlKGRhdGFUeXBlKSk7XHJcblx0XHRcdFx0XHRcdHZhciB5ID0gY29udGV4dC5vbmVzKHguc2hhcGUsIHguZGF0YVR5cGUpO1xyXG5cdFx0XHRcdFx0XHRjb250ZXh0LmV4cCh4LCB5KTtcclxuXHRcdFx0XHRcdFx0eS5nZXQoZnVuY3Rpb24oeSkge1xyXG5cdFx0XHRcdFx0XHRcdGZvciAodmFyIGsgPSAwOyBrIDwgeS5sZW5ndGg7IGsrKykge1xyXG5cdFx0XHRcdFx0XHRcdFx0ZXhwZWN0KHlba10pLnRvLmJlLmNsb3NlVG8oTWF0aC5leHAoeFJlZltrXSksIE1hdGguZXhwKHhSZWZba10pICogMyAqIHguZGF0YVR5cGUuZXBzaWxvbik7XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdGRvbmUoKTtcclxuXHRcdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHR9KShkYXRhVHlwZXNbaV0pO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHR9KTtcclxuXHRkZXNjcmliZShcImxvZ1wiLCBmdW5jdGlvbigpIHtcclxuXHRcdHZhciB4UmVmID0gWzEsIDMsIDEwXTtcclxuXHRcdHZhciBkYXRhVHlwZXMgPSBbXCJmMzJcIiwgXCJmNjRcIl07XHJcblxyXG5cdFx0ZGVzY3JpYmUoXCJXaXRoIG5vIG91dHB1dCBhcnJheSBzdXBwbGllZFwiLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0aXQoXCJDcmVhdGVzIGFuIG91dHB1dCBhcnJheSB3aXRoIHRoZSBzYW1lIHNoYXBlIGFzIGlucHV0IGFycmF5XCIsIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHZhciB4ID0gY29udGV4dC5vbmVzKFsyLCAzLCA0XSk7XHJcblx0XHRcdFx0dmFyIHkgPSBjb250ZXh0LmxvZyh4KTtcclxuXHRcdFx0XHRleHBlY3QoeS5zaGFwZSkudG8uZGVlcC5lcXVhbChbMiwgMywgNF0pO1xyXG5cdFx0XHRcdHkuaW52YWxpZGF0ZSgpO1xyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YVR5cGVzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0KGZ1bmN0aW9uKGRhdGFUeXBlKSB7XHJcblx0XHRcdFx0XHRpdChcIkNyZWF0ZXMgYW4gb3V0cHV0IGFycmF5IHdpdGggdGhlIHNhbWUgZGF0YSB0eXBlIGFzIGlucHV0IGFycmF5IChcIiArIGRhdGFUeXBlICsgXCIgZGF0YSB0eXBlKVwiLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRcdFx0dmFyIHggPSBjb250ZXh0LmFycmF5KHhSZWYsIG5ldyBmdXJpb3VzLkRhdGFUeXBlKGRhdGFUeXBlKSk7XHJcblx0XHRcdFx0XHRcdHZhciB5ID0gY29udGV4dC5sb2coeCk7XHJcblx0XHRcdFx0XHRcdGV4cGVjdCh5LmRhdGFUeXBlLmVxdWFscyhuZXcgZnVyaW91cy5EYXRhVHlwZShkYXRhVHlwZSkpKS50by5iZS50cnVlO1xyXG5cdFx0XHRcdFx0XHR5LmludmFsaWRhdGUoKTtcclxuXHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdH0pKGRhdGFUeXBlc1tpXSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YVR5cGVzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0KGZ1bmN0aW9uKGRhdGFUeXBlKSB7XHJcblx0XHRcdFx0XHRpdChcIkNyZWF0ZXMgYW4gb3V0cHV0IGFycmF5IHdpdGggYWJzb2x1dGUgdmFsdWVzIG9mIGVsZW1lbnRzIChcIiArIGRhdGFUeXBlICsgXCIgZGF0YSB0eXBlKVwiLCBmdW5jdGlvbihkb25lKSB7XHJcblx0XHRcdFx0XHRcdHZhciB4ID0gY29udGV4dC5hcnJheSh4UmVmLCBuZXcgZnVyaW91cy5EYXRhVHlwZShkYXRhVHlwZSkpO1xyXG5cdFx0XHRcdFx0XHR2YXIgeSA9IGNvbnRleHQubG9nKHgpO1xyXG5cdFx0XHRcdFx0XHR5LmdldChmdW5jdGlvbih5KSB7XHJcblx0XHRcdFx0XHRcdFx0Zm9yICh2YXIgayA9IDA7IGsgPCB5Lmxlbmd0aDsgaysrKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRleHBlY3QoeVtrXSkudG8uYmUuY2xvc2VUbyhNYXRoLmxvZyh4UmVmW2tdKSwgTWF0aC5sb2coeFJlZltrXSkgKiAzICogeC5kYXRhVHlwZS5lcHNpbG9uKTtcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0ZG9uZSgpO1xyXG5cdFx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdH0pKGRhdGFUeXBlc1tpXSk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdFx0ZGVzY3JpYmUoXCJXaXRoIGFuIG91dHB1dCBhcnJheVwiLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhVHlwZXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHQoZnVuY3Rpb24oZGF0YVR5cGUpIHtcclxuXHRcdFx0XHRcdGl0KFwiUG9wdWxhdGVzIHRoZSBvdXRwdXQgYXJyYXkgd2l0aCBhYnNvbHV0ZSB2YWx1ZXMgb2YgZWxlbWVudHMgKFwiICsgZGF0YVR5cGUgKyBcIiBkYXRhIHR5cGUpXCIsIGZ1bmN0aW9uKGRvbmUpIHtcclxuXHRcdFx0XHRcdFx0dmFyIHggPSBjb250ZXh0LmFycmF5KHhSZWYsIG5ldyBmdXJpb3VzLkRhdGFUeXBlKGRhdGFUeXBlKSk7XHJcblx0XHRcdFx0XHRcdHZhciB5ID0gY29udGV4dC5vbmVzKHguc2hhcGUsIHguZGF0YVR5cGUpO1xyXG5cdFx0XHRcdFx0XHRjb250ZXh0LmxvZyh4LCB5KTtcclxuXHRcdFx0XHRcdFx0eS5nZXQoZnVuY3Rpb24oeSkge1xyXG5cdFx0XHRcdFx0XHRcdGZvciAodmFyIGsgPSAwOyBrIDwgeS5sZW5ndGg7IGsrKykge1xyXG5cdFx0XHRcdFx0XHRcdFx0ZXhwZWN0KHlba10pLnRvLmJlLmNsb3NlVG8oTWF0aC5sb2coeFJlZltrXSksIE1hdGgubG9nKHhSZWZba10pICogMyAqIHguZGF0YVR5cGUuZXBzaWxvbik7XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdGRvbmUoKTtcclxuXHRcdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHR9KShkYXRhVHlwZXNbaV0pO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHR9KTtcclxuXHRkZXNjcmliZShcInNxcnRcIiwgZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgeFJlZiA9IFswLCAwLjI1LCAxLCA5LCAxMF07XHJcblx0XHR2YXIgZGF0YVR5cGVzID0gW1wiZjMyXCIsIFwiZjY0XCJdO1xyXG5cclxuXHRcdGRlc2NyaWJlKFwiV2l0aCBubyBvdXRwdXQgYXJyYXkgc3VwcGxpZWRcIiwgZnVuY3Rpb24oKSB7XHJcblx0XHRcdGl0KFwiQ3JlYXRlcyBhbiBvdXRwdXQgYXJyYXkgd2l0aCB0aGUgc2FtZSBzaGFwZSBhcyBpbnB1dCBhcnJheVwiLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHR2YXIgeCA9IGNvbnRleHQub25lcyhbMiwgMywgNF0pO1xyXG5cdFx0XHRcdHZhciB5ID0gY29udGV4dC5zcXJ0KHgpO1xyXG5cdFx0XHRcdGV4cGVjdCh5LnNoYXBlKS50by5kZWVwLmVxdWFsKFsyLCAzLCA0XSk7XHJcblx0XHRcdFx0eS5pbnZhbGlkYXRlKCk7XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhVHlwZXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHQoZnVuY3Rpb24oZGF0YVR5cGUpIHtcclxuXHRcdFx0XHRcdGl0KFwiQ3JlYXRlcyBhbiBvdXRwdXQgYXJyYXkgd2l0aCB0aGUgc2FtZSBkYXRhIHR5cGUgYXMgaW5wdXQgYXJyYXkgKFwiICsgZGF0YVR5cGUgKyBcIiBkYXRhIHR5cGUpXCIsIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0XHR2YXIgeCA9IGNvbnRleHQuYXJyYXkoeFJlZiwgbmV3IGZ1cmlvdXMuRGF0YVR5cGUoZGF0YVR5cGUpKTtcclxuXHRcdFx0XHRcdFx0dmFyIHkgPSBjb250ZXh0LnNxcnQoeCk7XHJcblx0XHRcdFx0XHRcdGV4cGVjdCh5LmRhdGFUeXBlLmVxdWFscyhuZXcgZnVyaW91cy5EYXRhVHlwZShkYXRhVHlwZSkpKS50by5iZS50cnVlO1xyXG5cdFx0XHRcdFx0XHR5LmludmFsaWRhdGUoKTtcclxuXHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdH0pKGRhdGFUeXBlc1tpXSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YVR5cGVzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0KGZ1bmN0aW9uKGRhdGFUeXBlKSB7XHJcblx0XHRcdFx0XHRpdChcIkNyZWF0ZXMgYW4gb3V0cHV0IGFycmF5IHdpdGggYWJzb2x1dGUgdmFsdWVzIG9mIGVsZW1lbnRzIChcIiArIGRhdGFUeXBlICsgXCIgZGF0YSB0eXBlKVwiLCBmdW5jdGlvbihkb25lKSB7XHJcblx0XHRcdFx0XHRcdHZhciB4ID0gY29udGV4dC5hcnJheSh4UmVmLCBuZXcgZnVyaW91cy5EYXRhVHlwZShkYXRhVHlwZSkpO1xyXG5cdFx0XHRcdFx0XHR2YXIgeSA9IGNvbnRleHQuc3FydCh4KTtcclxuXHRcdFx0XHRcdFx0eS5nZXQoZnVuY3Rpb24oeSkge1xyXG5cdFx0XHRcdFx0XHRcdGZvciAodmFyIGsgPSAwOyBrIDwgeS5sZW5ndGg7IGsrKykge1xyXG5cdFx0XHRcdFx0XHRcdFx0ZXhwZWN0KHlba10pLnRvLmJlLmNsb3NlVG8oTWF0aC5zcXJ0KHhSZWZba10pLCBNYXRoLnNxcnQoeFJlZltrXSkgKiAzICogeC5kYXRhVHlwZS5lcHNpbG9uKTtcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0ZG9uZSgpO1xyXG5cdFx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdH0pKGRhdGFUeXBlc1tpXSk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdFx0ZGVzY3JpYmUoXCJXaXRoIGFuIG91dHB1dCBhcnJheVwiLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhVHlwZXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHQoZnVuY3Rpb24oZGF0YVR5cGUpIHtcclxuXHRcdFx0XHRcdGl0KFwiUG9wdWxhdGVzIHRoZSBvdXRwdXQgYXJyYXkgd2l0aCBhYnNvbHV0ZSB2YWx1ZXMgb2YgZWxlbWVudHMgKFwiICsgZGF0YVR5cGUgKyBcIiBkYXRhIHR5cGUpXCIsIGZ1bmN0aW9uKGRvbmUpIHtcclxuXHRcdFx0XHRcdFx0dmFyIHggPSBjb250ZXh0LmFycmF5KHhSZWYsIG5ldyBmdXJpb3VzLkRhdGFUeXBlKGRhdGFUeXBlKSk7XHJcblx0XHRcdFx0XHRcdHZhciB5ID0gY29udGV4dC5vbmVzKHguc2hhcGUsIHguZGF0YVR5cGUpO1xyXG5cdFx0XHRcdFx0XHRjb250ZXh0LnNxcnQoeCwgeSk7XHJcblx0XHRcdFx0XHRcdHkuZ2V0KGZ1bmN0aW9uKHkpIHtcclxuXHRcdFx0XHRcdFx0XHRmb3IgKHZhciBrID0gMDsgayA8IHkubGVuZ3RoOyBrKyspIHtcclxuXHRcdFx0XHRcdFx0XHRcdGV4cGVjdCh5W2tdKS50by5iZS5jbG9zZVRvKE1hdGguc3FydCh4UmVmW2tdKSwgTWF0aC5zcXJ0KHhSZWZba10pICogMyAqIHguZGF0YVR5cGUuZXBzaWxvbik7XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdGRvbmUoKTtcclxuXHRcdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHR9KShkYXRhVHlwZXNbaV0pO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHR9KTtcclxuXHRkZXNjcmliZShcInNxdWFyZVwiLCBmdW5jdGlvbigpIHtcclxuXHRcdHZhciB4UmVmID0gWy0yLCAwLCAwLjUsIDEsIDNdO1xyXG5cdFx0dmFyIGRhdGFUeXBlcyA9IFtcImYzMlwiLCBcImY2NFwiXTtcclxuXHJcblx0XHRkZXNjcmliZShcIldpdGggbm8gb3V0cHV0IGFycmF5IHN1cHBsaWVkXCIsIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRpdChcIkNyZWF0ZXMgYW4gb3V0cHV0IGFycmF5IHdpdGggdGhlIHNhbWUgc2hhcGUgYXMgaW5wdXQgYXJyYXlcIiwgZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0dmFyIHggPSBjb250ZXh0Lm9uZXMoWzIsIDMsIDRdKTtcclxuXHRcdFx0XHR2YXIgeSA9IGNvbnRleHQuc3F1YXJlKHgpO1xyXG5cdFx0XHRcdGV4cGVjdCh5LnNoYXBlKS50by5kZWVwLmVxdWFsKFsyLCAzLCA0XSk7XHJcblx0XHRcdFx0eS5pbnZhbGlkYXRlKCk7XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhVHlwZXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHQoZnVuY3Rpb24oZGF0YVR5cGUpIHtcclxuXHRcdFx0XHRcdGl0KFwiQ3JlYXRlcyBhbiBvdXRwdXQgYXJyYXkgd2l0aCB0aGUgc2FtZSBkYXRhIHR5cGUgYXMgaW5wdXQgYXJyYXkgKFwiICsgZGF0YVR5cGUgKyBcIiBkYXRhIHR5cGUpXCIsIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0XHR2YXIgeCA9IGNvbnRleHQuYXJyYXkoeFJlZiwgbmV3IGZ1cmlvdXMuRGF0YVR5cGUoZGF0YVR5cGUpKTtcclxuXHRcdFx0XHRcdFx0dmFyIHkgPSBjb250ZXh0LnNxdWFyZSh4KTtcclxuXHRcdFx0XHRcdFx0ZXhwZWN0KHkuZGF0YVR5cGUuZXF1YWxzKG5ldyBmdXJpb3VzLkRhdGFUeXBlKGRhdGFUeXBlKSkpLnRvLmJlLnRydWU7XHJcblx0XHRcdFx0XHRcdHkuaW52YWxpZGF0ZSgpO1xyXG5cdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0fSkoZGF0YVR5cGVzW2ldKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhVHlwZXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHQoZnVuY3Rpb24oZGF0YVR5cGUpIHtcclxuXHRcdFx0XHRcdGl0KFwiQ3JlYXRlcyBhbiBvdXRwdXQgYXJyYXkgd2l0aCBhYnNvbHV0ZSB2YWx1ZXMgb2YgZWxlbWVudHMgKFwiICsgZGF0YVR5cGUgKyBcIiBkYXRhIHR5cGUpXCIsIGZ1bmN0aW9uKGRvbmUpIHtcclxuXHRcdFx0XHRcdFx0dmFyIHggPSBjb250ZXh0LmFycmF5KHhSZWYsIG5ldyBmdXJpb3VzLkRhdGFUeXBlKGRhdGFUeXBlKSk7XHJcblx0XHRcdFx0XHRcdHZhciB5ID0gY29udGV4dC5zcXVhcmUoeCk7XHJcblx0XHRcdFx0XHRcdHkuZ2V0KGZ1bmN0aW9uKHkpIHtcclxuXHRcdFx0XHRcdFx0XHRmb3IgKHZhciBrID0gMDsgayA8IHkubGVuZ3RoOyBrKyspIHtcclxuXHRcdFx0XHRcdFx0XHRcdGV4cGVjdCh5W2tdKS50by5iZS5jbG9zZVRvKHhSZWZba10gKiB4UmVmW2tdLCB4UmVmW2tdICogeFJlZltrXSAqIHguZGF0YVR5cGUuZXBzaWxvbik7XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdGRvbmUoKTtcclxuXHRcdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHR9KShkYXRhVHlwZXNbaV0pO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHRcdGRlc2NyaWJlKFwiV2l0aCBhbiBvdXRwdXQgYXJyYXlcIiwgZnVuY3Rpb24oKSB7XHJcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YVR5cGVzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0KGZ1bmN0aW9uKGRhdGFUeXBlKSB7XHJcblx0XHRcdFx0XHRpdChcIlBvcHVsYXRlcyB0aGUgb3V0cHV0IGFycmF5IHdpdGggYWJzb2x1dGUgdmFsdWVzIG9mIGVsZW1lbnRzIChcIiArIGRhdGFUeXBlICsgXCIgZGF0YSB0eXBlKVwiLCBmdW5jdGlvbihkb25lKSB7XHJcblx0XHRcdFx0XHRcdHZhciB4ID0gY29udGV4dC5hcnJheSh4UmVmLCBuZXcgZnVyaW91cy5EYXRhVHlwZShkYXRhVHlwZSkpO1xyXG5cdFx0XHRcdFx0XHR2YXIgeSA9IGNvbnRleHQub25lcyh4LnNoYXBlLCB4LmRhdGFUeXBlKTtcclxuXHRcdFx0XHRcdFx0Y29udGV4dC5zcXVhcmUoeCwgeSk7XHJcblx0XHRcdFx0XHRcdHkuZ2V0KGZ1bmN0aW9uKHkpIHtcclxuXHRcdFx0XHRcdFx0XHRmb3IgKHZhciBrID0gMDsgayA8IHkubGVuZ3RoOyBrKyspIHtcclxuXHRcdFx0XHRcdFx0XHRcdGV4cGVjdCh5W2tdKS50by5iZS5jbG9zZVRvKHhSZWZba10gKiB4UmVmW2tdLCB4UmVmW2tdICogeFJlZltrXSAqIHguZGF0YVR5cGUuZXBzaWxvbik7XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdGRvbmUoKTtcclxuXHRcdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHR9KShkYXRhVHlwZXNbaV0pO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHR9KTtcclxufSk7XHJcbiIsInZhciBmdXJpb3VzID0gcmVxdWlyZShcIi4uL2xpYi9mdXJpb3VzLmpzXCIpO1xyXG52YXIgZXhwZWN0ID0gcmVxdWlyZShcImNoYWlcIikuZXhwZWN0O1xyXG5cclxuZGVzY3JpYmUoXCJEYXRhVHlwZVwiLCBmdW5jdGlvbigpe1xyXG5cdGRlc2NyaWJlKFwiZjMyXCIsIGZ1bmN0aW9uKCl7XHJcblx0XHRpdChcInNob3VsZCBoYXZlIHNpemUgNFwiLCBmdW5jdGlvbigpe1xyXG5cdFx0XHR2YXIgZHR5cGUgPSBuZXcgZnVyaW91cy5EYXRhVHlwZShcImYzMlwiKTtcclxuXHRcdFx0ZXhwZWN0KGR0eXBlLnNpemUpLnRvLmVxdWFsKDQpO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0aXQoXCJzaG91bGQgaGF2ZSB0eXBlIFxcXCJmMzJcXFwiXCIsIGZ1bmN0aW9uKCl7XHJcblx0XHRcdHZhciBkdHlwZSA9IG5ldyBmdXJpb3VzLkRhdGFUeXBlKFwiZjMyXCIpO1xyXG5cdFx0XHRleHBlY3QoZHR5cGUudHlwZSkudG8uZXF1YWwoXCJmMzJcIik7XHJcblx0XHR9KTtcclxuXHR9KTtcclxuXHRkZXNjcmliZShcImY2NFwiLCBmdW5jdGlvbigpe1xyXG5cdFx0aXQoXCJzaG91bGQgaGF2ZSBzaXplIDhcIiwgZnVuY3Rpb24oKXtcclxuXHRcdFx0dmFyIGR0eXBlID0gbmV3IGZ1cmlvdXMuRGF0YVR5cGUoXCJmNjRcIik7XHJcblx0XHRcdGV4cGVjdChkdHlwZS5zaXplKS50by5lcXVhbCg4KTtcclxuXHRcdH0pO1xyXG5cclxuXHRcdGl0KFwic2hvdWxkIGhhdmUgdHlwZSBcXFwiZjY0XFxcIlwiLCBmdW5jdGlvbigpe1xyXG5cdFx0XHR2YXIgZHR5cGUgPSBuZXcgZnVyaW91cy5EYXRhVHlwZShcImY2NFwiKTtcclxuXHRcdFx0ZXhwZWN0KGR0eXBlLnR5cGUpLnRvLmVxdWFsKFwiZjY0XCIpO1xyXG5cdFx0fSk7XHJcblx0fSk7XHJcbn0pO1xyXG4iLCJ2YXIgZnVyaW91cyA9IHJlcXVpcmUoXCIuLi9saWIvZnVyaW91cy5qc1wiKTtcclxudmFyIGV4cGVjdCA9IHJlcXVpcmUoXCJjaGFpXCIpLmV4cGVjdDtcclxuXHJcbnZhciBjb250ZXh0ID0gbnVsbDtcclxuYmVmb3JlKGZ1bmN0aW9uKGRvbmUpIHtcclxuXHRmdXJpb3VzLmluaXQoZnVuY3Rpb24oY3R4KSB7XHJcblx0XHRjb250ZXh0ID0gY3R4O1xyXG5cdFx0ZG9uZSgpO1xyXG5cdH0pO1xyXG59KTtcclxuXHJcbmRlc2NyaWJlKFwiTkRBcnJheVwiLCBmdW5jdGlvbigpIHtcclxuXHRkZXNjcmliZShcImxlbmd0aFwiLCBmdW5jdGlvbigpIHtcclxuXHRcdGl0KFwiRXF1YWxzIHRvIHRoZSBudW1iZXIgcGFzc2VkIGluIGNvbnN0cnVjdG9yXCIsIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHR2YXIgeCA9IGNvbnRleHQuZW1wdHkoNDIpO1xyXG5cdFx0XHRleHBlY3QoeC5sZW5ndGgpLnRvLmVxdWFsKDQyKTtcclxuXHRcdFx0eC5pbnZhbGlkYXRlKCk7XHJcblx0XHR9KTtcclxuXHRcdGl0KFwiRXF1YWxzIHRvIHRoZSBudW1iZXIgcGFzc2VkIGluIGNvbnN0cnVjdG9yIGFzIGFuIGFycmF5XCIsIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHR2YXIgeCA9IGNvbnRleHQuZW1wdHkoWzQyXSk7XHJcblx0XHRcdGV4cGVjdCh4Lmxlbmd0aCkudG8uZXF1YWwoNDIpO1xyXG5cdFx0XHR4LmludmFsaWRhdGUoKTtcclxuXHRcdH0pO1xyXG5cdFx0aXQoXCJFcXVhbHMgdG8gdGhlIHByb2R1Y3Qgb2YgZGltZW5zaW9uc1wiLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0dmFyIHggPSBjb250ZXh0LmVtcHR5KFsyLCA1LCAzXSk7XHJcblx0XHRcdGV4cGVjdCh4Lmxlbmd0aCkudG8uZXF1YWwoMzApO1xyXG5cdFx0XHR4LmludmFsaWRhdGUoKTtcclxuXHRcdH0pO1xyXG5cdH0pO1xyXG5cdGRlc2NyaWJlKFwicmVzaGFwZVwiLCBmdW5jdGlvbigpIHtcclxuXHRcdGl0KFwiUHJlc2VydmVzIGxlbmd0aFwiLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0dmFyIHggPSBjb250ZXh0LmVtcHR5KFs3LDUsM10pO1xyXG5cdFx0XHR2YXIgeSA9IHgucmVzaGFwZShbMjEsNV0pO1xyXG5cdFx0XHRleHBlY3QoeS5sZW5ndGgpLnRvLmVxdWFsKHgubGVuZ3RoKTtcclxuXHRcdFx0eS5pbnZhbGlkYXRlKCk7XHJcblx0XHR9KTtcclxuXHRcdGl0KFwiQ2hhbmdlcyBzaGFwZVwiLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0dmFyIHggPSBjb250ZXh0LmVtcHR5KFs3LDUsM10pO1xyXG5cdFx0XHR2YXIgeSA9IHgucmVzaGFwZShbMjEsNV0pO1xyXG5cdFx0XHRleHBlY3QoeS5zaGFwZSkudG8uZGVlcC5lcXVhbChbMjEsNV0pO1xyXG5cdFx0XHR5LmludmFsaWRhdGUoKTtcclxuXHRcdH0pO1xyXG5cdFx0aXQoXCJSZWFycmFuZ2VzIGRhdGFcIiwgZnVuY3Rpb24oZG9uZSkge1xyXG5cdFx0XHR2YXIgeCA9IGNvbnRleHQubGluc3BhY2UoMSwgOCwgOCkucmVzaGFwZShbMiwgMiwgMl0pO1xyXG5cdFx0XHR4LmdldChmdW5jdGlvbihyZXN1bHQpIHtcclxuXHRcdFx0XHRleHBlY3QocmVzdWx0KS50by5kZWVwLmVxdWFsKFtbWyAxLCAgMl0sIFsgMywgIDRdXSxcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdCAgW1sgNSwgIDZdLCBbIDcsICA4XV1dKTtcclxuXHRcdFx0XHRkb25lKCk7XHJcblx0XHRcdH0pO1xyXG5cdFx0fSk7XHJcblx0fSk7XHJcblx0ZGVzY3JpYmUoXCJyZXBlYXRcIiwgZnVuY3Rpb24oKSB7XHJcblx0XHRpdChcIlJlcGVhdHMgYXJyYXkgZWxlbWVudHMgYWxvbmcgYXhpcyAwXCIsIGZ1bmN0aW9uKGRvbmUpIHtcclxuXHRcdFx0dmFyIHggPSBjb250ZXh0LmFycmF5KFtbOCwgMSwgNl0sXHJcblx0XHRcdCAgICAgICAgICAgICAgICAgICAgICAgWzMsIDUsIDddLFxyXG5cdFx0XHQgICAgICAgICAgICAgICAgICAgICAgIFs0LCA5LCAyXV0pO1xyXG5cdFx0XHR4LnJlcGVhdCgyLCAwKS5nZXQoZnVuY3Rpb24oeSkge1xyXG5cdFx0XHRcdGV4cGVjdCh5KS50by5kZWVwLmVxdWFsKFtbOCwgMSwgNl0sXHJcblx0XHRcdFx0ICAgICAgICAgICAgICAgICAgICAgICAgIFs4LCAxLCA2XSxcclxuXHRcdFx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgWzMsIDUsIDddLFxyXG5cdFx0XHRcdCAgICAgICAgICAgICAgICAgICAgICAgICBbMywgNSwgN10sXHJcblx0XHRcdFx0ICAgICAgICAgICAgICAgICAgICAgICAgIFs0LCA5LCAyXSxcclxuXHRcdFx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgWzQsIDksIDJdXSk7XHJcblx0XHRcdFx0ZG9uZSgpO1xyXG5cdFx0XHR9KTtcclxuXHRcdH0pO1xyXG5cdFx0aXQoXCJSZXBlYXRzIGFycmF5IGVsZW1lbnRzIGFsb25nIGF4aXMgMVwiLCBmdW5jdGlvbihkb25lKSB7XHJcblx0XHRcdHZhciB4ID0gY29udGV4dC5hcnJheShbWzgsIDEsIDZdLFxyXG5cdFx0XHQgICAgICAgICAgICAgICAgICAgICAgIFszLCA1LCA3XSxcclxuXHRcdFx0ICAgICAgICAgICAgICAgICAgICAgICBbNCwgOSwgMl1dKTtcclxuXHRcdFx0eC5yZXBlYXQoMiwgMSkuZ2V0KGZ1bmN0aW9uKHkpIHtcclxuXHRcdFx0XHRleHBlY3QoeSkudG8uZGVlcC5lcXVhbChbWzgsIDgsIDEsIDEsIDYsIDZdLFxyXG5cdFx0XHRcdCAgICAgICAgICAgICAgICAgICAgICAgICBbMywgMywgNSwgNSwgNywgN10sXHJcblx0XHRcdFx0ICAgICAgICAgICAgICAgICAgICAgICAgIFs0LCA0LCA5LCA5LCAyLCAyXV0pO1xyXG5cdFx0XHRcdGRvbmUoKTtcclxuXHRcdFx0fSk7XHJcblx0XHR9KTtcclxuXHR9KTtcclxuXHRkZXNjcmliZShcImdldFwiLCBmdW5jdGlvbigpe1xyXG5cdFx0aXQoXCJXb3JrcyB3aXRoIDEtZGltZW5zaW9uYWwgYXJyYXlcIiwgZnVuY3Rpb24oZG9uZSkge1xyXG5cdFx0XHR2YXIgeCA9IGNvbnRleHQuYXJyYXkoWzQyLCAxMF0pO1xyXG5cdFx0XHR4LmdldChmdW5jdGlvbih5KSB7XHJcblx0XHRcdFx0ZXhwZWN0KHkpLnRvLmRlZXAuZXF1YWwoWzQyLCAxMF0pO1xyXG5cdFx0XHRcdGRvbmUoKTtcclxuXHRcdFx0fSk7XHJcblx0XHR9KTtcclxuXHRcdGl0KFwiV29ya3Mgd2l0aCAyLWRpbWVuc2lvbmFsIGFycmF5XCIsIGZ1bmN0aW9uKGRvbmUpIHtcclxuXHRcdFx0dmFyIGFycmF5ID0gW1sxNiwgIDIsICAzLCAxMywgIDVdLFxyXG5cdFx0XHRcdFx0XHQgWzExLCAxMCwgIDgsICA5LCAgN10sXHJcblx0XHRcdFx0XHRcdCBbIDYsIDEyLCAgNCwgMTQsIDE1XV07XHJcblx0XHRcdHZhciB4ID0gY29udGV4dC5hcnJheShhcnJheSk7XHJcblx0XHRcdHguZ2V0KGZ1bmN0aW9uKHkpIHtcclxuXHRcdFx0XHRleHBlY3QoeSkudG8uZGVlcC5lcXVhbChhcnJheSk7XHJcblx0XHRcdFx0ZG9uZSgpO1xyXG5cdFx0XHR9KTtcclxuXHRcdH0pO1xyXG5cdH0pO1xyXG5cdGRlc2NyaWJlKFwiYWRkXCIsIGZ1bmN0aW9uKCkge1xyXG5cdFx0ZGVzY3JpYmUoXCJBZGQgYXJyYXlcIiwgZnVuY3Rpb24oKSB7XHJcblx0XHRcdGl0KFwiQ29ycmVjdCByZXN1bHQgZm9yIDEtZGltZW5zaW9uYWwgYXJyYXlzXCIsIGZ1bmN0aW9uKGRvbmUpIHtcclxuXHRcdFx0XHR2YXIgeCA9IGNvbnRleHQuYXJyYXkoWzEsIDQsIDldKTtcclxuXHRcdFx0XHR2YXIgeSA9IGNvbnRleHQuYXJyYXkoWzgsIC0xLCAxMF0pO1xyXG5cdFx0XHRcdHZhciB6ID0geC5hZGQoeSk7XHJcblx0XHRcdFx0ei5nZXQoZnVuY3Rpb24oeikge1xyXG5cdFx0XHRcdFx0ZXhwZWN0KHopLnRvLmRlZXAuZXF1YWwoWzksIDMsIDE5XSk7XHJcblx0XHRcdFx0XHRkb25lKCk7XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH0pO1xyXG5cdFx0XHRpdChcIkNvcnJlY3QgcmVzdWx0IGZvciAyLWRpbWVuc2lvbmFsIGFycmF5c1wiLCBmdW5jdGlvbihkb25lKSB7XHJcblx0XHRcdFx0dmFyIHggPSBjb250ZXh0LmFycmF5KFtbMSwgNF0sIFs5LCAtMTddXSk7XHJcblx0XHRcdFx0dmFyIHkgPSBjb250ZXh0LmFycmF5KFtbOCwgLTFdLCBbMTAsIC0yMV1dKTtcclxuXHRcdFx0XHR2YXIgeiA9IHguYWRkKHkpO1xyXG5cdFx0XHRcdHouZ2V0KGZ1bmN0aW9uKHJlc3VsdCkge1xyXG5cdFx0XHRcdFx0ZXhwZWN0KHJlc3VsdCkudG8uZGVlcC5lcXVhbChbWzksIDNdLCBbMTksIC0zOF1dKTtcclxuXHRcdFx0XHRcdGRvbmUoKTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fSk7XHJcblx0XHR9KTtcclxuXHRcdGRlc2NyaWJlKFwiQWRkIHNjYWxhclwiLCBmdW5jdGlvbigpe1xyXG5cdFx0XHRpdChcIkNvcnJlY3QgcmVzdWx0IGZvciAxLWRpbWVuc2lvbmFsIGFycmF5c1wiLCBmdW5jdGlvbihkb25lKSB7XHJcblx0XHRcdFx0dmFyIHggPSBjb250ZXh0LmFycmF5KFsxLCA0LCA5XSk7XHJcblx0XHRcdFx0dmFyIHogPSB4LmFkZCgtNyk7XHJcblx0XHRcdFx0ei5nZXQoZnVuY3Rpb24oeikge1xyXG5cdFx0XHRcdFx0ZXhwZWN0KHopLnRvLmRlZXAuZXF1YWwoWy02LCAtMywgMl0pO1xyXG5cdFx0XHRcdFx0ZG9uZSgpO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9KTtcclxuXHRcdFx0aXQoXCJDb3JyZWN0IHJlc3VsdCBmb3IgMi1kaW1lbnNpb25hbCBhcnJheXNcIiwgZnVuY3Rpb24oZG9uZSkge1xyXG5cdFx0XHRcdHZhciB4ID0gY29udGV4dC5hcnJheShbWzEsIDRdLCBbOSwgLTE3XV0pO1xyXG5cdFx0XHRcdHZhciB6ID0geC5hZGQoNDIpO1xyXG5cdFx0XHRcdHouZ2V0KGZ1bmN0aW9uKHopIHtcclxuXHRcdFx0XHRcdGV4cGVjdCh6KS50by5kZWVwLmVxdWFsKFtbNDMsIDQ2XSwgWzUxLCAyNV1dKTtcclxuXHRcdFx0XHRcdGRvbmUoKTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fSk7XHJcblx0XHR9KTtcclxuXHR9KTtcclxuXHRkZXNjcmliZShcInN1YlwiLCBmdW5jdGlvbigpIHtcclxuXHRcdGRlc2NyaWJlKFwiU3VidHJhY3QgYXJyYXlcIiwgZnVuY3Rpb24oKSB7XHJcblx0XHRcdGl0KFwiQ29ycmVjdCByZXN1bHQgZm9yIDEtZGltZW5zaW9uYWwgYXJyYXlzXCIsIGZ1bmN0aW9uKGRvbmUpIHtcclxuXHRcdFx0XHR2YXIgeCA9IGNvbnRleHQuYXJyYXkoWzEsIDQsIDldKTtcclxuXHRcdFx0XHR2YXIgeSA9IGNvbnRleHQuYXJyYXkoWzgsIC0xLCAxMF0pO1xyXG5cdFx0XHRcdHZhciB6ID0geC5zdWIoeSk7XHJcblx0XHRcdFx0ei5nZXQoZnVuY3Rpb24ocmVzdWx0KSB7XHJcblx0XHRcdFx0XHRleHBlY3QocmVzdWx0KS50by5kZWVwLmVxdWFsKFstNywgNSwgLTFdKTtcclxuXHRcdFx0XHRcdGRvbmUoKTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fSk7XHJcblx0XHRcdGl0KFwiQ29ycmVjdCByZXN1bHQgZm9yIDItZGltZW5zaW9uYWwgYXJyYXlzXCIsIGZ1bmN0aW9uKGRvbmUpIHtcclxuXHRcdFx0XHR2YXIgeCA9IGNvbnRleHQuYXJyYXkoW1sxLCA0XSwgWzksIC0xN11dKTtcclxuXHRcdFx0XHR2YXIgeSA9IGNvbnRleHQuYXJyYXkoW1s4LCAtMV0sIFsxMCwgLTIxXV0pO1xyXG5cdFx0XHRcdHZhciB6ID0geC5zdWIoeSk7XHJcblx0XHRcdFx0ei5nZXQoZnVuY3Rpb24ocmVzdWx0KSB7XHJcblx0XHRcdFx0XHRleHBlY3QocmVzdWx0KS50by5kZWVwLmVxdWFsKFtbLTcsIDVdLCBbLTEsIDRdXSk7XHJcblx0XHRcdFx0XHRkb25lKCk7XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH0pO1xyXG5cdFx0fSk7XHJcblx0XHRkZXNjcmliZShcIlN1YnRyYWN0IHNjYWxhclwiLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0aXQoXCJDb3JyZWN0IHJlc3VsdCBmb3IgMS1kaW1lbnNpb25hbCBhcnJheXNcIiwgZnVuY3Rpb24oZG9uZSkge1xyXG5cdFx0XHRcdHZhciB4ID0gY29udGV4dC5hcnJheShbMSwgNCwgOV0pO1xyXG5cdFx0XHRcdHZhciB5ID0geC5zdWIoLTcpO1xyXG5cdFx0XHRcdHkuZ2V0KGZ1bmN0aW9uKHkpIHtcclxuXHRcdFx0XHRcdGV4cGVjdCh5KS50by5kZWVwLmVxdWFsKFs4LCAxMSwgMTZdKTtcclxuXHRcdFx0XHRcdGRvbmUoKTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fSk7XHJcblx0XHRcdGl0KFwiQ29ycmVjdCByZXN1bHQgZm9yIDItZGltZW5zaW9uYWwgYXJyYXlzXCIsIGZ1bmN0aW9uKGRvbmUpIHtcclxuXHRcdFx0XHR2YXIgeCA9IGNvbnRleHQuYXJyYXkoW1sxLCA0XSwgWzksIC0xN11dKTtcclxuXHRcdFx0XHR2YXIgeSA9IHguc3ViKDQyKTtcclxuXHRcdFx0XHR5LmdldChmdW5jdGlvbih5KSB7XHJcblx0XHRcdFx0XHRleHBlY3QoeSkudG8uZGVlcC5lcXVhbChbWy00MSwgLTM4XSwgWy0zMywgLTU5XV0pO1xyXG5cdFx0XHRcdFx0ZG9uZSgpO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9KTtcclxuXHRcdH0pO1xyXG5cdH0pO1xyXG5cdGRlc2NyaWJlKFwibXVsXCIsIGZ1bmN0aW9uKCkge1xyXG5cdFx0ZGVzY3JpYmUoXCJNdWx0aXBseSBieSBhcnJheVwiLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0aXQoXCJDb3JyZWN0IHJlc3VsdCBmb3IgMS1kaW1lbnNpb25hbCBhcnJheXNcIiwgZnVuY3Rpb24oZG9uZSkge1xyXG5cdFx0XHRcdHZhciB4ID0gY29udGV4dC5hcnJheShbMSwgNCwgOV0pO1xyXG5cdFx0XHRcdHZhciB5ID0gY29udGV4dC5hcnJheShbOCwgLTEsIDEwXSk7XHJcblx0XHRcdFx0dmFyIHogPSB4Lm11bCh5KTtcclxuXHRcdFx0XHR6LmdldChmdW5jdGlvbih6KSB7XHJcblx0XHRcdFx0XHRleHBlY3QoeikudG8uZGVlcC5lcXVhbChbOCwgLTQsIDkwXSk7XHJcblx0XHRcdFx0XHRkb25lKCk7XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH0pO1xyXG5cdFx0XHRpdChcIkNvcnJlY3QgcmVzdWx0IGZvciAyLWRpbWVuc2lvbmFsIGFycmF5c1wiLCBmdW5jdGlvbihkb25lKSB7XHJcblx0XHRcdFx0dmFyIHggPSBjb250ZXh0LmFycmF5KFtbMSwgNF0sIFs5LCAtMTddXSk7XHJcblx0XHRcdFx0dmFyIHkgPSBjb250ZXh0LmFycmF5KFtbOCwgLTFdLCBbMTAsIC0yMV1dKTtcclxuXHRcdFx0XHR2YXIgeiA9IHgubXVsKHkpO1xyXG5cdFx0XHRcdHouZ2V0KGZ1bmN0aW9uKHopIHtcclxuXHRcdFx0XHRcdGV4cGVjdCh6KS50by5kZWVwLmVxdWFsKFtbOCwgLTRdLCBbOTAsIDM1N11dKTtcclxuXHRcdFx0XHRcdGRvbmUoKTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fSk7XHJcblx0XHR9KTtcclxuXHRcdGRlc2NyaWJlKFwiTXVsdGlwbHkgYnkgc2NhbGFyXCIsIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRpdChcIkNvcnJlY3QgcmVzdWx0IGZvciAxLWRpbWVuc2lvbmFsIGFycmF5c1wiLCBmdW5jdGlvbihkb25lKSB7XHJcblx0XHRcdFx0dmFyIHggPSBjb250ZXh0LmFycmF5KFsxLCA0LCA5XSk7XHJcblx0XHRcdFx0dmFyIHkgPSB4Lm11bCgtMTApO1xyXG5cdFx0XHRcdHkuZ2V0KGZ1bmN0aW9uKHkpIHtcclxuXHRcdFx0XHRcdGV4cGVjdCh5KS50by5kZWVwLmVxdWFsKFstMTAsIC00MCwgLTkwXSk7XHJcblx0XHRcdFx0XHRkb25lKCk7XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH0pO1xyXG5cdFx0XHRpdChcIkNvcnJlY3QgcmVzdWx0IGZvciAyLWRpbWVuc2lvbmFsIGFycmF5c1wiLCBmdW5jdGlvbihkb25lKSB7XHJcblx0XHRcdFx0dmFyIHggPSBjb250ZXh0LmFycmF5KFtbMSwgNF0sIFs5LCAtMTddXSk7XHJcblx0XHRcdFx0dmFyIHkgPSB4Lm11bCgxMCk7XHJcblx0XHRcdFx0eS5nZXQoZnVuY3Rpb24oeSkge1xyXG5cdFx0XHRcdFx0ZXhwZWN0KHkpLnRvLmRlZXAuZXF1YWwoW1sxMCwgNDBdLCBbOTAsIC0xNzBdXSk7XHJcblx0XHRcdFx0XHRkb25lKCk7XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH0pO1xyXG5cdFx0fSk7XHJcblx0fSk7XHJcblx0ZGVzY3JpYmUoXCJkaXZcIiwgZnVuY3Rpb24oKXtcclxuXHRcdGRlc2NyaWJlKFwiRGl2aWRlIGJ5IGFycmF5XCIsIGZ1bmN0aW9uKCl7XHJcblx0XHRcdGl0KFwiQ29ycmVjdCByZXN1bHQgZm9yIDEtZGltZW5zaW9uYWwgYXJyYXlzXCIsIGZ1bmN0aW9uKGRvbmUpIHtcclxuXHRcdFx0XHR2YXIgeCA9IGNvbnRleHQuYXJyYXkoWzEsIDQsIDldKTtcclxuXHRcdFx0XHR2YXIgeSA9IGNvbnRleHQuYXJyYXkoWzIsIC00LCA4XSk7XHJcblx0XHRcdFx0dmFyIHogPSB4LmRpdih5KTtcclxuXHRcdFx0XHR6LmdldChmdW5jdGlvbih6KSB7XHJcblx0XHRcdFx0XHRleHBlY3QoeikudG8uZGVlcC5lcXVhbChbMC41LCAtMSwgMS4xMjVdKTtcclxuXHRcdFx0XHRcdGRvbmUoKTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fSk7XHJcblx0XHRcdGl0KFwiQ29ycmVjdCByZXN1bHQgZm9yIDItZGltZW5zaW9uYWwgYXJyYXlzXCIsIGZ1bmN0aW9uKGRvbmUpIHtcclxuXHRcdFx0XHR2YXIgeCA9IGNvbnRleHQuYXJyYXkoW1sxLCA0XSwgWzksIC0xN11dKTtcclxuXHRcdFx0XHR2YXIgeSA9IGNvbnRleHQuYXJyYXkoW1stMiwgNF0sIFstOCwgMTZdXSk7XHJcblx0XHRcdFx0dmFyIHogPSB4LmRpdih5KTtcclxuXHRcdFx0XHR6LmdldChmdW5jdGlvbih6KSB7XHJcblx0XHRcdFx0XHRleHBlY3QoeikudG8uZGVlcC5lcXVhbChbWy0wLjUsIDFdLCBbLTEuMTI1LCAtMS4wNjI1XV0pO1xyXG5cdFx0XHRcdFx0ZG9uZSgpO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9KTtcclxuXHRcdH0pO1xyXG5cdFx0ZGVzY3JpYmUoXCJEaXZpZGUgYnkgc2NhbGFyXCIsIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRpdChcIkNvcnJlY3QgcmVzdWx0IGZvciAxLWRpbWVuc2lvbmFsIGFycmF5c1wiLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHR2YXIgeCA9IGNvbnRleHQuYXJyYXkoWzEsIDQsIDldKTtcclxuXHRcdFx0XHR2YXIgeSA9IHguZGl2KC0yKTtcclxuXHRcdFx0XHR5LmdldChmdW5jdGlvbih5KSB7XHJcblx0XHRcdFx0XHRleHBlY3QoeSkudG8uZGVlcC5lcXVhbChbLTAuNSwgLTIsIC00LjVdKTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fSk7XHJcblx0XHRcdGl0KFwiQ29ycmVjdCByZXN1bHQgZm9yIDItZGltZW5zaW9uYWwgYXJyYXlzXCIsIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHZhciB4ID0gY29udGV4dC5hcnJheShbWzEsIDRdLCBbOSwgLTE3XV0pO1xyXG5cdFx0XHRcdHZhciB5ID0geC5kaXYoLTQpO1xyXG5cdFx0XHRcdHkuZ2V0KGZ1bmN0aW9uKHkpIHtcclxuXHRcdFx0XHRcdGV4cGVjdCh5KS50by5kZWVwLmVxdWFsKFtbLTAuMjUsIC0xXSwgWy0yLjI1LCA0LjI1XV0pO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9KTtcclxuXHRcdH0pO1xyXG5cdH0pO1xyXG5cdGRlc2NyaWJlKFwibWluXCIsIGZ1bmN0aW9uKCl7XHJcblx0XHRkZXNjcmliZShcIkFsbCBlbGVtZW50c1wiLCBmdW5jdGlvbigpe1xyXG5cdFx0XHRpdChcIlJldHVybnMgemVyby1kaW1lbnNpb25hbCBhcnJheSBvZiBsZW5ndGggb25lXCIsIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHZhciB4ID0gY29udGV4dC56ZXJvcyhbMjAsIDMwXSk7XHJcblx0XHRcdFx0dmFyIHkgPSB4Lm1pbigpO1xyXG5cdFx0XHRcdGV4cGVjdCh5LnNoYXBlKS50by5kZWVwLmVxdWFsKFtdKTtcclxuXHRcdFx0XHRleHBlY3QoeS5sZW5ndGgpLnRvLmVxdWFsKDEpO1xyXG5cdFx0XHRcdHkuaW52YWxpZGF0ZSgpO1xyXG5cdFx0XHR9KTtcclxuXHRcdFx0aXQoXCJDb21wdXRlcyB0aGUgbWluaW11bSBvZiBhbGwgZWxlbWVudHMgaW4gYW4gYXJyYXlcIiwgZnVuY3Rpb24oZG9uZSkge1xyXG5cdFx0XHRcdHZhciB4ID0gY29udGV4dC5saW5zcGFjZSgtNTAsIDEwMCwgMTAwMDAwKS5yZXNoYXBlKFsyMDAsIDUwMF0pO1xyXG5cdFx0XHRcdHgubWluKCkuZ2V0KGZ1bmN0aW9uKHkpIHtcclxuXHRcdFx0XHRcdGV4cGVjdCh5KS50by5lcXVhbCgtNTApO1xyXG5cdFx0XHRcdFx0ZG9uZSgpO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9KTtcclxuXHRcdH0pO1xyXG5cdFx0ZGVzY3JpYmUoXCJBbG9uZyBhbiBheGlzXCIsIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRpdChcIkNvcnJlY3Qgc2hhcGUgZm9yIDMtZGltZW5zaW9uYWwgYXJyYXlzXCIsIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHZhciB4ID0gY29udGV4dC5saW5zcGFjZSgxLCAyNCwgMjQpLnJlc2hhcGUoWzIsIDMsIDRdKS5sb2NrKCk7XHJcblx0XHRcdFx0ZXhwZWN0KHgubWluKDApLnNoYXBlKS50by5kZWVwLmVxdWFsKFszLCA0XSk7XHJcblx0XHRcdFx0ZXhwZWN0KHgubWluKDEpLnNoYXBlKS50by5kZWVwLmVxdWFsKFsyLCA0XSk7XHJcblx0XHRcdFx0ZXhwZWN0KHgubWluKDIpLnNoYXBlKS50by5kZWVwLmVxdWFsKFsyLCAzXSk7XHJcblx0XHRcdFx0eC5pbnZhbGlkYXRlKCk7XHJcblx0XHRcdH0pO1xyXG5cdFx0XHRpdChcIkNvcnJlY3QgcmVzdWx0IGZvciAzLWRpbWVuc2lvbmFsIGFycmF5cywgYXhpcyAwXCIsIGZ1bmN0aW9uKGRvbmUpIHtcclxuXHRcdFx0XHR2YXIgeCA9IGNvbnRleHQubGluc3BhY2UoMSwgMjQsIDI0KS5yZXNoYXBlKFsyLCAzLCA0XSk7XHJcblx0XHRcdFx0eC5taW4oMCkuZ2V0KGZ1bmN0aW9uKHkpIHtcclxuXHRcdFx0XHRcdGV4cGVjdCh5KS50by5kZWVwLmVxdWFsKFtbIDEsICAyLCAgMywgIDRdLFxyXG5cdFx0XHRcdFx0ICAgICAgICAgICAgICAgICAgICAgICAgIFsgNSwgIDYsICA3LCAgOF0sXHJcblx0XHRcdFx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgWyA5LCAxMCwgMTEsIDEyXV0pO1xyXG5cdFx0XHRcdFx0ZG9uZSgpO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9KTtcclxuXHRcdFx0aXQoXCJDb3JyZWN0IHJlc3VsdCBmb3IgMy1kaW1lbnNpb25hbCBhcnJheXMsIGF4aXMgMVwiLCBmdW5jdGlvbihkb25lKSB7XHJcblx0XHRcdFx0dmFyIHggPSBjb250ZXh0LmxpbnNwYWNlKDEsIDI0LCAyNCkucmVzaGFwZShbMiwgMywgNF0pO1xyXG5cdFx0XHRcdHgubWluKDEpLmdldChmdW5jdGlvbih5KSB7XHJcblx0XHRcdFx0XHRleHBlY3QoeSkudG8uZGVlcC5lcXVhbChbWyAgMSwgIDIsICAzLCAgNF0sXHJcblx0XHRcdFx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgWyAxMywgMTQsIDE1LCAxNl1dKTtcclxuXHRcdFx0XHRcdGRvbmUoKTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fSk7XHJcblx0XHRcdGl0KFwiQ29ycmVjdCByZXN1bHQgZm9yIDMtZGltZW5zaW9uYWwgYXJyYXlzLCBheGlzIDJcIiwgZnVuY3Rpb24oZG9uZSkge1xyXG5cdFx0XHRcdHZhciB4ID0gY29udGV4dC5saW5zcGFjZSgxLCAyNCwgMjQpLnJlc2hhcGUoWzIsIDMsIDRdKTtcclxuXHRcdFx0XHR4Lm1pbigyKS5nZXQoZnVuY3Rpb24oeSkge1xyXG5cdFx0XHRcdFx0ZXhwZWN0KHkpLnRvLmRlZXAuZXF1YWwoW1sgIDEsICA1LCAgOV0sXHJcblx0XHRcdFx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgWyAxMywgMTcsIDIxXV0pO1xyXG5cdFx0XHRcdFx0ZG9uZSgpO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9KTtcclxuXHRcdH0pO1xyXG5cdH0pO1xyXG5cdGRlc2NyaWJlKFwibWF4XCIsIGZ1bmN0aW9uKCkge1xyXG5cdFx0ZGVzY3JpYmUoXCJBbGwgZWxlbWVudHNcIiwgZnVuY3Rpb24oKSB7XHJcblx0XHRcdGl0KFwiUmV0dXJucyB6ZXJvLWRpbWVuc2lvbmFsIGFycmF5IG9mIGxlbmd0aCBvbmVcIiwgZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0dmFyIHggPSBjb250ZXh0Lnplcm9zKFsyMCwgMzBdKTtcclxuXHRcdFx0XHR2YXIgeSA9IHgubWF4KCk7XHJcblx0XHRcdFx0ZXhwZWN0KHkuc2hhcGUpLnRvLmRlZXAuZXF1YWwoW10pO1xyXG5cdFx0XHRcdGV4cGVjdCh5Lmxlbmd0aCkudG8uZXF1YWwoMSk7XHJcblx0XHRcdFx0eS5pbnZhbGlkYXRlKCk7XHJcblx0XHRcdH0pO1xyXG5cdFx0XHRpdChcIkNvbXB1dGVzIHRoZSBtYXhpbXVtIG9mIGFsbCBlbGVtZW50cyBpbiBhbiBhcnJheVwiLCBmdW5jdGlvbihkb25lKSB7XHJcblx0XHRcdFx0dmFyIHggPSBjb250ZXh0LmxpbnNwYWNlKC01MCwgMTAwLCAxMDAwMDApLnJlc2hhcGUoWzIwMCwgNTAwXSk7XHJcblx0XHRcdFx0eC5tYXgoKS5nZXQoZnVuY3Rpb24oeSkge1xyXG5cdFx0XHRcdFx0ZXhwZWN0KHkpLnRvLmVxdWFsKDEwMCk7XHJcblx0XHRcdFx0XHRkb25lKCk7XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH0pO1xyXG5cdFx0fSk7XHJcblx0XHRkZXNjcmliZShcIkFsb25nIGFuIGF4aXNcIiwgZnVuY3Rpb24oKSB7XHJcblx0XHRcdGl0KFwiQ29ycmVjdCBzaGFwZSBmb3IgMy1kaW1lbnNpb25hbCBhcnJheXNcIiwgZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0dmFyIHggPSBjb250ZXh0LmxpbnNwYWNlKDEsIDI0LCAyNCkucmVzaGFwZShbMiwgMywgNF0pLmxvY2soKTtcclxuXHRcdFx0XHRleHBlY3QoeC5tYXgoMCkuc2hhcGUpLnRvLmRlZXAuZXF1YWwoWzMsIDRdKTtcclxuXHRcdFx0XHRleHBlY3QoeC5tYXgoMSkuc2hhcGUpLnRvLmRlZXAuZXF1YWwoWzIsIDRdKTtcclxuXHRcdFx0XHRleHBlY3QoeC5tYXgoMikuc2hhcGUpLnRvLmRlZXAuZXF1YWwoWzIsIDNdKTtcclxuXHRcdFx0XHR4LmludmFsaWRhdGUoKTtcclxuXHRcdFx0fSk7XHJcblx0XHRcdGl0KFwiQ29ycmVjdCByZXN1bHQgZm9yIDMtZGltZW5zaW9uYWwgYXJyYXlzLCBheGlzIDBcIiwgZnVuY3Rpb24oZG9uZSkge1xyXG5cdFx0XHRcdHZhciB4ID0gY29udGV4dC5saW5zcGFjZSgxLCAyNCwgMjQpLnJlc2hhcGUoWzIsIDMsIDRdKTtcclxuXHRcdFx0XHR4Lm1heCgwKS5nZXQoZnVuY3Rpb24oeSkge1xyXG5cdFx0XHRcdFx0ZXhwZWN0KHkpLnRvLmRlZXAuZXF1YWwoW1sgMTMsIDE0LCAxNSwgMTZdLFxyXG5cdFx0XHRcdFx0ICAgICAgICAgICAgICAgICAgICAgICAgIFsgMTcsIDE4LCAxOSwgMjBdLFxyXG5cdFx0XHRcdFx0ICAgICAgICAgICAgICAgICAgICAgICAgIFsgMjEsIDIyLCAyMywgMjRdXSk7XHJcblx0XHRcdFx0XHRkb25lKCk7XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH0pO1xyXG5cdFx0XHRpdChcIkNvcnJlY3QgcmVzdWx0IGZvciAzLWRpbWVuc2lvbmFsIGFycmF5cywgYXhpcyAxXCIsIGZ1bmN0aW9uKGRvbmUpIHtcclxuXHRcdFx0XHR2YXIgeCA9IGNvbnRleHQubGluc3BhY2UoMSwgMjQsIDI0KS5yZXNoYXBlKFsyLCAzLCA0XSk7XHJcblx0XHRcdFx0eC5tYXgoMSkuZ2V0KGZ1bmN0aW9uKHkpIHtcclxuXHRcdFx0XHRcdGV4cGVjdCh5KS50by5kZWVwLmVxdWFsKFtbICA5LCAxMCwgMTEsIDEyXSxcclxuXHRcdFx0XHRcdCAgICAgICAgICAgICAgICAgICAgICAgICBbIDIxLCAyMiwgMjMsIDI0XV0pO1xyXG5cdFx0XHRcdFx0ZG9uZSgpO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9KTtcclxuXHRcdFx0aXQoXCJDb3JyZWN0IHJlc3VsdCBmb3IgMy1kaW1lbnNpb25hbCBhcnJheXMsIGF4aXMgMlwiLCBmdW5jdGlvbihkb25lKSB7XHJcblx0XHRcdFx0dmFyIHggPSBjb250ZXh0LmxpbnNwYWNlKDEsIDI0LCAyNCkucmVzaGFwZShbMiwgMywgNF0pO1xyXG5cdFx0XHRcdHgubWF4KDIpLmdldChmdW5jdGlvbih5KSB7XHJcblx0XHRcdFx0XHRleHBlY3QoeSkudG8uZGVlcC5lcXVhbChbWyAgNCwgIDgsIDEyXSxcclxuXHRcdFx0XHRcdCAgICAgICAgICAgICAgICAgICAgICAgICBbIDE2LCAyMCwgMjRdXSk7XHJcblx0XHRcdFx0XHRkb25lKCk7XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH0pO1xyXG5cdFx0fSk7XHJcblx0fSk7XHJcblx0ZGVzY3JpYmUoXCJzdW1cIiwgZnVuY3Rpb24oKSB7XHJcblx0XHRkZXNjcmliZShcIkFsbCBlbGVtZW50c1wiLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0aXQoXCJSZXR1cm5zIHplcm8tZGltZW5zaW9uYWwgYXJyYXkgb2YgbGVuZ3RoIG9uZVwiLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHR2YXIgeCA9IGNvbnRleHQuemVyb3MoWzIwLCAzMF0pO1xyXG5cdFx0XHRcdHZhciB5ID0geC5zdW0oKTtcclxuXHRcdFx0XHRleHBlY3QoeS5zaGFwZSkudG8uZGVlcC5lcXVhbChbXSk7XHJcblx0XHRcdFx0ZXhwZWN0KHkubGVuZ3RoKS50by5lcXVhbCgxKTtcclxuXHRcdFx0XHR5LmludmFsaWRhdGUoKTtcclxuXHRcdFx0fSk7XHJcblx0XHRcdGl0KFwiQ29tcHV0ZXMgdGhlIHN1bSBvZiBhbGwgZWxlbWVudHMgaW4gYW4gYXJyYXlcIiwgZnVuY3Rpb24oZG9uZSkge1xyXG5cdFx0XHRcdHZhciB4ID0gY29udGV4dC5saW5zcGFjZSgxLCAxMDAwMDAsIDEwMDAwMCkucmVzaGFwZShbMjAwLCA1MDBdKTtcclxuXHRcdFx0XHR4LnN1bSgpLmdldChmdW5jdGlvbih5KSB7XHJcblx0XHRcdFx0XHRleHBlY3QoeSkudG8uZXF1YWwoNTAwMDA1MDAwMCk7XHJcblx0XHRcdFx0XHRkb25lKCk7XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH0pO1xyXG5cdFx0fSk7XHJcblx0XHRkZXNjcmliZShcIkFsb25nIGFuIGF4aXNcIiwgZnVuY3Rpb24oKSB7XHJcblx0XHRcdGl0KFwiQ29ycmVjdCBzaGFwZSBmb3IgMy1kaW1lbnNpb25hbCBhcnJheXNcIiwgZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0dmFyIHggPSBjb250ZXh0LmxpbnNwYWNlKDEsIDI0LCAyNCkucmVzaGFwZShbMiwgMywgNF0pLmxvY2soKTtcclxuXHRcdFx0XHRleHBlY3QoeC5zdW0oMCkuc2hhcGUpLnRvLmRlZXAuZXF1YWwoWzMsIDRdKTtcclxuXHRcdFx0XHRleHBlY3QoeC5zdW0oMSkuc2hhcGUpLnRvLmRlZXAuZXF1YWwoWzIsIDRdKTtcclxuXHRcdFx0XHRleHBlY3QoeC5zdW0oMikuc2hhcGUpLnRvLmRlZXAuZXF1YWwoWzIsIDNdKTtcclxuXHRcdFx0XHR4LmludmFsaWRhdGUoKTtcclxuXHRcdFx0fSk7XHJcblx0XHRcdGl0KFwiQ29ycmVjdCByZXN1bHQgZm9yIDMtZGltZW5zaW9uYWwgYXJyYXlzLCBheGlzIDBcIiwgZnVuY3Rpb24oZG9uZSkge1xyXG5cdFx0XHRcdHZhciB4ID0gY29udGV4dC5saW5zcGFjZSgxLCAyNCwgMjQpLnJlc2hhcGUoWzIsIDMsIDRdKTtcclxuXHRcdFx0XHR4LnN1bSgwKS5nZXQoZnVuY3Rpb24oeSkge1xyXG5cdFx0XHRcdFx0ZXhwZWN0KHkpLnRvLmRlZXAuZXF1YWwoW1sgMTQsIDE2LCAxOCwgMjBdLFxyXG5cdFx0XHRcdFx0ICAgICAgICAgICAgICAgICAgICAgICAgIFsgMjIsIDI0LCAyNiwgMjhdLFxyXG5cdFx0XHRcdFx0ICAgICAgICAgICAgICAgICAgICAgICAgIFsgMzAsIDMyLCAzNCwgMzZdXSk7XHJcblx0XHRcdFx0XHRkb25lKCk7XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH0pO1xyXG5cdFx0XHRpdChcIkNvcnJlY3QgcmVzdWx0IGZvciAzLWRpbWVuc2lvbmFsIGFycmF5cywgYXhpcyAxXCIsIGZ1bmN0aW9uKGRvbmUpIHtcclxuXHRcdFx0XHR2YXIgeCA9IGNvbnRleHQubGluc3BhY2UoMSwgMjQsIDI0KS5yZXNoYXBlKFsyLCAzLCA0XSk7XHJcblx0XHRcdFx0eC5zdW0oMSkuZ2V0KGZ1bmN0aW9uKHkpIHtcclxuXHRcdFx0XHRcdGV4cGVjdCh5KS50by5kZWVwLmVxdWFsKFtbIDE1LCAgMTgsICAyMSwgIDI0XSxcclxuXHRcdFx0XHRcdCAgICAgICAgICAgICAgICAgICAgICAgICBbIDUxLCAgNTQsICA1NywgIDYwXV0pO1xyXG5cdFx0XHRcdFx0ZG9uZSgpO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9KTtcclxuXHRcdFx0aXQoXCJDb3JyZWN0IHJlc3VsdCBmb3IgMy1kaW1lbnNpb25hbCBhcnJheXMsIGF4aXMgMlwiLCBmdW5jdGlvbihkb25lKSB7XHJcblx0XHRcdFx0dmFyIHggPSBjb250ZXh0LmxpbnNwYWNlKDEsIDI0LCAyNCkucmVzaGFwZShbMiwgMywgNF0pO1xyXG5cdFx0XHRcdHguc3VtKDIpLmdldChmdW5jdGlvbih5KSB7XHJcblx0XHRcdFx0XHRleHBlY3QoeSkudG8uZGVlcC5lcXVhbChbWyAxMCwgIDI2LCAgNDJdLFxyXG5cdFx0XHRcdFx0ICAgICAgICAgICAgICAgICAgICAgICAgIFsgNTgsICA3NCwgIDkwXV0pO1xyXG5cdFx0XHRcdFx0ZG9uZSgpO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9KTtcclxuXHRcdH0pO1xyXG5cdH0pO1xyXG5cdGRlc2NyaWJlKFwiZG90XCIsIGZ1bmN0aW9uKCkge1xyXG5cdFx0aXQoXCJDb3JyZWN0IHNoYXBlIGZvciAyLWRpbWVuc2lvbmFsIGFycmF5c1wiLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0dmFyIHggPSBjb250ZXh0LmVtcHR5KFsyLCA1XSk7XHJcblx0XHRcdHZhciB5ID0gY29udGV4dC5lbXB0eShbNSwgMTFdKTtcclxuXHRcdFx0dmFyIHogPSBjb250ZXh0LmRvdCh4LCB5KTtcclxuXHRcdFx0ZXhwZWN0KHouc2hhcGUpLnRvLmRlZXAuZXF1YWwoWzIsIDExXSk7XHJcblx0XHRcdHouaW52YWxpZGF0ZSgpO1xyXG5cdFx0fSk7XHJcblx0XHRpdChcIkNvcnJlY3Qgc2hhcGUgZm9yIDMtZGltZW5zaW9uYWwgYXJyYXlzXCIsIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHR2YXIgeCA9IGNvbnRleHQuZW1wdHkoWzIsIDMsIDRdKTtcclxuXHRcdFx0dmFyIHkgPSBjb250ZXh0LmVtcHR5KFs3LCA0LCA4XSk7XHJcblx0XHRcdHZhciB6ID0gY29udGV4dC5kb3QoeCwgeSk7XHJcblx0XHRcdGV4cGVjdCh6LnNoYXBlKS50by5kZWVwLmVxdWFsKFsyLCAzLCA3LCA4XSk7XHJcblx0XHRcdHouaW52YWxpZGF0ZSgpO1xyXG5cdFx0fSk7XHJcblx0XHRpdChcIkNvcnJlY3Qgc2hhcGUgZm9yIDQtZGltZW5zaW9uYWwgYXJyYXlzXCIsIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHR2YXIgeCA9IGNvbnRleHQuZW1wdHkoWzIsIDMsIDQsIDVdKTtcclxuXHRcdFx0dmFyIHkgPSBjb250ZXh0LmVtcHR5KFs2LCA3LCA1LCA4XSk7XHJcblx0XHRcdHZhciB6ID0gY29udGV4dC5kb3QoeCwgeSk7XHJcblx0XHRcdGV4cGVjdCh6LnNoYXBlKS50by5kZWVwLmVxdWFsKFsyLCAzLCA0LCA2LCA3LCA4XSk7XHJcblx0XHRcdHouaW52YWxpZGF0ZSgpO1xyXG5cdFx0fSk7XHJcblx0XHRpdChcIkNvcnJlY3QgdmFsdWUgZm9yIDEtZGltZW5zaW9uYWwgYXJyYXlzXCIsIGZ1bmN0aW9uKGRvbmUpIHtcclxuXHRcdFx0dmFyIHggPSBjb250ZXh0LmFycmF5KFsyLCA1XSk7XHJcblx0XHRcdHZhciB5ID0gY29udGV4dC5hcnJheShbNSwgMTFdKTtcclxuXHRcdFx0Y29udGV4dC5kb3QoeCwgeSkuZ2V0KGZ1bmN0aW9uKHopIHtcclxuXHRcdFx0XHRleHBlY3QoeikudG8uZGVlcC5lcXVhbCg2NSk7XHJcblx0XHRcdFx0ZG9uZSgpO1xyXG5cdFx0XHR9KTtcclxuXHRcdH0pO1xyXG5cdFx0aXQoXCJDb3JyZWN0IHZhbHVlIGZvciAyLWRpbWVuc2lvbmFsIGFycmF5c1wiLCBmdW5jdGlvbihkb25lKSB7XHJcblx0XHRcdHZhciB4ID0gY29udGV4dC5hcnJheShbWzY0LCAgMiwgIDNdLFxyXG5cdFx0XHQgICAgICAgICAgICAgICAgICAgICAgIFs2MSwgNjAsICA2XV0pO1xyXG5cdFx0XHR2YXIgeSA9IGNvbnRleHQuYXJyYXkoW1s5MiwgOTksICAxLCAgOCwgMTVdLFxyXG5cdFx0XHQgICAgICAgICAgICAgICAgICAgICAgIFs2NywgNzQsIDUxLCA1OCwgNDBdLFxyXG5cdFx0XHQgICAgICAgICAgICAgICAgICAgICAgIFs5OCwgODAsICA3LCAxNCwgMTZdXSk7XHJcblx0XHRcdHZhciB6ID0gY29udGV4dC5kb3QoeCwgeSk7XHJcblx0XHRcdHouZ2V0KGZ1bmN0aW9uKHJlc3VsdCkge1xyXG5cdFx0XHRcdGV4cGVjdChyZXN1bHQpLnRvLmRlZXAuZXF1YWwoW1sgIDYzMTYsICA2NzI0LCAgMTg3LCAgNjcwLCAxMDg4XSxcclxuXHRcdFx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbIDEwMjIwLCAxMDk1OSwgMzE2MywgNDA1MiwgMzQxMV1dKTtcclxuXHRcdFx0XHRkb25lKCk7XHJcblx0XHRcdH0pO1xyXG5cdFx0fSk7XHJcblx0fSk7XHJcbn0pO1xyXG4iXX0=
